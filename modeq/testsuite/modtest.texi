\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename modtest.info
@settitle Modelica Testsuite, Version 1.0
@c %**end of header

@c translation to HTML:
@c   texi2html -split_node -number -menu modtest.texi

@setchapternewpage odd
@paragraphindent 0
@iftex
@parindent 0pt
@parskip = @medskipamount
@end iftex

@ifinfo
This is a collection of testcases for Modelica.

Copyright 1998 Modelica Design Group
@end ifinfo

@titlepage
@sp 10
@comment The title is printed in a large font.
@title{Modelica Testsuite}
@subtitle{Version 1.0}
@author{Modelica Design Group}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998 Modelica Design Group
@end titlepage

@node    Top, Conventions, (dir), (dir)
@comment node-name, next,          previous, up

@menu
* Conventions::                 
* Open Issues::                 
* Testcases::                   Collection of files with testcases.

* Change-Log::                  

 --- The Detailed Node Listing ---

Conventions

* General Conventions::         
* Classification::              
* Flat Modelica::               

Open Issues

* Types::                       
* Array syntax::                
* Functions::                   
* Equations in declarations vs. in equation sections::  
* Connections::                 
* Built-in types as connectors::  
* Integer expressions::         
* Redeclaration of parameter as variable::  
@end menu

@c ********************************************************************

@comment node-name,     next,          previous, up
@node     Conventions, Open Issues, Top, Top
@chapter Conventions

@menu
* General Conventions::         
* Classification::              
* Flat Modelica::               
@end menu

@node General Conventions, Classification, Conventions, Conventions
@section General Conventions

A Modelica testcase is an example that illustrates one ore more
semantical aspects of the Modelica language. A testcase is given in two
formulations: Modelica code and a flat representation that specifies the
semantics of the example. Furthermore a classification is used to allow
grouping of several testcases.

Each testcase is formulated in one Modelica file consisting of

@enumerate
@item a header explaining the testcase
@item a classification entry  (@xref{Classification}.)
@item the Modelica code
@item a flat representation (@xref{Flat Modelica}.)
@end enumerate

Everything except the Modelica code is given as comment in the file. No
flat representation is given for incorrect examples.

@node Classification, Flat Modelica, General Conventions, Conventions
@section Classification

Each testcase contains a classification entry of the form

@samp{keywords:}  @var{keyword}  [@samp{,} @var{keyword}]*
@samp{status:}    @var{correctness}

Following identifiers are used to classify the tested @var{aspect}(s):
@table @samp
@item algorithm
@item array
@item connect
@item connection
@item constant
@item declaration
@item equation
@item extends
@item modification
@item partial
@item protected
@item redeclare
@item scoping
@item shadow
@item type
@item types
@item typing
@item unknown
@end table

The @var{correctness} of a testcase is given as one of:
@table @samp
@item correct
The example is correct.
@item incorrect
The example is incorrect according to the formal Modelica semantics or
syntax.
@item erroneous
The example is formally correct, but it contains a modeling error that 
should be outlined.

<david: What does this really mean?>
@end table

@node Flat Modelica,  , Classification, Conventions
@section Flat Modelica

The aim of the flat representation is to clearly specify the semantics
of a testcase. This is done using a low level format. The format has the 
same basic syntax as Modelica.

The following restrictions apply:

@itemize @bullet

@item 
Flat models contain only variables (or arrays) of predefined
types. Predefined attributes, e.g. @code{start}, @code{unit},
@code{min}, @code{max}, ... are declared as separate variables directly
behind the variable they belong to.

@item 
A flat model has one declaration section, optionally followed by an
equation section, which is followed by zero or more algorithm
sections.

@item
The order of equations is undefined.

@item
The order of statements in each algorithm section is kept intact, but
the order the algorithm sections appear is undefined.

@item
No modifications are used, i.e. equation modifications made in the
Modelica source code are stated in the equation section of the flat
representation.  Redeclarations are taken care of while flattening the
model.

@item
No connect statements are used, i.e. the corresponding connection
equations are stated.

@item
Array expressions and equations as well as short notations for regular
equation structures (i.e. @code{for} loops) are not used. Such Modelica
notations are expanded and unrolled, respectively, in the flat
representation.

<The expansion may not be sensible or may even not
be possible in all cases. But it is necessary for the specification of
the semantics (e.g. what is the step size in @code{a:b:c}, does
@code{a*b} mean outer or inner vector product, ...)>
@end itemize

The following extensions are made:

@itemize @bullet

@item
Identifiers may contain dots @samp{.} (resulting from subcomponents in the
originating Modelica code) and tilde signs @samp{~} (see below).

@item
In order to be able to declare a local variable @var{var} of a function 
@var{funcname}, an identifier of the form 
@example
@var{funcname}@samp{~}@var{n}@samp{.}@var{var}
@end example
with @var{n} a number is introduced. In this way calls to internal
functions (that are defined in Modelica) can be expanded, e.g. to
express the semantics of assigning input and output variables.
The number @var{n} should be incremented for each call to the same
function from the same class.

<Peter: The expansion is not possible for recursive functions.>

Calls to predefined and external functions remain in the flat
representation as they are in the Modelica code.

@item
Automatic type conversions defined in the Modelica semantics, e.g. from 
an @code{Integer} @code{i} to @code{Real}, are stated using the target
type name as conversion operator, i.e. @code{Real(i)}.

@item
Almost no overloading of operators occus in the flat Modelica.  If a
model contains an array multiplied by a scalar, the flat model does not
use the multiplication sign, but an operator that is specialized for
that particular operation.

The normal integer and real arithmetic operators are still overloaded,
but they should not, really.

@item
Due to the extensions a flat model representation is not valid
Modelica.  Therefore, the class definition in the flat code is declared
as @code{fclass} to differentiate it from Modelica's @code{class}.

@end itemize

@c ********************************************************************

@comment node-name,     next,          previous, up
@node    Open Issues, Testcases, Conventions, Top
@chapter Open Issues

The issues brought up here are not yet clarified in the current
Modelica language specification (Version 1c of the Modelica report).

@menu
* Types::                       
* Array syntax::                
* Functions::                   
* Equations in declarations vs. in equation sections::  
* Connections::                 
* Built-in types as connectors::  
* Integer expressions::         
* Redeclaration of parameter as variable::  
@end menu

@c --------------------------------------------------------- 
@node Types, Array syntax, Open Issues, Open Issues
@section Types

Modelica needs a well-defined type system, with a clear notion of what a
type actually is.

@subsection Functions

Functions have a type, which looks something like @code{Real => Real}
for a function from reals to reals.

This goes for the builtin functions too.  For instance, the function
@code{size} is not well-defined.  What is the type of its first
argument?

@subsection Multidimensional arrays

One very important issue is whether a multidimensional matrix is
equivalent to an array of arrays.  This decision affects many parts of
the semantic specification and needs to be thought about thoroughly.

Let's see what happens if we make it equivalent:

@itemize @bullet

@item
Partial indexing becomes very natural.  If the variable @code{x} is
defined as a n*m matrix, it can also be regarded as an array of size n
of arrays of size m.

@example
Real x[2,2];
...
x[1] = [ 1.0, 2.0 ];
@end example

This can be solved by writing @code{x[1,:]} even if we don't equate the
types.

@ref{ArrayModification5}

@item
The internal representation of both types must be the same.  This might
be problematic.  Say that you store the size of an array together with
the array.  If the types are not the same, you only have to store the
multi-dimensional size once for the whole multidimensional array.  It
they are the same, then each secondary array needs to be tagged with its
size, which would introduce irregularities in the representation.

@end itemize

Some random notes:

@itemize @bullet

@item
Defining arrays of arrays is already possible by derived type
declarations

@example
type T1 = Real[3];
type T2 = T1[2];
@end example

Does this mean that @code{T2} is the same as @code{Real[2,3]}?  If not,
this is the only way to describe this type, as @code{Real[2][3]} is not
a valid type.

@xref{Array4}

@end itemize

@subsection Array types

What is an array type?  How the concepts of subtypes and equivalent
types apply to arrays?  What about array types where one or more of the
sizes are unknown?

@subsection Determining types of expressions

One desired property of the type system would be if the type of
expressions can be determined without regard for the context it appears
in.  This is the case for C and C++, for instance.

This seems to be feasible.  At least as long as no strange array
constructors are introduced.  If, say, a "function" @code{ones()} which
created an array of arbitrary size to match whatever expresseion is
appeared together with was added to the language, this would cause
problems for the type system.

@subsection Overloading and automatic type conversions

@c --------------------------------------------------------- 
@node Array syntax, Functions, Types, Open Issues
@section Array syntax

@subsection Declaring arrays of arrays

If it is decided that arrays of arrays are not the same as
multidimensional arrays, should it not be possible to declare a variable
to be an array of arrays in a simple way?

@xref{Array4}

@subsection Array indexing operator

Should the indexing operator @code{[]} be a real postfix operator on
arbitrary array expressions?  Currently, the indexing is part of the
@code{component_reference} grammar rule, which means that you can only
index variables.

@example
x = cross(A,B)[2]
@end example

@c --------------------------------------------------------- 
@node Functions, Equations in declarations vs. in equation sections, Array syntax, Open Issues
@section Functions

Saying that functions are classes is simply silly and
counter-productive.

@c --------------------------------------------------------- 
@node Equations in declarations vs. in equation sections, Connections, Functions, Open Issues
@section Equations in declarations vs. in equation sections

@subsection Model modification
What are ``named'' equations that can be replaced via
modifications?  (only equations in declarations or all equations with a
single name on the left hand side) 
@* (@xref{Overwriting1}, and @ref{Overwriting2}.)

@subsection Scoping
If only equations in declarations can be modified, what more differences 
exist to equations in equation sections? For example: is the declared
variable already known in its declaration equation?
@* (@xref{ScopeDeclaration1}, and @ref{ScopeDeclaration2}, as well as
@ref{Lookup5}, and @ref{Lookup6}.) 

If @code{ScopeDeclaration1} was correct, then the following declaration
should also be correct:

@example
constant Real a[3] = [a[2]/a[3]; 2*a[3]; 3];
@end example

@subsection Typing

A surprising but correct example that shows a consequence of treating
declaration equations like ordinary equations is given in
@ref{Real2Integer1}.

@c --------------------------------------------------------- 
@node Connections, Built-in types as connectors, Equations in declarations vs. in equation sections, Open Issues
@section Connections

@subsection Parameters and constants in connectors
Should connection equations be generated for parameters and
constants? This issue has been discussed at the 10th design meeting. But 
no decision was made there.
@* (@xref{ConnectTypes}.)

<Ruediger: If no connection equations are generated, should then
@code{assert} statements be generated for two connected constants 
(or parameters) @code{c1} and @code{c2}, i.e. @code{assert(c1 == c1)},
so that no model information is lost in a flat representation?>

@c --------------------------------------------------------- 
@node Built-in types as connectors, Integer expressions, Connections, Open Issues
@section Built-in types as connectors

Are variables of predefined types, e.g. @code{Real}, valid
connectors? This is not specified in the Modelica 1c report.
It is assumed to be true here.
@* (@xref{Units1}, and @ref{Units2}.)

In the Modelica 1c report, section 4.6 ``Matrices'', subsection ``Block
Diagrams'', vectors of type @code{Real} are used as inputs and
outputs. But no example is given in the discussion about connection of
inputs and outputs there.

@c --------------------------------------------------------- 
@node Integer expressions, Redeclaration of parameter as variable, Built-in types as connectors, Open Issues
@section Integer expressions

Version 1c of the Modelica report, appendix B.9, introduces built-in
functions for doing things like integer division. Most of the
functions have return type @code{Real}. But should not this be
allowed:  

@example
model Foo
  Real a[10];
  Real b[20];
  Integer i;
equation
  for i in 2:20 loop
    a[div(i,2)] = b[i];
  end for;
end Foo;
@end example

There are two problems with the current specification:

@enumerate
@item 
Possibly not only the built-in function @code{size}, but also
@code{div}, @code{ceil}, @code{floor}, and @code{ndims} should have
return type @code{Integer}. If used in @code{Real} expressions, then
the result should be converted from @code{Integer} to @code{Real}
(as for any integer used in a real expression). 
@* (@xref{Integer2Real}.)

But this solution has another problem, which is more an
implementation problem. The @code{Integer} type is often
implemented as a limited type of typically 32 bits, which would mean 
that if you call ceiling(large_real_numer) you would overflow the
integer type. So there is probably the need to introduce functions
that conceptually do the same thing, but works on reals instead. 

@item 
The use of the mentioned built-in functions should not only be
allowed in @code{Boolean} equations and expressions, but also in
@code{Integer} equations and expressions (e.g. index expressions).
@* (See the example above)
@end enumerate

@page
@c --------------------------------------------------------- 
@node Redeclaration of parameter as variable,  , Integer expressions, Open Issues
@section Redeclaration of parameter as variable

Version 1c of the Modelica report, appendix B2, section ``Redeclaration'',
says that variability constraints may only become stronger in
redeclarations.
@* (@xref{DisturbedResistance2}.)

It should be noted that, using inheritance, one can formulate examples
that break the rule. Should this be valid?  @*
(@xref{DisturbedResistance3}, @ref{DisturbedResistance4}.)

@c ********************************************************************

@node Testcases, Change-Log, Open Issues, Top
@appendix Testcases

@c
@c generated by Makefile
@c

@include cases.texi

@c
@c end Makefile
@c

@c ======================================================================
@node Change-Log,  , Testcases, Top
@appendix Change-Log

@appendixsec Version 0.9.1 to 1.0

The following changes result from the discussion at the 12th Modelica
design meeting in Manchester. It is referred to the minutes of the
12th Modelica design meeting.

@enumerate
@item
New testcases, @ref{Overwriting3}, and @ref{Modification9}, according to
N.1 and N.2, respectively, given in the minutes.
@item
@xref{ScopeDeclaration1}, @ref{ScopeDeclaration2}, @ref{Lookup5}: new
header.
@item
@xref{Faculty1}: changed correctness to @samp{incorrect}.
@item
New testcase, @ref{ReplaceFunction}, according to N.3 of section 2.2 "Is
Modelica a strict define­before­use language?" of the minutes. 
@item
@xref{DeclareConstant1}, @ref{DeclareConstant3}: new header.
@item
@xref{ModifyConstant2}: changed correctness to @samp{correct}.
@item
New testcases, @ref{ModifyConstant5}, @ref{ModifyConstant6}, to check
modification of final constants.
@item
@xref{ConnectTypes}: introduced connection equations for parameters and
constants in the flat representation.
@item
@xref{ConnectHierarchical2}: changed correctness to @samp{correct}.
@item
@xref{ConnectFlowEffort}: simplified; 
added new testcase, @ref{RedeclareFlowEffort}. 
@item
@xref{ConstructParameters}: added keywords @samp{input} and
@samp{output} to declarations in the flat model representation.

@c @item 
@c @xref{Overwriting1}: use term @samp{replace} instead of @samp{overwrite}.
@item
@xref{Real2Integer1}: changed correctness to @samp{erroneous} and corrected
flat model representation.
@c @item
@c @xref{XPowers3}: The integer 'n' must be declared as constant.
@end enumerate

With these modifications most unclear issues of version 0.9.1 are
resolved. (@xref{Open Issues}, for remaining questions.)

@appendixsec Version 0.9 to 0.9.1

@enumerate
@item 
@xref{ConditionalArrayExpression1}: corrected classification (&array).

@ignore
@item
@xref{Connections}, @ref{ConnectTypes}: extended discussion in
subsection ``Parameters and constants in connectors''
(generation of assertions?).
@item
@xref{Connections}: new subsection ``Connections and Modifications''.
@item
@xref{Connections}: new subsection ``Directed connections''.
@end ignore

@end enumerate

@contents
@bye
