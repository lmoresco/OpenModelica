\input texinfo   @c -*-texinfo-*-
@c $Id$
@c %**start of header
@setfilename modtest.info
@settitle Modelica Testsuite
@c %**end of header

@c translation to HTML:
@c   texi2html -split_node -number -menu modtest.texi

@setchapternewpage odd
@paragraphindent 0
@iftex
@afourpaper
@parindent 0pt
@parskip = @medskipamount
@end iftex

@include VERSION.texi
@set UPDATED 13 July 1998
@set UPDATED-MONTH July 1998

@ifinfo
This is version @value{VERSION},
last updated @value{UPDATED},
of @cite{the Modelica testsuite},
version @value{VERSION}.

Copyright @copyright{} 1998 Modelica Design Group
@end ifinfo

@titlepage
@sp 10
@comment The title is printed in a large font.
@title Modelica Testsuite
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED-MONTH}
@author{Modelica Design Group}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998 Modelica Design Group
@end titlepage

@node    Top, Conventions, (dir), (dir)
@comment node-name, next,          previous, up

This is version @value{VERSION} of @cite{the Modelica testsuite}.

This document is made to provide a collection of issues that need to be
resolved in the Modelica design process.  It also contains the full set
of Modelica test cases currently defined.

A Modelica test case is an example Modelica model that illustrates one
ore more semantical aspects of the Modelica language.  It serves several
purposes, both to provide a testbed for new implementations and to make
unresolved design issues clearer.  For testing a new implementation of
the language, the set of test cases needs to be very large, as the
number of semantic rules is large, and there are many ways in which they
interact.  Only some of these test cases are interesting for the design
process, but it seems useful to keep it as one set of test cases, and
this discussions in this document only references a selected subset of
the test cases.

@menu
* Conventions::                 
* Open Issues::                 
* Closed Issues::               
* Test Cases::                  Collection of files with test cases.

* Change-Log::                  

 --- The Detailed Node Listing ---

Conventions

* General Conventions::         
* Classification::              
* Flat Modelica::               

Open Issues

* Types::                       
* Overloading and automatic type conversions::  
* Array syntax::                
* Parameters::                  
* Expression Properties::       
* Functions::                   
* Scoping::                     
* Declarations::                
* Connections::                 
* Built-in types as connectors::  
* Integer expressions::         
* Redeclaration of parameter as variable::  
* Equations::                   
@end menu

@c ********************************************************************

@comment node-name,     next,          previous, up
@node     Conventions, Open Issues, Top, Top
@chapter Conventions

This chapter lists the conventions used in the text.

@menu
* General Conventions::         
* Classification::              
* Flat Modelica::               
@end menu

@node General Conventions, Classification, Conventions, Conventions
@section General Conventions

A test case is given in two formulations, first the Modelica code, and
second a ``flat'' representation that specifies the semantics of the
example.  Furthermore, each test case is classifies according to a
couple of criteria.

Each test case is formulated in one Modelica file, consisting of

@enumerate
@item
A header containing some explanatory text to describe what it tests.
@item
A classification entry. (@xref{Classification}.)
@item
The Modelica code.
@item
A flat representation. (@xref{Flat Modelica}.)
@end enumerate

Everything except the Modelica code is given as comment in the file. No
flat representation is given for incorrect examples.

@node Classification, Flat Modelica, General Conventions, Conventions
@section Classification

Each test case contains a classification entry of the form

@samp{keywords:}  @var{keyword}  [@samp{,} @var{keyword}]* @*
@samp{status:}    @var{correctness}

The @var{keyword} clauses are used to tag each test with a number of
keywords to indicate what aspect of the semantic specification it tests.

The following list contains all the keywords used.
@var{aspect}(s):
@table @samp
@item algorithm
@item array
@item connect
@item constant
@item declaration
@item equation
@item extends
@item function
@item modification
@item partial
@item protected
@item redeclare
@item scoping
@item shadow
@item type
@item unknown
@end table

The @var{correctness} of a test case is given as one of:
@table @samp
@item correct
The example is correct.
@item incorrect
The example is incorrect according to the formal Modelica semantics or
syntax.
@item erroneous
The example is formally correct, but it contains a modeling error that 
should be outlined.

<david: What does this really mean and why is it needed here?>
@end table

@node Flat Modelica,  , Classification, Conventions
@section Flat Modelica

The aim of the flat representation is to clearly specify the semantics
of a test case. This is done using a low-level format. The format has the 
same basic syntax as Modelica.

The following restrictions apply:

@itemize @bullet

@item 
Flat models contain only components of predefined types. Predefined
attributes, e.g. @code{start}, @code{unit}, @code{min}, @code{max},
@dots{} are declared as separate variables.

@item 
A flat model has one declaration section, optionally followed by an
equation section, which is followed by zero or more algorithm
sections.

@item
The order of equations is undefined.

@item
The order of statements in each algorithm section is kept intact, but
the order in which the algorithm sections appear is undefined.

@item
No modifications are used, i.e. equation modifications made in the
Modelica source code are stated in the equation section of the flat
representation.  Redeclarations are taken care of while flattening the
model.

@item
No connect statements are used, i.e. the corresponding connection
equations are stated.

@item
For loops are not used in equations.  They are unrolled in the flat
representation.

@end itemize

The following extensions are made:

@itemize @bullet

@item
All array components are declared separately.  If the Modelica model
contains the declaration

@example
Real x[2,3];
@end example

the flat model will contain the following declarations:

@example
Real x[1,1];
Real x[1,2];
Real x[1,3];
Real x[2,1];
Real x[2,2];
Real x[2,3];
@end example

This means that the brackets in declaration do not denote array size, as
they do in normal Modelica.

<david: This is a consequence of how the semantic specification looks at
the components.  Using the simple @samp{x[2,3]} could be done instead,
as it is shorter and introduces no ambuguities.>

@item
Identifiers may contain dots @samp{.} (resulting from subcomponents in the
originating Modelica code) and tilde signs @samp{~} (see below).
Identifiers may also contain subscripts, as in @samp{x[1]}.  This is a
consequence of the fact that all array components are declared separately.

@item
In order to be able to declare a local variable @var{var} of a function 
@var{funcname}, an identifier of the form 
@example
@var{funcname}@samp{~}@var{n}@samp{.}@var{var}
@end example
with @var{n} a number is introduced. In this way calls to internal
functions (that are defined in Modelica) can be expanded, e.g. to
express the semantics of assigning input and output variables.
The number @var{n} should be incremented for each call to the same
function from the same class.

<Peter: The expansion is not possible for recursive functions.>

<david: This is still experimental. It might be removed.>

Calls to predefined and external functions remain in the flat
representation as they are in the Modelica code.

@item
Automatic type conversions defined in the Modelica semantics, e.g. from 
an @code{Integer} @code{i} to @code{Real}, are stated using the target
type name as conversion operator, i.e. @code{Real(i)}.

@item
A new postfix subscripting operator is introduced.  In the flat model,
it is necessary to be able to subscript expression, so the syntax
@samp{expression[x]} is allowed.  This is currently not allowed in
Modelica.

@item
Almost no overloading of operators occus in the flat Modelica.  If a
model contains an array multiplied by a scalar, the flat model does not
use the multiplication sign, but an operator that is specialized for
that particular operation.

The normal integer and real arithmetic operators are still overloaded,
but they should not, really.

@item
Due to the extensions a flat model representation is not valid
Modelica.  Therefore, the class definition in the flat code is declared
as @code{fclass} to differentiate it from Modelica's @code{class}.

@end itemize

The flat modelica grammar is probably not even context-free.

@c ********************************************************************

@comment node-name,     next,          previous, up
@node    Open Issues, Closed Issues, Conventions, Top
@chapter Open Issues

The issues brought up here are not yet clarified in the current
Modelica language specification (Version 1c of the Modelica report).

@menu
* Types::                       
* Overloading and automatic type conversions::  
* Array syntax::                
* Parameters::                  
* Expression Properties::       
* Functions::                   
* Scoping::                     
* Declarations::                
* Connections::                 
* Built-in types as connectors::  
* Integer expressions::         
* Redeclaration of parameter as variable::  
* Equations::                   
@end menu

@c --------------------------------------------------------- 
@node Types, Overloading and automatic type conversions, Open Issues, Open Issues
@section Types

Modelica needs a well-defined type system, with a clear notion of what a
type actually is.

@subsection Functions

Functions have a type, which looks something like @code{Real => Real}
for a function from reals to reals.  This goes for the builtin functions
too.

This causes a few problems.  For instance, the function @code{size} is
not well-defined.  What is the type of its first argument?  There is no
type called ``Array''.

@subsection Multidimensional arrays

One very important issue is whether a multidimensional matrix is
equivalent to an array of arrays.  This decision affects many parts of
the semantic specification and needs to be thought about thoroughly.

<david: Thanks to Henrik Nilsson for his thoughts on this subject>

Let's see what happens if we make it equivalent:

@itemize @bullet

@item
Partial indexing becomes very natural.  If the variable @code{x} is
defined as a n*m matrix, it can also be regarded as an array of size n
of arrays of size m.

@example
Real x[2,2];
@dots{}
x[1] = [ 1.0, 2.0 ];
@end example

This can be solved by writing @code{x[1,:]} even if we don't equate the
types. (@xref{ArrayModification5})

@item
If @code{A} is a m*n matrix, then @code{A[x,y] = A[x][y]}, but
@code{A[:,y] /= A[:][y]}.

This might not be a disaster, but it might be a little surprising on
first encouter.

@item
From the report:

@example
type Point = Real[2];
@dots{}
Point points[:];
@end example

This will mean that @code{points} is a matrix, i.e. @code{ndims(points)
= 2}.  Both @code{points[17,2]} and @code{[17][2]} denote the same thing
(provided that the Modelica syntax is extended @xref{Array syntax}).

@item
We get a simple and useful means to construct multidimensional arrays.
For example, @code{[[1,2],[3,4]]} is a 2*2 matrix.  This syntax might be
introduced even if arrays of arrays is not the same as a
multidimensional array, but it might bring nast consequences. In the
example below, @code{C} and @code{D} would become different.

@example
A = [1,2]
B = [3,4]
C = [A,B]
D = [[1,2],[3,4]]
@end example

A related issue is the splicing of vectors in the syntax. @xref{Array
syntax}.

@item
The internal representation of both types must be the same.  This might
be problematic.  Say that you store the size of an array together with
the array.  If the types are not the same, you only have to store the
multi-dimensional size once for the whole multidimensional array.  It
they are the same, then each secondary array needs to be tagged with its
size, which would introduce irregularities in the representation.

@end itemize

Some random notes:

@itemize @bullet

@item
Defining arrays of arrays is already possible by derived type
declarations

@example
type T1 = Real[3];
type T2 = T1[2];
@end example

Does this mean that @code{T2} is the same as @code{Real[2,3]}?  If not,
this is the only way to describe this type, as @code{Real[2][3]} is not
a valid type.

@xref{Array4}

@item
One could use a @code{reshape} function to construct multidimensional
arrays, similar to Fortran 90.

@end itemize

@subsection Array types

What is an array type?  How do the concepts of subtypes and equivalent
types apply to arrays?  What about array types where one or more of the
sizes are unknown?

@subsection Determining types of expressions

One desired property of the type system would be if the type of
expressions can be determined without regard for the context it appears
in.  This is the case for C and C++, for instance.

This seems to be feasible.  At least as long as no strange array
constructors are introduced.  If, say, a ``function'' @code{ones()}
which created an array of arbitrary size to match whatever expresseion
is appeared together with was added to the language, this would cause
problems for the type system.

@c --------------------------------------------------------- 
@node Overloading and automatic type conversions, Array syntax, Types, Open Issues
@section Overloading and automatic type conversions

Many of the operators in Modelica are overloaded on the types of its
arguments.  The plus operator is e.g. both an integer addition operator
and a real addition operator.  These two operations are similar, but not
the same.  It also doubles as a string concatenation operator, which is
a completely different operation, with other properties (it is not
associative, for instance).  The overloading of the asterisk operator is
even more extensive with both scalar and matrix multiplication.

@subsection Defining the operators

All operators need to be defined in terms of what they operate on.  A
short table of types and operations should be sufficient.

@subsection Vectors and scalar functions

It also seems to be the view of most people that functions defined on
scalars should be possible to apply to arrays (vectors at least), which
would apply the function element-wise.  Exactly how does this work?

On idea is to say that if @var{f} is defined as a function which takes
an argument of type @var{a} and returns a value of type @var{b}, then
@var{f} may be applied to a vector of @var{a}, returning a vector of
@var{b}.

Should this be generalized to n-dimensional arrays?

Should this be valid for any types @var{a} and @var{b}?

Another idea is to skip this idea, and introduce a function (or operator
of some sort) @code{elementwise} with takes an array and a function.
This is not easy to describe, as functions are not first-class objects
in Modelica.

@subsection Type conversions

Then there is the problem of type conversions.  There hasn't been much
discussion about this topic, but I believe it was brought up in
Manchester.  <david: The Manchester minutes mention an explicit
@code{integer} type cast operator, but that seems so strange that I'll
ignore it for now.>

Having implicit type casts is a convenience to the programmer. Take the
following model as an example:

@example
model Circuit
  parameter Integer N, Integer Rtot;
  Resistor r1(R = 5);
  Resistor rr[N](R = Rtot/N);
@dots{}
end Circuit;
@end example

In this example, implicit promotion (casts) of integer expressions to
real expressions need to occur in three places for the model to be
valid.

First, the @code{R} parameter to @code{Resistor} is a @code{Real}
parameter, but to make it equal the integer expression @code{5}, the
expression has to be converted into a real expression.

Second, the division operator is only defined for reals, which means
that both the sub-expressions @code{Rtot} and @code{N} have to be promoted
to reals before the division takes place.

If automatic type promotions didn't exist, the model would have to be
written as:

@example
model Circuit
  parameter Integer N, Integer Rtot;
  Resistor r1(R = 5.0);
  Resistor rr[N](R = Real(Rtot)/Real(N));
@dots{}
end Circuit;
@end example

This, in my (David's) opinion, is unnecessarly cluttered.

@c --------------------------------------------------------- 
@node Array syntax, Parameters, Overloading and automatic type conversions, Open Issues
@section Array syntax

@subsection Declaring arrays of arrays

If it is decided that arrays of arrays are not the same as
multidimensional arrays, should it not be possible to declare a variable
to be an array of arrays in a simple way?

@xref{Array4}

@subsection Array indexing operator

Should the indexing operator @code{[]} be a real postfix operator on
arbitrary array expressions?  Currently, the indexing is part of the
@code{component_reference} grammar rule, which means that you can only
index variables.


The following is currently not allowed:

@example
x = cross(A,B)[2]
@end example

@subsection Array splicing

What does the expression @code{[[1,2],[3,4]]} denote? Is it the vector
@code{[1,2,3,4]} or a 2*2 matrix?

The question is whether the vector splicing syntas (from MATLAB, I
believe) should be used.  A little more realistic example might be the
following:

@example
block Foo
  input Real x[:];
protected
  Real y[sizeof(x)+3] = [0,1,2,x];
end Foo;
@end example

In my (David's) opinion, this introduces unnecessary irregularities in
the syntax, and makes it difficult to do other things, like writing
@var{n}-dimensional array constants.  If I see the expression
@code{[a,b,c,d]}, I want to be able to know that it is a vector
(one-dimensional array or whatever) of four element.
                                      
The previous example can be solved in other ways, either by an explicit
vector concatenation function, or by using several equations, as in the
following example:

@example
block Foo
  input Real x[:];
protected
  Real y[size(x,1)+3];
equation
  y[1:3] = [0,1,2];
  y[4:size(x,1)+3] = x;
end Foo;
@end example

@c --------------------------------------------------------- 
@node Parameters, Expression Properties, Array syntax, Open Issues
@section Parameters

Saying that parameter setting should be left until after compile-time
might not be so easy.

@subsection Compile-time? What compile-time?

The term ``compile-time'' is used several times in the discussion about
Modelica, but it is never clearly defined what is meant by this.

The following might be a starting-point for the discussion for what
compile-time means:

@itemize @bullet

@item
Equations can be generated from the structured model.

@item
Parameter values are unknown.

@item
Constant values are known.

@end itemize

@subsection Array sizes

One of the obvious problems is parameterized array sizes.  If a vector
is declared as @code{Real x[N]}, where @code{N} is a parameter, then the
equations in the model might not be possible to determine.  As an
example, the following @code{for} loop (@xref{EquationFor3}) can not be
unrolled.

@example
class EquationFor3
  parameter Integer N = 4;
  Real a[N];
equation
  a[1] = 1.0;
  for i in 1:N-1 loop
    a[i+1] = a[i] + 1.0;
  end for;
end EquationFor3;
@end example

This might be taken as a quality-of-implementation issue.  If the
parameter is reset, some systems will need to recompile the model, and
some won't.

@subsection Parameterized connections

A more serious problem occurs when @code{connect} clauses are
involved.  In some cases the connections can not be used to generate
equations until the parameters are set. @xref{Connect7} and
@ref{Connect8}.

The only way to prevent recompilation in this case seems to be to
prohibit constructions like this.

@subsection Structural parameters

The semantic specification gets around all of this by describing the
semantics when the parameters are set in stone, but there are other
observations that can be made.

If a full set of equations is generated from the model, then some
parameters have to be set, but not all.  Many parameters (restistances
etc.) can still be reset.  This means that two different kinds of
parameters are identifiable, one that may affect the number and
structure of the equations, and one that don't.  Let's call the first
type @dfn{structural parameters} and the second kind something else
(what about @dfn{value parameters}?).

Not that I know exactly what to do with this classification, but it
might be useful.

@c --------------------------------------------------------- 
@node Expression Properties, Functions, Parameters, Open Issues
@section Expression Properties

In several places in the discussions about what may or may not appear in
expressions there are restrictions applied in a somewhat ad-hoc manner.
This should be cleared up and formalized.

Each expression has a number of properties that can be derivd by
analyzing its subexpressions.

@itemize @bullet

@item
A type. For each kind of expression (addition, logical-and etc.) it is
well-defined what the type of the expression is.  The only exception are
overloaded operators, but that problem is another issue (@xref{Overloading and automatic type conversions}.)

@item
A ``constancy'' property, which describes whether the expression is a
constant expression or not.  This can be stratified into the levels
constant / parameter / discrete / variable, just as components can be
declared constant etc.

@item
A ``differentiability'' property.  I'm not so sure about what this is,
but it seems to be needed.  For instance, the report states that the
@code{div()} function is not differentiable.

How is this property determined for function calls in the general case?

@end itemize

When these properties are defined, they can be used to define what may
appear where.  Some examples:

@itemize @bullet

@item
An array index must have type @code{Integer}.

@item
An array index in a @code{connect} statement must be a constant
expression of type @code{Integer}.

@item
Expressions in equations must be differentiable.

@end itemize

@c --------------------------------------------------------- 
@node Functions, Scoping, Expression Properties, Open Issues
@section Functions

Saying that functions are classes is simply silly and
counter-productive.

<david: I haven't had time to elaborate more on this>

@c --------------------------------------------------------- 
@node Scoping, Declarations, Functions, Open Issues
@section Scoping

@subsection Recursive declarations

Is the declared variable already known in its declaration equation?

@xref{ScopeDeclaration1}, and @ref{ScopeDeclaration2}, as well as
@ref{Lookup5}, and @ref{Lookup6}.

If @code{ScopeDeclaration1} was correct, then the following declaration
should also be correct:

@example
constant Real a[3] = [a[2]/a[3]; 2*a[3]; 3];
@end example

<david: The Manchester meeting decided that the declared thing does not
exist in the scope until it is completely defined.>

@c --------------------------------------------------------- 
@node Declarations, Connections, Scoping, Open Issues
@section Declarations

@subsection Model modification
What are the ``named'' equations that can be replaced via
modifications?  Only equations in declarations or all equations with a
single name on the left hand side?

<david: The Manchester meeting seems to have decided that ony equations
in the declaration section can be replaced by modifications.  I seem to
recall that Hilding or someone else thought that the other equations
should be replaeable too.>

(@xref{Overwriting1}, and @ref{Overwriting2}.)

@subsection Typing

A surprising but correct example that shows a consequence of treating
declaration equations like ordinary equations is given in
@ref{Real2Integer1}.

@xref{Overloading and automatic type conversions}

@subsection Array modifications

The type system makes the test case @ref{ArrayModification7} illegal.
This seems natural too me, but I just want to make sure that nobody
complains about this.


@c --------------------------------------------------------- 
@node Connections, Built-in types as connectors, Declarations, Open Issues
@section Connections

@subsection Parameters and constants in connectors
Should connection equations be generated for parameters and
constants? This issue has been discussed at the 10th design meeting. But 
no decision was made there.
@* (@xref{ConnectTypes}.)

<david: The Manchester meeting decided that they should.>

<Ruediger: If no connection equations are generated, should then
@code{assert} statements be generated for two connected constants 
(or parameters) @code{c1} and @code{c2}, i.e. @code{assert(c1 == c1)},
so that no model information is lost in a flat representation?>

@subsection Integers in connectors

Are integers allowed in connectors?

@xref{Connect4}

@subsection Booleans in connectors

Are booleans allowed in connectors?

@xref{Connect5}

@subsection Strings in connectors

Are strings allowed in connectors?

@xref{Connect6}

@subsection Constant connectors

Is it legal to declare a connector as @code{constant}?

@xref{ConnectConst1}

@c --------------------------------------------------------- 
@node Built-in types as connectors, Integer expressions, Connections, Open Issues
@section Built-in types as connectors

Are variables of predefined types, e.g. @code{Real}, valid
connectors? This is not specified in the Modelica 1c report.
It is assumed to be true here.
@* (@xref{Units1}, and @ref{Units2}.)

In the Modelica 1c report, section 4.6 ``Matrices'', subsection ``Block
Diagrams'', vectors of type @code{Real} are used as inputs and
outputs. But no example is given in the discussion about connection of
inputs and outputs there.

@c --------------------------------------------------------- 
@node Integer expressions, Redeclaration of parameter as variable, Built-in types as connectors, Open Issues
@section Integer expressions

Version 1c of the Modelica report, appendix B.9, introduces built-in
functions for doing things like integer division. Most of the functions
have return type @code{Real}. But should not the following be allowed?

@example
model Foo
  Real a[10];
  Real b[20];
  Integer i;
equation
  for i in 2:20 loop
    a[div(i,2)] = b[i];
  end for;
end Foo;
@end example

There are two problems with the current specification:

@enumerate
@item 
Possibly not only the built-in function @code{size}, but also
@code{div}, @code{ceil}, @code{floor}, and @code{ndims} should have
return type @code{Integer}. If used in @code{Real} expressions, then
the result should be converted from @code{Integer} to @code{Real}
(as for any integer used in a real expression). 

(@xref{Integer2Real}.)

But this solution has another problem, which is more an implementation
problem. The @code{Integer} type is often implemented as a limited type
of typically 32 bits, which would mean that if you call
ceiling(large_real_numer) you would overflow the integer type.

One solution taken by some other languages (like C) is to introduce a
double set of functions that conceptually do the same thing. On set that
returns integers, and one that returns reals.  A ``smaller'' solution
would be to only introduce an integer version of the @code{floor}
function, and write @code{int_floor(div(n,m))}, but then the gain would
be very small.

@item 
The use of the mentioned built-in functions should not only be allowed
in @code{Boolean} equations and expressions, but also in @code{Integer}
equations and expressions (e.g. index expressions). (See the example
above and @ref{Expression Properties})
@end enumerate

<david: The Manchester minutes say ``Require same type, introduce type
cast: operation integer(div(i,2))'', which seems to be to be a strange
thing to say. It doesn't really answer the question.>

@c --------------------------------------------------------- 
@node Redeclaration of parameter as variable, Equations, Integer expressions, Open Issues
@section Redeclaration of parameter as variable

Version 1c of the Modelica report, appendix B2, section ``Redeclaration'',
says that variability constraints may only become stronger in
redeclarations. (@xref{DisturbedResistance2}.)

It should be noted that, using inheritance, one can formulate examples
that break the rule. Should this be valid? (@xref{DisturbedResistance3},
@ref{DisturbedResistance4}.)

@subsection Resolutions from the Manchester meeting

@itemize @bullet
@item
Type prefix is not part of type equivalence. 
@item
Multiple inheritance should be forced to be equivalent. 
@item
Problem with correctness of equations, for example 
@example
C*der(v) = i 
der(C*v) = i 
@end example
@item
Open issue! Should add constraints to extends, similar to
redeclare. Should require that type-prefix is identical for extends.
@end itemize

@c --------------------------------------------------------- 
@node Equations,  , Redeclaration of parameter as variable, Open Issues
@section Equations

@subsection Discretes and equations

The test case Discrete2 (@ref{Discrete2}) depends on the expression
properties. If it is said that equations can only contain differentiable
expressions, then this is clearly illegal.

@xref{Expression Properties}

@c ********************************************************************

@node Closed Issues, Test Cases, Open Issues, Top
@chapter Closed Issues

@c ********************************************************************

@node Test Cases, Change-Log, Closed Issues, Top
@appendix Test Cases

@c
@c generated by Makefile
@c

@include cases.texi

@c
@c end Makefile
@c

@c ======================================================================
@node Change-Log,  , Test Cases, Top
@appendix Change-Log

@appendixsec Version 1.0 to 1.0-dk1

A lot of things were added and changed by David.

@appendixsec Version 0.9.1 to 1.0

The following changes result from the discussion at the 12th Modelica
design meeting in Manchester. It is referred to the minutes of the
12th Modelica design meeting.

@enumerate
@item
New test cases, @ref{Overwriting3}, and @ref{Modification9}, according to
N.1 and N.2, respectively, given in the minutes.
@item
@xref{ScopeDeclaration1}, @ref{ScopeDeclaration2}, @ref{Lookup5}: new
header.
@item
@xref{Faculty1}: changed correctness to @samp{incorrect}.
@item
New test case, @ref{ReplaceFunction}, according to N.3 of section 2.2 ``Is
Modelica a strict define­before­use language?'' of the minutes. 
@item
@xref{DeclareConstant1}, @ref{DeclareConstant3}: new header.
@item
@xref{ModifyConstant2}: changed correctness to @samp{correct}.
@item
New test cases, @ref{ModifyConstant5}, @ref{ModifyConstant6}, to check
modification of final constants.
@item
@xref{ConnectTypes}: introduced connection equations for parameters and
constants in the flat representation.
@item
@xref{ConnectHierarchical2}: changed correctness to @samp{correct}.
@item
@xref{ConnectFlowEffort}: simplified; 
added new test case, @ref{RedeclareFlowEffort}. 
@item
@xref{ConstructParameters}: added keywords @samp{input} and
@samp{output} to declarations in the flat model representation.

@c @item 
@c @xref{Overwriting1}: use term @samp{replace} instead of @samp{overwrite}.
@item
@xref{Real2Integer1}: changed correctness to @samp{erroneous} and corrected
flat model representation.
@c @item
@c @xref{XPowers3}: The integer 'n' must be declared as constant.
@end enumerate

With these modifications most unclear issues of version 0.9.1 are
resolved. (@xref{Open Issues}, for remaining questions.)

@appendixsec Version 0.9 to 0.9.1

@enumerate
@item 
@xref{ConditionalArrayExpression1}: corrected classification (&array).

@ignore
@item
@xref{Connections}, @ref{ConnectTypes}: extended discussion in
subsection ``Parameters and constants in connectors''
(generation of assertions?).
@item
@xref{Connections}: new subsection ``Connections and Modifications''.
@item
@xref{Connections}: new subsection ``Directed connections''.
@end ignore

@end enumerate

@contents
@bye
