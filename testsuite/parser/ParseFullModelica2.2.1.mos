// name:     ParseFullModelica2.2.1
// keywords: parse
// status:   correct
// env: OPENMODELICALIBRARY=../../libraries/msl221
// 
// Parse/Unparse entire MSL 2.2.1
//

loadModel(Modelica);
getErrorString();
list();

// Result:
// true
// ""
// "package Modelica "Modelica Standard Library"
//   extends Icons.Library;
//   annotation(preferedView = "info", version = "2.2.1", versionDate = "2006-03-24", conversion(from(version = "1.6", ModelicaAdditions(version = "1.5"), MultiBody(version = "1.0.1"), MultiBody(version = "1.0"), Matrices(version = "0.8"), script = "Scripts/ConvertModelica_from_1.6_to_2.1.mos"), from(version = "2.1 Beta1", script = "Scripts/ConvertModelica_from_2.1Beta1_to_2.1.mos"), noneFromVersion = "2.1", noneFromVersion = "2.2"), Dymola(checkSum = "539989979:1143034484"), Settings(NewStateSelection = true), Documentation(info = "<HTML>
// <p>
// Package <b>Modelica</b> is a <b>standardized</b> and <b>free</b> package
// that is developed together with the Modelica language from the
// Modelica Association, see <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>. 
// It is also called <b>Modelica Standard Library</b>. 
// It provides model components in many domains that are based on 
// standardized interface definitions. Some typical examples are shown
// in the next figure:
// </p>
//  
// <p>
// <img src=\"./Images/UsersGuide/ModelicaLibraries.png\">
// </p>
//  
// <p>
// For an introduction, have especially a look at:
// </p>
// <ul>
// <li> <a href=\"Modelica://Modelica.UsersGuide\">Users Guide</a>
//      discusses some aspects of the Modelica Standard Library, such as
//      interface definitions and used conventions.</li>
// <li><a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
//     summarizes the changes of new versions of this package.</li>
// <li> Packages <b>Examples</b> in the various subpackages, demonstrate
//      how to use the components of the corresponding sublibrary.</li>
// </ul>
//  
// <p>
// Copyright &copy; 1998-2006, Modelica Association.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// <p> <b>Note:</b> This is a <i>subset</i> of the official Modelica package with minor changes made by MathCore Engineering AB.
// For a complete list of changes see the <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>.
// </p> 
// </HTML>
// ", revisions = ""), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//   package UsersGuide "Users Guide"
//     annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Users Guide of the Modelica Standard Library</font></h3>
// <p>
// Package <b>Modelica</b> is a <b>standardized</b> and <b>pre-defined</b> package
// that is developed together with the Modelica language from the
// Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// It is also called <b>Modelica Standard Library</b>.
// It provides constants, types, connectors, partial models and model
// components in various disciplines.
// </p>
// <p>
// This package contains a short <b>users guide</b> for 
// the overall library. Some of the main sublibraries have their own
// users guides that can be accessed by the following links:
// </p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
// <!--  <tr><td><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide\">Digital</a>
//              </td>
//       <td>Library for digital electrical components based on the VHDL standard 
//          (2-,3-,4-,9-valued logic)</td>
//   </tr>
//   <tr><td><a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody</a>
//              </td>
//       <td>Library to model 3-dimensional mechanical systems</td>
//   </tr>-->
// 
//   <tr><td><a href=\"Modelica://Modelica.Mechanics.Rotational.UsersGuide\">Rotational</a>
//              </td>
//       <td>Library to model 1-dimensional mechanical systems</td>
//   </tr>
// 
//   <!--<tr><td><a href=\"Modelica://Modelica.Media.UsersGuide\">Media</a>
//              </td>
//       <td>Property models of media</td>
//   </tr>-->
//   <tr><td><a href=\"Modelica://Modelica.SIunits.UsersGuide\">SIunits.</a> </td>
//       <td>Type definitions based on SI units according to ISO 31-1992</td>
//   </tr>
// 
//   <tr><td><a href=\"Modelica://Modelica.StateGraph.UsersGuide\">StateGraph</a>
//              </td>
//       <td>Library to model discrete event and reactive systems by hierarchical state machines</td>
//   </tr>
// 
// 
//   <tr><td><a href=\"Modelica://Modelica.Utilities.UsersGuide\">Utilities</a>
//              </td>
//       <td>Utility functions especially for scripting (Files, Streams, Strings, System)</td>
//   </tr>
// </table>
// 
// </html>", revisions = ""), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     class Connectors "Connectors"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Connectors</font></h3>
// <p>
// The Modelica standard library defines the most important 
// <b>elementary connectors</b> in various domains. If any possible, 
// a user should utilize these connectors in order that components
// from the Modelica Standard Library and from other libraries
// can be combined without problems. The following elementary
// connectors are defined (potential variables are connector variables
// without the flow attribute, flow variables are connector variables
// that have the flow attribute):
// </p>
//  
// <table border=1 cellspacing=0 cellpadding=1>
//   <tr><td><b>domain</b></td>
//       <td><b>pot. variables</b></td>
//       <td><b>flow variables</b></td>
//       <td><b>connector definition</b></td>
//       <td><b>icons</b></td></tr>
//  
//   <tr><td><b>electrical<br>analog</b></td>
//       <td>electrical potential</td>
//       <td>electrical current</td>
//       <td><a href=\"Modelica://Modelica.Electrical.Analog.Interfaces\">Modelica.Electrical.Analog.Interfaces</a>
//            <br>Pin, PositivePin, NegativePin</td>
//       <td><img src=\"Images/UsersGuide/ElectricalPins.png\"></td></tr>
// 
//   <tr><td><b>electrical<br>multi-phase</b></td>
//       <td colspan=\"2\">vector of electrical pins</td>
//       <td><a href=\"Modelica://Modelica.Electrical.MultiPhase.Interfaces\">Modelica.Electrical.MultiPhase.Interfaces</a>
//            <br>Plug, PositivePlug, NegativePlug</td>
//       <td><img src=\"Images/UsersGuide/ElectricalPlugs.png\"></td></tr>
//   
//   <tr><td><b>electrical <br>sphace phasor</b></td>
//       <td>2 electrical potentials</td>
//       <td>2 electrical currents</td>
//       <td><a href=\"Modelica://Modelica.Electrical.Machines.Interfaces\">Modelica.Electrical.Machines.Interfaces</a>
//            <br>SpacePhasor</td>
//       <td><img src=\"Images/UsersGuide/SpacePhasor.png\"></td></tr>
//   
//   <tr><td><b>electrical <br>digital</b></td>
//       <td>Integer (1..9)</td>
//       <td>---</td>
//       <td><a href=\"Modelica://Modelica.Electrical.Digital.Interfaces\">Modelica.Electrical.Digital.Interfaces</a>
//            <br>DigitalSignal, DigitalInput, DigitalOutput</td>
//       <td><img src=\"Images/UsersGuide/Digital.png\"></td></tr>
//   
//   <tr><td><b>translational</b></td>
//       <td>distance</td>
//       <td>cut-force</td>
//       <td><a href=\"Modelica://Modelica.Mechanics.Translational.Interfaces\">Modelica.Mechanics.Translational.Interfaces</a>
//            <br>Flange_a, Flange_b</td>
//       <td><img src=\"Images/UsersGuide/TranslationalFlanges.png\"></td></tr>
//  
//   <tr><td><b>rotational</b></td>
//       <td>angle</td>
//       <td>cut-torque</td>
//       <td><a href=\"Modelica://Modelica.Mechanics.Rotational.Interfaces\">Modelica.Mechanics.Rotational.Interfaces</a>
//            <br>Flange_a, Flange_b</td>
//       <td><img src=\"Images/UsersGuide/RotationalFlanges.png\"></td></tr>
// 
//   <tr><td><b>3-dim.<br>mechanics</b></td>
//       <td>position vector<br>
//           orientation object</td>
//       <td>cut-force vector<br>
//           cut-torque vector</td>
//       <td><a href=\"Modelica://Modelica.Mechanics.MultiBody.Interfaces\">Modelica.Mechanics.MultiBody.Interfaces</a>
//            <br>Frame, Frame_a, Frame_b, Frame_resolve</td>
//       <td><img src=\"Images/UsersGuide/MultiBodyFrames.png\"></td></tr>
// 
//   <tr><td><b>simple<br>fluid flow</b></td>
//       <td>pressure<br>
//           specific enthalpy</td>
//       <td>mass flow rate<br>
//           enthalpy flow rate</td>
//       <td><a href=\"Modelica://Modelica.Thermal.FluidHeatFlow.Interfaces\">Modelica.Thermal.FluidHeatFlow.Interfaces</a>
//            <br>FlowPort, FlowPort_a, FlowPort_b</td>
//       <td><img src=\"Images/UsersGuide/FluidHeatFlowPorts.png\"></td></tr>
// 
//   <tr><td><b>heat<br>transfer</b></td>
//       <td>temperature</td>
//       <td>heat flow rate</td>
//       <td><a href=\"Modelica://Modelica.Thermal.HeatTransfer.Interfaces\">Modelica.Thermal.HeatTransfer.Interfaces</a>
//            <br>HeatPort, HeatPort_a, HeatPort_b</td>
//       <td><img src=\"Images/UsersGuide/ThermalHeatPorts.png\"></td></tr>
//  
//   <tr><td><b>block<br>diagram</b></td>
//       <td>Real variable<br>
//           Integer variable<br>
//           Boolean variable</td>
//       <td>---</td>
//       <td><a href=\"Modelica://Modelica.Blocks.Interfaces\">Modelica.Blocks.Interfaces</a>
//            <br>RealSignal, RealInput, RealOutput<br>
//                IntegerSignal, IntegerInput, IntegerOutput<br>
//                BooleanSignal, BooleanInput, BooleanOutput</td>
//       <td><img src=\"Images/UsersGuide/Signals.png\"></tr>
// 
//   <tr><td><b>state<br>machine</b></td>
//       <td>Boolean variables<br>
//           (occupied, set, <br>
//            available, reset)</td>
//       <td>---</td>
//       <td><a href=\"Modelica://Modelica.StateGraph.Interfaces\">Modelica.StateGraph.Interfaces</a>
//            <br>Step_in, Step_out, Transition_in, Transition_out</td>
//       <td><img src=\"Images/UsersGuide/StateGraphPorts.png\"></td></tr>
// 
//   <tr><td colspan=\"5\">&nbsp;<br><b>Connectors from libraries that will be included in one of 
//                                    the next releases of package Modelica</b></td></tr>
// 
//   <tr><td><b>thermo<br>fluid flow</b></td>
//       <td>pressure<br>
//           specific enthalpy<br>
//           mass fractions</td>
//       <td>mass flow rate<br>
//           enthalpy flow rate<br>
//           subst. mass flow rates</td>
//       <td><a href=\"Modelica://Modelica_Fluid.Interfaces\">Modelica_Fluid.Interfaces</a>
//            <br>FluidPort, FluidPort_a, FluidPort_b</td>
//       <td><img src=\"Images/UsersGuide/FluidPorts.png\"></td></tr>
// 
//   <tr><td><b>magnetic</b></td>
//       <td>magnetic potential</td>
//       <td>magnetic flux</td>
//       <td><a href=\"Modelica://Magnetic.Interfaces\">Magnetic.Interfaces</a>
//            <br>MagneticPort, PositiveMagneticPort, <br>NegativeMagneticPort</td>
//       <td><img src=\"Images/UsersGuide/MagneticPorts.png\"></td></tr>
// 
// 
//   <tr><td colspan=\"5\">&nbsp;<br><b>Connectors from other libraries</b></td></tr>
// 
//   <tr><td><b>hydraulic</b></td>
//       <td>pressure</td>
//       <td>volume flow rate</td>
//       <td><a href=\"Modelica://HyLibLight.Interfaces\">HyLibLight.Interfaces</a>
//            <br>Port_A, Port_b</td>
//       <td><img src=\"Images/UsersGuide/HydraulicPorts.png\"></td></tr>
// 
//   <tr><td><b>pneumatic</b></td>
//       <td>pressure</td>
//       <td>mass flow rate</td>
//       <td><a href=\"Modelica://PneuLibLight.Interfaces\">PneuLibLight.Interfaces</a>
//            <br>Port_1, Port_2</td>
//       <td><img src=\"Images/UsersGuide/PneumaticPorts.png\"></td></tr>
// </table>
// 
// <p>
// In all domains, usually 2 connectors are defined. The variable declarations
// are <b>identical</b>, only the icons are different in order that it is easy
// to distinguish connectors of the same domain that are attached at the same
// component.
// </p>
// 
// <p>
// Modelica supports also hierarchical connectors, in a similar way as hierarchical models. 
// As a result, it is, e.g., possible, to collect elementary connectors together. 
// For example, an electrical plug consisting of two electrical pins can be defined as:
// </p>
// 
// <pre>   <b>connector</b> Plug
//       <b>import</b> Modelica.Electrical.Analog.Interfaces;
//       Interfaces.PositivePin phase;
//       Interfaces.NegativePin ground;
//    <b>end</b> Plug;
// </pre>
// 
// <p>
// With one connect(..) equation, either two plugs can be connected 
// (and therefore implicitly also the phase and ground pins) or a 
// Pin connector can be directly connected to the phase or ground of 
// a Plug connector, such as \"connect(resistor.p, plug.phase)\".
// </p>
// 
// 
// </html>
// ", revisions = ""), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Connectors;
//     class Conventions "Conventions"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Conventions</font></h3>
// 
// <p>
// In the Modelica package the following conventions are used:
// </p>
// <ol>
// <li> Class and instance names are written in upper and lower case
//      letters, e.g., \"ElectricCurrent\". An underscore is only used
//      at the end of a name to characterize a lower or upper index,
//      e.g., \"pin_a\".<br>&nbsp;</li>
// 
// <li> <b>Class names</b> start always with an upper case letter.<br>&nbsp;</li>
// 
// <li> <b>Instance names</b>, i.e., names of component instances and
//      of variables (with the exception of constants), 
//      start usually with a lower case letter with only
//      a few exceptions if this is common sense 
//      (such as \"T\" for a temperature variable).<br>&nbsp;</li>
// 
// <li> <b>Constant names</b>, i.e., names of variables declared with the
//      \"constant\" prefix, follow the usual naming conventions 
//      (= upper and lower case letters) and start usually with an 
//      upper case letter, e.g. UniformGravity, SteadyState.<br>&nbsp;<li>
// 
// <li> The two connectors of a domain that have identical declarations
//      and different icons are usually distinguished by \"_a\", \"_b\"
//      or \"_p\", \"_n\", e.g., Flange_a/Flange_b, HeatPort_a, HeatPort_b.<br>&nbsp;</li>
// 
// <li> The <b>instance name</b> of a component is always displayed in its icon
//      (= text string \"%name\") in <b>blue color</b>. A connector class has the instance
//      name definition in the diagram layer and not in the icon layer.
//      <b>Parameter</b> values, e.g., resistance, mass, gear ratio, are displayed
//      in the icon in <b>black color</b> in a smaller font size as the instance name.
//     <br>&nbsp;<li>
// 
// <li> A main package has usually the following subpackages:
//      <ul>
//      <li><b>UsersGuide</b> containing an overall description of the library
//          and how to use it.</li>  
//      <li><b>Examples</b> containing models demonstrating the
//          usage of the library.</li>  
//      <li><b>Interfaces</b> containing connectors and partial
//          models.</li>  
//      <li><b>Types</b> containing type, enumeration and choice
//          definitions.</li>
//      </ul>
//      </li>
// </ol>
// 
// <p>
// &nbsp;<br>
// <b>Enumerations</b> are defined in the Modelica language since release 2.0.
// However, they are not yet supported in the most important Modelica
// simulation environment Dymola. For this reason, this language element
// is not used in the Modelica standard library. Instead, enumerations
// are emulated with packages and constants. For example, the enumeration
// </p>
// 
// <pre>   <b>type</b> Init = <b>enumeration</b> (NoInit, InitializeStates, SteadyState);
// 
//    <b>parameter</b> Init initType = Init.NoInit \"Type of initialization\";
// </pre>
// 
// <p>
// is emulated in the following way:
// </p>
// 
// <pre>   <b>package</b>  Init \"Enumeration emulation\" 
//       <b>extends</b>  Modelica.Icons.Enumeration;
//   
//       <b>constant</b>  Integer NoInit=1;
//       <b>constant</b>  Integer InitializeStates=2;
//       <b>constant</b>  Integer SteadyState=3;
//   
//       <b>type</b>  Temp  
//          <b>extends</b>  Modelica.Icons.TypeInteger;
//          <b>annotation</b>  (choices(
//              choice=Init.NoInit           \"NoInit (no initialization)\",
//              choice=Init.InitializeStates \"InitializeStates (initialize states)\",
//              choice=Init.SteadyState      \"SteadyState (initialize in steady state)\"));
//       <b>end</b>  Temp;
//    <b>end</b>  Init;
// 
//    <b>parameter</b> Init.Temp initType = Init.NoInit;
// </pre>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Conventions;
//     class ReleaseNotes "Release notes"
//       annotation(Documentation(info = "<h3><span style=\"color: #008000; font-size: large;\">Release notes</span></h3>
// <p>This section summarizes the changes that have been performed on the Modelica standard library.</p>
// <ul>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_2_2_1\">Version 2.2.1</a> (March 24, 2006)</li>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_2_2\">Version 2.2</a> (April 6, 2005)</li>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_2_1\">Version 2.1</a> (Nov. 11, 2004)</li>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_1_6\">Version 1.6</a> (June 21, 2004)</li>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_1_5\">Version 1.5</a> (Dec. 16, 2002)</li>
// <li> <a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes.Version_1_4\">Version 1.4</a> (June 28, 2001      and previous versions)</li>
// </ul>
// <p>Changes made by MathCore Engineering AB in 2007-2009.</p>
// <ul>
// <li> All graphical annotations are updated to Modelica v3.0. </li>
// <li> The following packages are excluded Electrical.Digital, Mechanics.MultiBody and Media.</li>
// <li> Modelica.Constants.Integer_inf changed from 2^31-1 to 2^30-1 (=1073741823). </li>
// <li> Changed Lact(start=Lzer) to Lact(start=Lzer,stateSelect=StateSelect.avoid) to prevent it from being selected as state in Modelica.Electrical.Analog.Basic.SaturatingInductor. Also changed from arctan to atan in same model.</li>
// <li> Changed ln to Modelica.Math.log in multiple places in the FluidHeatFlow package.</li>
// <li> Changed cos to Modelica.Math.cos in MultiPhase package. </li>
// <li> Added experiment annotations to MultiPhase examples.</li>
// <li> Removed example Modelica.Electrical.Analog.Examples.HeatingNPN_OrGate since it had modelling errors. </li>
// <li> Set stop time to 5e4 for Modelica.Electrical.Analog.Examples.ChuaCircuit in experiment annotation.</li>
// <li> The external functions referenced in Modelica.Blocks.Sources.CombiTimeTable (e.g. dymTableTimeIni2) have different names.</li>
// <li> Small bug fix for Mechanics.Rotational/Translational.Interfaces.FrictionBase when peak &gt; 1, proposed by Martin Otter. </li>
// <li> Modelica.StateGraph.Examples: Introduced the StateGraphRoot component on top level. </li>
// <li> Added unit bug fixes through out the library (same as done in later releases from Modelica Association), but for now using protected parameters instead of constants, because MathModelica always evaluate constants and replace by their bindings. </li>
// </ul>", revisions = ""), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       class Version_2_2_1 "Version 2.2.1"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 2.2.1</font></h3>
// <p>
// Version 2.2.1 is backward compatible to version 2.2.
// </p>
//  
// <p>
// In this version, <b>no</b> new libraries have been added.
// The following major improvements have been made:
// </p>
//  
// <ul>
// <li> The <b>Documentation</b> of the Modelica standard library was
//      considerably improved:<br>
//      In Dymola 6, the new feature was introduced to automatically add tables
//      for class content and component interface definitions (parameters and 
//      connectors) to the info layer. For this reason, the corresponding (partial)
//      tables previously present in the Modelica Standard Library have been
//      removed. The new feature of Dymola 6 has the significant advantage that
//      all tables are now guaranteed to be up-to-date.<br>
//      Additionally, the documentation has been improved by adding appropriate
//      description texts to parameters, connector instances, function input
//      and output arguments etc., in order that the automatically generated
//      tables do not have empty entries. Also new users guides for sublibraries
//      Rotational and SIunits have been added and the users guide on top
//      level (Modelica.UsersGuide) has been improved.<br>&nbsp;</li>
// 
// <li> Initialization options have been added to the Modelica.Blocks.<b>Continuous</b>
//      blocks (NoInit, SteadyState, InitialState, InitialOutput). If InitialOutput
//      is selected, the block output is provided as initial condition. The states
//      of the block are then initialized as close as possible to steady state.
//      Furthermore, the Continuous.LimPID block has been significantly
//      improved and much better documented.<br>&nbsp;</li>
// 
// <li> The Modelica.<b>Media</b> library has been significantly improved:<br>
//      New functions setState_pTX, setState_phX, setState_psX, setState_dTX
//      have been added to PartialMedium to compute the independent medium variables
//      (= state of medium) from p,T,X, or from p,h,X or from p,s,X or from
//      d,T,X. Then functions are provided for all interesting medium variables
//      to compute them from its medium state. All these functions are
//      implemented in a robust way for all media (with a few exceptions, if the
//      generic function does not make sense for a particular medium).</li>
// </ul>
//  
// <p>
// The following <b>new components</b> have been added to <b>existing</b> libraries:
// </p>
//  
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Examples.</b></td></tr>
//   <tr><td> PID_Controller</td>
//       <td> Example to demonstrate the usage of the
//            Blocks.Continuous.LimPID block.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
//   <tr><td> UnitConversions.*</td>
//       <td> New package that provides blocks for unit conversions.
//            UnitConversions.ConvertAllBlocks allows to select all
//            available conversions from a menu.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.</b></td></tr>
//   <tr><td> SM_ElectricalExcitedDamperCage</td>
//       <td> Electrical excited synchronous induction machine with damper cage</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.Components.</b></td></tr>
//   <tr><td> ElectricalExcitation </td>
//       <td> Electrical excitation for electrical excited synchronous 
//            induction machines</td> </tr>
//   <tr><td> DamperCage</td>
//       <td> Unsymmetrical damper cage for electrical excited synchronous 
//            induction machines. At least the user has to specify the dampers
//            resistance and stray inductance in d-axis; if he omits the
//            parameters of the q-axis, the same values as for the d.axis 
//            are used, assuming a symmetrical damper.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.Examples.</b></td></tr>
//   <tr><td> SMEE_Gen </td>
//       <td> Test example 7: ElectricalExcitedSynchronousInductionMachine 
//            as Generator</td> </tr>
//   <tr><td> Utilities.TerminalBox</td>
//       <td> Terminal box for three-phase induction machines to choose  
//            either star (wye) ? or delta ? connection</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Math.Matrices.</b></td></tr>
//   <tr><td> equalityLeastSquares</td>
//       <td> Solve a linear equality constrained least squares problem:<br>
//           min|A*x-a|^2 subject to B*x=b</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
//   <tr><td> Parts.PointMass</td>
//       <td> Point mass, i.e., body where inertia tensor is neglected.</td> </tr>
//   <tr><td> Interfaces.FlangeWithBearing</td>
//       <td> Connector consisting of 1-dim. rotational flange and its 
//            3-dim. bearing frame.</td> </tr>
//   <tr><td> Interfaces.FlangeWithBearingAdaptor</td>
//       <td> Adaptor to allow direct connections to the sub-connectors 
//            of FlangeWithBearing.</td> </tr>
//   <tr><td> Types.SpecularCoefficient</td>
//       <td> New type to define a specular coefficient.</td> </tr>
//   <tr><td> Types.ShapeExtra</td>
//       <td> New type to define the extra data for visual shape objects and to
//            have a central place for the documentation of this data.</td> </tr>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Examples.Elementary</b></td></tr>
//   <tr><td> PointGravityWithPointMasses</td>
//       <td> Example of two point masses in a central gravity field.</td> </tr>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td>UsersGuide</td>
//       <td> A users guide has been added by using the documentation previously
//            present in the package documentation of Rotational.</td> </tr>
//   <tr><td>Sensors.PowerSensor</td>
//       <td> New component to measure the energy flow between two connectors
//            of the Rotational library.</td> </tr>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.</b></td></tr>
//   <tr><td>Speed</td>
//       <td> New component to move a translational flange 
//            according to a reference speed</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Media.Interfaces.PartialMedium.</b></td></tr>
//   <tr><td>specificEnthalpy_pTX</td>
//       <td> New function to compute specific enthalpy from pressure, temperature
//            and mass fractions.</td> </tr>
//   <tr><td>temperature_phX</td>
//       <td> New function to compute temperature from pressure, specific enthalpy,
//            and mass fractions.</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
//   <tr><td> SignalBus</td>
//       <td> Icon for signal bus</td> </tr>
//   <tr><td> SignalSubBus</td>
//       <td> Icon for signal sub-bus</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
//   <tr><td>UsersGuide</td>
//       <td> A users guide has been added that describes unit handling.</td> </tr>
//   <tr><td> Resistance<br>
//            Conductance</td>
//       <td> Attribute 'min=0' removed from these types.</td> </tr>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.</b></td></tr>
//   <tr><td> Components.Valve</td>
//       <td> Simple controlled valve with either linear or 
//            exponential characteristic.</td> </tr>
//   <tr><td> Sources. IdealPump </td>
//       <td> Simple ideal pump (resp. fan)  dependent on the shaft?s speed;
//            pressure increase versus volume flow is defined as a linear 
//            function. Torque * Speed = Pressure invrease * Volume flow 
//            (without losses).</td> </tr>
//   <tr><td> Examples.PumpAndValve </td>
//       <td> Test example for valves.</td> </tr>
//   <tr><td> Examples.PumpDropOut </td>
//       <td> Drop out of 1 pump to test behavior of semiLinear.</td> </tr>
//   <tr><td> Examples.ParallelPumpDropOut </td>
//       <td> Drop out of 2 parallel pumps to test behavior of semiLinear.</td> </tr>
//   <tr><td> Examples.OneMass </td>
//       <td> Cooling of 1 hot mass to test behavior of semiLinear.</td> </tr>
//   <tr><td> Examples.TwoMass </td>
//       <td> Cooling of 2 hot masses to test behavior of semiLinear.</td> </tr>
// </table> 
//  
// <p>
// The following <b>components</b> have been improved:
// </p>
//  
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
//   <tr><td> UsersGuide</td>
//       <td> Users guide and package description of Modelica Standard Library improved.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Interfaces.</b></td></tr>
//   <tr><td> RealInput<br>
//            BooleanInput<br>
//            IntegerInput</td>
//       <td> When dragging one of these connectors the width and height
//            is a factor of 2 larger as a standard icon. Previously,
//            these connectors have been dragged and then manually enlarged
//            by a factor of 2 in the Modelica standard library.</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.</b></td></tr>
//   <tr><td> Continuous.*</td>
//       <td> Initialization options added to all blocks
//            (NoInit, SteadyState, InitialState, InitialOutput).
//            New parameter limitsAtInit to switch off the limits
//            of LimIntegrator or LimPID during initialization</td> </tr>
//   <tr><td> Continuous.LimPID</td>
//       <td> Option to select P, PI, PD, PID controller.
//            Documentation significantly improved.</td> </tr>
//   <tr><td> Nonlinear.Limiter<br>
//            Nonlinear.VariableLimiter<br>
//            Nonlinear.Deadzone</td>
//       <td> New parameter limitsAtInit/deadZoneAtInit to switch off the limits
//            or the dead zone during initialization</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog. </b></td></tr>
//   <tr><td> Sources</td>
//       <td> Icon improved (+/- added to voltage sources, arrow added to
//            current sources).</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors. </b></td></tr>
//   <tr><td> Diode</td>
//       <td> smooth() operator included to improve numerics.</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines. </b></td></tr>
//   <tr><td> SM_PermanentMagnetDamperCage<br>
//            SM_ElectricalExcitedDamperCage<br>
//            SM_ReluctanceRotorDamperCage</td>
//       <td> The user can choose \"DamperCage = false\" (default: true) 
//            to remove all equations for the damper cage from the model.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines. </b></td></tr>
//   <tr><td> AIM_SlipRing</td>
//       <td> Easier parameterization: if the user selects \"useTrunsRatio = false\" 
//            (default: true, this is the same behavior as before), 
//             parameter TurnsRatio is calculated internally from 
//             Nominal stator voltage and Locked-rotor voltage.</td> </tr>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Math.Matrices.</b></td></tr>
//   <tr><td>leastSquares</td>
//       <td>The A matrix in the least squares problem might be rank deficient.
//           Previously, it was required that A has full rank.</td>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
//   <tr><td>all models</td>
//       <td> <ul> 
//            <li> All components with animation information have a new variable
//                 <b>specularCoefficient</b> to define the reflection of ambient light. 
//                 The default value is world.defaultSpecularCoefficient which has
//                 a default of 0.7. By changing world.defaultSpecularCoefficient, the
//                 specularCoefficient of all components is changed that are not
//                 explicitly set differently. Since specularCoefficient is a variable
//                 (and no parameter), it can be changed during simulation. Since
//                 annotation(Dialog) is set, this variable still appears in the
//                 parameter menus.<br>
//                 Previously, a constant specularCoefficient of 0.7 was used
//                 for all components.</li>
//            <li> Variable <b>color</b> of all components is no longer a parameter
//                 but an input variable. Also all parameters in package <b>Visualizers</b>,
//                 with the exception of <b>shapeType</b> are no longer parameters but
//                 defined as input variables with annotation(Dialog). As a result,
//                 all these variables appear still in parameter menus, but they can
//                 be changed during simulation (e.g., color might be used to
//                 display the temperature of a part).</li>
//            <li> All menus have been changed to follow the Modelica 2.2 annotations
//                 \"Dialog, group, tab, enable\" (previously, a non-standard Dymola
//                 definition for menus was used). Also, the \"enable\" annotation 
//                 is used in all menus
//                 to disable input fields if the input would be ignored.</li>
//            <li> All visual shapes are now defined with conditional declarations
//                 (to remove them, if animation is switched off). Previously,
//                 these (protected) objects have been defined by arrays with
//                 dimension 0 or 1.</li>
//            </ul></td></tr>
// 
//   <tr><td>Frames.resolveRelative</td>
//       <td> The derivative of this function added as function and defined via
//            an annotation. In certain situations, tools had previously
//            difficulties to differentiate the inlined function automatically.</td>
// 
// 
//   <tr><td>Forces.*</td>
//       <td> The scaling factors N_to_m and Nm_to_m have no longer a default
//            value of 1000 but a default value of world.defaultN_to_m (=1000) 
//            and world.defaultNm_to_m (=1000). This allows to change the
//            scaling factors for all forces and torques in the world
//            object.</td>
//   <tr><td>Interfaces.Frame.a<br>
//           Interfaces.Frame.b<br>
//           Interfaces.Frame_resolve</td>
//       <td> The Frame connectors are now centered around the origin to ease
//            the usage. The shape was changed, such that the icon is a factor
//            of 1.6 larger as a standard icon (previously, the icon had a 
//            standard size when dragged and then the icon was manually enlarged
//            by a factor of 1.5 in the y-direction in the MultiBody library;
//            the height of 16 allows easy positioning on the standard grid size of 2).
//            The double line width of the border in icon and diagram layer was changed
//            to a single line width and when making a connection the connection
//            line is dark grey and no longer black which looks better.</td>
//   <tr><td>Joints.Assemblies.*</td>
//       <td> When dragging an assembly joint, the icon is a factor of 2
//            larger as a standard icon. Icon texts and connectors have a 
//            standard size in this enlarged icon (and are not a factor of 2
//            larger as previously). </td>
//   <tr><td>Types.*</td>
//       <td> All types have a corresponding icon now to visualize the content
//            in the package browser (previously, the types did not have an icon).</td>
//  
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td> Inertia</td>
//       <td> Initialization and state selection added.</td> </tr>
//   <tr><td> SpringDamper</td>
//       <td> Initialization and state selection added.</td> </tr>
//   <tr><td> Move</td>
//       <td> New implementation based solely on Modelica 2.2 language
//            (previously, the Dymola specific constrain(..) function was used).</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.</b></td></tr>
//   <tr><td> Move</td>
//       <td> New implementation based solely on Modelica 2.2 language
//            (previously, the Dymola specific constrain(..) function was used).</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.</b></td></tr>
//   <tr><td> SimpleFriction</td>
//       <td> Calculates friction losses from pressure drop and volume flow.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.Components.</b></td></tr>
//   <tr><td> IsolatedPipe <br>
//            HeatedPipe</td>
//       <td> Added geodetic height as a source of pressure change;
//            feeds friction losses as calculated by simple friction to  
//            the energy balance of the medium.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Media.Interfaces.PartialMedium.FluidConstants.</b></td></tr>
//   <tr><td>HCRIT0</td><td>Critical specifc enthalpy of the fundamental
//           equation (base formulation of the fluid medium model). </td></tr>
//   <tr><td>SCRIT0</td><td>Critical specifc entropy of the fundamental
//           equation (base formulation of the fluid medium model). </td></tr>
//   <tr><td>deltah</td><td>Enthalpy offset (default: 0) between the
//           specific enthalpy of the fluid model and the user-visible
//           specific enthalpy in the model: deltah = h_model - h_fundamentalEquation.
// </td></tr>
//   <tr><td>deltas</td><td>Entropy offset (default: 0) between the
//           specific entropy of the fluid model and the user-visible
//           specific entropy in the model: deltas = s_model - s_fundamentalEquation.</td></tr>
//   <tr><td>T_default</td><td>Default value for temperature of medium (for initialization)</td></tr>
//   <tr><td>h_default</td><td>Default value for specific enthalpy of medium (for initialization)</td></tr>
//   <tr><td>p_default</td><td>Default value for pressure of medium (for initialization)</td></tr>
//   <tr><td>X_default</td><td>Default value for mass fractions of medium (for initialization)</td></tr>
// </table> 
// <p>
// The following <b>errors</b> have been fixed:
// </p>
//  
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Tables.</b></td></tr>
//   <tr><td>CombiTable1D<br>
//           CombiTable1Ds<br>
//           CombiTable2D</td>
//       <td> Parameter \"tableOnFile\" determines now whether a table is read from
//            file or used from parameter \"table\". Previously, if \"fileName\" was not
//            \"NoName\", a table was always read from file \"fileName\", independently
//            of the setting of \"tableOnFile\". This has been corrected.<br>
//            Furthermore, the initialization of a table is now performed in a 
//            when-clause and no longer in a parameter declaration, because some
//            tools evaluate the parameter declaration in some situation more than
//            once and then the table is unnecessarily read several times    
//            (and occupies also more memory).</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
//   <tr><td>CombiTimeTable</td>
//       <td> Same bug fix/improvement as for the tables from Modelica.Blocks.Tables 
//            as outlined above.</td> </tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors. </b></td></tr>
//   <tr><td> PMOS<br>
//            NMOS<br>
//            HeatingPMOS<br>
//            HeatingNMOS</td>
//       <td> The Drain-Source-Resistance RDS had actually a resistance of
//            RDS/v, with v=Beta*(W+dW)/(L+dL). The correct formula is without
//            the divison by \"v\". This has now been corrected.<br>
//            This bug fix should not have an essential effect in most applications.
//            In the default case (Beta=1e-5), the Drain-Source-Resistance was
//            a factor of 1e5 too large and had in the default case the
//            wrong value 1e12, although it should have the value 1e7. The effect
//            was that this resistance had practically no effect.</td> </tr>
// 
//   <tr><td colspan=\"2\"> <b>Modelica.Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
//   <tr><td> dynamicViscosityLowPressure</td>
//       <td> Viscosity and thermal conductivity (which needs viscosity as input) 
//            were computed wrong for polar gases and gas mixtures 
//            (i.e. if dipole moment not 0.0). This has been fixed in version 2.2.1.</td> </tr>
//   <tr><td colspan=\"2\"><b>Modelica.Utilities.Streams.</b></td></tr>
//   <tr><td>readLine</td>
//       <td> Depending on the C-implementation, the stream was not correctly closed.
//            This has been corrected by adding a \"Streams.close(..)\" 
//            after reading the file content.</td> </tr>
// 
// </table>                                 
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_2_2_1;
//       class Version_2_2 "Version 2.2"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 2.2 (April 6, 2005)</font></h3>
// <p>
// Version 2.2 is backward compatible to version 2.1.
// </p>
// The following <b>new libraries</b> have been added:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td><a href=\"Modelica://Modelica.Media\">Modelica.Media</a></td>
//       <td> Property models of liquids and gases, especially
//            <ul>
//            <li>1241 detailed gas models,</li>
//            <li> moist air,</li>
//            <li> high precision water model (according to IAPWS/IF97 standard), </li>
//            <li> incompressible media defined by tables (cp(T), rho(t), eta(T), etc. are defined by tables).</li>
//            </ul>
//            The user can conveniently define mixtures of gases between the 
//            1241 gas models. The models are
//            designed to work well in dynamic simulations. They
//            are based on a new standard interface for media with
//            single and multiple substances and one or multiple phases
//            with the following features:
//            <ul>
//            <li> The independent variables of a medium model do not influence the 
//                 definition of a fluid connector port or how the
//                 balance equations have to be implemented.<br>
//                 Used independent variables: \"p,T\", \"p,T,X\", \"p,h\", \"d,T\".</li>
//            <li> Optional variables, e.g., dynamic viscosity, are only computed 
//                 if needed.<li>
//            <li> The medium models are implemented with regards to efficient 
//                 dynamic simulation.</li>
//            </ul>
//       </td><tr>
//   <tr><td><a href=\"Modelica://Modelica.Thermal.FluidHeatFlow\">Modelica.Thermal.FluidHeatFlow</a></td>
//       <td> Simple components for 1-dim., incompressible thermo-fluid flow 
//            to model coolant flows, e.g., of electrical machines.
//            Components can be connected arbitrarily together (= ideal mixing
//            at connection points) and fluid may reverse direction of flow. 
//   </td><tr>
// </table>
// <p>
// The following <b>changes</b> have been performed in the
// <b>Modelica.Mechanics.MultiBody</b> library:
// </p>
// <ul>
// <li> Component MultiBody.World has a new parameter
//      <b>driveTrainMechanics3D</b>. If set to <b>true</b>, 3D mechanical effects
//      of MultiBody.Parts.Mounting1D/Rotor1D/BevelGear1D are taken into account. If set to 
//      <b>false</b> (= default), 3D mechanical effects in these elements
//      are not taken into account and the
//      frame connectors to connect to 3D parts are disabled (all
//      connections to such a disabled connector are also disabled, due to the
//      new feature of conditional declarations in Modelica language 2.2)</li>
// <li> All references to \"MultiBody.xxx\" have
//      been changed to \"Modelica.Mechanics.MultiBodys.xxx\" in order that after
//      copying of a component outside of the Modelica library, the references
//      still remain valid.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_2_2;
//       class Version_2_1 "Version 2.1"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 2.1 (November 11, 2004)</font></h3>
// <p> This is a major change with respect to previous versions of the
//     Modelica Standard Library, because <b>many new libraries</b> and components
//     are included and because the input/output blocks (Modelica.Blocks)
//     have been considerably simplified:
// </p>
// <ul>
// <li> An input/output connector is defined <b>without</b> a hierarchy (this is possible
//      due to new features of the Modelica language). For example, the input
//      signal of a block \"FirstOrder\" was previously accessed as \"FirstOrder.inPort.signal[1]\".
//      Now it is accessed as \"FirstOrder.u\". This simplifies the understanding and usage 
//      especially for beginners.</li>
// <li> De-vectorized the <b>Modelica.Blocks</b> library. All blocks in the
//      Modelica.Blocks library are now scalar blocks. As a result,
//      the parameters of the Blocks are scalars and no vectors any
//      more. For example, a parameter \"amplitude\" that might had
//      a value of \"{1}\" previously, has now a value of \"1\". This simplifies
//      the understanding and usage especially for beginners.<br>
//      If a vector of blocks is needed, this can be easily
//      accomplished by adding a dimension to the instance. For example
//      \"Constant const[3](k={1,2,3}\" defines three Constant blocks. 
//      An additional advantage of the new approach is that
//      the implementation of Modelica.Blocks is much simpler and is easier to
//      understand.
// </li>
// </ul>
//      
// <p>
// The discussed changes of Modelica.Blocks are not backward compatible.
// A script to <b>automatically</b> convert models to this new version is
// provided. There might be rare cases, where this script does not convert. 
// In this case models have to be manually converted.
// In any case you should make a back-up copy of your model
// before automatic conversion is performed. 
// </p>
// <p>
// The following <b>new libraries</b> have been added:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td><a href=\"Modelica://Modelica.Electrical.Digital\">Modelica.Electrical.Digital</a></td>
//       <td>Digital electrical components based on 2-,3-,4-, and 9-valued logic<br>
//           according to the VHDL standard</td><tr>
//   <tr><td><a href=\"Modelica://Modelica.Electrical.Machines\">Modelica.Electrical.Machines</a></td>
//       <td>Asynchronous, synchronous and DC motor and generator models</td><tr>
//   <tr><td><a href=\"Modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a></td>
//       <td>Functions operatinng on matrices such as solve() (A*x=b), leastSquares(),<br>
//           norm(), LU(), QR(),  eigenValues(), singularValues(), exp(), ...</td><tr>
//   <tr><td><a href=\"Modelica://Modelica.StateGraph\">Modelica.StateGraph</a></td>
//       <td> Modeling of <b>discrete event</b> and <b>reactive</b> systems in a convenient way using<br>
//            <b>hierarchical state machines</b> and <b>Modelica</b> as <b>action language</b>. <br>
//            It is based on JGraphChart and Grafcet and  has a similar modeling power as <br>
//            StateCharts. It avoids deficiences of usually used action languages. <br>
//            This library makes the ModelicaAdditions.PetriNets library obsolet.</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Utilities.Files\">Modelica.Utilities.Files</a></td>
//       <td>Functions to operate on files and directories (copy, move, remove files etc.)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Utilities.Streams\">Modelica.Utilities.Streams</a></td>
//       <td>Read from files and write to files (print, readLine, readFile, error, ...)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Utilities.Strings\">Modelica.Utilities.Strings</a></td>
//       <td>Operations on strings (substring, find, replace, sort, scanToken, ...)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Utilities.System\">Modelica.Utilities.System</a></td>
//       <td>Get/set current directory, get/set environment variable, execute shell command, etc.</td></tr>
// </table>
// <p>
// The following existing libraries outside of the Modelica standard library
// have been improved and added as <b>new libraries</b>
// (models using the previous libraries are automatically converted
// to the new sublibraries inside package Modelica):
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td><a href=\"Modelica://Modelica.Blocks.Discrete\">Modelica.Blocks.Discrete</a></td>
//       <td> Discrete input/output blocks with fixed sample period<br>
//            (from ModelicaAdditions.Blocks.Discrete)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Blocks.Logical\">Modelica.Blocks.Logical</a></td>
//       <td> Logical components with Boolean input and output signals<br>
//            (from ModelicaAdditions.Blocks.Logical)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Blocks.Nonlinear\">Modelica.Blocks.Nonlinear</a></td>
//       <td> Discontinuous or non-differentiable algebraic control blocks such as variable limiter,<br>
//            fixed, variable and Pade delay etc. (from ModelicaAdditions.Blocks.Nonlinear)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Blocks.Routing\">Modelica.Blocks.Routing</a></td>
//       <td> Blocks to combine and extract signals, such as multiplexer<br>
//            (from ModelicaAdditions.Blocks.Multiplexer)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Blocks.Tables\">Modelica.Blocks.Tables</a></td>
//       <td> One and two-dimensional interpolation in tables. CombiTimeTable is available<br>
//            in Modelica.Blocks.Sources (from ModelicaAdditions.Tables)</td></tr>
//   <tr><td><a href=\"Modelica://Modelica.Mechanics.MultiBody\">Modelica.Mechanics.MultiBody</a></td>
//       <td> Components to model the movement of 3-dimensional mechanical systems. Contains <br>
//            body, joint, force and sensor components, analytic handling of kinematic loops,<br>
//            force elements with mass, series/parallel connection of 3D force elements etc.<br>
//            (from MultiBody 1.0 where the new signal connectors are used;<br>
//            makes the ModelicaAdditions.MultiBody library obsolet)</td></tr>
// </table>
// <p>
// As a result, the ModelicaAdditions library is obsolet, because all components
// are either included in the Modelica library or are replaced by much more
// powerful libraries (MultiBody, StateGraph).
// </p>
// <p>
// The following <b>new components</b> have been added to <b>existing</b> libraries.
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Logical.</b></td></tr>
//   <tr><td>Pre</td>
//       <td>y = pre(u): Breaks algebraic loops by an infinitesimal small <br>
//           time delay (event iteration continues until u = pre(u))</td></tr>
//   <tr><td>Edge</td>
//       <td>y = edge(u): Output y is true, if the input u has a rising edge </td></tr>
//   <tr><td>FallingEdge</td>
//       <td>y = edge(not u): Output y is true, if the input u has a falling edge </td></tr>
//   <tr><td>Change</td>
//       <td>y = change(u): Output y is true, if the input u has a rising or falling edge </td></tr>
//   <tr><td>GreaterEqual</td>
//       <td>Output y is true, if input u1 is greater or equal as input u2 </td></tr>
//   <tr><td>Less</td>
//       <td>Output y is true, if input u1 is less as input u2 </td></tr>
//   <tr><td>LessEqual</td>
//       <td>Output y is true, if input u1 is less or equal as input u2 </td></tr>
//   <tr><td>Timer</td>
//       <td>Timer measuring the time from the time instant where the <br>
//           Boolean input became true </td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
//   <tr><td>BooleanToReal</td>
//       <td>Convert Boolean to Real signal</td></tr>
//   <tr><td>BooleanToInteger</td>
//       <td>Convert Boolean to Integer signal</td></tr>
//   <tr><td>RealToBoolean</td>
//       <td>Convert Real to Boolean signal</td></tr>
//   <tr><td>IntegerToBoolean</td>
//       <td>Convert Integer to Boolean signal</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
//   <tr><td>RealExpression</td>
//       <td>Set output signal to a time varying Real expression</td></tr>
//   <tr><td>IntegerExpression</td>
//       <td>Set output signal to a time varying Integer expression</td></tr>
//   <tr><td>BooleanExpression</td>
//       <td>Set output signal to a time varying Boolean expression</td></tr>
//   <tr><td>BooleanTable</td>
//       <td>Generate a Boolean output signal based on a vector of time instants</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
//   <tr><td>Frames.from_T2</td>
//       <td>Return orientation object R from transformation matrix T and its derivative der(T)</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td>LinearSpeedDependentTorque</td>
//       <td>Linear dependency of torque versus speed (acts as load torque)</td></tr>
//   <tr><td>QuadraticSpeedDependentTorque</td>
//       <td>Quadratic dependency of torque versus speed (acts as load torque)</td></tr>
//   <tr><td>ConstantTorque</td>
//       <td>Constant torque, not dependent on speed (acts as load torque)</td></tr>
//   <tr><td>ConstantSpeed</td>
//       <td>Constant speed, not dependent on torque (acts as load torque)</td></tr>
//   <tr><td>TorqueStep</td>
//       <td>Constant torque, not dependent on speed (acts as load torque)</td></tr>
// </table>
// <p>
// The following <b>bugs</b> have been <b>corrected</b>:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Forces.</b></td></tr>
//   <tr><td>LineForceWithMass<br>
//           Spring</td>
//       <td>If mass of the line force or spring component is not zero, the<br>
//           mass was (implicitly) treated as \"mass*mass\" instead of as \"mass\"</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td>Speed</td>
//       <td>If parameter exact=<b>false</b>, the filter was wrong<br>
//           (position was filtered and not the speed input signal)</td></tr>
// </table> 
// <p>
// Other changes:
// </p>
// <ul>
// <li> All connectors are now smaller in the diagram layer. This gives
//      a nicer layout when connectors and components are used together
//      in a diagram</li>
// <li> Default instance names are defined for all connectors, according
//      to a new annotation introduced in Modelica 2.1. For example,
//      when dragging connector \"Flange_a\" from the Rotational library to
//      the diagram layer, the default connector instance name is
//      \"flange_a\" and not \"Flange_a1\".</li>
// <li> The Modelica.Mechanics.Rotational connectors are changed from
//      a square to a circle</li>
// <li> The Modelica.Mechanics.Translational connectors are changed from a
//      green to a dark green color in order that connection lines
//      can be better seen, especially when printed.</li>
// <li> The Modelica.Blocks connectors for Real signals are changed from
//      blue to dark blue in order to distinguish them from electrical signals.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_2_1;
//       class Version_1_6 "Version 1.6"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 1.6 (June 21, 2004)</font></h3>
// <p> Added 1 new library (Electrical.MultiPhase), 17 new components, 
//     improved 3 existing components
//     in the Modelica.Electrical library and improved 3 types
//     in the Modelica.SIunits library. Furthermore,
//     this Users Guide has been started. The improvements
//     in more detail:
// </p>
// <p>
// <b>New components</b>
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
//   <tr><td>SaturatingInductor</td>
//       <td>Simple model of an inductor with saturation</td></tr>
//   <tr><td>VariableResistor</td>
//       <td>Ideal linear electrical resistor with variable resistance</td></tr>
//   <tr><td>VariableConductor</td>
//       <td>Ideal linear electrical conductor with variable conductance</td></tr>
//   <tr><td>VariableCapacitor</td>
//       <td>Ideal linear electrical capacitor with variable capacitance</td></tr>
//   <tr><td>VariableInductor</td>
//       <td>Ideal linear electrical inductor with variable inductance</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors.</b></td></tr>
//   <tr><td>HeadingDiode</td>
//       <td>Simple diode with heating port</td></tr>
//   <tr><td>HeadingNMOS</td>
//       <td>Simple MOS Transistor with heating port</td></tr>
//   <tr><td>HeadingPMOS</td>
//       <td>Simple PMOS Transistor with heating port</td></tr>
//   <tr><td>HeadingNPN</td>
//       <td>Simple NPN BJT according to Ebers-Moll with heating port</td></tr>
//   <tr><td>HeadingPNP</td>
//       <td>Simple PNP BJT according to Ebers-Moll with heating port</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase</b><br>
//       A new library for multi-phase electrical circuits</td></tr>
// </table>
// <p>
// <b>New examples</b>
// </p>
// <p>
// The following new examples have been added to 
// Modelica.Electrical.Analog.Examples:
// </p>
// <p>
// CharacteristicThyristors, 
// CharacteristicIdealDiodes,
// HeatingNPN_OrGate,
// HeatingMOSInverter,
// HeatingRectifier,
// Rectifier,
// ShowSaturatingInductor
// ShowVariableResistor
// </p>
// <p>
// <b>Improved existing components</b>
// </p>
// <p>In the library Modelica.Electrical.Analog.Ideal,
//    a knee voltage has been introduced for the components
//    IdealThyristor, IdealGTOThyristor, IdealDiode in order
//    that the approximation of these ideal elements is improved
//    with not much computational effort.</p>
// <p> In the Modelica.SIunits library, the following changes
//     have been made:</p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td>Inductance</td>
//       <td>min=0 removed</td></tr>
//   <tr><td>SelfInductance</td>
//       <td>min=0 added</td></tr>
//   <tr><td>ThermodynamicTemperature</td>
//       <td>min=0 added</td></tr>
// </table>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_1_6;
//       class Version_1_5 "Version 1.5"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 1.5 (December 16, 2002)</font></h3>
// <p> Added 55 new components. In particular, added new package
//     <b>Thermal.HeatTransfer</b> for modeling of lumped
//     heat transfer, added model <b>LossyGear</b> in Mechanics.Rotational
//     to model gear efficiency and bearing friction according to a new
//     theory in a robust way, added 10 new models in Electrical.Analog and 
//     added several other new models and improved existing models. 
// </p>
// <p>
// <b>New components</b>
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.</b></td></tr>
//   <tr><td>Continuous.Der</td><td>Derivative of input (= analytic differentations)</td></tr>
//   <tr><td><b><i>Examples</i></b></td><td>Demonstration examples of the components of this package</td></tr>
//   <tr><td>Nonlinear.VariableLimiter</td><td>Limit the range of a signal with variable limits</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Interfaces.</b></td></tr>
//   <tr><td>RealPort</td><td>Real port (both input/output possible)</td></tr>
//   <tr><td>IntegerPort</td><td>Integer port (both input/output possible)</td></tr>
//   <tr><td>BooleanPort</td><td>Boolean port (both input/output possible)</td></tr>
//   <tr><td>SIMO</td><td>Single Input Multiple Output continuous control block</td></tr>
//   <tr><td>IntegerBlockIcon</td><td>Basic graphical layout of Integer block</td></tr>
//   <tr><td>IntegerMO</td><td>Multiple Integer Output continuous control block</td></tr>
//   <tr><td>IntegerSignalSource</td><td>Base class for continuous Integer signal source</td></tr>
//   <tr><td>IntegerMIBooleanMOs</td><td>Multiple Integer Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
//   <tr><td>BooleanMIMOs</td><td>Multiple Input Multiple Output continuous control block with same number of inputs and outputs of boolean type</td></tr>
//   <tr><td><b><i>BusAdaptors</i></b></td><td>Components to send signals to the bus or receive signals from the bus</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
//   <tr><td>RealToInteger</td><td>Convert real to integer signals</td></tr>
//   <tr><td>IntegerToReal</td><td>Convert integer to real signals</td></tr>
//   <tr><td>Max</td><td>Pass through the largest signal</td></tr>
//   <tr><td>Min</td><td>Pass through the smallest signal</td></tr>
//   <tr><td>Edge</td><td>Indicates rising edge of boolean signal</td></tr>
//   <tr><td>BooleanChange</td><td>Indicates boolean signal changing</td></tr>
//   <tr><td>IntegerChange</td><td>Indicates integer signal changing</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
//   <tr><td>IntegerConstant</td><td>Generate constant signals of type Integer</td></tr>
//   <tr><td>IntegerStep</td><td>Generate step signals of type Integer</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
//   <tr><td>HeatingResistor</td><td>Temperature dependent electrical resistor</td></tr>
//   <tr><td>OpAmp</td><td>Simple nonideal model of an OpAmp with limitation</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Ideal.</b></td></tr>
//   <tr><td>IdealCommutingSwitch</td><td>Ideal commuting switch</td></tr>
//   <tr><td>IdealIntermediateSwitch</td><td>Ideal intermediate switch</td></tr>
//   <tr><td>ControlledIdealCommutingSwitch</td><td>Controlled ideal commuting switch</td></tr>
//   <tr><td>ControlledIdealIntermediateSwitch</td><td>Controlled ideal intermediate switch</td></tr>
//   <tr><td>IdealOpAmpLimited</td><td>Ideal operational amplifier with limitation</td></tr>
//   <tr><td>IdealOpeningSwitch</td><td>Ideal opener</td></tr>
//   <tr><td>IdealClosingSwitch</td><td>Ideal closer</td></tr>
//   <tr><td>ControlledIdealOpeningSwitch</td><td>Controlled ideal opener</td></tr>
//   <tr><td>ControlledIdealClosingSwitch</td><td>Controlled ideal closer</td></tr>
//   
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Lines.</b></td></tr>
//   <tr><td>TLine1</td><td>Lossless transmission line (Z0, TD)</td></tr>
//   <tr><td>TLine2</td><td>Lossless transmission line (Z0, F, NL)</td></tr>
//   <tr><td>TLine2</td><td>Lossless transmission line (Z0, F)</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
//   <tr><td>Function</td><td>Icon for a function</td></tr>
//   <tr><td>Record</td><td>Icon for a record</td></tr>
//   <tr><td>Enumeration</td><td>Icon for an enumeration</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Math.</b></td></tr>
//   <tr><td>tempInterpol2</td><td>temporary routine for vectorized linear interpolation (will be removed)</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td>Examples.LossyGearDemo1</td><td>Example to show that gear efficiency may lead to stuck motion</td></tr>
//   <tr><td>Examples.LossyGearDemo2</td><td>Example to show combination of LossyGear and BearingFriction</td></tr>
//   <tr><td>LossyGear</td><td>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</td></tr>
//   <tr><td>Gear2</td><td>Realistic model of a gearbox (based on LossyGear)</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
//   <tr><td><b><i>Conversions</i></b></td><td>Conversion functions to/from non SI units and type definitions of non SI units</td></tr>
//   <tr><td>EnergyFlowRate</td><td>Same definition as <i>Power</i></td></tr>
//   <tr><td>EnthalpyFlowRate</td><td><tt>Real (final quantity=\"EnthalpyFlowRate\", final unit=\"W\")</tt></td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
//   <tr><td><b><i>Thermal.HeatTransfer</i></b></td><td>1-dimensional heat transfer with lumped elements</td></tr>
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Discrete.</b></td></tr>
//   <tr><td>TriggeredSampler</td><td>Triggered sampling of continuous signals</td></tr>
//   <tr><td>TriggeredMax</td><td>Compute maximum, absolute value of continuous signal at trigger instants</td></tr>
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.Interfaces.</b></td></tr>
//   <tr><td>BooleanMIRealMOs</td><td>Multiple Boolean Input Multiple Real Output continuous control block with same number of inputs and outputs</td></tr>
//   <tr><td>RealMIBooleanMOs</td><td>Multiple Real Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.</b></td></tr>
//   <tr><td>TriggeredTrapezoid</td><td>Triggered trapezoid generator</td></tr>
//   <tr><td>Hysteresis</td><td>Transform Real to Boolean with Hysteresis</td></tr>
//   <tr><td>OnOffController</td><td>On-off controller</td></tr>
//   <tr><td>Compare</td><td>True, if signal of inPort1 is larger than signal of inPort2</td></tr>
//   <tr><td>ZeroCrossing</td><td>Trigger zero crossing of input signal</td></tr>
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.</b></td></tr>
//   <tr><td>Blocks.Multiplexer.Extractor</td><td>Extract scalar signal out of signal vector dependent on IntegerRealInput index</td></tr>
//   <tr><td>Tables.CombiTable1Ds</td><td>Table look-up in one dimension (matrix/file) with only single input</td></tr>
// </table>
// <p>
// <b>Package-specific Changes</b>
// </p>
// <ul>
//   <li>All example models made <b>encapsulated</b></li>
//   <li>Upper case constants changed to lower case (cf. Modelica.Constants)</li>
//   <li>Introduced Modelica.SIunits.Wavelength due to typo \"Wavelenght\"</li>
//   <li>Introduced ModelicaAdditions.Blocks.Logical.Interfaces.Comparison due to typo \"Comparision\"</li>
//   <li>Changed these components of *.Blocks to <tt>block</tt> class, which have not been already of block type</li>
//   <li>Changed *.Interfaces.RelativeSensor to <tt>partial</tt> models</li>
// </ul>
// <p>
// <b>Class-specific Changes</b>
// </p>
// <p>
// <i>Modelica.SIunits</i>
// </p>
// <p>Removed <tt>final</tt> from quantity attribute for <i>Mass</i> and <i>MassFlowRate</i>.</p>
// <p>
// <i>Modelica.Blocks.Math.Sum</i>
// </p>
// <p>Implemented avoiding algorithm section, which would lead to expensive function calls.</p>
// <p><i>Modelica.Blocks.Sources.Step</i></p>
// <pre>
//   block Step \"Generate step signals of type Real\"
//     parameter Real height[:]={1} \"Heights of steps\";
// <b> // parameter Real offset[:]={0} \"Offsets of output signals\";
//  // parameter SIunits.Time startTime[:]={0} \"Output = offset for time < startTime\";
//  // extends Interfaces.MO          (final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));
//     extends Interfaces.SignalSource(final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));</b>
// </pre>
// <p><i>Modelica.Blocks.Sources.Exponentials</i></p>
// <p>Replaced usage of built-in function <tt>exp</tt> by Modelica.Math.exp.</p>
// <p><i>Modelica.Blocks.Sources.TimeTable</i></p>
// <p>Interface definition changed from</p>
// <pre>    parameter Real table[:, :]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// <p>to</p>
// <pre>    parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// <p>Did the same for subfunction <i>getInterpolationCoefficients</i>.</p>
// <p>Bug in <i>getInterpolationCoefficients</i> for startTime <> 0 fixed:</p>
// <pre>        ...
//         end if;
//       end if;
//       <b>// Take into account startTime \"a*(time - startTime) + b\"
//       b := b - a*startTime;</b>
//     end getInterpolationCoefficients;
// </pre>
// <p><i>Modelica.Blocks.Sources.BooleanStep</i></p>
// <pre>
//   block BooleanStep \"Generate step signals of type Boolean\"
//     parameter SIunits.Time startTime[:]={0} \"Time instants of steps\";
//     <b>parameter Boolean startValue[size(startTime, 1)]=fill(false, size(startTime, 1)) \"Output before startTime\";</b>
//     extends Interfaces.BooleanSignalSource(final nout=size(startTime, 1));
//   equation
//     for i in 1:nout loop
//  <b>//   outPort.signal[i] = time >= startTime[i];
//       outPort.signal[i] = if time >= startTime[i] then not startValue[i] else startValue[i];</b>
//     end for;
//   end BooleanStep;
// </pre>
// <p>
// <i>Modelica.Electrical.Analog</i></p>
// <p>Corrected table of values and default for Beta by dividing them by 1000
// (consistent with the values used in the NAND-example model):
// </p>
// <ul>
// <li>Semiconductors.PMOS</li>
// <li>Semiconductors.NMOS</li>
// </ul>
// <p>Corrected parameter defaults, unit and description for TrapezoidCurrent.
// This makes the parameters consistent with their use in the model.
// Models specifying parameter values are not changed.
// Models not specifying parameter values did not generate trapezoids previously.
// </p>
// <p>Icon layer background changed from transparent to white:</p>
// <ul>
//   <li>Basic.Gyrator</li>
//   <li>Basic.EMF</li>
//   <li>Ideal.Idle</li>
//   <li>Ideal.Short</li>
// </ul>
// <p>Basic.Transformer: Replaced invalid escape characters '\\ ' and '\\[newline]' in documentation by '|'.</p>
// <p><i>Modelica.Mechanics.Rotational</i></p>
// <p>Removed arrows and names documentation from flanges in diagram layer</p>
// <p><i>Modelica.Mechanics.Rotational.Interfaces.FrictionBase</i></p>
// <p><i>Modelica.Mechanics.Rotational.Position</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>Modelica.Mechanics.Rotational.RelativeStates/i></p>
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// <p><i>Modelica.Mechanics.Translational.Interfaces.flange_b</i></p>
// <p>Attribute <b>fillColor=7</b> added to Rectangle on Icon layer, i.e. it is now
// filled with white and not transparent any more.</p>
// <p><i>Modelica.Mechanics.Translational.Position</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>Modelica.Mechanics.Translational.RelativeStates</i></p>
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// <p><i>Modelica.Mechanics.Translational.Stop</i></p>
// <p>Use <tt>stateSelect = StateSelect.prefer</tt>.</p>
// <p><i>Modelica.Mechanics.Translational.Examples.PreLoad</i></p>
// <p>Improved documentation and coordinate system used for example.</p>
// <p><i>ModelicaAdditions.Blocks.Nonlinear.PadeDelay</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>ModelicaAdditions.HeatFlow1D.Interfaces</i></p>
// <p>Definition of connectors <i>Surface_a</i> and <i>Surface_b</i>:<br>
// <tt>flow SIunits.HeatFlux q;</tt> changed to <tt>flow SIunits.HeatFlowRate q;</tt></p>
// <p><i>MultiBody.Parts.InertialSystem</i></p>
// <p>Icon corrected.</p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_1_5;
//       class Version_1_4 "Version 1.4"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Version 1.4.1 (June 28, 2001)</font></h3>
// <ul>
// <li>Several minor bugs fixed. </li>
// <li>New models:<br>
//     Modelica.Blocks.Interfaces.IntegerRealInput/IntegerRealOutput,<br>
//     Modelica.Blocks.Math.TwoInputs/TwoOutputs<br>
//     Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin,<br>
//     Modelica.Mechanics.Rotational.Move,<br>
//     Modelica.Mechanics.Translational.Move.<br>
//     </li>
// </ul>
// <hr>
// <h3><font color=\"#008000\">Version 1.4.1beta1 (February 12, 2001)</font></h3>
// <p> Adapted to Modelica 1.4</p>
// <hr>
// <h3><font color=\"#008000\">Version 1.3.2beta2 (June 20, 2000)</font></h3>
// <ul>
//     <li>New subpackage Modelica.Mechanics.<b>Translational</b></li>
//     <li>Changes to Modelica.Mechanics.<b>Rotational</b>:<br>
//        New elements:
// <pre>
//    IdealGearR2T    Ideal gear transforming rotational in translational motion.
//    Position        Forced movement of a flange with a reference angle
//                    given as input signal
//    RelativeStates  Definition of relative state variables
// </pre>
// </li>
//     <li>Changes to Modelica.<b>SIunits</b>:<br>
//       Introduced new types:<br>
//       type Temperature = ThermodynamicTemperature;<br>
//       types DerDensityByEnthalpy, DerDensityByPressure,
//       DerDensityByTemperature, DerEnthalpyByPressure,
//       DerEnergyByDensity, DerEnergyByPressure<br>
//       Attribute \"final\" removed from min and max values
//       in order that these values can still be changed to narrow
//       the allowed range of values.<br>
//       Quantity=\"Stress\" removed from type \"Stress\", in order
//       that a type \"Stress\" can be connected to a type \"Pressure\".</li>
//     <li>Changes to Modelica.<b>Icons</b>:<br>
//        New icons for motors and gearboxes.</li>
//     <li>Changes to Modelica.<b>Blocks.Interfaces</b>:<br>
//        Introduced a replaceable signal type into
//        Blocks.Interfaces.RealInput/RealOutput:
// <pre>
//    replaceable type SignalType = Real
// </pre>
//        in order that the type of the signal of an input/output block
//        can be changed to a physical type, for example:
// <pre>
//    Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
// </pre>
//       </li></ul>
// </li>
// </ul>
// <hr>
// <h3><font color=\"#008000\">Version 1.3.1 (Dec. 13, 1999)</font></h3>
// <p>
// First official release of the library.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Version_1_4;
//     end ReleaseNotes;
//     class Contact "Contact"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// <dl>
// <dt>The development of the Modelica package is organized by<br>&nbsp;</dt>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br> 
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br></dd>
// </dl>
// <p>
// This library is developed by several people from
// the Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// In particular, the following people have directly contributed
// (many more people have contributed to the design):
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Peter Beater</b> </td
//       <td> University of Paderborn, Germany</td>
//       <td> Modelica.Mechanics.Translational </td>
//   </tr>
//   <tr><td><b>Dag Br&uuml;ck</b> </td
//       <td> Dynasim AB, Lund, Sweden</td>
//       <td> Modelica.Utilities</td>
//   </tr>
// 
//   <tr><td><b>Francesco Casella</b> </td
//       <td> Politecnico di Milano, Milano, Italy</td>
//       <td> Modelica.Media</td>
//   </tr>
// 
//   <tr><td><b>Christoph Clauss</b> </td
//       <td> Fraunhofer Institute for Integrated Circuits,<br> Dresden, Germany</td>
//       <td> Modelica.Electrical.Analog<br> 
//            Modelica.Electrical.Digital</td>
//   </tr>
// 
//   <tr><td><b>Jonas Eborn</b> </td
//       <td> Modelon AB, Lund, Sweden</td>
//       <td> Modelica.Media</td>
//   </tr>
// 
//   <tr><td><b>Hilding Elmqvist</b> </td
//       <td> Dynasim AB, Lund, Sweden</td>
//       <td> Modelica.Mechanics.MultiBody<br>
//            Modelica.Media<br>
//            Modelica.StateGraph<br>
//            Modelica.Utilities<br>
//            Conversion from 1.6 to 2.0</td>
//   </tr>
// 
//   <tr><td><b>R&uuml;diger Franke</b> </td
//       <td> ABB Corporate Research,<br>Ladenburg, German</td>
//       <td> Modelica.Media</td>
//   </tr>
// 
//   <tr><td><b>Anton Haumer</b> </td
//       <td> Consultant, St.Andrae-Woerdern,<br>Austria</td>
//       <td> Modelica.Electrical.Machines<br>
//            Modelica.Electrical.Multiphase<br>
//            Modelica.Mechanics.Rotational<br>
//            Modelica.Thermal.FluidHeatFlow</td>
//   </tr>
// 
//   <tr><td><b>Hans-Dieter Joos</b> </td
//       <td> Institute of Robotics and Mechatronics<br>
//            DLR, German Aerospace Center, <br>
//            Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Math.Matrices</td>
//   </tr>
// 
//   <tr><td><b>Christian Kral</b> </td
//       <td> arsenal research, Vienna, Austria</td>
//       <td> Modelica.Electrical.Machines<br>
//            Modelica.Thermal.FluidHeatFlow</td>
//   </tr>
// 
//   <tr><td><b>Sven Erik Mattsson</b> </td
//       <td> Dynasim AB, Lund, Sweden</td>
//       <td> Modelica.Mechanics.MultiBody</td>
//   </tr>
//   <tr><td><b>Hans Olsson</b> </td
//       <td> Dynasim AB, Lund, Sweden</td>
//       <td> Modelica.Blocks<br>
//            Modelica.Math.Matrices<br>
//            Modelica.Utilities<br>
//            Conversion from 1.6 to 2.0</td>
//   </tr>
//   <tr><td><b>Martin Otter</b> </td
//       <td> Institute of Robotics and Mechatronics<br>
//            DLR, German Aerospace Center, <br>
//            Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Blocks<br> 
//            Modelica.Mechanics.MultiBody<br>
//            Modelica.Mechanics.Rotational<br>
//            Modelica.Math<br>
//            Modelica.Media<br>
//            Modelica.SIunits<br>
//            Modelica.StateGraph<br>
//            Modelica.Thermal<br>
//            Modelica.Utilities<br>
//            ModelicaReference<br>
//            Conversion from 1.6 to 2.0</td>
//   </tr>
// 
//   <tr><td><b>Katrin Pr&ouml;l&szlig;</b> </td
//       <td> Department of Technical Thermodynamics,<br>
//            Technical University Hamburg-Harburg,<br>Germany</td>
//       <td> Modelica.Media</td>
//   </tr>
// 
//   <tr><td><b>Christoph C. Richter</b> </td
//       <td> Institut fr Thermodynamik, <br>
//            Technische Universit&auml;t Braunschweig, <br>
//            Germany</td>
//       <td> Modelica.Media</td>
//   </tr>
// 
//   <tr><td><b>Andr&eacute; Schneider</b> </td
//       <td> Fraunhofer Institute for Integrated Circuits,<br> Dresden, Germany</td>
//       <td> Modelica.Electrical.Analog<br> 
//            Modelica.Electrical.Digital</td>
//   </tr>
//   <tr><td><b>Christian Schweiger</b> </td
//       <td> Institute of Robotics and Mechatronics,<br>
//            DLR, German Aerospace Center,<br> 
//            Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Mechanics.Rotational<br>
//            ModelicaReference<br>
//            Conversion from 1.6 to 2.0</td>
//   </tr>
//   <tr><td><b>Michael Tiller</b> </td
//       <td> Emmeskay, Inc., Dearborn, MI, U.S.A, <br>
//            (previously Ford Motor Company, Dearborn) </td>
//       <td> Modelica.Media<br>
//            Modelica.Thermal</td>
//   </tr>
//   <tr><td><b>Hubertus Tummescheit</b> </td
//       <td> Modelon AB, Lund, Sweden </td>
//       <td> Modelica.Media<br>
//            Modelica.Thermal</td>
//   </tr>
//   <tr><td><b>Nico Walter</b> </td
//       <td> Master thesis at HTWK Leipzig<br>
//            (Prof. R. M&uuml;ller) and<br>
//            DLR Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Math.Matrices</td>
//   </tr>
// </table>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Contact;
//     class ModelicaLicense "Modelica License"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>The Modelica License 
// (Version 1.1 of June 30, 2000) </font></h3>
// <p>Redistribution and use in source and binary forms, with or without
// modification are permitted, provided that the following conditions are met:
// <ol>
// <li>
// The author and copyright notices in the source files, these license conditions
// and the disclaimer below are (a) retained and (b) reproduced in the documentation
// provided with the distribution.</li>
// <li>
// Modifications of the original source files are allowed, provided that a
// prominent notice is inserted in each changed file and the accompanying
// documentation, stating how and when the file was modified, and provided
// that the conditions under (1) are met.</li>
// <li>
// It is not allowed to charge a fee for the original version or a modified
// version of the software, besides a reasonable fee for distribution and support.
// Distribution in aggregate with other (possibly commercial) programs
// as part of a larger (possibly commercial) software distribution is permitted,
// provided that it is not advertised as a product of your own.</li>
// </ol>
// <h4><font color=\"#008000\">Disclaimer</font></h4>
// <p>The software (sources, binaries, etc.) in their original or in a modified
// form are provided
// \"as is\" and the copyright holders assume no responsibility for its contents
// what so ever. Any express or implied warranties, including, but not
// limited to, the implied warranties of merchantability and fitness for a
// particular purpose are <b>disclaimed</b>. <b>In no event</b> shall the
// copyright holders, or any party who modify and/or redistribute the package,
// <b>be liable</b> for any direct, indirect, incidental, special, exemplary, or
// consequential damages, arising in any way out of the use of this software,
// even if advised of the possibility of such damage.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end ModelicaLicense;
//   end UsersGuide;
//   package Blocks "Library for basic input/output control blocks (continuous, discrete, logical, table blocks)"
//     import SI = Modelica.SIunits;
//     extends Modelica.Icons.Library2;
//     annotation(preferedView = "info", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -32, -35},{16, -6}}),Rectangle(visible = true, extent = {{ -32, -85},{16, -56}}),Line(visible = true, points = {{16, -20},{49, -20},{49, -71},{16, -71}}),Line(visible = true, points = {{ -32, -72},{ -64, -72},{ -64, -21},{ -32, -21}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{16, -71},{29, -67},{29, -74},{16, -71}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -32, -21},{ -46, -17},{ -46, -25},{ -32, -21}})}), Documentation(info = "<html>
// <p>
// This library contains input/output blocks to build up block diagrams.
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// <br>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 23, 2004</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Introduced new block connectors and adapated all blocks to the new connectors.
//        Included subpackages Continuous, Discrete, Logical, Nonlinear from
//        package ModelicaAdditions.Blocks.
//        Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
//        and in the new package Modelica.Blocks.Tables.
//        Added new blocks to Blocks.Sources and Blocks.Logical.
//        </li>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New subpackage Examples, additional components.
//        </li>
// <li><i>June 20, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
//        Michael Tiller:<br>
//        Introduced a replaceable signal type into
//        Blocks.Interfaces.RealInput/RealOutput:
// <pre>
//    replaceable type SignalType = Real
// </pre>
//        in order that the type of the signal of an input/output block
//        can be changed to a physical type, for example:
// <pre>
//    Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
// </pre>
//       </li>
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renamed to Blocks. New subpackages Math, Nonlinear.
//        Additional components in subpackages Interfaces, Continuous
//        and Sources. </li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package Examples "Demonstration examples of the components of this package"
//       extends Icons.Library;
//       model PID_Controller "Demonstrate usage of the Continuous.LimPID controller"
//         extends Modelica.Icons.Example;
//         parameter Modelica.SIunits.Angle driveAngle = 1.57;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, extent = {{ -99,8},{ -32,48}}),Text(visible = true, fillColor = {255,0,0}, extent = {{ -98,51},{ -31,59}}, textString = "reference speed generation", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -98, -52},{ -60, -46}}, textString = "PI controller", fontName = "Arial"),Line(visible = true, points = {{ -76, -44},{ -57, -23}}, color = {255,0,0}, arrow = {Arrow.None,Arrow.Filled}),Rectangle(visible = true, lineColor = {255,0,0}, extent = {{ -25, -50},{99,6}}),Text(visible = true, fillColor = {255,0,0}, extent = {{4,7},{71,14}}, textString = "plant (simple drive train)", fontName = "Arial")}), experiment(StopTime = 4), experimentSetupOutput, Documentation(info = "<html>
// 
// <p>
// This is a simple drive train controlled by a PID controller:
// </p>
// 
// <ul>
// <li> The two blocks \"kinematic_PTP\" and \"integrator\" are used to generate
//      the reference speed (= constant acceleration phase, constant speed phase,
//      constant deceleration phase until inertia is at rest). To check
//      whether the system starts in steady state, the reference speed is
//      zero until time = 0.5 s and then follows the sketched trajectory.</li>
// 
// <li> The block \"PI\" is an instance of \"Blocks.Continuous.LimPID\" which is
//      a PID controller where several practical important aspects, such as
//      anti-windup-compensation has been added. In this case, the control block
//      is used as PI controller.</li>
// 
// <li> The output of the controller is a torque that drives a motor inertia
//      \"inertia1\". Via a compliant spring/damper component, the load
//      inertia \"inertia2\" is attached. A constant external torque of 10 Nm
//      is acting on the load inertia.</li>
// </ul>
// 
// <p>
// The PI controller settings included \"limitAtInit=false\", in order that
// the controller output limits of 12 Nm are removed from the initialization
// problem. 
// </p>
// 
// <p>
// The PI controller is initialized in steady state (initType=SteadyState)
// and the drive shall also be initialized in steady state.
// However, it is not possible to initialize \"inertia1\" in SteadyState, because
// \"der(inertia1.phi)=inertia1.w=0\" is an input to the PI controller that
// defines that the derivative of the integrator state is zero (= the same
// condition that was already defined by option SteadyState of the PI controller).
// Furthermore, one initial condition is missing, because the absolute position
// of inertia1 or inertia2 is not defined. The solution shown in this examples is
// to initialize the angle and the angular acceleration of \"inertia1\".
// </p>
// 
// <p>
// In the following figure, results of a typical simulation are shown:
// </p>
// 
// <p>
// <img src=\"../Images/Blocks/PID_controller.png\"><br>
// <img src=\"../Images/Blocks/PID_controller2.png\">
// </p>
// 
// <p>
// In the upper figure the reference speed (= integrator.y) and
// the actual speed (= inertia1.w) are shown. As can be seen,
// the system initializes in steady state, since no transients
// are present. The inertia follows the reference speed quite good
// until the end of the constant speed phase. Then there is a deviation.
// In the lower figure the reason can be seen: The output of the
// controller (PI.y) is in its limits. The anti-windup compensation
// works reasonably, since the input to the limiter (PI.limiter.u)
// is forced back to its limit after a transient phase.
// </p>
// 
// </html>"), Diagram(coordinateSystem(scale = 0, extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Continuous.LimPID PI(k = 100, Ti = 0.1, yMax = 12, Ni = 0.1, initType = Modelica.Blocks.Types.Init.SteadyState, limitsAtInit = false, controllerType = Modelica.Blocks.Types.SimpleController.PI) annotation(Placement(visible = true, transformation(origin = { -46, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.Inertia inertia1(initType = Modelica.Mechanics.Rotational.Types.Init.InitialAngleAcceleration) annotation(Placement(visible = true, transformation(origin = {12, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.Torque torque annotation(Placement(visible = true, transformation(origin = { -15, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.SpringDamper spring(c = 10000.0, d = 100, initType = Modelica.Mechanics.Rotational.Types.Init.SteadyState, stateSelection = Modelica.Blocks.Types.StateSelection.Prefer) annotation(Placement(visible = true, transformation(origin = {42, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.Inertia inertia2(J = 2) annotation(Placement(visible = true, transformation(origin = {70, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Sources.KinematicPTP kinematicPTP(startTime = 0.5, deltaq = {driveAngle}) annotation(Placement(visible = true, transformation(origin = { -82,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Continuous.Integrator integrator(initType = Modelica.Blocks.Types.Init.InitialState) annotation(Placement(visible = true, transformation(origin = { -53,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation(Placement(visible = true, transformation(origin = {12, -40}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//         Modelica.Mechanics.Rotational.ConstantTorque loadTorque(tau_constant = 10) annotation(Placement(visible = true, transformation(origin = {93, -10}, extent = {{5, -5},{ -5,5}}, rotation = 0)));
// 
//       equation 
//         connect(integrator.y,PI.u_s) annotation(Line(visible = true, points = {{ -42,30},{ -37,30},{ -37,11},{ -67,11},{ -67, -10},{ -58, -10}}, color = {0,0,191}));
//         connect(speedSensor.w,PI.u_m) annotation(Line(visible = true, points = {{1, -40},{ -46, -40},{ -46, -22}}, color = {0,0,191}));
//         connect(PI.y,torque.tau) annotation(Line(visible = true, points = {{ -35, -10},{ -27, -10}}, color = {0,0,191}));
//         connect(loadTorque.flange,inertia2.flange_b) annotation(Line(visible = true, points = {{88, -10},{80, -10}}));
//         connect(speedSensor.flange_a,inertia1.flange_b) annotation(Line(visible = true, points = {{22, -40},{22, -10}}));
//         connect(kinematicPTP.y[1],integrator.u) annotation(Line(visible = true, points = {{ -71,30},{ -65,30}}, color = {0,0,191}));
//         connect(torque.flange_b,inertia1.flange_a) annotation(Line(visible = true, points = {{ -5, -10},{2, -10}}));
//         connect(inertia1.flange_b,spring.flange_a) annotation(Line(visible = true, points = {{22, -10},{32, -10}}));
//         connect(spring.flange_b,inertia2.flange_a) annotation(Line(visible = true, points = {{52, -10},{60, -10}}));
//       end PID_Controller;
//       model ShowLogicalSources
//         extends Modelica.Icons.Example;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 10), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Sources.BooleanTable table(table = {2,4,6,8}) annotation(Placement(visible = true, transformation(origin = { -50, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.BooleanConstant const annotation(Placement(visible = true, transformation(origin = { -50,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.BooleanStep step(startTime = 4) annotation(Placement(visible = true, transformation(origin = { -50,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.BooleanPulse pulse(period = 1.5) annotation(Placement(visible = true, transformation(origin = { -50, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.SampleTrigger sample(period = 0.5) annotation(Placement(visible = true, transformation(origin = { -50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.BooleanExpression booleanExpression(y = pulse.y and step.y) annotation(Placement(visible = true, transformation(origin = {50,30}, extent = {{ -30, -10},{30,10}}, rotation = 0)));
//       end ShowLogicalSources;
//       model LogicalNetwork1
//         extends Modelica.Icons.Example;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 10), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Sources.BooleanTable table2(table = {1,3,5,7}) annotation(Placement(visible = true, transformation(origin = { -70, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.BooleanTable table1(table = {2,4,6,8}) annotation(Placement(visible = true, transformation(origin = { -70,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Logical.Not Not1 annotation(Placement(visible = true, transformation(origin = { -30, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Logical.And And1 annotation(Placement(visible = true, transformation(origin = {10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Logical.Or Or1 annotation(Placement(visible = true, transformation(origin = {50,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Logical.Pre Pre1 annotation(Placement(visible = true, transformation(origin = { -30, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(Or1.y,Pre1.u) annotation(Line(visible = true, points = {{61,30},{68,30},{68, -70},{ -60, -70},{ -60, -50},{ -42, -50}}, color = {255,0,255}));
//         connect(Pre1.y,And1.u2) annotation(Line(visible = true, points = {{ -19, -50},{ -10, -50},{ -10, -18},{ -2, -18}}, color = {255,0,255}));
//         connect(Not1.y,And1.u1) annotation(Line(visible = true, points = {{ -19, -10},{ -2, -10}}, color = {255,0,255}));
//         connect(table1.y,Or1.u1) annotation(Line(visible = true, points = {{ -59,30},{38,30}}, color = {255,0,255}));
//         connect(And1.y,Or1.u2) annotation(Line(visible = true, points = {{21, -10},{28, -10},{28,22},{38,22}}, color = {255,0,255}));
//         connect(table2.y,Not1.u) annotation(Line(visible = true, points = {{ -59, -10},{ -42, -10}}, color = {255,0,255}));
//       end LogicalNetwork1;
//       encapsulated model BusUsage "Demonstration of signal bus usage"
//         import Modelica.Icons;
//         import Modelica.Blocks.Interfaces.Adaptors;
//         import Modelica.Blocks.Sources;
//         import Modelica;
//         extends Icons.Example;
//         annotation(experiment(StopTime = 1), preferedView = "info", Documentation(info = "<HTML>
// <p><b>Signal bus concept</b></p>
// <p>
// In technical systems, such as vehicles, robots or satellites, many signals
// are exchanged between components. In a simulation system, these signals
// are  usually modelled by signal connections of input/output blocks.
// Unfortunately, the signal connection structure may become very complicated,
// especially for hierarchical models.
// </p>
// <p>
// The same is also true for real technical systems. To reduce complexity
// and get higher flexibility, many technical systems use data buses to
// exchange data between components. For the same reasons, it is often better
// to use a \"signal bus\" concept also in a Modelica model. This is demonstrated
// at hand of this model (Modelica.Blocks.Examples.BusUsage), see diagram layer:
// </p>
// <ul>
// <li>The thick line in the middle called \"bus\" is just a connector instance
//     which is drawn such that it looks like a \"usual\" bus representation. </li>
// <li>A component, such as \"part\", can be directly connected to the \"bus\",
//     provided it has also a bus connector, or the \"part\" connector is a
//     sub-connector contained in the \"bus\". </li>
// </ul>
// <p>
// Difficulties arise if the input or output connector of an
// input/output block shall be connected directly to a variable
// of a bus because connections can only be performed between
// connectors but not between variables. For convenience,
// single variable connectors for Real, Integer and Boolean
// variables are provided as Modelica.Blocks.Interfaces.<b>RealSignal</b>,
// Modelica.Blocks.Interfaces.<b>IntegerSignal</b>,
// Modelica.Blocks.Interfaces.<b>BooleanSignal</b>.
// For example, the RealSignal connector is basically defined as:
// </p>
// <pre>  <b>connector</b> RealSignal = Real;
// </pre>
// <p>
// This allows a definition of a bus in the form:
// </p>
// <pre>   <b>connector</b> Bus
//       RealSignal r1;
//       RealSignal r2;
//         ...
//    <b>end</b> Bus;
// </pre>
// <p>
// and a connection to r1 and r2 is possible since these are connectors.
// Unfortunately, signals defined in this way have, by default, no unit.
// To improve this situation, a RealSignal is actually defined as
// </p>
// <pre>   <b>connector</b> RealSignal
//       <b>replaceable type</b> SignalType = Real;
//       <b>extends</b> SignalType;
//    <b>end</b> RealSignal;
// </pre>
// <p>
// This allows a redeclaration of the Real type to the desired type, such as:
// </p>
// <pre>   <b>connector</b> Bus
//       <b>import</b> SI=Modelica.SIunits;
//       RealSignal v(<b>redeclare</b> SignalType=SI.Velocity);
//       RealSignal p(<b>redeclare</b> SignalType=SI.Pressure);
//       ...
//    <b>end</b> Bus;
// </pre>
// <p>
// Note, since RealSignal, RealInput and RealOutput have basically
// the same definition, it is possible to directly connector
// from a RealSignal of a bus to a RealInput or RealOutput of
// a block component.
// </p>
// <p>
// If a bus connector contains many signals it is no longer so easy
// to test just one part of a system, because all parts of
// the bus connector must get a value. To simplify this,
// it is practical to provide a <b>RestBus</b> component which
// sets all parts of a bus to a default value when selected
// via the parameter menu. This is also demonstrated in the example
// model (see diagram layer).
// </p>
// <p>Simulate the system for 1 s. The output of the \"gain\" block
// should be the same as the one from the \"generateRealSignal1\"
// block.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         encapsulated package Interfaces "Interfaces specialised for this example"
//           connector MultiPort "Combined port of real and boolean signal"
//             Real myRealSignal;
//             Boolean myBooleanSignal;
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}));
//           end MultiPort;
//           connector Bus "Signal bus"
//             import SI = Modelica.SIunits;
//             import Modelica.Blocks.Interfaces.*;
//             RealSignal realSignal1(redeclare type SignalType = SI.AngularVelocity) "First Real signal (angular velocity)";
//             RealSignal realSignal2 "Second Real signal";
//             IntegerSignal integerSignal "Integer signal";
//             BooleanSignal booleanSignal "Boolean signal";
//             MultiPort multiSignal "Combined signal";
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {127,0,255}, fillColor = {127,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {127,0,255}, extent = {{ -134,108},{134,168}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {127,0,255}, extent = {{ -134,108},{134,168}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, lineColor = {127,0,255}, fillColor = {127,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Documentation(info = "<HTML>
// <p>Defines connector for signalbus.</p>
// </HTML>
// "));
//           end Bus;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Interfaces;
//         encapsulated model Part "Component with MultiPort connector"
//           import Modelica.Blocks.Examples;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, fillPattern = FillPattern.Solid, extent = {{ -100, -60},{100,60}}),Text(visible = true, extent = {{ -106,68},{114,124}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Examples.BusUsage.Interfaces.MultiPort multiSignal annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           multiSignal.myRealSignal = time;
//           multiSignal.myBooleanSignal = time > 0.5;
//         end Part;
//         encapsulated model RestBus "Set default values for bus variables that are not defined elsewhere"
//           import Modelica.Blocks.Examples;
//           parameter Boolean set_realSignal1 = false "Set dummy value for desiredThrottle";
//           parameter Boolean set_realSignal2 = false "Set dummy value for brake";
//           parameter Boolean set_integerSignal = false "Set dummy value for controlLeverPosition";
//           parameter Boolean set_booleanSignal = false "Set dummy value for desiredGear";
//           parameter Boolean set_multiSignal = false "Set dummy value for ignition";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {127,0,255}, extent = {{ -100,96},{100,156}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{46, -40},{88, -10}}, textString = "0", fontName = "Arial"),Text(visible = true, extent = {{ -82,34},{38,62}}, textString = "false", fontName = "Arial"),Line(visible = true, points = {{ -28,24},{ -28, -66},{0, -66},{0, -104},{0, -102}}, color = {127,0,255}),Line(visible = true, points = {{68, -46},{68, -66},{0, -66},{0, -108}}, color = {127,0,255}),Rectangle(visible = true, extent = {{ -90,24},{46,78}}),Rectangle(visible = true, extent = {{40, -46},{92, -4}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Examples.BusUsage.Interfaces.Bus bus annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
// if set_realSignal1 then
//                       bus.realSignal1 = 0;
//           end if;
// if set_realSignal2 then
//                       bus.realSignal2 = 0;
//           end if;
// if set_integerSignal then
//                       bus.integerSignal = 0;
//           end if;
// if set_booleanSignal then
//                       bus.booleanSignal = false;
//           end if;
// if set_multiSignal then
//                       bus.multiSignal.myRealSignal = 0;
//             bus.multiSignal.myBooleanSignal = false;
//           end if;
//         end RestBus;
//         RestBus restBus(set_realSignal2 = true) annotation(Placement(visible = true, transformation(origin = {70,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.IntegerStep integerStep(height = 1, offset = 2, startTime = 0.5) annotation(Placement(visible = true, transformation(origin = {30,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Sources.BooleanStep booleanStep(startTime = 0.5) annotation(Placement(visible = true, transformation(origin = { -10,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Sources.Sine sine annotation(Placement(visible = true, transformation(origin = { -50,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Part part annotation(Placement(visible = true, transformation(origin = { -86, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Math.Gain gain annotation(Placement(visible = true, transformation(origin = { -36, -70}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//       protected 
//         Interfaces.Bus bus annotation(Placement(visible = true, transformation(origin = {0, -17}, extent = {{ -80, -3},{80,3}}, rotation = 0)));
// 
//       equation 
//         connect(gain.u,bus.realSignal1) annotation(Line(visible = true, points = {{ -36, -58},{ -36, -17},{0, -17}}, color = {0,0,255}));
//         connect(integerStep.y,bus.integerSignal) annotation(Line(visible = true, points = {{30,19},{30, -17},{0, -17}}, color = {255,127,0}));
//         connect(booleanStep.y,bus.booleanSignal) annotation(Line(visible = true, points = {{ -10,19},{ -10, -17},{0, -17}}, color = {255,0,255}));
//         connect(sine.y,bus.realSignal1) annotation(Line(visible = true, points = {{ -50,19},{ -50, -17},{0, -17}}, color = {0,0,255}));
//         connect(part.multiSignal,bus.multiSignal) annotation(Line(visible = true, points = {{ -75, -50},{ -58, -50},{ -58, -17},{0, -17}}));
//         connect(restBus.bus,bus) annotation(Line(visible = true, points = {{70,19},{70, -17},{0, -17}}, color = {127,0,255}));
//       end BusUsage;
//       annotation(Documentation(info = "<html>
// <p>
// This package contains example models to demonstrate the
// usage of package blocks.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Examples;
//     package Continuous "Continuous control blocks with internal states"
//       import Modelica.Blocks.Interfaces;
//       import Modelica.SIunits;
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains basic <b>continuous</b> input/output blocks
// described by differential equations.
// </p>
// 
// <p>
// All blocks of this package can be initialized in different
// ways controlled by parameter <b>initType</b>. The possible
// values of initType are defined in 
// <a href=\"Modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
// </p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Name</b></td>
//       <td><b>Description</b></td></tr>
// 
//   <tr><td><b>Init.NoInit</b></td>
//       <td>no initialization (start values are used as guess values with fixed=false)</td></tr>
// 
//   <tr><td><b>Init.SteadyState</b></td>
//       <td>steady state initialization (derivatives of states are zero)</td></tr>
// 
//   <tr><td><b>Init.InitialState</b></td>
//       <td>Initialization with initial states</td></tr>
// 
//   <tr><td><b>Init.InitialOutput</b></td>
//       <td>Initialization with initial outputs (and steady state of the states if possibles)</td></tr>
// </table>
// 
// <p>
// For backward compatibility reasons the default of all blocks is
// <b>Init.NoInit</b>, with the exception of Integrator and LimIntegrator 
// where the default is <b>Init.InitialState</b> (this was the initialization
// defined in version 2.2 of the Modelica standard library).
// </p>
// 
// <p>
// In many cases, the most useful initial condition is
// <b>Init.SteadyState</b> because initial transients are then no longer
// present. The drawback is that in combination with a non-linear
// plant, non-linear algebraic equations occur that might be
// difficult to solve if appropriate guess values for the
// iteration variables are not provided (i.e. start values with fixed=false). 
// However, it is often already useful to just initialize
// the linear blocks from the Continuous blocks library in SteadyState.
// This is uncritical, because only linear algebraic equations occur.
// If Init.NoInit is set, then the start values for the states are
// interpreted as <b>guess</b> values and are propagated to the
// states with fixed=<b>false</b>.
// </p>
// 
// <p>
// Note, initialization with Init.SteadyState is usually difficult 
// for a block that contains an integrator
// (Integrator, LimIntegrator, PI, PID, LimPID).
// This is due to the basic equation of an integrator:
// </p>
// 
// <pre>
//   <b>initial equation</b>
//      <b>der</b>(y) = 0;   // Init.SteadyState
//   <b>equation</b>
//      <b>der</b>(y) = k*u;
// </pre>
// 
// <p>
// The steady state equation leads to the condition that the input to the
// integrator is zero. If the input u is already (directly or indirectly) defined
// by another initial condition, then the initialization problem is <b>singular</b>
// (has none or infinitely many solutions). This situation occurs often
// for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
// since speed is both a state and a derivative, it is always defined by
// Init.InitialState or Init.SteadyState initializtion.
// </p>
// 
// <p>
// In such a case, <b>Init.NoInit</b> has to be selected for the integrator
// and an additional initial equation has to be added to the system
// to which the integrator is connected. E.g., useful initial conditions
// for a 1-dim. rotational inertia controlled by a PI controller are that
// <b>angle</b>, <b>speed</b>, and <b>acceleration</b> of the inertia are zero.
// </p>
// 
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       block Integrator "Output the integral of the input signal"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Integrator gain";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real y_start = 0 "Initial or guess value of output (= state)" annotation(Dialog(group = "Initialization"));
//         extends Interfaces.SISO(y(start = y_start));
//         annotation(Documentation(info = "<html>
// <p>
// This blocks computes output <b>y</b> (element-wise) as
// <i>integral</i> of the input <b>u</b> multiplied with
// the gain <i>k</i>:
// </p>
// <pre>
//          k
//      y = - u
//          s
// </pre>
// 
// <p>
// It might be difficult to initialize the integrator in steady state.
// This is discussed in the description of package
// <a href=\"Modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
// </p>
// 
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -70},{60, -10}}, textString = "I", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "k=%k", fontName = "Arial"),Line(visible = true, points = {{ -80, -80},{80,80}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}}),Text(visible = true, extent = {{ -36,2},{32,60}}, textString = "k", fontName = "Arial"),Text(visible = true, extent = {{ -32, -58},{36,0}}, textString = "s", fontName = "Arial"),Line(visible = true, points = {{ -46,0},{46,0}})}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(y) = 0;
// 
//         elseif initType == Init.InitialState or initType == Init.InitialOutput then
//           y = y_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(y) = k * u;
//       end Integrator;
//       block LimIntegrator "Integrator with limited value of the output"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Integrator gain";
//         parameter Real outMax = 1 "Upper limit of output";
//         parameter Real outMin =  -outMax "Lower limit of output";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Boolean limitsAtInit = true "= false, if limits are ignored during initializiation (i.e., der(y)=k*u)" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real y_start = 0 "Initial or guess value of output (must be in the limits outMin .. outMax)" annotation(Dialog(group = "Initialization"));
//         extends Interfaces.SISO(y(start = y_start));
//         annotation(Documentation(info = "<html>
// <p>
// This blocks computes <b>y</b> (element-wise) as <i>integral</i>
// of the input <b>u</b> multiplied with the gain <i>k</i>. If the
// integral reaches a given upper or lower <i>limit</i> and the
// input will drive the integral outside of this bound, the
// integration is halted and only restarted if the input drives
// the integral away from the bounds.
// </p>
// 
// <p>
// It might be difficult to initialize the integrator in steady state.
// This is discussed in the description of package
// <a href=\"Modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
// </p>
// 
// <p>
// If parameter <b>limitAtInit</b> = <b>false</b>, the limits of the
// integrator are removed from the initialization problem which 
// leads to a much simpler equation system. After initialization has been
// performed, it is checked via an assert whether the output is in the
// defined limits. For backward compatibility reasons 
// <b>limitAtInit</b> = <b>true</b>. In most cases it is best
// to use <b>limitAtInit</b> = <b>false</b>.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{20,20},{80,20}}),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -70},{60, -10}}, textString = "I", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "k=%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -54, -48},{ -4,46}}, textString = "lim", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}}),Text(visible = true, extent = {{ -8,2},{60,60}}, textString = "k", fontName = "Arial"),Text(visible = true, extent = {{ -8, -60},{60, -2}}, textString = "s", fontName = "Arial"),Line(visible = true, points = {{4,0},{46,0}})}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(y) = 0;
// 
//         elseif initType == Init.InitialState or initType == Init.InitialOutput then
//           y = y_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         if initial() and not limitsAtInit then
//           der(y) = k * u;
//           assert(y >= outMin - 0.01 * abs(outMin) and y <= outMax + 0.01 * abs(outMax), "LimIntegrator: During initialization the limits have been ignored.\n" + "However, the result is that the output y is not within the required limits:\n" + "  y = " + String(y) + ", outMin = " + String(outMin) + ", outMax = " + String(outMax));
// 
//         else
//           der(y) = smooth(0, if y < outMin and u < 0 or y > outMax and u > 0 then 0 else k * u);
// 
//         end if;
//       end LimIntegrator;
//       block Derivative "Approximated derivative block"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Gains";
//         parameter SIunits.Time T(min = Modelica.Constants.small) = 0.01 "Time constants (T>0 required; T=0 is ideal derivative block)";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x_start = 0 "Initial or guess value of state" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0 "Initial value of output (= state)" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         extends Interfaces.SISO;
//         output Real x(start = x_start) "State of block";
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks defines the transfer function between the
// input u and the output y
// (element-wise) as <i>approximated derivative</i>:
// </p>
// <pre>
//              k * s
//      y = ------------ * u
//             T * s + 1
// </pre>
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general block <b>TransferFunction</b> instead
// and model a derivative block with parameters<br>
// b = {k,0}, a = {T, 1}.
// </p>
//  
// <p>
// If k=0, the block reduces to y=0.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -80,60},{ -80,60},{ -70,17.95},{ -60, -11.46},{ -50, -32.05},{ -40, -46.45},{ -30, -56.53},{ -20, -63.58},{ -10, -68.51},{0, -71.96},{10, -74.37},{20, -76.06},{30, -77.25},{40, -78.07},{50, -78.65},{60, -79.06}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -30,14},{86,60}}, textString = "DT1", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "k=%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -54,10},{50,52}}, textString = "k s", fontName = "Arial"),Text(visible = true, extent = {{ -54, -52},{52, -6}}, textString = "T s + 1", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{50,0}}),Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//       protected 
//         parameter Boolean zeroGain = abs(k) < Modelica.Constants.eps;
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x) = 0;
// 
//         elseif initType == Init.InitialState then
//           x = x_start;
// 
// 
//         elseif initType == Init.InitialOutput then
//           if zeroGain then
//             x = u;
// 
//           else
//             y = y_start;
// 
//           end if;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(x) = if zeroGain then 0 else (u - x) / T;
//         y = if zeroGain then 0 else k / T * (u - x);
//       end Derivative;
//       block FirstOrder "First order transfer function block (= 1 pole)"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Gain";
//         parameter SIunits.Time T = 1 "Time Constant";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (InitialState and InitialOutput are identical)" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real y_start = 0 "Initial or guess value of output (= state)" annotation(Dialog(group = "Initialization"));
//         extends Interfaces.SISO(y(start = y_start));
//         annotation(Documentation(info = "<HTML>
// <p>
// This blocks defines the transfer function between the input u
// and the output y (element-wise) as <i>first order</i> system:
// </p>
// <pre>
//                k
//      y = ------------ * u
//             T * s + 1
// </pre>
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general block <b>TransferFunction</b> instead
// and model a first order SISO system with parameters<br>
// b = {k}, a = {T, 1}.
// </p>
// <pre>
// Example:
//    parameter: k = 0.3, T = 0.4
//    results in:
//              0.3
//       y = ----------- * u
//           0.4 s + 1.0
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -70, -45.11},{ -60, -19.58},{ -50, -0.9087},{ -40,12.75},{ -30,22.75},{ -20,30.06},{ -10,35.41},{0,39.33},{10,42.19},{20,44.29},{30,45.82},{40,46.94},{50,47.76},{60,48.36},{70,48.8},{80,49.12}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -60},{60,0}}, textString = "PT1", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "T=%T", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -48,8},{50,52}}, textString = "k", fontName = "Arial"),Text(visible = true, extent = {{ -54, -56},{56, -6}}, textString = "T s + 1", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{50,0}}),Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(y) = 0;
// 
//         elseif initType == Init.InitialState or initType == Init.InitialOutput then
//           y = y_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(y) = (k * u - y) / T;
//       end FirstOrder;
//       block SecondOrder "Second order transfer function block (= 2 poles)"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Gain";
//         parameter Real w = 1 "Angular frequency";
//         parameter Real D = 1 "Damping";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (InitialState and InitialOutput are identical)" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real y_start = 0 "Initial or guess value of output (= state)" annotation(Dialog(group = "Initialization"));
//         parameter Real yd_start = 0 "Initial or guess value of derivative of output (= state)" annotation(Dialog(group = "Initialization"));
//         extends Interfaces.SISO(y(start = y_start));
//         output Real yd(start = yd_start) "Derivative of y";
//         annotation(Documentation(info = "<HTML>
// <p>
// This blocks defines the transfer function between the input u and
// the output y (element-wise) as <i>second order</i> system:
// </p>
// <pre>
//                              k
//      y = ---------------------------------------- * u
//             ( s / w )^2 + 2*D*( s / w ) + 1
// </pre>
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general model class <b>TransferFunction</b>
// instead and model a second order SISO system with parameters<br>
// b = {k}, a = {1/w^2, 2*D/w, 1}.
// </p>
// <pre>
// Example:
// 
//    parameter: k =  0.3,  w = 0.5,  D = 0.4
//    results in:
//                   0.3
//       y = ------------------- * u
//           4.0 s^2 + 1.6 s + 1
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -72, -68.53},{ -64, -39.5},{ -56, -2.522},{ -48,32.75},{ -40,58.8},{ -32,71.51},{ -24,70.49},{ -16,58.45},{ -8,40.06},{0,20.55},{8,4.459},{16, -5.271},{24, -7.629},{32, -3.428},{40,5.21},{48,15.56},{56,25.03},{64,31.66},{72,34.5},{80,33.61}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -70},{60, -10}}, textString = "PT2", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "w=%w", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -60,14},{60,60}}, textString = "k", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -51.5, -22.5},{ -23.5, -2.5}}, textString = "s", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}}),Line(visible = true, points = {{ -50,14},{50,14}}),Line(visible = true, points = {{ -45, -22.5},{ -30, -22.5}}),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -47.23, -40},{ -27.77, -20}}, textString = "w", fontName = "Arial"),Line(visible = true, points = {{ -45,0},{ -49.5, -15},{ -49.5, -30},{ -45, -45}}, smooth = Smooth.Bezier),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -28.5, -7.5},{ -16.5,8.5}}, textString = "2", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -27.5, -32.5},{12.5, -12.5}}, textString = "+2D", fontName = "Arial"),Line(visible = true, points = {{15, -22.5},{30, -22.5}}),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{30, -32.5},{58, -12.5}}, textString = "+1", fontName = "Arial"),Line(visible = true, points = {{ -30,0},{ -25.5, -15},{ -25.5, -30},{ -30, -45}}, smooth = Smooth.Bezier),Line(visible = true, points = {{15,0},{10.5, -15},{10.5, -30},{15, -45}}, smooth = Smooth.Bezier),Line(visible = true, points = {{29,1.066e-14},{33.5, -15},{33.5, -30},{29, -45}}, smooth = Smooth.Bezier),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{12.77, -40},{32.23, -20}}, textString = "w", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{7.5, -22.5},{35.5, -2.5}}, textString = "s", fontName = "Arial")}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(y) = 0;
//           der(yd) = 0;
// 
//         elseif initType == Init.InitialState or initType == Init.InitialOutput then
//           y = y_start;
//           yd = yd_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(y) = yd;
//         der(yd) = w * (w * (k * u - y) - 2 * D * yd);
//       end SecondOrder;
//       block PI "Proportional-Integral controller"
//         import Modelica.Blocks.Types.Init;
//         parameter Real k = 1 "Gain";
//         parameter SIunits.Time T = 1 "Time Constant (T>0 required)";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (SteadyState and InitialOutput are identical)" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x_start = 0 "Initial or guess value of state" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0 "Initial value of output" annotation(Dialog(enable = initType == Init.SteadyState or initType == Init.InitialOutput, group = "Initialization"));
//         extends Interfaces.SISO;
//         output Real x(start = x_start) "State of block";
//         annotation(defaultComponentName = "PI", Documentation(info = "
// <HTML>
// <p>
// This blocks defines the transfer function between the input u and
// the output y (element-wise) as <i>PI</i> system:
// </p>
// <pre>
//                  1
//    y = k * (1 + ---) * u
//                 T*s
//            T*s + 1
//      = k * ------- * u
//              T*s
// </pre>
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general model class <b>TransferFunction</b>
// instead and model a PI SISO system with parameters<br>
// b = {k*T, k}, a = {T, 0}.
// </p>
// <pre>
// Example:
//  
//    parameter: k = 0.3,  T = 0.4
//  
//    results in:
//                0.4 s + 1
//       y = 0.3 ----------- * u
//                  0.4 s
// </pre>
// 
// <p>
// It might be difficult to initialize the PI component in steady state
// due to the integrator part.
// This is discussed in the description of package
// <a href=\"Modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -80, -20},{60,80}}),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -56},{60,6}}, textString = "PI", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "T=%T", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -68, -18},{ -24,24}}, textString = "k", fontName = "Arial"),Text(visible = true, extent = {{ -32,0},{60,48}}, textString = "T s + 1", fontName = "Arial"),Text(visible = true, extent = {{ -30, -40},{52, -8}}, textString = "T s", fontName = "Arial"),Line(visible = true, points = {{ -24,0},{54,0}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{62,0},{100,0}})}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x) = 0;
// 
//         elseif initType == Init.InitialState then
//           x = x_start;
// 
// 
//         elseif initType == Init.InitialOutput then
//           y = y_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(x) = u / T;
//         y = k * (x + u);
//       end PI;
//       block PID "PID-controller in additive description form"
//         import Modelica.Blocks.Types.InitPID;
//         extends Interfaces.SISO;
//         parameter Real k = 1 "Gain";
//         parameter SIunits.Time Ti(min = Modelica.Constants.small) = 0.5 "Time Constant of Integrator";
//         parameter SIunits.Time Td(min = 0) = 0.1 "Time Constant of Derivative block";
//         parameter Real Nd(min = Modelica.Constants.small) = 10 "The higher Nd, the more ideal the derivative block";
//         parameter InitPID.Temp initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)" annotation(Dialog(group = "Initialization"));
//         parameter Real xd_start = 0 "Initial or guess value for state of derivative block" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0 "Initial value of output" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         annotation(defaultComponentName = "PID", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -80,50},{ -80, -20},{60,80}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -20, -60},{80, -20}}, textString = "PID", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "Ti=%Ti", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is the text-book version of a PID-controller.
// For a more practically useful PID-controller, use
// block LimPID.
// </p>
//  
// <p>
// The PID block can be initialized in different
// ways controlled by parameter <b>initType</b>. The possible
// values of initType are defined in 
// <a href=\"Modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
// This type is identical to 
// <a href=\"Modelica://Modelica.Blocks.Types.Init\">Types.Init</a>, 
// with the only exception that the additional option
// <b>DoNotUse_InitialIntegratorState</b> is added for
// backward compatibility reasons (= integrator is initialized with
// InitialState whereas differential part is initialized with
// NoInit which was the initialization in version 2.2 of the Modelica
// standard library).
// </p>
//  
// <p>
// Based on the setting of initType, the integrator (I) and derivative (D)
// blocks inside the PID controller are initialized according to the following table:
// </p>
//  
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>initType</b></td>
//       <td><b>I.initType</b></td>
//       <td><b>D.initType</b></td></tr>
//  
//   <tr><td><b>NoInit</b></td>
//       <td>NoInit</td>
//       <td>NoInit</td></tr>
//  
//   <tr><td><b>SteadyState</b></td>
//       <td>SteadyState</td>
//       <td>SteadyState</td></tr>
//  
//   <tr><td><b>InitialState</b></td>
//       <td>InitialState</td>
//       <td>InitialState</td></tr>
//  
//   <tr><td><b>InitialOutput</b><br>
//           and initial equation: y = y_start</td>
//       <td>NoInit</td>
//       <td>SteadyState</td></tr>
//  
//   <tr><td><b>DoNotUse_InitialIntegratorState</b></td>
//       <td>InitialState</td>
//       <td>NoInit</td></tr>
// </table>
//  
// <p>
// In many cases, the most useful initial condition is
// <b>SteadyState</b> because initial transients are then no longer
// present. If initType = InitPID.SteadyState, then in some
// cases difficulties might occur. The reason is the 
// equation of the integrator:
// </p>
//  
// <pre>
//    <b>der</b>(y) = k*u;
// </pre>
//  
// <p>
// The steady state equation \"der(x)=0\" leads to the condition that the input u to the
// integrator is zero. If the input u is already (directly or indirectly) defined
// by another initial condition, then the initialization problem is <b>singular</b>
// (has none or infinitely many solutions). This situation occurs often
// for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
// since speed is both a state and a derivative, it is natural to
// initialize it with zero. As sketched this is, however, not possible.
// The solution is to not initialize u or the variable that is used
// to compute u by an algebraic equation.
// </p>
// 
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Math.Gain P "Proportional part of PID controller" annotation(Placement(visible = true, transformation(origin = { -40,80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Continuous.Integrator I(k = 1 / Ti, y_start = xi_start, initType = if initType == InitPID.SteadyState then InitPID.SteadyState else if initType == InitPID.InitialState or initType == InitPID.DoNotUse_InitialIntegratorState then InitPID.InitialState else InitPID.NoInit) "Integral part of PID controller" annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Continuous.Derivative D(k = Td, T = max([Td / Nd,100 * Modelica.Constants.eps]), x_start = xd_start, initType = if initType == InitPID.SteadyState or initType == InitPID.InitialOutput then InitPID.SteadyState else if initType == InitPID.InitialState then InitPID.InitialState else InitPID.NoInit) "Derivative part of PID controller" annotation(Placement(visible = true, transformation(origin = { -40, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Math.Gain Gain(k = k) "Gain of PID controller" annotation(Placement(visible = true, transformation(origin = {70,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Add3 Add annotation(Placement(visible = true, transformation(origin = {30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       initial equation 
// if initType == InitPID.InitialOutput then
//                   y = y_start;
//         end if;
// 
//       equation 
//         connect(Gain.y,y) annotation(Line(visible = true, origin = {95.5,0}, points = {{ -14.5,0},{14.5,0}}, color = {0,0,191}));
//         connect(u,D.u) annotation(Line(visible = true, points = {{ -120,0},{ -80,0},{ -80, -80},{ -64, -80}}, color = {0,0,191}));
//         connect(u,I.u) annotation(Line(visible = true, origin = { -92,0}, points = {{ -28,0},{28,0}}, color = {0,0,191}));
//         connect(u,P.u) annotation(Line(visible = true, points = {{ -120,0},{ -80,0},{ -80,80},{ -64,80}}, color = {0,0,191}));
//         connect(Add.y,Gain.u) annotation(Line(visible = true, points = {{41,0},{58,0}}, color = {0,0,191}));
//         connect(D.y,Add.u3) annotation(Line(visible = true, points = {{ -18, -80},{0, -80},{0, -8},{18, -8}}, color = {0,0,191}));
//         connect(I.y,Add.u2) annotation(Line(visible = true, points = {{ -18,0},{18,0}}, color = {0,0,191}));
//         connect(P.y,Add.u1) annotation(Line(visible = true, points = {{ -18,80},{0,80},{0,8},{18,8}}, color = {0,0,191}));
//       end PID;
//       block LimPID "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
//         import Modelica.Blocks.Types.InitPID;
//         import Modelica.Blocks.Types.SimpleController;
//         extends Interfaces.SVcontrol;
//         output Real controlError = u_s - u_m "Control error (set point - measurement)";
//         parameter SimpleController.Temp controllerType = Modelica.Blocks.Types.SimpleController.PID "Type of controller";
//         parameter Real k(min = 0) = 1 "Gain of controller";
//         parameter SIunits.Time Ti(min = Modelica.Constants.small) = 0.5 "Time constant of Integrator block" annotation(Dialog(enable = controllerType == SimpleController.PI or controllerType == SimpleController.PID));
//         parameter SIunits.Time Td(min = 0) = 0.1 "Time constant of Derivative block" annotation(Dialog(enable = controllerType == SimpleController.PD or controllerType == SimpleController.PID));
//         parameter Real yMax = 1 "Upper limit of output";
//         parameter Real yMin =  -yMax "Lower limit of output";
//         parameter Real wp(min = 0) = 1 "Set-point weight for Proportional block (0..1)";
//         parameter Real wd(min = 0) = 0 "Set-point weight for Derivative block (0..1)" annotation(Dialog(enable = controllerType == SimpleController.PD or controllerType == SimpleController.PID));
//         parameter Real Ni(min = 100 * Modelica.Constants.eps) = 0.9 "Ni*Ti is time constant of anti-windup compensation" annotation(Dialog(enable = controllerType == SimpleController.PI or controllerType == SimpleController.PID));
//         parameter Real Nd(min = 100 * Modelica.Constants.eps) = 10 "The higher Nd, the more ideal the derivative block" annotation(Dialog(enable = controllerType == SimpleController.PD or controllerType == SimpleController.PID));
//         parameter InitPID.Temp initType = Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Boolean limitsAtInit = true "= false, if limits are ignored during initializiation" annotation(Dialog(group = "Initialization", enable = controllerType == SimpleController.PI or controllerType == SimpleController.PID), Evaluate = true);
//         parameter Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)" annotation(Dialog(group = "Initialization", enable = controllerType == SimpleController.PI or controllerType == SimpleController.PID));
//         parameter Real xd_start = 0 "Initial or guess value for state of derivative block" annotation(Dialog(group = "Initialization", enable = controllerType == SimpleController.PD or controllerType == SimpleController.PID));
//         parameter Real y_start = 0 "Initial value of output" annotation(Dialog(enable = initType == InitPID.InitialOutput, group = "Initialization"));
//         annotation(defaultComponentName = "PID", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -80,50},{ -80, -20},{30,60},{80,60}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -20, -60},{80, -20}}, textString = "PID", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Via parameter <b>controllerType</b> either <b>P</b>, <b>PI</b>, <b>PD</b>, 
// or <b>PID</b> can be selected. If, e.g., PI is selected, all components belonging to the
// D-part are removed from the block (via conditional declarations).
// The example model
// <a href=\"Modelica://Modelica.Blocks.Examples.PID_Controller\">Modelica.Blocks.Examples.PID_Controller</a>
// demonstrates the usage of this controller.
// Several practical aspects of PID controller design are incorporated
// according to chapter 3 of the book:
// </p>
// 
// <dl>
// <dt>Astroem K.J., and Haegglund T.:</dt>
// <dd> <b>PID Controllers: Theory, Design, and Tuning</b>.
//      Instrument Society of America, 2nd edition, 1995.
//      Information from:
//      <a href=\"http://www.control.lth.se/publications/books/asthagg95.html\">http://www.control.lth.se/publications/books/asthagg95.html</a>
//      </dd>
// </dl>
// 
// <p>
// Besides the additive <b>proportional, integral</b> and <b>derivative</b>
// part of this controller, the following features are present:
// </p>
// <ul>
// <li> The output of this controller is limited. If the controller is
//      in its limits, anti-windup compensation is activated to drive
//      the integrator state to zero. </li>
// <li> The high-frequency gain of the derivative part is limited
//      to avoid excessive amplification of measurement noise.</li>
// <li> Setpoint weighting is present, which allows to weight
//      the setpoint in the proportional and the derivative part
//      independantly from the measurement. The controller will respond
//      to load disturbances and measurement noise independantly of this setting
//      (parameters wp, wd). However, setpoint changes will depend on this
//      setting. For example, it is useful to set the setpoint weight wd
//      for the derivative part to zero, if steps may occur in the
//      setpoint signal.</li>
// </ul>
// 
// <p>
// The parameters of the controller can be manually adjusted by performing
// simulations of the closed loop system (= controller + plant connected
// together) and using the following strategy:
// </p>
// 
// <ol>
// <li> Set very large limits, e.g., yMax = Modelica.Constants.inf</li>
// <li> Select a <b>P</b>-controller and manually enlarge parameter <b>k</b>
//      (the total gain of the controller) until the closed-loop response
//      cannot be improved any more.</li>
// <li> Select a <b>PI</b>-controller and manually adjust parameters
//      <b>k</b> and <b>Ti</b> (the time constant of the integrator).
//      The first value of Ti can be selected, such that it is in the
//      order of the time constant of the oscillations occuring with
//      the P-controller. If, e.g., vibrations in the order of T=10 ms
//      occur in the previous step, start with Ti=0.01 s.</li>
// <li> If you want to make the reaction of the control loop faster
//      (but probably less robust against disturbances and measurement noise)
//      select a <b>PID</b>-Controller and manually adjust parameters 
//      <b>k</b>, <b>Ti</b>, <b>Td</b> (time constant of derivative block).</li>
// <li> Set the limits yMax and yMin according to your specification.</li>
// <li> Perform simulations such that the output of the PID controller
//      goes in its limits. Tune <b>Ni</b> (Ni*Ti is the time constant of 
//      the anti-windup compensation) such that the input to the limiter
//      block (= limiter.u) goes quickly enough back to its limits.
//      If Ni is decreased, this happens faster. If Ni=infinity, the
//      anti-windup compensation is switched off and the controller works bad.</li>
// </ol>
//  
// <p>
// <b>Initialization</b>
// </p>
// 
// <p>
// This block can be initialized in different
// ways controlled by parameter <b>initType</b>. The possible
// values of initType are defined in 
// <a href=\"Modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
// This type is identical to 
// <a href=\"Modelica://Modelica.Blocks.Types.Init\">Types.Init</a>, 
// with the only exception that the additional option
// <b>DoNotUse_InitialIntegratorState</b> is added for
// backward compatibility reasons (= integrator is initialized with
// InitialState whereas differential part is initialized with
// NoInit which was the initialization in version 2.2 of the Modelica
// standard library).
// </p>
//  
// <p>
// Based on the setting of initType, the integrator (I) and derivative (D)
// blocks inside the PID controller are initialized according to the following table:
// </p>
//  
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>initType</b></td>
//       <td><b>I.initType</b></td>
//       <td><b>D.initType</b></td></tr>
//  
//   <tr><td><b>NoInit</b></td>
//       <td>NoInit</td>
//       <td>NoInit</td></tr>
//  
//   <tr><td><b>SteadyState</b></td>
//       <td>SteadyState</td>
//       <td>SteadyState</td></tr>
//  
//   <tr><td><b>InitialState</b></td>
//       <td>InitialState</td>
//       <td>InitialState</td></tr>
//  
//   <tr><td><b>InitialOutput</b><br>
//           and initial equation: y = y_start</td>
//       <td>NoInit</td>
//       <td>SteadyState</td></tr>
//  
//   <tr><td><b>DoNotUse_InitialIntegratorState</b></td>
//       <td>InitialState</td>
//       <td>NoInit</td></tr>
// </table>
//  
// <p>
// In many cases, the most useful initial condition is
// <b>SteadyState</b> because initial transients are then no longer
// present. If initType = InitPID.SteadyState, then in some
// cases difficulties might occur. The reason is the 
// equation of the integrator:
// </p>
//  
// <pre>
//    <b>der</b>(y) = k*u;
// </pre>
//  
// <p>
// The steady state equation \"der(x)=0\" leads to the condition that the input u to the
// integrator is zero. If the input u is already (directly or indirectly) defined
// by another initial condition, then the initialization problem is <b>singular</b>
// (has none or infinitely many solutions). This situation occurs often
// for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
// since speed is both a state and a derivative, it is natural to
// initialize it with zero. As sketched this is, however, not possible.
// The solution is to not initialize u_m or the variable that is used
// to compute u_m by an algebraic equation.
// </p>
// 
// <p>
// If parameter <b>limitAtInit</b> = <b>false</b>, the limits at the
// output of this controller block are removed from the initialization problem which 
// leads to a much simpler equation system. After initialization has been
// performed, it is checked via an assert whether the output is in the
// defined limits. For backward compatibility reasons 
// <b>limitAtInit</b> = <b>true</b>. In most cases it is best
// to use <b>limitAtInit</b> = <b>false</b>.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Math.Add addP(k1 = wp, k2 =  -1) annotation(Placement(visible = true, transformation(origin = { -70,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Add addD(k1 = wd, k2 =  -1) if with_D annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Gain P annotation(Placement(visible = true, transformation(origin = { -30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Continuous.Integrator I(k = 1 / Ti, y_start = xi_start, initType = if initType == InitPID.SteadyState then InitPID.SteadyState else if initType == InitPID.InitialState or initType == InitPID.DoNotUse_InitialIntegratorState then InitPID.InitialState else InitPID.NoInit) if with_I annotation(Placement(visible = true, transformation(origin = { -30, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Continuous.Derivative D(k = Td, T = max([Td / Nd,1e-14]), x_start = xd_start, initType = if initType == InitPID.SteadyState or initType == InitPID.InitialOutput then InitPID.SteadyState else if initType == InitPID.InitialState then InitPID.InitialState else InitPID.NoInit) if with_D annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Gain gainPID(k = k) annotation(Placement(visible = true, transformation(origin = {40,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Add3 addPID annotation(Placement(visible = true, transformation(origin = {10,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Add3 addI(k2 =  -1) if with_I annotation(Placement(visible = true, transformation(origin = { -70, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Math.Add addSat(k1 =  +1, k2 =  -1) if with_I annotation(Placement(visible = true, transformation(origin = {80.0, -50.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 90)));
//         Blocks.Math.Gain gainTrack(k = 1 / (k * Ni)) if with_I annotation(Placement(visible = true, transformation(origin = {30, -70}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//         Blocks.Nonlinear.Limiter limiter(uMax = yMax, uMin = yMin, limitsAtInit = limitsAtInit) annotation(Placement(visible = true, transformation(origin = {80,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Sources.Constant Dzero(k = 0) if not with_D annotation(Placement(visible = true, transformation(origin = { -25,25}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//         Sources.Constant Izero(k = 0) if not with_I annotation(Placement(visible = true, transformation(origin = {5, -50}, extent = {{5, -5},{ -5,5}}, rotation = 0)));
//       protected 
//         parameter Boolean with_I = controllerType == SimpleController.PI or controllerType == SimpleController.PID annotation(Hide = true, Evaluate = true);
//         parameter Boolean with_D = controllerType == SimpleController.PD or controllerType == SimpleController.PID annotation(Hide = true, Evaluate = true);
// 
//       initial equation 
// if initType == InitPID.InitialOutput then
//                   y = y_start;
//         end if;
// 
//       equation 
//         connect(gainPID.y,addSat.u2) annotation(Line(visible = true, points = {{51.0,0.0},{60.0,0.0},{60.0, -20.0},{74.0, -20.0},{74.0, -38.0}}, color = {0,0,191}));
//         connect(limiter.y,addSat.u1) annotation(Line(visible = true, points = {{91.0,0.0},{94.0,0.0},{94.0, -20.0},{86.0, -20.0},{86.0, -38.0}}, color = {0,0,191}));
//         connect(addSat.y,gainTrack.u) annotation(Line(visible = true, points = {{80.0, -61.0},{80.0, -70.0},{42.0, -70.0}}, color = {0,0,191}));
//         connect(u_m,addI.u2) annotation(Line(visible = true, points = {{0, -120},{0, -92},{ -92, -92},{ -92, -50},{ -82, -50}}, color = {0,0,191}, thickness = 0.5));
//         connect(u_m,addD.u2) annotation(Line(visible = true, points = {{0, -120},{0, -92},{ -92, -92},{ -92, -6},{ -82, -6}}, color = {0,0,191}, thickness = 0.5));
//         connect(u_m,addP.u2) annotation(Line(visible = true, points = {{0, -120},{0, -92},{ -92, -92},{ -92,44},{ -82,44}}, color = {0,0,191}, thickness = 0.5));
//         connect(limiter.y,y) annotation(Line(visible = true, origin = {100.5,0}, points = {{ -9.5,0},{9.5,0}}, color = {0,0,191}));
//         connect(u_s,addI.u1) annotation(Line(visible = true, points = {{ -120,0},{ -96,0},{ -96, -42},{ -82, -42}}, color = {0,0,191}));
//         connect(u_s,addD.u1) annotation(Line(visible = true, points = {{ -120,0},{ -96,0},{ -96,6},{ -82,6}}, color = {0,0,191}));
//         connect(u_s,addP.u1) annotation(Line(visible = true, points = {{ -120,0},{ -96,0},{ -96,56},{ -82,56}}, color = {0,0,191}));
//         connect(Izero.y,addPID.u3) annotation(Line(visible = true, points = {{ -0.5, -50},{ -10, -50},{ -10, -8},{ -2, -8}}, color = {0,0,191}));
//         connect(Dzero.y,addPID.u2) annotation(Line(visible = true, points = {{ -19.5,25},{ -14,25},{ -14,0},{ -2,0}}, color = {0,0,191}));
//         connect(gainTrack.y,addI.u3) annotation(Line(visible = true, points = {{19, -70},{ -88, -70},{ -88, -58},{ -82, -58}}, color = {0,0,191}));
//         connect(gainPID.y,limiter.u) annotation(Line(visible = true, points = {{51,0},{68,0}}, color = {0,0,191}));
//         connect(addPID.y,gainPID.u) annotation(Line(visible = true, points = {{21,0},{28,0}}, color = {0,0,191}));
//         connect(I.y,addPID.u3) annotation(Line(visible = true, points = {{ -19, -50},{ -10, -50},{ -10, -8},{ -2, -8}}, color = {0,0,191}));
//         connect(D.y,addPID.u2) annotation(Line(visible = true, points = {{ -19,0},{ -2,0}}, color = {0,0,191}));
//         connect(P.y,addPID.u1) annotation(Line(visible = true, points = {{ -19,50},{ -10,50},{ -10,8},{ -2,8}}, color = {0,0,191}));
//         connect(addI.y,I.u) annotation(Line(visible = true, points = {{ -59, -50},{ -42, -50}}, color = {0,0,191}));
//         connect(addD.y,D.u) annotation(Line(visible = true, points = {{ -59,0},{ -42,0}}, color = {0,0,191}));
//         connect(addP.y,P.u) annotation(Line(visible = true, points = {{ -59,50},{ -42,50}}, color = {0,0,191}));
//         assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) + ") < yMin (=" + String(yMin) + ")");
// if initType == InitPID.InitialOutput and (y_start < yMin or y_start > yMax) then
//                   Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) + ") is outside of the limits of yMin (=" + String(yMin) + ") and yMax (=" + String(yMax) + ")");
//         end if;
//         assert(limitsAtInit or not limitsAtInit and y >= yMin and y <= yMax, "LimPID: During initialization the limits have been switched off.\n" + "After initialization, the output y (=" + String(y) + ") is outside of the limits of yMin (=" + String(yMin) + ") and yMax (=" + String(yMax) + ")");
//       end LimPID;
//       block TransferFunction "Linear transfer function"
//         import Modelica.Blocks.Types.Init;
//         extends Interfaces.SISO;
//         parameter Real b[:] = {1} "Numerator coefficients of transfer function.";
//         parameter Real a[:] = {1,1} "Denominator coefficients of transfer function.";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x_start[size(a, 1) - 1] = zeros(nx) "Initial or guess values of states" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0 "Initial value of output (derivatives of y are zero upto nx-1-th derivative)" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         output Real x[size(a, 1) - 1](start = x_start) "State of transfer function from controller canonical form";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}),Text(visible = true, extent = {{ -90,10},{90,90}}, textString = "b(s)", fontName = "Arial"),Text(visible = true, extent = {{ -90, -90},{90, -10}}, textString = "a(s)", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{40,0},{ -40,0}}),Text(visible = true, extent = {{ -55,5},{55,55}}, textString = "b(s)", fontName = "Arial"),Text(visible = true, extent = {{ -55, -55},{55, -5}}, textString = "a(s)", fontName = "Arial"),Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}));
//       protected 
//         parameter Integer na = size(a, 1) "Size of Denominator of transfer function.";
//         parameter Integer nb(max = na) = size(b, 1) "Size of Numerator of transfer function.";
//         parameter Integer nx = size(a, 1) - 1;
//         Real x1dot "Derivative of first state of TransferFcn";
//         Real xn "Highest order state of TransferFcn";
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This block defines the transfer function between the input
// u and the output y
// as (nb = dimension of b, na = dimension of a):
// </p>
// <pre>
//            b[1]*s^[nb-1] + b[2]*s^[nb-2] + ... + b[nb]
//    y(s) = --------------------------------------------- * u(s)
//            a[1]*s^[na-1] + a[2]*s^[na-2] + ... + a[na]
// </pre>
// <p>
// State variables <b>x</b> are defined according to <b>controller canonical</b>
// form. Initial values of the states can be set as start values of <b>x</b>.
// <p>
// <p>
// Example:
// </p>
// <pre>
//      TransferFunction g(b = {2,4}, a = {1,3});
// </pre>
// <p>
// results in the following transfer function:
// </p>
// <pre>
//         2*s + 4
//    y = --------- * u
//          s + 3
// </pre>
// <p><b>Release Notes:</b></p>
// <ul>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,0},{80,0}}),Text(extent = {{ -90,10},{90,90}}, textString = "b(s)"),Text(extent = {{ -90, -10},{90, -90}}, textString = "a(s)")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{40,0},{ -40,0}}, color = {0,0,0}),Text(extent = {{ -55,55},{55,5}}, textString = "b(s)", fillColor = {0,0,0}),Text(extent = {{ -55, -5},{55, -55}}, textString = "a(s)", fillColor = {0,0,0}),Rectangle(extent = {{ -60,60},{60, -60}}),Line(points = {{ -100,0},{ -60,0}}),Line(points = {{60,0},{100,0}})}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x) = zeros(nx);
// 
//         elseif initType == Init.InitialState then
//           x = x_start;
// 
// 
//         elseif initType == Init.InitialOutput then
//           y = y_start;
//           der(x[1:nx - 1]) = zeros(nx - 1);
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         [der(x);xn] = [x1dot;x];
//         [u] = transpose([a]) * [x1dot;x];
//         [y] = transpose([zeros(na - nb, 1);b]) * [x1dot;x];
//       end TransferFunction;
//       block StateSpace "Linear state space system"
//         import Modelica.Blocks.Types.Init;
//         parameter Real A[:,size(A, 1)] = [1,0;0,1] "Matrix A of state space model";
//         parameter Real B[size(A, 1),:] = [1;1] "Matrix B of state space model";
//         parameter Real C[:,size(A, 1)] = [1,1] "Matrix C of state space model";
//         parameter Real D[size(C, 1),size(B, 2)] = zeros(size(C, 1), size(B, 2)) "Matrix D of state space model";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x_start[nx] = zeros(nx) "Initial or guess values of states" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start[ny] = zeros(ny) "Initial values of outputs (remaining states are in steady state if possible)" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         extends Interfaces.MIMO(final nin = size(B, 2), final nout = size(C, 1));
//         output Real x[size(A, 1)](start = x_start) "State vector";
//         annotation(Documentation(info = "<HTML>
// <p>
// The State Space block defines the relation
// between the input u and the output
// y in state space form:
// </p>
// <pre>
//  
//     der(x) = A * x + B * u
//         y  = C * x + D * u
// </pre>
// <p>
// The input is a vector of length nu, the output is a vector
// of length ny and nx is the number of states. Accordingly
// </p>
// <pre>
//         A has the dimension: A(nx,nx),
//         B has the dimension: B(nx,nu),
//         C has the dimension: C(ny,nx),
//         D has the dimension: D(ny,nu)
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter: A = [0.12, 2;3, 1.5]
//      parameter: B = [2, 7;3, 1]
//      parameter: C = [0.1, 2]
//      parameter: D = zeros(ny,nu)
// results in the following equations:
//   [der(x[1])]   [0.12  2.00] [x[1]]   [2.0  7.0] [u[1]]
//   [         ] = [          ]*[    ] + [        ]*[    ]
//   [der(x[2])]   [3.00  1.50] [x[2]]   [0.1  2.0] [u[2]]
//                              [x[1]]            [u[1]]
//        y[1]   = [0.1  2.0] * [    ] + [0  0] * [    ]
//                              [x[2]]            [u[2]]
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90,10},{ -10,90}}, textString = "A", fontName = "Arial"),Text(visible = true, extent = {{10,10},{90,90}}, textString = "B", fontName = "Arial"),Text(visible = true, extent = {{ -90, -90},{ -10, -10}}, textString = "C", fontName = "Arial"),Text(visible = true, extent = {{10, -90},{90, -10}}, textString = "D", fontName = "Arial"),Line(visible = true, points = {{0, -90},{0,90}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{90,0}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -60,0},{60,40}}, textString = "sx=Ax+Bu", fontName = "Arial"),Text(visible = true, extent = {{ -60, -40},{60,0}}, textString = " y=Cx+Du", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}));
//       protected 
//         parameter Integer nx = size(A, 1) "number of states";
//         parameter Integer ny = size(C, 1) "number of outputs";
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x) = zeros(nx);
// 
//         elseif initType == Init.InitialState then
//           x = x_start;
// 
// 
//         elseif initType == Init.InitialOutput then
//           x = Modelica.Math.Matrices.equalityLeastSquares(A,  -B * u, C, y_start - D * u);
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(x) = A * x + B * u;
//         y = C * x + D * u;
//       end StateSpace;
//       block Der "Derivative of input (= analytic differentations)"
//         extends Interfaces.SISO;
//         annotation(defaultComponentName = "der1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -80, -82},{80,76}}, textString = "der()", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Defines that the output y is the <i>derivative</i>
// of the input u. Note, that Modelica.Blocks.Continuous.Derivative
// computes the derivative in an approximate sense, where as this block computes
// the derivative exactly. This requires that the input u is differentiated
// by the Modelica translator, if this derivative is not yet present in
// the model.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = der(u);
//       end Der;
//       block LowpassButterworth "Output the input signal filtered with a low pass Butterworth filter of any order"
//         import Modelica.Math.*;
//         import Modelica.Blocks.Types.Init;
//         extends Modelica.Blocks.Interfaces.SISO;
//         parameter Integer n(min = 1) = 2 "Order of filter";
//         parameter SI.Frequency f = 1 "Cut-off frequency";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x1_start[m] = zeros(m) "Initial or guess values of states 1 (der(x1)=x2))" annotation(Dialog(group = "Initialization"));
//         parameter Real x2_start[m] = zeros(m) "Initial or guess values of states 2" annotation(Dialog(group = "Initialization"));
//         parameter Real xr_start = 0.0 "Initial or guess value of real pole for uneven order otherwise dummy" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0.0 "Initial value of output (states are initialized in steady state if possible)" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         output Real x1[m](start = x1_start) "states 1 of second order filters (der(x1) = x2)";
//         output Real x2[m](start = x2_start) "states 2 of second order filters";
//         output Real xr(start = xr_start) "state of real pole for uneven order otherwise dummy";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -90}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -79.5584,91.817},{ -87.5584,69.817},{ -71.5584,69.817},{ -79.5584,89.817},{ -79.5584,91.817}}),Line(visible = true, points = {{ -80, -80},{ -72, -68.53},{ -64, -39.5},{ -56, -2.522},{ -48,32.75},{ -40,58.8},{ -32,71.51},{ -24,70.49},{ -16,58.45},{ -8,40.06},{0,20.55},{8,4.459},{16, -5.271},{24, -7.629},{32, -3.428},{40,5.21},{48,15.56},{56,25.03},{64,31.66},{72,34.5},{80,33.61}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90.9779, -80.7697},{81.0221, -80.7697}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{91.3375, -79.8233},{69.3375, -71.8233},{69.3375, -87.8233},{91.3375, -79.8233}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -45.1735, -68},{92, -11.47}}, textString = "LowpassButterworthFilter", fontName = "Arial"),Text(visible = true, extent = {{8, -146},{8, -106}}, textString = "f=%f", fontName = "Arial"),Text(visible = true, fillColor = {192,192,192}, extent = {{ -2,48},{94,94}}, textString = "%n", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{40,0},{ -40,0}}),Text(visible = true, extent = {{ -55,5},{55,55}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -55, -55},{55, -5}}, textString = "a(s)", fontName = "Arial"),Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}), Documentation(info = "<html>
// <p>This block defines the transfer function between the input u
// and the output y as an n-th order low pass filter with <i>Butterworth</i>
// characteristics and cut-off frequency f. It is implemented as
// a series of second order filters and a first order filter.</p>
// <p>If transients at the simulation start shall be avoided the
// states x1 and xr need to be initialized with the start value
// of the input signal and the states x2 need to be initialized
// with zeros.</p>
// <pre>
//      y = PT21*PT22*...*PT2(n/2)*PT1 u
// </pre>
//  
// </HTML>
// "));
//       protected 
//         constant Real pi = Modelica.Constants.pi;
//         parameter Integer m = integer(n / 2);
//         parameter Boolean evenOrder = 2 * m == n;
//         parameter Real w = 2 * pi * f;
//         Real z[m + 1];
//         Real polereal[m];
//         Real poleimag[m];
//         Real realpol;
//         Real k2[m];
//         Real D[m];
//         Real w0[m];
//         Real k1;
//         Real T;
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x1) = zeros(m);
//           der(x2) = zeros(m);
// if not evenOrder then
//                       der(xr) = 0.0;
//           end if;
// 
//         elseif initType == Init.InitialState then
//           x1 = x1_start;
//           x2 = x2_start;
// if not evenOrder then
//                       xr = xr_start;
//           end if;
// 
// 
//         elseif initType == Init.InitialOutput then
//           y = y_start;
//           der(x1) = zeros(m);
//           if evenOrder then
// if m > 1 then
//                           der(x2[1:m - 1]) = zeros(m - 1);
//             end if;
// 
//           else
//             der(x1) = zeros(m);
// 
//           end if;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         k2 = ones(m);
//         k1 = 1;
//         z[1] = u;
//         for i in 1:m loop
//         polereal[i] = cos(pi / 2 + pi / n * (i - 0.5));
//         poleimag[i] = sin(pi / 2 + pi / n * (i - 0.5));
//         w0[i] = (polereal[i] ^ 2 + poleimag[i] ^ 2) * w;
//         D[i] =  -polereal[i] / w0[i] * w;
// 
//         end for;
//         realpol = 1 * w;
//         T = 1 / realpol;
//         for i in 1:m loop
//         der(x1[i]) = x2[i];
//         der(x2[i]) = k2[i] * w0[i] ^ 2 * z[i] - 2 * D[i] * w0[i] * x2[i] - w0[i] ^ 2 * x1[i];
//         z[i + 1] = x1[i];
// 
//         end for;
//         if evenOrder then
//           xr = 0;
//           y = z[m + 1];
// 
//         else
//           der(xr) = (k1 * z[m + 1] - xr) / T;
//           y = xr;
// 
//         end if;
//       end LowpassButterworth;
//       block CriticalDamping "Output the input signal filtered with an n-th order filter with critical damping"
//         import Modelica.Blocks.Types.Init;
//         extends Modelica.Blocks.Interfaces.SISO;
//         parameter Integer n = 2 "Order of filter";
//         parameter Modelica.SIunits.Frequency f = 1 "Cut-off frequency";
//         parameter Init.Temp initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization" annotation(Dialog(group = "Initialization"), Evaluate = true);
//         parameter Real x_start[n] = zeros(n) "Initial or guess values of states" annotation(Dialog(group = "Initialization"));
//         parameter Real y_start = 0.0 "Initial value of output (remaining states are in steady state)" annotation(Dialog(enable = initType == Init.InitialOutput, group = "Initialization"));
//         output Real x[n](start = x_start) "Filter states";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80.6897,77.6256},{ -80.6897, -90.3744}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -79.7044,90.6305},{ -87.7044,68.6305},{ -71.7044,68.6305},{ -79.7044,88.6305},{ -79.7044,90.6305}}),Line(visible = true, points = {{ -90, -80},{82, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Text(visible = true, fillColor = {192,192,192}, extent = {{0, -60},{60,0}}, textString = "PTn", fontName = "Arial"),Line(visible = true, points = {{ -80.7599, -80.5082},{ -70.7599, -74.5082},{ -56, -60},{ -48, -42},{ -42, -18},{ -36,4},{ -26,20},{ -10.7599,34.9018},{ -0.759907,38.8218},{9.24009,41.6818},{19.2401,43.7818},{29.2401,45.3118},{39.2401,46.4318},{49.2401,47.2518},{59.2401,47.8518},{69.2401,48.2918},{79.2401,48.6118}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -70,48},{26,94}}, textString = "%n", fontName = "Arial"),Text(visible = true, extent = {{8, -146},{8, -106}}, textString = "f=%f", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{40,0},{ -40,0}}),Text(visible = true, extent = {{ -55,5},{55,55}}, textString = "1", fontName = "Arial"),Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}}),Text(visible = true, extent = {{ -54, -56},{44, -6}}, textString = "(T s + 1)", fontName = "Arial"),Text(visible = true, extent = {{38, -30},{58, -10}}, textString = "n", fontName = "Arial")}), Documentation(info = "<html>
// <p>This block defines the transfer function between the
// input u and the output y
// as an n-th order filter with <i>critical damping</i>
// characteristics and cut-off frequency f=1/T. It is
// implemented as a series of first order filters.</p>
// <p>If transients at the simulation start shall be avoided
// the states x need to be initialized with the start value of
// the input.</p>
// <pre>
//                k
//      y = ------------- * u
//          (T * s + 1)^n
// </pre>
//  
// </HTML>
// "));
//       protected 
//         parameter Real w = 2 * Modelica.Constants.pi * f;
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(x) = zeros(n);
// 
//         elseif initType == Init.InitialState then
//           x = x_start;
// 
// 
//         elseif initType == Init.InitialOutput then
//           y = y_start;
//           der(x[1:n - 1]) = zeros(n - 1);
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         der(x[1]) = (u - x[1]) * w;
//         for i in 2:n loop
//         der(x[i]) = (x[i - 1] - x[i]) * w;
// 
//         end for;
//         y = x[n];
//       end CriticalDamping;
//     end Continuous;
//     package Discrete "Discrete input/output blocks with fixed sample period"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains <b>discrete control blocks</b>
// with <b>fixed sample period</b>.
// Every component of this package is structured in the following way:
// </p>
// <ol>
// <li> A component has <b>continuous real</b> input and output signals.</li>
// <li> The <b>input</b> signals are <b>sampled</b> by the given sample period
//      defined via parameter <b>samplePeriod</b>.
//      The first sample instant is defined by parameter <b>startTime</b>.
// <li> The <b>output</b> signals are computed from the sampled input signals.
// </ol>
// <p>
// A <b>sampled data system</b> may consist of components of package <b>Discrete</b>
// and of every other purely <b>algebraic</b> input/output block, such
// as the components of packages <b>Modelica.Blocks.Math</b>,
// <b>Modelica.Blocks.Nonlinear</b> or <b>Modelica.Blocks.Sources</b>.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New components TriggeredSampler and TriggeredMax added.</li>
// <li><i>June 18, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized based on a corresponding library of Dieter Moormann and
//        Hilding Elmqvist.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       block Sampler "Ideal sampling of continuous signals"
//         extends Interfaces.DiscreteSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{ -35,0},{30,35}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{ -35,0},{30,35}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Samples the continues input signal with a sampling rate defined
// via parameter <b>samplePeriod</b>.
// </p>
// </HTML>
// "));
// 
//       equation 
//         when {sampleTrigger,initial()} then
//                   y = u;
//         
//         end when;
//       end Sampler;
//       block ZeroOrderHold "Zero order hold of a sampled-data system"
//         extends Interfaces.DiscreteSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -78, -42},{ -52, -42},{ -52,0},{ -26,0},{ -26,24},{ -6,24},{ -6,64},{18,64},{18,20},{38,20},{38,0},{44,0},{44,0},{62,0}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Real ySample;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -78, -42},{ -52, -42},{ -52,0},{ -26,0},{ -26,24},{ -6,24},{ -6,64},{18,64},{18,20},{38,20},{38,0},{44,0},{44,0},{62,0}})}), Documentation(info = "<HTML>
// <p>
// The output is identical to the sampled input signal at sample
// time instants and holds the output at the value of the last
// sample instant during the sample points.
// </p>
// </HTML>
// "));
// 
//       equation 
//         when {sampleTrigger,initial()} then
//                   ySample = u;
//         
//         end when;
//         y = pre(ySample);
//       end ZeroOrderHold;
//       block FirstOrderHold "First order hold of a sampled-data system"
//         extends Interfaces.DiscreteSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -79, -41},{ -59, -33},{ -40,1},{ -20,9},{0,63},{21,20},{41,10},{60,20}}),Line(visible = true, points = {{60,19},{81,10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Real ySample;
//         Real tSample;
//         Real c;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -79, -41},{ -59, -33},{ -40,1},{ -20,9},{0,63},{21,20},{41,10},{60,20}}),Line(points = {{60,19},{81,10}})}), Documentation(info = "<HTML>
// <p>
// The output signal is the extrapolation through the
// values of the last two sampled input signals.
// </p>
// </HTML>
// "));
// 
//       equation 
//         when sampleTrigger then
//                   ySample = u;
//           tSample = time;
//           c = if firstTrigger then 0 else (ySample - pre(ySample)) / samplePeriod;
//         
//         end when;
//         y = pre(ySample) + pre(c) * (time - tSample);
//       end FirstOrderHold;
//       block UnitDelay "Unit Delay Block"
//         parameter Real y_start = 0 "Initial value of output signal";
//         extends Interfaces.DiscreteSISO;
//         annotation(Documentation(info = "<html>
// <p>
// This block describes a unit delay:
// </p>
// <pre>
//           1
//      y = --- * u
//           z
// </pre>
// <p>
// that is, the output signal y is the input signal u of the
// previous sample instant. Before the second sample instant,
// the output y is identical to parameter yStart.
// </p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -30,0},{30,0}}),Text(visible = true, extent = {{ -90,10},{90,90}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -90, -90},{90, -10}}, textString = "z", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -160, -10},{ -140,10}}, textString = "u", fontName = "Arial"),Text(visible = true, extent = {{115, -10},{135,10}}, textString = "y", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -60,0}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{ -40,0}}),Text(visible = true, extent = {{ -55,5},{55,55}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -55, -55},{55, -5}}, textString = "z", fontName = "Arial")}));
// 
//       equation 
//         when sampleTrigger then
//                   y = pre(u);
//         
//         end when;
// 
//       initial equation 
//         y = y_start;
//       end UnitDelay;
//       block TransferFunction "Discrete Transfer Function block"
//         parameter Real b[:] = {1} "Numerator coefficients of transfer function.";
//         parameter Real a[:] = {1,1} "Denominator coefficients of transfer function.";
//         extends Interfaces.DiscreteSISO;
//         output Real x[size(a, 1) - 1] "State of transfer function from controller canonical form";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{82,0},{ -84,0}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -92,12},{86,92}}, textString = "b(z)", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -90, -90},{90, -12}}, textString = "a(z)", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{40,0},{ -44,0}}, thickness = 0.5),Text(visible = true, extent = {{ -54,4},{54,54}}, textString = "b(z)", fontName = "Arial"),Text(visible = true, extent = {{ -54, -56},{56, -6}}, textString = "a(z)", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}));
//       protected 
//         parameter Integer nb = size(b, 1) "Size of Numerator of transfer function";
//         parameter Integer na = size(a, 1) "Size of Denominator of transfer function";
//         Real x1;
//         Real xext[size(a, 1)];
//         annotation(Documentation(info = "<html>
// <p>The <b>discrete transfer function</b> block defines the
// transfer function between the input signal u and the output
// signal y. The numerator has the order nb-1, the denominator
// has the order na-1.</p>
// <pre>          b(1)*z^(nb-1) + b(2)*z^(nb-2) + ... + b(nb)
//    y(z) = -------------------------------------------- * u(z)
//           a(1)*z^(na-1) + a(2)*z^(na-2) + ... + a(na)
// </pre>
// <p>State variables <b>x</b> are defined according to
// <b>controller canonical</b> form. Initial values of the
// states can be set as start values of <b>x</b>.<p>
// <p>Example:</p>
// <pre>     Blocks.Discrete.TransferFunction g(b = {2,4}, a = {1,3});
// </pre>
// <p>results in the following transfer function:</p>
// <pre>        2*z + 4
//    y = --------- * u
//          z + 3
// </pre>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>November 15, 2000</i>
//     by <a href=\"http://www.dynasim.se\">Hans Olsson</a>:<br>
//     Converted to when-semantics of Modelica 1.4 with special
//     care to avoid unnecessary algebraic loops.</li>
// <li><i>June 18, 2000</i>
//     by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//     Realized based on a corresponding model of Dieter Moormann
//     and Hilding Elmqvist.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{82,0},{ -84,0}}, color = {0,0,255}),Text(extent = {{ -92,92},{86,12}}, textString = "b(z)", fillColor = {0,0,255}),Text(extent = {{ -90, -12},{90, -90}}, textString = "a(z)", fillColor = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -60,60},{60, -60}}, fillPattern = FillPattern.None),Line(points = {{40,0},{ -44,0}}, color = {0,0,0}, thickness = 0.5),Text(extent = {{ -54,54},{54,4}}, textString = "b(z)", fillColor = {0,0,0}),Text(extent = {{ -54, -6},{56, -56}}, textString = "a(z)", fillColor = {0,0,0}),Line(points = {{ -100,0},{ -60,0}}),Line(points = {{60,0},{100,0}})}));
// 
//       equation 
//         when sampleTrigger then
//                   x1 = (u - a[2:size(a, 1)] * pre(x)) / a[1];
//           xext = vector([x1;pre(x)]);
//           x = xext[1:size(x, 1)];
//           y = vector([zeros(na - nb, 1);b]) * xext;
//         
//         end when;
//       end TransferFunction;
//       block StateSpace "Discrete State Space block"
//         parameter Real A[:,size(A, 1)] = [1,0;0,1] "Matrix A of state space model";
//         parameter Real B[size(A, 1),:] = [1;1] "Matrix B of state space model";
//         parameter Real C[:,size(A, 1)] = [1,1] "Matrix C of state space model";
//         parameter Real D[size(C, 1),size(B, 2)] = zeros(size(C, 1), size(B, 2)) "Matrix D of state space model";
//         extends Interfaces.DiscreteMIMO(final nin = size(B, 2), final nout = size(C, 1));
//         output Real x[size(A, 1)] "State vector";
//         annotation(Documentation(info = "<html>
// <p>
// The <b>discrete state space</b> block defines the relation
// between the input u=inPort.signal and the output
// y=outPort.signal in state space form:
// </p>
// <pre>
//     x = A * pre(x) + B * u
//     y = C * pre(x) + D * u
// </pre>
// <p>
// where pre(x) is the value of the discrete state x at
// the previous sample time instant.
// The input is a vector of length nu, the output is a vector
// of length ny and nx is the number of states. Accordingly
// </p>
// <pre>
//         A has the dimension: A(nx,nx),
//         B has the dimension: B(nx,nu),
//         C has the dimension: C(ny,nx),
//         D has the dimension: D(ny,nu)
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter: A = [0.12, 2;3, 1.5]
//      parameter: B = [2, 7;3, 1]
//      parameter: C = [0.1, 2]
//      parameter: D = zeros(ny,nu)
// 
// results in the following equations:
//   [x[1]]   [0.12  2.00] [pre(x[1])]   [2.0  7.0] [u[1]]
//   [    ] = [          ]*[         ] + [        ]*[    ]
//   [x[2]]   [3.00  1.50] [pre(x[2])]   [0.1  2.0] [u[2]]
//                              [pre(x[1])]            [u[1]]
//        y[1]   = [0.1  2.0] * [         ] + [0  0] * [    ]
//                              [pre(x[2])]            [u[2]]
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90,15},{ -15,90}}, textString = "A", fontName = "Arial"),Text(visible = true, extent = {{15,15},{90,90}}, textString = "B", fontName = "Arial"),Text(visible = true, extent = {{ -52, -20},{54,28}}, textString = "z", fontName = "Arial"),Text(visible = true, extent = {{ -90, -90},{ -15, -15}}, textString = "C", fontName = "Arial"),Text(visible = true, extent = {{15, -90},{90, -15}}, textString = "D", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -60, -60},{60,60}}),Text(visible = true, extent = {{ -54, -10},{52,50}}, textString = "zx=Ax+Bu", fontName = "Arial"),Text(visible = true, extent = {{ -56, -50},{54,14}}, textString = "  y=Cx+Du", fontName = "Arial"),Line(visible = true, points = {{ -102,0},{ -60,0}}),Line(visible = true, points = {{60,0},{100,0}})}));
// 
//       equation 
//         when sampleTrigger then
//                   x = A * pre(x) + B * u;
//           y = C * pre(x) + D * u;
//         
//         end when;
//       end StateSpace;
//       block TriggeredSampler "Triggered sampling of continuous signals"
//         extends Interfaces.DiscreteBlockIcon;
//         replaceable type SignalType = Real "type of input and output signal" annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         parameter SignalType y_start = 0 "initial value of output signal";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{0, -100},{0, -26}}, color = {255,0,255}),Line(visible = true, points = {{ -35,0},{28, -48}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{ -35,0},{28, -48}}, color = {0,0,255}),Line(visible = true, points = {{0, -100},{0, -26}}, color = {255,0,255})}), Documentation(info = "<HTML>
// <p>
// Samples the continuous input signal whenever the trigger input
// signal is rising (i.e., trigger changes from <b>false</b> to
// <b>true</b>) and provides the sampled input signal as output.
// Before the first sampling, the output signal is equal to
// the initial value defined via parameter <b>y0</b>.
// </p>
// </HTML>
// "));
//         Modelica.Blocks.Interfaces.RealInput u(redeclare type SignalType = SignalType) "Connector with an input signal of type SignalType" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y(redeclare type SignalType = SignalType) "Connector with an output signal of type SignalType" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.BooleanInput trigger annotation(Placement(visible = true, transformation(origin = {1.77636e-15, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270)));
// 
//       equation 
//         when trigger then
//                   y = u;
//         
//         end when;
// 
//       initial equation 
//         y = y_start;
//       end TriggeredSampler;
//       block TriggeredMax "Compute maximum, absolute value of continuous signal at trigger instants"
//         extends Interfaces.DiscreteBlockIcon;
//         replaceable type SignalType = Real "type of input and output signal" annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{0, -100},{0, -26}}, color = {255,0,255}),Line(visible = true, points = {{ -35,0},{28, -48}}, color = {0,0,255}),Text(visible = true, extent = {{ -86,24},{82,82}}, textString = "max", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -45, -10},{ -25,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{25, -10},{45,10}}),Line(visible = true, points = {{ -100,0},{ -45,0}}, color = {0,0,255}),Line(visible = true, points = {{45,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{ -35,0},{28, -48}}, color = {0,0,255}),Line(visible = true, points = {{0, -100},{0, -26}}, color = {255,0,255})}), Documentation(info = "<HTML>
// <p>
// Samples the continuous input signal whenever the trigger input
// signal is rising (i.e., trigger changes from <b>false</b> to
// <b>true</b>). The maximum, absolute value of the input signal
// at the sampling point is provided as output signal.
// </p>
// </HTML>
// "));
//         Modelica.Blocks.Interfaces.RealInput u(redeclare type SignalType = SignalType) "Connector with an input signal of type SignalType" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y(redeclare type SignalType = SignalType) "Connector with an output signal of type SignalType" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.BooleanInput trigger annotation(Placement(visible = true, transformation(origin = { -2.66454e-15, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270), iconTransformation(origin = { -4.44089e-16, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270)));
// 
//       equation 
//         when trigger then
//                   y = max(pre(y), abs(u));
//         
//         end when;
// 
//       initial equation 
//         y = 0;
//       end TriggeredMax;
//     end Discrete;
//     package Interfaces "Connectors and partial models for input/output blocks"
//       import Modelica.SIunits;
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains interface definitions for
// <b>continuous</b> input/output blocks with Real,
// Integer and Boolean signals. Furthermore, it contains
// partial models for continuous and discrete blocks.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added several new interfaces. <a href=\"../Documentation/ChangeNotes1.5.html\">Detailed description</a> available.
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        RealInputSignal renamed to RealInput. RealOutputSignal renamed to
//        output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
//        SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
//        SignalGenerator renamed to SignalSource. Introduced the following
//        new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
//        DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
//        BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{0,0},{733, -491}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       connector RealSignal "Real port (both input/output possible)"
//         replaceable type SignalType = Real annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends SignalType;
//         annotation(Documentation(info = "<html>
// <p>
// Connector with one signal of type Real (no icon, no input/output prefix).
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end RealSignal;
//       connector BooleanSignal = Boolean "Boolean port (both input/output possible)" annotation(Documentation(info = "<html>
// <p>
// Connector with one signal of type Boolean (no icon, no input/output prefix).
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       connector IntegerSignal = Integer "Integer port (both input/output possible)" annotation(Documentation(info = "<html>
// <p>
// Connector with one signal of type Icon (no icon, no input/output prefix).
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       connector RealInput = input RealSignal "'input Real' as connector" annotation(defaultComponentName = "u", Documentation(info = "<html>
// <p>
// Connector with one input signal of type Real.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,127}, fillColor = {0,0,127}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,127}, fillColor = {0,0,127}, fillPattern = FillPattern.Solid, points = {{0,50},{100,0},{0, -50},{0,50}}),Text(visible = true, fillColor = {0,0,127}, extent = {{ -120,60},{100,105}}, textString = "%name", fontName = "Arial")}));
//       connector RealOutput = output RealSignal "'output Real' as connector" annotation(defaultComponentName = "y", Documentation(info = "<html>
// <p>
// Connector with one output signal of type Real.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{0,0},{ -100, -50},{ -100,50}}),Text(visible = true, fillColor = {0,0,127}, extent = {{ -100,60},{130,140}}, textString = "%name", fontName = "Arial")}));
//       connector BooleanInput = input BooleanSignal "'input Boolean' as connector" annotation(defaultComponentName = "u", Documentation(info = "<html>
// <p>
// Connector with one input signal of type Boolean.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{0,50},{100,0},{0, -50},{0,50}}),Text(visible = true, fillColor = {255,0,255}, extent = {{ -120,60},{100,105}}, textString = "%name", fontName = "Arial")}));
//       connector BooleanOutput = output BooleanSignal "'output Boolean' as connector" annotation(defaultComponentName = "y", Documentation(info = "<html>
// <p>
// Connector with one output signal of type Boolean.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{0,0},{ -100, -50},{ -100,50}}),Text(visible = true, fillColor = {255,0,255}, extent = {{ -100,60},{130,140}}, textString = "%name", fontName = "Arial")}));
//       connector IntegerInput = input IntegerSignal "'input Integer' as connector" annotation(defaultComponentName = "u", Documentation(info = "<html>
// <p>
// Connector with one input signal of type Integer.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,127,0}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,127,0}, fillPattern = FillPattern.Solid, points = {{0,50},{100,0},{0, -50},{0,50}}),Text(visible = true, fillColor = {255,127,0}, extent = {{ -120,60},{100,105}}, textString = "%name", fontName = "Arial")}));
//       connector IntegerOutput = output IntegerSignal "'output Integer' as connector" annotation(defaultComponentName = "y", Documentation(info = "<html>
// <p>
// Connector with one output signal of type Integer.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{0,0},{ -100, -50},{ -100,50}}),Text(visible = true, fillColor = {255,127,0}, extent = {{ -100,60},{130,140}}, textString = "%name", fontName = "Arial")}));
//       partial block BlockIcon "Basic graphical layout of input/output block"
//         annotation(Documentation(info = "<html>
// <p>
// Block that has only the basic icon for an input/output
// block (no declarations, no equations). Most blocks
// of package Modelica.Blocks inherit directly or indirectly
// from this block.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end BlockIcon;
//       partial block SO "Single Output continuous control block"
//         extends BlockIcon;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// <p>
// Block has one continuous Real output signal.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end SO;
//       partial block MO "Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nout(min = 1) = 1 "Number of outputs";
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous Real output signal vector.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealOutput y[nout] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MO;
//       partial block SISO "Single Input Single Output continuous control block"
//         extends BlockIcon;
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous Real input and one continuous Real output signal.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u "Connector of Real input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end SISO;
//       partial block SI2SO "2 Single Input / 1 Single Output continuous control block"
//         extends BlockIcon;
//         annotation(Documentation(info = "<html>
// <p>
// Block has two continuous Real input signals u1 and u2 and one
// continuous Real output signal y.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u1 "Connector of Real input signal 1" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealInput u2 "Connector of Real input signal 2" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end SI2SO;
//       partial block SIMO "Single Input Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nout = 1 "Number of outputs";
//         annotation(Documentation(info = "<HTML>
// <p> Block has one continuous Real input signal and a
//     vector of continuous Real output signals.</p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u "Connector of Real input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y[nout] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end SIMO;
//       partial block MISO "Multiple Input Single Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nin = 1 "Number of inputs";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a vector of continuous Real input signals and
// one continuous Real output signal.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u[nin] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MISO;
//       partial block MIMO "Multiple Input Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nin = 1 "Number of inputs";
//         parameter Integer nout = 1 "Number of outputs";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous Real input and a continuous Real output signal vector.
// The signal sizes of the input and output vector may be different.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u[nin] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y[nout] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MIMO;
//       partial block MIMOs "Multiple Input Multiple Output continuous control block with same number of inputs and outputs"
//         extends BlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous Real input and a continuous Real output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u[n] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y[n] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MIMOs;
//       partial block MI2MO "2 Multiple Input / Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer n = 1 "Dimension of input and output vectors.";
//         annotation(Documentation(info = "<html>
// <p>
// Block has two continuous Real input vectors u1 and u2 and one
// continuous Real output vector y.
// All vectors have the same number of elements.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u1[n] "Connector 1 of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealInput u2[n] "Connector 2 of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y[n] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MI2MO;
//       partial block SignalSource "Base class for continuous signal source"
//         extends SO;
//         parameter Real offset = 0 "offset of output signal";
//         parameter SIunits.Time startTime = 0 "output = offset for time < startTime";
//         annotation(Documentation(info = "<html>
// <p>
// Basic block for Real sources of package Blocks.Sources.
// This component has one continuous Real output signal y
// and two parameters (offset, startTime) to shift the
// generated signal.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end SignalSource;
//       partial block SVcontrol "Single-Variable continuous controller"
//         extends BlockIcon;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -142,24},{ -102,34}}, textString = "(setpoint)", fontName = "Arial"),Text(visible = true, extent = {{100,14},{140,24}}, textString = "(actuator)", fontName = "Arial"),Text(visible = true, extent = {{ -83, -112},{ -33, -102}}, textString = " (measurement)", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// Block has two continuous Real input signals and one
// continuous Real output signal. The block is designed
// to be used as base class for a corresponding controller.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u_s "Connector of setpoint input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y "Connector of actuator output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         RealInput u_m "Connector of measurement input signal" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
//       end SVcontrol;
//       partial block MVcontrol "Multi-Variable continuous controller"
//         extends BlockIcon;
//         parameter Integer nu_s = 1 "Number of setpoint inputs";
//         parameter Integer nu_m = 1 "Number of measurement inputs";
//         parameter Integer ny = 1 "Number of actuator outputs";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -140,26},{ -100,36}}, textString = "(setpoint)", fontName = "Arial"),Text(visible = true, extent = {{102,14},{142,24}}, textString = "(actuator)", fontName = "Arial"),Text(visible = true, extent = {{ -75, -108},{ -25, -98}}, textString = " (measurement)", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// Block has two continuous Real input signal vectors and one
// continuous Real output signal vector. The block is designed
// to be used as base class for a corresponding controller.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u_s[nu_s] "Connector of setpoint input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y[ny] "Connector of actuator output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         RealInput u_m[nu_m] "Connector of measurement input signals" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
//       end MVcontrol;
//       partial block DiscreteBlockIcon "Graphical layout of discrete block component icon"
//         annotation(Documentation(info = "<html>
// <p>
// Block that has only the basic icon for an input/output,
// discrete block (no declarations, no equations), e.g.,
// from Blocks.Discrete.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {223,223,159}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end DiscreteBlockIcon;
//       partial block DiscreteBlock "Base class of discrete control blocks"
//         extends DiscreteBlockIcon;
//         parameter SI.Time samplePeriod(min = 100 * Modelica.Constants.eps) = 0.1 "Sample period of component";
//         parameter SI.Time startTime = 0 "First sample time instant";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         output Boolean sampleTrigger "True, if sample time instant";
//         output Boolean firstTrigger "Rising edge signals first sample instant";
// 
//       equation 
//         sampleTrigger = sample(startTime, samplePeriod);
//         when sampleTrigger then
//                   firstTrigger = time <= startTime + samplePeriod / 2;
//         
//         end when;
//         annotation(Documentation(info = "<html>
// <p>
// Basic definitions of a discrete block of library
// Blocks.Discrete.
// </p>
// </html>"));
//       end DiscreteBlock;
//       partial block DiscreteSISO "Single Input Single Output discrete control block"
//         extends DiscreteBlock;
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous input and one continuous output signal
// which are sampled due to the defined <b>samplePeriod</b> parameter.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.RealInput u "Continuous input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y "Continuous output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end DiscreteSISO;
//       partial block DiscreteMIMO "Multiple Input Multiple Output discrete control block"
//         extends DiscreteBlock;
//         parameter Integer nin = 1 "Number of inputs";
//         parameter Integer nout = 1 "Number of outputs";
//         annotation(Documentation(info = "<html>
// <p>
// Block has a continuous input and a continuous output signal vector
// which are sampled due to the defined <b>samplePeriod</b> parameter.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.RealInput u[nin] "Continuous input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[nout] "Continuous output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end DiscreteMIMO;
//       partial block DiscreteMIMOs "Multiple Input Multiple Output discrete control block"
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         extends DiscreteBlock;
//         annotation(Documentation(info = "<html>
// <p>
// Block has a continuous input and a continuous output signal vector
// where the signal sizes of the input and output vector are identical.
// These signals are sampled due to the defined <b>samplePeriod</b> parameter.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.RealInput u[n] "Continuous input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n] "Continuous output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end DiscreteMIMOs;
//       partial block SVdiscrete "Discrete Single-Variable controller"
//         extends DiscreteBlock;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -140,24},{ -100,34}}, textString = "(setpoint)", fontName = "Arial"),Text(visible = true, extent = {{100,14},{130,22}}, textString = "(actuator)", fontName = "Arial"),Text(visible = true, extent = {{ -70, -112},{ -20, -102}}, textString = " (measurement)", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// Block has two continuous Real input signals and one
// continuous Real output signal
// that are sampled due to the defined <b>samplePeriod</b> parameter.
// The block is designed
// to be used as base class for a corresponding controller.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Discrete.Sampler sampler_s(final samplePeriod = samplePeriod, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = { -90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Discrete.Sampler sampler_m(final samplePeriod = samplePeriod, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {0, -90}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Modelica.Blocks.Interfaces.RealInput u_s "Continuous scalar setpoint input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y "Continuous scalar actuator output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u_m "Continuous scalar measurement input signal" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
// 
//       equation 
//         connect(u_s,sampler_s.u) annotation(Line(visible = true, points = {{ -120,0},{ -102,0}}));
//         connect(u_m,sampler_m.u) annotation(Line(visible = true, points = {{0, -120},{0, -111},{0, -102},{0, -78}}));
//       end SVdiscrete;
//       partial block MVdiscrete "Discrete Multi-Variable controller"
//         extends DiscreteBlock;
//         parameter Integer nu_s = 1 "Number of setpoint inputs";
//         parameter Integer nu_m = 1 "Number of measurement inputs";
//         parameter Integer ny = 1 "Number of actuator outputs";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100, -30},{ -80, -10}}, textString = "u_s", fontName = "Arial"),Text(visible = true, extent = {{ -138,24},{ -98,34}}, textString = "(setpoint)", fontName = "Arial"),Text(visible = true, extent = {{98,14},{138,24}}, textString = "(actuator)", fontName = "Arial"),Text(visible = true, extent = {{ -62, -110},{ -12, -100}}, textString = " (measurement)", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// Block has two continuous Real input signal vectors and one
// continuous Real output signal vector. The vector signals
// are sampled due to the defined <b>samplePeriod</b> parameter.
// The block is designed
// to be used as base class for a corresponding controller.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Discrete.Sampler sampler_s[nu_s](each final samplePeriod = samplePeriod, each final startTime = startTime) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Discrete.Sampler sampler_m[nu_m](each final samplePeriod = samplePeriod, each final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {0, -80}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Modelica.Blocks.Interfaces.RealInput u_s[nu_s] "Continuous setpoint input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[ny] "Continuous actuator output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u_m[nu_m] "Continuous measurement input signals" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
// 
//       equation 
//         connect(u_s,sampler_s.u) annotation(Line(visible = true, points = {{ -120,0},{ -92,0}}));
//         connect(u_m,sampler_m.u) annotation(Line(visible = true, points = {{0, -120},{0, -106},{0, -92},{0, -68}}));
//       end MVdiscrete;
//       partial block BooleanBlockIcon "Basic graphical layout of Boolean block"
//         annotation(Documentation(info = "<html>
// <p>
// Block that has only the basic icon for an input/output,
// Boolean block (no declarations, no equations).
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end BooleanBlockIcon;
//       partial block BooleanSISO "Single Input Single Output control block with signals of type Boolean"
//         extends BooleanBlockIcon;
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous Boolean input and one continuous Boolean output signal.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         BooleanInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end BooleanSISO;
//       partial block BooleanMIMOs "Multiple Input Multiple Output continuous control block with same number of inputs and outputs of boolean type"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous Boolean input and a continuous Boolean output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         BooleanInput u[n] "Connector of Boolean input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         BooleanOutput y[n] "Connector of Boolean output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end BooleanMIMOs;
//       partial block MI2BooleanMOs "2 Multiple Input / Boolean Multiple Output block with same signal lengths"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Dimension of input and output vectors.";
//         annotation(Documentation(info = "<html>
// <p>Block has two Boolean input vectors u1 and u2 and one Boolean output
// vector y. All vectors have the same number of elements.</p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u1[n] "Connector 1 of Boolean input signals" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealInput u2[n] "Connector 2 of Boolean input signals" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         BooleanOutput y[n] "Connector of Boolean output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end MI2BooleanMOs;
//       partial block SI2BooleanSO "2 Single Input / Boolean Single Output block"
//         extends BooleanBlockIcon;
//         annotation(Documentation(info = "<html>
// <p>
// Block has two Boolean input signals u1 and u2 and one Boolean output signal y.
// </p>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         input RealInput u1 "Connector 1 of Boolean input signals" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         input RealInput u2 "Connector 2 of Boolean input signals" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         output BooleanOutput y "Connector of Boolean output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end SI2BooleanSO;
//       partial block BooleanSignalSource "Base class for Boolean signal sources"
//         extends BooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{68, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// <p>
// Basic block for Boolean sources of package Blocks.Sources.
// This component has one continuous Boolean output signal y.
// </p>
// </html>"));
//         BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end BooleanSignalSource;
//       partial block IntegerBlockIcon "Basic graphical layout of Integer block"
//         annotation(Documentation(info = "<html>
// <p>
// Block that has only the basic icon for an input/output,
// Integer block (no declarations, no equations).
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end IntegerBlockIcon;
//       partial block IntegerSO "Single Integer Output continuous control block"
//         extends IntegerBlockIcon;
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous Integer output signal.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         IntegerOutput y "Connector of Integer output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end IntegerSO;
//       partial block IntegerMO "Multiple Integer Output continuous control block"
//         extends IntegerBlockIcon;
//         parameter Integer nout(min = 1) = 1 "Number of outputs";
//         annotation(Documentation(info = "<html>
// <p>
// Block has one continuous Integer output signal vector.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         IntegerOutput y[nout] "Connector of Integer output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end IntegerMO;
//       partial block IntegerSignalSource "Base class for continuous Integer signal source"
//         extends IntegerSO;
//         parameter Integer offset = 0 "offset of output signal";
//         parameter SI.Time startTime = 0 "y = offset for time < startTime";
//         annotation(Documentation(info = "<html>
// <p>
// Basic block for Integer sources of package Blocks.Sources.
// This component has one continuous Integer output signal y
// and two parameters (offset, startTime) to shift the
// generated signal.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end IntegerSignalSource;
//       partial block IntegerSIBooleanSO "Integer Input Boolean Output continuous control block"
//         extends BooleanBlockIcon;
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous Integer input and a continuous Boolean output signal.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         IntegerInput u "Connector of Integer input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end IntegerSIBooleanSO;
//       partial block IntegerMIBooleanMOs "Multiple Integer Input Multiple Boolean Output continuous control block with same number of inputs and outputs"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous Integer input and a continuous Boolean output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         IntegerInput u[n] "Connector of Integer input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         BooleanOutput y[n] "Connector of Boolean output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end IntegerMIBooleanMOs;
//       partial block partialBooleanBlockIcon "Basic graphical layout of logical block"
//         annotation(Documentation(info = "<html>
// <p>
// Block that has only the basic icon for an input/output,
// Boolean block (no declarations, no equations) used especially
// in the Blocks.Logical library.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end partialBooleanBlockIcon;
//       partial block partialBooleanSISO "partialSingle Input / Single Output Boolean block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -7},{ -71,7}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Documentation(info = "<html>
// <p>
// Block has one continuous Boolean input and one continuous Boolean output signal
// with a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanSISO;
//       partial block partialBooleanSI2SO "partial2 Single Input / 1 Single Output Boolean block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -7},{ -71,7}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -88},{ -71, -74}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Documentation(info = "<html>
// <p>
// Block has two continuous Boolean input and one continuous Boolean output signal
// with a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.BooleanInput u1 "Connector of first Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanInput u2 "Connector of second Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanSI2SO;
//       partial block partialBooleanSI3SO "partial2 Single Input / 1 Single Output Boolean block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85,74},{ -71,88}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -7},{ -71,7}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -88},{ -71, -74}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Documentation(info = "<html>
// Block has three continuous Boolean input and one continuous Boolean output signal
// with a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.BooleanInput u1 "Connector of first Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanInput u2 "Connector of second Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanInput u3 "Connector of third Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanSI3SO;
//       partial block partialBooleanSI "partialSingle Input Boolean block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -85, -7},{ -71,7}})}), Documentation(info = "<html>
// <p>
// Block has one continuous Boolean input signal
// with a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//       end partialBooleanSI;
//       partial block partialBooleanSO "partialSingle Output Boolean block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Documentation(info = "<html>
// <p>
// Block has one continuous Boolean output signal
// with a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanSO;
//       partial block partialBooleanSource "partialBoolean source block"
//         extends partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -80,88},{ -88,66},{ -72,66},{ -80,88}}),Line(visible = true, points = {{ -80,66},{ -80, -82}}, color = {255,0,255}),Line(visible = true, points = {{ -90, -70},{72, -70}}, color = {255,0,255}),Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,80},{ -88,58},{ -72,58},{ -80,80}}),Line(visible = true, points = {{ -80,58},{ -80, -90}}),Line(visible = true, points = {{ -90, -70},{68, -70}}),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, extent = {{54, -96},{106, -84}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -108,64},{ -92,80}}, textString = "y", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// Basic block for Boolean sources of package Blocks.Sources.
// This component has one continuous Boolean output signal y
// and a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanSource;
//       partial block partialBooleanThresholdComparison "partialBoolean block to compare the Real input u with a threshold"
//         parameter Real threshold = 0 "Comparison with respect to threshold";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -150, -140},{150, -110}}, textString = "%threshold", fontName = "Arial"),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{71, -7},{85,7}})}), Documentation(info = "<html>
// <p>
// Block has one continuous Real input and one continuous Boolean output signal
// as well as a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanThresholdComparison;
//       partial block partialBooleanComparison "partialBoolean block to compare two Real inputs u1 and u2"
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -100},{100,100}}),Ellipse(visible = true, fillColor = {235,235,235}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{73, -7},{87,7}}),Ellipse(visible = true, fillColor = {0,0,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{32, -10},{52,10}}),Line(visible = true, points = {{ -100, -80},{42, -80},{42,0}}, color = {0,0,255})}), Documentation(info = "<html>
// <p>
// Block has two continuous Real input and one continuous Boolean output signal
// as a result of the comparision of the two input signals. The block
// has a 3D icon (e.g. used in Blocks.Logical library).
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u1 "Connector of first Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.RealInput u2 "Connector of second Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end partialBooleanComparison;
//       package Adaptors "Components to send signals to a bus or receive signals from a bus"
//         extends Modelica.Icons.Library;
//         block SendReal "Send Real signal to bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -100, -30},{100,30}}, textString = "send", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           RealOutput toBus annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           RealInput u annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           toBus = u;
//         end SendReal;
//         block SendBoolean "Send Boolean signal to bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {255,0,255}, extent = {{ -100, -30},{100,30}}, textString = "send", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           BooleanOutput toBus annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           BooleanInput u annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           toBus = u;
//         end SendBoolean;
//         block SendInteger "Send Integer signal to bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {255,127,0}, extent = {{ -100, -30},{100,30}}, textString = "send", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           IntegerOutput toBus annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           IntegerInput u annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           toBus = u;
//         end SendInteger;
//         block ReceiveReal "Receive Real signal from bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -100, -30},{100,30}}, textString = "receive", fontName = "Arial"),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           RealInput fromBus annotation(Placement(visible = true, transformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           RealOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           y = fromBus;
//         end ReceiveReal;
//         block ReceiveBoolean "Receive Boolean signal from bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, fillColor = {255,0,255}, extent = {{ -100, -30},{100,30}}, textString = "receive", fontName = "Arial"),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           BooleanInput fromBus annotation(Placement(visible = true, transformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           BooleanOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           y = fromBus;
//         end ReceiveBoolean;
//         block ReceiveInteger "Receive Integer signal from bus"
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, fillColor = {255,127,0}, extent = {{ -100, -30},{100,30}}, textString = "receive", fontName = "Arial"),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           IntegerInput fromBus annotation(Placement(visible = true, transformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           IntegerOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           y = fromBus;
//         end ReceiveInteger;
//         model AdaptorReal "Adaptor between 'old' and 'new' Real signal connectors"
//           RealPort oldReal(final n = 1) annotation(extent = [ -120, -10; -100,10]);
//           annotation(structurallyIncomplete, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -88, -24},{88,22}}, textString = "adaptor", fontName = "Arial"),Text(visible = true, extent = {{ -216, -80},{36, -58}}, textString = "port.signal", fontName = "Arial")}), Documentation(info = ""), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           connector RealPort "Connector with signals of type Real"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Real "type of signal";
//             SignalType signal[n] "Real signals" annotation(Hide = true);
//           end RealPort;
//           RealSignal newReal annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           connector RealPort "Connector with signals of type Real"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Real "type of signal";
//             SignalType signal[n] "Real signals" annotation(Hide = true);
//           end RealPort;
// 
//         equation 
//           newReal = oldReal.signal[1];
//         end AdaptorReal;
//         model AdaptorBoolean "Adaptor between 'old' and 'new' Boolean signal connectors"
//           BooleanPort oldBoolean(final n = 1) annotation(extent = [ -120, -10; -100,10]);
//           annotation(structurallyIncomplete, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "", fontName = "Arial"),Text(visible = true, fillColor = {255,0,255}, extent = {{ -88, -24},{88,22}}, textString = "adaptor", fontName = "Arial"),Text(visible = true, extent = {{ -216, -80},{36, -58}}, textString = "port.signal", fontName = "Arial")}), Documentation(info = ""), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           connector BooleanPort "Connector with signals of type Boolean"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Boolean "type of signal";
//             SignalType signal[n] "Boolean signals" annotation(Hide = true);
//           end BooleanPort;
//           BooleanSignal newBoolean annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           connector BooleanPort "Connector with signals of type Boolean"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Boolean "type of signal";
//             SignalType signal[n] "Boolean signals" annotation(Hide = true);
//           end BooleanPort;
// 
//         equation 
//           newBoolean = oldBoolean.signal[1];
//         end AdaptorBoolean;
//         model AdaptorInteger "Adaptor between 'old' and 'new' Integer signal connectors"
//           IntegerPort oldInteger(final n = 1) annotation(extent = [ -120, -10; -100,10]);
//           annotation(structurallyIncomplete, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -144,46},{144,96}}, textString = "", fontName = "Arial"),Text(visible = true, fillColor = {255,127,0}, extent = {{ -88, -24},{88,22}}, textString = "adaptor", fontName = "Arial"),Text(visible = true, extent = {{ -216, -80},{36, -58}}, textString = "port.signal", fontName = "Arial")}), Documentation(info = "
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           connector IntegerPort "Connector with signals of type Integer"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Integer "type of signal";
//             SignalType signal[n] "Integer signals" annotation(Hide = true);
//           end IntegerPort;
//           IntegerSignal newInteger annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           connector IntegerPort "Connector with signals of type Integer"
//             parameter Integer n = 1 "Dimension of signal vector" annotation(Hide = true);
//             replaceable type SignalType = Integer "type of signal";
//             SignalType signal[n] "Integer signals" annotation(Hide = true);
//           end IntegerPort;
// 
//         equation 
//           newInteger = oldInteger.signal[1];
//         end AdaptorInteger;
//         annotation(Documentation(info = "<html>
// <p>
// The components of this package should no longer be used.
// They are only provided for backward compatibility issues.
// Modelica language at release 2.2) should be the basis
// to define signal buses.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Adaptors;
//       partial block PartialConversionBlock "Partial block defining the interface for conversion blocks"
//         annotation(Documentation(info = "<html>
// <p>
// This block defines the interface of a conversion block that
// converts from one unit into another one.
// </p>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -90,0},{30,0}}, color = {127,0,0}),Polygon(visible = true, lineColor = {127,0,0}, fillColor = {127,0,0}, fillPattern = FillPattern.Solid, points = {{90,0},{30,20},{30, -20},{90,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -115,105},{115,155}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         RealInput u "Connector of Real input signal to be converted" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         RealOutput y "Connector of Real output signal containing input signal u in another unit" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end PartialConversionBlock;
//     end Interfaces;
//     package Logical "Components with Boolean input and output signals"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package provides blocks with Boolean input and output signals
// to describe logical networks. A typical example for a logical
// network built with package Logical is shown in the next figure:
// </p>
// <p align=\"center\">
// <img src=\"../Images/LogicalNetwork1.png\">
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       model And "Logical 'and': y = u1 and u2"
//         extends Blocks.Interfaces.partialBooleanSI2SO;
//         annotation(defaultComponentName = "and1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "and", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u1 and u2;
//       end And;
//       model Or "Logical 'or': y = u1 or u2"
//         extends Blocks.Interfaces.partialBooleanSI2SO;
//         annotation(defaultComponentName = "or1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "or", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u1 or u2;
//       end Or;
//       model Xor "Logical 'xor': y = u1 xor u2"
//         extends Blocks.Interfaces.partialBooleanSI2SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "xor", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = not (u1 and u2 or not u1 and not u2);
//       end Xor;
//       model Nor "Logical 'nor': y = not (u1 or u2)"
//         extends Blocks.Interfaces.partialBooleanSI2SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "nor", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = not (u1 or u2);
//       end Nor;
//       model Nand "Logical 'nand': y = not (u1 and u2)"
//         extends Blocks.Interfaces.partialBooleanSI2SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "nand", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = not (u1 and u2);
//       end Nand;
//       model Not "Logical 'not': y = not u"
//         extends Blocks.Interfaces.partialBooleanSISO;
//         annotation(defaultComponentName = "not1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "not", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = not u;
//       end Not;
//       model Pre "y = pre(u): Breaks algebraic loops by an infinitesimal small time delay (event iteration continues until u = pre(u))"
//         parameter Boolean pre_u_start = false "Start value of pre(u) at initial time";
//         extends Blocks.Interfaces.partialBooleanSISO;
//         annotation(defaultComponentName = "pre1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "pre", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       initial equation 
//         pre(u) = pre_u_start;
// 
//       equation 
//         y = pre(u);
//       end Pre;
//       model Edge "y = edge(u): Output y is true, if the input u has a rising edge"
//         parameter Boolean pre_u_start = false "Start value of pre(u) at initial time";
//         extends Blocks.Interfaces.partialBooleanSISO;
//         annotation(defaultComponentName = "edge1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "edge", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       initial equation 
//         pre(u) = pre_u_start;
// 
//       equation 
//         y = edge(u);
//       end Edge;
//       model FallingEdge "y = edge(not u): Output y is true, if the input u has a falling edge"
//         parameter Boolean pre_u_start = false "Start value of pre(u) at initial time";
//         extends Blocks.Interfaces.partialBooleanSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "falling", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
//       protected 
//         Boolean not_u = not u;
// 
//       initial equation 
//         pre(not_u) = not pre_u_start;
// 
//       equation 
//         y = edge(not_u);
//       end FallingEdge;
//       model Change "y = change(u): Output y is true, if the input u has a rising or falling edge"
//         parameter Boolean pre_u_start = false "Start value of pre(u) at initial time";
//         extends Blocks.Interfaces.partialBooleanSISO;
//         annotation(defaultComponentName = "change1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{90,40}}, textString = "change", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       initial equation 
//         pre(u) = pre_u_start;
// 
//       equation 
//         y = change(u);
//       end Change;
//       block GreaterThreshold "Output y is true, if input u is greater than threshold"
//         extends Blocks.Interfaces.partialBooleanThresholdComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{60,40}}, textString = ">", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u > threshold;
//       end GreaterThreshold;
//       block GreaterEqualThreshold "Output y is true, if input u is greater or equal than threshold"
//         extends Blocks.Interfaces.partialBooleanThresholdComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{60,40}}, textString = ">=", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u >= threshold;
//       end GreaterEqualThreshold;
//       block LessThreshold "Output y is true, if input u is less than threshold"
//         extends Blocks.Interfaces.partialBooleanThresholdComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{60,40}}, textString = "<", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u < threshold;
//       end LessThreshold;
//       block LessEqualThreshold "Output y is true, if input u is less or equal than threshold"
//         extends Blocks.Interfaces.partialBooleanThresholdComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -90, -40},{60,40}}, textString = "<=", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         y = u <= threshold;
//       end LessEqualThreshold;
//       block Greater "Output y is true, if input u1 is greater as input u2"
//         extends Blocks.Interfaces.partialBooleanComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{32, -10},{52,10}}),Line(visible = true, points = {{ -100, -80},{42, -80},{42,0}}),Text(visible = true, extent = {{ -80, -60},{20,60}}, textString = ">", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = u1 > u2;
//       end Greater;
//       block GreaterEqual "Output y is true, if input u1 is greater or equal as input u2"
//         extends Blocks.Interfaces.partialBooleanComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{32, -10},{52,10}}),Line(visible = true, points = {{ -100, -80},{42, -80},{42,0}}),Text(visible = true, extent = {{ -80, -60},{20,60}}, textString = ">=", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = u1 >= u2;
//       end GreaterEqual;
//       block Less "Output y is true, if input u1 is less as input u2"
//         extends Blocks.Interfaces.partialBooleanComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{32, -10},{52,10}}),Line(visible = true, points = {{ -100, -80},{42, -80},{42,0}}),Text(visible = true, extent = {{ -80, -60},{20,60}}, textString = "<", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = u1 < u2;
//       end Less;
//       block LessEqual "Output y is true, if input u1 is less or equal as input u2"
//         extends Blocks.Interfaces.partialBooleanComparison;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{32, -10},{52,10}}),Line(visible = true, points = {{ -100, -80},{42, -80},{42,0}}),Text(visible = true, extent = {{ -80, -60},{20,60}}, textString = "<=", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = u1 <= u2;
//       end LessEqual;
//       block ZeroCrossing "Trigger zero crossing of input u"
//         extends Blocks.Interfaces.partialBooleanSO;
//         annotation(Documentation(info = "<HTML>
// <p>
// The output \"y\" is <b>true</b> at the
// time instant when the input \"u\" becomes
// zero, provided the input \"enable\" is
// <b>true</b>. At all other time instants, the output \"y\" is <b>false</b>.
// If the input \"u\" is zero at a time instant when the \"enable\"
// input changes its value, then the output y is <b>false</b>.
// </p>
// <p>
// Note, that in the plot window of a Modelica simulator, the output of
// this block is usually identically to <b>false</b>, because the output
// may only be <b>true</b> at an event instant, but not during
// continuous integration. In order to check that this component is
// actually working as expected, one should connect its output to, e.g.,
// component <i>ModelicaAdditions.Blocks.Discrete.TriggeredSampler</i>.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -78,68},{ -78, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -78,90},{ -86,68},{ -70,68},{ -78,90}}),Line(visible = true, points = {{ -88,0},{70,0}}, color = {192,192,192}),Line(visible = true, points = {{ -78,0},{ -73.2,32.3},{ -70,50.3},{ -66.7,64.5},{ -63.5,74.2},{ -60.3,79.3},{ -57.1,79.6},{ -53.9,75.3},{ -50.7,67.1},{ -46.6,52.2},{ -41,25.8},{ -33, -13.9},{ -28.2, -33.7},{ -24.1, -45.9},{ -20.1, -53.2},{ -16.1, -55.3},{ -12.1, -52.5},{ -8.1, -45.3},{ -3.23, -32.1},{10.44,13.7},{15.3,26.4},{20.1,34.8},{24.1,38},{28.9,37.2},{33.8,31.8},{40.2,19.4},{53.1, -10.5},{59.5, -21.2},{65.1, -25.9},{70.7, -25.9},{77.2, -20.5},{82, -13.8}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{92,0},{70,8},{70, -8},{92,0}}),Line(visible = true, points = {{ -36, -59},{ -36,81}}, color = {255,0,255}),Line(visible = true, points = {{6, -59},{6,81}}, color = {255,0,255}),Line(visible = true, points = {{49, -59},{49,81}}, color = {255,0,255}),Line(visible = true, points = {{ -78,0},{70,0}}, color = {255,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanInput enable "Zero input crossing is triggered if the enable input signal is true" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
//       protected 
//         Boolean disable = not enable;
//         Boolean u_pos;
// 
//       initial equation 
//         pre(u_pos) = false;
//         pre(enable) = false;
//         pre(disable) = not pre(enable);
// 
//       equation 
//         u_pos = enable and u >= 0;
//         y = change(u_pos) and not edge(enable) and not edge(disable);
//       end ZeroCrossing;
//       block LogicalSwitch "Logical Switch"
//         extends Blocks.Interfaces.partialBooleanSI3SO;
//         annotation(Documentation(info = "<html>
// <p>The LogicalSwitch switches, depending on the
// Boolean u2 connector (the middle connector),
// between the two possible input signals
// u1 (upper connector) and u3 (lower connector).</p>
// <p>If u2 is true, connector y is set equal to
// u1, else it is set equal to u2.</p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{12,0},{100,0}}, color = {255,0,255}),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {255,0,255}),Line(visible = true, points = {{ -100, -80},{ -40, -80},{ -40, -80}}, color = {255,0,255}),Line(visible = true, points = {{ -40,12},{ -40, -10}}, color = {255,0,255}),Line(visible = true, points = {{ -100,80},{ -40,80}}, color = {255,0,255}),Line(visible = true, points = {{ -40,80},{8,2}}, color = {255,0,127}, thickness = 1),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{2, -6},{18,8}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = if u2 then u1 else u3;
//       end LogicalSwitch;
//       block Switch "Switch between two Real signals"
//         extends Blocks.Interfaces.partialBooleanBlockIcon;
//         annotation(defaultComponentName = "switch1", Documentation(info = "<html>
// <p>The Logical.Switch switches, depending on the
// logical connector u2 (the middle connector)
// between the two possible input signals
// u1 (upper connector) and u3 (lower connector).</p>
// <p>If u2 is <b>true</b>, the output signal y is set equal to
// u1, else it is set equal to u3.</p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{12,0},{100,0}}),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {255,0,127}),Line(visible = true, points = {{ -100, -80},{ -40, -80},{ -40, -80}}),Line(visible = true, points = {{ -40,12},{ -40, -12}}, color = {255,0,127}),Line(visible = true, points = {{ -100,80},{ -38,80}}),Line(visible = true, points = {{ -38,80},{6,2}}, thickness = 1),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{2, -6},{18,8}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u1 "Connector of first Real input signal" annotation(Placement(visible = true, transformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanInput u2 "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.RealInput u3 "Connector of second Real input signal" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = if u2 then u1 else u3;
//       end Switch;
//       block Hysteresis "Transform Real to Boolean signal with Hysteresis"
//         extends Blocks.Interfaces.partialBooleanBlockIcon;
//         parameter Real uLow = 0 "if y=true and u<=uLow, switch to y=false";
//         parameter Real uHigh = 1 "if y=false and u>=uHigh, switch to y=true";
//         parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -65,89},{ -73,67},{ -57,67},{ -65,89}}),Line(visible = true, points = {{ -65,67},{ -65, -81}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -65,75},{ -12,93}}, textString = "y", fontName = "Arial"),Line(visible = true, points = {{ -80, -70},{30, -70}}, thickness = 0.5),Line(visible = true, points = {{ -50,10},{80,10}}, thickness = 0.5),Line(visible = true, points = {{ -50,10},{ -50, -70}}, thickness = 0.5),Line(visible = true, points = {{30,10},{30, -70}}, thickness = 0.5),Line(visible = true, points = {{ -10, -65},{0, -70},{ -10, -75}}, thickness = 0.5),Line(visible = true, points = {{ -10,15},{ -20,10},{ -10,5}}, thickness = 0.5),Line(visible = true, points = {{ -55, -20},{ -50, -30},{ -44, -20}}, thickness = 0.5),Line(visible = true, points = {{25, -30},{30, -19},{35, -30}}, thickness = 0.5),Text(visible = true, fillColor = {160,160,160}, extent = {{ -99,2},{ -70,18}}, textString = "true", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -98, -87},{ -66, -73}}, textString = "false", fontName = "Arial"),Text(visible = true, extent = {{19, -87},{44, -70}}, textString = "uHigh", fontName = "Arial"),Text(visible = true, extent = {{ -63, -88},{ -38, -71}}, textString = "uLow", fontName = "Arial"),Line(visible = true, points = {{ -69,10},{ -60,10}}, color = {160,160,160})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -29}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{92, -29},{70, -21},{70, -37},{92, -29}}),Line(visible = true, points = {{ -79, -29},{84, -29}}, color = {192,192,192}),Line(visible = true, points = {{ -79, -29},{41, -29}}),Line(visible = true, points = {{ -15, -21},{1, -29},{ -15, -36}}),Line(visible = true, points = {{41,51},{41, -29}}),Line(visible = true, points = {{33,3},{41,22},{50,3}}),Line(visible = true, points = {{ -49,51},{81,51}}),Line(visible = true, points = {{ -4,59},{ -19,51},{ -4,43}}),Line(visible = true, points = {{ -59,29},{ -49,11},{ -39,29}}),Line(visible = true, points = {{ -49,51},{ -49, -29}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -92, -92},{ -9, -49}}, textString = "%uLow", fontName = "Arial"),Text(visible = true, fillColor = {192,192,192}, extent = {{2, -92},{91, -49}}, textString = "%uHigh", fontName = "Arial"),Rectangle(visible = true, lineColor = {192,192,192}, extent = {{ -91, -92},{ -8, -49}}),Line(visible = true, points = {{ -49, -29},{ -49, -49}}, color = {192,192,192}),Rectangle(visible = true, lineColor = {192,192,192}, extent = {{2, -92},{91, -49}}),Line(visible = true, points = {{41, -29},{41, -49}}, color = {192,192,192})}), Documentation(info = "<HTML>
// <p>
// This block transforms a <b>Real</b> input signal into a <b>Boolean</b>
// output signal:
// </p>
// <ul>
// <li> When the output was <b>false</b> and the input becomes
//      <b>greater</b> than parameter <b>uHigh</b>, the output
//      switches to <b>true</b>.</li>
// <li> When the output was <b>true</b> and the input becomes
//      <b>less</b> than parameter <b>uLow</b>, the output
//      switches to <b>false</b>.</li>
// </ul>
// <p>
// The start value of the output is defined via parameter
// <b>pre_y_start</b> (= value of pre(y) at initial time).
// The default value of this parameter is <b>false</b>.
// </p>
// </HTML>
// "));
//         Blocks.Interfaces.RealInput u annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       initial equation 
//         pre(y) = pre_y_start;
// 
//       equation 
//         y = u > uHigh or pre(y) and u >= uLow;
//       end Hysteresis;
//       block OnOffController "On-off controller"
//         extends Interfaces.partialBooleanBlockIcon;
//         parameter Real bandwidth = 0.1 "Bandwidth around reference signal";
//         parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineThickness = 0.5, extent = {{ -92,44},{44,74}}, textString = "reference", fontName = "Arial"),Text(visible = true, extent = {{ -94, -74},{ -34, -52}}, textString = "u", fontName = "Arial"),Line(visible = true, points = {{ -76, -32},{ -68, -6},{ -50,26},{ -24,40},{ -2,42},{16,36},{32,28},{48,12},{58, -6},{68, -28}}),Line(visible = true, points = {{ -78, -2},{ -6,18},{82, -12}}, color = {255,0,0}),Line(visible = true, points = {{ -78,12},{ -6,30},{82,0}}),Line(visible = true, points = {{ -78, -16},{ -6,4},{82, -26}}),Line(visible = true, points = {{ -82, -18},{ -56, -18},{ -56, -40},{64, -40},{64, -20},{90, -20}}, color = {255,0,255})}), Documentation(info = "<html>
// <p>The block OnOffController sets the output signal <b>y</b> to <b>true</b> when
// the input signal <b>u</b> falls below the <b>reference</b> signal minus half of
// the bandwidth and sets the output signal <b>y</b> to <b>false</b> when the input
// signal <b>u</b> exceeds the <b>reference</b> signal plus half of the bandwidth.</p>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput reference "Connector of Real input signal used as reference signal" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20,20},{20, -20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20,20},{20, -20}}, rotation = 0)));
//         Blocks.Interfaces.RealInput u "Connector of Real input signal used as measurement signal" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20,20},{20, -20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20,20},{20, -20}}, rotation = 0)));
//         Blocks.Interfaces.BooleanOutput y "Connector of Real output signal used as actuator signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       initial equation 
//         pre(y) = pre_y_start;
// 
//       equation 
//         y = pre(y) and u < reference + bandwidth / 2 or u < reference - bandwidth / 2;
//       end OnOffController;
//       block TriggeredTrapezoid "Triggered trapezoid generator"
//         extends Interfaces.partialBooleanBlockIcon;
//         parameter Real amplitude = 1 "Amplitude of trapezoid";
//         parameter Modelica.SIunits.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//         parameter Modelica.SIunits.Time falling(final min = 0) = rising "Falling duration of trapezoid";
//         parameter Real offset = 0 "Offset of output signal";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60, -70},{ -60, -70},{ -30,40},{8,40},{40, -70},{40, -70}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -70},{ -60, -70},{ -60,24},{8,24},{8, -70},{60, -70}}, color = {255,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -20},{ -60, -20},{ -30,40},{8,40},{40, -20},{60, -20}}),Line(visible = true, points = {{ -90, -70},{82, -70}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -68},{ -60, -68},{ -60, -42},{8, -42},{8, -68},{60, -68}}, color = {255,0,255}),Line(visible = true, points = {{ -60,40},{ -60, -42}}, pattern = LinePattern.Dot),Line(visible = true, points = {{8, -42},{8,40}}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -60,40},{ -30,40}}),Line(visible = true, points = {{8, -20},{40, -20}}),Line(visible = true, points = {{ -20,40},{ -20, -20}}),Line(visible = true, points = {{ -20, -20},{ -20, -70}}),Text(visible = true, extent = {{ -44,40},{ -44,50}}, textString = "rising", fontName = "Arial"),Text(visible = true, extent = {{24, -20},{24, -10}}, textString = "falling", fontName = "Arial"),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -60,40},{ -56,42},{ -56,38},{ -60,40}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -30,40},{ -34,42},{ -34,38},{ -30,40}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{8, -20},{12, -18},{12, -22},{8, -20}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{40, -20},{36, -18},{36, -22},{40, -20}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -22, -24},{ -20, -20},{ -18, -24},{ -22, -24}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -18, -66},{ -22, -66},{ -20, -70},{ -18, -66}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -22,36},{ -20,40},{ -18,36},{ -22,36}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -18, -16},{ -22, -16},{ -20, -20},{ -18, -16}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -4},{0,6}}),Text(visible = true, extent = {{ -20, -4},{ -20,6}}, textString = "amplitude", fontName = "Arial"),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -58},{0, -48}}),Text(visible = true, extent = {{ -20, -58},{ -20, -48}}, textString = "offset", fontName = "Arial"),Text(visible = true, extent = {{60, -92},{94, -82}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -88, -14},{ -54, -4}}, textString = "y", fontName = "Arial"),Text(visible = true, extent = {{ -88, -56},{ -54, -46}}, textString = "u", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>The block TriggeredTrapezoid has a boolean input and a real
// output signal and requires the parameters <i>amplitude</i>,
// <i>rising</i>, <i>falling</i> and <i>offset</i>. The
// output signal <b>y</b> represents a trapezoidal signal dependent on the
// input signal <b>u</b>.
// </p>
// <p>The behaviour is as follows: Assume the initial input to be false. In this
// case, the output will be <i>offset</i>. After a rising edge (i.e. the input
// changes from false to true), the output is rising during <i>rising</i> to the
// sum of <i>offset</i> and <i>amplitude</i>. In contrast, after a falling
// edge (i.e. the input changes from true to false), the output is falling
// during <i>falling</i> to a value of <i>offset</i>.
// </p>
// <p>Note, that the case of edges before expiration of rising or falling is
// handled properly.</p>
// </HTML>
// "));
//         Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         discrete Real endValue "Value of y at time of recent edge";
//         discrete Real rate "Current rising/falling rate";
//         discrete Modelica.SIunits.Time T "Predicted time of output reaching endValue";
// 
//       initial equation 
//         pre(y) = 0;
// 
//       equation 
//         y = if time < T then endValue - (T - time) * rate else endValue;
//         when {initial(),u,not u} then
//                   endValue = if u then offset + amplitude else offset;
//           rate = if u and rising > 0 then amplitude / rising else if not u and falling > 0 then  -amplitude / falling else 0;
//           T = if u and not rising > 0 or not u and not falling > 0 or not abs(amplitude) > 0 or initial() then time else time + (endValue - pre(y)) / rate;
//         
//         end when;
//       end TriggeredTrapezoid;
//       block Timer "Timer measuring the time from the time instant where the Boolean input became true"
//         extends Interfaces.partialBooleanBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -70},{ -60, -70},{ -60, -26},{38, -26},{38, -70},{66, -70}}, color = {255,0,255}),Line(visible = true, points = {{ -80,0},{ -62,0},{40,90},{40,0},{68,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -70},{82, -70}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -68},{ -60, -68},{ -60, -40},{20, -40},{20, -68},{60, -68}}, color = {255,0,255}),Line(visible = true, points = {{ -80, -20},{ -60, -20},{20,60},{20, -20},{60, -20},{60, -20}}, color = {0,0,255}),Text(visible = true, extent = {{ -88, -4},{ -54,6}}, textString = "y", fontName = "Arial"),Text(visible = true, extent = {{48, -88},{84, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -88, -46},{ -54, -36}}, textString = "u", fontName = "Arial")}), Documentation(info = "<HTML>
// <p> When the Boolean input \"u\" becomes <b>true</b>, the timer is started
// and the output \"y\" is the time from the time instant where u became true.
// The timer is stopped and the output is reset to zero, once the
// input becomes false.
// </p>
// </HTML>
// "));
//         Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Blocks.Interfaces.RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         discrete Modelica.SIunits.Time entryTime "Time instant when u became true";
// 
//       initial equation 
//         pre(entryTime) = 0;
// 
//       equation 
//         when u then
//                   entryTime = time;
//         
//         end when;
//         y = if u then time - entryTime else 0.0;
//       end Timer;
//     end Logical;
//     package Math "Mathematical functions as input/output blocks"
//       import Modelica.SIunits;
//       import Modelica.Blocks.Interfaces;
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "
// <HTML>
// <p>
// This package contains basic <b>mathematical operations</b>,
// such as summation and multiplication, and basic <b>mathematical
// functions</b>, such as <b>sqrt</b> and <b>sin</b>, as
// input/output blocks. All blocks of this library can be either
// connected with continuous blocks or with sampled-data blocks.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized (partly based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist).
// </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{0,0},{446, -493}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       encapsulated package UnitConversions
//         import Modelica;
//         import SI = Modelica.SIunits;
//         import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//         block ConvertAllUnits "Convert signal to a signal with different unit"
//           replaceable block ConversionBlock = Modelica.Blocks.Interfaces.PartialConversionBlock "Conversion block" annotation(choicesAllMatching = true, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends ConversionBlock;
//           annotation(defaultComponentName = "convert", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{30,0}}, color = {191,0,0}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{90,0},{30,20},{30, -20},{90,0}})}), Documentation(info = "<html>
// <p>This block implements the Modelica.SIunits.Conversions functions as a fixed causality block to
// simplify their use. The block contains a replaceable block class <b>ConversionBlock</b> that can be
// changed to be any of the blocks defined in Modelica.Blocks.Math.UnitConversions, and more generally, any
// blocks that extend from Modelica.Blocks.Interfaces.PartialConversionBlock.</p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end ConvertAllUnits;
//         block To_degC "Convert from Kelvin to Celsius"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "K"), y(unit = "degC"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "C", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_degC(u);
//         end To_degC;
//         block From_degC "Convert from Celsius to Kelvin"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "degC"), y(unit = "K"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "C", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_degC(u);
//         end From_degC;
//         block To_degF "Convert from Kelvin to Fahrenheit"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "K"), y(unit = "degF"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "F", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_degF(u);
//         end To_degF;
//         block From_degF "Convert from Fahrenheit to Kelvin"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "degF"), y(unit = "K"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "F", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_degF(u);
//         end From_degF;
//         block To_degRk "Convert from Kelvin to Rankine"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "K"), y(unit = "degRk"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "Rk", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_degRk(u);
//         end To_degRk;
//         block From_degRk "Convert from Rankine to Kelvin"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "degRk"), y(unit = "K"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "Rk", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_degRk(u);
//         end From_degRk;
//         block To_deg "Convert from radian to degree"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "rad"), y(unit = "deg"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "rad", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "deg", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_deg(u);
//         end To_deg;
//         block From_deg "Convert from degree to radian"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "deg"), y(unit = "rad"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "deg", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "rad", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_deg(u);
//         end From_deg;
//         block To_rpm "Convert from radian per second to revolutions per minute"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "rad/s"), y(unit = "rev/min"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -98,50},{26,82}}, textString = "rad/s", fontName = "Arial"),Text(visible = true, extent = {{ -62, -74},{100, -42}}, textString = "rev/min", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_rpm(u);
//         end To_rpm;
//         block From_rpm "Convert from revolutions per minute to radian per second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "rev/min"), y(unit = "rad/s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -94,56},{50,84}}, textString = "rev/min", fontName = "Arial"),Text(visible = true, extent = {{ -26, -74},{94, -42}}, textString = "rad/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_rpm(u);
//         end From_rpm;
//         block To_kmh "Convert from metre per second to kilometre per hour"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "m/s"), y(unit = "km/h"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -96,42},{0,82}}, textString = "m/s", fontName = "Arial"),Text(visible = true, extent = {{ -14, -84},{92, -40}}, textString = "km/h", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_kmh(u);
//         end To_kmh;
//         block From_kmh "Convert from kilometre per hour to metre per second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "km/h"), y(unit = "m/s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -96,48},{26,80}}, textString = "km/h", fontName = "Arial"),Text(visible = true, extent = {{ -20, -82},{92, -46}}, textString = "m/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_kmh(u);
//         end From_kmh;
//         block To_day "Convert from second to day"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "s"), y(unit = "d"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "day", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_day(u);
//         end To_day;
//         block From_day "Convert from day to second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "d"), y(unit = "s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "day", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_day(u);
//         end From_day;
//         block To_hour "Convert from second to hour"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "s"), y(unit = "h"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "hour", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_hour(u);
//         end To_hour;
//         block From_hour "Convert from hour to second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "h"), y(unit = "s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "hour", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_hour(u);
//         end From_hour;
//         block To_minute "Convert from second to minute"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "s"), y(unit = "min"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "minute", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_minute(u);
//         end To_minute;
//         block From_minute "Convert from minute to second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "min"), y(unit = "s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "minute", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_minute(u);
//         end From_minute;
//         block To_litre "Convert from cubic metre to litre"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "m3"), y(unit = "l"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "m3", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "litre", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_litre(u);
//         end To_litre;
//         block From_litre "Convert from litre to cubic metre"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "l"), y(unit = "m3"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "litre", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "m3", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_litre(u);
//         end From_litre;
//         block To_kWh "Convert from Joule to kilo Watt hour"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "J"), y(unit = "kWh"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "J", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "kWh", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_kWh(u);
//         end To_kWh;
//         block From_kWh "Convert from kilo Watt hour to Joule"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "kWh"), y(unit = "J"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "kWh", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "J", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_kWh(u);
//         end From_kWh;
//         block To_bar "Convert from Pascal to bar"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "Pa"), y(unit = "bar"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "Pa", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "bar", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_bar(u);
//         end To_bar;
//         block From_bar "Convert from bar to Pascal"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "bar"), y(unit = "Pa"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "bar", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "Pa", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_bar(u);
//         end From_bar;
//         block To_gps "Convert from kilogram per second to gram per second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "kg/s"), y(unit = "g/s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "kg/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "g/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.to_gps(u);
//         end To_gps;
//         block From_gps "Convert from gram per second to kilogram per second"
//           extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit = "g/s"), y(unit = "kg/s"));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "g/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "kg/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           y = SI.Conversions.from_gps(u);
//         end From_gps;
//         annotation(Documentation(info = "<html>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end UnitConversions;
//       block TwoInputs "Change causality of input signals by defining that two input signals are identical (e.g. for inverse models)"
//         extends Blocks.Interfaces.BlockIcon;
//         annotation(structurallyIncomplete, Documentation(info = "<HTML>
// <p>
// This block is used to enable asignment of values to variables preliminary
// defined as outputs (e.g. useful for inverse model generation).
// </p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,191}, extent = {{ -95, -50},{95,50}}, textString = "=", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u1 "Connector of first Real input signal" annotation(Placement(visible = true, transformation(origin = { -119.871,0.4978}, extent = {{ -19.871, -19.5022},{19.871,19.5022}}, rotation = 0), iconTransformation(origin = { -119.871,0.4978}, extent = {{ -19.871, -19.5022},{19.871,19.5022}}, rotation = 0)));
//         Blocks.Interfaces.RealInput u2 "Connector of second Real input signal (u1=u2)" annotation(Placement(visible = true, transformation(origin = {120,0}, extent = {{ -20, -20},{20,20}}, rotation =  -180), iconTransformation(origin = {120,0}, extent = {{ -20, -20},{20,20}}, rotation =  -180)));
// 
//       equation 
//         u1 = u2;
//       end TwoInputs;
//       block TwoOutputs "Change causality of output signals by defining that two output signals are identical (e.g. for inverse models)"
//         extends Blocks.Interfaces.BlockIcon;
//         annotation(structurallyIncomplete, Documentation(info = "
// <HTML>
// <p>
// This block is used to enable calculation of values preliminary defined as inputs.
// (e.g. useful for inverse model generation).
// </p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,191}, extent = {{ -95, -50},{95,50}}, textString = "=", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         output Blocks.Interfaces.RealOutput y1 "Connector of first Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         output Blocks.Interfaces.RealOutput y2 "Connector of second Real output signal (y1=y2)" annotation(Placement(visible = true, transformation(origin = { -110.365, -0.90289}, extent = {{ -10.0005, -10},{10.0005,10}}, rotation =  -180), iconTransformation(origin = { -110.365, -0.90289}, extent = {{ -10.0005, -10},{10.0005,10}}, rotation =  -180)));
// 
//       equation 
//         y1 = y2;
//       end TwoOutputs;
//       block Gain "Output the product of a gain value with the input signal"
//         parameter Real k = 1 "Gain value multiplied with input signal";
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This block computes output <i>y</i> as
// <i>product</i> of gain <i>k</i> with the
// input <i>u</i>:
// </p>
// <pre>
//     y = k * u;
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,191}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100, -100},{ -100,100},{100,0},{ -100, -100}}),Text(visible = true, extent = {{ -150, -140},{150, -100}}, textString = "k=%k", fontName = "Arial"),Text(visible = true, extent = {{ -150,100},{150,140}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,191}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100, -100},{ -100,100},{100,0},{ -100, -100}}),Text(visible = true, extent = {{ -76, -34},{0,38}}, textString = "k", fontName = "Arial")}));
//         Interfaces.RealInput u "Input signal connector" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.RealOutput y "Output signal connector" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = k * u;
//       end Gain;
//       block MatrixGain "Output the product of a gain matrix with the input signal vector"
//         parameter Real K[:,:] = [1,0;0,1] "Gain matrix which is multiplied with the input";
//         extends Interfaces.MIMO(final nin = size(K, 2), final nout = size(K, 1));
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes output vector <b>y</b> as <i>product</i> of the
// gain matrix <b>K</b> with the input signal vector <b>u</b>:
// </p>
// <pre>
//     <b>y</b> = <b>K</b> * <b>u</b>;
// </pre>
// <p>
// Example:
// </p>
// <pre>
//    parameter: <b>K</b> = [0.12 2; 3 1.5]
//    results in the following equations:
//      | y[1] |     | 0.12  2.00 |   | u[1] |
//      |      |  =  |            | * |      |
//      | y[2] |     | 3.00  1.50 |   | u[2] |
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -60},{90,60}}, textString = "*K", fontName = "Arial"),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -60},{90,60}}, textString = "*K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = K * u;
//       end MatrixGain;
//       block Sum "Output the sum of the elements of the input vector"
//         extends Interfaces.MISO;
//         parameter Real k[nin] = ones(nin) "Optional: sum coefficients";
//         annotation(defaultComponentName = "sum1", Documentation(info = "
// <HTML>
// <p>
// This blocks computes output <b>y</b> as
// <i>sum</i> of the elements of the input signal vector
// <b>u</b>:
// </p>
// <pre>
//     <b>y</b> = <b>u</b>[1] + <b>u</b>[2] + ...;
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter:   nin = 3;
//   results in the following equations:
//      y = u[1] + u[2] + u[3];
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{26,42},{ -34,42},{6,2},{ -34, -38},{26, -38}}),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{26,42},{ -34,42},{6,2},{ -34, -38},{26, -38}})}));
// 
//       equation 
//         y = k * u;
//       end Sum;
//       block Feedback "Output difference between commanded and feedback input"
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes output <b>y</b> as <i>difference</i> of the
// commanded input <b>u1</b> and the feedback
// input <b>u2</b>:
// </p>
// <pre>
//     <b>y</b> = <b>u1</b> - <b>u2</b>;
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter:   n = 2
//   results in the following equations:
//      y = u1 - u2
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,191}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -20, -20},{20,20}}),Line(visible = true, points = {{ -60,0},{ -20,0}}, color = {0,0,191}),Line(visible = true, points = {{20,0},{80,0}}, color = {0,0,191}),Line(visible = true, points = {{0, -20},{0, -60}}, color = {0,0,191}),Text(visible = true, extent = {{ -14, -94},{82,0}}, textString = "-", fontName = "Arial"),Text(visible = true, extent = {{ -100,60},{100,110}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -20, -20},{20,20}}),Line(visible = true, points = {{ -60,0},{ -20,0}}),Line(visible = true, points = {{20,0},{80,0}}),Line(visible = true, points = {{0, -20},{0, -60}}),Text(visible = true, extent = {{ -12, -84},{84,10}}, textString = "-", fontName = "Arial")}));
//         input Interfaces.RealInput u1 annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -80,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         output Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         input Interfaces.RealInput u2 annotation(Placement(visible = true, transformation(origin = {0, -80}, extent = {{ -20, -20},{20,20}}, rotation = 90), iconTransformation(origin = {0, -80}, extent = {{ -20, -20},{20,20}}, rotation = 90)));
// 
//       equation 
//         y = u1 - u2;
//       end Feedback;
//       block Add "Output the sum of the two inputs"
//         extends Interfaces.SI2SO;
//         parameter Real k1 =  +1 "Gain of upper input";
//         parameter Real k2 =  +1 "Gain of lower input";
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes output <b>y</b> as <i>sum</i> of the
// two input signals <b>u1</b> and <b>u2</b>:
// </p>
// <pre>
//     <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b>;
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter:   k1= +2, k2= -3
//   results in the following equations:
//      y = 2 * u1 - 3 * u2
// </pre>
// <p><b>Release Notes:</b></p>
// <ul>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -98, -92},{7, -52}}, textString = "%k2", fontName = "Arial"),Text(visible = true, extent = {{ -100,50},{5,90}}, textString = "%k1", fontName = "Arial"),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100,60},{ -40,60},{ -30,40}}),Ellipse(visible = true, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -100, -60},{ -40, -60},{ -30, -40}}),Line(visible = true, points = {{ -15, -25.99},{15,25.99}}),Rectangle(visible = true, lineColor = {0,0,191}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{50,0},{100,0}}),Line(visible = true, points = {{ -100,60},{ -74,24},{ -44,24}}, color = {0,0,191}),Line(visible = true, points = {{ -100, -60},{ -74, -28},{ -42, -28}}, color = {0,0,191}),Ellipse(visible = true, lineColor = {0,0,191}, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{50,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{ -38, -34},{38,34}}, textString = "+", fontName = "Arial"),Text(visible = true, extent = {{ -100,52},{5,92}}, textString = "%k1", fontName = "Arial"),Text(visible = true, extent = {{ -100, -92},{5, -52}}, textString = "%k2", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -98, -92},{7, -52}}, textString = "%k2", fontName = "Arial"),Text(visible = true, extent = {{ -100,50},{5,90}}, textString = "%k1", fontName = "Arial"),Line(visible = true, points = {{ -100,60},{ -40,60},{ -30,40}}),Ellipse(visible = true, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -100, -60},{ -40, -60},{ -30, -40}}),Line(visible = true, points = {{ -15, -25.99},{15,25.99}}),Rectangle(visible = true, lineColor = {0,0,191}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{50,0},{100,0}}),Line(visible = true, points = {{ -100,60},{ -74,24},{ -44,24}}, color = {0,0,191}),Line(visible = true, points = {{ -100, -60},{ -74, -28},{ -42, -28}}, color = {0,0,191}),Ellipse(visible = true, lineColor = {0,0,191}, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{50,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{ -38, -34},{38,34}}, textString = "+", fontName = "Arial"),Text(visible = true, extent = {{ -100,52},{5,92}}, textString = "k1", fontName = "Arial"),Text(visible = true, extent = {{ -100, -92},{5, -52}}, textString = "k2", fontName = "Arial")}));
// 
//       equation 
//         y = k1 * u1 + k2 * u2;
//       end Add;
//       block Add3 "Output the sum of the three inputs"
//         extends Interfaces.BlockIcon;
//         parameter Real k1 =  +1 "Gain of upper input";
//         parameter Real k2 =  +1 "Gain of middle input";
//         parameter Real k3 =  +1 "Gain of lower input";
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes output <b>y</b> as <i>sum</i> of the
// three input signals <b>u1</b>, <b>u2</b> and <b>u3</b>:
// </p>
// <pre>
//     <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b> + k3*<b>u3</b>;
// </pre>
// <p>
// Example:
// </p>
// <pre>
//      parameter:   k1= +2, k2= -3, k3=1;
//   results in the following equations:
//      y = 2 * u1 - 3 * u2 + u3;
// </pre>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,50},{5,90}}, textString = "%k1", fontName = "Arial"),Text(visible = true, extent = {{ -100, -20},{5,20}}, textString = "%k2", fontName = "Arial"),Text(visible = true, extent = {{ -100, -90},{5, -50}}, textString = "%k3", fontName = "Arial"),Text(visible = true, extent = {{2, -44},{100,36}}, textString = "+", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -100,50},{5,90}}, textString = "%k1", fontName = "Arial"),Text(visible = true, extent = {{ -100, -20},{5,20}}, textString = "%k2", fontName = "Arial"),Text(visible = true, extent = {{ -100, -90},{5, -50}}, textString = "%k3", fontName = "Arial"),Text(visible = true, extent = {{2, -44},{100,36}}, textString = "+", fontName = "Arial"),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -100,50},{5,90}}, textString = "k1", fontName = "Arial"),Text(visible = true, extent = {{ -100, -20},{5,20}}, textString = "k2", fontName = "Arial"),Text(visible = true, extent = {{ -100, -90},{5, -50}}, textString = "k3", fontName = "Arial"),Text(visible = true, extent = {{2, -44},{100,36}}, textString = "+", fontName = "Arial")}));
//         input Interfaces.RealInput u1 "Connector 1 of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         input Interfaces.RealInput u2 "Connector 2 of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         input Interfaces.RealInput u3 "Connector 3 of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         output Interfaces.RealOutput y "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = k1 * u1 + k2 * u2 + k3 * u3;
//       end Add3;
//       block Product "Output product of the two inputs"
//         extends Interfaces.SI2SO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <i>product</i> of the corresponding elements of
// the two inputs <b>u1</b> and <b>u2</b>:
// </p>
// <pre>
//     y = u1 * u2;
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,60},{ -40,60},{ -30,40}}, color = {0,0,191}),Line(visible = true, points = {{ -100, -60},{ -40, -60},{ -30, -40}}, color = {0,0,191}),Line(visible = true, points = {{50,0},{100,0}}, color = {0,0,191}),Line(visible = true, points = {{ -30,0},{30,0}}),Line(visible = true, points = {{ -15,25.99},{15, -25.99}}),Line(visible = true, points = {{ -15, -25.99},{15,25.99}}),Ellipse(visible = true, lineColor = {0,0,191}, extent = {{ -50, -50},{50,50}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -100,60},{ -40,60},{ -30,40}}),Line(visible = true, points = {{ -100, -60},{ -40, -60},{ -30, -40}}),Line(visible = true, points = {{50,0},{100,0}}),Line(visible = true, points = {{ -30,0},{30,0}}),Line(visible = true, points = {{ -15,25.99},{15, -25.99}}),Line(visible = true, points = {{ -15, -25.99},{15,25.99}}),Ellipse(visible = true, extent = {{ -50, -50},{50,50}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = u1 * u2;
//       end Product;
//       block Division "Output first input divided by second input"
//         extends Interfaces.SI2SO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This block computes the output <b>y</b> (element-wise)
// by <i>dividing</i> the corresponding elements of
// the two inputs <b>u1</b> and <b>u2</b>:
// </p>
// <pre>
//     y = u1 / u2;
// </pre>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{50,0},{100,0}}, color = {0,0,191}),Line(visible = true, points = {{ -30,0},{30,0}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5,20},{5,30}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -30},{5, -20}}),Ellipse(visible = true, lineColor = {0,0,191}, extent = {{ -50, -50},{50,50}}),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100,60},{ -66,60},{ -40,30}}, color = {0,0,191}),Line(visible = true, points = {{ -100, -60},{0, -60},{0, -50}}, color = {0,0,191})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{50,0},{100,0}}),Line(visible = true, points = {{ -30,0},{30,0}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5,20},{5,30}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -30},{5, -20}}),Ellipse(visible = true, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -100,60},{ -66,60},{ -40,30}}),Line(visible = true, points = {{ -100, -60},{0, -60},{0, -50}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = u1 / u2;
//       end Division;
//       block Abs "Output the absolute value of the input"
//         extends Interfaces.SISO;
//         annotation(defaultComponentName = "abs1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{92,0},{70,8},{70, -8},{92,0}}),Line(visible = true, points = {{ -80,80},{0,0},{80,80}}),Line(visible = true, points = {{0, -14},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -34, -76},{38, -28}}, textString = "abs", fontName = "Arial"),Line(visible = true, points = {{ -88,0},{76,0}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{76,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{92,0},{76,6},{76, -6},{92,0}}),Line(visible = true, points = {{ -80,80},{0,0},{80,80}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {160,160,160}, extent = {{7,78},{34,98}}, textString = "u", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{74, -28},{96, -8}}, textString = "y", fontName = "Arial"),Text(visible = true, extent = {{52, -23},{72, -3}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -86, -21},{ -66, -1}}, textString = "-1", fontName = "Arial"),Text(visible = true, extent = {{ -28,59},{ -8,79}}, textString = "1", fontName = "Arial")}), Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <i>absolute value</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>abs</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = abs(u);
//       end Abs;
//       block Sign "Output the sign of the input"
//         extends Interfaces.SISO;
//         annotation(defaultComponentName = "sign1", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{0, -80}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -90,24},{ -18,72}}, textString = "sign", fontName = "Arial"),Line(visible = true, points = {{0,80},{80,80}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -2, -4},{2,2}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{0, -80}}),Line(visible = true, points = {{ -0.01,0},{0.01,0}}),Line(visible = true, points = {{0,80},{80,80}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -2, -4},{2,2}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{7,82},{32,102}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -26},{94, -6}}, textString = "u", fontName = "Arial"),Text(visible = true, extent = {{ -25,70},{ -5,86}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{5, -88},{25, -72}}, textString = "-1", fontName = "Arial")}), Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <b>sign</b> of the input <b>u</b>:
// </p>
// <pre>
//          1  <b>if</b> u > 0
//     y =  0  <b>if</b> u == 0
//         -1  <b>if</b> u < 0
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = sign(u);
//       end Sign;
//       block Sqrt "Output the square root of the input (input >= 0 required)"
//         extends Interfaces.SISO;
//         annotation(defaultComponentName = "sqrt1", Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <i>square root</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = sqrt( u );
// </pre>
// <p>
// All elements of the input vector shall be zero or positive.
// Otherwise an error occurs.
// </p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -80},{68, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -68.7},{ -78.4, -64},{ -76.8, -57.3},{ -73.6, -47.9},{ -67.9, -36.1},{ -59.1, -22.2},{ -46.2, -6.49},{ -28.5,10.7},{ -4.42,30},{27.7,51.3},{69.5,74.7},{80,80}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -88},{ -80,68}}, color = {192,192,192}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -8, -52},{64, -4}}, textString = "sqrt", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -92, -80},{84, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -80},{84, -74},{84, -86},{100, -80}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -68.7},{ -78.4, -64},{ -76.8, -57.3},{ -73.6, -47.9},{ -67.9, -36.1},{ -59.1, -22.2},{ -46.2, -6.49},{ -28.5,10.7},{ -4.42,30},{27.7,51.3},{69.5,74.7},{80,80}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,98},{ -86,82},{ -74,82},{ -80,98}}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -71,78},{ -44,98}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{60, -72},{84, -52}}, textString = "u", fontName = "Arial")}));
// 
//       equation 
//         y = sqrt(u);
//       end Sqrt;
//       block Sin "Output the sine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <b>sine</b> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>sin</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -75,78},{ -46,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,96},{ -86,80},{ -74,80},{ -80,96}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -105,72},{ -85,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "2*pi", fontName = "Arial"),Text(visible = true, extent = {{ -105, -88},{ -85, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{76, -30},{98, -10}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -80},{ -80,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{12,36},{84,84}}, textString = "sin", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.sin(u);
//       end Sin;
//       block Cos "Output the cosine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <b>cos</b> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>cos</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -75,82},{ -48,102}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Text(visible = true, extent = {{ -103,72},{ -83,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -79, -88},{ -59, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "2*pi", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,80},{ -74.4,78.1},{ -68.7,72.3},{ -63.1,63},{ -56.7,48.7},{ -48.6,26.6},{ -29.3, -32.5},{ -22.1, -51.7},{ -15.7, -65.3},{ -10.1, -73.8},{ -4.42, -78.8},{1.21, -79.9},{6.83, -77.1},{12.5, -70.6},{18.1, -60.6},{24.5, -45.7},{32.6, -23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{74, -24},{98, -4}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -80},{ -80,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,80},{ -74.4,78.1},{ -68.7,72.3},{ -63.1,63},{ -56.7,48.7},{ -48.6,26.6},{ -29.3, -32.5},{ -22.1, -51.7},{ -15.7, -65.3},{ -10.1, -73.8},{ -4.42, -78.8},{1.21, -79.9},{6.83, -77.1},{12.5, -70.6},{18.1, -60.6},{24.5, -45.7},{32.6, -23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -36,34},{36,82}}, textString = "cos", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.cos(u);
//       end Cos;
//       block Tan "Output the tangent of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise)
// as <b>tan</b> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>tan</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -88},{0,86}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{11,80},{38,100}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,102},{ -6,86},{6,86},{0,102}}),Text(visible = true, extent = {{ -37, -88},{ -17, -72}}, textString = "-5.8", fontName = "Arial"),Text(visible = true, extent = {{ -33,70},{ -13,86}}, textString = " 5.8", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "1.4", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -78.4, -68.4},{ -76.8, -59.7},{ -74.4, -50},{ -71.2, -40.9},{ -67.1, -33},{ -60.7, -24.8},{ -51.1, -17.2},{ -35.8, -9.98},{ -4.42, -1.07},{33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,47.4},{76,56.1},{77.6,63.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -26},{94, -6}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -78.4, -68.4},{ -76.8, -59.7},{ -74.4, -50},{ -71.2, -40.9},{ -67.1, -33},{ -60.7, -24.8},{ -51.1, -17.2},{ -35.8, -9.98},{ -4.42, -1.07},{33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,47.4},{76,56.1},{77.6,63.8},{80,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -90,24},{ -18,72}}, textString = "tan", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.tan(u);
//       end Tan;
//       block Asin "Output the arc sine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>sine-inverse</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>asin</b>( u );
// </pre>
// <p>
// The absolute values of the elements of the input <b>u</b> need to
// be less or equal to one (<b>abs</b>( u ) <= 1).
// Otherwise an error occurs.
// </p>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{9,82},{36,102}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Text(visible = true, extent = {{ -40, -88},{ -15, -72}}, textString = "-pi/2", fontName = "Arial"),Text(visible = true, extent = {{ -38,72},{ -13,88}}, textString = " pi/2", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "+1", fontName = "Arial"),Text(visible = true, extent = {{ -90,1},{ -70,21}}, textString = "-1", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -72.8},{ -77.6, -67.5},{ -73.6, -59.4},{ -66.3, -49.8},{ -53.5, -37.3},{ -30.2, -19.7},{37.4,24.8},{57.5,40.8},{68.7,52.7},{75.2,62.2},{77.6,67.5},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{74, -26},{100, -4}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -79.2, -72.8},{ -77.6, -67.5},{ -73.6, -59.4},{ -66.3, -49.8},{ -53.5, -37.3},{ -30.2, -19.7},{37.4,24.8},{57.5,40.8},{68.7,52.7},{75.2,62.2},{77.6,67.5},{80,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -88,30},{ -16,78}}, textString = "asin", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.asin(u);
//       end Asin;
//       block Acos "Output the arc cosine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>cosine-inverse</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>acos</b>( u );
// </pre>
// <p>
// The absolute values of the elements of the input <b>u</b> need to
// be less or equal to one (<b>abs</b>( u ) <= 1).
// Otherwise an error occurs.
// </p>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{13,82},{42,100}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100, -80},{84, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -80},{84, -74},{84, -86},{100, -80}}),Line(visible = true, points = {{ -80,80},{ -79.2,72.8},{ -77.6,67.5},{ -73.6,59.4},{ -66.3,49.8},{ -53.5,37.3},{ -30.2,19.7},{37.4, -24.8},{57.5, -40.8},{68.7, -52.7},{75.2, -62.2},{77.6, -67.5},{80, -80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -30,72},{ -5,88}}, textString = " pi", fontName = "Arial"),Text(visible = true, extent = {{ -94, -77},{ -74, -57}}, textString = "-1", fontName = "Arial"),Text(visible = true, extent = {{80, -65},{100, -45}}, textString = "+1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{76, -102},{102, -84}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{ -80,80},{ -79.2,72.8},{ -77.6,67.5},{ -73.6,59.4},{ -66.3,49.8},{ -53.5,37.3},{ -30.2,19.7},{37.4, -24.8},{57.5, -40.8},{68.7, -52.7},{75.2, -62.2},{77.6, -67.5},{80, -80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{0, -88},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -80},{68, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86, -62},{ -14, -14}}, textString = "acos", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.acos(u);
//       end Acos;
//       block Atan "Output the arc tangent of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>tangent-inverse</i> of the input <b>u</b>:
// </p>
// <pre>
//     y= <b>atan</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{13,82},{42,102}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -52.7, -75.2},{ -37.4, -69.7},{ -26.9, -63},{ -19.7, -55.2},{ -14.1, -45.8},{ -10.1, -36.4},{ -6.03, -23.9},{ -1.21, -5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{69.5,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -32,71},{ -12,91}}, textString = "1.4", fontName = "Arial"),Text(visible = true, extent = {{ -32, -91},{ -12, -71}}, textString = "-1.4", fontName = "Arial"),Text(visible = true, extent = {{73,10},{93,26}}, textString = " 5.8", fontName = "Arial"),Text(visible = true, extent = {{ -103,4},{ -83,20}}, textString = "-5.8", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{66, -28},{94, -8}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -52.7, -75.2},{ -37.4, -69.7},{ -26.9, -63},{ -19.7, -55.2},{ -14.1, -45.8},{ -10.1, -36.4},{ -6.03, -23.9},{ -1.21, -5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{69.5,78.6},{80,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86,20},{ -14,68}}, textString = "atan", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.atan(u);
//       end Atan;
//       block Atan2 "Output atan(u1/u2) of the inputs u1 and u2"
//         extends Interfaces.SI2SO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>tangent-inverse</i> of the input <b>u1</b> divided by
// input <b>u2</b>:
// </p>
// <pre>
//     y = <b>atan2</b>( u1, u2 );
// </pre>
// <p>
// u1 and u2 shall not be zero at the same time instant.
// <b>Atan2</b> uses the sign of u1 and u2 in order to construct
// the solution in the range -180 deg &le; y &le; 180 deg, whereas
// block <b>Atan</b> gives a solution in the range
// -90 deg &le; y &le; 90 deg.
// </p>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{11,78},{42,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{0, -80},{8.93, -67.2},{17.1, -59.3},{27.3, -53.6},{42.1, -49.4},{69.9, -45.8},{80, -45.1}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80, -34.9},{ -46.1, -31.4},{ -29.4, -27.1},{ -18.3, -21.5},{ -10.3, -14.5},{ -2.03, -3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{62.1,33.5},{80,34.9}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80,45.1},{ -45.9,48.7},{ -29.1,52.9},{ -18.1,58.6},{ -10.2,65.8},{ -1.82,77.2},{0,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -30,70},{ -10,89}}, textString = "pi", fontName = "Arial"),Text(visible = true, extent = {{ -30, -88},{ -10, -69}}, textString = "-pi", fontName = "Arial"),Text(visible = true, extent = {{ -30,30},{ -10,49}}, textString = "pi/2", fontName = "Arial"),Line(visible = true, points = {{0,40},{ -8,40}}, color = {192,192,192}),Line(visible = true, points = {{0, -40},{ -8, -40}}, color = {192,192,192}),Text(visible = true, extent = {{ -30, -50},{ -10, -31}}, textString = "-pi/2", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{48, -34},{100,0}}, textString = "u1 / u2", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -34.9},{ -46.1, -31.4},{ -29.4, -27.1},{ -18.3, -21.5},{ -10.3, -14.5},{ -2.03, -3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{62.1,33.5},{80,34.9}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80,45.1},{ -45.9,48.7},{ -29.1,52.9},{ -18.1,58.6},{ -10.2,65.8},{ -1.82,77.2},{0,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{0, -80},{8.93, -67.2},{17.1, -59.3},{27.3, -53.6},{42.1, -49.4},{69.9, -45.8},{80, -45.1}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -90, -94},{ -18, -46}}, textString = "atan2", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.atan2(u1, u2);
//       end Atan2;
//       block Sinh "Output the hyperbolic sine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>hyperbolic sine</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>sinh</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{9,78},{34,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -76, -65.4},{ -71.2, -51.4},{ -65.5, -38.8},{ -59.1, -28.1},{ -51.1, -18.7},{ -41.4, -11.4},{ -27.7, -5.5},{ -4.42, -0.65},{24.5,4.57},{39,10.1},{49.4,17.2},{57.5,25.9},{63.9,35.8},{69.5,47.4},{74.4,60.4},{78.4,73.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "27", fontName = "Arial"),Text(visible = true, extent = {{ -35, -88},{ -15, -72}}, textString = "-27", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -98,1},{ -78,21}}, textString = "-4", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{72, -26},{96, -6}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86,32},{ -14,80}}, textString = "sinh", fontName = "Arial"),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -76, -65.4},{ -71.2, -51.4},{ -65.5, -38.8},{ -59.1, -28.1},{ -51.1, -18.7},{ -41.4, -11.4},{ -27.7, -5.5},{ -4.42, -0.65},{24.5,4.57},{39,10.1},{49.4,17.2},{57.5,25.9},{63.9,35.8},{69.5,47.4},{74.4,60.4},{78.4,73.8},{80,80}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}})}));
// 
//       equation 
//         y = Modelica.Math.sinh(u);
//       end Sinh;
//       block Cosh "Output the hyperbolic cosine of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>hyperbolic cosine</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>cosh</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{11,78},{38,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100, -86.08},{84, -86.08}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -86.08},{84, -80.08},{84, -92.08},{100, -86.08}}),Line(visible = true, points = {{ -80,80},{ -77.6,61.1},{ -74.4,39.3},{ -71.2,20.7},{ -67.1,1.29},{ -63.1, -14.6},{ -58.3, -29.8},{ -52.7, -43.5},{ -46.2, -55.1},{ -39, -64.3},{ -30.2, -71.7},{ -18.9, -77.1},{ -4.42, -79.9},{10.9, -79.1},{23.7, -75.2},{34.2, -68.7},{42.2, -60.6},{48.6, -51.2},{54.3, -40},{59.1, -27.5},{63.1, -14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "27", fontName = "Arial"),Text(visible = true, extent = {{62, -87},{82, -67}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -104, -83},{ -84, -63}}, textString = "-4", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{78, -74},{100, -54}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Text(visible = true, fillColor = {192,192,192}, extent = {{4,20},{66,66}}, textString = "cosh", fontName = "Arial"),Line(visible = true, points = {{ -80,80},{ -77.6,61.1},{ -74.4,39.3},{ -71.2,20.7},{ -67.1,1.29},{ -63.1, -14.6},{ -58.3, -29.8},{ -52.7, -43.5},{ -46.2, -55.1},{ -39, -64.3},{ -30.2, -71.7},{ -18.9, -77.1},{ -4.42, -79.9},{10.9, -79.1},{23.7, -75.2},{34.2, -68.7},{42.2, -60.6},{48.6, -51.2},{54.3, -40},{59.1, -27.5},{63.1, -14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90, -86.08},{68, -86.08}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -86.08},{68, -78.08},{68, -94.08},{90, -86.08}})}));
// 
//       equation 
//         y = Modelica.Math.cosh(u);
//       end Cosh;
//       block Tanh "Output the hyperbolic tangent of the input"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>hyperbolic tangent</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>tanh</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{9,80},{42,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -47.8, -78.7},{ -35.8, -75.7},{ -27.7, -70.6},{ -22.1, -64.2},{ -17.3, -55.9},{ -12.5, -44.3},{ -7.64, -29.2},{ -1.21, -4.82},{6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},{45.4,78.4},{72,79.9},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{70,5},{90,25}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -106,1},{ -86,21}}, textString = "-4", fontName = "Arial"),Text(visible = true, extent = {{ -29,72},{ -9,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{3, -88},{23, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{72, -26},{98, -8}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -47.8, -78.7},{ -35.8, -75.7},{ -27.7, -70.6},{ -22.1, -64.2},{ -17.3, -55.9},{ -12.5, -44.3},{ -7.64, -29.2},{ -1.21, -4.82},{6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},{45.4,78.4},{72,79.9},{80,80}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -88,24},{ -16,72}}, textString = "tanh", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}})}));
// 
//       equation 
//         y = Modelica.Math.tanh(u);
//       end Tanh;
//       block Exp "Output the exponential (base e) of the input"
//         extends Interfaces.SISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86,2},{ -14,50}}, textString = "exp", fontName = "Arial"),Line(visible = true, points = {{ -80, -80},{ -31, -77.9},{ -6.03, -74},{10.9, -68.4},{23.7, -61},{34.2, -51.6},{43, -40.3},{50.3, -27.8},{56.7, -13.5},{62.3,2.23},{67.1,18.6},{72,38.2},{76,57.6},{80,80}}),Line(visible = true, points = {{ -90, -80.3976},{68, -80.3976}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80.3976},{68, -72.3976},{68, -88.3976},{90, -80.3976}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{9,80},{40,100}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}}),Line(visible = true, points = {{ -100, -80.3976},{84, -80.3976}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -80.3976},{84, -74.3976},{84, -86.3976},{100, -80.3976}}),Line(visible = true, points = {{ -80, -80},{ -31, -77.9},{ -6.03, -74},{10.9, -68.4},{23.7, -61},{34.2, -51.6},{43, -40.3},{50.3, -27.8},{56.7, -13.5},{62.3,2.23},{67.1,18.6},{72,38.2},{76,57.6},{80,80}}),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -92, -103},{ -72, -83}}, textString = "-3", fontName = "Arial"),Text(visible = true, extent = {{70, -103},{90, -83}}, textString = "3", fontName = "Arial"),Text(visible = true, extent = {{ -18, -73},{2, -53}}, textString = "1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{66, -72},{96, -52}}, textString = "u", fontName = "Arial")}), Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>exponential</i> (of base e) of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>exp</b>( u );
// </pre>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//       equation 
//         y = Modelica.Math.exp(u);
//       end Exp;
//       block Log "Output the natural (base e) logarithm of the input (input > 0 required)"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>natural (base e) logarithm</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>log</b>( u );
// </pre>
// <p>
// An error occurs if the elements of the input <b>u</b> are
// zero or negative.
// </p>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -67,80},{ -40,98}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -105,72},{ -85,88}}, textString = "3", fontName = "Arial"),Text(visible = true, extent = {{ -109, -88},{ -89, -72}}, textString = "-3", fontName = "Arial"),Text(visible = true, extent = {{70, -23},{90, -3}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -78, -21},{ -58, -1}}, textString = "1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{68,8},{94,28}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -80},{ -80,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -6, -72},{66, -24}}, textString = "log", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.log(u);
//       end Log;
//       block Log10 "Output the base 10 logarithm of the input (input > 0 required)"
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// This blocks computes the output <b>y</b> (element-wise) as the
// <i>base 10 logarithm</i> of the input <b>u</b>:
// </p>
// <pre>
//     y = <b>log10</b>( u );
// </pre>
// <p>
// An error occurs if the elements of the input <b>u</b> are
// zero or negative.
// </p>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -65,78},{ -38,96}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -79.8, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{70, -23},{90, -3}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -78, -21},{ -58, -1}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -109,72},{ -89,88}}, textString = " 1.3", fontName = "Arial"),Text(visible = true, extent = {{ -109, -88},{ -89, -72}}, textString = "-1.3", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{62,10},{90,30}}, textString = "u", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Line(visible = true, points = {{ -79.8, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80, -80},{ -80,68}}, color = {192,192,192}),Text(visible = true, fillColor = {192,192,192}, extent = {{ -30, -70},{60, -22}}, textString = "log10", fontName = "Arial")}));
// 
//       equation 
//         y = Modelica.Math.log10(u);
//       end Log10;
//       block RealToInteger "Convert Real to Integer signal"
//         extends Interfaces.IntegerBlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100, -60},{0,60}}, textString = "R", fontName = "Arial"),Text(visible = true, fillColor = {255,127,0}, extent = {{20, -60},{120,60}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,127,0}, fillPattern = FillPattern.Solid, points = {{50,0},{30,20},{30,10},{0,10},{0, -10},{30, -10},{30, -20},{50,0}})}), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>
// as <i>nearest integer value</i> of the input <b>u</b>:
// </p>
// <pre>    y = <b>integer</b>( <b>floor</b>( u + 0.5 ) )  for  u &gt; 0;
//     y = <b>integer</b>( <b>ceil </b>( u - 0.5 ) )  for  u &lt; 0;
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Interfaces.RealInput u "Connector of Real input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.IntegerOutput y "Connector of Integer output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = if u > 0 then integer(floor(u + 0.5)) else integer(ceil(u - 0.5));
//       end RealToInteger;
//       block IntegerToReal "Convert integer to real signals"
//         extends Interfaces.BlockIcon;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {255,127,0}, extent = {{ -120, -60},{ -20,60}}, textString = "I", fontName = "Arial"),Text(visible = true, extent = {{0, -60},{100,60}}, textString = "R", fontName = "Arial"),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{10,0},{ -10,20},{ -10,10},{ -40,10},{ -40, -10},{ -10, -10},{ -10, -20},{10,0}})}), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>
// as <i>Real equivalent</i> of the Integer input <b>u</b>:
// </p>
// <pre>    y = u;
// </pre>
// <p>where <b>u</b> is of Integer and <b>y</b> of Real type.</p>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Interfaces.IntegerInput u "Connector of Integer input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = u;
//       end IntegerToReal;
//       block BooleanToReal "Convert Boolean to Real signal"
//         extends Interfaces.partialBooleanSI;
//         parameter Real realTrue = 1.0 "Output signal for true Boolean input";
//         parameter Real realFalse = 0.0 "Output signal for false Boolean input";
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>
// as <i>Real equivalent</i> of the Boolean input <b>u</b>:
// </p>
// <pre>    y = <b>if</b> u <b>then</b> realTrue <b>else</b> realFalse;
// </pre>
// <p>where <b>u</b> is of Boolean and <b>y</b> of Real type,
// and <b>realTrue</b> and <b>realFalse</b> are parameters.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {255,0,255}, extent = {{ -86,10},{ -6,92}}, textString = "B", fontName = "Arial"),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -12, -46},{ -32, -26},{ -32, -36},{ -64, -36},{ -64, -56},{ -32, -56},{ -32, -66},{ -12, -46}}),Text(visible = true, extent = {{8, -94},{92, -4}}, textString = "R", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealOutput y "Connector of Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = if u then realTrue else realFalse;
//       end BooleanToReal;
//       block BooleanToInteger "Convert Boolean to Integer signal"
//         extends Interfaces.partialBooleanSI;
//         parameter Integer integerTrue = 1 "Output signal for true Boolean input";
//         parameter Integer integerFalse = 0 "Output signal for false Boolean input";
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>
// as <i>Integer equivalent</i> of the Boolean input <b>u</b>:
// </p>
// <pre>    y = <b>if</b> u <b>then</b> integerTrue <b>else</b> integerFalse;
// </pre>
// <p>where <b>u</b> is of Boolean and <b>y</b> of Integer type,
// and <b>integerTrue</b> and <b>integerFalse</b> are parameters.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {255,0,255}, extent = {{ -86,10},{ -6,92}}, textString = "B", fontName = "Arial"),Polygon(visible = true, lineColor = {255,191,127}, fillColor = {255,191,127}, fillPattern = FillPattern.Solid, points = {{ -12, -46},{ -32, -26},{ -32, -36},{ -64, -36},{ -64, -56},{ -32, -56},{ -32, -66},{ -12, -46}}),Text(visible = true, fillColor = {255,191,127}, extent = {{8, -94},{92, -4}}, textString = "I", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.IntegerOutput y "Connector of Integer output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         y = if u then integerTrue else integerFalse;
//       end BooleanToInteger;
//       block RealToBoolean "Convert Real to Boolean signal"
//         extends Interfaces.partialBooleanSO;
//         parameter Real threshold = 0.5 "Output signal y is true, if input u >= threshold";
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the Boolean output <b>y</b>
// from the Real input <b> u</b> by the equation:
// </p>
// 
// <pre>    y = u &ge; threshold;
// </pre>
// 
// <p>
// where <b>threshold</b> is a parameter.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -86,10},{ -6,92}}, textString = "R", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -12, -46},{ -32, -26},{ -32, -36},{ -64, -36},{ -64, -56},{ -32, -56},{ -32, -66},{ -12, -46}}),Text(visible = true, fillColor = {255,0,255}, extent = {{8, -94},{92, -4}}, textString = "B", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.RealInput u "Connector of Real input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         y = u >= threshold;
//       end RealToBoolean;
//       block IntegerToBoolean "Convert Integer to Boolean signal"
//         extends Interfaces.partialBooleanSO;
//         parameter Integer threshold = 1 "Output signal y is true, if input u >= threshold";
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the Boolean output <b>y</b>
// from the Integer input <b> u</b> by the equation:
// </p>
// 
// <pre>    y = u &ge; threshold;
// </pre>
// 
// <p>
// where <b>threshold</b> is a parameter.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {255,127,0}, extent = {{ -86,10},{ -6,92}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -12, -46},{ -32, -26},{ -32, -36},{ -64, -36},{ -64, -56},{ -32, -56},{ -32, -66},{ -12, -46}}),Text(visible = true, fillColor = {255,0,255}, extent = {{8, -94},{92, -4}}, textString = "B", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Blocks.Interfaces.IntegerInput u "Connector of Integer input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         y = u >= threshold;
//       end IntegerToBoolean;
//       block Max "Pass through the largest signal"
//         extends Interfaces.SI2SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -36},{90,36}}, textString = "max()", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b> as <i>maximum</i>
// of the two Real inputs <b>u1</b> and <b>u2</b>:
// </p>
// <pre>    y = <b>max</b> ( u1 , u2 );
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = max(u1, u2);
//       end Max;
//       block Min "Pass through the smallest signal"
//         extends Interfaces.SI2SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -36},{90,36}}, textString = "min()", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b> as <i>minimum</i> of
// the two Real inputs <b>u1</b> and <b>u2</b>:
// </p>
// <pre>    y = <b>min</b> ( u1 , u2 );
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = min(u1, u2);
//       end Min;
//       block Edge "Indicates rising edge of boolean signal"
//         extends Interfaces.BooleanSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -36},{90,36}}, textString = "edge()", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b> to true,
// when the Boolean input <b>u</b> shows a <i>rising edge</i>:
// </p>
// <pre>    y = <b>edge</b>( u );
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = edge(u);
//       end Edge;
//       block BooleanChange "Indicates boolean signal changing"
//         extends Interfaces.BooleanSISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -36},{90,36}}, textString = "change()", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b> to true, when the
// Boolean input <b>u</b> shows a <i>rising or falling edge</i>,
// i.e., when the signal changes:
// </p>
// <pre>    y = <b>change</b>( u );
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = change(u);
//       end BooleanChange;
//       block IntegerChange "Indicates integer signal changing"
//         extends Interfaces.IntegerSIBooleanSO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {160,160,160}, extent = {{ -90, -36},{90,36}}, textString = "change()", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b> to true, when the
// Integer input <b>u</b> changes:
// </p>
// <pre>    y = <b>change</b>( u );
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         y = change(u);
//       end IntegerChange;
//     end Math;
//     package Nonlinear "Discontinuous or non-differentiable algebraic control blocks"
//       import Modelica.Blocks.Interfaces;
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "
// <HTML>
// <p>
// This package contains <b>discontinuous</b> and
// <b>non-differentiable, algebraic</b> input/output blocks.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New block VariableLimiter added.
// <li><i>August 22, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.
// </li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{0,0},{207, -132}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       block Limiter "Limit the range of a signal"
//         parameter Real uMax = 1 "Upper limits of input signals";
//         parameter Real uMin =  -uMax "Lower limits of input signals";
//         parameter Boolean limitsAtInit = true "= false, if limits are ignored during initializiation (i.e., y=u)";
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// The Limiter block passes its input signal as output signal
// as long as the input is within the specified upper and lower
// limits. If this is not the case, the corresponding limits are passed
// as output.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -90},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68, -8},{68,8},{90,0}}),Line(visible = true, points = {{ -80, -70},{ -50, -70},{50,70},{80,70}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "uMax=%uMax", fontName = "Arial"),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -60},{0,50}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,60},{ -5,50},{5,50},{0,60}}),Line(visible = true, points = {{ -60,0},{50,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{60,0},{50, -5},{50,5},{60,0}}),Line(visible = true, points = {{ -50, -40},{ -30, -40},{30,40},{50,40}}),Text(visible = true, fillColor = {128,128,128}, extent = {{46, -18},{68, -6}}, textString = "u", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -30,50},{ -5,70}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -58, -54},{ -28, -42}}, textString = "uMin", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{26,40},{66,56}}, textString = "uMax", fontName = "Arial")}));
// 
//       equation 
//         assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) + ") < uMin (=" + String(uMin) + ")");
//         if initial() and not limitsAtInit then
//           y = u;
//           assert(u >= uMin - 0.01 * abs(uMin) and u <= uMax + 0.01 * abs(uMax), "Limiter: During initialization the limits have been ignored.\n" + "However, the result is that the input u is not within the required limits:\n" + "  u = " + String(u) + ", uMin = " + String(uMin) + ", uMax = " + String(uMax));
// 
//         else
//           y = smooth(0, if u > uMax then uMax else if u < uMin then uMin else u);
// 
//         end if;
//       end Limiter;
//       block VariableLimiter "Limit the range of a signal with variable limits"
//         extends Interfaces.SISO;
//         parameter Boolean limitsAtInit = true "= false, if limits are ignored during initializiation (i.e., y=u)";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -90},{0,68}}, color = {192,192,192}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68, -8},{68,8},{90,0}}),Line(visible = true, points = {{ -80, -70},{ -50, -70},{50,70},{80,70}}),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100,80},{66,80},{66,70}}),Line(visible = true, points = {{ -100, -80},{ -64, -80},{ -64, -70}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -64, -70},{ -66, -74},{ -62, -74},{ -64, -70}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{66,70},{64,74},{68,74},{66,70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -60},{0,50}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,60},{ -5,50},{5,50},{0,60}}),Line(visible = true, points = {{ -60,0},{50,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{60,0},{50, -5},{50,5},{60,0}}),Line(visible = true, points = {{ -50, -40},{ -30, -40},{30,40},{50,40}}),Text(visible = true, fillColor = {128,128,128}, extent = {{46, -18},{68, -6}}, textString = "inPort", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -30,50},{ -5,70}}, textString = "outPort", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -66, -40},{ -26, -20}}, textString = "uMin", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{30,20},{70,40}}, textString = "uMax", fontName = "Arial"),Line(visible = true, points = {{ -100,80},{40,80},{40,40}}),Line(visible = true, points = {{ -100, -80},{ -40, -80},{ -40, -40}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{40,40},{35,50},{45,50},{40,40}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -40, -40},{ -45, -50},{ -35, -50},{ -40, -40}})}));
//         Interfaces.RealInput limit1 "Connector of Real input signal used as maximum of input u" annotation(Placement(visible = true, transformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.RealInput limit2 "Connector of Real input signal used as minimum of input u" annotation(Placement(visible = true, transformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -80}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//       protected 
//         Real uMax;
//         Real uMin;
//         annotation(Documentation(info = "<html>
// <p>
// The Limiter block passes its input signal as output signal
// as long as the input is within the upper and lower
// limits specified by the two additional inputs limit1 and
// limit2. If this is not the case, the corresponding limit
// is passed as output.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{0, -90},{0,68}}, color = {192,192,192}),Line(points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(points = {{90,0},{68, -8},{68,8},{90,0}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80, -70},{ -50, -70},{50,70},{80,70}}, color = {0,0,0}),Text(extent = {{ -150,150},{150,110}}, textString = "%name"),Line(points = {{ -100,80},{66,80},{66,70}}),Line(points = {{ -100, -80},{ -64, -80},{ -64, -70}}),Polygon(points = {{ -64, -70},{ -66, -74},{ -62, -74},{ -64, -70}}, fillPattern = FillPattern.Solid),Polygon(points = {{66,70},{64,74},{68,74},{66,70}}, fillPattern = FillPattern.Solid),Polygon(points = {{0,90},{ -8,68},{8,68},{0,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{0, -60},{0,50}}, color = {192,192,192}),Polygon(points = {{0,60},{ -5,50},{5,50},{0,60}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -60,0},{50,0}}, color = {192,192,192}),Polygon(points = {{60,0},{50, -5},{50,5},{60,0}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -50, -40},{ -30, -40},{30,40},{50,40}}, color = {0,0,0}),Text(extent = {{46, -6},{68, -18}}, textString = "inPort", fillColor = {128,128,128}),Text(extent = {{ -30,70},{ -5,50}}, textString = "outPort", fillColor = {128,128,128}),Text(extent = {{ -66, -40},{ -26, -20}}, textString = "uMin", fillColor = {128,128,128}),Text(extent = {{30,20},{70,40}}, textString = "uMax", fillColor = {128,128,128}),Line(points = {{ -100,80},{40,80},{40,40}}),Line(points = {{ -100, -80},{ -40, -80},{ -40, -40}}),Polygon(points = {{40,40},{35,50},{45,50},{40,40}}, fillPattern = FillPattern.Solid),Polygon(points = {{ -40, -40},{ -45, -50},{ -35, -50},{ -40, -40}}, fillPattern = FillPattern.Solid)}));
// 
//       equation 
//         uMax = max(limit1, limit2);
//         uMin = min(limit1, limit2);
//         if initial() and not limitsAtInit then
//           y = u;
//           assert(u >= uMin - 0.01 * abs(uMin) and u <= uMax + 0.01 * abs(uMax), "VariableLimiter: During initialization the limits have been ignored.\n" + "However, the result is that the input u is not within the required limits:\n" + "  u = " + String(u) + ", uMin = " + String(uMin) + ", uMax = " + String(uMax));
// 
//         else
//           y = smooth(0, if u > uMax then uMax else if u < uMin then uMin else u);
// 
//         end if;
//       end VariableLimiter;
//       block DeadZone "Provide a region of zero output"
//         parameter Real uMax = 1 "Upper limits of dead zones";
//         parameter Real uMin =  -uMax "Lower limits of dead zones";
//         parameter Boolean deadZoneAtInit = true "= false, if dead zone is ignored during initializiation (i.e., y=u)";
//         extends Interfaces.SISO;
//         annotation(Documentation(info = "
// <HTML>
// <p>
// The DeadZone block defines a region of zero output.
// </p>
// <p>
// If the input is within uMin ... uMax, the output
// is zero. Outside of this zone, the output is a linear
// function of the input with a slope of 1.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -90},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68, -8},{68,8},{90,0}}),Line(visible = true, points = {{ -80, -60},{ -20,0},{20,0},{80,60}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -150, -150},{150, -110}}, textString = "uMax=%uMax", fontName = "Arial"),Text(visible = true, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -60},{0,50}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,60},{ -5,50},{5,50},{0,60}}),Line(visible = true, points = {{ -76,0},{74,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{84,0},{74, -5},{74,5},{84,0}}),Line(visible = true, points = {{ -81, -40},{ -38,0},{40,0},{80,40}}),Text(visible = true, fillColor = {128,128,128}, extent = {{62, -25},{88, -7}}, textString = "u", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -36,50},{ -5,72}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{ -51,1},{ -28,19}}, textString = "uMin", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{27,5},{52,21}}, textString = "uMax", fontName = "Arial")}));
// 
//       equation 
//         assert(uMax >= uMin, "DeadZone: Limits must be consistent. However, uMax (=" + String(uMax) + ") < uMin (=" + String(uMin) + ")");
//         if initial() and not deadZoneAtInit then
//           y = u;
// 
//         else
//           y = smooth(0, if u > uMax then u - uMax else if u < uMin then u - uMin else 0);
// 
//         end if;
//       end DeadZone;
//       block FixedDelay "Delay block with fixed DelayTime"
//         extends Modelica.Blocks.Interfaces.SISO;
//         parameter SI.Time delayTime = 1 "Delay time of output with respect to input signal";
//         annotation(Documentation(info = "<html>
// <p>
// The Input signal is delayed by a given time instant, or more precisely:
// </p>
// <pre>
//    y = u(time - delayTime) for time &gt; time.start + delayTime
//      = u(time.start)       for time &le; time.start + delayTime
// </pre>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{8, -142},{8, -102}}, textString = "delayTime=%delayTime", fontName = "Arial"),Line(visible = true, points = {{ -92,0},{ -80.7,34.2},{ -73.5,53.1},{ -67.1,66.4},{ -61.4,74.6},{ -55.8,79.1},{ -50.2,79.8},{ -44.6,76.6},{ -38.9,69.7},{ -33.3,59.4},{ -26.9,44.1},{ -18.83,21.2},{ -1.9, -30.8},{5.3, -50.2},{11.7, -64.2},{17.3, -73.1},{23, -78.4},{28.6, -80},{34.2, -77.6},{39.9, -71.5},{45.5, -61.9},{51.9, -47.2},{60, -24.8},{68,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -62,0},{ -50.7,34.2},{ -43.5,53.1},{ -37.1,66.4},{ -31.4,74.6},{ -25.8,79.1},{ -20.2,79.8},{ -14.6,76.6},{ -8.9,69.7},{ -3.3,59.4},{3.1,44.1},{11.17,21.2},{28.1, -30.8},{35.3, -50.2},{41.7, -64.2},{47.3, -73.1},{53, -78.4},{58.6, -80},{64.2, -77.6},{69.9, -71.5},{75.5, -61.9},{81.9, -47.2},{90, -24.8},{98,0}}, color = {160,160,160}, smooth = Smooth.Bezier)}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -88},{ -80,86}}, color = {192,192,192}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -75,78},{ -46,98}}, textString = "outPort", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,96},{ -86,80},{ -74,80},{ -80,96}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -24,78},{ -2,98}}, textString = "inPort", fontName = "Arial"),Line(visible = true, points = {{ -64,0},{ -52.7,34.2},{ -45.5,53.1},{ -39.1,66.4},{ -33.4,74.6},{ -27.8,79.1},{ -22.2,79.8},{ -16.6,76.6},{ -10.9,69.7},{ -5.3,59.4},{1.1,44.1},{9.17,21.2},{26.1, -30.8},{33.3, -50.2},{39.7, -64.2},{45.3, -73.1},{51, -78.4},{56.6, -80},{62.2, -77.6},{67.9, -71.5},{73.5, -61.9},{79.9, -47.2},{88, -24.8},{96,0}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{67,6},{96,22}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -64, -30},{ -64,0}}, color = {192,192,192}),Text(visible = true, extent = {{ -58, -42},{ -58, -32}}, textString = "delayTime", fontName = "Arial"),Line(visible = true, points = {{ -94, -26},{ -80, -26}}, color = {192,192,192}),Line(visible = true, points = {{ -64, -26},{ -50, -26}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80, -26},{ -88, -24},{ -88, -28},{ -80, -26}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -56, -24},{ -64, -26},{ -56, -28},{ -56, -24}})}));
// 
//       equation 
//         y = delay(u, delayTime);
//       end FixedDelay;
//       block PadeDelay "Pade approximation of delay block with fixed DelayTime "
//         extends Modelica.Blocks.Interfaces.SISO;
//         parameter SI.Time delayTime = 1 "Delay time of output with respect to input signal";
//         parameter Integer n(min = 1) = 1 "Order of pade approximation";
//         parameter Integer m(min = 1, max = n) = n "Order of numerator";
//         final output Real x[n] "State of transfer function from controller canonical form";
//         annotation(Documentation(info = "<html>
// <p>
// The Input signal is delayed by a given time instant, or more precisely:
// </p>
// <pre>
//    y = u(time - delayTime) for time &gt; time.start + delayTime
//      = u(time.start)       for time &le; time.start + delayTime
// </pre>
// <p>
// The delay is approximated by a Pade approximation, i.e., by
// a transfer function
// </p>
// <pre>
//            b[1]*s^m + b[2]*s^[m-1] + ... + b[m+1]
//    y(s) = --------------------------------------------- * u(s)
//            a[1]*s^n + a[2]*s^[n-1] + ... + a[n+1]
// </pre>
// <p>
// where the coefficients b[:] and a[:] are calculated such that the
// coefficients of the Taylor expansion of the delay exp(-T*s) around s=0
// are identical upto order n+m.
// </p>
// <p>
// The main advantage of this approach is that the delay is
// approximated by a linear differential equation system, which
// is continuous and continuously differentiable. For example, it
// is uncritical to linearize a system containing a Pade-approximated
// delay.
// </p>
// <p>
// The standard text book version uses order \"m=n\", which is
// also the default setting of this block. The setting
// \"m=n-1\" may yield a better approximation in certain cases.
// <p>
// <p>
// Literature:<br>
// Otto Foellinger: Regelungstechnik, 8. Auflage,
// chapter 11.9, page 412-414, Huethig Verlag Heidelberg, 1994
// </p>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -88},{ -80,86}}, color = {192,192,192}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -75,78},{ -46,98}}, textString = "outPort", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,96},{ -86,80},{ -74,80},{ -80,96}}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -24,78},{ -2,98}}, textString = "inPort", fontName = "Arial"),Line(visible = true, points = {{ -64,0},{ -52.7,34.2},{ -45.5,53.1},{ -39.1,66.4},{ -33.4,74.6},{ -27.8,79.1},{ -22.2,79.8},{ -16.6,76.6},{ -10.9,69.7},{ -5.3,59.4},{1.1,44.1},{9.17,21.2},{26.1, -30.8},{33.3, -50.2},{39.7, -64.2},{45.3, -73.1},{51, -78.4},{56.6, -80},{62.2, -77.6},{67.9, -71.5},{73.5, -61.9},{79.9, -47.2},{88, -24.8},{96,0}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{67,6},{96,22}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -64, -30},{ -64,0}}, color = {192,192,192}),Text(visible = true, extent = {{ -58, -42},{ -58, -32}}, textString = "delayTime", fontName = "Arial"),Line(visible = true, points = {{ -94, -26},{ -80, -26}}, color = {192,192,192}),Line(visible = true, points = {{ -64, -26},{ -50, -26}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80, -26},{ -88, -24},{ -88, -28},{ -80, -26}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -56, -24},{ -64, -26},{ -56, -28},{ -56, -24}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{8, -142},{8, -102}}, textString = "delayTime=%delayTime", fontName = "Arial"),Line(visible = true, points = {{ -94,0},{ -82.7,34.2},{ -75.5,53.1},{ -69.1,66.4},{ -63.4,74.6},{ -57.8,79.1},{ -52.2,79.8},{ -46.6,76.6},{ -40.9,69.7},{ -35.3,59.4},{ -28.9,44.1},{ -20.83,21.2},{ -3.9, -30.8},{3.3, -50.2},{9.7, -64.2},{15.3, -73.1},{21, -78.4},{26.6, -80},{32.2, -77.6},{37.9, -71.5},{43.5, -61.9},{49.9, -47.2},{58, -24.8},{66,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -72,0},{ -60.7,34.2},{ -53.5,53.1},{ -47.1,66.4},{ -41.4,74.6},{ -35.8,79.1},{ -30.2,79.8},{ -24.6,76.6},{ -18.9,69.7},{ -13.3,59.4},{ -6.9,44.1},{1.17,21.2},{18.1, -30.8},{25.3, -50.2},{31.7, -64.2},{37.3, -73.1},{43, -78.4},{48.6, -80},{54.2, -77.6},{59.9, -71.5},{65.5, -61.9},{71.9, -47.2},{80, -24.8},{88,0}}, color = {160,160,160}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{ -10,38},{100,100}}, textString = "m=%m", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -98, -96},{6, -34}}, textString = "n=%n", fontName = "Arial")}));
//       protected 
//         Real x1dot "Derivative of first state of TransferFcn";
//         Real xn "Highest order state of TransferFcn";
//         Real a[n + 1];
//         Real b[m + 1];
//       protected 
//         function padeCoefficients
//           input Real T "delay time";
//           input Integer n "order of denominator";
//           input Integer m "order of numerator";
//           output Real b[m + 1] "numerator coefficients of transfer function";
//           output Real a[n + 1] "denominator coefficients of transfer function";
//         protected 
//           Real nm;
//         algorithm 
//           a[1]:=1;
//           b[1]:=1;
//           nm:=n + m;
//           for i in 1:n loop
//                       a[i + 1]:=(a[i] * T * (n - i + 1)) / (nm - i + 1) / i;
//             if i <= m then 
//                         b[i + 1]:= -(b[i] * T * (m - i + 1)) / (nm - i + 1) / i;
// 
//             else 
//             end if;
// 
//           end for;
//           b:=b[m + 1: -1:1];
//           a:=a[n + 1: -1:1];
//         end padeCoefficients;
// 
//       equation 
//         (b,a) = padeCoefficients(delayTime, n, m);
//         [der(x);xn] = [x1dot;x];
//         [u] = transpose([a]) * [x1dot;x];
//         [y] = transpose([zeros(n - m, 1);b]) * [x1dot;x];
// 
//       initial equation 
//         x[n] = u;
//       end PadeDelay;
//       block VariableDelay "Delay block with variable DelayTime"
//         extends Modelica.Blocks.Interfaces.SISO;
//         parameter Real delayMax(min = 0) = 1 "maximum delay time";
//         annotation(Documentation(info = "<html>
// <p>
// The Input signal is delayed by a given time instant, or more precisely:
// </p>
// <pre>
//    y = u(time - delayTime) for time &gt; time.start + delayTime
//      = u(time.start)       for time &le; time.start + delayTime
// </pre>
// <p>
// where delayTime is an additional input signal which must follow
// the following relationship:
// </p>
// <pre>  0 &le; delayTime &le; delayMax
// </pre>
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,96},{ -86,80},{ -74,80},{ -80,96}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -69,78},{ -40,98}}, textString = "outPort", fontName = "Arial"),Line(visible = true, points = {{ -64,0},{ -52.7,34.2},{ -45.5,53.1},{ -39.1,66.4},{ -33.4,74.6},{ -27.8,79.1},{ -22.2,79.8},{ -16.6,76.6},{ -10.9,69.7},{ -5.3,59.4},{1.1,44.1},{9.17,21.2},{26.1, -30.8},{33.3, -50.2},{39.7, -64.2},{45.3, -73.1},{51, -78.4},{56.6, -80},{62.2, -77.6},{67.9, -71.5},{73.5, -61.9},{79.9, -47.2},{88, -24.8},{96,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, color = {0,0,255}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Text(visible = true, fillColor = {160,160,160}, extent = {{67,6},{96,22}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -58, -42},{ -58, -32}}, textString = "delayTime", fontName = "Arial"),Line(visible = true, points = {{ -80, -88},{ -80,86}}, color = {192,192,192}),Text(visible = true, extent = {{ -24,78},{ -2,98}}, textString = "inPort", fontName = "Arial"),Text(visible = true, extent = {{ -24,78},{ -2,98}}, textString = "inPort", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80, -26},{ -88, -24},{ -88, -28},{ -80, -26}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -56, -24},{ -64, -26},{ -56, -28},{ -56, -24}}),Line(visible = true, points = {{ -64, -26},{ -50, -26}}, color = {192,192,192}),Line(visible = true, points = {{ -94, -26},{ -80, -26}}, color = {192,192,192}),Text(visible = true, extent = {{ -58, -42},{ -58, -32}}, textString = "delayTime", fontName = "Arial"),Line(visible = true, points = {{ -100, -60},{ -70, -60},{ -64, -44}}, arrow = {Arrow.None,Arrow.Filled}),Line(visible = true, points = {{ -80, -88},{ -80,86}}, color = {192,192,192}),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Line(visible = true, points = {{ -64,0},{ -52.7,34.2},{ -45.5,53.1},{ -39.1,66.4},{ -33.4,74.6},{ -27.8,79.1},{ -22.2,79.8},{ -16.6,76.6},{ -10.9,69.7},{ -5.3,59.4},{1.1,44.1},{9.17,21.2},{26.1, -30.8},{33.3, -50.2},{39.7, -64.2},{45.3, -73.1},{51, -78.4},{56.6, -80},{62.2, -77.6},{67.9, -71.5},{73.5, -61.9},{79.9, -47.2},{88, -24.8},{96,0}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,96},{ -86,80},{ -74,80},{ -80,96}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {0,0,255}, extent = {{ -69,78},{ -40,98}}, textString = "outPort", fontName = "Arial"),Text(visible = true, extent = {{ -24,78},{ -2,98}}, textString = "inPort", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{67,6},{96,22}}, textString = "time", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -64, -30},{ -64,0}}, color = {192,192,192})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100, -148},{100, -108}}, textString = "delayMax=%delayMax", fontName = "Arial"),Line(visible = true, points = {{ -92,0},{ -80.7,34.2},{ -73.5,53.1},{ -67.1,66.4},{ -61.4,74.6},{ -55.8,79.1},{ -50.2,79.8},{ -44.6,76.6},{ -38.9,69.7},{ -33.3,59.4},{ -26.9,44.1},{ -18.83,21.2},{ -1.9, -30.8},{5.3, -50.2},{11.7, -64.2},{17.3, -73.1},{23, -78.4},{28.6, -80},{34.2, -77.6},{39.9, -71.5},{45.5, -61.9},{51.9, -47.2},{60, -24.8},{68,0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -64,0},{ -52.7,34.2},{ -45.5,53.1},{ -39.1,66.4},{ -33.4,74.6},{ -27.8,79.1},{ -22.2,79.8},{ -16.6,76.6},{ -10.9,69.7},{ -5.3,59.4},{1.1,44.1},{9.17,21.2},{26.1, -30.8},{33.3, -50.2},{39.7, -64.2},{45.3, -73.1},{51, -78.4},{56.6, -80},{62.2, -77.6},{67.9, -71.5},{73.5, -61.9},{79.9, -47.2},{88, -24.8},{96,0}}, smooth = Smooth.Bezier),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{6,4},{ -14, -2},{ -6, -12},{6,4}}),Line(visible = true, points = {{ -100, -60},{ -76, -60},{ -8, -6}})}));
//         Modelica.Blocks.Interfaces.RealInput delayTime annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         y = delay(u, delayTime, delayMax);
//       end VariableDelay;
//     end Nonlinear;
//     package Routing "Blocks to combine and extract signals"
//       extends Icons.Library;
//       block ExtractSignal "Extract signals from an input signal vector"
//         extends Modelica.Blocks.Interfaces.MIMO;
//         parameter Integer extract[nout] = 1:nout "Extracting vector";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -100, -100},{100,100}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -50},{ -50,50}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{50, -50},{90,50}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -94.4104,1.90792},{ -94.4104, -2.09208},{ -90.4104, -0.0920762},{ -94.4104,1.90792}}),Line(visible = true, points = {{ -72,2},{ -60.1395,12.907},{ -49.1395,12.907}}),Line(visible = true, points = {{ -73,4},{ -59,40},{ -49,40}}),Line(visible = true, points = {{ -112,0},{ -75.0373, -0.0180176}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0437, -4.90745},{ -70.0437,4.59255}}),Line(visible = true, points = {{ -73, -5},{ -60, -40},{ -49, -40}}),Line(visible = true, points = {{ -72, -2},{ -60.0698, -12.907},{ -49.0698, -12.907}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.8808, -11},{ -48.8808, -15},{ -44.8808, -13},{ -48.8808, -11}}),Line(visible = true, points = {{ -46,13},{ -35,13},{35, -30},{45, -30}}),Line(visible = true, points = {{ -45,40},{ -35,40},{35,0},{44,0}}),Line(visible = true, points = {{ -45, -40},{ -34, -40},{35,30},{44,30}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -49,42},{ -49,38},{ -45,40},{ -49,42}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.8728, -38.0295},{ -48.8728, -42.0295},{ -44.8728, -40.0295},{ -48.8728, -38.0295}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.9983,14.8801},{ -48.9983,10.8801},{ -44.9983,12.8801},{ -48.9983,14.8801}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{70.3052, -5.37257},{80.3052,4.12743}}),Line(visible = true, points = {{80,0},{100,0}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.1618,32.3085},{44.1618,28.3085},{48.1618,30.3085},{44.1618,32.3085}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.2575,1.80443},{44.2575, -2.19557},{48.2575, -0.195573},{44.2575,1.80443}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.8805, -28.1745},{44.8805, -32.1745},{48.8805, -30.1745},{44.8805, -28.1745}}),Line(visible = true, points = {{48,0},{70,0}}),Line(visible = true, points = {{47,30},{60,30},{73,3}}),Line(visible = true, points = {{49, -30},{60, -30},{74, -4}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "extract=%extract", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -50},{ -50,50}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{50, -50},{90,50}}),Polygon(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -94.4104,1.90792},{ -94.4104, -2.09208},{ -90.4104, -0.0920762},{ -94.4104,1.90792}}),Line(visible = true, points = {{ -72,2},{ -60.1395,12.907},{ -49.1395,12.907}}, color = {0,0,255}),Line(visible = true, points = {{ -73,4},{ -59,40},{ -49,40}}, color = {0,0,255}),Line(visible = true, points = {{ -112,0},{ -75.0373, -0.0180176}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0437, -4.90745},{ -70.0437,4.59255}}),Line(visible = true, points = {{ -73, -5},{ -60, -40},{ -49, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -72, -2},{ -60.0698, -12.907},{ -49.0698, -12.907}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.8808, -11},{ -48.8808, -15},{ -44.8808, -13},{ -48.8808, -11}}),Line(visible = true, points = {{ -46,13},{ -35,13},{35, -30},{45, -30}}, color = {0,0,255}),Line(visible = true, points = {{ -45,40},{ -35,40},{35,0},{44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -45, -40},{ -34, -40},{35,30},{44,30}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -49,42},{ -49,38},{ -45,40},{ -49,42}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.8728, -38.0295},{ -48.8728, -42.0295},{ -44.8728, -40.0295},{ -48.8728, -38.0295}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -48.9983,14.8801},{ -48.9983,10.8801},{ -44.9983,12.8801},{ -48.9983,14.8801}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{70.3052, -5.37257},{80.3052,4.12743}}),Line(visible = true, points = {{80,0},{105,0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.1618,32.3085},{44.1618,28.3085},{48.1618,30.3085},{44.1618,32.3085}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.2575,1.80443},{44.2575, -2.19557},{48.2575, -0.195573},{44.2575,1.80443}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{44.8805, -28.1745},{44.8805, -32.1745},{48.8805, -30.1745},{44.8805, -28.1745}}),Line(visible = true, points = {{48,0},{70,0}}, color = {0,0,255}),Line(visible = true, points = {{47,30},{60,30},{73,3}}, color = {0,0,255}),Line(visible = true, points = {{49, -30},{60, -30},{74, -4}}, color = {0,0,255}),Rectangle(visible = true, extent = {{ -100, -81},{100,80}})}), Documentation(info = "<HTML>
// <p>Extract signals from the input connector and transfer them
// to the output connector.</p>
// <p>The extracting scheme is given by the integer vector 'extract'.
// This vector specifies, which input signals are taken and in which
// order they are transfered to the output vector. Note, that the
// dimension of 'extract' has to match the number of outputs.
// Additionally, the dimensions of the input connector signals and
// the output connector signals have to be explicitly defined via the
// parameters 'nin' and 'nout'.</p>
// <p>Example:</p>
// <pre>     nin = 7 \"Number of inputs\";
//      nout = 4 \"Number of outputs\";
//      extract[nout] = {6,3,3,2} \"Extracting vector\";
// </pre>
// <p>extracts four output signals (nout=4) from the seven elements of the
// input vector (nin=7):</p>
// <pre>   output no. 1 is set equal to input no. 6
//    output no. 2 is set equal to input no. 3
//    output no. 3 is set equal to input no. 3
//    output no. 4 is set equal to input no. 2
// </pre>
// </HTML>
// "));
// 
//       equation 
//         for i in 1:nout loop
//         y[i] = u[extract[i]];
// 
//         end for;
//       end ExtractSignal;
//       block Extractor "Extract scalar signal out of signal vector dependent on IntegerRealInput index"
//         extends Modelica.Blocks.Interfaces.MISO;
//         parameter Boolean allowOutOfRange = false "Index may be out of range";
//         parameter Real outOfRangeValue = 10000000000.0 "Output signal if index is out of range";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80, -50},{ -40,50}}),Polygon(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -84.4104,1.9079},{ -84.4104, -2.09208},{ -80.4104, -0.09208},{ -84.4104,1.9079}}),Line(visible = true, points = {{ -62,2},{ -50.1395,12.907},{ -39.1395,12.907}}, color = {0,0,255}),Line(visible = true, points = {{ -63,4},{ -49,40},{ -39,40}}, color = {0,0,255}),Line(visible = true, points = {{ -102,0},{ -65.0373, -0.01802}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -70.0437, -4.90745},{ -60.0437,4.5925}}),Line(visible = true, points = {{ -63, -5},{ -50, -40},{ -39, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -62, -2},{ -50.0698, -12.907},{ -39.0698, -12.907}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -38.8808, -11},{ -38.8808, -15},{ -34.8808, -13},{ -38.8808, -11}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -39,42},{ -39,38},{ -35,40},{ -39,42}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -38.8728, -38.0295},{ -38.8728, -42.0295},{ -34.8728, -40.0295},{ -38.8728, -38.0295}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -38.9983,14.8801},{ -38.9983,10.8801},{ -34.9983,12.8801},{ -38.9983,14.8801}}),Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -30, -50},{30,50}}),Line(visible = true, points = {{100,0},{0,0}}, color = {127,0,255}),Line(visible = true, points = {{0,2},{0, -104}}, color = {255,127,0}),Line(visible = true, points = {{ -35,40},{ -20,40}}, color = {127,0,255}),Line(visible = true, points = {{ -35,13},{ -20,13}}, color = {127,0,255}),Line(visible = true, points = {{ -35, -13},{ -20, -13}}, color = {127,0,255}),Line(visible = true, points = {{ -35, -40},{ -20, -40}}, color = {127,0,255}),Polygon(visible = true, lineColor = {127,0,255}, fillPattern = FillPattern.Solid, points = {{0,0},{ -18,13},{ -20,13},{ -2,0},{0,0}}),Ellipse(visible = true, lineColor = {255,127,0}, fillColor = {255,127,0}, fillPattern = FillPattern.Solid, extent = {{ -6, -6},{6,6}})}), Documentation(info = "<html>
// <p>This block extracts a scalar output signal out the
// vector of input signals dependent on the Integer
// value of the additional u index:</p>
// <pre>    y = u [ index ] ;
// </pre>
// <p>where index is an additional Integer input signal.</p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.IntegerInput index annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270), iconTransformation(origin = {0, -120}, extent = {{ -20, -20},{20,20}}, rotation =  -270)));
//       protected 
//         Real k[nin];
// 
//       equation 
//         when {initial(),change(index)} then
//                   for i in 1:nin loop
//           k[i] = if index == i then 1 else 0;
// 
//           end for;
//         
//         end when;
//         y = if not allowOutOfRange or index > 0 and index <= nin then k * u else outOfRangeValue;
//       end Extractor;
//       block Multiplex2 "Multiplexer block for two input connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of input signal connector 1";
//         parameter Integer n2 = 1 "dimension of input signal connector 2";
//         annotation(Documentation(info = "<HTML>
// <p>
// The output connector is the <b>concatenation</b> of the two input connectors.
// Note, that the dimensions of the input connector signals have to be
// explicitly defined via parameters n1 and n2.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -98,60},{ -60,60},{ -4,6}}),Line(visible = true, points = {{ -98, -60},{ -60, -60},{ -4, -4}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -98,60},{ -60,60},{ -4,6}}),Line(visible = true, points = {{ -98, -60},{ -60, -60},{ -4, -4}}),Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}})}));
//         Modelica.Blocks.Interfaces.RealInput u1[n1] "Connector of Real input signals 1" annotation(Placement(visible = true, transformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u2[n2] "Connector of Real input signals 2" annotation(Placement(visible = true, transformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n1 + n2] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [y] = [u1;u2];
//       end Multiplex2;
//       block Multiplex3 "Multiplexer block for three input connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of input signal connector 1";
//         parameter Integer n2 = 1 "dimension of input signal connector 2";
//         parameter Integer n3 = 1 "dimension of input signal connector 3";
//         annotation(Documentation(info = "<HTML>
// <p>
// The output connector is the <b>concatenation</b> of the three input connectors.
// Note, that the dimensions of the input connector signals have to be
// explicitly defined via parameters n1, n2 and n3.
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{8,0},{102,0}}),Line(visible = true, points = {{ -100,70},{ -60,70},{ -4,6}}),Line(visible = true, points = {{ -100,0},{ -12,0}}),Line(visible = true, points = {{ -100, -70},{ -62, -70},{ -4, -4}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,70},{ -60,70},{ -4,6}}),Line(visible = true, points = {{ -100, -70},{ -62, -70},{ -4, -4}}),Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -100,0},{ -12,0}})}));
//         Modelica.Blocks.Interfaces.RealInput u1[n1] "Connector of Real input signals 1" annotation(Placement(visible = true, transformation(origin = { -120,70}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,70}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u2[n2] "Connector of Real input signals 2" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u3[n3] "Connector of Real input signals 3" annotation(Placement(visible = true, transformation(origin = { -120, -70}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -70}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [y] = [u1;u2;u3];
//       end Multiplex3;
//       block Multiplex4 "Multiplexer block for four input connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of input signal connector 1";
//         parameter Integer n2 = 1 "dimension of input signal connector 2";
//         parameter Integer n3 = 1 "dimension of input signal connector 3";
//         parameter Integer n4 = 1 "dimension of input signal connector 4";
//         annotation(Documentation(info = "<HTML>
// <p>
// The output connector is the <b>concatenation</b> of the four input connectors.
// Note, that the dimensions of the input connector signals have to be
// explicitly defined via parameters n1, n2, n3 and n4.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{8,0},{102,0}}),Line(visible = true, points = {{ -100,90},{ -60,90},{ -3,4}}),Line(visible = true, points = {{ -100,30},{ -60,30},{ -9,0}}),Line(visible = true, points = {{ -99, -30},{ -59, -30},{ -10, -5}}),Line(visible = true, points = {{ -100, -90},{ -60, -90},{ -5, -6}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,90},{ -60,90},{ -3,4}}),Line(visible = true, points = {{ -100, -90},{ -60, -90},{ -5, -6}}),Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}}),Line(visible = true, points = {{ -100,30},{ -60,30},{ -9,0}}),Line(visible = true, points = {{ -99, -30},{ -59, -30},{ -10, -5}})}));
//         Modelica.Blocks.Interfaces.RealInput u1[n1] "Connector of Real input signals 1" annotation(Placement(visible = true, transformation(origin = { -120,90}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,90}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u2[n2] "Connector of Real input signals 2" annotation(Placement(visible = true, transformation(origin = { -120,30}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u3[n3] "Connector of Real input signals 3" annotation(Placement(visible = true, transformation(origin = { -120, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u4[n4] "Connector of Real input signals 4" annotation(Placement(visible = true, transformation(origin = { -120, -90}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -90}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [y] = [u1;u2;u3;u4];
//       end Multiplex4;
//       block Multiplex5 "Multiplexer block for five input connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of input signal connector 1";
//         parameter Integer n2 = 1 "dimension of input signal connector 2";
//         parameter Integer n3 = 1 "dimension of input signal connector 3";
//         parameter Integer n4 = 1 "dimension of input signal connector 4";
//         parameter Integer n5 = 1 "dimension of input signal connector 5";
//         annotation(Documentation(info = "<HTML>
// <p>
// The output connector is the <b>concatenation</b> of the five input connectors.
// Note, that the dimensions of the input connector signals have to be
// explicitly defined via parameters n1, n2, n3, n4 and n5.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{8,0},{102,0}}),Line(visible = true, points = {{ -100,100},{ -60,100},{ -4,6}}),Line(visible = true, points = {{ -99,50},{ -60,50},{ -8,5}}),Line(visible = true, points = {{ -100,0},{ -7,0}}),Line(visible = true, points = {{ -99, -50},{ -60, -50},{ -9, -6}}),Line(visible = true, points = {{ -100, -100},{ -60, -100},{ -4, -4}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,100},{ -60,100},{ -4,6}}),Line(visible = true, points = {{ -100, -100},{ -60, -100},{ -4, -4}}),Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}}),Line(visible = true, points = {{ -99,50},{ -60,50},{ -8,5}}),Line(visible = true, points = {{ -100,0},{ -7,0}}),Line(visible = true, points = {{ -99, -50},{ -60, -50},{ -9, -6}})}));
//         Modelica.Blocks.Interfaces.RealInput u1[n1] "Connector of Real input signals 1" annotation(Placement(visible = true, transformation(origin = { -120,100}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,100}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u2[n2] "Connector of Real input signals 2" annotation(Placement(visible = true, transformation(origin = { -120,50}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u3[n3] "Connector of Real input signals 3" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u4[n4] "Connector of Real input signals 4" annotation(Placement(visible = true, transformation(origin = { -120, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u5[n5] "Connector of Real input signals 5" annotation(Placement(visible = true, transformation(origin = { -120, -100}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120, -100}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4 + n5] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [y] = [u1;u2;u3;u4;u5];
//       end Multiplex5;
//       block Multiplex6 "Multiplexer block for six input connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of input signal connector 1";
//         parameter Integer n2 = 1 "dimension of input signal connector 2";
//         parameter Integer n3 = 1 "dimension of input signal connector 3";
//         parameter Integer n4 = 1 "dimension of input signal connector 4";
//         parameter Integer n5 = 1 "dimension of input signal connector 5";
//         parameter Integer n6 = 1 "dimension of input signal connector 6";
//         annotation(Documentation(info = "<HTML>
// <p>
// The output connector is the <b>concatenation</b> of the six input connectors.
// Note, that the dimensions of the input connector signals have to be
// explicitly defined via parameters n1, n2, n3, n4, n5 and n6.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}}),Line(visible = true, points = {{ -99,85},{ -61,85},{ -3,11}}),Line(visible = true, points = {{ -100,51},{ -61,51},{ -7,6}}),Line(visible = true, points = {{ -101,17},{ -60,17},{ -9,2}}),Line(visible = true, points = {{ -100, -18},{ -60, -18},{ -11, -4}}),Line(visible = true, points = {{ -99, -50},{ -60, -50},{ -9, -6}}),Line(visible = true, points = {{ -100, -85},{ -60, -85},{ -3, -10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -99,85},{ -61,85},{ -3,11}}),Line(visible = true, points = {{ -100, -85},{ -60, -85},{ -3, -10}}),Line(visible = true, points = {{8,0},{102,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -15, -15},{15,15}}),Line(visible = true, points = {{ -100,51},{ -61,51},{ -7,6}}),Line(visible = true, points = {{ -99, -50},{ -60, -50},{ -9, -6}}),Line(visible = true, points = {{ -101,17},{ -60,17},{ -9,2}}),Line(visible = true, points = {{ -100, -18},{ -60, -18},{ -11, -4}})}));
//         Modelica.Blocks.Interfaces.RealInput u1[n1] "Connector of Real input signals 1" annotation(Placement(visible = true, transformation(origin = { -112,85}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112,85}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u2[n2] "Connector of Real input signals 2" annotation(Placement(visible = true, transformation(origin = { -112,51}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112,51}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u3[n3] "Connector of Real input signals 3" annotation(Placement(visible = true, transformation(origin = { -112,17}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112,17}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u4[n4] "Connector of Real input signals 4" annotation(Placement(visible = true, transformation(origin = { -112, -17}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112, -17}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u5[n5] "Connector of Real input signals 5" annotation(Placement(visible = true, transformation(origin = { -112, -51}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112, -51}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput u6[n6] "Connector of Real input signals 6" annotation(Placement(visible = true, transformation(origin = { -112, -85}, extent = {{ -12, -12},{12,12}}, rotation = 0), iconTransformation(origin = { -112, -85}, extent = {{ -12, -12},{12,12}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4 + n5 + n6] "Connector of Real output signals" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [y] = [u1;u2;u3;u4;u5;u6];
//       end Multiplex6;
//       block DeMultiplex2 "DeMultiplexer block for two output connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of output signal connector 1";
//         parameter Integer n2 = 1 "dimension of output signal connector 2";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input connector is <b>splitted</b> up into two output connectors.
// Note, that the dimensions of the output connector signals have to be
// explicitly defined via parameters n1 and n2.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{100,60},{60,60},{10,8}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{100, -60},{60, -60},{8, -8}}),Line(visible = true, points = {{ -100,0},{ -6,0}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{100,60},{60,60},{10,8}}),Line(visible = true, points = {{100, -60},{60, -60},{8, -8}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}})}));
//         Modelica.Blocks.Interfaces.RealInput u[n1 + n2] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y1[n1] "Connector of Real output signals 1" annotation(Placement(visible = true, transformation(origin = {110,60}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y2[n2] "Connector of Real output signals 2" annotation(Placement(visible = true, transformation(origin = {110, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [u] = [y1;y2];
//       end DeMultiplex2;
//       block DeMultiplex3 "DeMultiplexer block for three output connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of output signal connector 1";
//         parameter Integer n2 = 1 "dimension of output signal connector 2";
//         parameter Integer n3 = 1 "dimension of output signal connector 3";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input connector is <b>splitted</b> up into three output connectors.
// Note, that the dimensions of the output connector signals have to be
// explicitly defined via parameters n1, n2 and n3.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Line(visible = true, points = {{100,70},{60,70},{4,5}}),Line(visible = true, points = {{0,0},{101,0}}),Line(visible = true, points = {{100, -70},{61, -70},{5, -5}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{100,70},{60,70},{4,5}}),Line(visible = true, points = {{100, -70},{61, -70},{5, -5}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -16, -15},{14,15}}),Line(visible = true, points = {{0,0},{101,0}})}));
//         Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y1[n1] "Connector of Real output signals 1" annotation(Placement(visible = true, transformation(origin = {110,70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y2[n2] "Connector of Real output signals 2" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y3[n3] "Connector of Real output signals 3" annotation(Placement(visible = true, transformation(origin = {110, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [u] = [y1;y2;y3];
//       end DeMultiplex3;
//       block DeMultiplex4 "DeMultiplexer block for four output connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of output signal connector 1";
//         parameter Integer n2 = 1 "dimension of output signal connector 2";
//         parameter Integer n3 = 1 "dimension of output signal connector 3";
//         parameter Integer n4 = 1 "dimension of output signal connector 4";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input connector is <b>splitted</b> up into four output connectors.
// Note, that the dimensions of the output connector signals have to be
// explicitly defined via parameters n1, n2, n3 and n4.
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Line(visible = true, points = {{100,90},{60,90},{6,5}}),Line(visible = true, points = {{100,30},{60,30},{9,2}}),Line(visible = true, points = {{100, -30},{60, -30},{8, -4}}),Line(visible = true, points = {{99, -90},{60, -90},{6, -6}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{100,90},{60,90},{6,5}}),Line(visible = true, points = {{99, -90},{60, -90},{6, -6}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Line(visible = true, points = {{100,30},{60,30},{9,2}}),Line(visible = true, points = {{100, -30},{60, -30},{8, -4}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -16, -15},{14,15}})}));
//         Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3 + n4] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y1[n1] "Connector of Real output signals 1" annotation(Placement(visible = true, transformation(origin = {110,90}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y2[n2] "Connector of Real output signals 2" annotation(Placement(visible = true, transformation(origin = {110,30}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y3[n3] "Connector of Real output signals 3" annotation(Placement(visible = true, transformation(origin = {110, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y4[n4] "Connector of Real output signals 4" annotation(Placement(visible = true, transformation(origin = {110, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [u] = [y1;y2;y3;y4];
//       end DeMultiplex4;
//       block DeMultiplex5 "DeMultiplexer block for five output connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of output signal connector 1";
//         parameter Integer n2 = 1 "dimension of output signal connector 2";
//         parameter Integer n3 = 1 "dimension of output signal connector 3";
//         parameter Integer n4 = 1 "dimension of output signal connector 4";
//         parameter Integer n5 = 1 "dimension of output signal connector 5";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input connector is <b>splitted</b> up into five output connectors.
// Note, that the dimensions of the output connector signals have to be
// explicitly defined via parameters n1, n2, n3, n4 and n5.
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Line(visible = true, points = {{99,80},{60,80},{6,5}}),Line(visible = true, points = {{100,40},{60,40},{10,3}}),Line(visible = true, points = {{100,0},{10,0}}),Line(visible = true, points = {{100, -40},{61, -40},{11, -7}}),Line(visible = true, points = {{100, -80},{60, -80},{7, -5}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{99,80},{60,80},{6,5}}),Line(visible = true, points = {{100, -80},{60, -80},{7, -5}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -15},{16,15}}),Line(visible = true, points = {{100,40},{60,40},{10,3}}),Line(visible = true, points = {{100,0},{10,0}}),Line(visible = true, points = {{100, -40},{61, -40},{11, -7}})}));
//         Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3 + n4 + n5] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y1[n1] "Connector of Real output signals 1" annotation(Placement(visible = true, transformation(origin = {110,80}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y2[n2] "Connector of Real output signals 2" annotation(Placement(visible = true, transformation(origin = {110,40}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y3[n3] "Connector of Real output signals 3" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y4[n4] "Connector of Real output signals 4" annotation(Placement(visible = true, transformation(origin = {110, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y5[n5] "Connector of Real output signals 5" annotation(Placement(visible = true, transformation(origin = {110, -80}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [u] = [y1;y2;y3;y4;y5];
//       end DeMultiplex5;
//       block DeMultiplex6 "DeMultiplexer block for six output connectors"
//         extends Modelica.Blocks.Interfaces.BlockIcon;
//         parameter Integer n1 = 1 "dimension of output signal connector 1";
//         parameter Integer n2 = 1 "dimension of output signal connector 2";
//         parameter Integer n3 = 1 "dimension of output signal connector 3";
//         parameter Integer n4 = 1 "dimension of output signal connector 4";
//         parameter Integer n5 = 1 "dimension of output signal connector 5";
//         parameter Integer n6 = 1 "dimension of output signal connector 6";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input connector is <b>splitted</b> up into six output connectors.
// Note, that the dimensions of the output connector signals have to be
// explicitly defined via parameters n1, n2, n3, n4, n5 and n6.
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -14},{16,16}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Line(visible = true, points = {{99,90},{60,90},{5,10}}),Line(visible = true, points = {{100,53},{60,53},{8,6}}),Line(visible = true, points = {{100,18},{59,18},{7,2}}),Line(visible = true, points = {{100, -19},{60, -19},{13, -2}}),Line(visible = true, points = {{99, -54},{60, -54},{9, -1}}),Line(visible = true, points = {{100, -91},{60, -91},{3, -7}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{99,90},{60,90},{5,10}}),Line(visible = true, points = {{100, -91},{60, -91},{3, -7}}),Line(visible = true, points = {{ -100,0},{ -6,0}}),Ellipse(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -14, -15},{16,15}}),Line(visible = true, points = {{100,53},{60,53},{8,6}}),Line(visible = true, points = {{99, -54},{60, -54},{9, -1}}),Line(visible = true, points = {{100,18},{59,18},{7,2}}),Line(visible = true, points = {{100, -19},{60, -19},{13, -2}})}));
//         Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3 + n4 + n5 + n6] "Connector of Real input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y1[n1] "Connector of Real output signals 1" annotation(Placement(visible = true, transformation(origin = {110,90}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y2[n2] "Connector of Real output signals 2" annotation(Placement(visible = true, transformation(origin = {110,54}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,54}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y3[n3] "Connector of Real output signals 3" annotation(Placement(visible = true, transformation(origin = {110,18}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,18}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y4[n4] "Connector of Real output signals 4" annotation(Placement(visible = true, transformation(origin = {110, -18}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -18}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y5[n5] "Connector of Real output signals 5" annotation(Placement(visible = true, transformation(origin = {110, -54}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -54}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput y6[n6] "Connector of Real output signals 6" annotation(Placement(visible = true, transformation(origin = {110, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         [u] = [y1;y2;y3;y4;y5;y6];
//       end DeMultiplex6;
//       annotation(Documentation(info = "<html>
// <p>
// This package contains blocks to combine and extract signals.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Routing;
//     package Sources "Signal source blocks generating Real and Boolean signals"
//       block RealExpression "Set output signal to a time varying Real expression"
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -96, -15},{96,15}}, textString = "%y", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{140,90}}, textString = "%name", fontName = "Arial")}));
//         Blocks.Interfaces.RealOutput y = 0.0 "Value of Real output" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end RealExpression;
//       block IntegerExpression "Set output signal to a time varying Integer expression"
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -96, -15},{96,15}}, textString = "%y", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{140,90}}, textString = "%name", fontName = "Arial")}));
//         Blocks.Interfaces.IntegerOutput y = 0 "Value of Integer output" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end IntegerExpression;
//       block BooleanExpression "Set output signal to a time varying Boolean expression"
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -96, -15},{96,15}}, textString = "%y", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{140,90}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{100,10},{120,0},{100, -10},{100,10}})}));
//         Blocks.Interfaces.BooleanOutput y = false "Value of Boolean output" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       end BooleanExpression;
//       import Modelica.Blocks.Interfaces;
//       import Modelica.SIunits;
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains <b>source</b> components, i.e., blocks which
// have only output signals. These blocks are used as signal generators
// for Real, Integer and Boolean signals.
// </p>
// 
// <p>
// All Real source signals (with the exception of the Constant source)
// have at least the following two parameters:
// </p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>offset</b></td>
//       <td>Value which is added to the signal</td>
//   </tr>
//   <tr><td><b>startTime</b></td>
//       <td>Start time of signal. For time &lt; startTime,
//                 the output y is set to offset.</td>
//   </tr>
// </table>
// 
// <p>
// The <b>offset</b> parameter is especially useful in order to shift
// the corresponding source, such that at initial time the system
// is stationary. To determine the corresponding value of offset,
// usually requires a trimming calculation.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
// <li><i>Nov. 8, 1999</i>
//        by <a href=\"mailto:clauss@eas.iis.fhg.de\">Christoph Clau&szlig;</a>,
//        <A HREF=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</A>,
//        <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
//        (nperiod=-1 is an infinite number of periods).</li>
// <li><i>Oct. 31, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        <a href=\"mailto:clauss@eas.iis.fhg.de\">Christoph Clau&szlig;</a>,
//        <A HREF=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</A>,
//        All sources vectorized. New sources: ExpSine, Trapezoid,
//        BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
//        Improved documentation, especially detailed description of
//        signals in diagram layer.</li>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{0,0},{430, -442}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       block Clock "Generate actual time signal "
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {160,160,160}, extent = {{ -80, -80},{80,80}}),Line(visible = true, points = {{0,80},{0,60}}, color = {160,160,160}),Line(visible = true, points = {{80,0},{60,0}}, color = {160,160,160}),Line(visible = true, points = {{0, -80},{0, -60}}, color = {160,160,160}),Line(visible = true, points = {{ -80,0},{ -60,0}}, color = {160,160,160}),Line(visible = true, points = {{37,70},{26,50}}, color = {160,160,160}),Line(visible = true, points = {{70,38},{49,26}}, color = {160,160,160}),Line(visible = true, points = {{71, -37},{52, -27}}, color = {160,160,160}),Line(visible = true, points = {{39, -70},{29, -51}}, color = {160,160,160}),Line(visible = true, points = {{ -39, -70},{ -29, -52}}, color = {160,160,160}),Line(visible = true, points = {{ -71, -37},{ -50, -26}}, color = {160,160,160}),Line(visible = true, points = {{ -71,37},{ -54,28}}, color = {160,160,160}),Line(visible = true, points = {{ -38,70},{ -28,51}}, color = {160,160,160}),Line(visible = true, points = {{0,0},{ -50,50}}, thickness = 0.5),Line(visible = true, points = {{0,0},{40,0}}, thickness = 0.5),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "startTime=%startTime", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80,0},{ -10,0},{60,70}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,0},{ -37, -13},{ -30, -13},{ -34,0}}),Line(visible = true, points = {{ -34, -13},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -69},{ -37, -56},{ -31, -56},{ -34, -69},{ -34, -69}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -81, -43},{ -35, -25}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -33, -89},{13, -71}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -66,72},{ -25,92}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10,0},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,0},{50,0}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{50,0},{50,60}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, fillColor = {160,160,160}, extent = {{35,23},{50,33}}, textString = "1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{14,1},{32,13}}, textString = "1", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else time - startTime);
//       end Clock;
//       block Constant "Generate constant signal of type Real"
//         parameter Real k = 1 "Constant output value";
//         extends Interfaces.SO;
//         annotation(defaultComponentName = "const", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80,0},{80,0}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "k=%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80,0},{80,0}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -75,76},{ -22,94}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -101, -12},{ -81,8}}, textString = "k", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = k;
//       end Constant;
//       block Step "Generate step signal of type Real"
//         parameter Real height = 1 "Height of step";
//         extends Interfaces.SignalSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{0, -70},{0,50},{80,50}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "startTime=%startTime", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -18},{0, -18},{0,50},{80,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -21, -90},{25, -72}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{0, -17},{0, -71}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, fillColor = {160,160,160}, extent = {{ -68, -54},{ -22, -36}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -13,50},{ -13, -17}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, pattern = LinePattern.Dash, points = {{2,50},{ -19,50},{2,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -17},{ -16, -4},{ -10, -4},{ -13, -17},{ -13, -17}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13,50},{ -16,37},{ -9,37},{ -13,50}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -68,8},{ -22,26}}, textString = "height", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -69},{ -16, -56},{ -10, -56},{ -13, -69},{ -13, -69}}),Line(visible = true, points = {{ -13, -18},{ -13, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -18},{ -16, -31},{ -9, -31},{ -13, -18}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -72,80},{ -31,100}}, textString = "y", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else height);
//       end Step;
//       block Ramp "Generate ramp signal"
//         parameter Real height = 1 "Height of ramps";
//         parameter Real duration(min = Modelica.Constants.small) = 2 "Durations of ramp";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{ -40, -70},{31,38}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "duration=%duration", fontName = "Arial"),Line(visible = true, points = {{31,38},{86,38}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -20},{ -20, -20},{50,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -20},{ -42, -30},{ -37, -30},{ -40, -20}}),Line(visible = true, points = {{ -40, -20},{ -40, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -80, -49},{ -41, -33}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -40, -88},{6, -70}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -66,72},{ -25,92}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -19, -20},{50, -20}}, color = {192,192,192}),Line(visible = true, points = {{50,50},{101,50}}, thickness = 0.5),Line(visible = true, points = {{50,50},{50, -20}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{42, -18},{42, -22},{50, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -20, -20},{ -11, -18},{ -11, -22},{ -20, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50,50},{48,40},{53,40},{50,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{47, -10},{52, -10},{50, -20},{50, -20}}),Text(visible = true, fillColor = {160,160,160}, extent = {{53,7},{82,25}}, textString = "height", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{0, -37},{35, -17}}, textString = "duration", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else if time < startTime + duration then ((time - startTime) * height) / duration else height);
//       end Ramp;
//       block Sine "Generate sine signal"
//         parameter Real amplitude = 1 "Amplitude of sine wave";
//         parameter SIunits.Frequency freqHz = 1 "Frequency of sine wave";
//         parameter SIunits.Angle phase = 0 "Phase of sine wave";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -40,0},{ -31.6,34.2},{ -26.1,53.1},{ -21.3,66.4},{ -17.1,74.6},{ -12.9,79.1},{ -8.64,79.8},{ -4.42,76.6},{ -0.2,69.7},{4.02,59.4},{8.84,44.1},{14.9,21.2},{27.5, -30.8},{33, -50.2},{37.8, -64.2},{42, -73.1},{46.2, -78.4},{50.5, -80},{54.7, -77.6},{58.9, -71.5},{63.1, -61.9},{67.9, -47.2},{74, -24.8},{80,0}}, thickness = 0.5, smooth = Smooth.Bezier),Line(visible = true, points = {{ -41, -2},{ -80, -2}}, thickness = 0.5),Text(visible = true, fillColor = {160,160,160}, extent = {{ -128, -11},{ -82,7}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -41, -2},{ -41, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, fillColor = {160,160,160}, extent = {{ -60, -61},{ -14, -43}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -74,86},{ -33,106}}, textString = "y", fontName = "Arial"),Line(visible = true, points = {{ -9,79},{43,79}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -42, -1},{50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,80},{30,67},{37,67},{33,80}}),Text(visible = true, fillColor = {160,160,160}, extent = {{37,39},{83,57}}, textString = "amplitude", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,1},{30,14},{36,14},{33,1},{33,1}}),Line(visible = true, points = {{33,79},{33,0}}, color = {192,192,192})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -147, -152},{153, -112}}, textString = "freqHz=%freqHz", fontName = "Arial")}));
//       protected 
//         constant Real pi = Modelica.Constants.pi;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(points = {{90,0},{68,8},{68, -8},{90,0}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, color = {0,0,0}),Text(extent = {{ -147, -152},{153, -112}}, textString = "freqHz=%freqHz", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(points = {{101, -40},{85, -34},{85, -46},{101, -40}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -40,0},{ -31.6,34.2},{ -26.1,53.1},{ -21.3,66.4},{ -17.1,74.6},{ -12.9,79.1},{ -8.64,79.8},{ -4.42,76.6},{ -0.201,69.7},{4.02,59.4},{8.84,44.1},{14.9,21.2},{27.5, -30.8},{33, -50.2},{37.8, -64.2},{42, -73.1},{46.2, -78.4},{50.5, -80},{54.7, -77.6},{58.9, -71.5},{63.1, -61.9},{67.9, -47.2},{74, -24.8},{80,0}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -41, -2},{ -80, -2}}, color = {0,0,0}, thickness = 0.5),Text(extent = {{ -128,7},{ -82, -11}}, textString = "offset", fillColor = {160,160,160}),Line(points = {{ -41, -2},{ -41, -40}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(extent = {{ -60, -43},{ -14, -61}}, textString = "startTime", fillColor = {160,160,160}),Text(extent = {{84, -52},{108, -72}}, textString = "time", fillColor = {160,160,160}),Text(extent = {{ -74,106},{ -33,86}}, textString = "y", fillColor = {160,160,160}),Line(points = {{ -9,79},{43,79}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -42, -1},{50,0}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(points = {{33,80},{30,67},{37,67},{33,80}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{37,57},{83,39}}, textString = "amplitude", fillColor = {160,160,160}),Polygon(points = {{33,1},{30,14},{36,14},{33,1},{33,1}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{33,79},{33,0}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None})}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else amplitude * Modelica.Math.sin(2 * pi * freqHz * (time - startTime) + phase));
//       end Sine;
//       block ExpSine "Generate exponentially damped sine signal"
//         parameter Real amplitude = 1 "Amplitude of sine wave";
//         parameter SIunits.Frequency freqHz = 2 "Frequency of sine wave";
//         parameter SIunits.Angle phase = 0 "Phase of sine wave";
//         parameter SIunits.Damping damping = 1 "Damping coefficient of sine wave";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -50,0},{ -46.1,28.2},{ -43.5,44},{ -40.9,56.4},{ -38.2,64.9},{ -35.6,69.4},{ -33,69.6},{ -30.4,65.9},{ -27.8,58.7},{ -24.5,45.7},{ -19.9,22.5},{ -13.4, -12.2},{ -9.5, -29.5},{ -6.23, -40.1},{ -2.96, -46.5},{0.3, -48.4},{3.57, -45.9},{6.83, -39.6},{10.8, -28.1},{21.9,12},{25.8,23.1},{29.7,30.5},{33,33.3},{36.9,32.5},{40.8,27.8},{46,16.9},{56.5, -9.2},{61.7, -18.6},{66.3, -22.7},{70.9, -22.6},{76.1, -18},{80, -12.1}}, thickness = 0.5, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{ -106, -10},{ -83,10}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -72, -54},{ -26, -36}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -79,87},{ -39,104}}, textString = "y", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{18,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50,0},{ -81,0}}, thickness = 0.5),Line(visible = true, points = {{ -50,77},{ -50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18, -1},{18,76}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18,73},{ -50,73}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -42,74},{9,88}}, textString = "1/freqHz", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -49,73},{ -40,75},{ -40,71},{ -49,73}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{18,73},{10,75},{10,71},{18,73}}),Line(visible = true, points = {{ -50, -61},{ -19, -61}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -18, -61},{ -26, -59},{ -26, -63},{ -18, -61}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -51, -75},{ -27, -63}}, textString = "t", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -82, -96},{108, -67}}, textString = "amplitude*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{ -50, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50, -54},{ -50, -72}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -15, -77},{ -1, -48}}, color = {192,192,192}, pattern = LinePattern.Dot)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,0},{ -75.2,32.3},{ -72,50.3},{ -68.7,64.5},{ -65.5,74.2},{ -62.3,79.3},{ -59.1,79.6},{ -55.9,75.3},{ -52.7,67.1},{ -48.6,52.2},{ -43,25.8},{ -35, -13.9},{ -30.2, -33.7},{ -26.1, -45.9},{ -22.1, -53.2},{ -18.1, -55.3},{ -14.1, -52.5},{ -10.1, -45.3},{ -5.23, -32.1},{8.44,13.7},{13.3,26.4},{18.1,34.8},{22.1,38},{26.9,37.2},{31.8,31.8},{38.2,19.4},{51.1, -10.5},{57.5, -21.2},{63.1, -25.9},{68.7, -25.9},{75.2, -20.5},{80, -13.8}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -147, -152},{153, -112}}, textString = "freqHz=%freqHz", fontName = "Arial")}));
//       protected 
//         constant Real pi = Modelica.Constants.pi;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(points = {{90,0},{68,8},{68, -8},{90,0}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,0},{ -75.2,32.3},{ -72,50.3},{ -68.7,64.5},{ -65.5,74.2},{ -62.3,79.3},{ -59.1,79.6},{ -55.9,75.3},{ -52.7,67.1},{ -48.6,52.2},{ -43,25.8},{ -35, -13.9},{ -30.2, -33.7},{ -26.1, -45.9},{ -22.1, -53.2},{ -18.1, -55.3},{ -14.1, -52.5},{ -10.1, -45.3},{ -5.23, -32.1},{8.44,13.7},{13.3,26.4},{18.1,34.8},{22.1,38},{26.9,37.2},{31.8,31.8},{38.2,19.4},{51.1, -10.5},{57.5, -21.2},{63.1, -25.9},{68.7, -25.9},{75.2, -20.5},{80, -13.8}}, color = {0,0,0}),Text(extent = {{ -147, -152},{153, -112}}, textString = "freqHz=%freqHz", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(points = {{101, -40},{85, -34},{85, -46},{101, -40}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -50,0},{ -46.1,28.2},{ -43.5,44},{ -40.9,56.4},{ -38.2,64.9},{ -35.6,69.4},{ -33,69.6},{ -30.4,65.9},{ -27.8,58.7},{ -24.5,45.7},{ -19.9,22.5},{ -13.4, -12.2},{ -9.5, -29.5},{ -6.23, -40.1},{ -2.96, -46.5},{0.302, -48.4},{3.57, -45.9},{6.83, -39.6},{10.8, -28.1},{21.9,12},{25.8,23.1},{29.7,30.5},{33,33.3},{36.9,32.5},{40.8,27.8},{46,16.9},{56.5, -9.2},{61.7, -18.6},{66.3, -22.7},{70.9, -22.6},{76.1, -18},{80, -12.1}}, color = {0,0,0}, thickness = 0.5),Text(extent = {{ -106,10},{ -83, -10}}, textString = "offset", fillColor = {160,160,160}),Text(extent = {{ -72, -36},{ -26, -54}}, textString = "startTime", fillColor = {160,160,160}),Text(extent = {{84, -52},{108, -72}}, textString = "time", fillColor = {160,160,160}),Text(extent = {{ -79,104},{ -39,87}}, textString = "y", fillColor = {160,160,160}),Line(points = {{ -50,0},{18,0}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -50,0},{ -81,0}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -50,77},{ -50,0}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{18, -1},{18,76}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{18,73},{ -50,73}}, color = {192,192,192}),Text(extent = {{ -42,88},{9,74}}, textString = "1/freqHz", fillColor = {160,160,160}),Polygon(points = {{ -49,73},{ -40,75},{ -40,71},{ -49,73}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{18,73},{10,75},{10,71},{18,73}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -50, -61},{ -19, -61}}, color = {192,192,192}),Polygon(points = {{ -18, -61},{ -26, -59},{ -26, -63},{ -18, -61}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -51, -63},{ -27, -75}}, textString = "t", fillColor = {160,160,160}),Text(extent = {{ -82, -67},{108, -96}}, textString = "amplitude*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", fillColor = {160,160,160}),Line(points = {{ -50,0},{ -50, -40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -50, -54},{ -50, -72}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -15, -77},{ -1, -48}}, color = {192,192,192}, pattern = LinePattern.Dash)}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else amplitude * Modelica.Math.exp( -(time - startTime) * damping) * Modelica.Math.sin(2 * pi * freqHz * (time - startTime) + phase));
//       end ExpSine;
//       model Exponentials "Generate a rising and falling exponential signal"
//         parameter Real outMax = 1 "Height of output for infinite riseTime";
//         parameter SIunits.Time riseTime(min = 0) = 0.5 "Rise time";
//         parameter SIunits.Time riseTimeConst(min = Modelica.Constants.small) = 0.1 "Rise time constant";
//         parameter SIunits.Time fallTimeConst(min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -70},{84, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -70},{84, -64},{84, -76},{100, -70}}),Line(visible = true, points = {{ -40, -30},{ -37.2, -15.3},{ -34.3, -2.1},{ -30.8,12.4},{ -27.3,25},{ -23.7,35.92},{ -19.5,47.18},{ -15.3,56.7},{ -10.3,66},{ -4.6,74.5},{1.7,82.1},{8.8,88.6},{17.3,94.3},{30,100},{30,100},{32.12,87.5},{34.95,72.7},{37.78,59.8},{40.61,48.45},{44.14,36.3},{47.68,26},{51.9,15.8},{56.2,7.4},{61.1, -0.5},{66.8, -7.4},{73.1, -13.3},{80.9, -18.5},{90.8, -22.8},{100, -25.4}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -70,71},{ -29,91}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -78, -56},{ -46, -43}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Line(visible = true, points = {{ -40, -29},{ -40, -60}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -30},{ -42, -40},{ -37, -40},{ -40, -30}}),Line(visible = true, points = {{ -39, -30},{ -80, -30}}, thickness = 0.5),Text(visible = true, fillColor = {160,160,160}, extent = {{ -59, -89},{ -13, -71}}, textString = "startTime", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -41, -30},{ -32, -28},{ -32, -32},{ -41, -30}}),Line(visible = true, points = {{ -40, -30},{29, -30}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{29, -30},{21, -28},{21, -32},{29, -30}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -26, -28},{19, -12}}, textString = "riseTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{78, -96},{102, -76}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{30,100},{30, -34}}, color = {192,192,192}, pattern = LinePattern.Dot)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -70},{68, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{ -77.2, -55.3},{ -74.3, -42.1},{ -70.8, -27.6},{ -67.3, -15},{ -63.7, -4.08},{ -59.5,7.18},{ -55.3,16.7},{ -50.3,26},{ -44.6,34.5},{ -38.3,42.1},{ -31.2,48.6},{ -22.7,54.3},{ -10,60},{ -10,60},{ -7.88,47.5},{ -5.05,32.7},{ -2.22,19.8},{0.61,8.45},{4.14, -3.7},{7.68, -14},{11.9, -24.2},{16.2, -32.6},{21.1, -40.5},{26.8, -47.4},{33.1, -53.3},{40.9, -58.5},{50.8, -62.8},{60, -65.4}}, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "riseTime=%riseTime", fontName = "Arial")}));
//       protected 
//         Real y_riseTime;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -90, -70},{68, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80, -70},{ -77.2, -55.3},{ -74.3, -42.1},{ -70.8, -27.6},{ -67.3, -15},{ -63.7, -4.08},{ -59.5,7.18},{ -55.3,16.7},{ -50.3,26},{ -44.6,34.5},{ -38.3,42.1},{ -31.2,48.6},{ -22.7,54.3},{ -12.1,59.2},{ -10,60},{ -7.88,47.5},{ -5.05,32.7},{ -2.22,19.8},{0.606,8.45},{4.14, -3.7},{7.68, -14},{11.9, -24.2},{16.2, -32.6},{21.1, -40.5},{26.8, -47.4},{33.1, -53.3},{40.9, -58.5},{50.8, -62.8},{60, -65.4}}, color = {0,0,0}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(extent = {{ -150, -150},{150, -110}}, textString = "riseTime=%riseTime", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -100, -70},{84, -70}}, color = {192,192,192}),Polygon(points = {{100, -70},{84, -64},{84, -76},{100, -70}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -40, -30},{ -37.2, -15.3},{ -34.3, -2.1},{ -30.8,12.4},{ -27.3,25},{ -23.7,35.92},{ -19.5,47.18},{ -15.3,56.7},{ -10.3,66},{ -4.6,74.5},{1.7,82.1},{8.8,88.6},{17.3,94.3},{27.9,99.2},{30,100},{32.12,87.5},{34.95,72.7},{37.78,59.8},{40.606,48.45},{44.14,36.3},{47.68,26},{51.9,15.8},{56.2,7.4},{61.1, -0.5},{66.8, -7.4},{73.1, -13.3},{80.9, -18.5},{90.8, -22.8},{100, -25.4}}, color = {0,0,0}, thickness = 0.5),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(extent = {{ -70,91},{ -29,71}}, textString = "y", fillColor = {160,160,160}),Text(extent = {{ -78, -43},{ -46, -56}}, textString = "offset", fillColor = {160,160,160}),Polygon(points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -40, -29},{ -40, -60}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Polygon(points = {{ -40, -30},{ -42, -40},{ -37, -40},{ -40, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -39, -30},{ -80, -30}}, color = {0,0,0}, thickness = 0.5),Text(extent = {{ -59, -71},{ -13, -89}}, textString = "startTime", fillColor = {160,160,160}),Polygon(points = {{ -41, -30},{ -32, -28},{ -32, -32},{ -41, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -40, -30},{29, -30}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Polygon(points = {{29, -30},{21, -28},{21, -32},{29, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -26, -12},{19, -28}}, textString = "riseTime", fillColor = {160,160,160}),Text(extent = {{78, -76},{102, -96}}, textString = "time", fillColor = {160,160,160}),Line(points = {{30,100},{30, -34}}, color = {192,192,192}, pattern = LinePattern.Dash)}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y_riseTime = outMax * (1 - Modelica.Math.exp( -riseTime / riseTimeConst));
//         y = offset + (if time < startTime then 0 else if time < startTime + riseTime then outMax * (1 - Modelica.Math.exp( -(time - startTime) / riseTimeConst)) else y_riseTime * Modelica.Math.exp( -(time - startTime - riseTime) / fallTimeConst));
//       end Exponentials;
//       block Pulse "Generate pulse signal of type Real"
//         parameter Real amplitude = 1 "Amplitude of pulse";
//         parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of periods";
//         parameter Modelica.SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//         parameter Real offset = 0 "Offset of output signals";
//         parameter Modelica.SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Modelica.Blocks.Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{ -40, -70},{ -40,44},{0,44},{0, -70},{40, -70},{40,44},{79,44}}),Text(visible = true, extent = {{ -147, -152},{153, -112}}, textString = "period=%period", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37, -12},{ -30, -12},{ -34,1}}),Line(visible = true, points = {{ -34, -1},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -33, -70},{ -36, -57},{ -30, -57},{ -33, -70},{ -33, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -76,79},{ -35,99}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10,0},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -80,0},{ -10,0},{ -10,50},{30,50},{30,0},{50,0},{50,50},{90,50}}, thickness = 0.5),Line(visible = true, points = {{ -10,88},{ -10,49}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{30,74},{30,50}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(visible = true, points = {{50,88},{50,50}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,83},{51,83}}, color = {192,192,192}),Line(visible = true, points = {{ -10,69},{30,69}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{0,85},{46,97}}, textString = "period", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -9,69},{30,81}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -43,50},{ -10,50}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -34,50},{ -34,1}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "amplitude", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,49},{ -37,36},{ -30,36},{ -34,49}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37,14},{ -31,14},{ -34,1},{ -34,1}}),Line(visible = true, points = {{90,50},{90,0},{100,0}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,69},{ -1,71},{ -1,67},{ -10,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{30,69},{22,71},{22,67},{30,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,83},{ -1,85},{ -1,81},{ -10,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50,83},{42,85},{42,81},{50,83}})}), Documentation(info = "<html>
// 
// </html>"));
//       protected 
//         Modelica.SIunits.Time T0(final start = startTime) "Start time of current period";
//         Modelica.SIunits.Time T_width = (period * width) / 100;
// 
//       equation 
//         when sample(startTime, period) then
//                   T0 = time;
//         
//         end when;
//         y = offset + (if time < startTime or time >= T0 + T_width then 0 else amplitude);
//       end Pulse;
//       block SawTooth "Generate saw tooth signal"
//         parameter Real amplitude = 1 "Amplitude of saw tooth";
//         parameter SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//         parameter Real offset = 0 "Offset of output signals";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{ -60, -70},{0,40},{0, -70},{60,41},{60, -70}}),Text(visible = true, extent = {{ -147, -152},{153, -112}}, textString = "period=%period", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -19},{ -37, -32},{ -30, -32},{ -34, -19}}),Line(visible = true, points = {{ -34, -20},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -70},{ -37, -57},{ -31, -57},{ -34, -70},{ -34, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -76,79},{ -35,99}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10, -20},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,88},{ -10, -20}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{30,88},{30,59}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,83},{30,83}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -12,85},{34,97}}, textString = "period", fontName = "Arial"),Line(visible = true, points = {{ -44,60},{30,60}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -34,47},{ -34, -7}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "amplitude", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,60},{ -37,47},{ -30,47},{ -34,60}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -20},{ -37, -7},{ -31, -7},{ -34, -20},{ -34, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,83},{ -1,85},{ -1,81},{ -10,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{30,83},{22,85},{22,81},{30,83}}),Line(visible = true, points = {{ -80, -20},{ -10, -20},{30,60},{30, -20},{72,60},{72, -20}}, thickness = 0.5)}));
//       protected 
//         SIunits.Time T0(final start = startTime) "Start time of current period";
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -80, -70},{ -60, -70},{0,40},{0, -70},{60,41},{60, -70}}, color = {0,0,0}),Text(extent = {{ -147, -152},{153, -112}}, textString = "period=%period", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -34, -19},{ -37, -32},{ -30, -32},{ -34, -19}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -34, -20},{ -34, -70}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Polygon(points = {{ -34, -70},{ -37, -57},{ -31, -57},{ -34, -70},{ -34, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -78, -24},{ -35, -36}}, textString = "offset", fillColor = {160,160,160}),Text(extent = {{ -31, -69},{15, -87}}, textString = "startTime", fillColor = {160,160,160}),Text(extent = {{ -76,99},{ -35,79}}, textString = "y", fillColor = {160,160,160}),Text(extent = {{70, -80},{94, -100}}, textString = "time", fillColor = {160,160,160}),Line(points = {{ -10, -20},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -10,88},{ -10, -20}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{30,88},{30,59}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -10,83},{30,83}}, color = {192,192,192}),Text(extent = {{ -12,97},{34,85}}, textString = "period", fillColor = {160,160,160}),Line(points = {{ -44,60},{30,60}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -34,47},{ -34, -7}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Text(extent = {{ -78,34},{ -37,20}}, textString = "amplitude", fillColor = {160,160,160}),Polygon(points = {{ -34,60},{ -37,47},{ -30,47},{ -34,60}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -34, -20},{ -37, -7},{ -31, -7},{ -34, -20},{ -34, -20}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -10,83},{ -1,85},{ -1,81},{ -10,83}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{30,83},{22,85},{22,81},{30,83}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -80, -20},{ -10, -20},{30,60},{30, -20},{72,60},{72, -20}}, color = {0,0,0}, thickness = 0.5)}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         when sample(startTime, period) then
//                   T0 = time;
//         
//         end when;
//         y = offset + (if time < startTime then 0 else amplitude / period * (time - T0));
//       end SawTooth;
//       block Trapezoid "Generate trapezoidal signal of type Real"
//         parameter Real amplitude = 1 "Amplitude of trapezoid";
//         parameter SIunits.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//         parameter SIunits.Time width(final min = 0) = 0.5 "Width duration of trapezoid";
//         parameter SIunits.Time falling(final min = 0) = 0 "Falling duration of trapezoid";
//         parameter SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//         parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, extent = {{ -147, -152},{153, -112}}, textString = "period=%period", fontName = "Arial"),Line(visible = true, points = {{ -81, -70},{ -60, -70},{ -30,40},{9,40},{39, -70},{61, -70},{90,40}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -30},{ -47, -41},{ -43, -41},{ -45, -30}}),Line(visible = true, points = {{ -45, -31},{ -45, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -70},{ -47, -60},{ -43, -60},{ -45, -70},{ -45, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -86, -55},{ -43, -43}}, textString = "offset", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -47, -87},{ -1, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -76,79},{ -35,99}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -29,82},{ -30, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,59},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{20,59},{20,39}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(visible = true, points = {{40,59},{40, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -20,76},{61,76}}, color = {192,192,192}),Line(visible = true, points = {{ -29,56},{40,56}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -2,77},{25,86}}, textString = "period", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -8,60},{21,70}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -42,40},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -39,40},{ -39, -19}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -77,0},{ -40,14}}, textString = "amplitude", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,56},{ -22,58},{ -22,54},{ -29,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,56},{ -17,58},{ -17,54},{ -10,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,76},{ -20,78},{ -20,74},{ -29,76}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{61,76},{53,78},{53,74},{61,76}}),Line(visible = true, points = {{ -80, -30},{ -30, -30},{ -10,40},{20,40},{40, -30},{60, -30},{80,40},{100,40}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39,40},{ -41,29},{ -37,29},{ -39,40}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39, -29},{ -41, -19},{ -37, -19},{ -39, -29},{ -39, -29}}),Line(visible = true, points = {{61,84},{60, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{39,56},{32,58},{32,54},{39,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{27,58},{27,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{13,58},{13,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -12,56},{ -5,58},{ -5,54},{ -12,56}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -34,60},{ -5,70}}, textString = "rising", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{16,60},{45,70}}, textString = "falling", fontName = "Arial")}));
//       protected 
//         parameter SIunits.Time T_rising = rising "End time of rising phase within one period";
//         parameter SIunits.Time T_width = T_rising + width "End time of width phase within one period";
//         parameter SIunits.Time T_falling = T_width + falling "End time of falling phase within one period";
//         SIunits.Time T0(final start = startTime) "Start time of current period";
//         Integer counter(start = nperiod) "Period counter";
//         Integer counter2(start = nperiod);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -147, -152},{153, -112}}, textString = "period=%period", fillColor = {0,0,0}),Line(points = {{ -81, -70},{ -60, -70},{ -30,40},{9,40},{39, -70},{61, -70},{90,40}}, color = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -45, -30},{ -47, -41},{ -43, -41},{ -45, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -45, -31},{ -45, -70}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Polygon(points = {{ -45, -70},{ -47, -60},{ -43, -60},{ -45, -70},{ -45, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -86, -43},{ -43, -55}}, textString = "offset", fillColor = {160,160,160}),Text(extent = {{ -47, -69},{ -1, -87}}, textString = "startTime", fillColor = {160,160,160}),Text(extent = {{ -76,99},{ -35,79}}, textString = "y", fillColor = {160,160,160}),Text(extent = {{70, -80},{94, -100}}, textString = "time", fillColor = {160,160,160}),Line(points = {{ -29,82},{ -30, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -10,59},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{20,59},{20,39}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(points = {{40,59},{40, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -20,76},{61,76}}, color = {192,192,192}),Line(points = {{ -29,56},{40,56}}, color = {192,192,192}),Text(extent = {{ -2,86},{25,77}}, textString = "period", fillColor = {160,160,160}),Text(extent = {{ -8,70},{21,60}}, textString = "width", fillColor = {160,160,160}),Line(points = {{ -42,40},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(points = {{ -39,40},{ -39, -19}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Text(extent = {{ -77,14},{ -40,0}}, textString = "amplitude", fillColor = {160,160,160}),Polygon(points = {{ -29,56},{ -22,58},{ -22,54},{ -29,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -10,56},{ -17,58},{ -17,54},{ -10,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -29,76},{ -20,78},{ -20,74},{ -29,76}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{61,76},{53,78},{53,74},{61,76}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -80, -30},{ -30, -30},{ -10,40},{20,40},{40, -30},{60, -30},{80,40},{100,40}}, color = {0,0,0}, thickness = 0.5),Polygon(points = {{ -39,40},{ -41,29},{ -37,29},{ -39,40}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -39, -29},{ -41, -19},{ -37, -19},{ -39, -29},{ -39, -29}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{61,84},{60, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(points = {{39,56},{32,58},{32,54},{39,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{20,56},{27,58},{27,54},{20,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{20,56},{13,58},{13,54},{20,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -12,56},{ -5,58},{ -5,54},{ -12,56}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Text(extent = {{ -34,70},{ -5,60}}, textString = "rising", fillColor = {160,160,160}),Text(extent = {{16,70},{45,60}}, textString = "falling", fillColor = {160,160,160})}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         when pre(counter2) <> 0 and sample(startTime, period) then
//                   T0 = time;
//           counter2 = pre(counter);
//           counter = pre(counter) - (if pre(counter) > 0 then 1 else 0);
//         
//         end when;
//         y = offset + (if time < startTime or counter2 == 0 or time >= T0 + T_falling then 0 else if time < T0 + T_rising then ((time - T0) * amplitude) / T_rising else if time < T0 + T_width then amplitude else ((T0 + T_falling - time) * amplitude) / (T_falling - T_width));
//       end Trapezoid;
//       block KinematicPTP "Move as fast as possible along a distance within given kinematic constraints"
//         parameter Real deltaq[:] = {1} "Distance to move";
//         parameter Real qd_max[:](final min = Modelica.Constants.small) = {1} "Maximum velocities der(q)";
//         parameter Real qdd_max[:](final min = Modelica.Constants.small) = {1} "Maximum accelerations der(qd)";
//         parameter SIunits.Time startTime = 0 "Time instant at which movement starts";
//         extends Interfaces.MO(final nout = max([size(deltaq, 1);size(qd_max, 1);size(qdd_max, 1)]));
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,78},{ -80, -82}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}),Line(visible = true, points = {{ -90,0},{82,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,0},{ -70,0},{ -70,70},{ -30,70},{ -30,0},{20,0},{20, -70},{60, -70},{60,0},{68,0}}),Text(visible = true, fillColor = {192,192,192}, extent = {{2,20},{80,80}}, textString = "acc", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "deltaq=%deltaq", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -80,78},{ -80, -82}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}),Line(visible = true, points = {{ -90,0},{82,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,0},{ -70,0},{ -70,70},{ -30,70},{ -30,0},{20,0},{20, -70},{60, -70},{60,0},{68,0}}, thickness = 0.5),Text(visible = true, fillColor = {192,192,192}, extent = {{ -76,83},{ -19,98}}, textString = "acceleration", fontName = "Arial"),Text(visible = true, fillColor = {192,192,192}, extent = {{69,12},{91,24}}, textString = "time", fontName = "Arial")}));
//       protected 
//         parameter Real p_deltaq[nout] = if size(deltaq, 1) == 1 then ones(nout) * deltaq[1] else deltaq;
//         parameter Real p_qd_max[nout] = if size(qd_max, 1) == 1 then ones(nout) * qd_max[1] else qd_max;
//         parameter Real p_qdd_max[nout] = if size(qdd_max, 1) == 1 then ones(nout) * qdd_max[1] else qdd_max;
//         Real sd_max;
//         Real sdd_max;
//         Real sdd;
//         Real aux1[nout];
//         Real aux2[nout];
//         SIunits.Time Ta1;
//         SIunits.Time Ta2;
//         SIunits.Time Tv;
//         SIunits.Time Te;
//         Boolean noWphase;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,78},{ -80, -82}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -90,0},{82,0}}, color = {192,192,192}),Polygon(points = {{90,0},{68,8},{68, -8},{90,0}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -80,0},{ -70,0},{ -70,70},{ -30,70},{ -30,0},{20,0},{20, -70},{60, -70},{60,0},{68,0}}, color = {0,0,0}, thickness = 0.25),Text(extent = {{2,80},{80,20}}, textString = "acc", fillColor = {192,192,192}),Text(extent = {{ -150, -150},{150, -110}}, textString = "deltaq=%deltaq", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100, -100},{100,100}}, lineColor = {0,0,255}, fillColor = {0,0,0}, fillPattern = FillPattern.None),Line(points = {{ -80,78},{ -80, -82}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,88},{ -80,90}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -90,0},{82,0}}, color = {192,192,192}),Polygon(points = {{90,0},{68,8},{68, -8},{90,0}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -80,0},{ -70,0},{ -70,70},{ -30,70},{ -30,0},{20,0},{20, -70},{60, -70},{60,0},{68,0}}, color = {0,0,0}, thickness = 0.5),Text(extent = {{ -76,98},{ -19,83}}, textString = "acceleration", fillColor = {192,192,192}),Text(extent = {{69,24},{91,12}}, textString = "time", fillColor = {192,192,192})}), Documentation(info = "<HTML>
// <p>
// The goal is to move as <b>fast</b> as possible along a distance
// <b>deltaq</b>
// under given <b>kinematical constraints</b>. The distance can be a positional or
// angular range. In robotics such a movement is called <b>PTP</b> (Point-To-Point).
// This source block generates the <b>acceleration</b> qdd of this signal
// as output. After integrating the output two times, the position q is
// obtained. The signal is constructed in such a way that it is not possible
// to move faster, given the <b>maximally</b> allowed <b>velocity</b> qd_max and
// the <b>maximally</b> allowed <b>acceleration</b> qdd_max.
// </p>
// <p>
// If several distances are given (vector deltaq has more than 1 element),
// an acceleration output vector is constructed such that all signals
// are in the same periods in the acceleration, constant velocity
// and deceleration phase. This means that only one of the signals
// is at its limits whereas the others are sychnronized in such a way
// that the end point is reached at the same time instant.
// </p>
// <p>
// This element is useful to generate a reference signal for a controller
// which controls a drive train or in combination with model
// Modelica.Mechanics.Rotational.<b>Accelerate</b> to drive
// a flange according to a given acceleration.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 27, 2001</i>
//        by Bernhard Bachmann.<br>
//        Bug fixed that element is also correct if startTime is not zero.</li>
// <li><i>Nov. 3, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized and moved from Rotational to Blocks.Sources.</li>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// </html>"));
// 
//       equation 
//         for i in 1:nout loop
//         aux1[i] = p_deltaq[i] / p_qd_max[i];
//         aux2[i] = p_deltaq[i] / p_qdd_max[i];
// 
//         end for;
//         sd_max = 1 / max(abs(aux1));
//         sdd_max = 1 / max(abs(aux2));
//         Ta1 = sqrt(1 / sdd_max);
//         Ta2 = sd_max / sdd_max;
//         noWphase = Ta2 >= Ta1;
//         Tv = if noWphase then Ta1 else 1 / sd_max;
//         Te = if noWphase then Ta1 + Ta1 else Tv + Ta2;
//         sdd = if time < startTime then 0 else if noWphase then if time < Ta1 + startTime then sdd_max else if time < Te + startTime then  -sdd_max else 0 else if time < Ta2 + startTime then sdd_max else if time < Tv + startTime then 0 else if time < Te + startTime then  -sdd_max else 0;
//         y = p_deltaq * sdd;
//       end KinematicPTP;
//       block TimeTable "Generate a (possibly discontinuous) signal by linear interpolation in a table"
//         parameter Real table[:,2] = [0,0;1,1;2,4] "Table matrix (time = first column)";
//         parameter Real offset = 0 "Offset of output signal";
//         parameter SIunits.Time startTime = 0 "Output = offset for time < startTime";
//         extends Interfaces.SO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -48, -50},{2,70}}),Line(visible = true, points = {{ -48, -50},{ -48,70},{52,70},{52, -50},{ -48, -50},{ -48, -20},{52, -20},{52,10},{ -48,10},{ -48,40},{52,40},{52,70},{2,70},{2, -51}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "offset=%offset", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -30},{30,90}}),Line(visible = true, points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{30,90},{30, -31}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -77, -58},{ -38, -42}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}),Line(visible = true, points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, fillColor = {160,160,160}, extent = {{ -38, -88},{8, -70}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, fillColor = {160,160,160}, extent = {{ -73,78},{ -41,93}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{66, -93},{91, -81}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -15,68},{24,83}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{33,67},{76,83}}, textString = "y", fontName = "Arial")}));
//       protected 
//         Real a "Interpolation coefficients a of actual interval (y=a*x+b)";
//         Real b "Interpolation coefficients b of actual interval (y=a*x+b)";
//         Integer last(start = 1) "Last used lower grid index";
//         SIunits.Time nextEvent(start = 0) "Next event instant";
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -48,70},{2, -50}}, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -48, -50},{ -48,70},{52,70},{52, -50},{ -48, -50},{ -48, -20},{52, -20},{52,10},{ -48,10},{ -48,40},{52,40},{52,70},{2,70},{2, -51}}, color = {0,0,0}),Text(extent = {{ -150, -150},{150, -110}}, textString = "offset=%offset", fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -20,90},{30, -30}}, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{30,90},{30, -31}}, color = {0,0,0}),Text(extent = {{ -77, -42},{ -38, -58}}, textString = "offset", fillColor = {160,160,160}),Polygon(points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(extent = {{ -38, -70},{8, -88}}, textString = "startTime", fillColor = {160,160,160}),Line(points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(extent = {{ -73,93},{ -41,78}}, textString = "y", fillColor = {160,160,160}),Text(extent = {{66, -81},{91, -93}}, textString = "time", fillColor = {160,160,160}),Text(extent = {{ -15,83},{24,68}}, textString = "time", fillColor = {0,0,0}),Text(extent = {{33,83},{76,67}}, textString = "y", fillColor = {0,0,0})}), Documentation(info = "<HTML>
// <p>
// This block generates an output signal by <b>linear interpolation</b> in
// a table. The time points and function values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the data to be interpolated.
// The table interpolation has the following proporties:
// </p>
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the function value is just returned independantly of the
//     actual time instant.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the ordinate value.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// <p>
// Example:
// </p>
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the output y =  2.5,
//     e.g., time = 2.0, the output y =  4.0,
//     e.g., time = 5.0, the output y = 23.0 (i.e. extrapolation).
// </pre>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Corrected interface from
// <pre>
//     parameter Real table[:, :]=[0, 0; 1, 1; 2, 4];
// </pre>
//        to
// <pre>
//     parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4];
// </pre>
//        </li>
// <li><i>Nov. 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// </html>"));
//         function getInterpolationCoefficients "Determine interpolation coefficients and next time event"
//           input Real table[:,2] "Table for interpolation";
//           input Real offset "y-offset";
//           input Real startTime "time-offset";
//           input Real t "Actual time instant";
//           input Integer last "Last used lower grid index";
//           input Real TimeEps "Relative epsilon to check for identical time instants";
//           output Real a "Interpolation coefficients a (y=a*x + b)";
//           output Real b "Interpolation coefficients b (y=a*x + b)";
//           output Real nextEvent "Next event instant";
//           output Integer next "New lower grid index";
//         protected 
//           Integer columns = 2 "Column to be interpolated";
//           Integer ncol = 2 "Number of columns to be interpolated";
//           Integer nrow = size(table, 1) "Number of table rows";
//           Integer next0;
//           Real tp;
//           Real dt;
//         algorithm 
//           next:=last;
//           nextEvent:=t - TimeEps * abs(t);
//           tp:=t + TimeEps * abs(t) - startTime;
//           if tp < 0.0 then 
//                     nextEvent:=startTime;
//           a:=0;
//           b:=offset;
//           elseif nrow < 2 then
//             a:=0;
//             b:=offset + table[1,columns];
// 
// 
//           else           while (next < nrow and tp >= table[next,1]) loop
//                       next:=next + 1;
// 
//           end while;
//           if next < nrow then 
//                     nextEvent:=startTime + table[next,1];
// 
//           else 
//           end if;
//           next0:=next - 1;
//           dt:=table[next,1] - table[next0,1];
//           if dt <= TimeEps * abs(table[next,1]) then 
//                     a:=0;
//           b:=offset + table[next,columns];
// 
//           else           a:=(table[next,columns] - table[next0,columns]) / dt;
//           b:=offset + table[next0,columns] - a * table[next0,1];
// 
//           end if;
// 
//           end if;
//           b:=b - a * startTime;
//         end getInterpolationCoefficients;
//       algorithm 
//         when {time >= pre(nextEvent),initial()} then
//                   (a,b,nextEvent,last):=getInterpolationCoefficients(table, offset, startTime, time, last, 100 * Modelica.Constants.eps);
//         
//         end when;
// 
//       equation 
//         y = a * time + b;
//       end TimeTable;
//       model CombiTimeTable "Table look-up with respect to time and linear/perodic extrapolation methods (data from matrix/file)"
//         parameter Boolean tableOnFile = false "true, if table is defined on file or in function usertab" annotation(Dialog(group = "table data definition"));
//         parameter Real table[:,:] = fill(0.0, 0, 2) "table matrix (time = first column)" annotation(Dialog(group = "table data definition", enable = not tableOnFile));
//         parameter String tableName = "NoName" "table name on file or in function usertab (see docu)" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter String fileName = "NoName" "file where matrix is stored" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter Integer columns[:] = 2:size(table, 2) "columns of table to be interpolated" annotation(Dialog(group = "table data interpretation"));
//         parameter Blocks.Types.Smoothness.Temp smoothness = Blocks.Types.Smoothness.LinearSegments "smoothness of table interpolation" annotation(Dialog(group = "table data interpretation"));
//         parameter Blocks.Types.Extrapolation.Temp extrapolation = Blocks.Types.Extrapolation.LastTwoPoints "extrapolation of data outside the definition range" annotation(Dialog(group = "table data interpretation"));
//         parameter Real offset[:] = {0} "Offsets of output signals" annotation(Dialog(group = "table data interpretation"));
//         parameter SI.Time startTime = 0 "Output = offset for time < startTime" annotation(Dialog(group = "table data interpretation"));
//         extends Modelica.Blocks.Interfaces.MO(final nout = max([size(columns, 1);size(offset, 1)]));
//         final parameter Real t_min(fixed = false);
//         final parameter Real t_max(fixed = false);
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -30},{20,90}}),Line(visible = true, points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{20,90},{20, -30}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -77, -58},{ -38, -42}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}),Line(visible = true, points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -20, -30},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, fillColor = {160,160,160}, extent = {{ -38, -88},{8, -70}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, fillColor = {160,160,160}, extent = {{ -73,78},{ -41,93}}, textString = "y", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{66, -93},{91, -81}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{ -19,68},{20,83}}, textString = "time", fontName = "Arial"),Text(visible = true, extent = {{21,68},{50,82}}, textString = "y[1]", fontName = "Arial"),Line(visible = true, points = {{50,90},{50, -30}}),Line(visible = true, points = {{80,0},{100,0}}),Text(visible = true, extent = {{34, -42},{71, -30}}, textString = "columns", fontName = "Arial"),Text(visible = true, extent = {{51,68},{80,82}}, textString = "y[2]", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -48, -50},{2,70}}),Line(visible = true, points = {{ -48, -50},{ -48,70},{52,70},{52, -50},{ -48, -50},{ -48, -20},{52, -20},{52,10},{ -48,10},{ -48,40},{52,40},{52,70},{2,70},{2, -51}})}));
//       protected 
//         final parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         Integer tableID;
//         function tableTimeInit
//           input Real timeIn;
//           input Real startTime;
//           input Integer ipoType;
//           input Integer expoType;
//           input String tableName;
//           input String fileName;
//           input Real table[:,:];
//           input Integer colWise;
//           output Integer tableID;
// 
//           external "C" tableID = omcTableTimeIni(timeIn,startTime,ipoType,expoType,tableName,fileName,table,size(table, 1),size(table, 2),colWise) ;
//         end tableTimeInit;
//         function tableTimeIpo
//           input Integer tableID;
//           input Integer icol;
//           input Real timeIn;
//           output Real value;
// 
//           external "C" value = omcTableTimeIpo(tableID,icol,timeIn) ;
//         end tableTimeIpo;
//         function tableTimeTmin
//           input Integer tableID;
//           output Real Tmin "minimum time value in table";
// 
//           external "C" Tmin = omcTableTimeTmin(tableID) ;
//         end tableTimeTmin;
//         function tableTimeTmax
//           input Integer tableID;
//           output Real Tmax "maximum time value in table";
// 
//           external "C" Tmax = omcTableTimeTmax(tableID) ;
//         end tableTimeTmax;
//         annotation(Documentation(info = "<HTML>
// <p>
// This block generates an output signal y[:] by <b>linear interpolation</b> in
// a table. The time points and function values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the other columns contain the data to be interpolated.
// Via parameter <b>columns</b> it can be defined which columns of the
// table are interpolated. If, e.g., columns={2,4}, it is assumed that
// 2 output signals are present and that the first output is computed
// by interpolation of column 2 and the second output is computed
// by interpolation of column 4 of the table matrix.
// The table interpolation has the following properties:
// </p>
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     extrapolation according to the setting of parameter
//     <b>extrapolation</b>:
// <pre>
//   extrapolation = 0: hold the first or last value of the table,
//                      if outside of the range.
//                 = 1: extrapolate through the last or first two
//                      points of the table.
//                 = 2: periodically repeat the table data
//                      (periodical function).
// </pre></li>
// <li>Via parameter <b>smoothness</b> it is defined how the data is interpolated:
// <pre>
//   smoothness = 0: linear interpolation
//              = 1: smooth interpolation with Akima Splines such
//                   that der(y) is continuous.
// </pre></li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the table values of this row are just returned.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the ordinate value.
//     The time instants stored in the table are therefore <b>relative</b>
//     to <b>startTime</b>.
//     If time &lt; startTime, no interpolation is performed and the offset
//     is used as ordinate value for all outputs.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// <li>For special applications it is sometimes needed to know the minimum
//     and maximum time instant defined in the table as a parameter. For this
//     reason parameters <b>t_min</b> and <b>t_max</b> are provided and can be access from
//     the outside of the table object.
// </li>
// </ul>
// <p>
// Example:
// </p>
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]; extrapolation = 1 (default)
// If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the output y =  2.5,
//     e.g., time = 2.0, the output y =  4.0,
//     e.g., time = 5.0, the output y = 23.0 (i.e. extrapolation via last 2 points).
// </pre>
// <p>
// The table matrix can be defined in the following ways:
// </p>
// <ol>
// <li> Explicitly supplied as <b>parameter matrix</b> \"table\",
//      and the other parameters have the following values:
// <pre>
//    tableName is \"NoName\" or has only blanks,
//    fileName  is \"NoName\" or has only blanks.
// </pre></li>
// <li> <b>Read</b> from a <b>file</b> \"fileName\" where the matrix is stored as
//       \"tableName\". Both ASCII and binary file format is possible.
//       (the ASCII format is described below).
//       It is most convenient to generate the binary file from Matlab
//       (Matlab 4 storage format), e.g., by command
// <pre>
//    save tables.mat tab1 tab2 tab3 -V4
// </pre>
//       when the three tables tab1, tab2, tab3 should be
//       used from the model.</li>
// <li>  Statically stored in function \"usertab\" in file \"usertab.c\".
//       The matrix is identified by \"tableName\". Parameter
//       fileName = \"NoName\" or has only blanks.</li>
// </ol>
// <p>
// Table definition methods (1) and (3) do <b>not</b> allocate dynamic memory,
// and do not access files, whereas method (2) does. Therefore (1) and (3)
// are suited for hardware-in-the-loop simulation (e.g. with dSpace hardware).
// When the constant \"NO_FILE\" is defined in \"usertab.c\", all parts of the
// source code of method (2) are removed by the C-preprocessor, such that
// no dynamic memory allocation and no access to files takes place.
// </p>
// <p>
// If tables are read from an ASCII-file, the file need to have the
// following structure (\"-----\" is not part of the file content):
// </p>
// <pre>
// -----------------------------------------------------
// #1
// double tab1(6,2)   # comment line
//   0   0
//   1   0
//   1   1
//   2   4
//   3   9
//   4  16
// double tab2(6,2)   # another comment line
//   0   0
//   2   0
//   2   2
//   4   8
//   6  18
//   8  32
// -----------------------------------------------------
// </pre>
// <p>
// Note, that the first two characters in the file need to be
// \"#1\". Afterwards, the corresponding matrix has to be declared
// with type, name and actual dimensions. Finally, in successive
// rows of the file, the elements of the matrix have to be given.
// Several matrices may be defined one after another.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>March 31, 2001</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Used CombiTableTime as a basis and added the
//        arguments <b>extrapolation, columns, startTime</b>.
//        This allows periodic function definitions. </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -48,70},{2, -50}}, lineColor = {255,255,255}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Line(points = {{ -48, -50},{ -48,70},{52,70},{52, -50},{ -48, -50},{ -48, -20},{52, -20},{52,10},{ -48,10},{ -48,40},{52,40},{52,70},{2,70},{2, -51}}, color = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Line(points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(points = {{90, -70},{68, -62},{68, -78},{90, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -20,90},{20, -30}}, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{20,90},{20, -30}}, color = {0,0,0}),Text(extent = {{ -77, -42},{ -38, -58}}, textString = "offset", fillColor = {160,160,160}),Polygon(points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Polygon(points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid),Line(points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -20, -30},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(extent = {{ -38, -70},{8, -88}}, textString = "startTime", fillColor = {160,160,160}),Line(points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(extent = {{ -73,93},{ -41,78}}, fillColor = {160,160,160}, textString = "y"),Text(extent = {{66, -81},{91, -93}}, textString = "time", fillColor = {160,160,160}),Text(extent = {{ -19,83},{20,68}}, textString = "time", fillColor = {0,0,0}),Text(extent = {{21,82},{50,68}}, fillColor = {0,0,0}, textString = "y[1]"),Line(points = {{50,90},{50, -30}}, color = {0,0,0}),Line(points = {{80,0},{100,0}}),Text(extent = {{34, -30},{71, -42}}, textString = "columns"),Text(extent = {{51,82},{80,68}}, fillColor = {0,0,0}, textString = "y[2]")}));
// 
//       equation 
// if tableOnFile then
//                   assert(tableName <> "NoName", "tableOnFile = true and no table name given");
//         end if;
// if not tableOnFile then
//                   assert(size(table, 1) > 0 and size(table, 2) > 0, "tableOnFile = false and parameter table is an empty matrix");
//         end if;
//         for i in 1:nout loop
//         y[i] = p_offset[i] + tableTimeIpo(tableID, columns[i], time);
// 
//         end for;
//         when initial() then
//                   tableID = tableTimeInit(0.0, startTime, smoothness, extrapolation, if not tableOnFile then "NoName" else tableName, if not tableOnFile then "NoName" else fileName, table, 0);
//         
//         end when;
// 
//       initial equation 
//         t_min = tableTimeTmin(tableID);
//         t_max = tableTimeTmax(tableID);
//       end CombiTimeTable;
//       block BooleanConstant "Generate constant signal of type Boolean"
//         parameter Boolean k = true "Constant output value";
//         extends Interfaces.partialBooleanSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}),Text(visible = true, extent = {{ -150, -140},{150, -110}}, textString = "%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, thickness = 0.5),Text(visible = true, fillColor = {160,160,160}, extent = {{ -83,0},{ -63,20}}, textString = "k", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -100, -6},{ -80,6}}, textString = "true", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -104, -70},{ -78, -58}}, textString = "false", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = k;
//       end BooleanConstant;
//       block BooleanStep "Generate step signal of type Boolean"
//         parameter Modelica.SIunits.Time startTime = 0 "Time instant of step start";
//         parameter Boolean startValue = false "Output before startTime";
//         extends Interfaces.partialBooleanSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -70},{0, -70},{0,50},{80,50}}),Text(visible = true, extent = {{ -150, -140},{150, -110}}, textString = "%startTime", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -70},{0, -70},{0,50},{80,50}}, thickness = 0.5),Text(visible = true, extent = {{ -25, -94},{21, -76}}, textString = "startTime", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, pattern = LinePattern.Dash, points = {{2,50},{ -80,50},{2,50}}),Text(visible = true, extent = {{ -130,42},{ -86,56}}, textString = "not startValue", fontName = "Arial"),Text(visible = true, extent = {{ -126, -78},{ -94, -64}}, textString = "startValue", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = if time >= startTime then not startValue else startValue;
//       end BooleanStep;
//       block BooleanPulse "Generate pulse signal of type Boolean"
//         parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of period";
//         parameter Modelica.SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//         parameter Modelica.SIunits.Time startTime = 0 "Time instant of first pulse";
//         extends Modelica.Blocks.Interfaces.partialBooleanSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -150, -140},{150, -110}}, textString = "%period", fontName = "Arial"),Line(visible = true, points = {{ -80, -70},{ -40, -70},{ -40,44},{0,44},{0, -70},{40, -70},{40,44},{79,44}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -60, -90},{ -14, -72}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -78, -70},{ -40, -70},{ -40,20},{20,20},{20, -70},{50, -70},{50,20},{100,20}}, thickness = 0.5),Line(visible = true, points = {{ -40,61},{ -40,21}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{20,44},{20,20}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(visible = true, points = {{50,58},{50,20}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -40,53},{50,53}}, color = {192,192,192}),Line(visible = true, points = {{ -40,35},{20,35}}, color = {192,192,192}),Text(visible = true, extent = {{ -30,55},{16,67}}, textString = "period", fontName = "Arial"),Text(visible = true, extent = {{ -35,37},{14,49}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -80,20},{ -41,20}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40,35},{ -31,37},{ -31,33},{ -40,35}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,35},{12,37},{12,33},{20,35}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40,53},{ -31,55},{ -31,51},{ -40,53}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50,53},{42,55},{42,51},{50,53}}),Text(visible = true, extent = {{ -109,14},{ -77,28}}, textString = "true", fontName = "Arial"),Text(visible = true, extent = {{ -101, -71},{ -80, -56}}, textString = "false", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
//       protected 
//         parameter Modelica.SIunits.Time Twidth = (period * width) / 100 "width of one pulse" annotation(Hide = true);
//         discrete Modelica.SIunits.Time pulsStart "Start time of pulse" annotation(Hide = true);
// 
//       initial equation 
//         pulsStart = startTime;
// 
//       equation 
//         when sample(startTime, period) then
//                   pulsStart = time;
//         
//         end when;
//         y = time >= pulsStart and time < pulsStart + Twidth;
//       end BooleanPulse;
//       block SampleTrigger "Generate sample trigger signal"
//         parameter Modelica.SIunits.Time period(final min = Modelica.Constants.small) = 0.01 "Sample period";
//         parameter Modelica.SIunits.Time startTime = 0 "Time instant of first sample trigger";
//         extends Interfaces.partialBooleanSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60, -70},{ -60,70}}),Line(visible = true, points = {{ -20, -70},{ -20,70}}),Line(visible = true, points = {{20, -70},{20,70}}),Line(visible = true, points = {{60, -70},{60,70}}),Text(visible = true, extent = {{ -150, -140},{150, -110}}, textString = "%period", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -53, -89},{ -7, -71}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -30,47},{ -30,19}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{0,47},{0,18}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -30,41},{0,41}}, color = {192,192,192}),Text(visible = true, extent = {{ -37,49},{9,61}}, textString = "period", fontName = "Arial"),Line(visible = true, points = {{ -80,19},{ -30,19}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -30,41},{ -21,43},{ -21,39},{ -30,41}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,41},{ -8,43},{ -8,39},{0,41}}),Text(visible = true, extent = {{ -100,13},{ -80,28}}, textString = "true", fontName = "Arial"),Text(visible = true, extent = {{ -100, -71},{ -80, -56}}, textString = "false", fontName = "Arial"),Line(visible = true, points = {{0, -70},{0,19}}, thickness = 0.5),Line(visible = true, points = {{ -30, -70},{ -30,19}}, thickness = 0.5),Line(visible = true, points = {{30, -70},{30,19}}, thickness = 0.5),Line(visible = true, points = {{60, -70},{60,19}}, thickness = 0.5)}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = sample(startTime, period);
//       end SampleTrigger;
//       block BooleanTable "Generate a Boolean output signal based on a vector of time instants"
//         parameter Boolean startValue = false "Start value of y. At time = table[1], y changes to 'not startValue'";
//         parameter Modelica.SIunits.Time table[:] "Vector of time points. At every time point, the output y gets its opposite value";
//         extends Interfaces.partialBooleanSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -18, -50},{32,70}}),Line(visible = true, points = {{ -18, -50},{ -18,70},{32,70},{32, -50},{ -18, -50},{ -18, -20},{32, -20},{32,10},{ -18,10},{ -18,40},{32,40},{32,70},{32,70},{32, -51}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -34, -54},{16,66}}),Line(visible = true, points = {{ -34, -54},{ -34,66},{16,66},{16, -54},{ -34, -54},{ -34, -24},{16, -24},{16,6},{ -34,6},{ -34,36},{16,36},{16,66},{16,66},{16, -55}}),Text(visible = true, extent = {{ -29,44},{10,59}}, textString = "time", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
//       protected 
//         function getFirstIndex "Get first index of table and check table"
//           input Real table[:] "Vector of time instants";
//           input Modelica.SIunits.Time simulationStartTime "Simulation start time";
//           input Boolean startValue "Value of y for y < table[1]";
//           output Integer index "First index to be used";
//           output Modelica.SIunits.Time nextTime "Time instant of first event";
//           output Boolean y "Value of y at simulationStartTime";
//         protected 
//           Modelica.SIunits.Time t_last;
//           Integer j;
//           Integer n = size(table, 1) "Number of table points";
//         algorithm 
//           if size(table, 1) == 0 then 
//                     index:=0;
//           nextTime:= -Modelica.Constants.inf;
//           y:=startValue;
//           elseif size(table, 1) == 1 then
//             index:=1;
//             if table[1] > simulationStartTime then 
//                         nextTime:=table[1];
//             y:=startValue;
// 
//             else             nextTime:=simulationStartTime;
//             y:=startValue;
// 
//             end if;
// 
// 
//           else           t_last:=table[1];
//           for i in 2:n loop
//                       assert(table[i] > t_last, "Time values of table not strict monotonically increasing: table[" + String(i - 1) + "] = " + String(table[i - 1]) + "table[" + String(i) + "] = " + String(table[i]));
// 
//           end for;
//           j:=1;
//           y:=startValue;
//           while (j < n and table[j] <= simulationStartTime) loop
//                       y:=not y;
//             j:=j + 1;
// 
//           end while;
//           if j == 1 then 
//                     nextTime:=table[1];
//           y:=startValue;
//           elseif j == n and table[n] <= simulationStartTime then
//             nextTime:=simulationStartTime - 1;
//             y:=not y;
// 
// 
//           else           nextTime:=table[j];
// 
//           end if;
//           index:=j;
// 
//           end if;
//         end getFirstIndex;
//         parameter Integer n = size(table, 1) "Number of table points";
//         Modelica.SIunits.Time nextTime;
//         Integer index "Index of actual table entry";
//       initial algorithm 
//         (index,nextTime,y):=getFirstIndex(table, time, startValue);
//       algorithm 
//         when time >= pre(nextTime) and n > 0 then
//                   if index < n then 
//                     index:=index + 1;
//           nextTime:=table[index];
//           y:=not y;
//           elseif index == n then
//             index:=index + 1;
//             y:=not y;
// 
// 
//           else 
//           end if;
//         
//         end when;
//       end BooleanTable;
//       block IntegerConstant "Generate constant signal of type Integer"
//         parameter Integer k = 1 "Constant output value";
//         extends Interfaces.IntegerSO;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80,0},{80,0}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "k=%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80,0},{80,0}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -75,76},{ -22,94}}, textString = "outPort", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -101, -12},{ -81,8}}, textString = "k", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = k;
//       end IntegerConstant;
//       block IntegerStep "Generate step signal of type Integer"
//         parameter Integer height = 1 "Height of step";
//         extends Interfaces.IntegerSignalSource;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -70},{0, -70},{0,50},{80,50}}),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "startTime=%startTime", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -18},{0, -18},{0,50},{80,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -21, -90},{25, -72}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{0, -17},{0, -71}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, fillColor = {160,160,160}, extent = {{ -68, -54},{ -22, -36}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -13,50},{ -13, -17}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, pattern = LinePattern.Dash, points = {{2,50},{ -19,50},{2,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -17},{ -16, -4},{ -10, -4},{ -13, -17},{ -13, -17}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13,50},{ -16,37},{ -9,37},{ -13,50}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -68,8},{ -22,26}}, textString = "height", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -69},{ -16, -56},{ -10, -56},{ -13, -69},{ -13, -69}}),Line(visible = true, points = {{ -13, -18},{ -13, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -18},{ -16, -31},{ -9, -31},{ -13, -18}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -72,80},{ -31,100}}, textString = "outPort", fontName = "Arial")}), Documentation(info = "<html>
// 
// </html>"));
// 
//       equation 
//         y = offset + (if time < startTime then 0 else height);
//       end IntegerStep;
//     end Sources;
//     package Tables "One and two-dimensional interpolation in tables"
//       extends Icons.Library;
//       model CombiTable1D "Table look-up in one dimension (matrix/file) with n inputs and n outputs "
//         import Modelica.Blocks.Types;
//         parameter Boolean tableOnFile = false "true, if table is defined on file or in function usertab" annotation(Dialog(group = "table data definition"));
//         parameter Real table[:,:] = fill(0.0, 0, 2) "table matrix (grid = first column)" annotation(Dialog(group = "table data definition", enable = not tableOnFile));
//         parameter String tableName = "NoName" "table name on file or in function usertab (see docu)" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter String fileName = "NoName" "file where matrix is stored" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter Integer columns[:] = 2:size(table, 2) "columns of table to be interpolated" annotation(Dialog(group = "table data interpretation"));
//         parameter Blocks.Types.Smoothness.Temp smoothness = Types.Smoothness.LinearSegments "smoothness of table interpolation" annotation(Dialog(group = "table data interpretation"));
//         extends Modelica.Blocks.Interfaces.MIMOs(final n = size(columns, 1));
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60,40},{ -60, -40},{60, -40},{60,40},{30,40},{30, -40},{ -30, -40},{ -30,40},{ -60,40},{ -60,20},{60,20},{60,0},{ -60,0},{ -60, -20},{60, -20},{60, -40},{ -60, -40},{ -60,40},{60,40},{60, -40}}),Line(visible = true, points = {{0,40},{0, -40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60,20},{ -30,40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60,0},{ -30,20}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60, -20},{ -30,0}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60, -40},{ -30, -20}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -100,0},{ -58,0}}),Line(visible = true, points = {{60,0},{100,0}}),Text(visible = true, extent = {{ -100,64},{100,100}}, textString = "1 dimensional linear table interpolation", fontName = "Arial"),Line(visible = true, points = {{ -54,40},{ -54, -40},{54, -40},{54,40},{28,40},{28, -40},{ -28, -40},{ -28,40},{ -54,40},{ -54,20},{54,20},{54,0},{ -54,0},{ -54, -20},{54, -20},{54, -40},{ -54, -40},{ -54,40},{54,40},{54, -40}}),Line(visible = true, points = {{0,40},{0, -40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54,20},{ -28,40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54,0},{ -28,20}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54, -20},{ -28,0}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54, -40},{ -28, -20}}),Text(visible = true, extent = {{ -50,42},{ -32,54}}, textString = "u[1]/[2]", fontName = "Arial"),Text(visible = true, extent = {{ -24,42},{0,54}}, textString = "y[1]", fontName = "Arial"),Text(visible = true, extent = {{ -2, -54},{30, -40}}, textString = "columns", fontName = "Arial"),Text(visible = true, extent = {{2,42},{26,54}}, textString = "y[2]", fontName = "Arial")}));
//       protected 
//         Integer tableID;
//         annotation(Documentation(info = "<html>
// <p>
// <b>Linear interpolation</b> in <b>one</b> dimension of a <b>table</b>.
// Via parameter <b>columns</b> it can be defined how many columns of the
// table are interpolated. If, e.g., columns={2,4}, it is assumed that 2 input
// and 2 output signals are present and that the first output interpolates
// the first input via column 2 and the second output interpolates the
// second input via column 4 of the table matrix.
// </p>
// <p>
// The grid points and function values are stored in a matrix \"table[i,j]\",
// where the first column \"table[:,1]\" contains the grid points and the
// other columns contain the data to be interpolated. Example:
// </p>
// <pre>
//    table = [0,  0;
//             1,  1;
//             2,  4;
//             4, 16]
//    If, e.g., the input u = 1.0, the output y =  1.0,
//        e.g., the input u = 1.5, the output y =  2.5,
//        e.g., the input u = 2.0, the output y =  4.0,
//        e.g., the input u =-1.0, the output y = -1.0 (i.e. extrapolation).
// </pre>
// <ul>
// <li> The interpolation is <b>efficient</b>, because a search for a new interpolation
//      starts at the interval used in the last call.</li>
// <li> If the table has only <b>one row</b>, the table value is returned,
//      independent of the value of the input signal.</li>
// <li> If the input signal <b>u[i]</b> is <b>outside</b> of the defined <b>interval</b>, i.e.,
//      u[i] &gt; table[size(table,1),i+1] or u[i] &lt; table[1,1], the corresponding
//      value is also determined by linear
//      interpolation through the last or first two points of the table.</li>
// <li> The grid values (first column) have to be <b>strict</b>
//      monotonically increasing.</li>
// </ul>
// <p>
// The table matrix can be defined in the following ways:
// </p>
// <ol>
// <li> Explicitly supplied as <b>parameter matrix</b> \"table\",
//      and the other parameters have the following values:
// <pre>
//    tableName is \"NoName\" or has only blanks,
//    fileName  is \"NoName\" or has only blanks.
// </pre></li>
// <li> <b>Read</b> from a <b>file</b> \"fileName\" where the matrix is stored as
//       \"tableName\". Both ASCII and binary file format is possible.
//       (the ASCII format is described below).
//       It is most convenient to generate the binary file from Matlab
//       (Matlab 4 storage format), e.g., by command
// <pre>
//    save tables.mat tab1 tab2 tab3 -V4
// </pre>
//       when the three tables tab1, tab2, tab3 should be
//       used from the model.</li>
// <li>  Statically stored in function \"usertab\" in file \"usertab.c\".
//       The matrix is identified by \"tableName\". Parameter
//       fileName = \"NoName\" or has only blanks.</li>
// </ol>
// <p>
// Table definition methods (1) and (3) do <b>not</b> allocate dynamic memory,
// and do not access files, whereas method (2) does. Therefore (1) and (3)
// are suited for hardware-in-the-loop simulation (e.g. with dSpace hardware).
// When the constant \"NO_FILE\" is defined in \"usertab.c\", all parts of the
// source code of method (2) are removed by the C-preprocessor, such that
// no dynamic memory allocation and no access to files takes place.
// </p>
// <p>
// If tables are read from an ASCII-file, the file need to have the
// following structure (\"-----\" is not part of the file content):
// </p>
// <pre>
// -----------------------------------------------------
// #1
// double tab1(5,2)   # comment line
//   0   0
//   1   1
//   2   4
//   3   9
//   4  16
// double tab2(5,2)   # another comment line
//   0   0
//   2   2
//   4   8
//   6  18
//   8  32
// -----------------------------------------------------
// </pre>
// <p>
// Note, that the first two characters in the file need to be
// \"#1\". Afterwards, the corresponding matrix has to be declared
// with type, name and actual dimensions. Finally, in successive
// rows of the file, the elements of the matrix have to be given.
// Several matrices may be defined one after another.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -60,40},{ -60, -40},{60, -40},{60,40},{30,40},{30, -40},{ -30, -40},{ -30,40},{ -60,40},{ -60,20},{60,20},{60,0},{ -60,0},{ -60, -20},{60, -20},{60, -40},{ -60, -40},{ -60,40},{60,40},{60, -40}}, color = {0,0,0}),Line(points = {{0,40},{0, -40}}, color = {0,0,0}),Rectangle(extent = {{ -60,40},{ -30,20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60,20},{ -30,0}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60,0},{ -30, -20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60, -20},{ -30, -40}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -60,60},{60, -60}}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid),Line(points = {{ -100,0},{ -58,0}}),Line(points = {{60,0},{100,0}}),Text(extent = {{ -100,100},{100,64}}, textString = "1 dimensional linear table interpolation"),Line(points = {{ -54,40},{ -54, -40},{54, -40},{54,40},{28,40},{28, -40},{ -28, -40},{ -28,40},{ -54,40},{ -54,20},{54,20},{54,0},{ -54,0},{ -54, -20},{54, -20},{54, -40},{ -54, -40},{ -54,40},{54,40},{54, -40}}, color = {0,0,0}),Line(points = {{0,40},{0, -40}}, color = {0,0,0}),Rectangle(extent = {{ -54,40},{ -28,20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54,20},{ -28,0}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54,0},{ -28, -20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54, -20},{ -28, -40}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Text(extent = {{ -50,54},{ -32,42}}, textString = "u[1]/[2]"),Text(extent = {{ -24,54},{0,42}}, textString = "y[1]"),Text(extent = {{ -2, -40},{30, -54}}, textString = "columns"),Text(extent = {{2,54},{26,42}}, textString = "y[2]")}));
// 
//       equation 
// if tableOnFile then
//                   assert(tableName <> "NoName", "tableOnFile = true and no table name given");
//         end if;
// if not tableOnFile then
//                   assert(size(table, 1) > 0 and size(table, 2) > 0, "tableOnFile = false and parameter table is an empty matrix");
//         end if;
//         for i in 1:n loop
//         y[i] = if not tableOnFile and size(table, 1) == 1 then table[1,columns[i]] else tableTimeIpo(tableID, columns[i], u[i]);
// 
//         end for;
//         when initial() then
//                   tableID = tableTimeInit(1.0, 0.0, smoothness, 0, if tableOnFile then tableName else "NoName", if tableOnFile then fileName else "NoName", table, 0);
//         
//         end when;
//       end CombiTable1D;
//       model CombiTable1Ds "Table look-up in one dimension (matrix/file) with one input and n outputs"
//         import Modelica.Blocks.Types;
//         parameter Boolean tableOnFile = false "true, if table is defined on file or in function usertab" annotation(Dialog(group = "table data definition"));
//         parameter Real table[:,:] = fill(0.0, 0, 2) "table matrix (grid = first column)" annotation(Dialog(group = "table data definition", enable = not tableOnFile));
//         parameter String tableName = "NoName" "table name on file or in function usertab (see docu)" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter String fileName = "NoName" "file where matrix is stored" annotation(Dialog(group = "table data definition", enable = tableOnFile));
//         parameter Integer columns[:] = 2:size(table, 2) "columns of table to be interpolated" annotation(Dialog(group = "table data interpretation"));
//         parameter Blocks.Types.Smoothness.Temp smoothness = Types.Smoothness.LinearSegments "smoothness of table interpolation" annotation(Dialog(group = "table data interpretation"));
//         extends Modelica.Blocks.Interfaces.SIMO(final nout = size(columns, 1));
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -60, -62.17},{60,57.83}}),Line(visible = true, points = {{ -100,0},{ -58,0}}),Line(visible = true, points = {{60,0},{100,0}}),Text(visible = true, extent = {{ -100,64},{100,100}}, textString = "1 dimensional linear table interpolation", fontName = "Arial"),Line(visible = true, points = {{ -54,40},{ -54, -40},{54, -40},{54,40},{28,40},{28, -40},{ -28, -40},{ -28,40},{ -54,40},{ -54,20},{54,20},{54,0},{ -54,0},{ -54, -20},{54, -20},{54, -40},{ -54, -40},{ -54,40},{54,40},{54, -40}}),Line(visible = true, points = {{0,40},{0, -40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54,20},{ -28,40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54,0},{ -28,20}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54.23, -20},{ -28.23,0}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -54, -40},{ -28, -20}}),Text(visible = true, extent = {{ -52,44},{ -34,56}}, textString = "u", fontName = "Arial"),Text(visible = true, extent = {{ -22,42},{2,54}}, textString = "y[1]", fontName = "Arial"),Text(visible = true, extent = {{4,42},{28,54}}, textString = "y[2]", fontName = "Arial"),Text(visible = true, extent = {{0, -54},{32, -40}}, textString = "columns", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60,40},{ -60, -40},{60, -40},{60,40},{30,40},{30, -40},{ -30, -40},{ -30,40},{ -60,40},{ -60,20},{60,20},{60,0},{ -60,0},{ -60, -20},{60, -20},{60, -40},{ -60, -40},{ -60,40},{60,40},{60, -40}}),Line(visible = true, points = {{0,40},{0, -40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60,20},{ -30,40}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60,0},{ -30,20}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60, -20},{ -30,0}}),Rectangle(visible = true, fillColor = {255,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60, -40},{ -30, -20}})}));
//       protected 
//         Integer tableID;
//         annotation(Documentation(info = "<html>
// <p>
// <b>Linear interpolation</b> in <b>one</b> dimension of a <b>table</b>.
// Via parameter <b>columns</b> it can be defined how many columns of the
// table are interpolated. If, e.g., icol={2,4}, it is assumed that one input
// and 2 output signals are present and that the first output interpolates
// via column 2 and the second output interpolates via column 4 of the
// table matrix.
// </p>
// <p>
// The grid points and function values are stored in a matrix \"table[i,j]\",
// where the first column \"table[:,1]\" contains the grid points and the
// other columns contain the data to be interpolated. Example:
// </p>
// <pre>
//    table = [0,  0;
//             1,  1;
//             2,  4;
//             4, 16]
//    If, e.g., the input u = 1.0, the output y =  1.0,
//        e.g., the input u = 1.5, the output y =  2.5,
//        e.g., the input u = 2.0, the output y =  4.0,
//        e.g., the input u =-1.0, the output y = -1.0 (i.e. extrapolation).
// </pre>
// <ul>
// <li> The interpolation is <b>efficient</b>, because a search for a new interpolation
//      starts at the interval used in the last call.</li>
// <li> If the table has only <b>one row</b>, the table value is returned,
//      independent of the value of the input signal.</li>
// <li> If the input signal <b>u</b> is <b>outside</b> of the defined <b>interval</b>, i.e.,
//      u &gt; table[size(table,1),1] or u &lt; table[1,1], the corresponding
//      value is also determined by linear
//      interpolation through the last or first two points of the table.</li>
// <li> The grid values (first column) have to be <b>strict</b>
//      monotonically increasing.</li>
// </ul>
// <p>
// The table matrix can be defined in the following ways:
// </p>
// <ol>
// <li> Explicitly supplied as <b>parameter matrix</b> \"table\",
//      and the other parameters have the following values:
// <pre>
//    tableName is \"NoName\" or has only blanks,
//    fileName  is \"NoName\" or has only blanks.
// </pre></li>
// <li> <b>Read</b> from a <b>file</b> \"fileName\" where the matrix is stored as
//       \"tableName\". Both ASCII and binary file format is possible.
//       (the ASCII format is described below).
//       It is most convenient to generate the binary file from Matlab
//       (Matlab 4 storage format), e.g., by command
// <pre>
//    save tables.mat tab1 tab2 tab3 -V4
// </pre>
//       when the three tables tab1, tab2, tab3 should be
//       used from the model.</li>
// <li>  Statically stored in function \"usertab\" in file \"usertab.c\".
//       The matrix is identified by \"tableName\". Parameter
//       fileName = \"NoName\" or has only blanks.</li>
// </ol>
// <p>
// Table definition methods (1) and (3) do <b>not</b> allocate dynamic memory,
// and do not access files, whereas method (2) does. Therefore (1) and (3)
// are suited for hardware-in-the-loop simulation (e.g. with dSpace hardware).
// When the constant \"NO_FILE\" is defined, all parts of the
// source code of method (2) are removed by the C-preprocessor, such that
// no dynamic memory allocation and no access to files takes place.
// </p>
// <p>
// If tables are read from an ASCII-file, the file need to have the
// following structure (\"-----\" is not part of the file content):
// </p>
// <pre>
// -----------------------------------------------------
// #1
// double tab1(5,2)   # comment line
//   0   0
//   1   1
//   2   4
//   3   9
//   4  16
// double tab2(5,2)   # another comment line
//   0   0
//   2   2
//   4   8
//   6  18
//   8  32
// -----------------------------------------------------
// </pre>
// <p>
// Note, that the first two characters in the file need to be
// \"#1\". Afterwards, the corresponding matrix has to be declared
// with type, name and actual dimensions. Finally, in successive
// rows of the file, the elements of the matrix have to be given.
// Several matrices may be defined one after another.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -60,40},{ -60, -40},{60, -40},{60,40},{30,40},{30, -40},{ -30, -40},{ -30,40},{ -60,40},{ -60,20},{60,20},{60,0},{ -60,0},{ -60, -20},{60, -20},{60, -40},{ -60, -40},{ -60,40},{60,40},{60, -40}}, color = {0,0,0}),Line(points = {{0,40},{0, -40}}, color = {0,0,0}),Rectangle(extent = {{ -60,40},{ -30,20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60,20},{ -30,0}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60,0},{ -30, -20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -60, -20},{ -30, -40}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -60,60},{60, -60}}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid),Line(points = {{ -100,0},{ -58,0}}),Line(points = {{60,0},{100,0}}),Text(extent = {{ -100,100},{100,64}}, textString = "1 dimensional linear table interpolation"),Line(points = {{ -54,40},{ -54, -40},{54, -40},{54,40},{28,40},{28, -40},{ -28, -40},{ -28,40},{ -54,40},{ -54,20},{54,20},{54,0},{ -54,0},{ -54, -20},{54, -20},{54, -40},{ -54, -40},{ -54,40},{54,40},{54, -40}}, color = {0,0,0}),Line(points = {{0,40},{0, -40}}, color = {0,0,0}),Rectangle(extent = {{ -54,40},{ -28,20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54,20},{ -28,0}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54,0},{ -28, -20}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Rectangle(extent = {{ -54, -20},{ -28, -40}}, lineColor = {0,0,0}, fillColor = {255,255,0}, fillPattern = FillPattern.Solid),Text(extent = {{ -52,56},{ -34,44}}, textString = "u"),Text(extent = {{ -22,54},{2,42}}, textString = "y[1]"),Text(extent = {{4,54},{28,42}}, textString = "y[2]"),Text(extent = {{0, -40},{32, -54}}, textString = "columns")}));
// 
//       equation 
// if tableOnFile then
//                   assert(tableName <> "NoName", "tableOnFile = true and no table name given");
//         end if;
// if not tableOnFile then
//                   assert(size(table, 1) > 0 and size(table, 2) > 0, "tableOnFile = false and parameter table is an empty matrix");
//         end if;
//         for i in 1:nout loop
//         y[i] = if not tableOnFile and size(table, 1) == 1 then table[1,columns[i]] else tableTimeIpo(tableID, columns[i], u);
// 
//         end for;
//         when initial() then
//                   tableID = tableTimeInit(1.0, 0.0, smoothness, 0, if tableOnFile then tableName else "NoName", if tableOnFile then fileName else "NoName", table, 0);
//         
//         end when;
//       end CombiTable1Ds;
//       annotation(Documentation(info = "<html>
// <p>
// This package contains blocks for one- and two-dimensional
// interpolation in tables.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     protected 
//       function tableTimeInit
//         input Real timeIn;
//         input Real startTime;
//         input Integer ipoType;
//         input Integer expoType;
//         input String tableName;
//         input String fileName;
//         input Real table[:,:];
//         input Integer colWise;
//         output Integer tableID;
// 
//         external "C" tableID = omcTableTimeIni(timeIn,startTime,ipoType,expoType,tableName,fileName,table,size(table, 1),size(table, 2),colWise) ;
//       end tableTimeInit;
//       function tableTimeIpo
//         input Integer tableID;
//         input Integer icol;
//         input Real timeIn;
//         output Real value;
// 
//         external "C" value = omcTableTimeIpo(tableID,icol,timeIn) ;
//       end tableTimeIpo;
//       function tableTimeTmin
//         input Integer tableID;
//         output Real Tmin "minimum time value in table";
// 
//         external "C" Tmin = omcTableTimeTmin(tableID) ;
//       end tableTimeTmin;
//       function tableTimeTmax
//         input Integer tableID;
//         output Real Tmax "maximum time value in table";
// 
//         external "C" Tmax = omcTableTimeTmax(tableID) ;
//       end tableTimeTmax;
//     end Tables;
//     package Types "Constants and types with choices, especially to build menus"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// In this package <b>types</b> and <b>constants</b> are defined that are used
// in library Modelica.Blocks. The types have additional annotation choices
// definitions that define the menus to be built up in the graphical
// user interface when the type is used as parameter in a declaration.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Extrapolation "Type, constants and menu choices to define the extrapolation of time table interpolation"
//         annotation(Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer HoldLastPoint = 0 "Hold the last table point outside of the table scope";
//         constant Integer LastTwoPoints = 1 "Extrapolate linearly through the last two table points outside of the table scope";
//         constant Integer Periodic = 2 "Repeat the table scope periodically";
//         type Temp "Temporary type of Extrapolation with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger;
//           annotation(choices(choice = Modelica.Blocks.Types.Extrapolation.HoldLastPoint "hold last point (constant extrapolation)", choice = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "last two points (linear extrapolation)", choice = Modelica.Blocks.Types.Extrapolation.Periodic "periodic (repeat table)"), Documentation(info = "<html>
// <p>
// Type of extrapolation in a table.
// </p>
//  
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>choice</b></td>
//       <td><b>Meaning of choice</b></td>
//   </tr>
//  
//   <tr><td>HoldLastPoint</td>
//       <td>Hold the last table point outside of the table scope</td>
//   </tr>
//   <tr><td>LastTwoPoints</td>
//       <td>Extrapolate linearly through the last two table points
//           outside of the table scope</td>
//   </tr>
//   <tr><td>Periodic</td>
//       <td>Repeat the table scope periodically</td>
//   </tr>
// </table>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end Extrapolation;
//       package Init "Type, constants and menu choices to define initialization of blocks"
//         annotation(Documentation(info = "<html>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer NoInit = 1 "no initialization (start values are used as guess values with fixed=false)";
//         constant Integer SteadyState = 2 "steady state initialization (derivatives of states are zero)";
//         constant Integer InitialState = 3 "initialization with initial states";
//         constant Integer InitialOutput = 4 "initialization with initial outputs (and steady state of the states if possibles)";
//         type Temp "Temporary type of initialization with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger(min = 1, max = 4);
//           annotation(Evaluate = true, choices(choice = Modelica.Blocks.Types.Init.NoInit "no initialization (start values are used as guess values with fixed=false)", choice = Modelica.Blocks.Types.Init.SteadyState "steady state initialization (derivatives of states are zero)", choice = Modelica.Blocks.Types.Init.InitialState "initialization with initial states", choice = Modelica.Blocks.Types.Init.InitialOutput "initialization with initial outputs (and steady state of the states if possibles)"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end Init;
//       package InitPID "Type, constants and menu choices to define initialization of PID and LimPID blocks"
//         annotation(Documentation(info = "<html>
// <p>
// This initialization type is identical to Types.Init and has just one
// additional option <b>DoNotUse_InitialIntegratorState</b>. This options
// is only introduced in order that the default initialization for the
// Continuous.PID and Continuous.LimPID blocks are backward 
// compatible. In Modelica 2.2, the integrators have been initialized
// with their given states wheresas the D-part has not been initialized.
// The option \"DoNotUse_InitialIntegratorState\" leads to this
// initialization definition.
// </p>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer NoInit = 1 "no initialization (start values are used as guess values with fixed=false)";
//         constant Integer SteadyState = 2 "steady state initialization (derivatives of states are zero)";
//         constant Integer InitialState = 3 "initialization with initial states";
//         constant Integer InitialOutput = 4 "initialization with initial outputs (and steady state of the states if possibles)";
//         constant Integer DoNotUse_InitialIntegratorState = 5 "don't use, only for backward compatibility (initialize only integrator state)";
//         type Temp "Temporary type of initialization with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger(min = 1, max = 5);
//           annotation(Evaluate = true, choices(choice = Modelica.Blocks.Types.Init.NoInit "no initialization (start values are used as guess values with fixed=false)", choice = Modelica.Blocks.Types.Init.SteadyState "steady state initialization (derivatives of states are zero)", choice = Modelica.Blocks.Types.Init.InitialState "initialization with initial states", choice = Modelica.Blocks.Types.Init.InitialOutput "initialization with initial outputs (and steady state of the states if possibles)", choice = Modelica.Blocks.Types.Init.DoNotUse_InitialIntegratorState "don't use, only for backward compatibility (initialize only integrator state)"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end InitPID;
//       package SimpleController "Type, constants and menu choices to define a simple controller type"
//         annotation(Documentation(info = "<html>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer P = 1 "P controller";
//         constant Integer PI = 2 "PI controller";
//         constant Integer PD = 3 "PD controller";
//         constant Integer PID = 4 "PID controller";
//         type Temp "Temporary type of simple controller type with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger(min = 1, max = 4);
//           annotation(Evaluate = true, choices(choice = Modelica.Blocks.Types.SimpleController.P "P controller", choice = Modelica.Blocks.Types.SimpleController.PI "PI controller", choice = Modelica.Blocks.Types.SimpleController.PD "PD controller", choice = Modelica.Blocks.Types.SimpleController.PID "PID controller"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end SimpleController;
//       package Smoothness "Type, constants and menu choices to define the smoothness of table interpolation"
//         annotation(Documentation(info = "<html>
//    
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer LinearSegments = 0 "Table points are linearly interpolated";
//         constant Integer ContinuousDerivative = 1 "Table points are interpolated such that the first derivative is continuous";
//         type Temp "Temporary type of Smoothness with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger;
//           annotation(choices(choice = Modelica.Blocks.Types.Smoothness.LinearSegments "linear segments", choice = Modelica.Blocks.Types.Smoothness.ContinuousDerivative "continuous derivative"), Documentation(info = "<html>
// <p>
// Smoothness of interpolation in a table.
// </p>
//  
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>choice</b></td>
//       <td><b>Meaning of choice</b></td>
//   </tr>
//  
//   <tr><td>LinearSegments</td>
//       <td>Table points are linearly interpolated</td>
//   </tr>
//   <tr><td>ContinuousDerivative</td>
//       <td>Table points are interpolated such that the
//           first derivative is continuous</td>
//   </tr>
// </table>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end Smoothness;
//       package StateSelection "Type, constants and menu choices to define state selection of variables"
//         annotation(Documentation(info = "<html>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         extends Modelica.Icons.Enumeration;
//         constant Integer Never = 1 "Never (never use as state)";
//         constant Integer Avoid = 2 "Avoid (avoid to use as state)";
//         constant Integer Default = 3 "Default (default behaviour)";
//         constant Integer Prefer = 4 "Prefer (use as state if possible)";
//         constant Integer Always = 5 "Always (always use as state)";
//         type Temp "Temporary type of state selection with choices for menus (until enumerations are available)"
//           extends Modelica.Icons.TypeInteger(min = 1, max = 5);
//           annotation(Evaluate = true, choices(choice = Modelica.Blocks.Types.StateSelection.Never "Never (never use as state)", choice = Modelica.Blocks.Types.StateSelection.Avoid "Avoid (avoid to use as state)", choice = Modelica.Blocks.Types.StateSelection.Default "Default (default behaviour)", choice = Modelica.Blocks.Types.StateSelection.Prefer "Prefer (use as state if possible)", choice = Modelica.Blocks.Types.StateSelection.Always "Always (always use as state)"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Temp;
//       end StateSelection;
//     end Types;
//   end Blocks;
//   package Electrical "Library for electrical models (analog, digital, machines, multi-phase)"
//     extends Modelica.Icons.Library2;
//     annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This library contains electrical components to build up analog and digital circuits,
// as well as machines to model electrical motors and generators,
// especially three phase induction machines such as an asynchronous motor.
// </p>
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -29, -27},{3, -13}}),Line(visible = true, points = {{37, -58},{62, -58}}),Line(visible = true, points = {{36, -49},{61, -49}}),Line(visible = true, points = {{ -78, -50},{ -43, -50}}),Line(visible = true, points = {{ -67, -55},{ -55, -55}}),Line(visible = true, points = {{ -61, -50},{ -61, -20},{ -29, -20}}),Line(visible = true, points = {{3, -20},{48, -20},{48, -49}}),Line(visible = true, points = {{48, -58},{48, -78},{ -61, -78},{ -61, -55}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package Analog "Library for analog electrical models"
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(preferedView = "info", Window(x = 0.05, y = 0.06, width = 0.16, height = 0.58, library = 1, autolayout = 1), classOrder = {"Examples","*"}, Documentation(info = "<html>
// <p>
// This package contains packages for analog electrical components:
// <ul>
// <li>Basic: basic components (resistor, capacitor, conductor, inductor, transformer, gyrator)</li>
// <li>Semiconductors: semiconductor devices (diode, bipolar and MOS transistors)</li>
// <li>Lines: transmission lines (lossy and lossless)</li>
// <li>Ideal: ideal elements (switches, diode, transformer, idle, short, ...)</li>
// <li>Sources: time-dependend and controlled voltage and current sources</li>
// <li>Sensors: sensors to measure potential, voltage, and current</li>
// </ul>
// </p>
// <dl>
// <dt>
// <b>Main Authors:</b></dt>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden</dd>
// </dl>
//  
//  
// <p>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Examples "Examples that demonstrate the usage of the Analog electrical components"
//         extends Modelica.Icons.Library2;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains examples that demonstrate the usage of the
// components of the Electrical.Analog library.
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         package Utilities "Utility components used by package Examples"
//           extends Modelica.Icons.Library2;
//           annotation(Documentation(info = "<html>
// <p>
// This package contains utility components used by package Examples.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model Nand "CMOS NAND Gate (see Tietze/Schenk, page 157)"
//             annotation(Documentation(info = "<html>
// <p>
// The nand gate is a basic CMOS building block. It consists of four CMOS transistors.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 157
// <p>
// </dd>
// </dl>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -50.0, -70.0},{50.0,70.0}}),Ellipse(visible = true, pattern = LinePattern.None, extent = {{50.0, -5.0},{60.0,5.0}}),Text(visible = true, extent = {{ -16.0,20.0},{14.0,50.0}}, textString = "&", fontName = "Arial"),Line(visible = true, points = {{60.0,0.0},{100.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0,70.0},{0.0,100.0}}, color = {0,0,255}),Line(visible = true, points = {{ -50.0,50.0},{ -100.0,50.0}}, color = {0,0,255}),Line(visible = true, points = {{ -50.0, -50.0},{ -100.0, -50.0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{50.0, -5.0},{60.0,5.0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,24.0},{ -90.0,34.0}}, textString = "x1", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -75.0},{ -90.0, -65.0}}, textString = "x2", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{90.0, -25.0},{100.0, -15.0}}, textString = "y", fontName = "Arial")}));
//             Semiconductors.PMOS TP1(W = 6.5e-06, L = 3.1e-06, Beta = 1.05e-05, Vt =  -1, K2 = 0.41, K5 = 0.8385, dW =  -2.5e-06, dL =  -2.1e-06) annotation(Placement(visible = true, transformation(origin = {20,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Semiconductors.PMOS TP2(W = 6.5e-06, L = 3.1e-06, Beta = 1.05e-05, Vt =  -1, K2 = 0.41, K5 = 0.8385, dW =  -2.5e-06, dL =  -2.1e-06) annotation(Placement(visible = true, transformation(origin = { -30,55}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Semiconductors.NMOS TN1(W = 6.5e-06, L = 3.1e-06, Beta = 4.1e-05, Vt = 0.8, K2 = 1.144, K5 = 0.7311, dW =  -2.5e-06, dL =  -1.5e-06) annotation(Placement(visible = true, transformation(origin = {20,25}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Semiconductors.NMOS TN2(W = 6.5e-06, L = 3.1e-06, Beta = 4.1e-05, Vt = 0.8, K2 = 1.144, K5 = 0.7311, dW =  -2.5e-06, dL =  -1.5e-06) annotation(Placement(visible = true, transformation(origin = {20, -15}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Basic.Ground Gnd annotation(Placement(visible = true, transformation(origin = {45, -20}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Basic.Ground Gnd2 annotation(Placement(visible = true, transformation(origin = {60,5}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Basic.Ground Gnd3 annotation(Placement(visible = true, transformation(origin = {55, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Basic.Ground Gnd6 annotation(Placement(visible = true, transformation(origin = { -10,35}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Basic.Ground Gnd7 annotation(Placement(visible = true, transformation(origin = {45,20}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Basic.Ground Gnd8 annotation(Placement(visible = true, transformation(origin = {45,65}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//             Interfaces.Pin x1 annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin x2 annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin Vdd annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin y annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Basic.Capacitor C4(C = 4e-14) annotation(Placement(visible = true, transformation(origin = {60,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//             Basic.Capacitor C7(C = 4e-14) annotation(Placement(visible = true, transformation(origin = {55, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//           equation 
//             connect(TP2.D,Vdd) annotation(Line(visible = true, points = {{ -20.0,60.0},{ -20.0,80.0},{0.0,80.0},{0.0,100.0}}, color = {0,0,255}));
//             connect(Vdd,TP1.D) annotation(Line(visible = true, points = {{0.0,100.0},{0.0,80.0},{30.0,80.0},{30.0,75.0}}, color = {0,0,255}));
//             connect(TP2.S,TN1.D) annotation(Line(visible = true, points = {{ -20.0,50.0},{30.0,50.0},{30.0,30.0}}, color = {0,0,255}));
//             connect(TN1.G,x2) annotation(Line(visible = true, points = {{10.0,20.0},{ -70.0,20.0},{ -70.0, -50.0},{ -100.0, -50.0}}, color = {0,0,255}));
//             connect(TP2.G,TN2.G) annotation(Line(visible = true, points = {{ -40.0,50.0},{ -40.0, -20.0},{10.0, -20.0}}, color = {0,0,255}));
//             connect(TP2.G,x1) annotation(Line(visible = true, points = {{ -40.0,50.0},{ -100.0,50.0}}, color = {0,0,255}));
//             connect(TP1.B,Gnd8.p) annotation(Line(visible = true, points = {{30.0,70.0},{45.0,70.0}}, color = {0,0,255}));
//             connect(TN1.B,Gnd7.p) annotation(Line(visible = true, points = {{30.0,25.0},{45.0,25.0}}, color = {0,0,255}));
//             connect(TP2.B,Gnd6.p) annotation(Line(visible = true, points = {{ -20.0,55.0},{ -10.0,55.0},{ -10.0,40.0}}, color = {0,0,255}));
//             connect(TP1.G,TN1.G) annotation(Line(visible = true, points = {{10.0,65.0},{10.0,20.0}}, color = {0,0,255}));
//             connect(TP1.S,TN1.D) annotation(Line(visible = true, points = {{30.0,65.0},{30.0,30.0}}, color = {0,0,255}));
//             connect(TN2.S,Gnd.p) annotation(Line(visible = true, points = {{30.0, -20.0},{38.0, -20.0},{38.0, -15.0},{45.0, -15.0}}, color = {0,0,255}));
//             connect(TN2.B,Gnd.p) annotation(Line(visible = true, points = {{30.0, -15.0},{38.0, -15.0},{38.0, -15.0},{45.0, -15.0}}, color = {0,0,255}));
//             connect(TN1.S,TN2.D) annotation(Line(visible = true, points = {{30.0,20.0},{30.0, -10.0}}, color = {0,0,255}));
//             connect(C4.n,Gnd2.p) annotation(Line(visible = true, points = {{60.0,20.0},{60.0,10.0}}, color = {0,0,255}));
//             connect(TN1.D,C4.p) annotation(Line(visible = true, points = {{30.0,30.0},{30.0,50.0},{60.0,50.0},{60.0,40.0}}, color = {0,0,255}));
//             connect(C4.p,y) annotation(Line(visible = true, points = {{60.0,40.0},{60.0,50.0},{80.0,50.0},{80.0,0.0},{100.0,0.0}}, color = {0,0,255}));
//             connect(TN2.D,C7.p) annotation(Line(visible = true, points = {{30.0, -10.0},{55.0, -10.0},{55.0, -40.0}}, color = {0,0,255}));
//             connect(C7.n,Gnd3.p) annotation(Line(visible = true, points = {{55.0, -60.0},{55.0, -70.0}}, color = {0,0,255}));
//           end Nand;
//           model NonlinearResistor "Chua's resistor"
//             extends Interfaces.OnePort;
//             annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70.0, -30.0},{70.0,30.0}}),Line(visible = true, points = {{ -90.0,0.0},{ -70.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,0.0},{90.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{ -50.0, -60.0},{50.0,60.0}}, color = {0,0,255}, arrow = {Arrow.None,Arrow.Filled}, arrowSize = 12),Text(visible = true, fillColor = {0,0,255}, extent = {{ -100.0,70.0},{100.0,100.0}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70.0, -30.0},{70.0,30.0}}),Line(visible = true, points = {{ -100.0,0.0},{ -70.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,0.0},{100.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{ -50.0, -60.0},{50.0,60.0}}, color = {0,0,255}, arrow = {Arrow.None,Arrow.Filled}, arrowSize = 12)}));
//             parameter SI.Conductance Ga;
//             parameter SI.Conductance Gb;
//             parameter SI.Voltage Ve;
// 
//           equation 
//             i = if v <  -Ve then Gb * (v + Ve) - Ga * Ve else if v > Ve then Gb * (v - Ve) + Ga * Ve else Ga * v;
//           end NonlinearResistor;
//           model RealSwitch
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Interfaces.Pin n1 annotation(Placement(visible = true, transformation(origin = {100,60}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin n2 annotation(Placement(visible = true, transformation(origin = {100,14}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,14}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin p annotation(Placement(visible = true, transformation(origin = { -100,37.5}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Basic.Resistor R(R = 0.01) annotation(Placement(visible = true, transformation(origin = { -45.8334,37.5}, extent = {{ -23.3333, -23.3333},{23.3333,23.3333}}, rotation = 0)));
//             Interfaces.Pin control annotation(Placement(visible = true, transformation(origin = {35,100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {34,100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Ideal.ControlledIdealCommutingSwitch S(level = 2.5) annotation(Placement(visible = true, transformation(origin = {35.0947,37.5}, extent = {{ -23.3333, -23.3333},{23.3333,23.3333}}, rotation = 0)));
// 
//           equation 
//             connect(p,R.p) annotation(Line(visible = true, points = {{ -100.0,37.5},{ -69.1667,37.5}}, color = {0,0,255}));
//             connect(R.n,S.p) annotation(Line(visible = true, points = {{ -22.5001,37.5},{11.7614,37.5}}, color = {0,0,255}));
//             connect(n1,S.n1) annotation(Line(visible = true, origin = {71.4891,54.5833}, points = {{28.5109,5.4167},{ -7.7249,5.4167},{ -7.7249, -5.4167},{ -13.0611, -5.4167}}, color = {0,0,255}));
//             connect(n2,S.n2) annotation(Line(visible = true, origin = {71.4891,25.75}, points = {{28.5109, -11.75},{ -7.7249, -11.75},{ -7.7249,11.75},{ -13.0611,11.75}}, color = {0,0,255}));
//             connect(control,S.control) annotation(Line(visible = true, points = {{35.0,100.0},{35.0947,60.8333}}, color = {0,0,255}));
//           end RealSwitch;
//           model Transistor
//             annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -80.0, -80.0},{80.0,80.0}}),Line(visible = true, points = {{80.0,60.0},{100.0,60.0}}, color = {0,0,255}),Line(visible = true, points = {{80.0, -60.0},{100.0, -60.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{ -60.0,0.0},{ -10.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{ -10.0,40.0},{ -10.0, -40.0}}, color = {0,0,255}),Line(visible = true, points = {{60.0,60.0},{40.0,60.0},{ -10.0,10.0}}, color = {0,0,255}),Line(visible = true, points = {{ -10.0, -10.0},{40.0, -60.0},{60.0, -60.0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Basic.Resistor rtb(R = 0.05) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Basic.Resistor rtc(R = 0.1) annotation(Placement(visible = true, transformation(origin = {50,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Semiconductors.NPN Tr(Bf = 50, Br = 0.1, Is = 1e-16, Vak = 0.02, Tauf = 1.2e-10, Taur = 5e-09, Ccs = 1e-12, Cje = 4e-13, Cjc = 5e-13, Phie = 0.8, Me = 0.4, Phic = 0.8, Mc = 0.333, Gbc = 1e-15, Gbe = 1e-15, Vt = 0.02585) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//             Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -40, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin c annotation(Placement(visible = true, transformation(origin = {100,60}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin b annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.Pin e annotation(Placement(visible = true, transformation(origin = {100, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Basic.Capacitor ct(C = 1e-10) annotation(Placement(visible = true, transformation(origin = { -40, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//           equation 
//             connect(Tr.E,e) annotation(Line(visible = true, points = {{20.0, -10.0},{80.0, -10.0},{80.0, -60.0},{100.0, -60.0}}, color = {0,0,255}));
//             connect(b,rtb.p) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}, color = {0,0,255}));
//             connect(rtc.n,c) annotation(Line(visible = true, points = {{60.0,10.0},{80.0,10.0},{80.0,60.0},{100.0,60.0}}, color = {0,0,255}));
//             connect(Tr.C,rtc.p) annotation(Line(visible = true, points = {{20.0,10.0},{40.0,10.0}}, color = {0,0,255}));
//             connect(rtb.n,Tr.B) annotation(Line(visible = true, points = {{ -60.0,0.0},{ -20.0,0.0}}, color = {0,0,255}));
//             connect(rtb.n,ct.p) annotation(Line(visible = true, points = {{ -60.0,0.0},{ -40.0,0.0},{ -40.0, -20.0}}, color = {0,0,255}));
//             connect(ct.n,Ground1.p) annotation(Line(visible = true, points = {{ -40.0, -40.0},{ -40.0, -60.0}}, color = {0,0,255}));
//           end Transistor;
//         end Utilities;
//         model CauerLowPassAnalog "Cauer low pass filter with analog components"
//           annotation(uses(Modelica(version = "2.2")), experiment(StopTime = 60), experimentSetupOutput, Documentation(revisions = "<html>
// <ul>
// <li><i>January 13, 2006</i> 
//        by Christoph Clauss<br>
//        included into Modelica Standard Library</li>
// <li><i>September 15, 2005</i>
//        by Peter Trappe designed and by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </html>", info = "<html>
//  
// <p>
// The example Cauer Filter is a low-pass-filter of the fifth order. It is realized
// using an analog network. The voltage source V is the input voltage (step),
// and the R2.p.v is the filter output voltage. The pulse response is calculated.
// <p>
// The simulation end time should be 60. Please plot both V.p.v (input voltage) and R2.p.v (output voltage). 
// <p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -98.85},{80,51.15}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -96, -49},{77,3}}, textString = "Example", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,73},{120,132}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -150,100},{150, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{ -62,28},{ -58,32}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{ -2,28},{2,32}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{58,28},{62,32}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{58, -52},{62, -48}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{ -2, -52},{2, -48}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {127,127,255}, fillPattern = FillPattern.Solid, extent = {{ -62, -52},{ -58, -48}}),Text(visible = true, extent = {{ -110,64},{100,116}}, textString = "CauerLowPassAnalog", fontName = "Arial")}));
//           parameter Real l1 = 1.304;
//           parameter Real l2 = 0.8586;
//           parameter Real c1 = 1.072;
//           parameter Real c2 = 1 / (1.704992 ^ 2 * l1);
//           parameter Real c3 = 1.682;
//           parameter Real c4 = 1 / (1.179945 ^ 2 * l2);
//           parameter Real c5 = 0.7262;
//           Modelica.Electrical.Analog.Basic.Ground G annotation(Placement(visible = true, transformation(origin = {0, -80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C1(C = c1) annotation(Placement(visible = true, transformation(origin = { -60, -20}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Capacitor C2(C = c2) annotation(Placement(visible = true, transformation(origin = { -30,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C3(C = c3) annotation(Placement(visible = true, transformation(origin = {0, -20}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Capacitor C4(C = c4) annotation(Placement(visible = true, transformation(origin = {30,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C5(C = c5) annotation(Placement(visible = true, transformation(origin = {60, -20}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Inductor L1(L = l1) annotation(Placement(visible = true, transformation(origin = { -30,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Inductor L2(L = l2) annotation(Placement(visible = true, transformation(origin = {30,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R2 annotation(Placement(visible = true, transformation(origin = {100, -20}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Sources.StepVoltage V(startTime = 1, offset = 0) annotation(Placement(visible = true, transformation(origin = { -100, -10}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Resistor R1 annotation(Placement(visible = true, transformation(origin = { -90,30}, extent = {{ -10, -10},{10,10}}, rotation =  -360)));
// 
//         equation 
//           connect(V.n,G.p) annotation(Line(visible = true, points = {{ -100, -20},{ -100, -70},{0, -70}}, color = {0,0,255}));
//           connect(C5.p,R2.p) annotation(Line(visible = true, points = {{60, -10},{60,30},{100,30},{100, -10}}, color = {0,0,255}));
//           connect(R2.n,C1.n) annotation(Line(visible = true, points = {{100, -30},{100, -50},{ -60, -50},{ -60, -30}}, color = {0,0,255}));
//           connect(R2.n,C3.n) annotation(Line(visible = true, points = {{100, -30},{100, -50},{0, -50},{0, -30},{0, -30}}, color = {0,0,255}));
//           connect(R2.n,C5.n) annotation(Line(visible = true, points = {{100, -30},{100, -50},{60, -50},{60, -30}}, color = {0,0,255}));
//           connect(C1.n,C5.n) annotation(Line(visible = true, points = {{ -60, -30},{ -60, -50},{60, -50},{60, -30}}, color = {0,0,255}));
//           connect(C1.n,C3.n) annotation(Line(visible = true, points = {{ -60, -30},{ -60, -50},{0, -50},{0, -30},{0, -30}}, color = {0,0,255}));
//           connect(C5.n,G.p) annotation(Line(visible = true, points = {{60, -30},{60, -50},{0, -50},{0, -70}}, color = {0,0,255}));
//           connect(C3.n,G.p) annotation(Line(visible = true, points = {{0, -30},{0, -30},{0, -70}}, color = {0,0,255}));
//           connect(C4.n,R2.p) annotation(Line(visible = true, points = {{40,30},{100,30},{100, -10}}, color = {0,0,255}));
//           connect(C4.n,C5.p) annotation(Line(visible = true, points = {{40,30},{60,30},{60, -10}}, color = {0,0,255}));
//           connect(R2.n,G.p) annotation(Line(visible = true, points = {{100, -30},{100, -50},{0, -50},{0, -70}}, color = {0,0,255}));
//           connect(L2.n,R2.p) annotation(Line(visible = true, points = {{40,70},{40,30},{100,30},{100, -10}}, color = {0,0,255}));
//           connect(L2.n,C5.p) annotation(Line(visible = true, points = {{40,70},{40,30},{60,30},{60, -10}}, color = {0,0,255}));
//           connect(L2.n,C4.n) annotation(Line(visible = true, points = {{40,70},{40,30}}, color = {0,0,255}));
//           connect(C3.p,L2.p) annotation(Line(visible = true, points = {{0, -10},{0, -10},{0,30},{20,30},{20,70}}, color = {0,0,255}));
//           connect(C2.n,L2.p) annotation(Line(visible = true, points = {{ -20,30},{20,30},{20,70}}, color = {0,0,255}));
//           connect(L2.p,C4.p) annotation(Line(visible = true, points = {{20,70},{20,30}}, color = {0,0,255}));
//           connect(L1.n,C4.p) annotation(Line(visible = true, points = {{ -20,70},{ -20,30},{20,30}}, color = {0,0,255}));
//           connect(L1.n,C3.p) annotation(Line(visible = true, points = {{ -20,70},{ -20,30},{1.83691e-15,30},{0, -10}}, color = {0,0,255}));
//           connect(C2.n,C4.p) annotation(Line(visible = true, points = {{ -20,30},{20,30}}, color = {0,0,255}));
//           connect(C2.n,C3.p) annotation(Line(visible = true, points = {{ -20,30},{1.83691e-15,30},{0, -10}}, color = {0,0,255}));
//           connect(L1.n,C2.n) annotation(Line(visible = true, points = {{ -20,70},{ -20,30}}, color = {0,0,255}));
//           connect(L1.p,C1.p) annotation(Line(visible = true, points = {{ -40,70},{ -40,30},{ -60,30},{ -60, -10}}, color = {0,0,255}));
//           connect(L1.p,C2.p) annotation(Line(visible = true, points = {{ -40,70},{ -40,30}}, color = {0,0,255}));
//           connect(C1.n,G.p) annotation(Line(visible = true, points = {{ -60, -30},{ -60, -50},{0, -50},{0, -70}}, color = {0,0,255}));
//           connect(R1.n,C1.p) annotation(Line(visible = true, points = {{ -80,30},{ -60,30},{ -60, -10}}, color = {0,0,255}));
//           connect(R1.n,C2.p) annotation(Line(visible = true, points = {{ -80,30},{ -40,30}}, color = {0,0,255}));
//           connect(R1.p,V.p) annotation(Line(visible = true, points = {{ -100,30},{ -100,0}}, color = {0,0,255}));
//         end CauerLowPassAnalog;
//         model CauerLowPassOPV "Cauer low pass filter with operational amplifiers"
//           annotation(uses(Modelica(version = "2.2")), experiment(StopTime = 60), experimentSetupOutput, Documentation(revisions = "<html>
// <ul>
// <li><i>January 13, 2006</i> 
//        by Christoph Clauss<br>
//        included into Modelica Standard Library</li>
// <li><i>September 15, 2005</i>
//        by by Peter Trappe designed and by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </html>", info = "<html>
// The example Cauer Filter is a low-pass-filter of the fifth order. It is realized
// using an analog network with operational amplifiers. The voltage source V is the input voltage (step),
// and the OP5.out.v is the filter output voltage. The pulse response is calculated.
// <p>
// This model is identical to the CauerLowPassAnalog example, but inverting. To get the same response
// as that of the CauerLowPassAnalog example, a negative voltage step is used as input.
// <p>
// The simulation end time should be 60. Please plot both V.v (which is the inverted input voltage) and OP5.p.v (output voltage). Compare this result with the CauerLowPassAnalog result.
// <p>
// During translation some warnings are issued concerning resistor values (Value=-1 not in range[0,1.e+100]).
// Do not worry about it. The negative values are o.k.
// <p>
// </html>"), Diagram(coordinateSystem(extent = {{ -250,200},{250, -200}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -130,120},{80,172}}, textString = "CauerLowPassOPV", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -96, -49},{77,3}}, textString = "Example", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,73},{120,132}}, textString = "%name", fontName = "Arial")}));
//           parameter Real l1 = 1.304;
//           parameter Real l2 = 0.8586;
//           parameter Real c1 = 1.072;
//           parameter Real c2 = 1 / (1.704992 ^ 2 * l1);
//           parameter Real c3 = 1.682;
//           parameter Real c4 = 1 / (1.179945 ^ 2 * l2);
//           parameter Real c5 = 0.7262;
//           Modelica.Electrical.Analog.Basic.Capacitor C1(C = c1 + c2) annotation(Placement(visible = true, transformation(origin = { -182,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C2(C = c2) annotation(Placement(visible = true, transformation(origin = { -230, -80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C3(C = l1) annotation(Placement(visible = true, transformation(origin = { -80,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C4(C = c4) annotation(Placement(visible = true, transformation(origin = { -20,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C5(C = c2) annotation(Placement(visible = true, transformation(origin = { -20, -110}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R1 annotation(Placement(visible = true, transformation(origin = { -230, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R2 annotation(Placement(visible = true, transformation(origin = { -230,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R3 annotation(Placement(visible = true, transformation(origin = { -183,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op1 annotation(Placement(visible = true, transformation(origin = { -180, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G annotation(Placement(visible = true, transformation(origin = { -181, -88}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R4(R =  -1) annotation(Placement(visible = true, transformation(origin = { -130, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R5(R =  -1) annotation(Placement(visible = true, transformation(origin = { -130, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op2 annotation(Placement(visible = true, transformation(origin = { -80, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op3 annotation(Placement(visible = true, transformation(origin = {26, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G1 annotation(Placement(visible = true, transformation(origin = { -80, -88}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R6 annotation(Placement(visible = true, transformation(origin = { -21,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R7 annotation(Placement(visible = true, transformation(origin = { -21, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C6(C = c2 + c3 + c4) annotation(Placement(visible = true, transformation(origin = {19,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R8(R =  -1) annotation(Placement(visible = true, transformation(origin = {70,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R9(R =  -1) annotation(Placement(visible = true, transformation(origin = {70, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R10 annotation(Placement(visible = true, transformation(origin = {170, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op4 annotation(Placement(visible = true, transformation(origin = {120, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op5 annotation(Placement(visible = true, transformation(origin = {220, -50}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C7(C = l2) annotation(Placement(visible = true, transformation(origin = {120,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C8(C = c4) annotation(Placement(visible = true, transformation(origin = {170, -140}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C9(C = c4 + c5) annotation(Placement(visible = true, transformation(origin = {218,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R11 annotation(Placement(visible = true, transformation(origin = {219,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G2 annotation(Placement(visible = true, transformation(origin = {19, -88}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G3 annotation(Placement(visible = true, transformation(origin = {120, -88}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G4 annotation(Placement(visible = true, transformation(origin = {220, -88}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.StepVoltage V(startTime = 1) annotation(Placement(visible = true, transformation(origin = { -240, -170}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -240, -196}, extent = {{ -6, -6},{6,6}}, rotation = 0)));
//         protected 
//           Modelica.Electrical.Analog.Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = { -212, -40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = { -212,0}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n3 annotation(Placement(visible = true, transformation(origin = { -212,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n4 annotation(Placement(visible = true, transformation(origin = { -160,20}, extent = {{2,2},{ -2, -2}}, rotation =  -180)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n5 annotation(Placement(visible = true, transformation(origin = { -112, -50}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p1 annotation(Placement(visible = true, transformation(origin = { -151, -140}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n6 annotation(Placement(visible = true, transformation(origin = { -60,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n7 annotation(Placement(visible = true, transformation(origin = { -4, -50}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n8 annotation(Placement(visible = true, transformation(origin = { -4,0}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p2 annotation(Placement(visible = true, transformation(origin = { -4,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin out1 annotation(Placement(visible = true, transformation(origin = {46, -140}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p3 annotation(Placement(visible = true, transformation(origin = {60,60}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n9 annotation(Placement(visible = true, transformation(origin = {88,0}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n10 annotation(Placement(visible = true, transformation(origin = {88, -50}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n11 annotation(Placement(visible = true, transformation(origin = {140,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n12 annotation(Placement(visible = true, transformation(origin = {240,40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n13 annotation(Placement(visible = true, transformation(origin = {240,0}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p4 annotation(Placement(visible = true, transformation(origin = {191,0}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n14 annotation(Placement(visible = true, transformation(origin = {191, -50}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
// 
//         equation 
//           connect(V.n,R1.p) annotation(Line(visible = true, points = {{ -240, -160},{ -250, -160},{ -250, -40},{ -240, -40}}, color = {0,0,255}));
//           connect(V.p,Ground1.p) annotation(Line(visible = true, points = {{ -240, -180},{ -240, -190}}, color = {0,0,255}));
//           connect(Op5.in_p,G4.p) annotation(Line(visible = true, points = {{200, -60},{200, -80},{220, -80}}, color = {0,0,255}));
//           connect(Op4.in_p,G3.p) annotation(Line(visible = true, points = {{100, -60},{100, -80},{120, -80}}, color = {0,0,255}));
//           connect(C8.n,n14) annotation(Line(visible = true, points = {{180, -140},{191, -140},{191, -50}}, color = {0,0,255}));
//           connect(Op5.in_n,n14) annotation(Line(visible = true, points = {{200, -40},{191, -40},{191, -50}}, color = {0,0,255}));
//           connect(p4,n14) annotation(Line(visible = true, points = {{191,0},{191, -50}}, color = {0,0,255}));
//           connect(R10.n,n14) annotation(Line(visible = true, points = {{180, -50},{191, -50}}, color = {0,0,255}));
//           connect(R11.p,p4) annotation(Line(visible = true, points = {{209,40},{191,40},{191,0}}, color = {0,0,255}));
//           connect(C9.p,p4) annotation(Line(visible = true, points = {{208,0},{191,0}}, color = {0,0,255}));
//           connect(n13,Op5.out) annotation(Line(visible = true, points = {{240,0},{240, -50}}, color = {0,0,255}));
//           connect(n12,n13) annotation(Line(visible = true, points = {{240,40},{240,0}}, color = {0,0,255}));
//           connect(C9.n,n13) annotation(Line(visible = true, points = {{228,0},{240,0}}, color = {0,0,255}));
//           connect(p3,n12) annotation(Line(visible = true, points = {{60,60},{240,60},{240,40}}, color = {0,0,255}));
//           connect(R11.n,n12) annotation(Line(visible = true, points = {{229,40},{240,40}}, color = {0,0,255}));
//           connect(G2.p,Op3.in_p) annotation(Line(visible = true, points = {{19, -80},{6, -80},{6, -60}}, color = {0,0,255}));
//           connect(Op4.out,R10.p) annotation(Line(visible = true, points = {{140, -50},{160, -50}}, color = {0,0,255}));
//           connect(n11,Op4.out) annotation(Line(visible = true, points = {{140,20},{140, -50}}, color = {0,0,255}));
//           connect(R6.p,n11) annotation(Line(visible = true, points = {{ -31,0},{ -48,0},{ -48,80},{140,80},{140,20}}, color = {0,0,255}));
//           connect(C7.n,n11) annotation(Line(visible = true, points = {{130,20},{140,20}}, color = {0,0,255}));
//           connect(n9,C7.p) annotation(Line(visible = true, points = {{88,0},{88,20},{110,20}}, color = {0,0,255}));
//           connect(n10,Op4.in_n) annotation(Line(visible = true, points = {{88, -50},{88, -40},{100, -40}}, color = {0,0,255}));
//           connect(R9.n,n10) annotation(Line(visible = true, points = {{80, -50},{88, -50}}, color = {0,0,255}));
//           connect(n9,n10) annotation(Line(visible = true, points = {{88,0},{88, -50}}, color = {0,0,255}));
//           connect(R8.n,n9) annotation(Line(visible = true, points = {{80,0},{88,0}}, color = {0,0,255}));
//           connect(p3,R8.p) annotation(Line(visible = true, points = {{60,60},{60,0}}, color = {0,0,255}));
//           connect(C4.p,p3) annotation(Line(visible = true, points = {{ -30,40},{ -40,40},{ -40,60},{60,60}}, color = {0,0,255}));
//           connect(out1,C8.p) annotation(Line(visible = true, points = {{46, -140},{160, -140}}, color = {0,0,255}));
//           connect(p1,out1) annotation(Line(visible = true, points = {{ -151, -140},{46, -140}}, color = {0,0,255}));
//           connect(Op3.out,out1) annotation(Line(visible = true, points = {{46, -50},{46, -140}}, color = {0,0,255}));
//           connect(R9.p,Op3.out) annotation(Line(visible = true, points = {{60, -50},{46, -50}}, color = {0,0,255}));
//           connect(C6.n,Op3.out) annotation(Line(visible = true, points = {{29,20},{46,20},{46, -50}}, color = {0,0,255}));
//           connect(C4.n,p2) annotation(Line(visible = true, points = {{ -10,40},{ -4,40},{ -4,20}}, color = {0,0,255}));
//           connect(n8,p2) annotation(Line(visible = true, points = {{ -4,0},{ -4,20}}, color = {0,0,255}));
//           connect(C6.p,p2) annotation(Line(visible = true, points = {{9,20},{ -4,20}}, color = {0,0,255}));
//           connect(n7,n8) annotation(Line(visible = true, points = {{ -4, -50},{ -4,0},{ -4,0}}, color = {0,0,255}));
//           connect(R6.n,n8) annotation(Line(visible = true, points = {{ -11,0},{ -4,0}}, color = {0,0,255}));
//           connect(C5.n,n7) annotation(Line(visible = true, points = {{ -10, -110},{ -4, -110},{ -4, -50}}, color = {0,0,255}));
//           connect(n7,Op3.in_n) annotation(Line(visible = true, points = {{ -4, -50},{ -4, -40},{6, -40}}, color = {0,0,255}));
//           connect(R7.n,n7) annotation(Line(visible = true, points = {{ -11, -50},{ -4, -50}}, color = {0,0,255}));
//           connect(Op2.out,R7.p) annotation(Line(visible = true, points = {{ -60, -50},{ -31, -50}}, color = {0,0,255}));
//           connect(R2.p,n6) annotation(Line(visible = true, points = {{ -240,0},{ -240,80},{ -60,80},{ -60,20}}, color = {0,0,255}));
//           connect(n6,Op2.out) annotation(Line(visible = true, points = {{ -60,20},{ -60, -50}}, color = {0,0,255}));
//           connect(C3.n,n6) annotation(Line(visible = true, points = {{ -70,20},{ -60,20}}, color = {0,0,255}));
//           connect(C2.p,p1) annotation(Line(visible = true, points = {{ -240, -80},{ -240, -140},{ -151, -140}}, color = {0,0,255}));
//           connect(R5.p,p1) annotation(Line(visible = true, points = {{ -140, -90},{ -151, -90},{ -151, -140}}, color = {0,0,255}));
//           connect(R5.n,n5) annotation(Line(visible = true, points = {{ -120, -90},{ -112, -90},{ -112, -50}}, color = {0,0,255}));
//           connect(C3.p,n5) annotation(Line(visible = true, points = {{ -90,20},{ -112,20},{ -112, -50}}, color = {0,0,255}));
//           connect(n5,Op2.in_n) annotation(Line(visible = true, points = {{ -112, -50},{ -112, -40},{ -100, -40}}, color = {0,0,255}));
//           connect(R4.n,n5) annotation(Line(visible = true, points = {{ -120, -50},{ -112, -50}}, color = {0,0,255}));
//           connect(C5.p,Op1.out) annotation(Line(visible = true, points = {{ -30, -110},{ -160, -110},{ -160, -50}}, color = {0,0,255}));
//           connect(R4.p,Op1.out) annotation(Line(visible = true, points = {{ -140, -50},{ -160, -50}}, color = {0,0,255}));
//           connect(n4,Op1.out) annotation(Line(visible = true, points = {{ -160,20},{ -160, -50}}, color = {0,0,255}));
//           connect(R3.n,n4) annotation(Line(visible = true, points = {{ -173,60},{ -160,60},{ -160,20}}, color = {0,0,255}));
//           connect(C1.n,n4) annotation(Line(visible = true, points = {{ -172,20},{ -160,20}}, color = {0,0,255}));
//           connect(n3,R3.p) annotation(Line(visible = true, points = {{ -212,20},{ -212,60},{ -193,60}}, color = {0,0,255}));
//           connect(n3,C1.p) annotation(Line(visible = true, points = {{ -212,20},{ -192,20}}, color = {0,0,255}));
//           connect(n2,n3) annotation(Line(visible = true, points = {{ -212,0},{ -212,20}}, color = {0,0,255}));
//           connect(n1,n2) annotation(Line(visible = true, points = {{ -212, -40},{ -212,0}}, color = {0,0,255}));
//           connect(R2.n,n2) annotation(Line(visible = true, points = {{ -220,0},{ -212,0}}, color = {0,0,255}));
//           connect(C2.n,n1) annotation(Line(visible = true, points = {{ -220, -80},{ -212, -80},{ -212, -40}}, color = {0,0,255}));
//           connect(n1,Op1.in_n) annotation(Line(visible = true, points = {{ -212, -40},{ -200, -40}}, color = {0,0,255}));
//           connect(R1.n,n1) annotation(Line(visible = true, points = {{ -220, -40},{ -212, -40}}, color = {0,0,255}));
//           connect(G1.p,Op2.in_p) annotation(Line(visible = true, points = {{ -80, -80},{ -80, -70},{ -100, -70},{ -100, -60}}, color = {0,0,255}));
//           connect(Op1.in_p,G.p) annotation(Line(visible = true, points = {{ -200, -60},{ -200, -70},{ -180, -70},{ -180, -80},{ -181, -80}}, color = {0,0,255}));
//         end CauerLowPassOPV;
//         model CauerLowPassSC "Cauer low-pass filter with operational amplifiers and switched capacitors"
//           model Rp
//             annotation(uses(Modelica(version = "2.2")), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, origin = {0,0.97}, lineColor = {0,0,255}, extent = {{ -80, -30.97},{80,29.03}}),Line(visible = true, points = {{ -92,0},{ -80,0}}, color = {127,127,255}),Line(visible = true, points = {{80,0},{92,0}}, color = {127,127,255}),Text(visible = true, extent = {{ -40, -72},{32, -40}}, textString = "R=%R", fontName = "Arial"),Line(visible = true, points = {{ -74,0},{ -80,0},{ -60,0}}, color = {127,255,127}),Line(visible = true, points = {{ -80, -20},{ -60, -20},{ -60, -16},{ -40, -10},{ -4, -10}}, color = {127,255,127}),Line(visible = true, points = {{4, -10},{40, -10},{60, -16},{60, -20},{80, -20}}, color = {127,255,127}),Line(visible = true, points = {{80,0},{60,0}}, color = {127,255,127}),Line(visible = true, points = {{60,0},{60, -4}}, color = {127,255,127}),Line(visible = true, points = {{ -60,0},{ -60, -6}}, color = {159,223,159}),Line(visible = true, points = {{ -4,0},{ -4, -20}}, color = {127,255,127}),Line(visible = true, points = {{4,0},{4, -20}}, color = {127,255,127}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -60,40},{60,80}}, textString = "%name", fontName = "Arial")}));
//             parameter Real clock = 1;
//             parameter Modelica.SIunits.Resistance R = 1 "Resistance";
//             Modelica.Blocks.Sources.BooleanPulse BooleanPulse1(period = clock) annotation(Placement(visible = true, transformation(origin = {0,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = R * clock) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//             Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch IdealCommutingSwitch1 annotation(Placement(visible = true, transformation(origin = { -50,2.66454e-15}, extent = {{10,10},{ -10, -10}}, rotation =  -360)));
//             Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch IdealCommutingSwitch2 annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -60,44}, extent = {{ -5, -6},{5,6}}, rotation =  -540)));
//             Modelica.Electrical.Analog.Basic.Ground Ground2 annotation(Placement(visible = true, transformation(origin = {60, -46}, extent = {{ -5, -6},{5,6}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = { -102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100, -4.44089e-16}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,2}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//           equation 
//             connect(IdealCommutingSwitch1.p,Capacitor1.p) annotation(Line(visible = true, origin = { -30,2.55691e-15}, points = {{ -10,2.55691e-15},{10, -2.55691e-15}}, color = {0,0,255}));
//             connect(Capacitor1.n,IdealCommutingSwitch2.p) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {0,0,255}));
//             connect(IdealCommutingSwitch2.control,BooleanPulse1.y) annotation(Line(visible = true, points = {{50,8},{50,30},{20,30},{20,60},{11,60}}, color = {255,0,255}));
//             connect(IdealCommutingSwitch1.control,BooleanPulse1.y) annotation(Line(visible = true, points = {{ -50, -8},{ -50,30},{20,30},{20,60},{11,60}}, color = {255,0,255}));
//             connect(Ground1.p,IdealCommutingSwitch1.n2) annotation(Line(visible = true, points = {{ -60,38},{ -60,2.15242e-16}}, color = {0,0,255}));
//             connect(Ground2.p,IdealCommutingSwitch2.n2) annotation(Line(visible = true, points = {{60, -40},{60,0}}, color = {0,0,255}));
//             connect(IdealCommutingSwitch1.n1,n1) annotation(Line(visible = true, origin = {19,0}, points = {{ -79, -5},{ -99, -5},{ -99,0},{ -121,0}}, color = {0,0,255}));
//             connect(IdealCommutingSwitch2.n1,n2) annotation(Line(visible = true, points = {{60,5},{80,5},{80, -4.44089e-16},{100, -4.44089e-16}}, color = {0,0,255}));
//           end Rp;
//           model Rn
//             parameter Real clock = 1;
//             parameter Modelica.SIunits.Resistance R = 1 "Resistance";
//             annotation(uses(Modelica(version = "2.2")), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, origin = {0, -0.97}, lineColor = {0,0,255}, extent = {{ -80, -29.03},{80,30.97}}),Text(visible = true, extent = {{ -30, -72},{30, -40}}, textString = "R=%R", fontName = "Arial"),Line(visible = true, points = {{ -74,0},{ -80,0},{ -60,0}}, color = {127,255,127}),Line(visible = true, points = {{ -80, -20},{ -60, -20},{ -60, -16},{ -40, -8},{ -4, -8}}, color = {127,255,127}),Line(visible = true, points = {{80,0},{60,0}}, color = {127,255,127}),Line(visible = true, points = {{ -60,2},{ -60, -4}}, color = {159,223,159}),Line(visible = true, points = {{ -4,2},{ -4, -18}}, color = {127,255,127}),Line(visible = true, points = {{4,2},{4, -18}}, color = {127,255,127}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -60,40},{60,80}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -92,0},{ -80,0}}, color = {127,127,255}),Line(visible = true, points = {{90,0},{80,0},{80,0}}, color = {127,127,255}),Line(visible = true, points = {{4, -8},{40, -8},{60, -4}}, color = {127,255,127}),Line(visible = true, points = {{60,0},{60, -4}}, color = {127,255,127}),Line(visible = true, points = {{60, -16},{60, -20},{80, -20}}, color = {127,255,127})}));
//             Modelica.Blocks.Sources.BooleanPulse BooleanPulse1(period = clock) annotation(Placement(visible = true, transformation(origin = {0,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = R * clock) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//             Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch IdealCommutingSwitch1 annotation(Placement(visible = true, transformation(origin = { -50,0}, extent = {{ -10, -10},{10,10}}, rotation =  -180)));
//             Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch IdealCommutingSwitch2 annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -60, -26}, extent = {{ -6, -6},{6,6}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground Ground2 annotation(Placement(visible = true, transformation(origin = {60, -26}, extent = {{ -6, -6},{6,6}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = { -102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100,4.44089e-16}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,2}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//           equation 
//             connect(IdealCommutingSwitch1.p,Capacitor1.p) annotation(Line(visible = true, points = {{ -40,0},{ -20,0}}, color = {0,0,255}));
//             connect(Capacitor1.n,IdealCommutingSwitch2.p) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {0,0,255}));
//             connect(IdealCommutingSwitch2.control,BooleanPulse1.y) annotation(Line(visible = true, points = {{50,8},{50,30},{20,30},{20,60},{11,60}}, color = {255,0,255}));
//             connect(IdealCommutingSwitch1.control,BooleanPulse1.y) annotation(Line(visible = true, points = {{ -50, -8},{ -50,30},{20,30},{20,60},{11,60}}, color = {255,0,255}));
//             connect(Ground2.p,IdealCommutingSwitch2.n2) annotation(Line(visible = true, points = {{60, -20},{60,0}}, color = {0,0,255}));
//             connect(IdealCommutingSwitch2.n1,n2) annotation(Line(visible = true, points = {{60,5},{80,5},{80,0},{100,4.44089e-16}}, color = {0,0,255}));
//             connect(n1,IdealCommutingSwitch1.n2) annotation(Line(visible = true, points = {{ -102,0},{ -60,0}}, color = {0,0,255}));
//             connect(Ground1.p,IdealCommutingSwitch1.n1) annotation(Line(visible = true, points = {{ -60, -20},{ -60, -5}}, color = {0,0,255}));
//           end Rn;
//           annotation(uses(Modelica(version = "2.2")), experiment(StopTime = 60, NumberOfIntervals = 1500), experimentSetupOutput, Documentation(revisions = "<html>
// <ul>
// <li><i>January 13, 2006</i> 
//        by Christoph Clauss<br>
//        included into Modelica Standard Library</li>
// <li><i>September 15, 2005</i>
//        by by Peter Trappe designed and by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </html>", info = "<html>
// The example CauerLowPassSC is a low-pass-filter of the fifth order. It is realized
// using an switched-capacitor network with operational amplifiers. The voltage source V is the input voltage (step),
// and the OP5.out.v is the filter output voltage. The pulse response is calculated.
// <p>
// This model is identical to the CauerLowPassAnalog example, but inverting. To get the same response
// as that of the CauerLowPassAnalog example, a negative voltage step is used as input.
// <p>
// This model is identical to the CauerLowPassOPV example. But the resistors are realized by
// switched capacitors. There are two such resistors Rp (of value +1), and Rn (of value -1).
// In this models the switching clock source is included. In a typical switched capacitor circuit
// there would be a central clock source.
// <p>
// The simulation end time should be 60. Please plot both V.v (which is the inverted input voltage) and OP5.p.v (output voltage). Compare this result with the CauerLowPassAnalog result.
// <p>
// Due to the recharging of the capacitances after switching the performance of simulation is not as good as in the CauerLowPassOPV example.
// <p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -96, -49},{77,3}}, textString = "Example", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,73},{120,132}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -250,200},{250, -200}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,140},{94,180}}, textString = "CauerLowPassSC", fontName = "Arial")}));
//           parameter Real l1 = 1.304;
//           parameter Real l2 = 0.8586;
//           parameter Real c1 = 1.072;
//           parameter Real c2 = 1 / (1.704992 ^ 2 * l1);
//           parameter Real c3 = 1.682;
//           parameter Real c4 = 1 / (1.179945 ^ 2 * l2);
//           parameter Real c5 = 0.7262;
//           Modelica.Electrical.Analog.Basic.Capacitor C1(C = c1 + c2) annotation(Placement(visible = true, transformation(origin = { -183,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C2(C = c2) annotation(Placement(visible = true, transformation(origin = { -231, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C3(C = l1) annotation(Placement(visible = true, transformation(origin = { -81,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C4(C = c4) annotation(Placement(visible = true, transformation(origin = { -21,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C5(C = c2) annotation(Placement(visible = true, transformation(origin = { -21, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op1 annotation(Placement(visible = true, transformation(origin = { -181, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G annotation(Placement(visible = true, transformation(origin = { -182, -68}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op2 annotation(Placement(visible = true, transformation(origin = { -81, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op3 annotation(Placement(visible = true, transformation(origin = {25, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G1 annotation(Placement(visible = true, transformation(origin = { -81, -68}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C6(C = c2 + c3 + c4) annotation(Placement(visible = true, transformation(origin = {18,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op4 annotation(Placement(visible = true, transformation(origin = {119, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin Op5 annotation(Placement(visible = true, transformation(origin = {219, -30}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C7(C = l2) annotation(Placement(visible = true, transformation(origin = {119,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C8(C = c4) annotation(Placement(visible = true, transformation(origin = {169, -120}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor C9(C = c4 + c5) annotation(Placement(visible = true, transformation(origin = {217,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G2 annotation(Placement(visible = true, transformation(origin = {18, -68}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G3 annotation(Placement(visible = true, transformation(origin = {119, -68}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G4 annotation(Placement(visible = true, transformation(origin = {219, -68}, extent = {{ -7, -8},{7,8}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.StepVoltage V(startTime = 1) annotation(Placement(visible = true, transformation(origin = { -241, -150}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -241, -176}, extent = {{ -6, -6},{6,6}}, rotation = 0)));
//           Rn R4(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -130, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rn R5(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -130, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rn R8(clock = 0.1) annotation(Placement(visible = true, transformation(origin = {70,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rn R9(clock = 0.1) annotation(Placement(visible = true, transformation(origin = {70, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R1(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -230, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R2(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -230,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R3(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -190,80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp Rp1(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -22,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R7(clock = 0.1) annotation(Placement(visible = true, transformation(origin = { -22, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R10(clock = 0.1) annotation(Placement(visible = true, transformation(origin = {170, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rp R11(clock = 0.1) annotation(Placement(visible = true, transformation(origin = {218,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Modelica.Electrical.Analog.Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = { -213, -20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = { -213,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n3 annotation(Placement(visible = true, transformation(origin = { -213,40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n4 annotation(Placement(visible = true, transformation(origin = { -161,40}, extent = {{2,2},{ -2, -2}}, rotation =  -180)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n5 annotation(Placement(visible = true, transformation(origin = { -113, -30}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p1 annotation(Placement(visible = true, transformation(origin = { -152, -120}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n6 annotation(Placement(visible = true, transformation(origin = { -61,40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n7 annotation(Placement(visible = true, transformation(origin = { -5, -30}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n8 annotation(Placement(visible = true, transformation(origin = { -5,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p2 annotation(Placement(visible = true, transformation(origin = { -5,40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin out1 annotation(Placement(visible = true, transformation(origin = {45, -120}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p3 annotation(Placement(visible = true, transformation(origin = {59,80}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n9 annotation(Placement(visible = true, transformation(origin = {87,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n10 annotation(Placement(visible = true, transformation(origin = {87, -30}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n11 annotation(Placement(visible = true, transformation(origin = {139,40}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n12 annotation(Placement(visible = true, transformation(origin = {239,60}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n13 annotation(Placement(visible = true, transformation(origin = {239,20}, extent = {{ -2, -2},{2,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p4 annotation(Placement(visible = true, transformation(origin = {190,20}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n14 annotation(Placement(visible = true, transformation(origin = {190, -30}, extent = {{ -3, -2},{3,2}}, rotation = 0)));
// 
//         equation 
//           connect(R11.n1,p4) annotation(Line(visible = true, points = {{207.8,60},{190,60},{190,20}}, color = {0,0,255}));
//           connect(R11.n2,n12) annotation(Line(visible = true, points = {{228,60.2},{234,60.2},{234,60},{239,60}}, color = {0,0,255}));
//           connect(R10.n2,n14) annotation(Line(visible = true, points = {{180, -29.8},{186, -29.8},{186, -30},{190, -30}}, color = {0,0,255}));
//           connect(R10.n1,Op4.out) annotation(Line(visible = true, points = {{159.8, -30},{139, -30}}, color = {0,0,255}));
//           connect(R7.n2,n7) annotation(Line(visible = true, points = {{ -12, -29.8},{ -8, -29.8},{ -8, -30},{ -5, -30}}, color = {0,0,255}));
//           connect(Op2.out,R7.n1) annotation(Line(visible = true, points = {{ -61, -30},{ -32.2, -30}}, color = {0,0,255}));
//           connect(Rp1.n1,n11) annotation(Line(visible = true, points = {{ -32.2,20},{ -52,20},{ -52,100},{139,100},{139,40}}, color = {0,0,255}));
//           connect(Rp1.n2,n8) annotation(Line(visible = true, points = {{ -12,20.2},{ -8,20.2},{ -8,20},{ -5,20}}, color = {0,0,255}));
//           connect(R3.n2,n4) annotation(Line(visible = true, points = {{ -180,80.2},{ -170,80.2},{ -170,80},{ -161,80},{ -161,40}}, color = {0,0,255}));
//           connect(R3.n1,n3) annotation(Line(visible = true, points = {{ -200.2,80},{ -213,80},{ -213,40}}, color = {0,0,255}));
//           connect(R2.n1,n6) annotation(Line(visible = true, points = {{ -240.2,20},{ -240,20},{ -240,100},{ -61,100},{ -61,40}}, color = {0,0,255}));
//           connect(R2.n2,n2) annotation(Line(visible = true, points = {{ -220,20.2},{ -218,20.2},{ -218,20},{ -213,20}}, color = {0,0,255}));
//           connect(R1.n2,n1) annotation(Line(visible = true, points = {{ -220, -19.8},{ -216, -19.8},{ -216, -20},{ -213, -20}}, color = {0,0,255}));
//           connect(R1.n1,V.n) annotation(Line(visible = true, points = {{ -240.2, -20},{ -250, -20},{ -250, -130},{ -241, -130},{ -241, -160}}, color = {0,0,255}));
//           connect(R9.n2,n10) annotation(Line(visible = true, points = {{80, -29.8},{84, -29.8},{84, -30},{87, -30}}, color = {0,0,255}));
//           connect(Op3.out,R9.n1) annotation(Line(visible = true, points = {{45, -30},{59.8, -30}}, color = {0,0,255}));
//           connect(R8.n2,n9) annotation(Line(visible = true, points = {{80,20.2},{84,20.2},{84,20},{87,20}}, color = {0,0,255}));
//           connect(p3,R8.n1) annotation(Line(visible = true, points = {{59,80},{59.8,80},{59.8,20}}, color = {0,0,255}));
//           connect(R5.n2,n5) annotation(Line(visible = true, points = {{ -120, -69.8},{ -116, -69.8},{ -116, -70},{ -113, -70},{ -113, -30}}, color = {0,0,255}));
//           connect(R5.n1,p1) annotation(Line(visible = true, points = {{ -140.2, -70},{ -152, -70},{ -152, -120}}, color = {0,0,255}));
//           connect(Op1.out,R4.n1) annotation(Line(visible = true, points = {{ -161, -30},{ -140.2, -30}}, color = {0,0,255}));
//           connect(R4.n2,n5) annotation(Line(visible = true, points = {{ -120, -29.8},{ -116, -29.8},{ -116, -30},{ -113, -30}}, color = {0,0,255}));
//           connect(V.p,Ground1.p) annotation(Line(visible = true, points = {{ -241, -140},{ -241, -170}}, color = {0,0,255}));
//           connect(Op5.in_p,G4.p) annotation(Line(visible = true, points = {{199, -40},{199, -60},{219, -60}}, color = {0,0,255}));
//           connect(Op4.in_p,G3.p) annotation(Line(visible = true, points = {{99, -40},{99, -60},{119, -60}}, color = {0,0,255}));
//           connect(C8.n,n14) annotation(Line(visible = true, points = {{179, -120},{190, -120},{190, -30}}, color = {0,0,255}));
//           connect(Op5.in_n,n14) annotation(Line(visible = true, points = {{199, -20},{190, -20},{190, -30}}, color = {0,0,255}));
//           connect(p4,n14) annotation(Line(visible = true, points = {{190,20},{190, -30}}, color = {0,0,255}));
//           connect(C9.p,p4) annotation(Line(visible = true, points = {{207,20},{190,20}}, color = {0,0,255}));
//           connect(n13,Op5.out) annotation(Line(visible = true, points = {{239,20},{239, -30}}, color = {0,0,255}));
//           connect(n12,n13) annotation(Line(visible = true, points = {{239,60},{239,20}}, color = {0,0,255}));
//           connect(C9.n,n13) annotation(Line(visible = true, points = {{227,20},{239,20}}, color = {0,0,255}));
//           connect(p3,n12) annotation(Line(visible = true, points = {{59,80},{239,80},{239,60}}, color = {0,0,255}));
//           connect(G2.p,Op3.in_p) annotation(Line(visible = true, points = {{18, -60},{5, -60},{5, -40}}, color = {0,0,255}));
//           connect(n11,Op4.out) annotation(Line(visible = true, points = {{139,40},{139, -30}}, color = {0,0,255}));
//           connect(C7.n,n11) annotation(Line(visible = true, points = {{129,40},{139,40}}, color = {0,0,255}));
//           connect(n9,C7.p) annotation(Line(visible = true, points = {{87,20},{87,40},{109,40}}, color = {0,0,255}));
//           connect(n10,Op4.in_n) annotation(Line(visible = true, points = {{87, -30},{87, -20},{99, -20}}, color = {0,0,255}));
//           connect(n9,n10) annotation(Line(visible = true, points = {{87,20},{87, -30}}, color = {0,0,255}));
//           connect(C4.p,p3) annotation(Line(visible = true, points = {{ -31,60},{ -41,60},{ -41,80},{59,80}}, color = {0,0,255}));
//           connect(out1,C8.p) annotation(Line(visible = true, points = {{45, -120},{159, -120}}, color = {0,0,255}));
//           connect(p1,out1) annotation(Line(visible = true, points = {{ -152, -120},{45, -120}}, color = {0,0,255}));
//           connect(Op3.out,out1) annotation(Line(visible = true, points = {{45, -30},{45, -120}}, color = {0,0,255}));
//           connect(C6.n,Op3.out) annotation(Line(visible = true, points = {{28,40},{45,40},{45, -30}}, color = {0,0,255}));
//           connect(C4.n,p2) annotation(Line(visible = true, points = {{ -11,60},{ -5,60},{ -5,40}}, color = {0,0,255}));
//           connect(n8,p2) annotation(Line(visible = true, points = {{ -5,20},{ -5,40}}, color = {0,0,255}));
//           connect(C6.p,p2) annotation(Line(visible = true, points = {{8,40},{ -5,40}}, color = {0,0,255}));
//           connect(n7,n8) annotation(Line(visible = true, points = {{ -5, -30},{ -5,20}}, color = {0,0,255}));
//           connect(C5.n,n7) annotation(Line(visible = true, points = {{ -11, -90},{ -5, -90},{ -5, -30}}, color = {0,0,255}));
//           connect(n7,Op3.in_n) annotation(Line(visible = true, points = {{ -5, -30},{ -5, -20},{5, -20}}, color = {0,0,255}));
//           connect(n6,Op2.out) annotation(Line(visible = true, points = {{ -61,40},{ -61, -30}}, color = {0,0,255}));
//           connect(C3.n,n6) annotation(Line(visible = true, points = {{ -71,40},{ -61,40}}, color = {0,0,255}));
//           connect(C2.p,p1) annotation(Line(visible = true, points = {{ -241, -60},{ -241, -120},{ -152, -120}}, color = {0,0,255}));
//           connect(C3.p,n5) annotation(Line(visible = true, points = {{ -91,40},{ -113,40},{ -113, -30}}, color = {0,0,255}));
//           connect(n5,Op2.in_n) annotation(Line(visible = true, points = {{ -113, -30},{ -113, -20},{ -101, -20}}, color = {0,0,255}));
//           connect(C5.p,Op1.out) annotation(Line(visible = true, points = {{ -31, -90},{ -161, -90},{ -161, -30}}, color = {0,0,255}));
//           connect(n4,Op1.out) annotation(Line(visible = true, points = {{ -161,40},{ -161, -30}}, color = {0,0,255}));
//           connect(C1.n,n4) annotation(Line(visible = true, points = {{ -173,40},{ -161,40}}, color = {0,0,255}));
//           connect(n3,C1.p) annotation(Line(visible = true, points = {{ -213,40},{ -193,40}}, color = {0,0,255}));
//           connect(n2,n3) annotation(Line(visible = true, points = {{ -213,20},{ -213,40}}, color = {0,0,255}));
//           connect(n1,n2) annotation(Line(visible = true, points = {{ -213, -20},{ -213,20}}, color = {0,0,255}));
//           connect(C2.n,n1) annotation(Line(visible = true, points = {{ -221, -60},{ -213, -60},{ -213, -20}}, color = {0,0,255}));
//           connect(n1,Op1.in_n) annotation(Line(visible = true, points = {{ -213, -20},{ -201, -20}}, color = {0,0,255}));
//           connect(G1.p,Op2.in_p) annotation(Line(visible = true, points = {{ -81, -60},{ -81, -50},{ -101, -50},{ -101, -40}}, color = {0,0,255}));
//           connect(Op1.in_p,G.p) annotation(Line(visible = true, points = {{ -201, -40},{ -201, -50},{ -181, -50},{ -181, -60},{ -182, -60}}, color = {0,0,255}));
//         end CauerLowPassSC;
//         model CharacteristicIdealDiodes "Characteristic of ideal diodes"
//           extends Modelica.Icons.Example;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -88,48},{92,102}}, textString = "Characteristic Ideal Diodes", fontName = "Arial")}), Documentation(info = "<HTML>
// <P>
// Three examples of ideal diodes are shown:<br><br>
// the <b>totally ideal diode</b> (Ideal) with all parameters to be zero <br>
// the <b>nearly ideal diode</b> with <i>Ron=0.1</i> and <i>Goff=0.1</i> <br>
// the nearly ideal but <b>displaced diode</b> with <i>Vknee=5</i> and <i>Ron=0.1</i> and 
// <i>Goff=0.1</i> <br><br>
// The resistance and conductance are chosen untypically high since the slopes should
// be seen in the graphics.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Ideal.i versus Ideal.v <br>
// With_Ron_Goff.i versus With_Ron_Goff.v<br>
// With_Ron_Goff_Vknee.i versus With_Ron_Goff_Vknee.v<br>
// </P>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           annotation(Documentation(info = "<HTML>
// <P>
// Three examples of ideal diodes are shown:<br><br>
// the <b>totally ideal diode</b> (Ideal) with all parameters to be zero <br>
// the <b>nearly ideal diode</b> with <i>Ron=0.1</i> and <i>Goff=0.1</i> <br>
// the nearly ideal but <b>displaced diode</b> with <i>Vknee=5</i> and <i>Ron=0.1</i> and 
// <i>Goff=0.1</i> <br><br>
// The resistance and conductance are chosen untypically high since the slopes should
// be seen in the graphics.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Ideal.i versus Ideal.v <br>
// With_Ron_Goff.i versus With_Ron_Goff.v<br>
// With_Ron_Goff_Vknee.i versus With_Ron_Goff_Vknee.v<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 1));
//           Modelica.Electrical.Analog.Ideal.IdealDiode Ideal(Ron = 0, Goff = 0) annotation(Placement(visible = true, transformation(origin = {10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealDiode With_Ron_Goff(Ron = 0.1, Goff = 0.1) annotation(Placement(visible = true, transformation(origin = {10,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealDiode With_Ron_Goff_Vknee(Ron = 0.2, Goff = 0.2, Vknee = 5) annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = 10, offset =  -9) annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -40, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R1(R = 0.001) annotation(Placement(visible = true, transformation(origin = {70,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R2(R = 0.001) annotation(Placement(visible = true, transformation(origin = {70,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R3(R = 0.001) annotation(Placement(visible = true, transformation(origin = {70, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage2(V = 10, offset = 0) annotation(Placement(visible = true, transformation(origin = { -60,40}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage3(V = 10, offset = 0) annotation(Placement(visible = true, transformation(origin = { -20, -40}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
// 
//         equation 
//           connect(SineVoltage3.n,Ground1.p) annotation(Line(visible = true, points = {{ -20, -50},{ -20, -60},{ -40, -60}}, color = {0,0,255}));
//           connect(With_Ron_Goff_Vknee.p,SineVoltage3.p) annotation(Line(visible = true, points = {{0, -30},{ -20, -30}}, color = {0,0,255}));
//           connect(SineVoltage1.p,With_Ron_Goff.p) annotation(Line(visible = true, points = {{ -40,10},{0,10}}, color = {0,0,255}));
//           connect(SineVoltage2.n,Ground1.p) annotation(Line(visible = true, points = {{ -60,30},{ -60, -60},{ -40, -60}}, color = {0,0,255}));
//           connect(SineVoltage2.p,Ideal.p) annotation(Line(visible = true, points = {{ -60,50},{0,50}}, color = {0,0,255}));
//           connect(R3.n,Ground1.p) annotation(Line(visible = true, points = {{80, -30},{80, -60},{ -40, -60}}, color = {0,0,255}));
//           connect(R2.n,R3.n) annotation(Line(visible = true, points = {{80,10},{80, -30}}, color = {0,0,255}));
//           connect(R1.n,R2.n) annotation(Line(visible = true, points = {{80,50},{80,10}}, color = {0,0,255}));
//           connect(With_Ron_Goff_Vknee.n,R3.p) annotation(Line(visible = true, points = {{20, -30},{60, -30}}, color = {0,0,255}));
//           connect(With_Ron_Goff.n,R2.p) annotation(Line(visible = true, points = {{20,10},{60,10}}, color = {0,0,255}));
//           connect(Ideal.n,R1.p) annotation(Line(visible = true, points = {{20,50},{60,50}}, color = {0,0,255}));
//           connect(Ground1.p,SineVoltage1.n) annotation(Line(visible = true, points = {{ -40, -60},{ -40, -10}}, color = {0,0,255}));
//         end CharacteristicIdealDiodes;
//         model CharacteristicThyristors "Characteristic of ideal thyristors"
//           extends Modelica.Icons.Example;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -96,60},{98,100}}, textString = "Characteristic Thyristors", fontName = "Arial")}), Documentation(info = "<HTML>
// <P>
// Two examples of thyristors are shown:<br><br>
// the <b>ideal thyristor</b>  <br>
// and the <b>ideal GTO thyristor</b>  with <i>Vknee=5</i>  <br><br>
// </P>
// <P>
// Simulate until T=2 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// IdealThyristor1.i and IdealGTOThyristor1.i <br>
// IdealThyristor1.v and IdealGTOThyristor1.v <br>
// </P>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           annotation(Documentation(info = "<HTML>
// <P>
// Two examples of thyristors are shown:<br><br>
// the <b>ideal thyristor</b>  <br>
// and the <b>ideal GTO thyristor</b>  with <i>Vknee=5</i>  <br><br>
// </P>
// <P>
// Simulate until T=2 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// IdealThyristor1.i and IdealGTOThyristor1.i <br>
// IdealThyristor1.v and IdealGTOThyristor1.v <br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 2));
//           Modelica.Electrical.Analog.Ideal.IdealThyristor IdealThyristor1(Vknee = 5) annotation(Placement(visible = true, transformation(origin = { -10,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = 10, offset = 0) annotation(Placement(visible = true, transformation(origin = { -40, -10}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -40, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R3(R = 0.001) annotation(Placement(visible = true, transformation(origin = {50,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep1(startValue = false, startTime = 1.25) annotation(Placement(visible = true, transformation(origin = { -50,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealGTOThyristor IdealGTOThyristor1(Vknee = 0) annotation(Placement(visible = true, transformation(origin = { -10, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R1(R = 0.001) annotation(Placement(visible = true, transformation(origin = {50, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(IdealGTOThyristor1.fire,IdealThyristor1.fire) annotation(Line(visible = true, points = {{ -3, -9},{ -3, -2.5},{ -2, -2.5},{ -2,5},{ -3,5},{ -3,21}}, color = {255,0,255}));
//           connect(IdealGTOThyristor1.p,IdealThyristor1.p) annotation(Line(visible = true, points = {{ -20, -20},{ -20,10}}, color = {0,0,255}));
//           connect(R1.n,Ground1.p) annotation(Line(visible = true, points = {{60, -20},{60, -40},{ -40, -40}}, color = {0,0,255}));
//           connect(R3.n,R1.n) annotation(Line(visible = true, points = {{60,10},{60, -20}}, color = {0,0,255}));
//           connect(IdealGTOThyristor1.n,R1.p) annotation(Line(visible = true, points = {{0, -20},{40, -20}}, color = {0,0,255}));
//           connect(BooleanStep1.y,IdealThyristor1.fire) annotation(Line(visible = true, points = {{ -39,50},{ -3,50},{ -3,21}}, color = {255,0,255}));
//           connect(SineVoltage1.p,IdealThyristor1.p) annotation(Line(visible = true, points = {{ -40, -20},{ -40,10},{ -20,10}}, color = {0,0,255}));
//           connect(Ground1.p,SineVoltage1.n) annotation(Line(visible = true, points = {{ -40, -40},{ -40,0}}, color = {0,0,255}));
//           connect(IdealThyristor1.n,R3.p) annotation(Line(visible = true, points = {{0,10},{40,10}}, color = {0,0,255}));
//         end CharacteristicThyristors;
//         encapsulated model ChuaCircuit "Chua's circuit, ns, V, A"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 50000.0), Documentation(info = "<html>
// <p>
//  Chua's circuit is the most simple nonlinear circuit which shows chaotic behaviour. The circuit consists of linear basic elements (capacitors, resistor, conductor, inductor), and one nonlinear element, which is called Chua's diode. The chaotic behaviour is simulated.
// <p>
// The simulation end time should be set to 5e4. To get the chaotic behaviour please plot C1.v. Choose C2.v as the independent variable.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Kennedy, M.P.: Three Steps to Chaos - Part I: Evolution. IEEE Transactions on CAS I 40 (1993)10, 640-656
// </dd>
// </dl>
//  
// </HTML>
// ", revisions = "<html>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Basic.Conductor G(G = 0.565) annotation(Placement(visible = true, transformation(origin = {0.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Basic.Ground Gnd annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Basic.Inductor L(L = 18) annotation(Placement(visible = true, transformation(origin = { -50.0,20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Basic.Resistor Ro(R = 0.0125) annotation(Placement(visible = true, transformation(origin = { -50.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Utilities.NonlinearResistor Nr(Ga(min =  -1) =  -0.757576, Gb(min =  -1) =  -0.409091, Ve = 1) annotation(Placement(visible = true, transformation(origin = {47.8454, -0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Basic.Capacitor C1(C = 10, v(start = 4)) annotation(Placement(visible = true, transformation(origin = {20.0, -0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Basic.Capacitor C2(C = 100) annotation(Placement(visible = true, transformation(origin = { -20.0, -0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(L.p,G.p) annotation(Line(visible = true, origin = { -36.6667,36.6667}, points = {{ -13.333, -6.667},{ -13.333,3.333},{26.667,3.333}}, color = {0,0,255}));
//           connect(L.n,Ro.p) annotation(Line(visible = true, origin = { -50.0, -0.0}, points = {{0.0,10.0},{0.0, -10.0}}, color = {0,0,255}));
//           connect(Ro.n,Gnd.p) annotation(Line(visible = true, origin = { -25.0, -42.9994}, points = {{ -25.0,12.999},{ -25.0, -2.999},{25.0, -2.999},{25.0, -7.001}}, color = {0,0,255}));
//           connect(G.p,C2.p) annotation(Line(visible = true, origin = { -16.6667,30.0}, points = {{6.667,10.0},{ -3.333,10.0},{ -3.333, -20.0}}, color = {0,0,255}));
//           connect(Nr.n,Gnd.p) annotation(Line(visible = true, origin = {23.9227, -37.9994}, points = {{23.923,27.999},{23.923, -7.999},{ -23.923, -7.999},{ -23.923, -12.001}}, color = {0,0,255}));
//           connect(C1.p,G.n) annotation(Line(visible = true, origin = {16.6667,30.0}, points = {{3.333, -20.0},{3.333,10.0},{ -6.667,10.0}}, color = {0,0,255}));
//           connect(C1.n,Gnd.p) annotation(Line(visible = true, origin = {10.0, -37.9994}, points = {{10.0,27.999},{10.0, -7.999},{ -10.0, -7.999},{ -10.0, -12.001}}, color = {0,0,255}));
//           connect(G.n,Nr.p) annotation(Line(visible = true, origin = {35.2303,30.0}, points = {{ -25.23,10.0},{12.615,10.0},{12.615, -20.0}}, color = {0,0,255}));
//           connect(C2.n,Gnd.p) annotation(Line(visible = true, origin = { -10.0, -37.9994}, points = {{ -10.0,27.999},{ -10.0, -7.999},{10.0, -7.999},{10.0, -12.001}}, color = {0,0,255}));
//         end ChuaCircuit;
//         encapsulated model DifferenceAmplifier "Simple NPN transistor amplifier circuit"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Sources;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1e-08), Documentation(info = "<html>
// <p>
// It is a simple NPN transistor amplifier circuit. The voltage difference between R1.p and R3.n is amplified. The output signal is the voltage between R2.n and R4.n. In this example the voltage at V1 is amplified because R3.n is grounded.
// <p>
// The simulation end time should be set to 1e- 8. Please plot the input voltage V1.v, and the output voltages R2.n.v, and R4.n.v.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 59
// </dd>
// </dl>
//  
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Basic.Resistor R1(R = 0.0001) annotation(Placement(visible = true, transformation(origin = { -80, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Resistor R3(R = 0.0001) annotation(Placement(visible = true, transformation(origin = {80, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Capacitor C4(C = 1e-10) annotation(Placement(visible = true, transformation(origin = {20, -4}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Capacitor C2(C = 1e-10) annotation(Placement(visible = true, transformation(origin = { -20, -4}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Ground Gnd1 annotation(Placement(visible = true, transformation(origin = { -90, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd9 annotation(Placement(visible = true, transformation(origin = {80,25}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd3 annotation(Placement(visible = true, transformation(origin = { -10, -15}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd2 annotation(Placement(visible = true, transformation(origin = { -60, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd6 annotation(Placement(visible = true, transformation(origin = {10, -15}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd7 annotation(Placement(visible = true, transformation(origin = { -10, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd8 annotation(Placement(visible = true, transformation(origin = {10, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd5 annotation(Placement(visible = true, transformation(origin = {60, -75}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd4 annotation(Placement(visible = true, transformation(origin = {90, -45}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Utilities.Transistor Transistor1 annotation(Placement(visible = true, transformation(origin = { -50, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Utilities.Transistor Transistor2 annotation(Placement(visible = true, transformation(origin = {50, -10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Sources.RampCurrent I1(I = 0.16, duration = 1e-09) annotation(Placement(visible = true, transformation(origin = { -10, -50}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Sources.ExpSineVoltage V1(V = 0.2, freqHz = 200000000.0, damping = 10000000.0) annotation(Placement(visible = true, transformation(origin = { -90, -50}, extent = {{ -10, -10},{10,10}}, rotation = 2790)));
//           Sources.RampVoltage V2(V = 15, duration = 1e-09) annotation(Placement(visible = true, transformation(origin = {80,50}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Basic.Resistor R2(R = 100) annotation(Placement(visible = true, transformation(origin = { -40,30}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Basic.Resistor R4(R = 100) annotation(Placement(visible = true, transformation(origin = {40,30}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Basic.Capacitor C5(C = 1e-10) annotation(Placement(visible = true, transformation(origin = {10, -50}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Basic.Capacitor C3(C = 1e-10) annotation(Placement(visible = true, transformation(origin = {60, -50}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Basic.Capacitor C1(C = 1e-10) annotation(Placement(visible = true, transformation(origin = { -60, -50}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
// 
//         equation 
//           connect(C4.n,Transistor2.c) annotation(Line(visible = true, points = {{30.0, -4.0},{40.0, -4.0}}, color = {0,0,255}));
//           connect(Transistor2.b,R3.p) annotation(Line(visible = true, points = {{60.0, -10.0},{70.0, -10.0}}, color = {0,0,255}));
//           connect(Transistor1.c,C2.p) annotation(Line(visible = true, points = {{ -40.0, -4.0},{ -30.0, -4.0}}, color = {0,0,255}));
//           connect(R1.n,Transistor1.b) annotation(Line(visible = true, points = {{ -70.0, -10.0},{ -60.0, -10.0}}, color = {0,0,255}));
//           connect(C4.p,Gnd6.p) annotation(Line(visible = true, points = {{10.0, -4.0},{10.0, -10.0}}, color = {0,0,255}));
//           connect(C2.n,Gnd3.p) annotation(Line(visible = true, points = {{ -10.0, -4.0},{ -10.0, -10.0}}, color = {0,0,255}));
//           connect(R3.n,Gnd4.p) annotation(Line(visible = true, points = {{90.0, -10.0},{90.0, -40.0}}, color = {0,0,255}));
//           connect(I1.n,Gnd7.p) annotation(Line(visible = true, points = {{ -10.0, -60.0},{ -10.0, -70.0}}, color = {0,0,255}));
//           connect(Transistor1.e,I1.p) annotation(Line(visible = true, points = {{ -40.0, -16.0},{ -30.0, -16.0},{ -30.0, -40.0},{ -10.0, -40.0}}, color = {0,0,255}));
//           connect(V1.n,Gnd1.p) annotation(Line(visible = true, points = {{ -90.0, -60.0},{ -90.0, -70.0}}, color = {0,0,255}));
//           connect(R1.p,V1.p) annotation(Line(visible = true, points = {{ -90.0, -10.0},{ -90.0, -40.0}}, color = {0,0,255}));
//           connect(V2.n,Gnd9.p) annotation(Line(visible = true, points = {{80.0,40.0},{80.0,30.0}}, color = {0,0,255}));
//           connect(R2.p,V2.p) annotation(Line(visible = true, points = {{ -40.0,40.0},{ -40.0,70.0},{80.0,70.0},{80.0,60.0}}, color = {0,0,255}));
//           connect(R2.n,Transistor1.c) annotation(Line(visible = true, points = {{ -40.0,20.0},{ -40.0, -4.0}}, color = {0,0,255}));
//           connect(R4.p,V2.p) annotation(Line(visible = true, points = {{40.0,40.0},{40.0,70.0},{80.0,70.0},{80.0,60.0}}, color = {0,0,255}));
//           connect(R4.n,Transistor2.c) annotation(Line(visible = true, points = {{40.0,20.0},{40.0, -4.0}}, color = {0,0,255}));
//           connect(C5.n,Gnd8.p) annotation(Line(visible = true, points = {{10.0, -60.0},{10.0, -70.0}}, color = {0,0,255}));
//           connect(I1.p,C5.p) annotation(Line(visible = true, points = {{ -10.0, -40.0},{10.0, -40.0}}, color = {0,0,255}));
//           connect(C5.p,Transistor2.e) annotation(Line(visible = true, points = {{10.0, -40.0},{30.0, -40.0},{30.0, -16.0},{40.0, -16.0}}, color = {0,0,255}));
//           connect(C3.n,Gnd5.p) annotation(Line(visible = true, points = {{60.0, -60.0},{60.0, -70.0}}, color = {0,0,255}));
//           connect(Transistor2.b,C3.p) annotation(Line(visible = true, points = {{60.0, -10.0},{60.0, -40.0}}, color = {0,0,255}));
//           connect(C1.n,Gnd2.p) annotation(Line(visible = true, points = {{ -60.0, -60.0},{ -60.0, -70.0}}, color = {0,0,255}));
//           connect(Transistor1.b,C1.p) annotation(Line(visible = true, points = {{ -60.0, -10.0},{ -60.0, -40.0}}, color = {0,0,255}));
//         end DifferenceAmplifier;
//         model HeatingMOSInverter "Heating MOS Inverter"
//           annotation(experiment(StopTime = 5), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,72},{ -6,100}}, textString = "Heating MOS Inverter", fontName = "Arial")}), Documentation(info = "<HTML>
// <P>
// The heating MOS inverter shows a heat flow always if a transistor is leading.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Sin.p.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and H_PMOS.heatPort.T and H_NMOS.heatPort.T<br>
// H_PMOS.heatPort.Q_flow and H_NMOS.heatPort.Q_flow<br>
// </P>
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
// by Christoph Clauss<br> realized<br>
// </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Modelica.Icons.Example;
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 0.01) annotation(Placement(visible = true, transformation(origin = {70.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -450)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC1(G = 0.01) annotation(Placement(visible = true, transformation(origin = {10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC2(G = 0.01) annotation(Placement(visible = true, transformation(origin = {10.0, -80.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.FixedTemperature FixedTemperature1(T = 300) annotation(Placement(visible = true, transformation(origin = {90.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC3(G = 0.01) annotation(Placement(visible = true, transformation(origin = {60.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G annotation(Placement(visible = true, transformation(origin = { -70, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Semiconductors.HeatingPMOS H_PMOS annotation(Placement(visible = true, transformation(origin = { -30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Semiconductors.HeatingNMOS H_NMOS annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage Sin(V = 5) annotation(Placement(visible = true, transformation(origin = { -70,8.32667e-16}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Sources.RampVoltage V(V = 5, duration = 0.01) annotation(Placement(visible = true, transformation(origin = {50,50}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 1e-05) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
// 
//         equation 
//           connect(TC3.port_a,HeatCapacitor1.port) annotation(Line(visible = true, origin = { -12.0,0.0}, points = {{62.0, -30.0},{52.0, -30.0},{52.0, -60.0},{72.0, -60.0}}, color = {191,0,0}));
//           connect(TC3.port_b,FixedTemperature1.port) annotation(Line(visible = true, origin = {75.0, -30.0}, points = {{ -5.0,0.0},{5.0,0.0}}, color = {191,0,0}));
//           connect(TC2.port_a,H_NMOS.heatPort) annotation(Line(visible = true, origin = { -20.0, -53.3333}, points = {{20.0, -26.6667},{ -10.0, -26.6667},{ -10.0,53.3333}}, color = {191,0,0}));
//           connect(TC1.port_a,H_PMOS.heatPort) annotation(Line(visible = true, points = {{ -0.0, -40.0},{ -10.0, -40.0},{ -10.0,40.0},{ -30.0,40.0}}, color = {191,0,0}));
//           connect(TC2.port_b,HeatCapacitor1.port) annotation(Line(visible = true, points = {{20.0, -80.0},{40.0, -80.0},{40.0, -60.0},{60.0, -60.0}}, color = {191,0,0}));
//           connect(TC1.port_b,HeatCapacitor1.port) annotation(Line(visible = true, points = {{20.0, -40.0},{40.0, -40.0},{40.0, -60.0},{60.0, -60.0}}, color = {191,0,0}));
//           connect(H_PMOS.B,H_PMOS.D) annotation(Line(visible = true, points = {{ -20.0,50.0},{ -20.0,55.0}}, color = {0,0,255}));
//           connect(H_NMOS.S,G.p) annotation(Line(visible = true, points = {{ -20.0,5.0},{ -20.0, -20.0},{ -70.0, -20.0}}, color = {0,0,255}));
//           connect(H_NMOS.B,H_NMOS.S) annotation(Line(visible = true, points = {{ -20.0,10.0},{ -20.0,5.0}}, color = {0,0,255}));
//           connect(H_PMOS.S,H_NMOS.D) annotation(Line(visible = true, points = {{ -20.0,45.0},{ -20.0,15.0}}, color = {0,0,255}));
//           connect(H_NMOS.G,H_PMOS.G) annotation(Line(visible = true, points = {{ -40.0,5.0},{ -40.0,45.0}}, color = {0,0,255}));
//           connect(Sin.n,G.p) annotation(Line(visible = true, points = {{ -70, -10},{ -70, -20}}, color = {0,0,255}));
//           connect(H_NMOS.G,Sin.p) annotation(Line(visible = true, points = {{ -40.0,5.0},{ -40.0,10.0},{ -70.0,10.0}}, color = {0,0,255}));
//           connect(V.p,H_PMOS.D) annotation(Line(visible = true, points = {{50.0,60.0},{ -20.0,60.0},{ -20.0,55.0}}, color = {0,0,255}));
//           connect(V.n,G.p) annotation(Line(visible = true, points = {{50,40},{50, -20},{ -70, -20}}, color = {0,0,255}));
//           connect(Capacitor1.n,G.p) annotation(Line(visible = true, points = {{30,0},{30, -20},{ -70, -20}}, color = {0,0,255}));
//           connect(H_NMOS.D,Capacitor1.p) annotation(Line(visible = true, points = {{ -20.0,15.0},{ -20.0,20.0},{30.0,20.0}}, color = {0,0,255}));
//           annotation(Documentation(info = "<HTML>
// <P>
// The heating MOS inverter shows a heat flow always if a transistor is leading.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Sin.p.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and H_PMOS.heatPort.T and H_NMOS.heatPort.T<br>
// H_PMOS.heatPort.Q_flow and H_NMOS.heatPort.Q_flow<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 5));
//         end HeatingMOSInverter;
//         model HeatingRectifier "Heating rectifier"
//           annotation(experiment(StopTime = 5), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -94,74},{0,102}}, textString = "HeatingRectifier", fontName = "Arial")}), Documentation(info = "<HTML>
// <P>
// The heating rectifier shows a heat flow always if the electrical capacitor is loaded.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// SineVoltage1.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and HeatingDiode1.heatPort.T<br>
// HeatingDiode1.heatPort.Q_flow<br>
// </P>
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
// by Christoph Clauss<br> realized<br>
// </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Modelica.Icons.Example;
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 1) annotation(Placement(visible = true, transformation(origin = { -10.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor1(G = 10) annotation(Placement(visible = true, transformation(origin = { -10.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Semiconductors.HeatingDiode HeatingDiode1 annotation(Placement(visible = true, transformation(origin = { -10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground G annotation(Placement(visible = true, transformation(origin = { -70,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1 annotation(Placement(visible = true, transformation(origin = {30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R(R = 1) annotation(Placement(visible = true, transformation(origin = {30,80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1 annotation(Placement(visible = true, transformation(origin = { -70,40}, extent = {{ -10, -10},{10,10}}, rotation = 270)));
// 
//         equation 
//           connect(R.n,Capacitor1.n) annotation(Line(visible = true, points = {{40,80},{40,50}}, color = {0,0,255}));
//           connect(R.p,Capacitor1.p) annotation(Line(visible = true, points = {{20,80},{20,50}}, color = {0,0,255}));
//           connect(ThermalConductor1.port_b,HeatCapacitor1.port) annotation(Line(visible = true, points = {{ -10.0, -20.0},{ -10.0, -25.75},{ -10.0, -25.75},{ -10.0, -30.5},{ -10.0, -40.0},{ -10.0, -40.0}}, color = {191,0,0}));
//           connect(HeatingDiode1.heatPort,ThermalConductor1.port_a) annotation(Line(visible = true, points = {{ -10.0,40.0},{ -10.0,20.5},{ -10.0,0.0},{ -10.0,0.0}}, color = {191,0,0}));
//           connect(HeatingDiode1.n,Capacitor1.p) annotation(Line(visible = true, points = {{0,50},{20,50}}, color = {0,0,255}));
//           connect(Capacitor1.n,G.p) annotation(Line(visible = true, points = {{40,50},{40,20},{ -70,20}}, color = {0,0,255}));
//           connect(SineVoltage1.p,HeatingDiode1.p) annotation(Line(visible = true, points = {{ -70,50},{ -20,50}}, color = {0,0,255}));
//           connect(SineVoltage1.n,G.p) annotation(Line(visible = true, points = {{ -70,30},{ -70,20}}, color = {0,0,255}));
//           annotation(Documentation(info = "<HTML>
// <P>
// The heating rectifier shows a heat flow always if the electrical capacitor is loaded.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// SineVoltage1.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and HeatingDiode1.heatPort.T<br>
// HeatingDiode1.heatPort.Q_flow<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 5));
//         end HeatingRectifier;
//         encapsulated model NandGate "CMOS NAND Gate (see Tietze/Schenk, page 157)"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Sources;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1e-07), Documentation(info = "<html>
// <p>
// The nand gate is a basic CMOS building block. It consists of four CMOS transistors.
// The output voltage Nand.y.v is low if and only if the two input voltages at Nand.x1.v and Nand.x2.v
// are both high. In this way the nand functionality is realized.
// <p>
// The simulation end time should be set to 1e-7. Please plot the input voltages Nand.x1.v,
// d Nand.x2.v, and the output voltage Nand.y.v.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 157
// <p>
// </dd>
// </dl>
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Basic.Ground Gnd1 annotation(Placement(visible = true, transformation(origin = {50,48}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd4 annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Basic.Ground Gnd5 annotation(Placement(visible = true, transformation(origin = { -70, -50}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Utilities.Nand Nand annotation(Placement(visible = true, transformation(origin = {0,5}, extent = {{ -40, -50},{40,50}}, rotation = 0)));
//           Sources.TrapezoidVoltage VIN1(V = 3.5, startTime = 2e-08, rising = 1e-09, width = 1.9e-08, falling = 1e-09, period = 4e-08) annotation(Placement(visible = true, transformation(origin = { -70,20}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Sources.TrapezoidVoltage VIN2(V = 3.5, startTime = 1e-08, rising = 1e-09, width = 1.9e-08, falling = 1e-09, period = 4e-08) annotation(Placement(visible = true, transformation(origin = { -70, -30}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Sources.RampVoltage VDD(V = 5, duration = 1e-09) annotation(Placement(visible = true, transformation(origin = {50,70}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
// 
//         equation 
//           connect(VIN1.n,Gnd4.p) annotation(Line(visible = true, points = {{ -70.0,10.0},{ -70.0,5.0}}, color = {0,0,255}));
//           connect(VIN1.p,Nand.x1) annotation(Line(visible = true, points = {{ -70.0,30.0},{ -40.0,30.0}}, color = {0,0,255}));
//           connect(VIN2.n,Gnd5.p) annotation(Line(visible = true, points = {{ -70.0, -40.0},{ -70.0, -45.0}}, color = {0,0,255}));
//           connect(VIN2.p,Nand.x2) annotation(Line(visible = true, points = {{ -70.0, -20.0},{ -40.0, -20.0}}, color = {0,0,255}));
//           connect(VDD.n,Gnd1.p) annotation(Line(visible = true, points = {{50.0,60.0},{50.0,53.0}}, color = {0,0,255}));
//           connect(Nand.Vdd,VDD.p) annotation(Line(visible = true, points = {{0.0,55.0},{0.0,90.0},{50.0,90.0},{50.0,80.0}}, color = {0,0,255}));
//         end NandGate;
//         model Rectifier "B6 diode bridge"
//           extends Modelica.Icons.Example;
//           import Modelica.Electrical.Analog.Ideal;
//           parameter Modelica.SIunits.Voltage VAC = 400 "RMS line-to-line";
//           parameter Modelica.SIunits.Frequency f = 50 "line frequency";
//           parameter Modelica.SIunits.Inductance LAC = 6e-05 "line inductor";
//           parameter Modelica.SIunits.Resistance Ron = 0.001 "diode forward resistance";
//           parameter Modelica.SIunits.Conductance Goff = 0.001 "diode backward conductance";
//           parameter Modelica.SIunits.Voltage Vknee = 2 "diode threshold voltage";
//           parameter Modelica.SIunits.Capacitance CDC = 0.015 "DC capacitance";
//           parameter Modelica.SIunits.Current IDC = 500 "load current";
//           output Modelica.SIunits.Voltage uDC;
//           output Modelica.SIunits.Current iAC[3];
//           output Modelica.SIunits.Voltage uAC[3];
//           output Modelica.SIunits.Power Losses;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -80,70},{80,90}}, textString = "Rectifier", fontName = "Arial"),Line(visible = true, points = {{ -16,18},{ -16,2},{ -18,6},{ -14,6},{ -16,2}}),Line(visible = true, points = {{ -30,22},{ -26,20},{ -30,18},{ -30,22}}),Line(visible = true, points = {{32,30},{32, -30},{30, -26},{34, -26},{32, -30}}),Text(visible = true, extent = {{ -38,8},{ -22,16}}, textString = "iAC", fontName = "Arial"),Text(visible = true, extent = {{ -14,0},{2,8}}, textString = "uAC", fontName = "Arial"),Text(visible = true, extent = {{22, -24},{38, -16}}, textString = "uDC", fontName = "Arial")}), experiment(StopTime = 0.1, Interval = 1e-05), experimentSetupOutput(doublePrecision = true, states = false, derivatives = false, inputs = false, auxiliaries = false), Documentation(info = "<HTML>
// <P>
// The rectifier example shows a B6 diode bridge fed by a three phase sinusoidal voltage, loaded by a DC current.<br>
// DC capacitors start at ideal no-load voltage, thus making easier initial transient.
// </P>
// <P>
// Simulate until T=0.1 s.<br><br>
// Plot in separate windows:<br><br>
// uDC ... DC-voltage<br>
// iAC ... AC-currents 1..3<br>
// uAC ... AC-voltages 1..3 (distorted)<br>
// Try different load currents iDC = 0..approximately 500 A.
// </P>
// <p>
// You may watch Losses (of the whole diode bridge) trying different diode parameters.
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Anton Haumer<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage2(freqHz = f, phase =  -2 / 3 * Modelica.Constants.pi, V = VAC * sqrt(2 / 3)) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage3(freqHz = f, phase =  -4 / 3 * Modelica.Constants.pi, V = VAC * sqrt(2 / 3)) annotation(Placement(visible = true, transformation(origin = { -80, -20}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Inductor Inductor1(L = LAC) annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Inductor Inductor2(L = LAC) annotation(Placement(visible = true, transformation(origin = { -50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Inductor Inductor3(L = LAC) annotation(Placement(visible = true, transformation(origin = { -50, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = {50, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant Constant1(k = IDC) annotation(Placement(visible = true, transformation(origin = {90,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(freqHz = f, V = VAC * sqrt(2 / 3)) annotation(Placement(visible = true, transformation(origin = { -80,20}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor2(C = 2 * CDC) annotation(Placement(visible = true, transformation(origin = {40, -40}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Ideal.IdealDiode IdealDiode6(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {20, -40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Ideal.IdealDiode IdealDiode5(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {0, -40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Ideal.IdealDiode IdealDiode4(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = { -20, -40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Ideal.IdealDiode IdealDiode1(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = { -20,40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Ideal.IdealDiode IdealDiode2(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = { -2.77556e-16,40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Ideal.IdealDiode IdealDiode3(Ron = Ron, Goff = Goff, Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {20,40}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 2 * CDC) annotation(Placement(visible = true, transformation(origin = {40,40}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
//           Modelica.Electrical.Analog.Sources.SignalCurrent SignalCurrent1 annotation(Placement(visible = true, transformation(origin = {60,0}, extent = {{ -10, -10},{10,10}}, rotation = 1710)));
// 
//         initial equation 
//           Capacitor1.v = (VAC * sqrt(2)) / 2;
//           Capacitor2.v = (VAC * sqrt(2)) / 2;
// 
//         equation 
//           connect(SineVoltage3.p,Inductor3.p) annotation(Line(visible = true, points = {{ -70, -20},{ -60, -20}}, color = {0,0,255}));
//           connect(SineVoltage2.p,Inductor2.p) annotation(Line(visible = true, points = {{ -70,0},{ -60,0}}, color = {0,0,255}));
//           connect(SineVoltage2.n,SineVoltage3.n) annotation(Line(visible = true, points = {{ -90,0},{ -90, -20}}, color = {0,0,255}));
//           connect(SineVoltage1.n,SineVoltage2.n) annotation(Line(visible = true, points = {{ -90,20},{ -90,0}}, color = {0,0,255}));
//           connect(SineVoltage1.p,Inductor1.p) annotation(Line(visible = true, points = {{ -70,20},{ -60,20}}, color = {0,0,255}));
//           connect(Capacitor2.n,IdealDiode6.p) annotation(Line(visible = true, points = {{40, -50},{20, -50}}, color = {0,0,255}));
//           connect(IdealDiode5.p,IdealDiode6.p) annotation(Line(visible = true, points = {{ -3.06152e-15, -50},{20, -50}}, color = {0,0,255}));
//           connect(IdealDiode4.p,IdealDiode5.p) annotation(Line(visible = true, points = {{ -20, -50},{ -3.06152e-15, -50}}, color = {0,0,255}));
//           connect(IdealDiode1.p,IdealDiode4.n) annotation(Line(visible = true, points = {{ -20,30},{ -20, -30}}, color = {0,0,255}));
//           connect(Inductor1.n,IdealDiode1.p) annotation(Line(visible = true, points = {{ -40,20},{ -20,20},{ -20,30}}, color = {0,0,255}));
//           connect(IdealDiode2.p,IdealDiode5.n) annotation(Line(visible = true, points = {{ -3.33907e-15,30},{ -6.12303e-16,16},{0,0},{0, -30},{3.06152e-15, -30}}, color = {0,0,255}));
//           connect(IdealDiode1.n,IdealDiode2.n) annotation(Line(visible = true, points = {{ -20,50},{2.78396e-15,50}}, color = {0,0,255}));
//           connect(Inductor2.n,IdealDiode2.p) annotation(Line(visible = true, points = {{ -40,0},{ -6.12303e-16,0},{ -3.33907e-15,30}}, color = {0,0,255}));
//           connect(IdealDiode3.p,IdealDiode6.n) annotation(Line(visible = true, points = {{20,30},{20, -30}}, color = {0,0,255}));
//           connect(IdealDiode2.n,IdealDiode3.n) annotation(Line(visible = true, points = {{2.78396e-15,50},{20,50}}, color = {0,0,255}));
//           connect(Inductor3.n,IdealDiode3.p) annotation(Line(visible = true, points = {{ -40, -20},{20, -20},{20,30}}, color = {0,0,255}));
//           connect(IdealDiode3.n,Capacitor1.p) annotation(Line(visible = true, points = {{20,50},{40,50}}, color = {0,0,255}));
//           connect(Capacitor1.n,Capacitor2.p) annotation(Line(visible = true, points = {{40,30},{40, -30}}, color = {0,0,255}));
//           connect(Capacitor1.p,SignalCurrent1.p) annotation(Line(visible = true, points = {{40,50},{60,50},{60,10}}, color = {0,0,255}));
//           connect(SignalCurrent1.n,Capacitor2.n) annotation(Line(visible = true, points = {{60, -10},{60, -50},{40, -50}}, color = {0,0,255}));
//           connect(Constant1.y,SignalCurrent1.i) annotation(Line(visible = true, points = {{79,0},{79,4.28612e-16},{67,4.29087e-15}}, color = {0,0,255}));
//           connect(Capacitor2.p,Ground1.p) annotation(Line(visible = true, points = {{40, -30},{40,0},{50,0},{50, -60}}, color = {0,0,255}));
//           uDC = Capacitor1.v + Capacitor2.v;
//           iAC = {Inductor1.i,Inductor2.i,Inductor3.i};
//           uAC[1] = Inductor1.n.v - Inductor2.n.v;
//           uAC[2] = Inductor2.n.v - Inductor3.n.v;
//           uAC[3] = Inductor3.n.v - Inductor1.n.v;
//           Losses = IdealDiode1.v * IdealDiode1.i + IdealDiode2.v * IdealDiode2.i + IdealDiode3.v * IdealDiode3.i + IdealDiode4.v * IdealDiode4.i + IdealDiode5.v * IdealDiode5.i + IdealDiode6.v * IdealDiode6.i;
//         end Rectifier;
//         model ShowSaturatingInductor "Simple demo to show behaviour of SaturatingInductor component"
//           extends Modelica.Icons.Example;
//           parameter Modelica.SIunits.Inductance Lzer = 2;
//           parameter Modelica.SIunits.Inductance Lnom = 1;
//           parameter Modelica.SIunits.Current Inom = 1;
//           parameter Modelica.SIunits.Inductance Linf = 0.5;
//           parameter Modelica.SIunits.Voltage U = 1.25;
//           parameter Modelica.SIunits.Frequency f = 1 / (2 * Modelica.Constants.pi);
//           parameter Modelica.SIunits.Angle phase = Modelica.Constants.pi / 2;
//           output Modelica.SIunits.Voltage v;
//           output Modelica.SIunits.Current i;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 6.2832, Interval = 0.01), experimentSetupOutput(doublePrecision = true), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Basic.SaturatingInductor SaturatingInductance1(Lzer = Lzer, Lnom = Lnom, Inom = Inom, Linf = Linf) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{10, -10},{ -10,10}}, rotation =  -270)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -20, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = U, phase = phase, freqHz = f) annotation(Placement(visible = true, transformation(origin = { -20,10}, extent = {{ -10, -10},{10,10}}, rotation = 630)));
// 
//         equation 
//           connect(SaturatingInductance1.p,SineVoltage1.p) annotation(Line(visible = true, points = {{30,20},{30,30},{ -20,30},{ -20,20}}, color = {0,0,255}));
//           connect(SineVoltage1.n,Ground1.p) annotation(Line(visible = true, points = {{ -20,0},{ -20, -20}}, color = {0,0,255}));
//           connect(SineVoltage1.n,SaturatingInductance1.n) annotation(Line(visible = true, points = {{ -20,0},{ -20, -10},{30, -10},{30,0}}, color = {0,0,255}));
//           v = SaturatingInductance1.v;
//           i = SaturatingInductance1.i;
//         end ShowSaturatingInductor;
//         model ShowVariableResistor "Simple demo of a VariableResistor model"
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <P>
// It is a simple test circuit for the VariableResistor. The VariableResistor
// sould be compared with R2.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Teresa Schlegel<br> realized<br>
//        </li>
// </ul>
// </html>"), experiment(StopTime = 1), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -100,40},{80,112}}, textString = "Example VariableResistor", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           annotation(Diagram);
//           Modelica.Electrical.Analog.Basic.VariableResistor VariableResistor annotation(Placement(visible = true, transformation(origin = { -10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground2 annotation(Placement(visible = true, transformation(origin = {70, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R1 annotation(Placement(visible = true, transformation(origin = { -50,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R2 annotation(Placement(visible = true, transformation(origin = { -10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R3 annotation(Placement(visible = true, transformation(origin = {30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R4 annotation(Placement(visible = true, transformation(origin = { -50, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Resistor R5 annotation(Placement(visible = true, transformation(origin = {30, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1 annotation(Placement(visible = true, transformation(origin = { -90, -30}, extent = {{ -10, -10},{10,10}}, rotation = 450)));
//           Modelica.Blocks.Sources.Ramp Ramp1(height = 5, offset = 2) annotation(Placement(visible = true, transformation(origin = { -10,20}, extent = {{ -10, -10},{10,10}}, rotation = 1350)));
// 
//         equation 
//           connect(Ground2.p,R5.n) annotation(Line(visible = true, points = {{70, -20},{70, -10},{40, -10}}, color = {0,0,255}));
//           connect(R3.n,Ground2.p) annotation(Line(visible = true, points = {{40,50},{70,50},{70, -20}}, color = {0,0,255}));
//           connect(VariableResistor.n,R5.p) annotation(Line(visible = true, points = {{0, -10},{20, -10}}, color = {0,0,255}));
//           connect(R4.n,VariableResistor.p) annotation(Line(visible = true, points = {{ -40, -10},{ -20, -10}}, color = {0,0,255}));
//           connect(R2.n,R3.p) annotation(Line(visible = true, points = {{0,50},{20,50}}, color = {0,0,255}));
//           connect(R1.n,R2.p) annotation(Line(visible = true, points = {{ -40,50},{ -20,50}}, color = {0,0,255}));
//           connect(SineVoltage1.p,Ground1.p) annotation(Line(visible = true, points = {{ -90, -40},{ -90, -60}}, color = {0,0,255}));
//           connect(SineVoltage1.n,R1.p) annotation(Line(visible = true, points = {{ -90, -20},{ -90,50},{ -60,50}}, color = {0,0,255}));
//           connect(SineVoltage1.n,R4.p) annotation(Line(visible = true, points = {{ -90, -20},{ -90, -10},{ -60, -10}}, color = {0,0,255}));
//           connect(Ramp1.y,VariableResistor.R) annotation(Line(visible = true, points = {{ -10,9},{ -10,4.5},{ -10,1},{ -10,1}}, color = {0,0,255}));
//         end ShowVariableResistor;
//       end Examples;
//       package Basic "Basic electrical components such as resistor, capacitor, transformer"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains basic analog electrical components.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model Ground "Ground node"
//           annotation(Documentation(info = "<HTML>
// <P>
// Ground of an electrical circuit. The potential at the
// ground node is zero. Every electrical circuit has to contain
// at least one ground object.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60,50},{60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,30},{40,30}}, color = {0,0,255}),Line(visible = true, points = {{ -20,10},{20,10}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,50}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -144, -60},{138,0}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60,50},{60,50}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -40,30},{40,30}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -20,10},{20,10}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{0,96},{0,50}}, color = {0,0,255}, thickness = 0.5),Text(visible = true, extent = {{ -24, -38},{22, -6}}, textString = "p.v=0", fontName = "Arial")}));
//           Interfaces.Pin p annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0,100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
// 
//         equation 
//           p.v = 0;
//         end Ground;
//         model Resistor "Ideal linear electrical resistor"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance R = 1 "Resistance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i*R = v</i>.
// The Resistance <i>R</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Text(visible = true, extent = {{ -144, -100},{144, -60}}, textString = "R=%R", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -144,40},{144,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -96,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}}, color = {0,0,255})}));
// 
//         equation 
//           R * i = v;
//         end Resistor;
//         model HeatingResistor "Temperature dependent electrical resistor"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter SI.Resistance R_ref = 1 "Resistance at temperature T_ref";
//           parameter SI.Temperature T_ref = 300 "Reference temperature";
//           parameter Real alpha(unit = "1/K") = 0 "Temperature coefficient of resistance";
//           SI.Resistance R "Resistance = R_ref*(1 + alpha*(heatPort.T - T_ref));";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -110,20},{ -85,20}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -95,23},{ -85,20},{ -95,17},{ -95,23}}),Line(visible = true, points = {{90,20},{115,20}}, color = {160,160,160}),Line(visible = true, points = {{ -125,0},{ -115,0}}, color = {160,160,160}),Line(visible = true, points = {{ -120, -5},{ -120,5}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -110,25},{ -90,45}}, textString = "i", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{105,23},{115,20},{105,17},{105,23}}),Line(visible = true, points = {{115,0},{125,0}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{90,25},{110,45}}, textString = "i", fontName = "Arial"),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -96,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0, -30},{0, -90}}, color = {191,0,0}),Line(visible = true, points = {{ -52, -50},{48,50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,52},{50,42},{54,56},{40,52}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -142,60},{143,118}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{0, -30},{0, -91}}, color = {191,0,0}),Line(visible = true, points = {{ -52, -50},{48,50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,52},{50,42},{54,56},{40,52}})}), Documentation(info = "<HTML>
// <p>This is a model for an electrical resistor where the generated heat
// is dissipated to the environment via connector <b>heatPort</b> and where
// the resistance R is temperature dependent according to the following
// equation:</p>
// <pre>    R = R_ref*(1 + alpha*(heatPort.T - T_ref))
// </pre>
// <p><b>alpha</b> is the <b>temperature coefficient of resistance</b>, which
// is often abbreviated as <b>TCR</b>. In resistor catalogues, it is usually
// defined as <b>X [ppm/K]</b> (parts per million, similarly to per centage)
// meaning <b>X*1.e-6 [1/K]</b>. Resistors are available for 1 .. 7000 ppm/K,
// i.e., alpha = 1e-6 .. 7e-3 1/K;</p>
// <p>When connector <b>heatPort</b> is <b>not</b> connected, the temperature
// dependent behaviour is switched off by setting heatPort.T = T_ref.
// Additionally, the equation <tt>heatPort.Q_flow = 0</tt> is implicitly present
// due to a special rule in Modelica that flow variables of not connected
// connectors are set to zero.</p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 2002   </i>
//        by Anton Haumer<br> initially implemented<br>
//        </li>
// </ul>
// </html>"));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort annotation(Placement(visible = true, transformation(origin = {0, -99.53}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = { -0.63, -99.53}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           v = R * i;
//           if cardinality(heatPort) > 0 then
//             R = R_ref * (1 + alpha * (heatPort.T - T_ref));
//             heatPort.Q_flow =  -v * i;
// 
//           else
//             R = R_ref;
//             heatPort.T = T_ref;
// 
//           end if;
//         end HeatingResistor;
//         model Conductor "Ideal linear electrical conductor"
//           extends Interfaces.OnePort;
//           parameter SI.Conductance G = 1 "Conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear conductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i = v*G</i>.
// The Conductance <i>G</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Text(visible = true, extent = {{ -138, -100},{140, -60}}, textString = "G=%G", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -140,40},{142,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{70,30}})}));
// 
//         equation 
//           i = G * v;
//         end Conductor;
//         model Capacitor "Ideal linear electrical capacitor"
//           extends Interfaces.OnePort;
//           parameter SI.Capacitance C = 1 "Capacitance";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear capacitor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i = C * dv/dt</i>.
// The Capacitance <i>C</i> is allowed to be positive, zero, or negative.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -14,28},{ -14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{14,28},{14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -90,0},{ -14,0}}, color = {0,0,255}),Line(visible = true, points = {{14,0},{90,0}}, color = {0,0,255}),Text(visible = true, extent = {{ -136, -100},{136, -60}}, textString = "C=%C", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -142,40},{140,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -20,40},{ -20, -40}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{20,40},{20, -40}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -96,0},{ -20,0}}, color = {0,0,255}),Line(visible = true, points = {{20,0},{96,0}}, color = {0,0,255})}));
// 
//         equation 
//           i = C * der(v);
//         end Capacitor;
//         model Inductor "Ideal linear electrical inductor"
//           extends Interfaces.OnePort;
//           parameter SI.Inductance L = 1 "Inductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear inductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by  <i>v = L * di/dt</i>.
// The Inductance <i>L</i> is allowed to be positive, zero, or negative.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}, endAngle = 180),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{ -96,0},{ -60,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}, endAngle = 180),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -60,0}}, color = {0,0,255}),Text(visible = true, extent = {{ -138, -102},{144, -60}}, textString = "L=%L", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{ -146,38},{148,100}}, textString = "%name", fontName = "Arial")}));
// 
//         equation 
//           L * der(i) = v;
//         end Inductor;
//         model SaturatingInductor "Simple model of an inductor with saturation"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Current Inom = 1 "Nominal current";
//           parameter Modelica.SIunits.Inductance Lnom = 1 "Nominal inductance at Nominal current";
//           parameter Modelica.SIunits.Inductance Lzer = 2 * Lnom "Inductance near current=0";
//           parameter Modelica.SIunits.Inductance Linf = Lnom / 2 "Inductance at large currents";
//           Modelica.SIunits.Inductance Lact(start = Lzer, stateSelect = StateSelect.avoid);
//           Modelica.SIunits.MagneticFlux Psi;
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, extent = {{ -60.0, -15.0},{ -30.0,15.0}}, endAngle = 180),Ellipse(visible = true, extent = {{ -30.0, -15.0},{0.0,15.0}}, endAngle = 180),Ellipse(visible = true, extent = {{0.0, -15.0},{30.0,15.0}}, endAngle = 180),Ellipse(visible = true, extent = {{30.0, -15.0},{60.0,15.0}}, endAngle = 180),Line(visible = true, points = {{60.0,0.0},{90.0,0.0}}),Line(visible = true, points = {{ -90.0,0.0},{ -60.0,0.0}}),Rectangle(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Sphere, extent = {{ -60.0, -10.0},{60.0, -20.0}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -142.0,40.0},{148.0,102.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -150.0, -92.0},{150.0, -48.0}}, textString = "Lnom=%Lnom", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This model approximates the behaviour of an inductor with the influence of saturation,
// i.e. the value of the inductance depends on the current flowing through the inductor.
// The inductance decreases as current increases.<br>
// The parameters are:
// <ul>
// <li>Inom...nominal current</li>
// <li>Lnom...nominal inductance at nominal current</li>
// <li>Lzer...inductance near current = 0; Lzer has to be greater than Lnom</li>
// <li>Linf...inductance at large currents; Linf has to be less than Lnom</li>
// </ul>
// </p>
// </HTML>
// ", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Author:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> May 27, 2004: Implemented by Anton Haumer</li>
//   </ul>
//   </dd>
// </dl>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, extent = {{ -60, -15},{ -30,15}}, endAngle = 180),Ellipse(visible = true, extent = {{ -30, -15},{0,15}}, endAngle = 180),Ellipse(visible = true, extent = {{0, -15},{30,15}}, endAngle = 180),Ellipse(visible = true, extent = {{30, -15},{60,15}}, endAngle = 180),Line(visible = true, points = {{60,0},{96,0}}),Line(visible = true, points = {{ -96,0},{ -60,0}}),Rectangle(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Sphere, extent = {{ -60, -10},{60, -20}})}));
//         protected 
//           parameter Modelica.SIunits.Current Ipar(start = Inom / 10, fixed = false);
// 
//         initial equation 
//           Lnom - Linf = ((Lzer - Linf) * Ipar) / Inom * (Modelica.Constants.pi / 2 - atan(Ipar / Inom));
// 
//         equation 
//           assert(Lzer > Lnom + Modelica.Constants.eps, "Lzer (= " + String(Lzer) + ") has to be > Lnom (= " + String(Lnom) + ")");
//           assert(Linf < Lnom - Modelica.Constants.eps, "Linf (= " + String(Linf) + ") has to be < Lnom (= " + String(Lnom) + ")");
//           ((Lact - Linf) * i) / Ipar = (Lzer - Linf) * noEvent(atan(i / Ipar));
//           Psi = Lact * i;
//           v = der(Psi);
//         end SaturatingInductor;
//         model Transformer "Transformer with two ports"
//           extends Interfaces.TwoPort;
//           parameter SI.Inductance L1 = 1 "Primary inductance";
//           parameter SI.Inductance L2 = 1 "Secondary inductance";
//           parameter SI.Inductance M = 1 "Coupling inductance";
//           annotation(Documentation(info = "<HTML>
// <p>The transformer is a two port. The left port voltage <i>v1</i>, left port current <i>i1</i>,
// right port voltage <i>v2</i> and right port current <i>i2</i> are connected by the following
// relation:</p>
// <pre>         | v1 |         | L1   M  |  | i1' |
//          |    |    =    |         |  |     |
//          | v2 |         | M    L2 |  | i2' |</pre>
// <p><i>L1</i>, <i>L2</i>, and <i>M</i> are the primary, secondary, and coupling inductances respectively.</p>
// </html>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -100,68.94},{100,126.9}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}, startAngle =  -90, endAngle = 90),Line(visible = true, points = {{ -90,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}, startAngle = 90, endAngle =  -90),Line(visible = true, points = {{32,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{90, -50}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -89, -10},{ -60,18}}, textString = "L1", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{64, -10},{90,18}}, textString = "L2", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -18, -98},{20, -70}}, textString = "M", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}, startAngle =  -90, endAngle = 90),Line(visible = true, points = {{ -96,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}, startAngle = 90, endAngle =  -90),Line(visible = true, points = {{32,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{96, -50}}, color = {0,0,255})}));
// 
//         equation 
//           v1 = L1 * der(i1) + M * der(i2);
//           v2 = M * der(i1) + L2 * der(i2);
//         end Transformer;
//         model Gyrator "Gyrator"
//           extends Interfaces.TwoPort;
//           parameter SI.Conductance G1 = 1 "Gyration conductance";
//           parameter SI.Conductance G2 = 1 "Gyration conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// A gyrator is a two-port element defined by the following equations:
// </P>
// <PRE>
//     i1 =  G2 * v2
//     i2 = -G1 * v1
// </PRE>
// <P>
// where the constants <i>G1</i>, <i>G2</i> are called the gyration conductance.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -96,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{60, -50},{96, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,30},{40,30}}, color = {0,0,255}),Line(visible = true, points = {{ -21, -22},{19, -22}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30,34},{40,30},{30,26},{30,34}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -30, -22.5},{ -20, -18.5},{ -20, -26.5},{ -30, -22.5}}),Line(visible = true, points = {{ -4,5},{ -6, -5}}, color = {0,0,255}, thickness = 1),Line(visible = true, points = {{3,5},{1, -5}}, color = {0,0,255}, thickness = 1),Line(visible = true, points = {{ -8,5},{7,5}}, color = {0,0,255}, thickness = 1),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -20,35.34},{20,50.34}}, textString = "G1", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -20, -45},{20, -30}}, textString = "G2", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -90,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{60, -50},{90, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,30},{40,30}}, color = {0,0,255}),Line(visible = true, points = {{ -20, -20},{20, -20}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30,34},{40,30},{30,26},{30,34}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -26, -19},{ -16, -15},{ -16, -23},{ -26, -19}}),Line(visible = true, points = {{ -5,10},{ -10, -10}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{9,10},{4, -9}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -14,9},{16,10}}, color = {0,0,255}, thickness = 0.5),Text(visible = true, fillColor = {0,0,255}, extent = {{ -100,69},{100,130}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -29,30},{30,59}}, textString = "G1", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -29, -58},{29, -29}}, textString = "G2", fontName = "Arial")}));
// 
//         equation 
//           i1 = G2 * v2;
//           i2 =  -G1 * v1;
//         end Gyrator;
//         model EMF "Electromotoric force (electric/mechanic transformer)"
//           parameter Real k(final unit = "N.m/A") = 1 "Transformation coefficient";
//           SI.Voltage v "Voltage drop between the two pins";
//           SI.Current i "Current flowing from positive to negative pin";
//           SI.AngularVelocity w "Angular velocity of flange_b";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,90},{0,40}}, color = {0,0,255}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{100,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Line(visible = true, points = {{0, -90},{0, -40}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, extent = {{20, -100},{100, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{30,40},{119,100}}, textString = "k=%k", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -17,95},{ -20,85},{ -23,95},{ -17,95}}),Line(visible = true, points = {{ -20,110},{ -20,85}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -40,90},{ -30,110}}, textString = "i", fontName = "Arial"),Line(visible = true, points = {{9,75},{19,75}}, color = {192,192,192}),Line(visible = true, points = {{0,96},{0,40}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -40, -40},{40,40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{96,10}}),Line(visible = true, points = {{ -20, -110},{ -20, -85}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -17, -100},{ -20, -110},{ -23, -100},{ -17, -100}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -40, -110},{ -30, -90}}, textString = "i", fontName = "Arial"),Line(visible = true, points = {{8, -79},{18, -79}}, color = {192,192,192}),Line(visible = true, points = {{0, -96},{0, -40}}, color = {0,0,255}),Line(visible = true, points = {{14,80},{14,70}}, color = {192,192,192}),Line(visible = true, points = {{140,0},{110,0}}),Text(visible = true, extent = {{114, -14},{148, -4}}, textString = "flange_b.phi", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{140,3},{150,0},{140, -3},{140,3},{140,3}}),Text(visible = true, extent = {{112,6},{148,16}}, textString = "flange_b.tau", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{120,35},{100,40},{100,30},{120,35}}),Line(visible = true, points = {{30,35},{101,35}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{37,46},{105,59}}, textString = "rotation axis", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// EMF transforms electrical energy into rotational mechanical energy.
// It is used as basic building block of an electrical motor. The mechanical
// connector flange_b can be connected to elements of the
// Modelica.Mechanics.Rotational library. flange_b.tau is the cut-torque,
// flange_b.phi is the angle at the rotational connection.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Martin Otter<br> initially implemented<br>
//        </li>
// </ul>
// </html>"));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Interfaces.NegativePin n annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//           w = der(flange_b.phi);
//           k * w = v;
//           flange_b.tau =  -k * i;
//         end EMF;
//         model VCV "Linear voltage-controlled voltage source"
//           extends Interfaces.TwoPort;
//           parameter Real gain = 1 "Voltage gain";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear voltage-controlled voltage source is a TwoPort.
// The right port voltage v2 is controlled by the left port voltage v1
// via
// </p>
// <pre>
//     v2 = v1 * gain.
// </pre>
// <p>
// The left port current is zero. Any voltage gain can be chosen.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -99, -129},{100, -79}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,50},{ -30,50}}, color = {0,0,255}),Line(visible = true, points = {{ -30, -50},{ -90, -50}}, color = {0,0,255}),Line(visible = true, points = {{100,50},{30,50},{30, -50},{100, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,50},{ -31,50}}, color = {0,0,255}),Line(visible = true, points = {{ -30, -50},{ -96, -50}}, color = {0,0,255}),Line(visible = true, points = {{96,50},{30,50},{30, -50},{96, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}})}));
// 
//         equation 
//           v2 = v1 * gain;
//           i1 = 0;
//         end VCV;
//         model VCC "Linear voltage-controlled current source"
//           extends Interfaces.TwoPort;
//           parameter SI.Conductance transConductance = 1 "Transconductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear voltage-controlled current source is a TwoPort.
// The right port current i2 is controlled by the left port voltage v1
// via
// </p>
// <pre>
//     i2 = v1 * transConductance.
// </pre>
// <p>
// The left port current is zero. Any transConductance can be chosen.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -99, -129},{100, -80}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,50},{ -30,50}}, color = {0,0,255}),Line(visible = true, points = {{ -30, -50},{ -90, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{90,50},{30,50},{30,20}}, color = {0,0,255}),Line(visible = true, points = {{91, -50},{30, -50},{30, -20}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{50,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,50},{ -30,50}}, color = {0,0,255}),Line(visible = true, points = {{ -30, -50},{ -96, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{96,50},{30,50},{30,20}}, color = {0,0,255}),Line(visible = true, points = {{96, -50},{30, -50},{30, -20}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{50,0}}, color = {0,0,255})}));
// 
//         equation 
//           i2 = v1 * transConductance;
//           i1 = 0;
//         end VCC;
//         model CCV "Linear current-controlled voltage source"
//           extends Interfaces.TwoPort;
//           parameter SI.Resistance transResistance = 1 "Transresistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear current-controlled voltage source is a TwoPort.
// The right port voltage v2 is controlled by the left port current i1
// via
// </p>
// <pre>
//     v2 = i1 * transResistance.
// </pre>
// <p>
// The left port voltage is zero. Any transResistance can be chosen.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -99, -130},{100, -80}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{100,50},{30,50},{30, -50},{100, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{ -90,50},{ -20,50},{ -20, -50},{ -90, -50}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{96,50},{30,50},{30, -50},{96, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -96,50},{ -30,50},{ -30, -50},{ -96, -50}}, color = {0,0,255})}));
// 
//         equation 
//           v2 = i1 * transResistance;
//           v1 = 0;
//         end CCV;
//         model CCC "Linear current-controlled current source"
//           extends Interfaces.TwoPort;
//           parameter Real gain = 1 "Current gain";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear current-controlled current source is a TwoPort.
// The right port current i2 is controlled by the left port current i1
// via
// </p>
// <pre>
//     i2 = i1 * gain.
// </pre>
// <p>
// The left port voltage is zero. Any current gain can be chosen.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -104, -127},{97, -76}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100,50},{ -30,50},{ -30, -50},{ -100, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{90,50},{30,50},{30,20}}, color = {0,0,255}),Line(visible = true, points = {{91, -50},{30, -50},{30, -20}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{50,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -20},{50,20}}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{ -20,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,60},{10,63},{10,57},{20,60}}),Line(visible = true, points = {{96,50},{30,50},{30,20}}, color = {0,0,255}),Line(visible = true, points = {{96, -50},{30, -50},{30, -20}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{50,0}}, color = {0,0,255}),Line(visible = true, points = {{ -96,50},{ -30,50},{ -30, -50},{ -96, -50}}, color = {0,0,255})}));
// 
//         equation 
//           i2 = i1 * gain;
//           v1 = 0;
//         end CCC;
//         model OpAmp "Simple nonideal model of an OpAmp with limitation"
//           annotation(Documentation(info = "<HTML>
// <P>
// The OpAmp is a simle nonideal model with a smooth out.v = f(vin) characteristic,
// where \"vin = in_p.v - in_n.v\".
// The characteristic is limited by VMax.v and VMin.v. Its slope at vin=0
// is the parameter Slope, which must be positive. (Therefore, the absolute 
// value of Slope is taken into calculation.)
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 2000   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -95,88},{115,146}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -45, -10},{ -20, -10},{ -14, -9},{ -11, -7},{ -9,7},{ -6,9},{0,10},{20,10}}),Line(visible = true, points = {{0,35},{0,80}}),Line(visible = true, points = {{0, -35},{0, -80}}),Line(visible = true, points = {{ -90,50},{ -60,50}}),Line(visible = true, points = {{ -90, -50},{ -60, -50}}),Line(visible = true, points = {{60,0},{90,0}}),Line(visible = true, points = {{ -48,32},{ -28,32}}),Line(visible = true, points = {{ -39, -20},{ -39, -41}}),Line(visible = true, points = {{ -50, -31},{ -28, -31}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -45, -10},{ -20, -10},{ -14, -9},{ -11, -7},{ -9,7},{ -6,9},{0,10},{20,10}}),Line(visible = true, points = {{0,35},{0,70}}),Line(visible = true, points = {{0, -35},{0, -70}}),Line(visible = true, points = {{ -96,50},{ -60,50}}),Line(visible = true, points = {{ -96, -50},{ -60, -50}}),Line(visible = true, points = {{60,0},{96,0}}),Line(visible = true, points = {{ -55,50},{ -45,50}}),Line(visible = true, points = {{ -50, -45},{ -50, -55}}),Line(visible = true, points = {{ -55, -50},{ -45, -50}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -112, -93},{ -91, -73}}, textString = "in_p.i=0", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,3},{110,0},{120, -3},{120,3}}),Line(visible = true, points = {{111,0},{136,0}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{118,2},{135,17}}, textString = "i2", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -111,60},{ -85,80}}, textString = "in_n.i=0", fontName = "Arial"),Line(visible = true, points = {{ -100, -35},{ -100,23},{ -100,24}}, color = {160,160,160}, arrow = {Arrow.None,Arrow.Filled}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -97, -16},{ -74,4}}, textString = "vin", fontName = "Arial")}));
//           parameter Real Slope = 1 "Slope of the out.v/vin characteristic at vin=0";
//           SI.Voltage vin "input voltagae";
//           Modelica.Electrical.Analog.Interfaces.PositivePin in_p "Positive pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin in_n "Negative pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin out "Output pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin VMax "Positive output voltage limitation" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin VMin "Negative output voltage limitation" annotation(Placement(visible = true, transformation(origin = {0, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Real f "auxiliary variable";
//           Real absSlope;
// 
//         equation 
//           in_p.i = 0;
//           in_n.i = 0;
//           VMax.i = 0;
//           VMin.i = 0;
//           vin = in_p.v - in_n.v;
//           f = 2 / (VMax.v - VMin.v);
//           absSlope = if Slope < 0 then  -Slope else Slope;
//           out.v = (VMax.v + VMin.v) / 2 + (absSlope * vin) / (1 + absSlope * noEvent(if f * vin < 0 then  -f * vin else f * vin));
//         end OpAmp;
//         model VariableResistor "Ideal linear electrical resistor with variable resistance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i*R = v</i></b>
// </P>
// <P>
// The Resistance <i>R</i> is given as input signal.
// <P>
// <b>Attention!!!</b><br>
//   It is recommended that the R signal should not cross the zero value. Otherwise 
//   depending on the surrounding circuit the probability of singularities is high. <br>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -148, -100},{144, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -96,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.RealInput R(redeclare type SignalType = Modelica.SIunits.Resistance) annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           v = R * i;
//         end VariableResistor;
//         model VariableConductor "Ideal linear electrical conductor with variable conductance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear conductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i = G*v</i></b>
// </P>
// <P>
// The Conductance <i>G</i> is given as input signal.
// </P>
// <P>
// <b>Attention!!!</b><br>
//   It is recommended that the G signal should not cross the zero value. Otherwise 
//   depending on the surrounding circuit the probability of singularities is high. <br>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -144, -102},{142, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Line(visible = true, points = {{ -96,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}})}));
//           Modelica.Blocks.Interfaces.RealInput G(redeclare type SignalType = Modelica.SIunits.Conductance) annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           i = G * v;
//         end VariableConductor;
//         model VariableCapacitor "Ideal linear electrical capacitor with variable capacitance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Capacitance Cmin = Modelica.Constants.eps;
//           Modelica.SIunits.ElectricCharge Q;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear capacitor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i = dQ/dt</i></b>  with <b><i>Q = C * v</i> </b>.
// </P>
// <P>
// The capacitance <i>C</i> is given as input signal.
// </P>
// <P>
// It is required that C &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// C = Cmin, if 0 &le; C &lt; Cmin, where
// Cmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -134, -100},{136, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -14,0}}, color = {0,0,255}),Line(visible = true, points = {{14,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Line(visible = true, points = {{ -14,28},{ -14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{14,28},{14, -28}}, color = {0,0,255}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,0},{ -14,0}}, color = {0,0,255}),Line(visible = true, points = {{14,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Line(visible = true, points = {{ -14,28},{ -14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{14,28},{14, -28}}, color = {0,0,255}, thickness = 0.5)}));
//           Modelica.Blocks.Interfaces.RealInput C(redeclare type SignalType = Modelica.SIunits.Capacitance) annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           assert(C >= 0, "Capacitance C (= " + String(C) + ") has to be >= 0!");
//           Q = noEvent(max(C, Cmin)) * v;
//           i = der(Q);
//         end VariableCapacitor;
//         model VariableInductor "Ideal linear electrical inductor with variable inductance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.SIunits.MagneticFlux Psi;
//           parameter Modelica.SIunits.Inductance Lmin = Modelica.Constants.eps;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear inductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>v = d Psi/dt </i></b>   with  <b><i>Psi = L * i </i></b>.
// </P>
// <P>
// The inductance <i>L</i> is as input signal.
// </P>
// <P>
// It is required that L &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// L = Lmin, if 0 &le; L &lt; Lmin, where
// Lmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, extent = {{ -138, -100},{136, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -60,0}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,8}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}, endAngle = 180)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,0},{ -60,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,8}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}, endAngle = 180),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}, endAngle = 180),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.RealInput L(redeclare type SignalType = Modelica.SIunits.Inductance) annotation(Placement(visible = true, transformation(origin = {0,108}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,108}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           assert(L >= 0, "Inductance L_ (= " + String(L) + ") has to be >= 0!");
//           Psi = noEvent(max(L, Lmin)) * i;
//           v = der(Psi);
//         end VariableInductor;
//       end Basic;
//       package Ideal "Ideal electrical elements such as switches, diode, transformer, operational amplifier"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains electrical components with idealized behaviour:
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model IdealThyristor "Ideal thyristor"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Ron(final min = 0) = 1e-05 "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Goff(final min = 0) = 1e-05 "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{30,20},{70,60},{70,90}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{60,30}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{70,4},{80,0},{70, -4},{70,4}}),Line(visible = true, points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -4,70},{0,80},{4,70},{ -4,70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{10,70},{20,80}}, textString = "i", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{70, -20},{80, -10}}, textString = "v", fontName = "Arial"),Line(visible = true, points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, thickness = 0.5),Line(visible = true, points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20, -10},{40,0}}, textString = "Vknee", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20,60},{40,70}}, textString = "Ron", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{ -20,0},{0,10}}, textString = "Goff", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid, extent = {{18,8},{22,12}}),Line(visible = true, points = {{20,10},{70,40}}, thickness = 0.5)}));
//           Modelica.Blocks.Interfaces.BooleanInput fire annotation(Placement(visible = true, transformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "<html>
// This is an ideal thyristor model which is<br><br>
// <b>open </b>(off), if the voltage drop is less than 0 or fire is false<br>
// <b>closed</b> (on), if the voltage drop is greater or equal 0  and fire is true.<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// thyristor has a small conductance <i>Goff</i> and the closed thyristor has a low
// resistance <i>Ron</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Goff</i>-characteristic until <i>v = Vknee</i>.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name"),Polygon(points = {{30,0},{ -30,40},{ -30, -40},{30,0}}, fillPattern = FillPattern.Solid, lineColor = {0,0,255}, fillColor = {255,255,255}),Line(points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(points = {{40,0},{90,0}}, color = {0,0,255}),Line(points = {{30,40},{30, -40}}, color = {0,0,255}),Line(points = {{30,20},{70,60},{70,90}}, color = {0,0,255}),Line(points = {{40,50},{60,30}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(points = {{70,4},{80,0},{70, -4},{70,4}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Line(points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(points = {{ -4,70},{0,80},{4,70},{ -4,70}}, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid),Text(lineColor = {0,0,255}, extent = {{10,80},{20,70}}, fillColor = {128,128,128}, textString = "i"),Text(lineColor = {0,0,255}, extent = {{70, -10},{80, -20}}, fillColor = {128,128,128}, textString = "v"),Line(points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, color = {0,0,0}, thickness = 0.5),Line(points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(lineColor = {0,0,255}, extent = {{20,0},{40, -10}}, fillColor = {128,128,128}, textString = "Vknee"),Text(lineColor = {0,0,255}, extent = {{20,70},{40,60}}, fillColor = {128,128,128}, textString = "Ron"),Text(lineColor = {0,0,255}, extent = {{ -20,10},{0,0}}, fillColor = {128,128,128}, textString = "Goff"),Ellipse(lineColor = {0,0,255}, extent = {{18,12},{22,8}}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid),Line(points = {{20,10},{70,40}}, color = {0,0,0}, thickness = 0.5)}));
// 
//         equation 
//           off = s < 0 or pre(off) and not fire;
//           v = s * unitCurrent * (if off then 1 else Ron) + Vknee;
//           i = s * unitVoltage * (if off then Goff else 1) + Goff * Vknee;
//         end IdealThyristor;
//         model IdealGTOThyristor "Ideal GTO thyristor"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Ron(final min = 0) = 1e-05 "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Goff(final min = 0) = 1e-05 "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{30,20},{70,60},{70,90}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{60,30}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{70,4},{80,0},{70, -4},{70,4}}),Line(visible = true, points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -4,70},{0,80},{4,70},{ -4,70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{10,70},{20,80}}, textString = "i", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{70, -20},{80, -10}}, textString = "v", fontName = "Arial"),Line(visible = true, points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, thickness = 0.5),Line(visible = true, points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20, -10},{40,0}}, textString = "Vknee", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20,60},{40,70}}, textString = "Ron", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{ -20,0},{0,10}}, textString = "Goff", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid, extent = {{18,8},{22,12}}),Line(visible = true, points = {{20,10},{70,40}}, thickness = 0.5)}));
//           Modelica.Blocks.Interfaces.BooleanInput fire annotation(Placement(visible = true, transformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "<html>
// This is an ideal GTO thyristor model which is<br><br>
// <b>open </b>(off), if the voltage drop is less than 0 or fire is false<br>
// <b>closed</b> (on), if the voltage drop is greater or equal 0  and fire is true.<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// thyristor has a small conductance <i>Goff</i> and the closed thyristor has a low
// resistance <i>Ron</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Goff</i>-characteristic until <i>v = Vknee</i>.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name"),Polygon(points = {{30,0},{ -30,40},{ -30, -40},{30,0}}, fillPattern = FillPattern.Solid, lineColor = {0,0,255}, fillColor = {255,255,255}),Line(color = {0,0,255}, points = {{ -90,0},{40,0}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Line(points = {{30,40},{30, -40}}, color = {0,0,255}),Line(color = {0,0,255}, points = {{30,20},{70,60},{70,90}}),Line(color = {0,0,255}, points = {{40,50},{60,30}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(points = {{70,4},{80,0},{70, -4},{70,4}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Line(points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(points = {{ -4,70},{0,80},{4,70},{ -4,70}}, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid),Text(lineColor = {0,0,255}, extent = {{10,80},{20,70}}, fillColor = {128,128,128}, textString = "i"),Text(lineColor = {0,0,255}, extent = {{70, -10},{80, -20}}, fillColor = {128,128,128}, textString = "v"),Line(points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, color = {0,0,0}, thickness = 0.5),Line(points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(lineColor = {0,0,255}, extent = {{20,0},{40, -10}}, fillColor = {128,128,128}, textString = "Vknee"),Text(lineColor = {0,0,255}, extent = {{20,70},{40,60}}, fillColor = {128,128,128}, textString = "Ron"),Text(lineColor = {0,0,255}, extent = {{ -20,10},{0,0}}, fillColor = {128,128,128}, textString = "Goff"),Ellipse(lineColor = {0,0,255}, extent = {{18,12},{22,8}}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid),Line(points = {{20,10},{70,40}}, color = {0,0,0}, thickness = 0.5)}));
// 
//         equation 
//           off = s < 0 or not fire;
//           v = s * unitCurrent * (if off then 1 else Ron) + Vknee;
//           i = s * unitVoltage * (if off then Goff else 1) + Goff * Vknee;
//         end IdealGTOThyristor;
//         model IdealCommutingSwitch "Ideal commuting switch"
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The commuting switch has a positive pin p and two negative pins n1 and n2. 
// The switching behaviour is controlled
// by the inpug signal control. If control is true, the pin p is connected 
// with the negative pin n2. Otherwise, the pin p is connected to the negative pin n1.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{0,60},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,0},{ -60,22}}, textString = "p", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,50},{80,72}}, textString = "n1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,0},{80,22}}, textString = "n2", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control "true => p--n2 connected, false => p--n1 connected" annotation(Placement(visible = true, transformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s1;
//           Real s2 "Auxiliary variables";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
// 
//         equation 
//           0 = p.i + n2.i + n1.i;
//           p.v - n1.v = s1 * unitCurrent * (if control then 1 else Ron);
//           n1.i =  -s1 * unitVoltage * (if control then Goff else 1);
//           p.v - n2.v = s2 * unitCurrent * (if control then Ron else 1);
//           n2.i =  -s2 * unitVoltage * (if control then 1 else Goff);
//         end IdealCommutingSwitch;
//         model IdealIntermediateSwitch "Ideal intermediate switch"
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The intermediate switch has four switching contact pins p1, p2, n1, and n2. 
// The switching behaviour is controlled by the input signal control. If control
// is true, the pin p1 is connected to pin n2, and the pin p2 is 
// connected to the pin n2. Otherwise, the pin p1 is connected to n1, and
// p2 is connected to n2.
// </P>
// <IMG SRC=\"../Images/IdealIntermediateSwitch1.png\" ALT=\"IdealIntermediateSwitch1\">
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// </P>
// <IMG SRC=\"../Images/IdealIntermediateSwitch2.png\" ALT=\"IdealIntermediateSwitch2\">
// <P>
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -4,21},{4,29}}),Line(visible = true, points = {{ -96,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{ -96,50},{ -40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,0},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,50},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{0,60},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -4,22},{4,30}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,50},{ -60,72}}, textString = "p1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,0},{ -60,22}}, textString = "p2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,50},{80,72}}, textString = "n1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,0},{80,22}}, textString = "n2", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,50},{ -44,50}}, color = {0,0,255}),Line(visible = true, points = {{ -44,0},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -44,50},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p1 annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin p2 annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control "true => p1--n2, p2--n1 connected, otherwise p1--n1, p2--n2  connected" annotation(Placement(visible = true, transformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s1;
//           Real s2;
//           Real s3;
//           Real s4 "Auxiliary variables";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
// 
//         equation 
//           p1.v - n1.v = s1 * unitCurrent * (if control then 1 else Ron);
//           p2.v - n2.v = s2 * unitCurrent * (if control then 1 else Ron);
//           p1.v - n2.v = s3 * unitCurrent * (if control then Ron else 1);
//           p2.v - n1.v = s4 * unitCurrent * (if control then Ron else 1);
//           p1.i = if control then s1 * unitVoltage * Goff + s3 * unitCurrent else s1 * unitCurrent + s3 * unitVoltage * Goff;
//           p2.i = if control then s2 * unitVoltage * Goff + s4 * unitCurrent else s2 * unitCurrent + s4 * unitVoltage * Goff;
//           n1.i = if control then  -s1 * unitVoltage * Goff - s4 * unitCurrent else  -s1 * unitCurrent - s4 * unitVoltage * Goff;
//           n2.i = if control then  -s2 * unitVoltage * Goff - s3 * unitCurrent else  -s2 * unitCurrent - s3 * unitVoltage * Goff;
//         end IdealIntermediateSwitch;
//         model ControlledIdealCommutingSwitch "Controlled ideal commuting switch"
//           parameter SI.Voltage level = 0.5 "Switch level";
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The commuting switch has a positive pin p and two negative pins n1 and n2. 
// The switching behaviour is controlled
// by the control pin. If its voltage exceeds the value of the parameter level,
// the pin p is connected with the negative pin n2. Otherwise, the pin p is 
// connected the negative pin n1.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{0,96},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,0},{ -60,22}}, textString = "p", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,50},{80,72}}, textString = "n1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,0},{80,22}}, textString = "n2", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin control "Control pin: if control.v > level p--n2 connected, otherwise p--n1 connected" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           Real s1;
//           Real s2 "Auxiliary variables";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n2.i + n1.i;
//           p.v - n1.v = s1 * unitCurrent * (if control.v > level then 1 else Ron);
//           n1.i =  -s1 * unitVoltage * (if control.v > level then Goff else 1);
//           p.v - n2.v = s2 * unitCurrent * (if control.v > level then Ron else 1);
//           n2.i =  -s2 * unitVoltage * (if control.v > level then 1 else Goff);
//         end ControlledIdealCommutingSwitch;
//         model ControlledIdealIntermediateSwitch "Controlled ideal intermediate switch"
//           parameter SI.Voltage level = 0.5 "Switch level";
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The intermediate switch has four switching contact pins p1, p2, n1, and n2. 
// The switching behaviour is controlled
// by the control pin. If its voltage exceeds the value of the 
// parameter level, the pin p1 is connected to pin n2, and the pin p2 is 
// connected to the pin n2. Otherwise, the pin p1 is connected to n1, and
// p2 is connected to n2.
// </P>
// <IMG SRC=\"../Images/ControlledIdealIntermediateSwitch1.png\" ALT=\"ControlledIdealIntermediateSwitch1\">
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// </P>
// <IMG SRC=\"../Images/ControlledIdealIntermediateSwitch2.png\" ALT=\"ControlledIdealIntermediateSwitch2\">
// <P>
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -4,21},{4,29}}),Line(visible = true, points = {{ -96,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{ -96,50},{ -40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,0},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,50},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{0,96},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -4,22},{4,30}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,50},{ -60,72}}, textString = "p1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80,0},{ -60,22}}, textString = "p2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,50},{80,72}}, textString = "n1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60,0},{80,22}}, textString = "n2", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,50},{ -39,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,0},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -40,50},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p1 annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin p2 annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n1 annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin control "Control pin: if control.v > level p1--n2, p2--n1 connected,
//          otherwise p1--n1, p2--n2  connected" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           Real s1;
//           Real s2;
//           Real s3;
//           Real s4 "Auxiliary variables";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
// 
//         equation 
//           control.i = 0;
//           p1.v - n1.v = s1 * unitCurrent * (if control.v > level then 1 else Ron);
//           p2.v - n2.v = s2 * unitCurrent * (if control.v > level then 1 else Ron);
//           p1.v - n2.v = s3 * unitCurrent * (if control.v > level then Ron else 1);
//           p2.v - n1.v = s4 * unitCurrent * (if control.v > level then Ron else 1);
//           p1.i = if control.v > level then s1 * unitVoltage * Goff + s3 * unitCurrent else s1 * unitCurrent + s3 * unitVoltage * Goff;
//           p2.i = if control.v > level then s2 * unitVoltage * Goff + s4 * unitCurrent else s2 * unitCurrent + s4 * unitVoltage * Goff;
//           n1.i = if control.v > level then  -s1 * unitVoltage * Goff - s4 * unitCurrent else  -s1 * unitCurrent - s4 * unitVoltage * Goff;
//           n2.i = if control.v > level then  -s2 * unitVoltage * Goff - s3 * unitCurrent else  -s2 * unitCurrent - s3 * unitVoltage * Goff;
//         end ControlledIdealIntermediateSwitch;
//         model IdealOpAmp "Ideal operational amplifier (norator-nullator pair)"
//           SI.Voltage v1 "Voltage drop over the left port";
//           SI.Voltage v2 "Voltage drop over the right port";
//           SI.Current i1 "Current flowing from pos. to neg. pin of the left port";
//           SI.Current i2 "Current flowing from pos. to neg. pin of the right port";
//           annotation(Documentation(info = "<html>
// <P>
// The ideal OpAmp is a two-port. The left port is fixed to <i>v1=0</i> and <i>i1=0</i>
// (nullator). At the right port both any voltage <i>v2</i> and any current <i>i2</i>
// are possible (norator).
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -96,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0, -35},{0, -96}}, color = {0,0,255}),Line(visible = true, points = {{ -55,50},{ -45,50}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -45},{ -50, -55}}, color = {0,0,255}),Line(visible = true, points = {{ -55, -50},{ -45, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111, -39},{ -90, -19}}, textString = "p1.i=0", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,3},{110,0},{120, -3},{120,3}}),Line(visible = true, points = {{111,0},{136,0}}, color = {160,160,160}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{118,2},{135,17}}, textString = "i2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111,60},{ -90,80}}, textString = "n1.i=0", fontName = "Arial"),Line(visible = true, points = {{18, -111},{18, -86}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{21, -101},{18, -111},{15, -101},{21, -101}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{22, -100},{39, -85}}, textString = "i2", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -90,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0, -35},{0, -91}}, color = {0,0,255}),Line(visible = true, points = {{ -48,32},{ -28,32}}, color = {0,0,255}),Line(visible = true, points = {{ -39, -20},{ -39, -41}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -31},{ -28, -31}}, color = {0,0,255})}));
//           Interfaces.PositivePin p1 "Positive pin of the left port" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n1 "Negative pin of the left port" annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin p2 "Positive pin of the right port" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n2 "Negative pin of the right port" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
// 
//         equation 
//           v1 = p1.v - n1.v;
//           v2 = p2.v - n2.v;
//           0 = p1.i + n1.i;
//           0 = p2.i + n2.i;
//           i1 = p1.i;
//           i2 = p2.i;
//           v1 = 0;
//           i1 = 0;
//         end IdealOpAmp;
//         model IdealOpAmp3Pin "Ideal operational amplifier (norator-nullator pair), but 3 pins"
//           annotation(Documentation(info = "<html>
// <P>
// The ideal OpAmp with three pins is of exactly the same behaviour as the ideal
// OpAmp with four pins. Only the negative output pin is left out.
// Both the input voltage and current are fixed to zero (nullator).
// At the output pin both any voltage <i>v2</i> and any current <i>i2</i>
// are possible.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 2002   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -96,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{97,0}}, color = {0,0,255}),Line(visible = true, points = {{ -55,50},{ -45,50}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -45},{ -50, -55}}, color = {0,0,255}),Line(visible = true, points = {{ -55, -50},{ -45, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111, -39},{ -90, -19}}, textString = "p1.i=0", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,3},{110,0},{120, -3},{120,3}}),Line(visible = true, points = {{111,0},{136,0}}, color = {160,160,160}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{118,2},{135,17}}, textString = "i2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111,60},{ -90,80}}, textString = "n1.i=0", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -90,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -48,32},{ -28,32}}, color = {0,0,255}),Line(visible = true, points = {{ -39, -20},{ -39, -41}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -31},{ -28, -31}}, color = {0,0,255})}));
//           Interfaces.PositivePin in_p "Positive pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin in_n "Negative pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin out "Output pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           in_p.v = in_n.v;
//           in_p.i = 0;
//           in_n.i = 0;
//         end IdealOpAmp3Pin;
//         model IdealOpAmpLimited "Ideal operational amplifier with limitation"
//           annotation(Documentation(info = "<HTML>
// <P>
// The ideal OpAmp with limitation behaves like an ideal OpAmp without limitation,
// if the output voltage is within the limits (VMin < out.v < VMax). In this case
// the input voltage vin=in_p.v - in_n.v is zero.
// If the input voltage is vin < 0, the output voltage is out.v = VMin.
// If the input voltage is vin > 0, the output voltage is out.v = VMax.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -45, -10},{ -10, -10},{ -10,10},{20,10}}, color = {0,0,255}),Line(visible = true, points = {{0,35},{0,80}}, color = {0,0,255}),Line(visible = true, points = {{0, -35},{0, -80}}, color = {0,0,255}),Line(visible = true, points = {{ -96,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{ -55,50},{ -45,50}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -45},{ -50, -55}}, color = {0,0,255}),Line(visible = true, points = {{ -55, -50},{ -45, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111, -39},{ -90, -19}}, textString = "p1.i=0", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,3},{110,0},{120, -3},{120,3}}),Line(visible = true, points = {{111,0},{136,0}}, color = {160,160,160}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{118,2},{135,17}}, textString = "i2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -111,60},{ -90,80}}, textString = "n1.i=0", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -110,80},{100,116.5}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{60,0},{ -60,70},{ -60, -70},{60,0}}),Line(visible = true, points = {{ -45, -10},{ -10, -10},{ -10,10},{20,10}}, color = {0,0,255}),Line(visible = true, points = {{0,35},{0,80}}, color = {0,0,255}),Line(visible = true, points = {{0, -35},{0, -80}}, color = {0,0,255}),Line(visible = true, points = {{ -90,50},{ -60,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -60, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -48,32},{ -28,32}}, color = {0,0,255}),Line(visible = true, points = {{ -39, -20},{ -39, -41}}, color = {0,0,255}),Line(visible = true, points = {{ -50, -31},{ -28, -31}}, color = {0,0,255})}));
//           SI.Voltage vin "input voltage";
//           Interfaces.PositivePin in_p "Positive pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin in_n "Negative pin of the input port" annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin out "Output pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePin VMax "Positive output voltage limitation" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin VMin "Negative output voltage limitation" annotation(Placement(visible = true, transformation(origin = {0, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Real s "Auxiliary variable";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
// 
//         equation 
//           in_p.i = 0;
//           in_n.i = 0;
//           VMax.i = 0;
//           VMin.i = 0;
//           vin = in_p.v - in_n.v;
//           in_p.v - in_n.v = unitVoltage * (if s <  -1 then s + 1 else if s > 1 then s - 1 else 0);
//           out.v = if s <  -1 then VMin.v else if s > 1 then VMax.v else ((VMax.v - VMin.v) * s) / 2 + (VMax.v + VMin.v) / 2;
//         end IdealOpAmpLimited;
//         model IdealDiode "Ideal diode"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Ron(final min = 0) = 1e-05 "Forward state-on differential resistance (closed diode resistance)";
//           parameter Modelica.SIunits.Conductance Goff(final min = 0) = 1e-05 "Backward state-off conductance (opened diode conductance)";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{70,4},{80,0},{70, -4},{70,4}}),Line(visible = true, points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -4,70},{0,80},{4,70},{ -4,70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{10,70},{20,80}}, textString = "i", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{70, -20},{80, -10}}, textString = "v", fontName = "Arial"),Line(visible = true, points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, thickness = 0.5),Line(visible = true, points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20, -10},{40,0}}, textString = "Vknee", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{20,60},{40,70}}, textString = "Ron", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {128,128,128}, extent = {{ -20,0},{0,10}}, textString = "Goff", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid, extent = {{18,8},{22,12}})}));
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "<html>
// <P>
// This is an ideal switch which is<br><br>
// <b>open </b>(off), if it is reversed biased (voltage drop less than 0)<br>
// <b>closed</b> (on), if it is conducting (current > 0).<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// diode has a small conductance <i>Gon</i> and the closed diode has a low
// resistance <i>Roff</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Gon</i>-characteristic until <i>v = Vknee</i>.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{30,0},{ -30,40},{ -30, -40},{30,0}}, fillPattern = FillPattern.Solid, lineColor = {0,0,255}, fillColor = {255,255,255}),Line(color = {0,0,255}, points = {{ -90,0},{40,0}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Line(points = {{30,40},{30, -40}}, color = {0,0,255}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "%name")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,0},{80,0}}, color = {128,128,128}),Polygon(points = {{70,4},{80,0},{70, -4},{70,4}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Line(points = {{0,80},{0, -80}}, color = {128,128,128}),Polygon(points = {{ -4,70},{0,80},{4,70},{ -4,70}}, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid),Text(lineColor = {0,0,255}, extent = {{10,80},{20,70}}, fillColor = {128,128,128}, textString = "i"),Text(lineColor = {0,0,255}, extent = {{70, -10},{80, -20}}, fillColor = {128,128,128}, textString = "v"),Line(points = {{ -80, -40},{ -20, -10},{20,10},{40,70}}, color = {0,0,0}, thickness = 0.5),Line(points = {{20,9},{20,0}}, color = {128,128,128}, pattern = LinePattern.Dot),Text(lineColor = {0,0,255}, extent = {{20,0},{40, -10}}, fillColor = {128,128,128}, textString = "Vknee"),Text(lineColor = {0,0,255}, extent = {{20,70},{40,60}}, fillColor = {128,128,128}, textString = "Ron"),Text(lineColor = {0,0,255}, extent = {{ -20,10},{0,0}}, fillColor = {128,128,128}, textString = "Goff"),Ellipse(lineColor = {0,0,255}, extent = {{18,12},{22,8}}, pattern = LinePattern.Dot, fillPattern = FillPattern.Solid)}));
// 
//         equation 
//           off = s < 0;
//           v = s * unitCurrent * (if off then 1 else Ron) + Vknee;
//           i = s * unitVoltage * (if off then Goff else 1) + Goff * Vknee;
//         end IdealDiode;
//         model IdealTransformer "Ideal electrical transformer"
//           extends Interfaces.TwoPort;
//           parameter Real n = 1 "Turns ratio";
//           annotation(Documentation(info = "<html>
// <P>
// The ideal transformer is an ideal two-port resistive circuit element
// which is characterized by the following two equations:
// </P>
// <PRE>
//     v1 =  n * v2
//     i2 = -n * i1
// </PRE>
// <P>
// where <i>n</i> is a real number called the turns ratio.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}, startAngle =  -90, endAngle = 90),Line(visible = true, points = {{ -96,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -96, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}, startAngle = 90, endAngle =  -90),Line(visible = true, points = {{32,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{96, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}, startAngle = 90, endAngle =  -90)}), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,114.8}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}, startAngle =  -90, endAngle = 90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}, startAngle =  -90, endAngle = 90),Line(visible = true, points = {{ -90,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}, startAngle = 90, endAngle =  -90),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}, startAngle = 90, endAngle =  -90),Line(visible = true, points = {{32,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{90, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -80}}, textString = "n=%n", fontName = "Arial")}));
// 
//         equation 
//           v1 = n * v2;
//           i2 =  -n * i1;
//         end IdealTransformer;
//         model IdealGyrator "Ideal gyrator"
//           extends Interfaces.TwoPort;
//           annotation(Documentation(info = "<html>
// <P>
// A gyrator is an ideal two-port element defined by the following equations:
// </P>
// <PRE>
//     i1 =  G * v2
//     i2 = -G * v1
// </PRE>
// <P>
// where the constant <i>G</i> is called the gyration conductance.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{ -10,30}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80, -40},{ -41,40}}),Line(visible = true, points = {{ -96,50},{ -40,50},{ -40, -50},{ -96, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -30,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,63},{30,60},{20,57},{20,63}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -30},{70,30}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{40, -40},{80,40}}),Line(visible = true, points = {{96,50},{40,50},{40, -50},{96, -50}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -70, -30},{ -10,30}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80, -40},{ -41,40}}),Line(visible = true, points = {{ -90,50},{ -40,50},{ -40, -50},{ -90, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -30,60},{20,60}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{20,63},{30,60},{20,57},{20,63}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{10, -30},{70,30}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{40, -40},{80,40}}),Line(visible = true, points = {{90,50},{40,50},{40, -50},{90, -50}}, color = {0,0,255})}));
//           parameter SI.Conductance G = 1 "Gyration conductance";
// 
//         equation 
//           i1 = G * v2;
//           i2 =  -G * v1;
//         end IdealGyrator;
//         model Idle "Idle branch"
//           extends Interfaces.OnePort;
//           annotation(Documentation(info = "<html>
// <P>
// The model Idle is a simple idle running branch.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -96,0},{ -41,0}}, color = {0,0,255}),Line(visible = true, points = {{96,0},{40,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -90,0},{ -41,0}}, color = {0,0,255}),Line(visible = true, points = {{91,0},{40,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}));
// 
//         equation 
//           i = 0;
//         end Idle;
//         model Short "Short cut branch"
//           extends Interfaces.OnePort;
//           annotation(Documentation(info = "<html>
// <P>
// The model Short is a simple short cut branch.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{96,0},{ -96,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "Short", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{91,0},{ -90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}));
// 
//         equation 
//           v = 0;
//         end Short;
//         model IdealOpeningSwitch "Ideal electrical opener"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [10,10;56.6667,56.6667]);
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0,51},{0,26}}, color = {0,0,255}),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{0,51},{0,26}}, color = {0,0,255}),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.BooleanInput control "true => switch open, false => p--n connected" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "<HTML>
// <P> 
// The ideal opening switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the input signal control. 
// If control is true, pin p is not connected 
// with negative pin n. Otherwise, pin p is connected 
// with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -90,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name"),Line(color = {0,0,255}, points = {{0,51},{0,26}}),Line(color = {0,0,255}, points = {{40,20},{40,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -96,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{96,0}}),Text(lineColor = {0,0,255}, extent = {{ -100, -40},{100, -79}}, textString = "%name"),Line(color = {0,0,255}, points = {{0,51},{0,26}}),Line(color = {0,0,255}, points = {{40,20},{40,0}})}));
// 
//         equation 
//           v = s * unitCurrent * (if control then 1 else Ron);
//           i = s * unitVoltage * (if control then Goff else 1);
//         end IdealOpeningSwitch;
//         model IdealClosingSwitch "Ideal electrical closer"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [10,10;56.6667,56.6667]);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{0,51},{0,26}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0,51},{0,26}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.BooleanInput control "true => p--n connected, false => switch open" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -450), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "<HTML>
// <P> 
// The ideal closing switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by input signal control. 
// If control is true, pin p is connected 
// with negative pin n. Otherwise, pin p is not connected 
// with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -90,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name"),Line(color = {0,0,255}, points = {{0,51},{0,26}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -96,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{96,0}}),Text(lineColor = {0,0,255}, extent = {{ -100, -40},{100, -79}}, textString = "%name"),Line(color = {0,0,255}, points = {{0,51},{0,26}})}));
// 
//         equation 
//           v = s * unitCurrent * (if control then Ron else 1);
//           i = s * unitVoltage * (if control then 1 else Goff);
//         end IdealClosingSwitch;
//         model ControlledIdealOpeningSwitch "Controlled ideal electrical opener"
//           parameter SI.Voltage level = 0.5 "Switch level" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [10,10;56.6667,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [ -56.6667, -56.6667; -10, -10]);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0,96},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255})}));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin control "Control pin: control.v > level switch open, otherwise p--n connected" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The ideal switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control pin. 
// If its voltage exceeds the voltage of the parameter level,
// pin p is not connected with negative pin n. 
// Otherwise, pin p is connected with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -90,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Line(color = {0,0,255}, points = {{0,90},{0,25}}),Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name"),Line(color = {0,0,255}, points = {{40,20},{40,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -96,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{96,0}}),Line(color = {0,0,255}, points = {{0,96},{0,25}}),Line(color = {0,0,255}, points = {{40,20},{40,0}})}));
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n.i;
//           p.v - n.v = s * unitCurrent * (if control.v > level then 1 else Ron);
//           p.i = s * unitVoltage * (if control.v > level then Goff else 1);
//         end ControlledIdealOpeningSwitch;
//         model ControlledIdealClosingSwitch "Controlled ideal electrical closer"
//           parameter SI.Voltage level = 0.5 "Switch level" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [10,10;56.6667,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [ -56.6667, -56.6667; -10, -10]);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100, -70}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -96,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{0,96},{0,25}}, color = {0,0,255})}));
//           Modelica.Electrical.Analog.Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin n annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin control "Control pin: control.v > level switch closed, otherwise switch open" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           Real s "Auxiliary variable";
//           parameter Modelica.SIunits.Voltage unitVoltage = 1 annotation(HideResult = true);
//           parameter Modelica.SIunits.Current unitCurrent = 1 annotation(HideResult = true);
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The closing ideal switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control pin. 
// If its voltage exceeds the voltage of the parameter level,
// pin p is connected with negative pin n. 
// Otherwise, pin p is not connected with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -90,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Line(color = {0,0,255}, points = {{0,90},{0,25}}),Text(lineColor = {0,0,255}, extent = {{ -100, -70},{100, -100}}, textString = "%name")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(lineColor = {0,0,255}, extent = {{ -44,4},{ -36, -4}}),Line(color = {0,0,255}, points = {{ -96,0},{ -44,0}}),Line(color = {0,0,255}, points = {{ -37,2},{40,50}}),Line(color = {0,0,255}, points = {{40,0},{96,0}}),Line(color = {0,0,255}, points = {{0,96},{0,25}})}));
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n.i;
//           p.v - n.v = s * unitCurrent * (if control.v > level then Ron else 1);
//           p.i = s * unitVoltage * (if control.v > level then 1 else Goff);
//         end ControlledIdealClosingSwitch;
//       end Ideal;
//       package Interfaces "Connectors and partial models for Analog electrical components"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains connectors and interfaces (partial models) for
// analog electrical components.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// </dl>
// 
// <b>Copyright:</b>
// <dl>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// 
// <ul>
// <li><i> 1998</i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector Pin "Pin of an electrical component"
//           SI.Voltage v "Potential at the pin";
//           flow SI.Current i "Current flowing into the pin";
//           annotation(defaultComponentName = "pin", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"));
//         end Pin;
//         connector PositivePin "Positive pin of an electric component"
//           extends Pin;
//           annotation(defaultComponentName = "pin_p", Documentation(info = "<html><p>Connectors PositivePin
// and NegativePin are nearly identical.
// The only difference is that the icons are different in order
// to identify more easily the pins of a component. Usually,
// connector PositivePin is used for the positive and
// connector NegativePin for the negative pin of an electrical
// component.</p></html>", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -160,50},{40,110}}, textString = "%name", fontName = "Arial")}));
//         end PositivePin;
//         connector NegativePin "Negative pin of an electric component"
//           extends Pin;
//           annotation(defaultComponentName = "pin_n", Documentation(info = "<html><p>Connectors PositivePin
// and NegativePin are nearly identical.
// The only difference is that the icons are different in order
// to identify more easily the pins of a component. Usually,
// connector PositivePin is used for the positive and
// connector NegativePin for the negative pin of an electrical
// component.</p></html>", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -40,50},{160,110}}, textString = "%name", fontName = "Arial")}));
//         end NegativePin;
//         partial model TwoPin "Component with one electrical port"
//           SI.Voltage v "Voltage drop between the two pins (= p.v - n.v)";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -120,3},{ -110,0},{ -120, -3},{ -120,3}}),Line(visible = true, points = {{ -136,0},{ -111,0}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -134,5},{ -117,20}}, textString = "p.i", fontName = "Arial"),Line(visible = true, points = {{110,0},{135,0}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,3},{110,0},{120, -3},{120,3}}),Text(visible = true, fillColor = {160,160,160}, extent = {{117,3},{134,18}}, textString = "n.i", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           PositivePin p "Positive pin Positive pin (potential p.v > n.v for positive voltage drop v)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePin n "Negative pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v = p.v - n.v;
//         end TwoPin;
//         partial model OnePort "Component with two electrical pins p and n and current i from p to n"
//           SI.Voltage v "Voltage drop between the two pins (= p.v - n.v)";
//           SI.Current i "Current flowing from pin p to pin n";
//           annotation(Documentation(info = "<HTML>
// <P>
// Superclass of elements which have <b>two</b> electrical pins:
// the positive pin connector <i>p</i>, and the negative pin
// connector <i>n</i>. It is assumed that the current flowing
// into pin p is identical to the current flowing out of pin n.
// This current is provided explicitly as current i.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -110,20},{ -85,20}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -95,23},{ -85,20},{ -95,17},{ -95,23}}),Line(visible = true, points = {{90,20},{115,20}}, color = {160,160,160}),Line(visible = true, points = {{ -125,0},{ -115,0}}, color = {160,160,160}),Line(visible = true, points = {{ -120, -5},{ -120,5}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -110,25},{ -90,45}}, textString = "i", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{105,23},{115,20},{105,17},{105,23}}),Line(visible = true, points = {{115,0},{125,0}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{90,25},{110,45}}, textString = "i", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           PositivePin p "Positive pin (potential p.v > n.v for positive voltage drop v)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePin n "Negative pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//         end OnePort;
//         partial model TwoPort "Component with two electrical ports, including current"
//           SI.Voltage v1 "Voltage drop over the left port";
//           SI.Voltage v2 "Voltage drop over the right port";
//           SI.Current i1 "Current flowing from pos. to neg. pin of the left port";
//           SI.Current i2 "Current flowing from pos. to neg. pin of the right port";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -120,53},{ -110,50},{ -120,47},{ -120,53}}),Line(visible = true, points = {{ -136,50},{ -111,50}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{127, -47},{137, -50},{127, -53},{127, -47}}),Line(visible = true, points = {{111, -50},{136, -50}}, color = {160,160,160}),Text(visible = true, fillColor = {160,160,160}, extent = {{112, -44},{128, -29}}, textString = "i2", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{118,52},{135,67}}, textString = "i2", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{120,53},{110,50},{120,47},{120,53}}),Line(visible = true, points = {{111,50},{136,50}}, color = {160,160,160}),Line(visible = true, points = {{ -136, -49},{ -111, -49}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -126, -46},{ -136, -49},{ -126, -52},{ -126, -46}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -127, -46},{ -110, -31}}, textString = "i1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -136,53},{ -119,68}}, textString = "i1", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>", info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           PositivePin p1 "Positive pin of the left port (potential p1.v > n1.v for positive voltage drop v1)" annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePin n1 "Negative pin of the left port" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           PositivePin p2 "Positive pin of the right port (potential p2.v > n2.v for positive voltage drop v2)" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           NegativePin n2 "Negative pin of the right port" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v1 = p1.v - n1.v;
//           v2 = p2.v - n2.v;
//           0 = p1.i + n1.i;
//           0 = p2.i + n2.i;
//           i1 = p1.i;
//           i2 = p2.i;
//         end TwoPort;
//         partial model AbsoluteSensor "Base class to measure the absolute value of a pin variable"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{100,0}})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p "Pin to be measured" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y "Measured quantity as Real output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Base class to measure a relative variable between two pins"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{96,0}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p "Positive pin" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n "Negative pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y "Measured quantity as Real output signal" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//         end RelativeSensor;
//         partial model VoltageSource "Interface for voltage sources"
//           extends OnePort;
//           parameter SI.Voltage offset = 0 "Voltage offset";
//           parameter SI.Time startTime = 0 "Time offset";
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{90,0}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -120,0},{ -20,50}}, textString = "+", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{20,0},{120,50}}, textString = "-", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           replaceable Modelica.Blocks.Interfaces.SignalSource signalSource(final offset = offset, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {80,80}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v = signalSource.y;
//         end VoltageSource;
//         partial model CurrentSource "Interface for current sources"
//           extends OnePort;
//           parameter SI.Current offset = 0 "Current offset";
//           parameter SI.Time startTime = 0 "Time offset";
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -90,0},{ -50,0}}),Line(visible = true, points = {{50,0},{90,0}}),Line(visible = true, points = {{0, -50},{0,50}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -60, -80},{60, -80}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60, -80},{30, -70},{30, -90},{60, -80}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           replaceable Modelica.Blocks.Interfaces.SignalSource signalSource(final offset = offset, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {80.5,79}, extent = {{ -10.5, -10},{10.5,10}}, rotation = 0)));
// 
//         equation 
//           i = signalSource.y;
//         end CurrentSource;
//       end Interfaces;
//       package Lines "Lossy and lossless segmented transmission lines, and LC distributed line models"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains lossy and lossless segmented transmission lines,
// and LC distributed line models.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Joachim.Haase/\">Joachim Haase;</a> 
//     &lt;<a href=\"mailto:haase@eas.iis.fhg.de\">haase@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a> 
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model OLine "Lossy Transmission Line"
//           SI.Voltage v13;
//           SI.Voltage v23;
//           SI.Current i1;
//           SI.Current i2;
//           parameter Real r(final min = Modelica.Constants.small, unit = "Ohm/m") = 1 "Resistance per meter";
//           parameter Real l(final min = Modelica.Constants.small, unit = "H/m") = 1 "Inductance per meter";
//           parameter Real g(final min = Modelica.Constants.small, unit = "Siemens/m") = 1 "Conductance per meter";
//           parameter Real c(final min = Modelica.Constants.small, unit = "F/m") = 1 "Capacitance per meter";
//           parameter SI.Length length(final min = Modelica.Constants.small) = 1 "Length of line";
//           parameter Integer N(final min = 1) = 1 "Number of lumped segments";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{0, -60},{0, -90}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -60,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{0, -60},{0, -96}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{ -60,0},{ -96,0}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255})}));
//           Interfaces.Pin p1 annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin p2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin p3 annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Basic.Resistor R[N + 1](R = fill((r * length) / (N + 1), N + 1));
//           Basic.Inductor L[N + 1](L = fill((l * length) / (N + 1), N + 1));
//           Basic.Capacitor C[N](C = fill((c * length) / N, N));
//           Basic.Conductor G[N](G = fill((g * length) / N, N));
//           annotation(Documentation(info = "<html>
// <P>
// Lossy Transmission Line.
//   The lossy transmission line OLine consists of segments of
//   lumped resistances and inductances in series
//   and conductances and capacitances that are
//   connected with the reference pin p3. The precision
//   of the model depends on the number N of
//   lumped segments.
// </P>
// <DL>
// <DT>
// <b>References:</b>
// <DD>
//   Johnson, B.; Quarles, T.; Newton, A. R.; Pederson, D. O.;
//   Sangiovanni-Vincentelli, A.: SPICE3 Version 3e User's Manual
//   (April 1, 1991). Department of Electrical Engineering and
//   Computer Sciences, University of California, Berkley
//   p. 12, p. 106 - 107
// </DL>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}, fillPattern = FillPattern.Solid, fillColor = {255,255,255}),Line(color = {0,0,255}, points = {{0, -60},{0, -90}}),Line(color = {0,0,255}, points = {{60,0},{90,0}}),Line(color = {0,0,255}, points = {{ -60,0},{ -90,0}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "%name")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{0, -60},{0, -96}}),Line(color = {0,0,255}, points = {{60,0},{96,0}}),Line(color = {0,0,255}, points = {{ -60,0},{ -96,0}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}})}));
// 
//         equation 
//           connect(L[N + 1].n,p2);
//           connect(R[N + 1].n,L[N + 1].p);
//           connect(p1,R[1].p);
//           v13 = p1.v - p3.v;
//           v23 = p2.v - p3.v;
//           i1 = p1.i;
//           i2 = p2.i;
//           for i in 1:N loop
//           connect(R[i].n,L[i].p);
//           connect(L[i].n,C[i].p);
//           connect(L[i].n,G[i].p);
//           connect(C[i].n,p3);
//           connect(G[i].n,p3);
//           connect(L[i].n,R[i + 1].p);
// 
//           end for;
//         end OLine;
//         model ULine "Lossy RC Line"
//           SI.Voltage v13;
//           SI.Voltage v23;
//           SI.Current i1;
//           SI.Current i2;
//           parameter Real r(final min = Modelica.Constants.small, unit = "Ohm/m") = 1 "Resistance per meter";
//           parameter Real c(final min = Modelica.Constants.small, unit = "F/m") = 1 "Capacitance per meter";
//           parameter SI.Length length(final min = Modelica.Constants.small) = 1 "Length of line";
//           parameter Integer N(final min = 1) = 1 "Number of lumped segments";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{0, -60},{0, -90}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -60,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{0, -60},{0, -96}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{ -60,0},{ -96,0}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255})}));
//           Interfaces.Pin p1 annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin p2 annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin p3 annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Basic.Resistor R[N + 1](R = fill((r * length) / (N + 1), N + 1));
//           Basic.Capacitor C[N](C = fill((c * length) / N, N));
//           annotation(Documentation(info = "<html>
// <P>
// The lossy RC line ULine consists of segments of
// lumped series resistances and capacitances that are
// connected with the reference pin p3. The precision
// of the model depends on the number N of
// lumped segments.
// </P>
// 
// <p>
// <b>References</b></dt>
// </p>
// <dl>
// <dt> Johnson, B.; Quarles, T.; Newton, A. R.; Pederson, D. O.;
//     Sangiovanni-Vincentelli, A.</dt>
// <dd> SPICE3 Version 3e User's Manual
//     (April 1, 1991). Department of Electrical Engineering and
//     Computer Sciences, University of California, Berkley
//     p. 22, p. 124</dd>
// </dl>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}, fillPattern = FillPattern.Solid, fillColor = {255,255,255}),Line(color = {0,0,255}, points = {{0, -60},{0, -90}}),Line(color = {0,0,255}, points = {{60,0},{90,0}}),Line(color = {0,0,255}, points = {{ -60,0},{ -90,0}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "%name")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{0, -60},{0, -96}}),Line(color = {0,0,255}, points = {{60,0},{96,0}}),Line(color = {0,0,255}, points = {{ -60,0},{ -96,0}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}})}));
// 
//         equation 
//           connect(R[N + 1].n,p2);
//           connect(p1,R[1].p);
//           v13 = p1.v - p3.v;
//           v23 = p2.v - p3.v;
//           i1 = p1.i;
//           i2 = p2.i;
//           for i in 1:N loop
//           connect(R[i].n,R[i + 1].p);
// 
//           end for;
//           for i in 1:N loop
//           connect(R[i].n,C[i].p);
// 
//           end for;
//           for i in 1:N loop
//           connect(C[i].n,p3);
// 
//           end for;
//         end ULine;
//         model TLine1 "Lossless transmission line with characteristic impedance Z0 and transmission delay TD"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Characteristic impedance";
//           parameter Modelica.SIunits.Time TD = 1 "Transmission delay";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{96, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -96, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -30, -31},{31,0}}, textString = "TLine1", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{90, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -90, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -30, -20},{30,10}}, textString = "TLine1", fontName = "Arial")}));
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           annotation(Documentation(info = "<html>
// <p>
// Lossless transmission line with characteristic impedance Z0 and transmission delay TD
//   The lossless transmission line TLine1 is a two Port. Both port branches
//   consist of a resistor with characteristic impedance Z0 and a controled voltage
//   source that takes into consideration the transmission delay TD.
//   For further details see Branin's article below.
//   The model parameters can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e.
//   Z0 = sqrt(L'/C') and TD = sqrt(L'*C')*length_of_line. Resistance R'
//   and conductance C' per meter are assumed to be zero.
// </p>
// 
// 
// <p>
// <b>References:</b>
// </p>
// <dl>
// <dt>Branin Jr., F. H.</dt>
// <dd> Transient Analysis of Lossless Transmission Lines.
//      Proceedings of the IEEE 55(1967), 2012 - 2013<dd>
// <dt> Hoefer, E. E. E.; Nielinger, H.</dt>
// <dd> SPICE : Analyseprogramm fuer elektronische
//   Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// </dd>
// </dl>
// 
// </html>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Joachim Haase<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{90, -50}}),Line(color = {0,0,255}, points = {{60,50},{90,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -90,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -90, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine1"),Text(lineColor = {0,0,255}, extent = {{ -30,10},{30, -20}}, textString = "TLine1")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{96, -50}}),Line(color = {0,0,255}, points = {{60,50},{96,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -96,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -96, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine1"),Text(lineColor = {0,0,255}, extent = {{ -30,0},{31, -31}}, textString = "TLine1")}));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(TD > 0, "TD has to be positive");
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine1;
//         model TLine2 "Lossless transmission line with characteristic impedance Z0, frequency F and normalized length NL"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Characteristic impedance";
//           parameter Modelica.SIunits.Frequency F = 1 "Frequency";
//           parameter Real NL = 1 "Normalized length";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{96, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -96, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine2", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{90, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -90, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -30, -20},{30,9.997}}, textString = "TLine2", fontName = "Arial")}));
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           parameter Modelica.SIunits.Time TD = NL / F;
//           annotation(Documentation(info = "<html>
// <p>
// Lossless transmission line with characteristic impedance Z0, frequency F and normalized length NL
//   The lossless transmission line TLine2 is a two Port. Both port branches
//   consist of a resistor with the value of the characteristic impedance Z0 
//   and a controled voltage source that takes into consideration 
//   the transmission delay.
//   For further details see Branin's article below.
//   Resistance R' and conductance C' per meter are assumed to be zero.
//   The characteristic impedance Z0 can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e. Z0 = sqrt(L'/C').   
//   The normalized length NL is equal to the length of the line divided
//   by the wavelength corresponding to the frequency F, i. e. the
//   transmission delay TD is the quotient of NL and F.
// </p>
// 
// 
// <p>
// <b>References:</b>
// </p>
// <dl>
// <dt>Branin Jr., F. H.</dt>
// <dd> Transient Analysis of Lossless Transmission Lines.
//      Proceedings of the IEEE 55(1967), 2012 - 2013<dd>
// <dt> Hoefer, E. E. E.; Nielinger, H.</dt>
// <dd> SPICE : Analyseprogramm fuer elektronische
//   Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// </dd>
// </dl>
// 
// </html>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Joachim Haase<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{90, -50}}),Line(color = {0,0,255}, points = {{60,50},{90,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -90,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -90, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine2"),Text(lineColor = {0,0,255}, extent = {{ -30,10},{30, -20}}, textString = "TLine2")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{96, -50}}),Line(color = {0,0,255}, points = {{60,50},{96,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -96,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -96, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine2")}));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(NL > 0, "NL has to be positive");
//           assert(F > 0, "F  has to be positive");
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine2;
//         model TLine3 "Lossless transmission line with characteristic impedance Z0 and frequency F"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Natural impedance";
//           parameter Modelica.SIunits.Frequency F = 1 "Frequency";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{96, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -96,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -96, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine3", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{60, -50},{90, -50}}, color = {0,0,255}),Line(visible = true, points = {{60,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60,50},{ -90,50}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -50},{ -90, -50}}, color = {0,0,255}),Line(visible = true, points = {{30,30},{ -30,30}}, color = {0,0,255}),Line(visible = true, points = {{ -30,40},{ -30,20}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30,20}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "TLine3", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -29, -31},{30, -1}}, textString = "TLine3", fontName = "Arial")}));
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           parameter Modelica.SIunits.Time TD = 1 / F / 4;
//           annotation(Documentation(info = "<html>
// <p>
// Lossless transmission line with characteristic impedance Z0 and frequency F
//   The lossless transmission line TLine3 is a two Port. Both port branches
//   consist of a resistor with value of the characteristic impedance Z0 
//   and a controled voltage source that takes into consideration 
//   the transmission delay.
//   For further details see Branin's article below.
//   Resistance R' and conductance C' per meter are assumed to be zero.
//   The characteristic impedance Z0 can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e. Z0 = sqrt(L'/C').   
//   The length of the line is equal to a quarter of the wavelength
//   corresponding to the frequency F, i. e. the
//   transmission delay is the quotient of 4 and F.
//   In this case, the caracteristic impedance is called natural impedance.
// </p>
// 
// 
// <p>
// <b>References:</b>
// </p>
// <dl>
// <dt>Branin Jr., F. H.</dt>
// <dd> Transient Analysis of Lossless Transmission Lines.
//      Proceedings of the IEEE 55(1967), 2012 - 2013<dd>
// <dt> Hoefer, E. E. E.; Nielinger, H.</dt>
// <dd> SPICE : Analyseprogramm fuer elektronische
//   Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// </dd>
// </dl>
// 
// </html>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Joachim Haase<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{90, -50}}),Line(color = {0,0,255}, points = {{60,50},{90,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -90,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -90, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine3"),Text(lineColor = {0,0,255}, extent = {{ -29, -1},{30, -31}}, textString = "TLine3")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(lineColor = {0,0,255}, extent = {{ -60,60},{60, -60}}),Line(color = {0,0,255}, points = {{60, -50},{96, -50}}),Line(color = {0,0,255}, points = {{60,50},{96,50}}),Line(color = {0,0,255}, points = {{ -60,50},{ -96,50}}),Line(color = {0,0,255}, points = {{ -60, -50},{ -96, -50}}),Line(color = {0,0,255}, points = {{30,30},{ -30,30}}),Line(color = {0,0,255}, points = {{ -30,40},{ -30,20}}),Line(color = {0,0,255}, points = {{30,40},{30,20}}),Text(lineColor = {0,0,255}, extent = {{ -100,100},{100,70}}, textString = "TLine3")}));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(F > 0, "F  has to be positive");
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine3;
//       end Lines;
//       package Semiconductors "Semiconductor devices such as diode, MOS and bipolar transistor"
//         extends Modelica.Icons.Library;
//         import Modelica.SIunits;
//         annotation(preferedView = "info", Documentation(info = "
// <HTML>
// <p>
// This package contains semiconductor devices:
// <ul>
// <li>diode</li>
// <li>MOS transistors</li>
// <li>bipolar transistors</li>
// <li>diode, MOS and bipolar transistors with temperature
//     dependent characteristic and a heatPort for connection
//     to the thermal domain</li>
// </ul>
// </p>
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model Diode "Simple diode"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter SIunits.Current Ids = 1e-06 "Saturation current";
//           parameter SIunits.Voltage Vt = 0.04 "Voltage equivalent of temperature (kT/qn)";
//           parameter Real Maxexp(final min = Modelica.Constants.small) = 15 "Max. exponent for linear continuation";
//           parameter SIunits.Resistance R = 100000000.0 "Parallel ohmic resistance";
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The simple diode is a one port. It consists of the diode itself and an parallel ohmic
// resistance <i>R</i>. The diode formula is:
// </P>
// <PRE>
//                 v/vt
//   i  =  ids ( e      - 1).
// </PRE>
// <P>
// If the exponent <i>v/vt</i> reaches the limit <i>maxex</i>, the diode characterisic is linearly
// continued to avoid overflow.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i> November 15, 2005   </i>
//        by Christoph Clauss<br> smooth function added<br>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -96,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -98, -100},{102, -58}}, textString = "Vt=%Vt", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,70},{100,100}}, textString = "%name", fontName = "Arial")}));
// 
//         equation 
//           i = smooth(1, if v / Vt > Maxexp then Ids * (exp(Maxexp) * (1 + v / Vt - Maxexp) - 1) + v / R else Ids * (exp(v / Vt) - 1) + v / R);
//         end Diode;
//         model PMOS "Simple MOS Transistor"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The PMOS model is a simple model of a p-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag
//   Muenchen Wien 1990.
// </DL>
// <P>
// Some typical parameter sets are:
// </P>
// <PRE>
//   W       L      Beta        Vt       K2       K5       DW         DL
//   m       m      A/V^2       V        -        -        m          m
//   50.e-6  8.e-6  .0085e-3   -.15     .41      .839    -3.8e-6    -4.0e-6
//   20.e-6  6.e-6  .0105e-3  -1.0      .41      .839    -2.5e-6    -2.1e-6
//   30.e-6  5.e-6  .0059e-3   -.3      .98     1.01      0         -3.9e-6
//   30.e-6  5.e-6  .0152e-3   -.69     .104    1.1       -.8e-6     -.4e-6
//   30.e-6  5.e-6  .0163e-3   -.69     .104    1.1       -.8e-6     -.4e-6
//   30.e-6  5.e-6  .0182e-3   -.69     .086    1.06      -.1e-6     -.6e-6
//   20.e-6  6.e-6  .0074e-3  -1.       .4       .59      0          0
// </PRE>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>December 7, 2005   </i>
//        by Christoph Clauss<br>
//        error in RDS calculation deleted</li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{96, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60,0},{40,5},{40, -5},{60,0}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,60},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{91,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{90, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60,0},{40,5},{40, -5},{60,0}})}));
//           parameter SIunits.Length W = 2e-05 "Width";
//           parameter SIunits.Length L = 6e-06 "Length";
//           parameter SIunits.Transconductance Beta = 1.05e-05 "Transconductance parameter";
//           parameter SIunits.Voltage Vt =  -1.0 "Zero bias threshold voltage";
//           parameter Real K2 = 0.41 "Bulk threshold parameter";
//           parameter Real K5 = 0.839 "Reduction of pinch-off region";
//           parameter SIunits.Length dW =  -2.5e-06 "Narrowing of channel";
//           parameter SIunits.Length dL =  -2.1e-06 "Shortening of channel";
//           parameter SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           Interfaces.Pin D "Drain" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin G "Gate" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0)));
//           Interfaces.Pin S "Source" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Interfaces.Pin B "Bulk" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
// 
//         equation 
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (Beta * (W + dW)) / (L + dL);
//           ud = if D.v > S.v then S.v else D.v;
//           us = if D.v > S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v < us then 0 else B.v - us;
//           ugst = (G.v - us - Vt + K2 * ubs) * K5;
//           id = if ugst >= 0 then uds * gds else if ugst < uds then  -v * uds * (ugst - uds / 2) + uds * gds else  -(v * ugst * ugst) / 2 + uds * gds;
//           G.i = 0;
//           D.i = if D.v > S.v then  -id else id;
//           S.i = if D.v > S.v then id else  -id;
//           B.i = 0;
//         end PMOS;
//         model NMOS "Simple MOS Transistor"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The NMos model is a simple model of a n-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <P>
// <PRE>
//   W       L      Beta        Vt       K2      K5       DW         DL
//   m       m      A/V^2       V        -       -        m          m
//   12.e-6  4.e-6  .062e-3   -4.5      .24     .61     -1.2e-6     -.9e-6      depletion
//   60.e-6  3.e-6  .048e-3     .1      .08     .68     -1.2e-6     -.9e-6      enhancement
//   12.e-6  4.e-6  .0625e-3   -.8      .21     .78     -1.2e-6     -.9e-6      zero
//   50.e-6  8.e-6  .0299e-3    .24    1.144    .7311   -5.4e-6    -4.e-6
//   20.e-6  6.e-6  .041e-3     .8     1.144    .7311   -2.5e-6    -1.5e-6
//   30.e-6  9.e-6  .025e-3   -4.       .861    .878    -3.4e-6    -1.74e-6
//   30.e-6  5.e-6  .031e-3     .6     1.5      .72      0         -3.9e-6
//   50.e-6  6.e-6  .0414e-3  -3.8      .34     .8      -1.6e-6    -2.e-6       depletion
//   50.e-6  5.e-6  .03e-3      .37     .23     .86     -1.6e-6    -2.e-6       enhancement
//   50.e-6  6.e-6  .038e-3    -.9      .23     .707    -1.6e-6    -2.e-6       zero
//   20.e-6  4.e-6  .06776e-3   .5409   .065    .71      -.8e-6     -.2e-6
//   20.e-6  4.e-6  .06505e-3   .6209   .065    .71      -.8e-6     -.2e-6
//   20.e-6  4.e-6  .05365e-3   .6909   .03     .8       -.3e-6     -.2e-6
//   20.e-6  4.e-6  .05365e-3   .4909   .03     .8       -.3e-6     -.2e-6
//   12.e-6  4.e-6  .023e-3   -4.5      .29     .6       0          0           depletion
//   60.e-6  3.e-6  .022e-3     .1      .11     .65      0          0           enhancement
//   12.e-6  4.e-6  .038e-3    -.8      .33     .6       0          0           zero
//   20.e-6  6.e-6  .022e-3     .8     1        .66      0          0
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag
// Muenchen Wien 1990.
// </DL>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>December 7, 2005   </i>
//        by Christoph Clauss<br>
//        error in RDS calculation deleted</li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{96, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,0},{60,5},{60, -5},{40,0}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{91,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{90, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,0},{60,5},{60, -5},{40,0}})}));
//           parameter SIunits.Length W = 2e-05 "Width";
//           parameter SIunits.Length L = 6e-06 "Length";
//           parameter SIunits.Transconductance Beta = 4.1e-05 "Transconductance parameter";
//           parameter SIunits.Voltage Vt = 0.8 "Zero bias threshold voltage";
//           parameter Real K2 = 1.144 "Bulk threshold parameter";
//           parameter Real K5 = 0.7311 "Reduction of pinch-off region";
//           parameter SIunits.Length dW =  -2.5e-06 "narrowing of channel";
//           parameter SIunits.Length dL =  -1.5e-06 "shortening of channel";
//           parameter SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           Interfaces.Pin D "Drain" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Pin G "Gate" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0)));
//           Interfaces.Pin S "Source" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Interfaces.Pin B "Bulk" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
// 
//         equation 
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (Beta * (W + dW)) / (L + dL);
//           ud = if D.v < S.v then S.v else D.v;
//           us = if D.v < S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v > us then 0 else B.v - us;
//           ugst = (G.v - us - Vt + K2 * ubs) * K5;
//           id = if ugst <= 0 then uds * gds else if ugst > uds then v * uds * (ugst - uds / 2) + uds * gds else (v * ugst * ugst) / 2 + uds * gds;
//           G.i = 0;
//           D.i = if D.v < S.v then  -id else id;
//           S.i = if D.v < S.v then id else  -id;
//           B.i = 0;
//         end NMOS;
//         model NPN "Simple BJT according to Ebers-Moll"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter SIunits.Voltage Vt = 0.02585 "Voltage equivalent of temperature";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{91,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{91, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30, -50},{24, -36},{16, -44},{30, -50}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{100, -50}}, color = {0,0,255}),Line(visible = true, points = {{100,50},{30,50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30, -50},{24, -36},{16, -44},{30, -50}})}));
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//         protected 
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           function pow "Just a helper function for x^y"
//             input Real x;
//             input Real y;
//             output Real z;
//           algorithm 
//             z:=x ^ y;
//           end pow;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar npn junction transistor according
// to Ebers-Moll.
// </P>
// <P>
// A typical parameter set is:
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe    Vt
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     V
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15  0.02585
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// <P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -100,80},{100,100}}, textString = "%name"),Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -90,0}}),Line(color = {0,0,255}, points = {{91,50},{30,50}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{91, -50}}),Polygon(lineColor = {0,0,255}, points = {{30, -50},{24, -36},{16, -44},{30, -50}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -100,0}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{100, -50}}),Line(color = {0,0,255}, points = {{100,50},{30,50}}),Polygon(lineColor = {0,0,255}, points = {{30, -50},{24, -36},{16, -44},{30, -50}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid)}));
// 
//         equation 
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = B.v - C.v;
//           vbe = B.v - E.v;
//           qbk = 1 - vbc * Vak;
//           ibc = if vbc / Vt < EMin then Is * (ExMin * (vbc / Vt - EMin + 1) - 1) + vbc * Gbc else if vbc / Vt > EMax then Is * (ExMax * (vbc / Vt - EMax + 1) - 1) + vbc * Gbc else Is * (exp(vbc / Vt) - 1) + vbc * Gbc;
//           ibe = if vbe / Vt < EMin then Is * (ExMin * (vbe / Vt - EMin + 1) - 1) + vbe * Gbe else if vbe / Vt > EMax then Is * (ExMax * (vbe / Vt - EMax + 1) - 1) + vbe * Gbe else Is * (exp(vbe / Vt) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / Vt < EMin then (Taur * Is) / Vt * ExMin * (vbc / Vt - EMin + 1) + Capcjc else if vbc / Vt > EMax then (Taur * Is) / Vt * ExMax * (vbc / Vt - EMax + 1) + Capcjc else (Taur * Is) / Vt * exp(vbc / Vt) + Capcjc;
//           cbe = if vbe / Vt < EMin then (Tauf * Is) / Vt * ExMin * (vbe / Vt - EMin + 1) + Capcje else if vbe / Vt > EMax then (Tauf * Is) / Vt * ExMax * (vbe / Vt - EMax + 1) + Capcje else (Tauf * Is) / Vt * exp(vbe / Vt) + Capcje;
//           C.i = (ibe - ibc) * qbk - ibc / Br - cbc * der(vbc) + Ccs * der(C.v);
//           B.i = ibe / Bf + ibc / Br + cbc * der(vbc) + cbe * der(vbe);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//         end NPN;
//         model PNP "Simple BJT according to Ebers-Moll"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter SIunits.Voltage Vt = 0.02585 "Voltage equivalent of temperature";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{91,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{91, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -99,0}}, color = {0,0,255}),Line(visible = true, points = {{100,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{99, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}})}));
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//         protected 
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           function pow "Just a helper function for x^y"
//             input Real x;
//             input Real y;
//             output Real z;
//           algorithm 
//             z:=x ^ y;
//           end pow;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar pnp junction transistor according
// to Ebers-Moll.
// <P>
// A typical parameter set is:
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe    Vt
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     V
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15  0.02585
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// <P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -100,80},{100,100}}, textString = "%name"),Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -90,0}}),Line(color = {0,0,255}, points = {{91,50},{30,50}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{91, -50}}),Polygon(lineColor = {0,0,255}, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -99,0}}),Line(color = {0,0,255}, points = {{100,50},{30,50}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{99, -50}}),Polygon(lineColor = {0,0,255}, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid)}));
// 
//         equation 
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = C.v - B.v;
//           vbe = E.v - B.v;
//           qbk = 1 - vbc * Vak;
//           ibc = if vbc / Vt < EMin then Is * (ExMin * (vbc / Vt - EMin + 1) - 1) + vbc * Gbc else if vbc / Vt > EMax then Is * (ExMax * (vbc / Vt - EMax + 1) - 1) + vbc * Gbc else Is * (exp(vbc / Vt) - 1) + vbc * Gbc;
//           ibe = if vbe / Vt < EMin then Is * (ExMin * (vbe / Vt - EMin + 1) - 1) + vbe * Gbe else if vbe / Vt > EMax then Is * (ExMax * (vbe / Vt - EMax + 1) - 1) + vbe * Gbe else Is * (exp(vbe / Vt) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / Vt < EMin then (Taur * Is) / Vt * ExMin * (vbc / Vt - EMin + 1) + Capcjc else if vbc / Vt > EMax then (Taur * Is) / Vt * ExMax * (vbc / Vt - EMax + 1) + Capcjc else (Taur * Is) / Vt * exp(vbc / Vt) + Capcjc;
//           cbe = if vbe / Vt < EMin then (Tauf * Is) / Vt * ExMin * (vbe / Vt - EMin + 1) + Capcje else if vbe / Vt > EMax then (Tauf * Is) / Vt * ExMax * (vbe / Vt - EMax + 1) + Capcje else (Tauf * Is) / Vt * exp(vbe / Vt) + Capcje;
//           C.i =  -(ibe - ibc) * qbk - ibc / Br - cbc * der(vbc) - Ccs * der(C.v);
//           B.i =  -ibe / Bf + ibc / Br + cbe * der(vbe) + cbc * der(vbc);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//         end PNP;
//         model HeatingDiode "Simple diode with heating port"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Current Ids = 1e-06 "Saturation current";
//           parameter Real Maxexp(final min = Modelica.Constants.small) = 15 "Max. exponent for linear continuation";
//           parameter Modelica.SIunits.Resistance R = 100000000.0 "Parallel ohmic resistance";
//           parameter Real EG = 1.11 "activation energy";
//           parameter Real N = 1 "Emission coefficient";
//           parameter Modelica.SIunits.Temperature TNOM = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent of saturation current";
//           Modelica.SIunits.Temperature vt_t "Temperature voltage";
//           Modelica.SIunits.Current id "diode current";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -142,51},{143,101}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{0, -20},{0, -91}}, color = {191,0,0})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{ -99,0},{39,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{0, -20},{0, -91}}, color = {191,0,0})}));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
//         protected 
//           Real k = 1.380662e-23 "Boltzmann's constant, J/K";
//           Real q = 1.6021892e-19 "Electron charge, As";
//           Modelica.SIunits.Temperature htemp "auxiliary temperature";
//           Real aux;
//           Real auxp;
//           Real maxexp = exp(Maxexp);
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The simple diode is an electrical one port, where a heat port is added, which is
// defined in the Modelica.Thermal library. It consists of the diode itself and an parallel ohmic
// resistance <i>R</i>. The diode formula is:
// </P>
// <PRE>
//                 v/vt_t
//   i  =  ids ( e        - 1).
// </PRE>
// where vt_t depends on the temperature of the heat port:
// <PRE>
//   vt_t = k*temp/q
// </PRE>
// <P>
// If the exponent <i>v/vt_t</i> reaches the limit <i>maxex</i>, the diode characterisic is linearly
// continued to avoid overflow.<br>
// The thermal power is calculated by <i>i*v</i>.
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>April 5, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{30,0},{ -30,40},{ -30, -40},{30,0}}, fillPattern = FillPattern.Solid, lineColor = {0,0,255}, fillColor = {255,255,255}),Line(color = {0,0,255}, points = {{ -90,0},{40,0}}),Line(color = {0,0,255}, points = {{40,0},{90,0}}),Line(points = {{30,40},{30, -40}}, color = {0,0,255}),Text(lineColor = {0,0,255}, extent = {{ -142,101},{143,51}}, textString = "%name"),Line(points = {{0, -20},{0, -91}}, color = {191,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{30,0},{ -30,40},{ -30, -40},{30,0}}, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.None),Line(color = {0,0,255}, points = {{ -99,0},{39,0}}),Line(color = {0,0,255}, points = {{40,0},{96,0}}),Line(points = {{30,40},{30, -40}}, color = {0,0,255}),Line(points = {{0, -20},{0, -91}}, color = {191,0,0})}));
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           htemp = heatPort.T;
//           vt_t = (k * htemp) / q;
//           id = exlin(v / (N * vt_t), Maxexp) - 1;
//           aux = ((htemp / TNOM - 1) * EG) / (N * vt_t);
//           auxp = exp(aux);
//           i = Ids * id * pow(htemp / TNOM, XTI / N) * auxp + v / R;
//           heatPort.Q_flow =  -i * v;
//         end HeatingDiode;
//         model HeatingNMOS "Simple MOS Transistor with heating port"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The NMos model is a simple model of a n-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <P>
// <PRE>
//   W       L      Beta        Vt       K2      K5       DW         DL
//   m       m      A/V^2       V        -       -        m          m
//   12.e-6  4.e-6  .062e-3   -4.5      .24     .61     -1.2e-6     -.9e-6      depletion
//   60.e-6  3.e-6  .048e-3     .1      .08     .68     -1.2e-6     -.9e-6      enhancement
//   12.e-6  4.e-6  .0625e-3   -.8      .21     .78     -1.2e-6     -.9e-6      zero
//   50.e-6  8.e-6  .0299e-3    .24    1.144    .7311   -5.4e-6    -4.e-6
//   20.e-6  6.e-6  .041e-3     .8     1.144    .7311   -2.5e-6    -1.5e-6
//   30.e-6  9.e-6  .025e-3   -4.       .861    .878    -3.4e-6    -1.74e-6
//   30.e-6  5.e-6  .031e-3     .6     1.5      .72      0         -3.9e-6
//   50.e-6  6.e-6  .0414e-3  -3.8      .34     .8      -1.6e-6    -2.e-6       depletion
//   50.e-6  5.e-6  .03e-3      .37     .23     .86     -1.6e-6    -2.e-6       enhancement
//   50.e-6  6.e-6  .038e-3    -.9      .23     .707    -1.6e-6    -2.e-6       zero
//   20.e-6  4.e-6  .06776e-3   .5409   .065    .71      -.8e-6     -.2e-6
//   20.e-6  4.e-6  .06505e-3   .6209   .065    .71      -.8e-6     -.2e-6
//   20.e-6  4.e-6  .05365e-3   .6909   .03     .8       -.3e-6     -.2e-6
//   20.e-6  4.e-6  .05365e-3   .4909   .03     .8       -.3e-6     -.2e-6
//   12.e-6  4.e-6  .023e-3   -4.5      .29     .6       0          0           depletion
//   60.e-6  3.e-6  .022e-3     .1      .11     .65      0          0           enhancement
//   12.e-6  4.e-6  .038e-3    -.8      .33     .6       0          0           zero
//   20.e-6  6.e-6  .022e-3     .8     1        .66      0          0
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag
// Muenchen Wien 1990.
// </DL>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>December 7, 2005   </i>
//        by Christoph Clauss<br>
//        error in RDS calculation deleted</li>
// <li><i>March 31, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{96,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{96, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,0},{60,5},{60, -5},{40,0}}),Line(visible = true, points = {{0, -90},{0, -49}}, color = {191,0,0})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{91,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{90, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40,0},{60,5},{60, -5},{40,0}}),Line(visible = true, points = {{0, -91},{0, -50}}, color = {191,0,0})}));
//           parameter Modelica.SIunits.Length W = 2e-05 "Width";
//           parameter Modelica.SIunits.Length L = 6e-06 "Length";
//           parameter Modelica.SIunits.Transconductance Beta = 4.1e-05 "Transconductance parameter";
//           parameter Modelica.SIunits.Voltage Vt = 0.8 "Zero bias threshold voltage";
//           parameter Real K2 = 1.144 "Bulk threshold parameter";
//           parameter Real K5 = 0.7311 "Reduction of pinch-off region";
//           parameter Modelica.SIunits.Length dW =  -2.5e-06 "narrowing of channel";
//           parameter Modelica.SIunits.Length dL =  -1.5e-06 "shortening of channel";
//           parameter Modelica.SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real kvt =  -0.00696 "fitting parameter for Vt";
//           parameter Real kk2 = 0.0006 "fitting parameter for K22";
//           Modelica.Electrical.Analog.Interfaces.Pin D "Drain" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin G "Gate" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin S "Source" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Bulk" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
//           Real beta_t;
//           Real vt_t;
//           Real k2_t;
// 
//         equation 
//           assert(L + dL > 0, "Effective length must be positive");
//           assert(W + dW > 0, "Effective width  must be positive");
//           assert(heatPort.T > 0, "temperature must be positive");
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (beta_t * (W + dW)) / (L + dL);
//           ud = if D.v < S.v then S.v else D.v;
//           us = if D.v < S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v > us then 0 else B.v - us;
//           ugst = (G.v - us - vt_t + k2_t * ubs) * K5;
//           id = if ugst <= 0 then uds * gds else if ugst > uds then v * uds * (ugst - uds / 2) + uds * gds else (v * ugst * ugst) / 2 + uds * gds;
//           beta_t = Beta * pow(heatPort.T / Tnom,  -1.5);
//           vt_t = Vt * (1 + (heatPort.T - Tnom) * kvt);
//           k2_t = K2 * (1 + (heatPort.T - Tnom) * kk2);
//           G.i = 0;
//           D.i = if D.v < S.v then  -id else id;
//           S.i = if D.v < S.v then id else  -id;
//           B.i = 0;
//           heatPort.Q_flow =  -D.i * (D.v - S.v);
//         end HeatingNMOS;
//         model HeatingPMOS "Simple PMOS Transistor with heating port"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The PMOS model is a simple model of a p-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag
//   Muenchen Wien 1990.
// </DL>
// <P>
// Some typical parameter sets are:
// </P>
// <PRE>
//   W       L      Beta        Vt       K2       K5       DW         DL
//   m       m      A/V^2       V        -        -        m          m
//   50.e-6  8.e-6  .0085e-3   -.15     .41      .839    -3.8e-6    -4.0e-6
//   20.e-6  6.e-6  .0105e-3  -1.0      .41      .839    -2.5e-6    -2.1e-6
//   30.e-6  5.e-6  .0059e-3   -.3      .98     1.01      0         -3.9e-6
//   30.e-6  5.e-6  .0152e-3   -.69     .104    1.1       -.8e-6     -.4e-6
//   30.e-6  5.e-6  .0163e-3   -.69     .104    1.1       -.8e-6     -.4e-6
//   30.e-6  5.e-6  .0182e-3   -.69     .086    1.06      -.1e-6     -.6e-6
//   20.e-6  6.e-6  .0074e-3  -1.       .4       .59      0          0
// </PRE>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>December 7, 2005   </i>
//        by Christoph Clauss<br>
//        error in RDS calculation deleted</li>
// <li><i>March 31, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{96,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{101,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{100, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60,0},{40,5},{40, -5},{60,0}}),Line(visible = true, points = {{0, -95},{0, -50}}, color = {191,0,0})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90, -50},{ -10, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -50},{ -10,50}}, color = {0,0,255}),Line(visible = true, points = {{10,70},{10,29}}, color = {0,0,255}),Line(visible = true, points = {{10,20},{10, -21}}, color = {0,0,255}),Line(visible = true, points = {{10, -30},{10, -71}}, color = {0,0,255}),Line(visible = true, points = {{10,50},{91,50}}, color = {0,0,255}),Line(visible = true, points = {{10,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{10, -50},{90, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60,0},{40,5},{40, -5},{60,0}}),Line(visible = true, points = {{0, -91},{0, -50}}, color = {191,0,0})}));
//           parameter Modelica.SIunits.Length W = 2e-05 "Width";
//           parameter Modelica.SIunits.Length L = 6e-06 "Length";
//           parameter Modelica.SIunits.Transconductance Beta = 1.05e-05 "Transconductance parameter";
//           parameter Modelica.SIunits.Voltage Vt =  -1.0 "Zero bias threshold voltage";
//           parameter Real K2 = 0.41 "Bulk threshold parameter";
//           parameter Real K5 = 0.839 "Reduction of pinch-off region";
//           parameter Modelica.SIunits.Length dW =  -2.5e-06 "Narrowing of channel";
//           parameter Modelica.SIunits.Length dL =  -2.1e-06 "Shortening of channel";
//           parameter Modelica.SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real kvt =  -0.0029 "fitting parameter for Vt";
//           parameter Real kk2 = 0.00062 "fitting parameter for Kk2";
//           Modelica.Electrical.Analog.Interfaces.Pin D "Drain" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin G "Gate" annotation(Placement(visible = true, transformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0), iconTransformation(origin = { -100, -50}, extent = {{10,10},{ -10, -10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin S "Source" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Bulk" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
//           Real beta_t;
//           Real vt_t;
//           Real k2_t;
// 
//         equation 
//           assert(L + dL > 0, "Effective length must be positive");
//           assert(W + dW > 0, "Effective width  must be positive");
//           assert(heatPort.T > 0, "temperature must be positive");
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (beta_t * (W + dW)) / (L + dL);
//           ud = if D.v > S.v then S.v else D.v;
//           us = if D.v > S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v < us then 0 else B.v - us;
//           ugst = (G.v - us - vt_t + k2_t * ubs) * K5;
//           id = if ugst >= 0 then uds * gds else if ugst < uds then  -v * uds * (ugst - uds / 2) + uds * gds else  -(v * ugst * ugst) / 2 + uds * gds;
//           beta_t = Beta * pow(heatPort.T / Tnom,  -1.5);
//           vt_t = Vt * (1 + (heatPort.T - Tnom) * kvt);
//           k2_t = K2 * (1 + (heatPort.T - Tnom) * kk2);
//           G.i = 0;
//           D.i = if D.v > S.v then  -id else id;
//           S.i = if D.v > S.v then id else  -id;
//           B.i = 0;
//           heatPort.Q_flow =  -D.i * (D.v - S.v);
//         end HeatingPMOS;
//         model HeatingNPN "Simple NPN BJT according to Ebers-Moll with heating port"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter Modelica.SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter Modelica.SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter Modelica.SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter Modelica.SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter Modelica.SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter Modelica.SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter Modelica.SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter Modelica.SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter Modelica.SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter Modelica.SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter Modelica.SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent for effect on Is";
//           parameter Real XTB = 0 "Forward and reverse beta temperature exponent";
//           parameter Real EG = 1.11 "Energy gap for temperature effect on Is";
//           parameter Real NF = 1.0 "Forward current emission coefficient";
//           parameter Real NR = 1.0 "Reverse current emission coefficient";
//           parameter Real K = 1.3806226e-23 "Boltzmann's constant";
//           parameter Real q = 1.6021918e-19 "Elementary electronic charge";
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           Real is_t;
//           Real br_t;
//           Real bf_t;
//           Real vt_t;
//           Real hexp;
//           Real htempexp;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar npn junction transistor according
// to Ebers-Moll.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// A typical parameter set is (the parameter Vt is no longer used):
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// </P>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 20, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{100, -50}}, color = {0,0,255}),Line(visible = true, points = {{100,50},{30,50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30, -50},{24, -36},{16, -44},{30, -50}}),Line(visible = true, points = {{0, -94},{0, -32}}, color = {191,0,0})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{91,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{91, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30, -50},{24, -36},{16, -44},{30, -50}}),Line(visible = true, points = {{0, -91},{0, -30}}, color = {191,0,0})}));
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = B.v - C.v;
//           vbe = B.v - E.v;
//           qbk = 1 - vbc * Vak;
//           hexp = ((heatPort.T / Tnom - 1) * EG) / vt_t;
//           htempexp = if hexp < EMin then ExMin * (hexp - EMin + 1) else if hexp > EMax then ExMax * (hexp - EMax + 1) else exp(hexp);
//           is_t = Is * pow(heatPort.T / Tnom, XTI) * htempexp;
//           br_t = Br * pow(heatPort.T / Tnom, XTB);
//           bf_t = Bf * pow(heatPort.T / Tnom, XTB);
//           vt_t = K / q * heatPort.T;
//           ibc = if vbc / (NR * vt_t) < EMin then is_t * (ExMin * (vbc / (NR * vt_t) - EMin + 1) - 1) + vbc * Gbc else if vbc / (NR * vt_t) > EMax then is_t * (ExMax * (vbc / (NR * vt_t) - EMax + 1) - 1) + vbc * Gbc else is_t * (exp(vbc / (NR * vt_t)) - 1) + vbc * Gbc;
//           ibe = if vbe / (NF * vt_t) < EMin then is_t * (ExMin * (vbe / (NF * vt_t) - EMin + 1) - 1) + vbe * Gbe else if vbe / (NF * vt_t) > EMax then is_t * (ExMax * (vbe / (NF * vt_t) - EMax + 1) - 1) + vbe * Gbe else is_t * (exp(vbe / (NF * vt_t)) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / (NR * vt_t) < EMin then (Taur * is_t) / (NR * vt_t) * ExMin * (vbc / (NR * vt_t) - EMin + 1) + Capcjc else if vbc / (NR * vt_t) > EMax then (Taur * is_t) / (NR * vt_t) * ExMax * (vbc / (NR * vt_t) - EMax + 1) + Capcjc else (Taur * is_t) / (NR * vt_t) * exp(vbc / (NR * vt_t)) + Capcjc;
//           cbe = if vbe / (NF * vt_t) < EMin then (Tauf * is_t) / (NF * vt_t) * ExMin * (vbe / (NF * vt_t) - EMin + 1) + Capcje else if vbe / (NF * vt_t) > EMax then (Tauf * is_t) / (NF * vt_t) * ExMax * (vbe / (NF * vt_t) - EMax + 1) + Capcje else (Tauf * is_t) / (NF * vt_t) * exp(vbe / (NF * vt_t)) + Capcje;
//           C.i = (ibe - ibc) * qbk - ibc / br_t - cbc * der(vbc) + Ccs * der(C.v);
//           B.i = ibe / bf_t + ibc / br_t + cbc * der(vbc) + cbe * der(vbe);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//           heatPort.Q_flow =  -(vbc * ibc) / br_t + (vbe * ibe) / bf_t + (ibe - ibc) * qbk * (C.v - E.v);
//         end HeatingNPN;
//         model HeatingPNP "Simple PNP BJT according to Ebers-Moll with heating port"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter Modelica.SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter Modelica.SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter Modelica.SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter Modelica.SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter Modelica.SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter Modelica.SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter Modelica.SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter Modelica.SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter Modelica.SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter Modelica.SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter Modelica.SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent for effect on Is";
//           parameter Real XTB = 0 "Forward and reverse beta temperature exponent";
//           parameter Real EG = 1.11 "Energy gap for temperature effect on Is";
//           parameter Real NF = 1.0 "Forward current emission coefficient";
//           parameter Real NR = 1.0 "Reverse current emission coefficient";
//           parameter Real K = 1.3806226e-23 "Boltzmann's constant";
//           parameter Real q = 1.6021918e-19 "Elementary electronic charge";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -90,0}}, color = {0,0,255}),Line(visible = true, points = {{91,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{91, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}),Line(visible = true, points = {{0, -91},{0, -30}}, color = {191,0,0})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -10,40},{ -10, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -10,0},{ -99,0}}, color = {0,0,255}),Line(visible = true, points = {{96,50},{30,50}}, color = {0,0,255}),Line(visible = true, points = {{30,50},{ -10,10}}, color = {0,0,255}),Line(visible = true, points = {{ -10, -10},{30, -50}}, color = {0,0,255}),Line(visible = true, points = {{30, -50},{96, -50}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}),Line(visible = true, points = {{0, -91},{0, -30}}, color = {191,0,0})}));
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(Placement(visible = true, transformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 90)));
//         protected 
//           Real vcb;
//           Real veb;
//           Real qbk;
//           Real icb;
//           Real ieb;
//           Real ccb;
//           Real ceb;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           Real is_t;
//           Real br_t;
//           Real bf_t;
//           Real vt_t;
//           Real hexp;
//           Real htempexp;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar pnp junction transistor according
// to Ebers-Moll.
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// A typical parameter set is  (the parameter Vt is no longer used):
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 20, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -100,80},{100,100}}, textString = "%name"),Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -90,0}}),Line(color = {0,0,255}, points = {{91,50},{30,50}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{91, -50}}),Polygon(lineColor = {0,0,255}, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid),Line(points = {{0, -91},{0, -30}}, color = {191,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(color = {0,0,255}, points = {{ -10,40},{ -10, -40}}),Line(color = {0,0,255}, points = {{ -10,0},{ -99,0}}),Line(color = {0,0,255}, points = {{96,50},{30,50}}),Line(color = {0,0,255}, points = {{30,50},{ -10,10}}),Line(color = {0,0,255}, points = {{ -10, -10},{30, -50}}),Line(color = {0,0,255}, points = {{30, -50},{96, -50}}),Polygon(lineColor = {0,0,255}, points = {{ -10, -10},{5, -17},{ -3, -25},{ -10, -10}}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid),Line(points = {{0, -91},{0, -30}}, color = {191,0,0})}));
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vcb = C.v - B.v;
//           veb = E.v - B.v;
//           qbk = 1 - vcb * Vak;
//           hexp = ((heatPort.T / Tnom - 1) * EG) / vt_t;
//           htempexp = if hexp < EMin then ExMin * (hexp - EMin + 1) else if hexp > EMax then ExMax * (hexp - EMax + 1) else exp(hexp);
//           is_t = Is * pow(heatPort.T / Tnom, XTI) * htempexp;
//           br_t = Br * pow(heatPort.T / Tnom, XTB);
//           bf_t = Bf * pow(heatPort.T / Tnom, XTB);
//           vt_t = K / q * heatPort.T;
//           icb = if vcb / (NR * vt_t) < EMin then is_t * (ExMin * (vcb / (NR * vt_t) - EMin + 1) - 1) + vcb * Gbc else if vcb / (NR * vt_t) > EMax then is_t * (ExMax * (vcb / (NR * vt_t) - EMax + 1) - 1) + vcb * Gbc else is_t * (exp(vcb / (NR * vt_t)) - 1) + vcb * Gbc;
//           ieb = if veb / (NF * vt_t) < EMin then is_t * (ExMin * (veb / (NF * vt_t) - EMin + 1) - 1) + veb * Gbe else if veb / (NF * vt_t) > EMax then is_t * (ExMax * (veb / (NF * vt_t) - EMax + 1) - 1) + veb * Gbe else is_t * (exp(veb / (NF * vt_t)) - 1) + veb * Gbe;
//           Capcjc = if vcb / Phic > 0 then Cjc * (1 + (Mc * vcb) / Phic) else Cjc * pow(1 - vcb / Phic,  -Mc);
//           Capcje = if veb / Phie > 0 then Cje * (1 + (Me * veb) / Phie) else Cje * pow(1 - veb / Phie,  -Me);
//           ccb = if vcb / (NR * vt_t) < EMin then (Taur * is_t) / (NR * vt_t) * ExMin * (vcb / (NR * vt_t) - EMin + 1) + Capcjc else if vcb / (NR * vt_t) > EMax then (Taur * is_t) / (NR * vt_t) * ExMax * (vcb / (NR * vt_t) - EMax + 1) + Capcjc else (Taur * is_t) / (NR * vt_t) * exp(vcb / (NR * vt_t)) + Capcjc;
//           ceb = if veb / (NF * vt_t) < EMin then (Tauf * is_t) / (NF * vt_t) * ExMin * (veb / (NF * vt_t) - EMin + 1) + Capcje else if veb / (NF * vt_t) > EMax then (Tauf * is_t) / (NF * vt_t) * ExMax * (veb / (NF * vt_t) - EMax + 1) + Capcje else (Tauf * is_t) / (NF * vt_t) * exp(veb / (NF * vt_t)) + Capcje;
//           C.i = icb / br_t + ccb * der(vcb) + Ccs * der(C.v) + (icb - ieb) * qbk;
//           B.i =  -ieb / bf_t - icb / br_t - ceb * der(veb) - ccb * der(vcb);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//           heatPort.Q_flow =  -(vcb * icb) / br_t + (veb * ieb) / bf_t + (icb - ieb) * qbk * (E.v - C.v);
//         end HeatingPNP;
//       protected 
//         function pow "Just a helper function for x^y in order that a symbolic engine can apply some transformations more easily"
//           input Real x;
//           input Real y;
//           output Real z;
//         algorithm 
//           z:=x ^ y;
//         end pow;
//         function exlin "Exponential function linearly continued for x > Maxexp"
//           input Real x;
//           input Real Maxexp;
//           output Real z;
//         algorithm 
//           z:=if x > Maxexp then exp(Maxexp) * (1 + x - Maxexp) else exp(x);
//         end exlin;
//       end Semiconductors;
//       package Sensors "Potential, voltage, current, and power sensors"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains potential, voltage, and current sensors.
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model PotentialSensor "Sensor to measure the potential"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{100,0},{70,0}}, color = {0,0,255})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "V", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{100,0},{70,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p "pin to be measured" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput phi(redeclare type SignalType = SI.ElectricPotential) "Absolute voltage potential as output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           p.i = 0;
//           phi = p.v;
//         end PotentialSensor;
//         model VoltageSensor "Sensor to measure the voltage between two pins"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{96,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "V", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePin p "positive pin" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n "negative pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput v(redeclare type SignalType = SI.Voltage) "Voltage between pin p and n (= p.v - n.v) as output signal" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           p.i = 0;
//           n.i = 0;
//           v = p.v - n.v;
//         end VoltageSensor;
//         model CurrentSensor "Sensor to measure the current in a branch"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{96,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "A", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -90},{0, -70}}, color = {0,0,255})}));
//           Interfaces.PositivePin p "positive pin" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n "negative pin" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput i(redeclare type SignalType = SI.Current) "current in the branch from p to n as output signal" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           p.v = n.v;
//           p.i = i;
//           n.i =  -i;
//         end CurrentSensor;
//         model PowerSensor "Sensor to measure the power"
//           annotation(uses(Modelica(version = "2.2")), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html><p>
// This power sensor measures instantaneous electrical power of a singlephase system and has a separated voltage and current path. The pins of the voltage path are <code>pv</code> and <code>nv</code>, the pins of the current path are <code>pc</code> and <code>nc</code>. The internal resistance of the current path is zero, the internal resistance of the voltage path is infinite.
// </p>
// </html>", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> January 12, 2006   </i>
//        by Anton Haumer<br> implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem()), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,100},{0,70}}, color = {0,0,255}),Line(visible = true, points = {{0, -70},{0, -100}}, color = {0,0,255}),Line(visible = true, points = {{ -80, -100},{ -80,0}}, color = {0,0,255}),Line(visible = true, points = {{ -100,0},{100,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,119.7},{150,159.7}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "P", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Interfaces.PositivePin pc "Positive pin, current path" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin nc "Negative pin, current path" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin pv "Positive pin, voltage path" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {0,100}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin nv "Negative pin, voltage path" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Math.Product product annotation(Placement(visible = true, transformation(origin = { -30, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -450)));
//           Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor annotation(Placement(visible = true, transformation(origin = {0, -30}, extent = {{10,10},{ -10, -10}}, rotation =  -270)));
//           Modelica.Blocks.Interfaces.RealOutput power(redeclare type SignalType = Modelica.SIunits.Power) annotation(Placement(visible = true, transformation(origin = { -80, -110}, extent = {{10, -10},{ -10,10}}, rotation =  -450), iconTransformation(origin = { -80, -110}, extent = {{10, -10},{ -10,10}}, rotation =  -450)));
// 
//         equation 
//           connect(currentSensor.n,nc) annotation(Line(visible = true, points = {{ -30,0},{100,0}}, color = {0,0,255}));
//           connect(pc,currentSensor.p) annotation(Line(visible = true, points = {{ -100,0},{ -50,0}}, color = {0,0,255}));
//           connect(currentSensor.i,product.u2) annotation(Line(visible = true, points = {{ -40, -10},{ -40, -30},{ -36, -30},{ -36, -38}}, color = {0,0,191}));
//           connect(pv,voltageSensor.p) annotation(Line(visible = true, points = {{0,100},{0, -20},{0, -20}}, color = {0,0,255}));
//           connect(voltageSensor.n,nv) annotation(Line(visible = true, points = {{0, -40},{ -6.123e-16, -63},{0, -63},{0, -100}}, color = {0,0,255}));
//           connect(voltageSensor.v,product.u1) annotation(Line(visible = true, points = {{ -10, -30},{ -24, -30},{ -24, -38}}, color = {0,0,191}));
//           connect(product.y,power) annotation(Line(visible = true, points = {{ -30, -61},{ -30, -80},{ -80, -80},{ -80, -110}}, color = {0,0,191}));
//         end PowerSensor;
//       end Sensors;
//       package Sources "Time-dependend and controlled voltage and current sources"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains time-dependend and controlled voltage and current sources.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model SignalVoltage "Generic voltage source using the input signal as source voltage"
//           SI.Current i "Current flowing from pin p to pin n";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -96,0},{ -50,0}}),Line(visible = true, points = {{50,0},{96,0}}),Line(visible = true, points = {{ -50,0},{50,0}}),Line(visible = true, points = {{ -109,20},{ -84,20}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -94,23},{ -84,20},{ -94,17},{ -94,23}}),Line(visible = true, points = {{91,20},{116,20}}, color = {160,160,160}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -109,25},{ -89,45}}, textString = "i", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{106,23},{116,20},{106,17},{106,23}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{91,25},{111,45}}, textString = "i", fontName = "Arial"),Line(visible = true, points = {{ -119, -5},{ -119,5}}, color = {160,160,160}),Line(visible = true, points = {{ -124,0},{ -114,0}}, color = {160,160,160}),Line(visible = true, points = {{116,0},{126,0}}, color = {160,160,160})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Martin Otter<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -90,0},{ -50,0}}),Line(visible = true, points = {{50,0},{90,0}}),Line(visible = true, points = {{ -50,0},{50,0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -120},{100, -80}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -120,0},{ -20,50}}, textString = "+", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{20,0},{120,50}}, textString = "-", fontName = "Arial")}));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput v(redeclare type SignalType = SI.Voltage) "Voltage between pin p and n (= p.v - n.v) as input signal" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//         end SignalVoltage;
//         model ConstantVoltage "Source for constant voltage"
//           parameter SI.Voltage V = 1 "Value of constant voltage";
//           extends Interfaces.OnePort;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -10,0}}),Line(visible = true, points = {{ -10,60},{ -10, -60}}),Line(visible = true, points = {{0,30},{0, -30}}),Line(visible = true, points = {{0,0},{90,0}})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -10,0}}),Line(visible = true, points = {{ -10,60},{ -10, -60}}),Line(visible = true, points = {{0,30},{0, -30}}),Line(visible = true, points = {{0,0},{90,0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -120},{100, -80}}, textString = "%name=%V", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -120,0},{ -20,50}}, textString = "+", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{20,0},{120,50}}, textString = "-", fontName = "Arial")}));
// 
//         equation 
//           v = V;
//         end ConstantVoltage;
//         model StepVoltage "Step voltage source"
//           parameter SI.Voltage V = 1 "Height of step";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Step signalSource(height = V));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70, -70},{0, -70},{0,70},{69,70}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -18},{0, -18},{0,50},{80,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -21, -90},{25, -72}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{0, -17},{0, -71}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -68, -54},{ -22, -36}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -13,50},{ -13, -17}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, pattern = LinePattern.Dash, points = {{2,50},{ -19,50},{2,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -17},{ -16, -4},{ -10, -4},{ -13, -17},{ -13, -17}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13,50},{ -16,37},{ -9,37},{ -13,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -68,8},{ -22,26}}, textString = "V", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -69},{ -16, -56},{ -10, -56},{ -13, -69},{ -13, -69}}),Line(visible = true, points = {{ -13, -18},{ -13, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -18},{ -16, -31},{ -9, -31},{ -13, -18}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -67,67},{ -2,93}}, textString = "v = p.v - n.v", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end StepVoltage;
//         model RampVoltage "Ramp voltage source"
//           parameter SI.Voltage V = 1 "Height of ramp";
//           parameter SI.Time duration(min = Modelica.Constants.small) = 2 "Duration of ramp";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Ramp signalSource(final height = V, final duration = duration));
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -20},{ -20, -20},{50,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -20},{ -42, -30},{ -37, -30},{ -40, -20}}),Line(visible = true, points = {{ -40, -20},{ -40, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -80, -49},{ -41, -33}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -40, -88},{6, -70}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -67,67},{ -2,93}}, textString = "v = p.v - n.v", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -19, -20},{50, -20}}, color = {192,192,192}),Line(visible = true, points = {{50,50},{101,50}}, thickness = 0.5),Line(visible = true, points = {{50,50},{50, -20}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{42, -18},{42, -22},{50, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -20, -20},{ -11, -18},{ -11, -22},{ -20, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50,50},{48,40},{53,40},{50,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{47, -10},{52, -10},{50, -20},{50, -20}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{53,7},{82,25}}, textString = "V", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{0, -37},{35, -17}}, textString = "duration", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -60},{ -50, -60},{50,60},{80,60}}, color = {192,192,192})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end RampVoltage;
//         model SineVoltage "Sine voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Frequency freqHz = 1 "Frequency of sine wave";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Sine signalSource(amplitude = V, freqHz = freqHz, phase = phase));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -40,0},{ -31.6,34.2},{ -26.1,53.1},{ -21.3,66.4},{ -17.1,74.6},{ -12.9,79.1},{ -8.64,79.8},{ -4.42,76.6},{ -0.2,69.7},{4.02,59.4},{8.84,44.1},{14.9,21.2},{27.5, -30.8},{33, -50.2},{37.8, -64.2},{42, -73.1},{46.2, -78.4},{50.5, -80},{54.7, -77.6},{58.9, -71.5},{63.1, -61.9},{67.9, -47.2},{74, -24.8},{80,0}}, thickness = 0.5, smooth = Smooth.Bezier),Line(visible = true, points = {{ -40.5, -2.22e-16},{ -79.5, -2.22e-16}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -106, -29},{ -60, -11}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -41, -2},{ -41, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -60, -61},{ -14, -43}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -9,79},{43,79}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -42, -1},{50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,80},{30,67},{37,67},{33,80}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{37,39},{83,57}}, textString = "V", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,1},{30,14},{36,14},{33,1},{33,1}}),Line(visible = true, points = {{33,79},{33,0}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -70,82.5},{ -5,108.5}}, textString = "v = p.v - n.v", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -66,0},{ -56.2,29.9},{ -49.8,46.5},{ -44.2,58.1},{ -39.3,65.2},{ -34.3,69.2},{ -29.4,69.8},{ -24.5,67},{ -19.6,61},{ -14.6,52},{ -9,38.6},{ -1.98,18.6},{12.79, -26.9},{19.1, -44},{24.8, -56.2},{29.7, -64},{34.6, -68.6},{39.5, -70},{44.5, -67.9},{49.4, -62.5},{54.3, -54.1},{59.9, -41.3},{67, -21.7},{74,0}}, color = {192,192,192}, smooth = Smooth.Bezier)}));
//         end SineVoltage;
//         model ExpSineVoltage "Exponentially damped sine voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of sine wave";
//           parameter SI.Frequency freqHz = 2 "Frequency of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Damping damping = 1 "Damping coefficient of sine wave";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.ExpSine signalSource(amplitude = V, freqHz = freqHz, phase = phase, damping = damping));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -50,0},{ -46.1,28.2},{ -43.5,44},{ -40.9,56.4},{ -38.2,64.9},{ -35.6,69.4},{ -33,69.6},{ -30.4,65.9},{ -27.8,58.7},{ -24.5,45.7},{ -19.9,22.5},{ -13.4, -12.2},{ -9.5, -29.5},{ -6.23, -40.1},{ -2.96, -46.5},{0.3, -48.4},{3.57, -45.9},{6.83, -39.6},{10.8, -28.1},{21.9,12},{25.8,23.1},{29.7,30.5},{33,33.3},{36.9,32.5},{40.8,27.8},{46,16.9},{56.5, -9.2},{61.7, -18.6},{66.3, -22.7},{70.9, -22.6},{76.1, -18},{80, -12.1}}, thickness = 0.5, smooth = Smooth.Bezier),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -19},{ -55,1}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -72, -54},{ -26, -36}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{18,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50,0},{ -81,0}}, thickness = 0.5),Line(visible = true, points = {{ -50,77},{ -50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18, -1},{18,76}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18,73},{ -50,73}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -42,74},{9,88}}, textString = "1/freqHz", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -49,73},{ -40,75},{ -40,71},{ -49,73}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{18,73},{10,75},{10,71},{18,73}}),Line(visible = true, points = {{ -50, -61},{ -19, -61}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -18, -61},{ -26, -59},{ -26, -63},{ -18, -61}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -51, -75},{ -27, -63}}, textString = "t", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -82, -96},{108, -67}}, textString = "V*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{ -50, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50, -54},{ -50, -72}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18, -76},{ -1, -48}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77,92},{ -38,105}}, textString = "v = p.v - n.v", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -64, -14},{ -59.2,18.3},{ -56,36.3},{ -52.7,50.5},{ -49.5,60.2},{ -46.3,65.3},{ -43.1,65.6},{ -39.9,61.3},{ -36.7,53.1},{ -32.6,38.2},{ -27,11.8},{ -19, -27.9},{ -14.2, -47.7},{ -10.1, -59.9},{ -6.1, -67.2},{ -2.1, -69.3},{1.9, -66.5},{5.9, -59.3},{10.77, -46.1},{24.44, -0.3},{29.3,12.4},{34.1,20.8},{38.1,24},{42.9,23.2},{47.8,17.8},{54.2,5.4},{67.1, -24.5},{73.5, -35.2},{79.1, -39.9},{84.7, -39.9},{91.2, -34.5},{96, -27.8}}, color = {192,192,192}, smooth = Smooth.Bezier)}));
//         end ExpSineVoltage;
//         model ExponentialsVoltage " Rising and falling exponential voltage source"
//           parameter Real vMax = 1 "Upper bound for rising edge";
//           parameter SI.Time riseTime(min = 0) = 0.5 "Rise time";
//           parameter SI.Time riseTimeConst(min = Modelica.Constants.small) = 0.1 "Rise time constant";
//           parameter SI.Time fallTimeConst(min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Exponentials signalSource(outMax = vMax, riseTime = riseTime, riseTimeConst = riseTimeConst, fallTimeConst = fallTimeConst));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -70},{84, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -70},{84, -64},{84, -76},{100, -70}}),Line(visible = true, points = {{ -40, -30},{ -37.2, -15.3},{ -34.3, -2.1},{ -30.8,12.4},{ -27.3,25},{ -23.7,35.92},{ -19.5,47.18},{ -15.3,56.7},{ -10.3,66},{ -4.6,74.5},{1.7,82.1},{8.8,88.6},{17.3,94.3},{27.9,99.2},{30,100},{32.12,87.5},{34.95,72.7},{37.78,59.8},{40.61,48.45},{44.14,36.3},{47.68,26},{51.9,15.8},{56.2,7.4},{61.1, -0.5},{66.8, -7.4},{73.1, -13.3},{80.9, -18.5},{90.8, -22.8},{100, -25.4}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -70,71},{ -29,91}}, textString = "outPort", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -56},{ -46, -43}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Line(visible = true, points = {{ -40, -29},{ -40, -60}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -30},{ -42, -40},{ -37, -40},{ -40, -30}}),Line(visible = true, points = {{ -39, -30},{ -80, -30}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -59, -89},{ -13, -71}}, textString = "startTime", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -41, -30},{ -32, -28},{ -32, -32},{ -41, -30}}),Line(visible = true, points = {{ -40, -30},{29, -30}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{29, -30},{21, -28},{21, -32},{29, -30}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -26, -28},{19, -12}}, textString = "riseTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{78, -96},{102, -76}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -100, -70},{84, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -70},{84, -64},{84, -76},{100, -70}}),Line(visible = true, points = {{ -40, -30},{ -37.2, -15.3},{ -34.3, -2.1},{ -30.8,12.4},{ -27.3,25},{ -23.7,35.92},{ -19.5,47.18},{ -15.3,56.7},{ -10.3,66},{ -4.6,74.5},{1.7,82.1},{8.8,88.6},{17.3,94.3},{30,100},{30,100},{32.12,87.5},{34.95,72.7},{37.78,59.8},{40.61,48.45},{44.14,36.3},{47.68,26},{51.9,15.8},{56.2,7.4},{61.1, -0.5},{66.8, -7.4},{73.1, -13.3},{80.9, -18.5},{90.8, -22.8},{100, -25.4}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -70,71},{ -29,91}}, textString = "outPort", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -56},{ -46, -43}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Line(visible = true, points = {{ -40, -29},{ -40, -60}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -30},{ -42, -40},{ -37, -40},{ -40, -30}}),Line(visible = true, points = {{ -39, -30},{ -80, -30}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -59, -89},{ -13, -71}}, textString = "startTime", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -41, -30},{ -32, -28},{ -32, -32},{ -41, -30}}),Line(visible = true, points = {{ -40, -30},{29, -30}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{29, -30},{21, -28},{21, -32},{29, -30}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -26, -28},{19, -12}}, textString = "riseTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{78, -96},{102, -76}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{30,100},{30, -34}}, color = {192,192,192}, pattern = LinePattern.Dot)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -76, -59},{ -73.2, -44.3},{ -70.3, -31.1},{ -66.8, -16.6},{ -63.3, -4},{ -59.7,6.92},{ -55.5,18.18},{ -51.3,27.7},{ -46.3,37},{ -40.6,45.5},{ -34.3,53.1},{ -27.2,59.6},{ -18.7,65.3},{ -6,71},{ -6,71},{ -3.88,58.5},{ -1.05,43.7},{1.78,30.8},{4.61,19.45},{8.14,7.3},{11.68, -3},{15.9, -13.2},{20.2, -21.6},{25.1, -29.5},{30.8, -36.4},{37.1, -42.3},{44.9, -47.5},{54.8, -51.8},{64, -54.4}}, color = {192,192,192}, smooth = Smooth.Bezier)}));
//         end ExponentialsVoltage;
//         model PulseVoltage "Pulse voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of pulse";
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of period";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Pulse signalSource(amplitude = V, width = width, period = period));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70, -70},{ -40, -70},{ -40,70},{0,70},{0, -70},{40, -70},{40,70},{80,70}}, color = {192,192,192})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37, -12},{ -30, -12},{ -34,1}}),Line(visible = true, points = {{ -34, -1},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -33, -70},{ -36, -57},{ -30, -57},{ -33, -70},{ -33, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10,0},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -80,0},{ -21,0},{ -21,50},{21,50},{21,0},{41,0},{41,50},{79.72,50}}, thickness = 0.5),Line(visible = true, points = {{ -19,88},{ -19,49}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{21,74},{21,50}}, color = {160,160,160}, pattern = LinePattern.Dot),Line(visible = true, points = {{41,88},{41,50}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -19,83},{42,83}}, color = {192,192,192}),Line(visible = true, points = {{ -19,69},{21,69}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -9,85},{37,97}}, textString = "period", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -18,69},{21,81}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -52,50},{ -19,50}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -34,50},{ -34,1}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "V", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,49},{ -37,36},{ -30,36},{ -34,49}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37,14},{ -31,14},{ -34,1},{ -34,1}}),Line(visible = true, points = {{79.94,50.17},{79.94,8.882e-16},{90,8.882e-16}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -19,69},{ -10,71},{ -10,67},{ -19,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{21,69},{13,71},{13,67},{21,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -19,83},{ -10,85},{ -10,81},{ -19,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{41,83},{33,85},{33,81},{41,83}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78,89},{ -24,103}}, textString = "v = p.v - n.v", fontName = "Arial")}));
//         end PulseVoltage;
//         model SawToothVoltage "Saw tooth voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of saw tooth";
//           parameter SI.Time period = 1 "Time for one period";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.SawTooth signalSource(amplitude = V, period = period));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -85, -70},{ -65, -70},{ -5,71},{ -5, -70},{55,71},{55, -70}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -19},{ -37, -32},{ -30, -32},{ -34, -19}}),Line(visible = true, points = {{ -34, -20},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -70},{ -37, -57},{ -31, -57},{ -34, -70},{ -34, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10, -20},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,88},{ -10, -20}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{30,88},{30,59}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,83},{30,83}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -12,85},{34,97}}, textString = "period", fontName = "Arial"),Line(visible = true, points = {{ -44,60},{30,60}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -34,47},{ -34, -7}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "V", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,60},{ -37,47},{ -30,47},{ -34,60}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -20},{ -37, -7},{ -31, -7},{ -34, -20},{ -34, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,83},{ -1,85},{ -1,81},{ -10,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{30,83},{22,85},{22,81},{30,83}}),Line(visible = true, points = {{ -80, -20},{ -10, -20},{30,60},{30, -20},{72,60},{72, -20}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77,88},{ -27,100}}, textString = "v = p.v - n.v", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end SawToothVoltage;
//         model TrapezoidVoltage "Trapezoidal voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of trapezoid";
//           parameter SI.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//           parameter SI.Time width(final min = 0) = 0.5 "Width duration of trapezoid";
//           parameter SI.Time falling(final min = 0) = 0 "Falling duration of trapezoid";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Trapezoid signalSource(amplitude = V, rising = rising, width = width, falling = falling, period = period, nperiod = nperiod));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -81, -70},{ -60, -70},{ -30,70},{1,70},{30, -70},{51, -70},{80,70}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -30},{ -47, -41},{ -43, -41},{ -45, -30}}),Line(visible = true, points = {{ -45, -31},{ -45, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -70},{ -47, -60},{ -43, -60},{ -45, -70},{ -45, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -86, -55},{ -43, -43}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -47, -87},{ -1, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -30,81},{ -30, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,59},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{20,59},{20,39}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(visible = true, points = {{40,59},{40, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -29,56},{40,56}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -8,60},{21,70}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -42,40},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -39,40},{ -39, -19}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77,0},{ -40,14}}, textString = "V", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,56},{ -22,58},{ -22,54},{ -29,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,56},{ -17,58},{ -17,54},{ -10,56}}),Line(visible = true, points = {{ -80, -30},{ -30, -30},{ -9,46},{21,46},{40, -30},{60, -30},{80,46},{100,46}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39,40},{ -41,29},{ -37,29},{ -39,40}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39, -29},{ -41, -19},{ -37, -19},{ -39, -29},{ -39, -29}}),Line(visible = true, points = {{60,81},{60, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{39,56},{32,58},{32,54},{39,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{27,58},{27,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{13,58},{13,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -12,56},{ -5,58},{ -5,54},{ -12,56}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -34,60},{ -5,70}}, textString = "rising", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{16,60},{45,70}}, textString = "falling", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77,91},{ -23,103}}, textString = "v = p.v - n.v", fontName = "Arial"),Line(visible = true, points = {{ -20,76},{61,76}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,76},{ -20,78},{ -20,74},{ -29,76}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{61,76},{53,78},{53,74},{61,76}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -2,77},{25,86}}, textString = "period", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end TrapezoidVoltage;
//         model TableVoltage "Voltage source by linear interpolation in a table"
//           parameter Real table[:,:] = [0,0;1,1;2,4] "Table matrix (time = first column, voltage = second column)";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.TimeTable signalSource(table = table));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -58, -36},{ -58,84},{42,84},{42, -36},{ -58, -36},{ -58, -6},{42, -6},{42,24},{ -58,24},{ -58,54},{42,54},{42,84},{ -8,84},{ -8, -37}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -30},{30,90}}),Line(visible = true, points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{30,90},{30, -31}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77, -58},{ -38, -42}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}),Line(visible = true, points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -38, -88},{8, -70}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{66, -93},{91, -81}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -15,68},{24,83}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{33,67},{76,83}}, textString = "v", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -81,85},{ -31,98}}, textString = "v = p.v - n.v", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This block generates a voltage source by <b>linear interpolation</b> in
// a table. The time points and voltage values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the voltage to be interpolated.
// The table interpolation has the following proporties:
// </p>
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the voltage value is just returned independantly of the
//     actual time instant, i.e., this is a constant voltage source.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the voltage.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// <p>
// Example:
// </p>
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// If, e.g., time = 1.0, the voltage v =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the voltage v =  2.5,
//     e.g., time = 2.0, the voltage v =  4.0,
//     e.g., time = 5.0, the voltage v = 23.0 (i.e. extrapolation).
// </pre>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"));
//         end TableVoltage;
//         model SignalCurrent "Generic current source using the input signal as source current"
//           SI.Voltage v "Voltage drop between the two pins (= p.v - n.v)";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -96,0},{ -50,0}}),Line(visible = true, points = {{50,0},{96,0}}),Line(visible = true, points = {{0, -50},{0,50}})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Martin Otter<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -90,0},{ -50,0}}),Line(visible = true, points = {{50,0},{90,0}}),Line(visible = true, points = {{0, -50},{0,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -120},{100, -80}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -60, -70},{60, -70}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60, -70},{30, -60},{30, -80},{60, -70}})}));
//           Interfaces.PositivePin p annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePin n annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput i(redeclare type SignalType = SI.Current) "Current flowing from pin p to pin n as input signal" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//         end SignalCurrent;
//         model ConstantCurrent "Source for constant current"
//           parameter SI.Current I = 1 "Value of constant current";
//           extends Interfaces.OnePort;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -96,0},{ -50,0}}),Line(visible = true, points = {{50,0},{96,0}}),Line(visible = true, points = {{0, -50},{0,50}})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -90,0},{ -50,0}}),Line(visible = true, points = {{50,0},{90,0}}),Line(visible = true, points = {{0, -50},{0,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,80},{100,120}}, textString = "%name=%I", fontName = "Arial"),Line(visible = true, points = {{ -60, -80},{60, -80}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{60, -80},{30, -70},{30, -90},{60, -80}})}));
// 
//         equation 
//           i = I;
//         end ConstantCurrent;
//         model StepCurrent "Step current source"
//           parameter SI.Current I = 1 "Height of step";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Step signalSource(height = I));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -86, -70},{ -14, -70},{ -14,70},{57,70}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -18},{0, -18},{0,50},{80,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -21, -90},{25, -72}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{0, -17},{0, -71}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -68, -54},{ -22, -36}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -13,50},{ -13, -17}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, pattern = LinePattern.Dash, points = {{2,50},{ -19,50},{2,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -17},{ -16, -4},{ -10, -4},{ -13, -17},{ -13, -17}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13,50},{ -16,37},{ -9,37},{ -13,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -68,8},{ -22,26}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -69},{ -16, -56},{ -10, -56},{ -13, -69},{ -13, -69}}),Line(visible = true, points = {{ -13, -18},{ -13, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -13, -18},{ -16, -31},{ -9, -31},{ -13, -18}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end StepCurrent;
//         model RampCurrent "Ramp current source"
//           parameter SI.Current I = 1 "Height of ramp";
//           parameter SI.Time duration(min = Modelica.Constants.small) = 2 "Duration of ramp";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Ramp signalSource(final height = I, final duration = duration));
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -20},{ -20, -20},{50,50}}, thickness = 0.5),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -20},{ -42, -30},{ -37, -30},{ -40, -20}}),Line(visible = true, points = {{ -40, -20},{ -40, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -80, -49},{ -41, -33}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -40, -88},{6, -70}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -19, -20},{50, -20}}, color = {192,192,192}),Line(visible = true, points = {{50,50},{101,50}}, thickness = 0.5),Line(visible = true, points = {{50,50},{50, -20}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{42, -18},{42, -22},{50, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -20, -20},{ -11, -18},{ -11, -22},{ -20, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50,50},{48,40},{53,40},{50,50}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -20},{47, -10},{52, -10},{50, -20},{50, -20}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{53,7},{82,25}}, textString = "I", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{0, -37},{35, -17}}, textString = "duration", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -60},{ -50, -60},{50,60},{80,60}}, color = {192,192,192})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end RampCurrent;
//         model SineCurrent "Sine current source"
//           parameter SI.Current I = 1 "Amplitude of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Frequency freqHz = 1 "Frequency of sine wave";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Sine signalSource(amplitude = I, freqHz = freqHz, phase = phase));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -40,0},{ -31.6,34.2},{ -26.1,53.1},{ -21.3,66.4},{ -17.1,74.6},{ -12.9,79.1},{ -8.64,79.8},{ -4.42,76.6},{ -0.2,69.7},{4.02,59.4},{8.84,44.1},{14.9,21.2},{27.5, -30.8},{33, -50.2},{37.8, -64.2},{42, -73.1},{46.2, -78.4},{50.5, -80},{54.7, -77.6},{58.9, -71.5},{63.1, -61.9},{67.9, -47.2},{74, -24.8},{80,0}}, thickness = 0.5, smooth = Smooth.Bezier),Line(visible = true, points = {{ -40.5,0},{ -79.5,0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -106, -29},{ -60, -11}}, textString = "offset", fontName = "Arial"),Line(visible = true, points = {{ -41, -2},{ -41, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -60, -61},{ -14, -43}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -9,79},{43,79}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -42, -1},{50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,80},{30,67},{37,67},{33,80}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{37,39},{83,57}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{33,1},{30,14},{36,14},{33,1},{33,1}}),Line(visible = true, points = {{33,79},{33,0}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,82},{ -53,102}}, textString = "i", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -60.2,29.9},{ -53.8,46.5},{ -48.2,58.1},{ -43.3,65.2},{ -38.3,69.2},{ -33.4,69.8},{ -28.5,67},{ -23.6,61},{ -18.6,52},{ -13,38.6},{ -5.98,18.6},{8.79, -26.9},{15.1, -44},{20.8, -56.2},{25.7, -64},{30.6, -68.6},{35.5, -70},{40.5, -67.9},{45.4, -62.5},{50.3, -54.1},{55.9, -41.3},{63, -21.7},{70,0}}, color = {192,192,192}, smooth = Smooth.Bezier)}));
//         end SineCurrent;
//         model ExpSineCurrent "Exponentially damped sine current source"
//           parameter Real I = 1 "Amplitude of sine wave";
//           parameter SI.Frequency freqHz = 2 "Frequency of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Damping damping = 1 "Damping coefficient of sine wave";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.ExpSine signalSource(amplitude = I, freqHz = freqHz, phase = phase, damping = damping));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -14},{ -75.2,18.3},{ -72,36.3},{ -68.7,50.5},{ -65.5,60.2},{ -62.3,65.3},{ -59.1,65.6},{ -55.9,61.3},{ -52.7,53.1},{ -48.6,38.2},{ -43,11.8},{ -35, -27.9},{ -30.2, -47.7},{ -26.1, -59.9},{ -22.1, -67.2},{ -18.1, -69.3},{ -14.1, -66.5},{ -10.1, -59.3},{ -5.23, -46.1},{8.44, -0.3},{13.3,12.4},{18.1,20.8},{22.1,24},{26.9,23.2},{31.8,17.8},{38.2,5.4},{51.1, -24.5},{57.5, -35.2},{63.1, -39.9},{68.7, -39.9},{75.2, -34.5},{80, -27.8}}, color = {192,192,192}, smooth = Smooth.Bezier)}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}}),Line(visible = true, points = {{ -99, -40},{85, -40}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{101, -40},{85, -34},{85, -46},{101, -40}}),Line(visible = true, points = {{ -50,0},{ -46.1,28.2},{ -43.5,44},{ -40.9,56.4},{ -38.2,64.9},{ -35.6,69.4},{ -33,69.6},{ -30.4,65.9},{ -27.8,58.7},{ -24.5,45.7},{ -19.9,22.5},{ -13.4, -12.2},{ -9.5, -29.5},{ -6.23, -40.1},{ -2.96, -46.5},{0.3, -48.4},{3.57, -45.9},{6.83, -39.6},{10.8, -28.1},{21.9,12},{25.8,23.1},{29.7,30.5},{33,33.3},{36.9,32.5},{40.8,27.8},{46,16.9},{56.5, -9.2},{61.7, -18.6},{66.3, -22.7},{70.9, -22.6},{76.1, -18},{80, -12.1}}, thickness = 0.5, smooth = Smooth.Bezier),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -19},{ -55,1}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -72, -54},{ -26, -36}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{84, -72},{108, -52}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{18,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50,0},{ -81,0}}, thickness = 0.5),Line(visible = true, points = {{ -50,77},{ -50,0}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18, -1},{18,76}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18,73},{ -50,73}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -42,74},{9,88}}, textString = "1/freqHz", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -49,73},{ -40,75},{ -40,71},{ -49,73}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{18,73},{10,75},{10,71},{18,73}}),Line(visible = true, points = {{ -50, -61},{ -19, -61}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -18, -61},{ -26, -59},{ -26, -63},{ -18, -61}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -51, -75},{ -27, -63}}, textString = "t", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -82, -96},{108, -67}}, textString = "I*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", fontName = "Arial"),Line(visible = true, points = {{ -50,0},{ -50, -40}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -50, -54},{ -50, -72}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{18, -76},{ -1, -48}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -74,83},{ -54,103}}, textString = "i", fontName = "Arial")}));
//         end ExpSineCurrent;
//         model ExponentialsCurrent " Rising and falling exponential current source"
//           parameter Real iMax = 1 "Upper bound for rising edge";
//           parameter SI.Time riseTime(min = 0) = 0.5 "Rise time";
//           parameter SI.Time riseTimeConst(min = Modelica.Constants.small) = 0.1 "Rise time constant";
//           parameter SI.Time fallTimeConst(min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Exponentials signalSource(outMax = iMax, riseTime = riseTime, riseTimeConst = riseTimeConst, fallTimeConst = fallTimeConst));
//           annotation(Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -70},{84, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -70},{84, -64},{84, -76},{100, -70}}),Line(visible = true, points = {{ -40, -30},{ -37.2, -15.3},{ -34.3, -2.1},{ -30.8,12.4},{ -27.3,25},{ -23.7,35.92},{ -19.5,47.18},{ -15.3,56.7},{ -10.3,66},{ -4.6,74.5},{1.7,82.1},{8.8,88.6},{17.3,94.3},{30,100},{30,100},{32.12,87.5},{34.95,72.7},{37.78,59.8},{40.61,48.45},{44.14,36.3},{47.68,26},{51.9,15.8},{56.2,7.4},{61.1, -0.5},{66.8, -7.4},{73.1, -13.3},{80.9, -18.5},{90.8, -22.8},{100, -25.4}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -70},{ -43, -60},{ -38, -60},{ -40, -70},{ -40, -70}}),Line(visible = true, points = {{ -40, -29},{ -40, -60}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -40, -30},{ -42, -40},{ -37, -40},{ -40, -30}}),Line(visible = true, points = {{ -39, -30},{ -80, -30}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -59, -89},{ -13, -71}}, textString = "startTime", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -41, -30},{ -32, -28},{ -32, -32},{ -41, -30}}),Line(visible = true, points = {{ -40, -30},{29, -30}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{29, -30},{21, -28},{21, -32},{29, -30}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -26, -28},{19, -12}}, textString = "riseTime", fontName = "Arial"),Line(visible = true, points = {{ -39, -30},{ -80, -30}}, thickness = 0.5),Line(visible = true, points = {{30,100},{30, -34}}, color = {192,192,192}, pattern = LinePattern.Dot),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -76, -59},{ -73.2, -44.3},{ -70.3, -31.1},{ -66.8, -16.6},{ -63.3, -4},{ -59.7,6.92},{ -55.5,18.18},{ -51.3,27.7},{ -46.3,37},{ -40.6,45.5},{ -34.3,53.1},{ -27.2,59.6},{ -18.7,65.3},{ -6,71},{ -6,71},{ -3.88,58.5},{ -1.05,43.7},{1.78,30.8},{4.61,19.45},{8.14,7.3},{11.68, -3},{15.9, -13.2},{20.2, -21.6},{25.1, -29.5},{30.8, -36.4},{37.1, -42.3},{44.9, -47.5},{54.8, -51.8},{64, -54.4}}, color = {192,192,192}, smooth = Smooth.Bezier)}));
//         end ExponentialsCurrent;
//         model PulseCurrent "Pulse current source"
//           parameter SI.Current I = 1 "Amplitude of pulse";
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of period";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Pulse signalSource(amplitude = I, width = width, period = period));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70, -67},{ -40, -67},{ -40,73},{0,73},{0, -67},{40, -67},{40,73},{80,73}}, color = {192,192,192})}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37, -12},{ -30, -12},{ -34,1}}),Line(visible = true, points = {{ -34, -1},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -33, -70},{ -36, -57},{ -30, -57},{ -33, -70},{ -33, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10,0},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -80.03, -1.776e-15},{ -21.03, -1.776e-15},{ -21.03,50},{20.97,50},{20.97, -1.776e-15},{39.97,0},{39.97,50},{80.03,50}}, thickness = 0.5),Line(visible = true, points = {{ -19,88},{ -19,49}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{21,74},{21,50}}, color = {160,160,160}, pattern = LinePattern.Dot),Line(visible = true, points = {{41,88},{41,50}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -19,83},{42,83}}, color = {192,192,192}),Line(visible = true, points = {{ -19,69},{21,69}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -9,85},{37,97}}, textString = "period", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -18,69},{21,81}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -52,50},{ -19,50}}, color = {192,192,192}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -34,50},{ -34,1}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,49},{ -37,36},{ -30,36},{ -34,49}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,1},{ -37,14},{ -31,14},{ -34,1},{ -34,1}}),Line(visible = true, points = {{80,50.17},{80,0},{90,0}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -19,69},{ -10,71},{ -10,67},{ -19,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{21,69},{13,71},{13,67},{21,69}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -19,83},{ -10,85},{ -10,81},{ -19,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{41,83},{33,85},{33,81},{41,83}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}));
//         end PulseCurrent;
//         model SawToothCurrent "Saw tooth current source"
//           parameter SI.Current I = 1 "Amplitude of saw tooth";
//           parameter SI.Time period = 1 "Time for one period";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.SawTooth signalSource(amplitude = I, period = period));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70, -71},{ -50, -71},{10,70},{10, -71},{70,70},{70, -71}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -19},{ -37, -32},{ -30, -32},{ -34, -19}}),Line(visible = true, points = {{ -34, -20},{ -34, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -70},{ -37, -57},{ -31, -57},{ -34, -70},{ -34, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78, -36},{ -35, -24}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -31, -87},{15, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -10, -20},{ -10, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,88},{ -10, -20}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{30,88},{30,59}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,83},{30,83}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -12,85},{34,97}}, textString = "period", fontName = "Arial"),Line(visible = true, points = {{ -44,60},{30,60}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -34,47},{ -34, -7}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -78,20},{ -37,34}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34,60},{ -37,47},{ -30,47},{ -34,60}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -34, -20},{ -37, -7},{ -31, -7},{ -34, -20},{ -34, -20}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,83},{ -1,85},{ -1,81},{ -10,83}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{30,83},{22,85},{22,81},{30,83}}),Line(visible = true, points = {{ -80, -20},{ -10, -20},{30,60},{30, -20},{72,60},{72, -20}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end SawToothCurrent;
//         model TrapezoidCurrent "Trapezoidal current source"
//           parameter SI.Current I = 1 "Amplitude of trapezoid";
//           parameter SI.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//           parameter SI.Time width(final min = 0) = 0.5 "Width duration of trapezoid";
//           parameter SI.Time falling(final min = 0) = 0 "Falling duration of trapezoid";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Trapezoid signalSource(amplitude = I, rising = rising, width = width, falling = falling, period = period, nperiod = nperiod));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -81, -66},{ -60, -66},{ -30,74},{1,74},{30, -66},{51, -66},{80,74}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -30},{ -47, -41},{ -43, -41},{ -45, -30}}),Line(visible = true, points = {{ -45, -31},{ -45, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -45, -70},{ -47, -60},{ -43, -60},{ -45, -70},{ -45, -70}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -86, -55},{ -43, -43}}, textString = "offset", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -47, -87},{ -1, -69}}, textString = "startTime", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{70, -100},{94, -80}}, textString = "time", fontName = "Arial"),Line(visible = true, points = {{ -29,79},{ -30, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -10,59},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{20,59},{20,39}}, color = {160,160,160}, pattern = LinePattern.Dash),Line(visible = true, points = {{40,59},{40, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -20,75},{60,75}}, color = {192,192,192}),Line(visible = true, points = {{ -29,56},{40,56}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -9,76},{37,88}}, textString = "period", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -8,60},{21,70}}, textString = "width", fontName = "Arial"),Line(visible = true, points = {{ -42,40},{ -10,40}}, color = {192,192,192}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -39,40},{ -39, -19}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77,0},{ -40,14}}, textString = "I", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,56},{ -22,58},{ -22,54},{ -29,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -10,56},{ -17,58},{ -17,54},{ -10,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -29,75},{ -20,77},{ -20,73},{ -29,75}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{60,75},{52,77},{52,73},{60,75}}),Line(visible = true, points = {{ -80, -30},{ -30, -30},{ -9,46},{21,46},{40, -30},{60, -30},{80,46},{100,46}}, thickness = 0.5),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39,40},{ -41,29},{ -37,29},{ -39,40}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -39, -29},{ -41, -19},{ -37, -19},{ -39, -29},{ -39, -29}}),Line(visible = true, points = {{60,80},{60, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{39,56},{32,58},{32,54},{39,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{27,58},{27,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{20,56},{13,58},{13,54},{20,56}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -12,56},{ -5,58},{ -5,54},{ -12,56}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -34,60},{ -5,70}}, textString = "rising", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{16,60},{45,70}}, textString = "falling", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Documentation(revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         end TrapezoidCurrent;
//         model TableCurrent "Current source by linear interpolation in a table"
//           parameter Real table[:,:] = [0,0;1,1;2,4] "Table matrix (time = first column, current = second column)";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.TimeTable signalSource(table = table));
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -66, -36},{ -66,84},{34,84},{34, -36},{ -66, -36},{ -66, -6},{34, -6},{34,24},{ -66,24},{ -66,54},{34,54},{34,84},{ -16,84},{ -16, -37}}, color = {192,192,192})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -30},{30,90}}),Line(visible = true, points = {{ -20, -30},{ -20,90},{80,90},{80, -30},{ -20, -30},{ -20,0},{80,0},{80,30},{ -20,30},{ -20,60},{80,60},{80,90},{30,90},{30, -31}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -77, -58},{ -38, -42}}, textString = "offset", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -31, -30},{ -33, -40},{ -28, -40},{ -31, -30}}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -30, -70},{ -33, -60},{ -28, -60},{ -30, -70},{ -30, -70}}),Line(visible = true, points = {{ -31, -31},{ -31, -70}}, color = {192,192,192}),Line(visible = true, points = {{ -20, -20},{ -20, -70}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{ -38, -88},{8, -70}}, textString = "startTime", fontName = "Arial"),Line(visible = true, points = {{ -20, -30},{ -80, -30}}, color = {192,192,192}, pattern = LinePattern.Dash),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, extent = {{66, -93},{91, -81}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -15,68},{24,83}}, textString = "time", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{33,67},{76,83}}, textString = "v", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {192,192,192}, extent = {{ -73,75},{ -53,95}}, textString = "i", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This block generates a current source by <b>linear interpolation</b> in
// a table. The time points and current values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the current to be interpolated.
// The table interpolation has the following proporties:
// </p>
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the current value is just returned independantly of the
//     actual time instant, i.e., this is a constant current source.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the current.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// <p>
// Example:
// </p>
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// If, e.g., time = 1.0, the current i =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the current i =  2.5,
//     e.g., time = 2.0, the current i =  4.0,
//     e.g., time = 5.0, the current i = 23.0 (i.e. extrapolation).
// </pre>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>"));
//         end TableCurrent;
//       end Sources;
//     end Analog;
//     package Digital "Library for digital electrical components based on the VHDL standard with 9-valued logic and conversion to 2-,3-,4-valued logic"
//       package UsersGuide "Users Guide"
//         annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Users Guide of package Electrical.Digital</font></h3>
// <p>
// Library <b>Electrical.Digital</b> is a <b>free</b> Modelica package providing
// components to model <b>digital</b> electronic
// systems based on combinational and sequential logic in a convenient
// way. This package contains the <b>users guide</b> for
// the library and has the following content:
// </p>
// <ol>
// <li><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.OverView\">Overview of library</a>
//      gives an overview of the library.</li>
// <li> <a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.FirstExample\">A first example</a>
//      demonstrates at hand of a first example how to use this library.</li>
// <li> <a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.ApplicationExample\">An
//      application example</a> demonstrates a generic n-bit adder.
//      .</li>
// <li><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.ReleaseNotes\">Release Notes</a>
//     summarizes the differences between different versions of this library.</li>
// <li><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.Literature\">Literature</a>
//     provides references that have been used to design and implement this
//     library.</li>
// <li><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide.Contact\">Contact</a>
//     provides information about the authors of the library as well as
//     acknowledgments.</li>
// </ol>
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         class OverView "Overview of library"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Overview of Library Electrical.Digital</font></h3>
// <p>
// In this section, an overview of the most important features
// of this library is given.
// </p>
// <p>(will be added as soon as possible). </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end OverView;
//         class FirstExample "A first example"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>A first example</font></h3>
// <p>
// A first example will be given here (not yet done).
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end FirstExample;
//         class ApplicationExample "An application example"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>An application example</font></h3>
// <p>
// An application example will be given here (not yet done).
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end ApplicationExample;
//         class ReleaseNotes "Release notes"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Release notes</font></h3>
// <h3><font color=\"#008000\">Version 1.0.7, 2005-07-01</font></h3>
// <ul>
// <li> xxxx</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.6, 2004-10-18</font></h3>
// <ul>
// <li> Missing HTML tags added (problems with mismatched pre tags fixed).</li>
// <li> CVS ID string deleted.</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.5, 2004-10-01</font></h3>
// <ul>
// <li> Wrong identifiers x0 and Tdel in HalfAdder example fixed.</li>
// <li> Experiment command in FlipFlop example deleted.</li>
// <li> Known issue: Pulse source causes a warning in Dymola. It is recommended to use Clock source.</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.4, 2004-09-30</font></h3>
// <ul>
// <li> Documentation improved.</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.3, 2004-09-21</font></h3>
// <ul>
// <li> Table names changed from \"map\" to \"Table\".</li>
// <li> Icons for converters modified.</li>
// <li> LogicValueType renamed to Logic. For the Electrical.Digital library
//      the type Logic has a fundamental meaning. Logic is similar to
//      Real, Integer or Boolean in other packages. Names for converters
//      are now more consistent (LogicToBoolean, RealToLogic etc.).</li>
// <li> Icons for gates and sources improved.</li>
// <li> New examples added.</li>
// <li> Internal names for signals and ports unified.</li>
// <li> Simple Clock source added in addition to Pulse source (for convenience reasons).</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.2, 2004-09-13</font></h3>
// <ul>
// <li> First prerelease for discussions at the 40th Modelica Design Meeting.</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.1, 2004-06-01</font></h3>
// <ul>
// <li> Packages Tables, Basic, and Gates implemented.</li>
// <li> Transport and inertial delay implemented and successfully tested.</li>
// </ul>
// <h3><font color=\"#008000\">Version 1.0.0, 2003-05-01</font></h3>
// <ul>
// <li> A first version has been implemented for case studies.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end ReleaseNotes;
//         class Literature "Literature"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Literature</font></h3>
// <p>
// The Electrical.Digital library is based on the following references:
// </p>
// <dl>
// <dt>Ashenden, P. J.:</dt>
// <dd> <b>The Designer's Guide to VHDL.</b> San Francisco: Morgan Kaufmann, 1995, 688 p. ISBN 1-55860-270-4.
//      <br>&nbsp;</dd>
// </dl>
// <dl>
// <dt>IEEE 1076-1993:</dt>
// <dd> <b>IEEE Standard VHDL Language Reference Manual (ANSI).</b> 288 p. ISBN 1-55937-376-8. IEEE Ref. SH16840-NYF.
//      <br>&nbsp;</dd>
// </dl>
// <dl>
// <dt>IEEE 1164-1993:</dt>
// <dd> <b>IEEE Standard Multivalue Logic System for VHDL Model Interoperability (Std_logic_1164).</b> 24 p. ISBN 1-55937-299-0. IEEE Ref. SH16097-NYF.
//      <br>&nbsp;</dd>
// </dl>
// <dl>
// <dt>Lipsett, R.; Schaefer, C.; Ussery, C.:</dt>
// <dd> <b>VHDL: Hardware Description and Design.</b> Boston: Kluwer, 1989, 299 p. ISBN 079239030X.
//      <br>&nbsp;</dd>
// </dl>
// <dl>
// <dt>Navabi, Z:</dt>
// <dd> <b>VHDL: Analysis and Modeling of Digital Systems.</b> New York: McGraw-Hill, 1993, 375 p. ISBN 0070464723.
//      <br>&nbsp;</dd>
// </dl>
// </html>
//  "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Literature;
//         class Contact "Contact"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// <dl>
// <dt><b>Main Authors:</b>
// <dd><a href=\"http://people.eas.iis.fraunhofer.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<A HREF=\"mailto:Christoph.Clauss@eas.iis.fraunhofer.de\">Christoph.Clauss@eas.iis.fraunhofer.de</A>&gt;<br>
//     <a href=\"http://people.eas.iis.fraunhofer.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<A HREF=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</A>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits (IIS)<br>
//     Design Automation Department (EAS)<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
//     Germany<br>
// </dl>
// <br>
// <br>
// <dl>
// <dt><b>Acknowledgements:</b></dt>
// <dd>
//     We thank our colleague <a href=\"http://people.eas.iis.fraunhofer.de/Ulrich.Donath/\">Ulrich Donath</a>
//     &lt;<a href=\"mailto:Ulrich.Donath@eas.iis.fraunhofer.de\">Ulrich.Donath@eas.iis.fraunhofer.de</a>&gt;
//     for his support and fruitful discussions regarding all questions on VHDL and the IEEE 1164 standard
//     logic libraries. Furthermore, we thank our students Teresa Schlegel and Enrico Weber for implementing
//     and carefully testing many models and examples.<br>
// </dd>
// </dl>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Contact;
//       end UsersGuide;
//       annotation(Documentation(info = "<html>
// <p>
// This library contains packages for digital electrical components. Both, type system
// and models are based on the VHDL standard (IEEE Std 1076-1987 VHDL, IEEE Std 1076-1993 VHDL,
// IEEE Std 1164 Multivalue Logic System):
// <ul>
// <li>Interfaces: Definition of signals and interfaces</li>
// <li>Tables: All truth tables needed</li>
// <li>Delay: Transport and inertial delay</li>
// <li>Basic: Basic logic without delay</li>
// <li>Gates: Basic gates composed by basic components and inertial delay</li>
// <li>Tristate: (not yet available)</li>
// <li>FlipFlops: (not yet available) </li>
// <li>Latches: (not yet available)</li>
// <li>TransferGates: (not yet available)</li>
// <li>Multiplexers (not yet available)</li>
// <li>Memory: Ram, Rom, (not yet available)</li>
// <li>Sources: Time-dependend signal sources</li>
// <li>Converters</li>
// <li>Examples</li>
// </ul>
// </p>
// <p>
// The logic values are coded by integer values. The following code table is necessary
// for both setting of input and interpreting the output values.
// </p>
// <p><b>Code Table:</b></p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// 
// <p>
// The library will be developed in two main steps. The first step contains the basic components and
// the gates. In the next step the more complicated devices will be added. Currently the first step of
// the library is implemented and released for public use.
// </p>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and Fraunhofer-Gesellschaft.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// 
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0, -100.0},{ -100.0,50.0},{80.0,50.0},{80.0, -100.0},{ -100.0, -100.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -52.0,4.0},{ -32.0, -36.0}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{8.0, -46.0},{28.0, -86.0}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{8.0,4.0},{28.0, -36.0}}),Line(visible = true, points = {{ -72.0, -6.0},{ -52.0, -6.0}}),Line(visible = true, points = {{ -72.0, -28.0},{ -52.0, -28.0}}),Ellipse(visible = true, extent = {{ -32.0, -14.0},{ -28.0, -18.0}}),Ellipse(visible = true, extent = {{28.0, -14.0},{32.0, -18.0}}),Line(visible = true, points = {{ -28.0, -16.0},{8.0, -16.0}}),Line(visible = true, points = {{ -28.0, -16.0},{ -12.0, -16.0},{ -12.0, -56.0},{8.0, -56.0}}),Line(visible = true, points = {{8.0, -76.0},{ -72.0, -76.0}}),Line(visible = true, points = {{32.0, -16.0},{48.0, -16.0}}),Line(visible = true, points = {{28.0, -66.0},{48.0, -66.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -52.0, -8.0},{ -32.0,0.0}}, textString = "&", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{8.0, -10.0},{28.0, -2.0}}, textString = "1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{8.0, -58.0},{28.0, -50.0}}, textString = "=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -90.0,10.0},{70.0,40.0}}, textString = "Library", fontName = "Arial")}));
//       package Examples "Examples that demonstrate the usage of the Digital electrical components"
//         model Multiplexer "4 to 1 Bit Multiplexer Example"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           annotation(Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>4 to 1 Bit Multiplexer</font></h3>
// <P>
// The multiplexer converts a parallel 4 bit signal in a sequential
// 1 bit stream.
// </P>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -100.0,100.0},{100.0, -100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 250), experimentSetupOutput);
//           Modelica.Electrical.Digital.Sources.Clock CLK(period = 20) annotation(Placement(visible = true, transformation(origin = { -70.0, -46.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table D0(y0 = 3, x = {4,3,4,3}, t = {50,100,145,200}) annotation(Placement(visible = true, transformation(origin = { -70.0,68.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table D1(y0 = 3, x = {4,3,4,3}, t = {22,140,150,180}) annotation(Placement(visible = true, transformation(origin = { -70.0,42.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.MUX4 MUX annotation(Placement(visible = true, transformation(origin = {30.0,40.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table D2(y0 = 3, x = {4,3,4,3}, t = {22,140,150,180}) annotation(Placement(visible = true, transformation(origin = { -70.0,16.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table D3(y0 = 3, x = {4,3,4,3}, t = {22,140,150,180}) annotation(Placement(visible = true, transformation(origin = { -70.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.JKFF FF annotation(Placement(visible = true, transformation(origin = { -10.0, -52.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Set Enable annotation(Placement(visible = true, transformation(origin = { -70.0, -72.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(FF.q,MUX.a1) annotation(Line(visible = true, points = {{0.0, -45.0},{2.0, -45.0},{2.0, -22.0},{ -20.0, -22.0},{ -20.0,12.0},{ -10.0,12.0}}, color = {127,0,127}));
//           connect(D3.y,MUX.d3) annotation(Line(visible = true, points = {{ -60.0, -10.0},{ -46.0, -10.0},{ -46.0,36.8},{ -10.0,36.8}}, color = {127,0,127}));
//           connect(D2.y,MUX.d2) annotation(Line(visible = true, points = {{ -60.0,16.0},{ -50.0,16.0},{ -50.0,47.2},{ -10.0,47.2}}, color = {127,0,127}));
//           connect(D1.y,MUX.d1) annotation(Line(visible = true, points = {{ -60.0,42.0},{ -54.0,42.0},{ -54.0,57.6},{ -10.0,57.6}}, color = {127,0,127}));
//           connect(D0.y,MUX.d0) annotation(Line(visible = true, points = {{ -60.0,68.0},{ -10.0,68.0}}, color = {127,0,127}));
//           connect(CLK.y,MUX.a0) annotation(Line(visible = true, points = {{ -60.0, -46.0},{ -36.0, -46.0},{ -36.0,22.4},{ -10.0,22.4}}, color = {127,0,127}));
//           connect(Enable.y,FF.j) annotation(Line(visible = true, points = {{ -60.0, -72.0},{ -30.0, -72.0},{ -30.0, -45.0},{ -20.0, -45.0}}, color = {127,0,127}));
//           connect(Enable.y,FF.k) annotation(Line(visible = true, points = {{ -60.0, -72.0},{ -30.0, -72.0},{ -30.0, -59.0},{ -20.0, -59.0}}, color = {127,0,127}));
//           connect(CLK.y,FF.clk) annotation(Line(visible = true, points = {{ -60.0, -46.0},{ -36.0, -46.0},{ -36.0, -52.0},{ -20.0, -52.0}}, color = {127,0,127}));
//         end Multiplexer;
//         model FlipFlop "Pulse Triggered Master Slave Flip-Flop"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           annotation(Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>FlipFlop</font></h3>
// <P>
// Pulse-triggered master-slave flip-flop.
// </P>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -100.0,100.0},{100.0, -100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 250), experimentSetupOutput);
//           Modelica.Electrical.Digital.Examples.Utilities.JKFF FF annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Clock CLK(period = 10) annotation(Placement(visible = true, transformation(origin = { -70.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table J(y0 = 3, x = {4,3,4,3}, t = {50,100,145,200}) annotation(Placement(visible = true, transformation(origin = { -70.0,28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table K(y0 = 3, x = {4,3,4,3}, t = {22,140,150,180}) annotation(Placement(visible = true, transformation(origin = { -70.0, -28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(K.y,FF.k) annotation(Line(visible = true, points = {{ -60.0, -28.0},{ -10.0, -28.0}}, color = {127,0,127}));
//           connect(CLK.y,FF.clk) annotation(Line(visible = true, points = {{ -60.0,0.0},{ -10.0,0.0}}, color = {127,0,127}));
//           connect(J.y,FF.j) annotation(Line(visible = true, points = {{ -60.0,28.0},{ -10.0,28.0}}, color = {127,0,127}));
//         end FlipFlop;
//         model HalfAdder "adding circuit for binary numbers without input carry bit"
//           import Modelica.Electrical.Digital;
//           annotation(Documentation(info = "<HTML>
// <P>
// This example demonstrates an adding circuit for binary numbers, which internally realizes the interconnection to
// And and to Xor in the final sum.
// <br>
// <br>
// 1 + 0 = 1<br>
// 0 + 1 = 1<br>
// 1 + 1 = 10<br>
// 0 + 0 = 0
// <br>
// <br>
// <b>a</b> + <b>b</b> = <b>s</b>
// <br>(The carry of this adding is <b>c</b>.)
// <br>
// <br>and
// <br>
// <br>
// <b>a</b> * <b>b</b> = <b>s</b>
// <br>  (It is an interconnection to And.)
// <br>
// <br>
// <b>a</b> * <b>b</b> + <b>a</b> * <b>b</b> = <b>a</b> Xor <b>b</b> = <b>c</b>
// <br>(It is an interconnection to Xor.)
// <br>
// <br>
// <pre>  <b>a</b>     <b>b</b>     <b>c</b>      <b>s</b>     <b>t</b></pre>
// 
//  <pre>  1     0     1      0     1</pre>
//  <pre>  0     1     1      0     2</pre>
//  <pre>  1     1     0      1     3</pre>
//  <pre>  0     0     0      0     4</pre>
// 
// <br>
// <br>
// <b>t</b> is the pick-up instant of the next bit(s) in the simulation.
// The simulation stop time should be 5 seconds.
// </P>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -88.0,100.0},{90.0, -100.0}}),Line(visible = true, points = {{40.0,54.0},{40.0,60.0},{ -40.0,60.0},{10.0,0.0},{ -40.0, -60.0},{40.0, -60.0},{40.0, -52.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 5), experimentSetupOutput);
//           Modelica.Electrical.Digital.Sources.Table a(t = {1,2,3,4}, x = {4,3,4,3}, y0 = 3) annotation(Placement(visible = true, transformation(origin = { -70.0,28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table b(x = {4,3}, t = {2,4}, y0 = 3) annotation(Placement(visible = true, transformation(origin = { -70.0, -28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.HalfAdder Adder(delayTime = 0.3) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal s annotation(Placement(visible = true, transformation(origin = {70.0,28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal c annotation(Placement(visible = true, transformation(origin = {70.0, -28.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(Adder.c,c.x[1]) annotation(Line(visible = true, points = {{40.0, -28.0},{65.0, -28.0}}, color = {127,0,127}));
//           connect(Adder.s,s.x[1]) annotation(Line(visible = true, points = {{40.0,28.0},{65.0,28.0}}, color = {127,0,127}));
//           connect(a.y,Adder.a) annotation(Line(visible = true, points = {{ -60.0,28.0},{ -40.0,28.0}}, color = {127,0,127}));
//           connect(b.y,Adder.b) annotation(Line(visible = true, points = {{ -60.0, -28.0},{ -40.0, -28.0}}, color = {127,0,127}));
//         end HalfAdder;
//         model FullAdder "Full 1 Bit Adder Example"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           annotation(Documentation(info = "<HTML>
// <P>
// <br>It is an adding circuit for binary numbers with input carry bit, which consists of two HalfAdders.
// <br>
// <br>
// <b>a</b>.y, <b>b</b>.y and <b>c</b>.y are the inputs of the FullAdder.
// <br>
// <b>c</b>out = <b>Or1</b>.y and <b>h</b>.s are the outputs of the Fulladder.
// <br>
// <br>
// <b>t</b> is the pick-up instant of the next bit(s) in the simulation.
// <pre>   <b>a</b>.y      <b>b</b>.y      <b>c</b>.y     <b>c</b>out        <b>h</b>.s        <b>t</b> </pre>
// 
// <pre>
//      1        0        0        0          1        1
//      0        1        0        0          1        2
//      0        0        1        0          1        3
//      1        1        0        1          0        4
//      0        1        1        1          0        5
//      1        0        1        1          0        6
//      1        1        1        1          1        7
//      0        0        0        0          0        8
// </pre>
// </P>
// The simulation stop time should be 10 seconds.
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -100.0,100.0},{100.0, -100.0}}),Line(visible = true, points = {{40.0,54.0},{40.0,60.0},{ -40.0,60.0},{10.0,0.0},{ -40.0, -60.0},{40.0, -60.0},{40.0, -52.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 10), experimentSetupOutput(states = false, derivatives = false, inputs = false));
//           Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder1 annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -30.0, -30.0},{30.0,30.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal s annotation(Placement(visible = true, transformation(origin = {80.0,22.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal c_out annotation(Placement(visible = true, transformation(origin = {80.0, -22.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.Counter3 Counter annotation(Placement(visible = true, transformation(origin = { -40.0,2.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Set Enable(x = L.'1') annotation(Placement(visible = true, transformation(origin = { -80.0,16.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Clock CLK annotation(Placement(visible = true, transformation(origin = { -80.0, -12.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(Counter.q0,Adder1.c_in) annotation(Line(visible = true, points = {{ -20.0, -12.0},{ -10.0, -12.0},{ -10.0, -21.0},{0.0, -21.0}}, color = {127,0,127}));
//           connect(Counter.q1,Adder1.b) annotation(Line(visible = true, points = {{ -20.0,2.0},{ -10.0,2.0},{ -10.0,9.0},{0.0,9.0}}, color = {127,0,127}));
//           connect(Counter.q2,Adder1.a) annotation(Line(visible = true, points = {{ -20.0,16.0},{ -10.0,16.0},{ -10.0,21.0},{0.0,21.0}}, color = {127,0,127}));
//           connect(Enable.y,Counter.enable) annotation(Line(visible = true, points = {{ -70.0,16.0},{ -60.0,16.0}}, color = {127,0,127}));
//           connect(CLK.y,Counter.count) annotation(Line(visible = true, points = {{ -70.0, -12.0},{ -60.0, -12.0}}, color = {127,0,127}));
//           connect(Adder1.c_out,c_out.x[1]) annotation(Line(visible = true, points = {{60.0, -21.0},{68.0, -21.0},{68.0, -22.0},{75.0, -22.0}}, color = {127,0,127}));
//           connect(Adder1.s,s.x[1]) annotation(Line(visible = true, points = {{60.3,21.0},{68.0,21.0},{68.0,22.0},{75.0,22.0}}, color = {127,0,127}));
//         end FullAdder;
//         model Adder4 "4 Bit Adder Example"
//           import Modelica.Electrical.Digital;
//           annotation(Documentation(info = "<HTML>
// <P>
// Four Fulladders are combined to built a four bit adder unit.
// <br>
// <br>
// In dependence on time five additions are carried out:
// <br>
// <pre>
// at t = 0                            at t = 1
//  a       0 0 0 0                       a      1 1 1 0
//  b    +  0 0 0 0                       b   +  1 0 1 1
//  <b>s     0 0 0 0 0</b>                      <b>s     1 0 0 1 0</b>
// at t = 2                             at t = 3
//  a       0 1 1 0                       a      1 1 1 0
//  b    +  0 0 1 1                       b   +  1 0 1 0
//  <b>s     1 0 1 0 0</b>                      <b>s     0 0 0 1 1</b>
// 
// at t = 4
//  a      1 1 0 0
//  b   +  1 1 1 0
//  <b>s    0 0 1 0 1</b>
//  </pre>
// To show the influence of delay a large delay time of 0.1s is choosen.
// Furthermore, all signals are initialized with U, the unitialized value.
// Please remember, that the nine logic values are coded by the numbers 1,...,9.
// The summands a and b can be found at the output signals of the taba and tabb sources.
// The result can be seen in the output signals of the Fulladders according to:
// <pre>
//       a                       <b>a4</b>.y      <b>a3</b>.y      <b>a2</b>.y      <b>a1</b>.y
//       b                       <b>b4</b>.y      <b>b3</b>.y      <b>b2</b>.y      <b>b1</b>.y
//       sum   <b>Adder4</b>.c_out  <b>Adder4.s</b>  <b>Adder3.s</b>  <b>Adder2.s</b>  <b>Adder1.s</b>
// </pre>
// The simulation stop time has to be 5s.
// 
// </P>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -200.0, -200.0},{200.0,200.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -200.0,200.0},{200.0, -200.0}})}), Diagram(coordinateSystem(extent = {{ -200.0, -200.0},{200.0,200.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 5), experimentSetupOutput(states = false, derivatives = false, inputs = false));
//           Modelica.Electrical.Digital.Sources.Table b4(y0 = 3, x = {4,3}, t = {1,3}) annotation(Placement(visible = true, transformation(origin = {90.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table b1(x = {4,3,4}, y0 = 3, t = {1,2,3}) annotation(Placement(visible = true, transformation(origin = { -150.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table b2(y0 = 3, x = {4}, t = {4}) annotation(Placement(visible = true, transformation(origin = { -70.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table b3(y0 = 3, x = {4}, t = {1}) annotation(Placement(visible = true, transformation(origin = {10.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table a1(y0 = 3, x = {4,3,4}, t = {1,2,3}) annotation(Placement(visible = true, transformation(origin = { -150.0,60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table a2(y0 = 3, x = {4}, t = {1}) annotation(Placement(visible = true, transformation(origin = { -70.0,60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table a3(y0 = 3, x = {4,3}, t = {1,4}) annotation(Placement(visible = true, transformation(origin = {11.0,60.0}, extent = {{ -19.0, -20.0},{19.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Table a4(y0 = 3, x = {3}, t = {1}) annotation(Placement(visible = true, transformation(origin = {90.0,60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Set Set(x = 3) annotation(Placement(visible = true, transformation(origin = { -150.0, -74.0}, extent = {{20.0,20.0},{ -20.0, -20.0}}, rotation =  -180)));
//           Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder1 annotation(Placement(visible = true, transformation(origin = { -80.0, -60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder2 annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder3 annotation(Placement(visible = true, transformation(origin = {80.0, -60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder4 annotation(Placement(visible = true, transformation(origin = {160.0, -60.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//         equation 
//           connect(a4.y,Adder4.a) annotation(Line(visible = true, points = {{110.0,60.0},{130.0,60.0},{130.0, -46.0},{140.0, -46.0}}, color = {127,0,127}));
//           connect(b4.y,Adder4.b) annotation(Line(visible = true, points = {{110.0,0.0},{120.0,0.0},{120.0, -54.0},{140.0, -54.0}}, color = {127,0,127}));
//           connect(a3.y,Adder3.a) annotation(Line(visible = true, points = {{30.0,60.0},{50.0,60.0},{50.0, -46.0},{60.0, -46.0}}, color = {127,0,127}));
//           connect(b3.y,Adder3.b) annotation(Line(visible = true, points = {{30.0,0.0},{40.0,0.0},{40.0, -54.0},{60.0, -54.0}}, color = {127,0,127}));
//           connect(a2.y,Adder2.a) annotation(Line(visible = true, points = {{ -50.0,60.0},{ -30.0,60.0},{ -30.0, -46.0},{ -20.0, -46.0}}, color = {127,0,127}));
//           connect(b2.y,Adder2.b) annotation(Line(visible = true, points = {{ -50.0,0.0},{ -40.0,0.0},{ -40.0, -54.0},{ -20.0, -54.0}}, color = {127,0,127}));
//           connect(Adder3.c_out,Adder4.c_in) annotation(Line(visible = true, points = {{100.0, -74.0},{140.0, -74.0}}, color = {127,0,127}));
//           connect(Adder2.c_out,Adder3.c_in) annotation(Line(visible = true, points = {{20.0, -74.0},{60.0, -74.0}}, color = {127,0,127}));
//           connect(Adder1.c_out,Adder2.c_in) annotation(Line(visible = true, points = {{ -60.0, -74.0},{ -20.0, -74.0}}, color = {127,0,127}));
//           connect(Set.y,Adder1.c_in) annotation(Line(visible = true, points = {{ -130.0, -74.0},{ -100.0, -74.0}}, color = {127,0,127}));
//           connect(a1.y,Adder1.a) annotation(Line(visible = true, points = {{ -130.0,60.0},{ -110.0,60.0},{ -110.0, -46.0},{ -100.0, -46.0}}, color = {127,0,127}));
//           connect(b1.y,Adder1.b) annotation(Line(visible = true, points = {{ -130.0,0.0},{ -120.0,0.0},{ -120.0, -54.0},{ -100.0, -54.0}}, color = {127,0,127}));
//         end Adder4;
//         model Counter3 "3 Bit Counter Example"
//           import D = Modelica.Electrical.Digital;
//           annotation(Documentation(info = "<HTML>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -100.0,100.0},{100.0, -100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 10), experimentSetupOutput(states = false, derivatives = false, inputs = false));
//           Modelica.Electrical.Digital.Sources.Step Enable annotation(Placement(visible = true, transformation(origin = { -70.0,28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Clock Clock annotation(Placement(visible = true, transformation(origin = { -70.0, -28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.Counter3 Counter annotation(Placement(visible = true, transformation(origin = {10.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
// 
//         equation 
//           connect(Clock.y,Counter.count) annotation(Line(visible = true, points = {{ -50.0, -28.0},{ -30.0, -28.0}}, color = {127,0,127}));
//           connect(Enable.y,Counter.enable) annotation(Line(visible = true, points = {{ -50.0,28.0},{ -30.0,28.0}}, color = {127,0,127}));
//         end Counter3;
//         model Counter "Generic N Bit Counter Example"
//           import D = Modelica.Electrical.Digital;
//           annotation(Documentation(info = "<HTML>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -100.0,100.0},{100.0, -100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 100), experimentSetupOutput(states = false, derivatives = false, inputs = false));
//           Modelica.Electrical.Digital.Sources.Step Enable annotation(Placement(visible = true, transformation(origin = { -70.0,28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Sources.Clock Clock annotation(Placement(visible = true, transformation(origin = { -70.0, -28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Examples.Utilities.Counter Counter(n = 4) annotation(Placement(visible = true, transformation(origin = {10.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal Q0 annotation(Placement(visible = true, transformation(origin = {76.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal Q1 annotation(Placement(visible = true, transformation(origin = {76.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal Q2 annotation(Placement(visible = true, transformation(origin = {76.0,10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Converters.LogicToReal Q3 annotation(Placement(visible = true, transformation(origin = {76.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(Q3.x[1],Counter.q[4]) annotation(Line(visible = true, points = {{71.0,30.0},{60.0,30.0},{60.0,24.0},{50.0,0.0}}, color = {127,0,127}));
//           connect(Q2.x[1],Counter.q[3]) annotation(Line(visible = true, points = {{71.0,10.0},{60.0,10.0},{60.0,8.0},{50.0,0.0}}, color = {127,0,127}));
//           connect(Q1.x[1],Counter.q[2]) annotation(Line(visible = true, points = {{71.0, -10.0},{60.0, -10.0},{60.0, -8.0},{50.0,0.0}}, color = {127,0,127}));
//           connect(Q0.x[1],Counter.q[1]) annotation(Line(visible = true, points = {{71.0, -30.0},{58.0, -30.0},{58.0, -24.0},{50.0,0.0}}, color = {127,0,127}));
//           connect(Clock.y,Counter.count) annotation(Line(visible = true, points = {{ -50.0, -28.0},{ -30.0, -28.0}}, color = {127,0,127}));
//           connect(Enable.y,Counter.enable) annotation(Line(visible = true, points = {{ -50.0,28.0},{ -30.0,28.0}}, color = {127,0,127}));
//         end Counter;
//         package Utilities "Utility components used by package Examples"
//           model MUX4 "4 to 1 Bit Multiplexer"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,60.0},{ -64.0,80.0}}, textString = "D0", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0, -8.0},{86.0,12.0}}, textString = "D", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0,40.0},{60.0,100.0}}, textString = "MUX", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -80.0},{ -64.0, -60.0}}, textString = "A1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,34.0},{ -64.0,54.0}}, textString = "D1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,8.0},{ -64.0,28.0}}, textString = "D2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -18.0},{ -64.0,2.0}}, textString = "D3", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -56.0},{ -64.0, -36.0}}, textString = "A0", fontName = "Arial")}));
//             parameter Modelica.SIunits.Time delayTime = 0.001;
//             parameter D.Interfaces.Logic q0 = L.'0';
//             Modelica.Electrical.Digital.Interfaces.DigitalInput d0 annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput d1 annotation(Placement(visible = true, transformation(origin = { -100.0,44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput d2 annotation(Placement(visible = true, transformation(origin = { -100.0,18.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,18.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput d3 annotation(Placement(visible = true, transformation(origin = { -100.0, -8.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -8.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput a0 annotation(Placement(visible = true, transformation(origin = { -100.0, -44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput a1 annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput d annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Or Or1(n = 4) annotation(Placement(visible = true, transformation(origin = {60.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And1(n = 3) annotation(Placement(visible = true, transformation(origin = { -10.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And2(n = 3) annotation(Placement(visible = true, transformation(origin = { -10.0,44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And3(n = 3) annotation(Placement(visible = true, transformation(origin = { -10.0,18.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And4(n = 3) annotation(Placement(visible = true, transformation(origin = { -10.0, -8.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Not Not1 annotation(Placement(visible = true, transformation(origin = { -66.0, -44.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Not Not2 annotation(Placement(visible = true, transformation(origin = { -66.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(a1,And3.x[1]) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -80.0, -70.0},{ -80.0, -90.0},{ -30.0, -90.0},{ -30.0,12.6667},{ -16.0,18.0}}, color = {127,0,127}));
//             connect(a1,And4.x[1]) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -80.0, -70.0},{ -80.0, -90.0},{ -30.0, -90.0},{ -30.0, -13.3333},{ -16.0, -8.0}}, color = {127,0,127}));
//             connect(a0,And2.x[3]) annotation(Line(visible = true, points = {{ -100.0, -44.0},{ -80.0, -44.0},{ -80.0,49.3333},{ -16.0,44.0}}, color = {127,0,127}));
//             connect(a0,And4.x[3]) annotation(Line(visible = true, points = {{ -100.0, -44.0},{ -80.0, -44.0},{ -80.0, -2.6667},{ -16.0, -8.0}}, color = {127,0,127}));
//             connect(Not2.y,And2.x[1]) annotation(Line(visible = true, points = {{ -56.0, -70.0},{ -40.0, -70.0},{ -40.0,38.6667},{ -16.0,44.0}}, color = {127,0,127}));
//             connect(Not2.y,And1.x[1]) annotation(Line(visible = true, points = {{ -56.0, -70.0},{ -40.0, -70.0},{ -40.0,64.6667},{ -16.0,70.0}}, color = {127,0,127}));
//             connect(Not1.y,And3.x[3]) annotation(Line(visible = true, points = {{ -56.0, -44.0},{ -50.0, -44.0},{ -50.0,23.3333},{ -16.0,18.0}}, color = {127,0,127}));
//             connect(Not1.y,And1.x[3]) annotation(Line(visible = true, points = {{ -56.0, -44.0},{ -50.0, -44.0},{ -50.0,75.3333},{ -16.0,70.0}}, color = {127,0,127}));
//             connect(Or1.y,d) annotation(Line(visible = true, points = {{70.0,30.0},{80.0,30.0},{80.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//             connect(And1.y,Or1.x[4]) annotation(Line(visible = true, points = {{0.0,70.0},{40.0,70.0},{40.0,36.0},{54.0,30.0}}, color = {127,0,127}));
//             connect(And2.y,Or1.x[3]) annotation(Line(visible = true, points = {{0.0,44.0},{20.0,44.0},{20.0,32.0},{54.0,30.0}}, color = {127,0,127}));
//             connect(And3.y,Or1.x[2]) annotation(Line(visible = true, points = {{0.0,18.0},{20.0,18.0},{20.0,28.0},{54.0,30.0}}, color = {127,0,127}));
//             connect(And4.y,Or1.x[1]) annotation(Line(visible = true, points = {{0.0, -8.0},{40.0, -8.0},{40.0,24.0},{54.0,30.0}}, color = {127,0,127}));
//             connect(d3,And4.x[2]) annotation(Line(visible = true, points = {{ -100.0, -8.0},{ -58.0, -8.0},{ -58.0, -8.0},{ -16.0, -8.0}}, color = {127,0,127}));
//             connect(d2,And3.x[2]) annotation(Line(visible = true, points = {{ -100.0,18.0},{ -16.0,18.0}}, color = {127,0,127}));
//             connect(d1,And2.x[2]) annotation(Line(visible = true, points = {{ -100.0,44.0},{ -16.0,44.0}}, color = {127,0,127}));
//             connect(d0,And1.x[2]) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -58.0,70.0},{ -58.0,70.0},{ -16.0,70.0}}, color = {127,0,127}));
//             connect(a1,Not2.x) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -72.0, -70.0}}, color = {127,0,127}));
//             connect(a0,Not1.x) annotation(Line(visible = true, points = {{ -100.0, -44.0},{ -72.0, -44.0}}, color = {127,0,127}));
//           end MUX4;
//           model RS "Unclocked RS FlipFlop"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,40.0},{100.0,100.0}}, textString = "RS", fontName = "Arial"),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -80.0},{ -64.0, -60.0}}, textString = "R", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,60.0},{ -64.0,80.0}}, textString = "S", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0,60.0},{86.0,80.0}}, textString = "Q", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0, -80.0},{86.0, -60.0}}, textString = "QN", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial")}));
//             parameter Modelica.SIunits.Time delayTime = 0 "delay time";
//             parameter D.Interfaces.Logic q0 = L.'U' "initial value of output";
//             Modelica.Electrical.Digital.Basic.Nor Nor1 annotation(Placement(visible = true, transformation(origin = { -20.0,62.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Nor Nor2 annotation(Placement(visible = true, transformation(origin = { -20.0, -62.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput s annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput r annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput qn annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Delay.TransportDelay TD1(delayTime = delayTime, y0 = q0) annotation(Placement(visible = true, transformation(origin = { -50.0, -54.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(TD1.x,Nor1.y) annotation(Line(visible = true, points = {{ -56.0, -54.0},{ -70.0, -54.0},{ -70.0, -20.0},{20.0,20.0},{20.0,62.0},{0.0,62.0}}, color = {127,0,127}));
//             connect(TD1.y,Nor2.x[2]) annotation(Line(visible = true, points = {{ -40.0, -54.0},{ -32.0, -62.0}}, color = {127,0,127}));
//             connect(Nor2.y,q) annotation(Line(visible = true, points = {{0.0, -62.0},{70.0, -62.0},{70.0,70.0},{100.0,70.0}}, color = {127,0,127}));
//             connect(Nor1.y,qn) annotation(Line(visible = true, points = {{0.0,62.0},{50.0,62.0},{50.0, -70.0},{100.0, -70.0}}, color = {127,0,127}));
//             connect(Nor2.y,Nor1.x[1]) annotation(Line(visible = true, points = {{0.0, -62.0},{20.0, -62.0},{20.0, -20.0},{ -70.0,20.0},{ -70.0,54.0},{ -32.0,62.0}}, color = {127,0,127}));
//             connect(r,Nor2.x[1]) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -32.0, -62.0}}, color = {127,0,127}));
//             connect(s,Nor1.x[2]) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -32.0,62.0}}, color = {127,0,127}));
//           end RS;
//           model RSFF "Unclocked RS FlipFlop"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,40.0},{100.0,100.0}}, textString = "RS", fontName = "Arial"),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -80.0},{ -64.0, -60.0}}, textString = "R", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,60.0},{ -64.0,80.0}}, textString = "S", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0,60.0},{86.0,80.0}}, textString = "Q", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0, -80.0},{86.0, -60.0}}, textString = "QN", fontName = "Arial"),Line(visible = true, points = {{ -90.0,20.0},{ -60.0,0.0},{ -90.0, -20.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial")}));
//             parameter Modelica.SIunits.Time delayTime = 0.01;
//             parameter D.Interfaces.Logic q0 = L.'U';
//             Modelica.Electrical.Digital.Interfaces.DigitalInput s annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput r annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput qn "not Q" annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput clk annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.RS RS1(delayTime = delayTime, q0 = q0) annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And1 annotation(Placement(visible = true, transformation(origin = { -50.0,28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And2 annotation(Placement(visible = true, transformation(origin = { -50.0, -28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//           equation 
//             connect(RS1.qn,qn) annotation(Line(visible = true, points = {{70.0, -28.0},{80.0, -28.0},{80.0, -70.0},{100.0, -70.0}}, color = {127,0,127}));
//             connect(RS1.q,q) annotation(Line(visible = true, points = {{70.0,28.0},{80.0,28.0},{80.0,70.0},{100.0,70.0}}, color = {127,0,127}));
//             connect(r,And2.x[1]) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -70.0, -70.0},{ -70.0, -36.0},{ -62.0, -28.0}}, color = {127,0,127}));
//             connect(clk,And2.x[2]) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -70.0,0.0},{ -70.0, -20.0},{ -62.0, -28.0}}, color = {127,0,127}));
//             connect(clk,And1.x[1]) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -70.0,0.0},{ -70.0,20.0},{ -62.0,28.0}}, color = {127,0,127}));
//             connect(s,And1.x[2]) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -70.0,70.0},{ -70.0,36.0},{ -62.0,28.0}}, color = {127,0,127}));
//             connect(And1.y,RS1.s) annotation(Line(visible = true, points = {{ -30.0,28.0},{ -10.0,28.0}}, color = {127,0,127}));
//             connect(And2.y,RS1.r) annotation(Line(visible = true, points = {{ -30.0, -28.0},{ -10.0, -28.0}}, color = {127,0,127}));
//           end RSFF;
//           model DFF "D FlipFlop"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -86.0,80.0},{ -64.0,60.0}}, textString = "D", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{64.0,80.0},{86.0,60.0}}, textString = "Q", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{64.0, -60.0},{86.0, -80.0}}, textString = "QN", fontName = "Arial"),Line(visible = true, points = {{ -90.0,20.0},{ -60.0,0.0},{ -90.0, -20.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150.0, -100.0},{150.0, -160.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100.0,100.0},{100.0,40.0}}, textString = "D", fontName = "Arial")}));
//             parameter Modelica.SIunits.Time Tdel = 0.01;
//             parameter Digital.Interfaces.Logic QInit = L.'U';
//             Modelica.Electrical.Digital.Interfaces.DigitalInput d annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput qn "not Q" annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput clk annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.RSFF RSFF1 annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -40.0, -40.0},{40.0,40.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Not Not1 annotation(Placement(visible = true, transformation(origin = { -50.0, -28.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//           equation 
//             connect(d,RSFF1.s) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -80.0,70.0},{ -80.0,28.0},{ -10.0,28.0}}, color = {127,0,127}));
//             connect(d,Not1.x) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -80.0,70.0},{ -80.0, -28.0},{ -62.0, -28.0}}, color = {127,0,127}));
//             connect(clk,RSFF1.clk) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -10.0,0.0}}, color = {127,0,127}));
//             connect(Not1.y,RSFF1.r) annotation(Line(visible = true, points = {{ -30.0, -28.0},{ -10.0, -28.0}}, color = {127,0,127}));
//             connect(RSFF1.qn,qn) annotation(Line(visible = true, points = {{70.0, -28.0},{80.0, -28.0},{80.0, -70.0},{100.0, -70.0}}, color = {127,0,127}));
//             connect(RSFF1.q,q) annotation(Line(visible = true, points = {{70.0,28.0},{80.0,28.0},{80.0,70.0},{100.0,70.0}}, color = {127,0,127}));
//           end DFF;
//           model JKFF "JK FlipFlop"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,60.0},{ -64.0,80.0}}, textString = "J", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0,60.0},{86.0,80.0}}, textString = "Q", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0, -80.0},{86.0, -60.0}}, textString = "QN", fontName = "Arial"),Line(visible = true, points = {{ -90.0,20.0},{ -60.0,0.0},{ -90.0, -20.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, origin = {0.0,0.0}, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,40.0},{100.0,100.0}}, textString = "JK", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -80.0},{ -64.0, -60.0}}, textString = "K", fontName = "Arial")}));
//             parameter Modelica.SIunits.Time delayTime = 0.001;
//             parameter D.Interfaces.Logic q0 = L.'0';
//             Modelica.Electrical.Digital.Interfaces.DigitalInput j annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput qn "not Q" annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput clk annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput k annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.RS RS1(delayTime = delayTime, q0 = q0) annotation(Placement(visible = true, transformation(origin = {50.0, -4.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.RS RS2(delayTime = delayTime, q0 = q0) annotation(Placement(visible = true, transformation(origin = { -24.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And1(n = 3) annotation(Placement(visible = true, transformation(origin = { -60.0,14.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And2(n = 3) annotation(Placement(visible = true, transformation(origin = { -60.0, -14.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And3 annotation(Placement(visible = true, transformation(origin = {14.0,10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.And And4 annotation(Placement(visible = true, transformation(origin = {14.0, -18.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Basic.Not Not1 annotation(Placement(visible = true, transformation(origin = { -24.0, -56.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(RS1.q,qn) annotation(Line(visible = true, points = {{70.0,10.0},{80.0,10.0},{80.0, -70.0},{100.0, -70.0}}, color = {127,0,127}));
//             connect(RS1.qn,q) annotation(Line(visible = true, points = {{70.0, -18.0},{86.0, -18.0},{86.0,70.0},{100.0,70.0}}, color = {127,0,127}));
//             connect(RS1.qn,And1.x[3]) annotation(Line(visible = true, points = {{70.0, -18.0},{86.0, -18.0},{86.0,36.0},{ -70.0,36.0},{ -70.0,19.3333},{ -66.0,14.0}}, color = {127,0,127}));
//             connect(RS1.q,And2.x[1]) annotation(Line(visible = true, points = {{70.0,10.0},{80.0,10.0},{80.0, -36.0},{ -70.0, -36.0},{ -70.0, -19.3333},{ -66.0, -14.0}}, color = {127,0,127}));
//             connect(j,And1.x[2]) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -74.0,70.0},{ -74.0,14.0},{ -66.0,14.0}}, color = {127,0,127}));
//             connect(Not1.y,And4.x[1]) annotation(Line(visible = true, points = {{ -14.0, -56.0},{2.0, -56.0},{2.0, -22.0},{8.0, -18.0}}, color = {127,0,127}));
//             connect(Not1.y,And3.x[1]) annotation(Line(visible = true, points = {{ -14.0, -56.0},{2.0, -56.0},{2.0,6.0},{8.0,10.0}}, color = {127,0,127}));
//             connect(clk,Not1.x) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0},{ -80.0, -56.0},{ -30.0, -56.0}}, color = {127,0,127}));
//             connect(RS2.q,And3.x[2]) annotation(Line(visible = true, points = {{ -4.0,14.0},{8.0,10.0}}, color = {127,0,127}));
//             connect(RS2.qn,And4.x[2]) annotation(Line(visible = true, points = {{ -4.0, -14.0},{8.0, -18.0}}, color = {127,0,127}));
//             connect(And3.y,RS1.s) annotation(Line(visible = true, points = {{24.0,10.0},{30.0,10.0}}, color = {127,0,127}));
//             connect(And4.y,RS1.r) annotation(Line(visible = true, points = {{24.0, -18.0},{30.0, -18.0}}, color = {127,0,127}));
//             connect(k,And2.x[2]) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -74.0, -70.0},{ -74.0, -14.0},{ -66.0, -14.0}}, color = {127,0,127}));
//             connect(clk,And1.x[1]) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -74.0,0.0},{ -74.0,8.6667},{ -66.0,14.0}}, color = {127,0,127}));
//             connect(clk,And2.x[3]) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -74.0,0.0},{ -74.0, -8.6667},{ -66.0, -14.0}}, color = {127,0,127}));
//             connect(And1.y,RS2.s) annotation(Line(visible = true, points = {{ -50.0,14.0},{ -44.0,14.0}}, color = {127,0,127}));
//             connect(And2.y,RS2.r) annotation(Line(visible = true, points = {{ -50.0, -14.0},{ -44.0, -14.0}}, color = {127,0,127}));
//           end JKFF;
//           model HalfAdder
//             parameter Real delayTime = 0;
//             Modelica.Electrical.Digital.Interfaces.DigitalInput b annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput s annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -90.0,60.0},{ -60.0,80.0}}, textString = "a", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -90.0, -80.0},{ -60.0, -60.0}}, textString = "b", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60.0,60.0},{90.0,80.0}}, textString = "s", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60.0, -80.0},{90.0, -60.0}}, textString = "c", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, origin = {0.0, -50.0}, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,0.0},{100.0,100.0}}, textString = "+", fontName = "Arial"),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5)}), Documentation(info = "<html>
//   
// </html>"));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput a annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput c annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Gates.AndGate AND(tLH = delayTime, tHL = delayTime) annotation(Placement(visible = true, transformation(origin = {0.0, -70.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Gates.XorGate XOR(tLH = delayTime, tHL = delayTime) annotation(Placement(visible = true, transformation(origin = { -0.0,70.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//           equation 
//             connect(a,AND.x[2]) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -40.0,70.0},{ -40.0, -60.0},{ -12.0, -70.0}}, color = {127,0,127}));
//             connect(AND.y,c) annotation(Line(visible = true, origin = {60.0, -70.0}, points = {{ -40.0,0.0},{40.0,0.0}}, color = {127,0,127}));
//             connect(b,AND.x[1]) annotation(Line(visible = true, origin = { -56.0, -70.0}, points = {{ -44.0,0.0},{44.0,0.0}}, color = {127,0,127}));
//             connect(b,XOR.x[1]) annotation(Line(visible = true, origin = {0.0, -10.0}, points = {{ -100.0, -60.0},{ -30.0, -60.0},{ -30.0,70.0},{ -12.0,80.0}}, color = {127,0,127}));
//             connect(a,XOR.x[2]) annotation(Line(visible = true, origin = { -56.0,62.9668}, points = {{ -44.0,7.0332},{44.0,7.0332}}, color = {127,0,127}));
//             connect(XOR.y,s) annotation(Line(visible = true, origin = {60.0,70.0}, points = {{ -40.0,0.0},{40.0,0.0}}, color = {127,0,127}));
//           end HalfAdder;
//           model FullAdder "adding circuit for binary numbers with input carry bit"
//             annotation(Documentation(info = "<HTML>
// <P>
//  <pre>
//   <b>a     b     c in     c out     s</b>
// 
//          1     1     1     0
//          0     0     0     0
//          1     0     0     1
//          0     1     0     1
//  </pre>
// 
// 
// </P>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -151.0},{150.0, -96.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,60.0},{ -64.0,80.0}}, textString = "a", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0,20.0},{ -64.0,40.0}}, textString = "b", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -86.0, -80.0},{ -64.0, -60.0}}, textString = "c_in", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{60.0, -80.0},{90.0, -60.0}}, textString = "c_out", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0,60.0},{86.0,80.0}}, textString = "s", fontName = "Arial"),Text(visible = true, origin = {0.0,0.0}, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,0.0},{100.0,100.0}}, textString = "+", fontName = "Arial"),Line(visible = true, points = {{ -60.0,100.0},{ -60.0, -100.0}}, thickness = 0.5),Line(visible = true, points = {{60.0,100.0},{60.0, -100.0}}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Modelica.Electrical.Digital.Examples.Utilities.HalfAdder Adder2(delayTime = 0.001) annotation(Placement(visible = true, transformation(origin = {30.0,56.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.HalfAdder Adder1(delayTime = 0.001) annotation(Placement(visible = true, transformation(origin = { -40.0,56.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput a annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput b annotation(Placement(visible = true, transformation(origin = { -100.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180), iconTransformation(origin = { -100.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput c_in annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -180)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput s annotation(Placement(visible = true, transformation(origin = {101.0,70.0}, extent = {{11.0, -10.0},{ -11.0,10.0}}, rotation =  -180), iconTransformation(origin = {101.0,70.0}, extent = {{11.0, -10.0},{ -11.0,10.0}}, rotation =  -180)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput c_out annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -180), iconTransformation(origin = {100.0, -70.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -180)));
//             Modelica.Electrical.Digital.Basic.Or OR annotation(Placement(visible = true, transformation(origin = {30.0, -70.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//           equation 
//             connect(c_in,Adder2.b) annotation(Line(visible = true, points = {{ -100.0, -70.0},{0.0, -70.0},{0.0,42.0},{10.0,42.0}}, color = {127,0,127}));
//             connect(Adder1.c,OR.x[1]) annotation(Line(visible = true, points = {{ -20.0,42.0},{ -10.0,42.0},{ -10.0, -78.0},{18.0, -70.0}}, color = {127,0,127}));
//             connect(Adder1.s,Adder2.a) annotation(Line(visible = true, points = {{ -20.0,70.0},{10.0,70.0}}, color = {127,0,127}));
//             connect(b,Adder1.b) annotation(Line(visible = true, points = {{ -100.0,30.0},{ -70.0,30.0},{ -70.0,42.0},{ -60.0,42.0}}, color = {127,0,127}));
//             connect(Adder1.a,a) annotation(Line(visible = true, points = {{ -60.0,70.0},{ -100.0,70.0}}, color = {127,0,127}));
//             connect(Adder2.s,s) annotation(Line(visible = true, points = {{50.0,70.0},{101.0,70.0}}, color = {127,0,127}));
//             connect(Adder2.c,OR.x[2]) annotation(Line(visible = true, points = {{50.0,42.0},{70.0,42.0},{70.0, -40.0},{10.0, -40.0},{10.0, -62.0},{18.0, -70.0}}, color = {127,0,127}));
//             connect(c_out,OR.y) annotation(Line(visible = true, points = {{100.0, -70.0},{50.0, -70.0}}, color = {127,0,127}));
//           end FullAdder;
//           model Adder "Generic N Bit Adder"
//             import Modelica.Electrical.Digital;
//             annotation(Documentation(info = "<HTML>
//   
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{68.0,60.0},{88.0,80.0}}, textString = "S", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0,20.0},{40.0,60.0}}, textString = "Adder", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{48.0, -80.0},{88.0, -60.0}}, textString = "Cout", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0, -80.0},{ -50.0, -60.0}}, textString = "Cin", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -88.0,60.0},{ -68.0,80.0}}, textString = "A", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -88.0,20.0},{ -68.0,40.0}}, textString = "B", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 5), experimentSetupOutput(states = false, derivatives = false, inputs = false), DymolaStoredErrors);
//             parameter Integer n = 2;
//             Modelica.Electrical.Digital.Examples.Utilities.FullAdder Adder[n] annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput a[n] annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput b[n] annotation(Placement(visible = true, transformation(origin = { -100.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput c_in annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput s[n] annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput c_out annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(Adder[n].c_out,c_out);
//             connect(c_in,Adder[1].c_in);
//             for i in 1:n loop
//             connect(a[i],Adder[i].a);
//             connect(b[i],Adder[i].b);
//             connect(Adder[i].a,s[i]);
// if i > 1 then
//                           connect(Adder[i - 1].c_out,Adder[i].c_in);
//             end if;
// 
//             end for;
//           end Adder;
//           model Counter3 "3 Bit Counter"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
//   
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -80.0,60.0},{ -40.0,80.0}}, textString = "ENABLE", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0,60.0},{86.0,80.0}}, textString = "Q2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{64.0, -80.0},{86.0, -60.0}}, textString = "Q0", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0,0.0},{60.0,40.0}}, textString = "Counter3", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -80.0, -80.0},{ -40.0, -60.0}}, textString = "COUNT", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{62.0, -12.0},{84.0,8.0}}, textString = "Q1", fontName = "Arial")}));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput enable annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q2 annotation(Placement(visible = true, transformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput count annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.JKFF FF1 annotation(Placement(visible = true, transformation(origin = { -54.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.JKFF FF2 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Examples.Utilities.JKFF FF3 annotation(Placement(visible = true, transformation(origin = {54.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q1 annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q0 annotation(Placement(visible = true, transformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(FF2.q,q1) annotation(Line(visible = true, points = {{20.0,14.0},{24.0,14.0},{24.0, -50.0},{86.0, -50.0},{86.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//             connect(FF1.q,q0) annotation(Line(visible = true, points = {{ -34.0,14.0},{ -30.0,14.0},{ -30.0, -70.0},{100.0, -70.0}}, color = {127,0,127}));
//             connect(FF3.q,q2) annotation(Line(visible = true, points = {{74.0,14.0},{80.0,14.0},{80.0,70.0},{100.0,70.0}}, color = {127,0,127}));
//             connect(FF3.j,enable) annotation(Line(visible = true, points = {{34.0,14.0},{28.0,14.0},{28.0,70.0},{ -100.0,70.0}}, color = {127,0,127}));
//             connect(FF3.k,FF3.j) annotation(Line(visible = true, points = {{34.0, -14.0},{28.0, -14.0},{28.0,14.0},{34.0,14.0}}, color = {127,0,127}));
//             connect(FF2.k,FF2.j) annotation(Line(visible = true, points = {{ -20.0, -14.0},{ -26.0, -14.0},{ -26.0,14.0},{ -20.0,14.0}}, color = {127,0,127}));
//             connect(FF2.j,enable) annotation(Line(visible = true, points = {{ -20.0,14.0},{ -26.0,14.0},{ -26.0,70.0},{ -100.0,70.0}}, color = {127,0,127}));
//             connect(FF2.q,FF3.clk) annotation(Line(visible = true, points = {{20.0,14.0},{24.0,14.0},{24.0,0.0},{34.0,0.0}}, color = {127,0,127}));
//             connect(FF1.q,FF2.clk) annotation(Line(visible = true, points = {{ -34.0,14.0},{ -30.0,14.0},{ -30.0,0.0},{ -20.0,0.0}}, color = {127,0,127}));
//             connect(count,FF1.clk) annotation(Line(visible = true, points = {{ -100.0, -70.0},{ -86.0, -70.0},{ -86.0,0.0},{ -74.0,0.0}}, color = {127,0,127}));
//             connect(enable,FF1.k) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -80.0,70.0},{ -80.0, -14.0},{ -74.0, -14.0}}, color = {127,0,127}));
//             connect(enable,FF1.j) annotation(Line(visible = true, points = {{ -100.0,70.0},{ -80.0,70.0},{ -80.0,14.0},{ -74.0,14.0}}, color = {127,0,127}));
//           end Counter3;
//           model Counter "Generic N Bit Counter"
//             import D = Modelica.Electrical.Digital;
//             import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//             annotation(Documentation(info = "<HTML>
//   
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{90.0,80.0},{110.0, -80.0}})}), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{90.0,80.0},{110.0, -80.0}}),Rectangle(visible = true, fillColor = {255,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -90.0,100.0},{90.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -80.0,60.0},{ -40.0,80.0}}, textString = "ENABLE", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{66.0, -12.0},{88.0,8.0}}, textString = "Q", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0,0.0},{40.0,40.0}}, textString = "Counter", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -80.0, -80.0},{ -40.0, -60.0}}, textString = "COUNT", fontName = "Arial")}));
//             parameter Integer n = 3;
//             parameter Modelica.SIunits.Time delayTime = 0.001;
//             parameter D.Interfaces.Logic q0 = L.'0';
//             Modelica.Electrical.Digital.Interfaces.DigitalInput enable annotation(Placement(visible = true, transformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Digital.Interfaces.DigitalInput count annotation(Placement(visible = true, transformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             D.Examples.Utilities.JKFF FF[n](each delayTime = delayTime, each q0 = q0);
//             Modelica.Electrical.Digital.Interfaces.DigitalOutput q[n] annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -80.0},{10.0,80.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -80.0},{10.0,80.0}}, rotation = 0)));
// 
//           equation 
//             connect(FF[1].q,q[1]);
//             connect(count,FF[1].clk);
//             connect(enable,FF[1].k);
//             connect(enable,FF[1].j);
//             for i in 2:n loop
//             connect(enable,FF[i].j);
//             connect(enable,FF[i].k);
//             connect(FF[i - 1].q,FF[i].clk);
//             connect(FF[i].q,q[i]);
// 
//             end for;
//           end Counter;
//           annotation(Documentation(info = "<html>
// <p>
// This package contains utility components used by package Examples.
// </p>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Utilities;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This package contains examples that demonstrate the usage of the
// components of the Electrical.Digital library.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Examples;
//       package Interfaces "Connectors for Digital electrical components"
//         type Logic = Integer(min = 1, max = 9) "Signal type in package Digital according to the IEEE 1164 STD_ULOGIC type" annotation(Documentation(info = "<html>
//  
// <p>
// A variable of type Logic is an Integer in the range 1-9.
// The Integer values have the following meaning:
// </p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         record LogicValue "Logic values and their coding"
//           extends Modelica.Icons.Enumeration;
//           constant Integer min = 1;
//           constant Integer max = 9;
//           constant Integer 'U' = 1 "Uninitialized";
//           constant Integer 'X' = 2 "Forcing Unknown";
//           constant Integer '0' = 3 "Forcing 0";
//           constant Integer '1' = 4 "Forcing 1";
//           constant Integer 'Z' = 5 "High Impedance";
//           constant Integer 'W' = 6 "Weak    Unknown";
//           constant Integer 'L' = 7 "Weak    0";
//           constant Integer 'H' = 8 "Weak    1";
//           constant Integer '-' = 9 "Don't care";
//           annotation(Documentation(info = "<html>
// <p><b>Code Table:</b></p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// 
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end LogicValue;
//         connector DigitalSignal = Logic "Digital port (both input/output possible)" annotation(Documentation(info = "<html>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector DigitalInput = input DigitalSignal "input DigitalSignal as connector" annotation(defaultComponentName = "x", Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}));
//         connector DigitalOutput = output DigitalSignal "output DigitalSignal as connector" annotation(defaultComponentName = "y", Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100.0,100.0},{100.0,0.0},{ -100.0, -100.0},{ -100.0,100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100.0,100.0},{100.0,0.0},{ -100.0, -100.0},{ -100.0,100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial")}));
//         partial block SISO "Single input, single output"
//           import D = Modelica.Electrical.Digital;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x "Connector of Digital input signal" annotation(Placement(visible = true, transformation(origin = { -60.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -60.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y "Connector of Digital output signal" annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Line(visible = true, points = {{50.0,0.0},{92.0,0.0}}, color = {127,0,127})}), Documentation(info = "<html>
//  
// </html>"));
//         end SISO;
//         partial block MISO "Multiple input - single output"
//           import D = Modelica.Electrical.Digital;
//           parameter Integer n(final min = 2) = 2 "Number of inputs";
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] "Connector of Digital input signal vector" annotation(Placement(visible = true, transformation(origin = { -60.0,0.0}, extent = {{ -10.0, -80.0},{10.0,80.0}}, rotation = 0), iconTransformation(origin = { -60.0,0.0}, extent = {{ -10.0, -80.0},{10.0,80.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y "Connector of Digital output signal" annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -50,100},{50, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {255,255,255}),Line(points = {{50,0},{90,0}}, color = {127,0,127})}), Diagram, Documentation(info = "<html>
//  
// </html>"));
//         end MISO;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// This package contains interface definitions
// (connectors) digital electrical components.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Interfaces;
//       package Tables "Truth tables for all components of package Digital"
//         import D = Modelica.Electrical.Digital;
//         import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//         constant D.Interfaces.Logic AndTable[L.max,L.max] = [L.'U',L.'U',L.'0',L.'U',L.'U',L.'U',L.'0',L.'U',L.'U';L.'U',L.'X',L.'0',L.'X',L.'X',L.'X',L.'0',L.'X',L.'X';L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'U',L.'X',L.'0',L.'X',L.'X',L.'X',L.'0',L.'X',L.'X';L.'U',L.'X',L.'0',L.'X',L.'X',L.'X',L.'0',L.'X',L.'X';L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0',L.'0';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'U',L.'X',L.'0',L.'X',L.'X',L.'X',L.'0',L.'X',L.'X'] "9-value logic for 'and'";
//         constant D.Interfaces.Logic OrTable[L.max,L.max] = [L.'U',L.'U',L.'U',L.'1',L.'U',L.'U',L.'U',L.'1',L.'U';L.'U',L.'X',L.'X',L.'1',L.'X',L.'X',L.'X',L.'1',L.'X';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1';L.'U',L.'X',L.'X',L.'1',L.'X',L.'X',L.'X',L.'1',L.'X';L.'U',L.'X',L.'X',L.'1',L.'X',L.'X',L.'X',L.'1',L.'X';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1',L.'1';L.'U',L.'X',L.'X',L.'1',L.'X',L.'X',L.'X',L.'1',L.'X'] "9-value logic for 'or'";
//         constant D.Interfaces.Logic NotTable[L.max] = {L.'U',L.'X',L.'1',L.'0',L.'X',L.'X',L.'1',L.'0',L.'X'} "9-value logic for 'not'";
//         constant D.Interfaces.Logic XorTable[L.max,L.max] = [L.'U',L.'U',L.'U',L.'U',L.'U',L.'U',L.'U',L.'U',L.'U';L.'U',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'U',L.'X',L.'1',L.'0',L.'X',L.'X',L.'1',L.'0',L.'X';L.'U',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X';L.'U',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X';L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X';L.'U',L.'X',L.'1',L.'0',L.'X',L.'X',L.'1',L.'0',L.'X';L.'U',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X',L.'X'] "9-value logic for 'xor'";
//         constant D.Interfaces.Logic X01Table[L.max] = {L.'X',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X'};
//         constant D.Interfaces.Logic X01ZTable[L.max] = {L.'X',L.'X',L.'0',L.'1',L.'Z',L.'X',L.'0',L.'1',L.'Z'};
//         constant D.Interfaces.Logic UX01Table[L.max] = {L.'U',L.'X',L.'0',L.'1',L.'X',L.'X',L.'0',L.'1',L.'X'};
//         constant Integer DelayTable[9,9] = [0,0, -1,1,0,0, -1,1,0;0,0, -1,1,0,0, -1,1,0;1,1,0,1,1,1,0,1,1; -1, -1, -1,0, -1, -1, -1,0, -1;0,0, -1,1,0,0, -1,1,0;0,0, -1,1,0,0, -1,1,0;1,1,0,1,1,1,0,1,1; -1, -1, -1,0, -1, -1, -1,0, -1;0,0, -1,1,0,0, -1,1,0];
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Tables;
//       package Delay "Transport and inertial delay blocks"
//         partial block DelayParams "Definition of delay parameters"
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter Modelica.SIunits.Time tLH = 0 "rise inertial delay";
//           parameter Modelica.SIunits.Time tHL = 0 "fall inertial delay";
//           parameter Digital.Interfaces.Logic y0 = L.'U' "initial value of output";
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         algorithm 
//           annotation(Documentation(info = "<html>
//    
// </html>"));
//         end DelayParams;
//         model TransportDelay "Transport delay with initial parameter"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.SISO;
//           parameter Modelica.SIunits.Time delayTime = 0 "delay time";
//           parameter D.Interfaces.Logic y0 = L.'U' "initial value of output";
//           annotation(Documentation(info = "<HTML>
// <P>
// Provide the input as output exactly delayed by <i>Tdel</i>.
// If time less than <i>Tdel</i> the initial value <i>initout</i> holds.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 11, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Polygon(visible = true, points = {{ -6.0,60.0},{ -16.0,40.0},{4.0,40.0},{ -6.0,60.0}}),Line(visible = true, points = {{0.0,60.0},{20.0,60.0}}),Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0, -40.0},{50.0, -20.0}}, textString = "Transport", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0, -60.0},{50.0, -40.0}}, textString = "Delay", fontName = "Arial")}));
//         protected 
//           D.Interfaces.Logic x_delayed;
//         algorithm 
//           x_delayed:=integer(delay(x, delayTime));
//           y:=if delayTime > 0 then if time >= delayTime then x_delayed else y0 else x;
//         end TransportDelay;
//         block InertialDelay "Inertial delay with initial parameter"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.SISO;
//           parameter Modelica.SIunits.Time delayTime = 0 "Minimum time to hold value";
//           parameter D.Interfaces.Logic y0 = L.'U' "Initial value of output y";
//           annotation(Documentation(info = "<HTML>
// <P>
// Provides the input as output delayed by <i>Tdel</i> if the input holds its value for a longer time than <i>Tdel</i>.
// If time is less than <i>Tdel</i> the initial value <i>initout</i> holds.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 12, 2003   </i>
//        by Christoph Clauss<br>
//        reviced</li>
// <li><i>March 19, 2003</i>
//        by Martin Otter<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Diagram, Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{152, -160},{ -148, -100}}, textString = "%name", fillColor = {0,0,255}),Rectangle(extent = {{ -50,100},{50, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {213,170,255}),Polygon(points = {{ -6,60},{ -16,40},{4,40},{ -6,60}}, lineColor = {0,0,0}),Line(points = {{10,60},{10,40}}, color = {0,0,0}),Line(points = {{0,60},{20,60}}, color = {0,0,0}),Text(lineColor = {0,0,255}, extent = {{ -50, -40},{50, -20}}, fillColor = {0,0,0}, lineThickness = 0.5, textString = "Inertial"),Text(lineColor = {0,0,255}, extent = {{ -50, -60},{50, -40}}, fillColor = {0,0,0}, lineThickness = 0.5, textString = "Delay")}));
//         protected 
//           D.Interfaces.Logic y_auxiliary(start = y0, fixed = true);
//           D.Interfaces.Logic x_old(start = y0, fixed = true);
//           discrete Modelica.SIunits.Time t_next(start = delayTime, fixed = true);
//         algorithm 
//           when delayTime > 0 and change(x) then
//                       x_old:=x;
//             t_next:=time + delayTime;
//           elsewhen time >= t_next then
//             y_auxiliary:=x;
// 
//           end when;
//           y:=if delayTime > 0 then y_auxiliary else x;
//         end InertialDelay;
//         model InertialDelaySensitive "Provide the input as output if it holds its value for a specific amount of time"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.SISO;
//           parameter Modelica.SIunits.Time tLH = 0 "rise inertial delay";
//           parameter Modelica.SIunits.Time tHL = 0 "fall inertial delay";
//           parameter D.Interfaces.Logic y0 = L.'U' "initial value of output";
//           annotation(Documentation(info = "<HTML>
// <P>
// Provides the input as output delayed by <i>Tdel</i> if the input holds its value for a longer time than <i>Tdel</i>.
// If the time is less than <i>Tdel</i> the initial value <i>initout</i> holds.<br>
// The delay <i>Tdel</i> depends on the values of the signal change. To calculate <i>Tdel</i>, the delaymap specified in
// Digital.Tables is used. If the corresponding value is 1, then <i>tLH</i> is used, if it is -1, then <i>tHL</i>
// is used, if it is zero, the input is not delayed.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>January 13, 2005  </i> improved when-conditions and declaration of delayTable
//        by Dynasim<br>
//        </li>
// <li><i>September 15, 2004  </i> color changed, names changed
//        by Christoph Clauss<br>
//        </li>
// <li><i>May 12, 2004  </i> test <i>if Tdel=0</i> replaced
//        by Christoph Clauss<br>
//        </li>
// <li><i>February 5, 2004 </i> handling of <i>tHL=0</i> or <i>tLH=0</i> revised
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 12, 2003   </i>
//        by Christoph Clauss<br>
//        initially modelled</li>
// </HTML>"), Diagram, Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0, -40.0},{50.0, -20.0}}, textString = "Inertial", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0, -60.0},{50.0, -40.0}}, textString = "Delay", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0, -80.0},{50.0, -60.0}}, textString = "sensitive", fontName = "Arial"),Polygon(visible = true, points = {{ -6.0,60.0},{ -16.0,40.0},{4.0,40.0},{ -6.0,60.0}}),Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}),Line(visible = true, points = {{0.0,60.0},{20.0,60.0}})}));
//         protected 
//           Integer delayTable[:,:] = D.Tables.DelayTable "specification of delay according to signal change";
//           Modelica.SIunits.Time delayTime;
//           D.Interfaces.Logic y_auxiliary(start = y0, fixed = true);
//           D.Interfaces.Logic x_old(start = y0, fixed = true);
//           Integer lh;
//           discrete Modelica.SIunits.Time t_next;
//         algorithm 
//           when {initial(),(tLH > 0 or tHL > 0) and change(x) and not initial()} then
//                       x_old:=if initial() or pre(x) == 0 then y0 else pre(x);
//             lh:=delayTable[x_old,x];
//             delayTime:=if lh > 0 then tLH else if lh < 0 then tHL else 0;
//             t_next:=time + delayTime;
//             if lh == 0 or abs(delayTime) < Modelica.Constants.small then 
//                         y_auxiliary:=x;
// 
//             else 
//             end if;
//           elsewhen time >= t_next then
//             y_auxiliary:=x;
// 
//           end when;
//           y:=if tLH > 0 or tHL > 0 then y_auxiliary else x;
//         end InertialDelaySensitive;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Delay;
//       package Basic "Basic logic blocks without delays"
//         model Not "Not Logic"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.SISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// Not with 1 input value, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 14, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary(start = L.'0');
// 
//         equation 
//           auxiliary = D.Tables.NotTable[x];
//           y = pre(auxiliary);
//         end Not;
//         model And "And logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// And with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by  Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "&", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial")}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.AndTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(auxiliary[n]);
//         end And;
//         model Nand "Nand logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// Nand with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by  Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "&", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.AndTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(D.Tables.NotTable[auxiliary[n]]);
//         end Nand;
//         model Or "Or logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// Or with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by  Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = ">=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial")}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.OrTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(auxiliary[n]);
//         end Or;
//         model Nor "Nor logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// Nor with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = ">=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.OrTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(D.Tables.NotTable[auxiliary[n]]);
//         end Nor;
//         model Xor "Xor logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// Xor with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial")}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.XorTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(auxiliary[n]);
//         end Xor;
//         model Xnor "Xnor logic with multiple input and one output"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           extends D.Interfaces.MISO;
//           annotation(Documentation(info = "<HTML>
// <P>
// XNor with n input values, without delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial")}), Diagram);
//         protected 
//           D.Interfaces.Logic auxiliary[n](each start = L.'U');
// 
//         equation 
//           auxiliary[1] = x[1];
//           for i in 1:n - 1 loop
//           auxiliary[i + 1] = D.Tables.XorTable[auxiliary[i],x[i + 1]];
// 
//           end for;
//           y = pre(D.Tables.NotTable[auxiliary[n]]);
//         end Xnor;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Basic;
//       package Gates "Logic gates including delays"
//         model InvGate "InvGate with 1 input value, composed by Not and sensitive intertial delay"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.SISO;
//           Modelica.Electrical.Digital.Basic.Not G1 annotation(Placement(visible = true, transformation(origin = { -40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// InvGate with 1 input value, composed by Not and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 14, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{152.0, -160.0},{ -148.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -18.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}));
// 
//         equation 
//           connect(G2.y,y) annotation(Line(visible = true, origin = {80.0,0.0}, points = {{ -20.0,0.0},{20.0,0.0}}, color = {127,0,127}));
//           connect(G1.x,x) annotation(Line(visible = true, points = {{ -52.0,0.0},{ -60.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{ -20.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end InvGate;
//         model AndGate "AndGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Interfaces.MISO;
//           extends D.Delay.DelayParams;
//           Modelica.Electrical.Digital.Basic.And G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// AndGate with n input values, composed by And and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "&", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           connect(y,G2.y) annotation(Line(visible = true, points = {{100.0,0.0},{60.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, origin = { -46.0,0.0}, points = {{ -14.0,0.0},{14.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end AndGate;
//         model NandGate "NandGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.MISO;
//           annotation(extent = [0, -20;40,20], Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0,80.0}}, textString = "&", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}), Documentation(revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>", info = "<HTML>
// <P>
// NandGate with n input values, composed by Nand and sensitive intertial delay.
// </P>
// </HTML>"));
//           annotation(Documentation(info = "<HTML>
// <P>
// NandGate with n input values, composed by Nand and sensitive intertial delay.
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        realized.</li>
// </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -40,80},{40,40}}, fillColor = {0,0,0}, lineThickness = 0.5, textString = "&"),Text(lineColor = {0,0,255}, extent = {{ -20, -40},{20, -80}}, fillColor = {0,0,0}, lineThickness = 0.5, textString = "Gate"),Ellipse(extent = {{60, -10},{40,10}}, lineColor = {0,0,0}, lineThickness = 0.5)}), Diagram, DymolaStoredErrors);
//           Modelica.Electrical.Digital.Basic.Nand G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
// 
//         equation 
//           connect(G2.y,y) annotation(Line(visible = true, points = {{60.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, origin = { -46.0,0.0}, points = {{ -14.0,0.0},{14.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end NandGate;
//         model OrGate "OrGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.MISO;
//           Modelica.Electrical.Digital.Basic.Or G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// OrGate with n input values, composed by Or and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = ">=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           connect(y,G2.y) annotation(Line(visible = true, points = {{100.0,0.0},{60.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, origin = { -46.0,0.0}, points = {{ -14.0,0.0},{14.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end OrGate;
//         model NorGate "NorGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.MISO;
//           Modelica.Electrical.Digital.Basic.Nor G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// NorGate with n input values, composed by Nor and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = ">=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{50.0,6.0},{62.0, -6.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           connect(y,G2.y) annotation(Line(visible = true, points = {{100.0,0.0},{60.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, origin = { -46.0,0.0}, points = {{ -14.0,0.0},{14.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end NorGate;
//         model XorGate "XorGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.MISO;
//           Modelica.Electrical.Digital.Basic.Xor G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// XorGate with n input values, composed by Xor and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "=1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           connect(G2.y,y) annotation(Line(visible = true, points = {{60.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, origin = { -46.0,0.0}, points = {{ -14.0,0.0},{14.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//         end XorGate;
//         model XnorGate "XnorGate with multiple input"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.MISO;
//           Modelica.Electrical.Digital.Basic.Xnor G1(n = n) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G2(tLH = tLH, tHL = tHL, y0 = y0) annotation(Placement(visible = true, transformation(origin = {40.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// XNorGate with n input values, composed by XNor and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004</i> vector approach used for all fixed numbers of inputs
//        by Christoph Clauss<br>
//        </li>
// <li><i>October 22, 2003</i>
//        by Liane Jacobi<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0,80.0}}, textString = "=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), DymolaStoredErrors);
// 
//         equation 
//           connect(G1.y,G2.x) annotation(Line(visible = true, points = {{0.0,0.0},{28.0,0.0}}, color = {127,0,127}));
//           connect(G2.y,y) annotation(Line(visible = true, points = {{60.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//           connect(x,G1.x) annotation(Line(visible = true, points = {{ -60.0,0.0},{ -32.0,0.0}}, color = {127,0,127}));
//         end XnorGate;
//         model BufGate "BufGate with 1 input value, composed by Not and sensitive intertial delay"
//           import D = Modelica.Electrical.Digital;
//           extends D.Delay.DelayParams;
//           extends D.Interfaces.SISO;
//           Modelica.Electrical.Digital.Delay.InertialDelaySensitive G1(tLH = tLH, tHL = tHL) annotation(Placement(visible = true, transformation(origin = { -10.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// BufGate with 1 input value, composed by Not and sensitive intertial delay.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>September 21, 2004</i>
//        by Andre Schneider<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{152.0, -160.0},{ -148.0, -100.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {213,170,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -18.0, -100.0},{20.0, -60.0}}, textString = "Gate", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "1", fontName = "Arial")}));
// 
//         equation 
//           connect(G1.x,x) annotation(Line(visible = true, points = {{ -22.0,0.0},{ -60.0,0.0}}, color = {127,0,127}));
//           connect(G1.y,y) annotation(Line(visible = true, points = {{10.0,0.0},{100.0,0.0}}, color = {127,0,127}));
//         end BufGate;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Gates;
//       package Sources "Time-dependend digital signal sources"
//         block Set "Digital Set Source"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter D.Interfaces.Logic x = L.'1' "Logic value to be set";
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// Sets a nine valued digital signal, which is specified by the <i>setval</i> parameter.
// </P>
// <P>
// To specify <i>setval</i>, the integer code has to be used.
// </P>
// <p><b>Code Table</b></p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// 
// <P>
// If the logic values are imported by <br><b> import L = Modelica.Electrical.Digital.Interfaces.LogicValue; </b> <br>
// they can be used to specify the parameter, e.g. <b>L.'0'</b> for forcing 0.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 20, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {213,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{ -50.0,40.0},{50.0,80.0}}, textString = "SET", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{50.0,0.0},{90.0,0.0}}, color = {127,0,127})}));
//         algorithm 
//           assert(x >= L.min and x <= L.max, "Parameter is no logic value");
//           y:=x;
//         end Set;
//         block Step "Digital Step Source"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter D.Interfaces.Logic before = L.'0' "Logic value before step";
//           parameter D.Interfaces.Logic after = L.'1' "Logic value after step";
//           parameter Real stepTime = 1 "step time";
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// The step source output signal steps from the value <i>before</i> to the value <i>after</i>
// at the time <i>stepTime</i>.
// </P>
// <P>
// To specify the logic value parameters, the integer code has to be used.
// </P>
// <p><b>Code Table</b></p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// <P>
// If the logic values are imported by <br><b> import L = Modelica.Electrical.Digital.Interfaces.LogicValue; </b> <br>
// they can be used to specify the parameter, e.g. <b>L.'0'</b> for forcing 0.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 20, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {213,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -30.0,40.0},{0.0,40.0},{0.0,80.0},{30.0,80.0}}),Line(visible = true, points = {{50.0,0.0},{90.0,0.0}}, color = {127,0,127})}), Diagram);
//         algorithm 
//           assert(before >= L.min and before <= L.max, "Parameter is no logic value");
//           assert(after >= L.min and after <= L.max, "Parameter is no logic value");
//           when initial() then
//                       y:=before;
//           
//           end when;
//           if stepTime <= time then 
//                     y:=after;
// 
//           else           y:=before;
// 
//           end if;
//         end Step;
//         block Table "Digital Tabular Source"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter D.Interfaces.Logic x[:] = {1};
//           parameter Real t[size(x, 1)] = {1};
//           parameter D.Interfaces.Logic y0 = L.'U';
//           final parameter Integer n = size(x, 1);
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// The table source output signal <i>y</i> steps to the values of the  <i>x</i> table at the corresponding
// timepoints in the <i>t</i> table. <br>The initial value is specified by <i>y0</i>.
// </P>
// <P>
// To specify the logic value parameters, the integer code has to be used.
// </P>
// <p><b>Code Table</b></p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// <P>
// If the logic values are imported by <br><b> import L = Modelica.Electrical.Digital.Interfaces.LogicValue; </b> <br>
// they can be used to specify the parameter, e.g. <b>L.'0'</b> for forcing 0.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>August 20, 2003</i>
//        by Teresa Schlegel<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {213,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{50.0,0.0},{90.0,0.0}}, color = {127,0,127}),Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -30.0,80.0},{32.0,70.0}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -30.0,70.0},{32.0,40.0}}),Line(visible = true, points = {{0.0,80.0},{0.0,40.0}}),Line(visible = true, points = {{ -30.0,60.0},{32.0,60.0}}),Line(visible = true, points = {{ -30.0,50.0},{32.0,50.0}})}), Diagram);
//         algorithm 
//           if initial() then 
//                     assert(y0 >= L.min and y0 <= L.max, "Parameter y0 is not of type Logic");
//           assert(n > 0, "Invalid size of table (n < 1)");
//           for i in 1:n loop
//                       assert(x[i] >= L.min and x[i] <= L.max, "Table element is not of type Logic");
// 
//           end for;
// 
//           else 
//           end if;
//           y:=y0;
//           for i in 1:n loop
//                       if time >= t[i] then 
//                         y:=x[i];
// 
//             else 
//             end if;
// 
//           end for;
//         end Table;
//         model Pulse "Digital Pulse Source"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Widths of pulses in % of periods";
//           parameter Modelica.SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Modelica.SIunits.Time startTime = 0 "Output = offset for time < startTime";
//           parameter D.Interfaces.Logic pulse = L.'0';
//           parameter D.Interfaces.Logic quiet = L.'1';
//           Modelica.SIunits.Time T0(final start = startTime) "Start time of current period";
//           parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//           Integer np(start = 0);
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// The pulse source forms pulses between the  <i>quiet</i> value and the <i>pulse</i> value.
// The pulse length <i>width</i> is specified in percent of the period length <i>period</i>.
// The number of periods is specified by <i>nperiod</i>. If <i>nperiod</i> is less than zero,
// the number of periods is unlimited.
// </P>
// <P>
// To specify the logic value parameters, the integer code has to be used.
// </P>
// <p><b>Code Table</b></p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Logic value</b></td>
//       <td><b>Integer code</b></td>
//       <td><b>Meaning</b></td>
//   </tr>
//                          
//   <tr><td>'U'</td> <td>1</td> <td>Uninitialized</td></tr>
//   <tr><td>'X'</td> <td>2</td> <td>Forcing Unknown</td></tr>
//   <tr><td>'0'</td> <td>3</td> <td>Forcing 0</td></tr>
//   <tr><td>'1'</td> <td>4</td> <td>Forcing 1</td></tr>
//   <tr><td>'Z'</td> <td>5</td> <td>High Impedance</td></tr>
//   <tr><td>'W'</td> <td>6</td> <td>Weak Unknown</td></tr>
//   <tr><td>'L'</td> <td>7</td> <td>Weak 0</td></tr>
//   <tr><td>'H'</td> <td>8</td> <td>Weak 1</td></tr>
//   <tr><td>'-'</td> <td>9</td> <td>Don't care</td></tr>
// </table>
// <P>
// If the logic values are imported by <br><b> import L = Modelica.Electrical.Digital.Interfaces.LogicValue; </b> <br>
// they can be used to specify the parameter, e.g. <b>L.'0'</b> for forcing 0.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>September 2, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {213,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{50.0,0.0},{90.0,0.0}}, color = {127,0,127}),Line(visible = true, points = {{ -36.0,40.0},{ -30.0,40.0},{ -30.0,40.0},{ -18.0,40.0},{ -18.0,40.0},{ -14.0,40.0},{ -14.0,80.0},{14.0,80.0},{14.0,40.0},{14.0,40.0},{14.0,40.0},{28.0,40.0},{30.0,40.0},{36.0,40.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial")}));
//         algorithm 
//           if nperiod == 0 then 
//                     y:=quiet;
//           elseif nperiod >= np or nperiod < 0 then
//             when sample(startTime, period) then
//                           T0:=time;
//               if nperiod > 0 then 
//                             np:=np + 1;
// 
//               else 
//               end if;
//             
//             end when;
//             y:=if time < startTime or time >= T0 + (width * period) / 100 or not (nperiod >= np or nperiod < 0) then quiet else pulse;
// 
// 
//           else           y:=quiet;
// 
//           end if;
//         end Pulse;
//         model Clock "Digital Clock Source"
//           import D = Modelica.Electrical.Digital;
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           parameter Modelica.SIunits.Time startTime = 0 "Output = offset for time < startTime";
//           parameter Modelica.SIunits.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulses in % of period";
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y "Connector of Digital output signal" annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// The clock source forms pulses between the  <i>'0'</i> value (forcing 0) and the <i>'1'</i> value (forcing 1).
// The pulse length <i>width</i> is specified in percent of the period length <i>period</i>.
// The number of periods is unlimited. The first pulse starts at startTime.
// </P>
// <P> The clock source is a special but often used variant of the pulse source.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>   </i>
//        by ...<br>
//        </li>
// <li><i>September 18, 2004</i>
//        by Andre Schneider<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {213,255,170}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -50.0,100.0},{50.0, -100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -160.0},{152.0, -100.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{50.0,0.0},{90.0,0.0}}, color = {127,0,127}),Line(visible = true, points = {{ -36.0,40.0},{ -30.0,40.0},{ -30.0,80.0},{ -18.0,80.0},{ -18.0,40.0},{ -6.0,40.0},{ -6.0,80.0},{6.0,80.0},{6.0,40.0},{18.0,40.0},{18.0,80.0},{30.0,80.0},{30.0,40.0},{36.0,40.0}})}), DymolaStoredErrors);
//         protected 
//           Modelica.SIunits.Time t_i(final start = startTime) "Start time of current period";
//           Modelica.SIunits.Time t_width = (period * width) / 100;
//         algorithm 
//           when sample(startTime, period) then
//                       t_i:=time;
//           
//           end when;
//           y:=if time < startTime or time >= t_i + t_width then L.'0' else L.'1';
//         end Clock;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Sources;
//       package Converters "Converters between 2-,3-,4- and 9-valued logic"
//         block LogicToXO1 "Conversion to XO1"
//           import D = Modelica.Electrical.Digital;
//           import T = Modelica.Electrical.Digital.Tables;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Integer n(final min = 1) = 1 "signal width";
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a nine valued digital input into a X01 digital output without
// any delay according to IEEE 1164 To_X01 function.
// </P>
// <p><b>Conversion Table:</b></p>
// <pre>
//                           input                  output
//                           'U' (coded by 1)       'X'  (coded by 2)
//                           'X' (coded by 2)       'X'  (coded by 2)
//                           '0' (coded by 3)       '0'  (coded by 3)
//                           '1' (coded by 4)       '1'  (coded by 4)
//                           'Z' (coded by 5)       'X'  (coded by 2)
//                           'W' (coded by 6)       'X'  (coded by 2)
//                           'L' (coded by 7)       '0'  (coded by 3)
//                           'H' (coded by 8)       '1'  (coded by 4)
//                           '-' (coded by 9)       'X'  (coded by 2)
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss name converted from cvt_to_x01 into LogicToX01<br>
//        </li>
// <li><i>November 5, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0}}),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, points = {{ -40.0, -40.0},{40.0, -40.0},{40.0,40.0},{ -40.0, -40.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{0.0, -40.0},{40.0, -20.0}}, textString = "X01", fontName = "Arial"),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram);
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=T.X01Table[x[i]];
// 
//           end for;
//         end LogicToXO1;
//         block LogicToXO1Z "Conversion to XO1Z"
//           import D = Modelica.Electrical.Digital;
//           import T = Modelica.Electrical.Digital.Tables;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Integer n(final min = 1) = 1 "signal width";
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a nine valued digital input into a X01Z digital output without
// any delay according to IEEE 1164 To_X01Z function.
// </P>
// <p><b>Conversion Table:</b></p>
// <pre>
//                           input                  output
//                           'U' (coded by 1)       'X'  (coded by 2)
//                           'X' (coded by 2)       'X'  (coded by 2)
//                           '0' (coded by 3)       '0'  (coded by 3)
//                           '1' (coded by 4)       '1'  (coded by 4)
//                           'Z' (coded by 5)       'Z'  (coded by 5)
//                           'W' (coded by 6)       'X'  (coded by 2)
//                           'L' (coded by 7)       '0'  (coded by 3)
//                           'H' (coded by 8)       '1'  (coded by 4)
//                           '-' (coded by 9)       'X'  (coded by 2)
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss name converted from cvt_to_x01z into LogicToX01Z<br>
//        </li>
// <li><i>November 5, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0}}),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, points = {{ -40.0, -40.0},{40.0, -40.0},{40.0,40.0},{ -40.0, -40.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{0.0, -40.0},{40.0, -20.0}}, textString = "X01Z", fontName = "Arial"),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram);
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=T.X01ZTable[x[i]];
// 
//           end for;
//         end LogicToXO1Z;
//         block LogicToUX01 "Conversion to UXO1"
//           import D = Modelica.Electrical.Digital;
//           import T = Modelica.Electrical.Digital.Tables;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Integer n(final min = 1) = 1 "signal width";
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a nine valued digital input into a UX01 digital output without
// any delay according to IEEE 1164 To_UX01 function.
// </P>
// <p><b>Conversion Table:</b></p>
// <pre>
//                           input                  output
//                           'U' (coded by 1)       'U'  (coded by 1)
//                           'X' (coded by 2)       'X'  (coded by 2)
//                           '0' (coded by 3)       '0'  (coded by 3)
//                           '1' (coded by 4)       '1'  (coded by 4)
//                           'Z' (coded by 5)       'X'  (coded by 2)
//                           'W' (coded by 6)       'X'  (coded by 2)
//                           'L' (coded by 7)       '0'  (coded by 3)
//                           'H' (coded by 8)       '1'  (coded by 4)
//                           '-' (coded by 9)       'X'  (coded by 2)
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss name converted from cvt_to_ux01 into LogicToUX01<br>
//        </li>
// <li><i>November 5, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0}}),Polygon(visible = true, lineColor = {127,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, points = {{ -40.0, -40.0},{40.0, -40.0},{40.0,40.0},{ -40.0, -40.0}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 0.5, extent = {{0.0, -40.0},{40.0, -20.0}}, textString = "UX01", fontName = "Arial"),Rectangle(visible = true, origin = {0.0,0.0}, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram);
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=T.UX01Table[x[i]];
// 
//           end for;
//         end LogicToUX01;
//         block BooleanToLogic "Boolean to Logic converter"
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           Modelica.Blocks.Interfaces.BooleanInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a Boolean input into a digital output without any delay according to:
// </P>
// <pre>
//                           input      output
//                           true       '1'  (coded by 4)
//                           false      '0'  (coded by 3)
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss colors changed<br>
//        </li>
// <li><i>November 4, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), extent = [ -60, -10; -40,10], DymolaStoredErrors, Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{40.0,40.0},{40.0, -40.0},{ -40.0, -40.0}}),Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0},{ -40.0,40.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(extent = [40, -10;60,10]);
//           annotation(Diagram);
//           parameter Integer n(final min = 1) = 1 "signal width";
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=if x[i] then L.'1' else L.'0';
// 
//           end for;
//         end BooleanToLogic;
//         block LogicToBoolean "Logic to Boolean converter"
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a digital input into a Boolean output without any delay according to:
// </P>
// <pre>
//                           input                 output
//                           'U'  (coded by 1)     false
//                           'X'  (coded by 2)     false
//                           '0'  (coded by 3)     false
//                           '1'  (coded by 4)     true
//                           'Z'  (coded by 5)     false
//                           'W'  (coded by 6)     false
//                           'L'  (coded by 7)     false
//                           'H'  (coded by 8)     true
//                           '-'  (coded by 9)     false
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss colors changed<br>
//        </li>
// <li><i>November 4, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0},{ -40.0,40.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,255}, fillColor = {255,0,255}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{40.0, -40.0},{40.0,40.0},{ -40.0, -40.0}}),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter Integer n(final min = 1) = 1 "signal width";
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=if x[i] == 4 or x[i] == 8 then true else false;
// 
//           end for;
//         end LogicToBoolean;
//         block RealToLogic "Real to Logic converter"
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           Modelica.Blocks.Interfaces.RealInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a real input into a digital output without any delay according to:
// </P>
// <pre>
//                                  condition            output
//       first check:               input greater upp    lupp
//       second check:              input larger low     llow
//                                  else                 lmid
// </pre>
// <P>
// If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss colors changed<br>
//        </li>
// <li><i>November 5, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), extent = [ -60, -10; -40,10], DymolaStoredErrors, Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{40.0,40.0},{40.0, -40.0},{ -40.0, -40.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0},{ -40.0,40.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -152.0, -100.0},{148.0, -40.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Digital.Interfaces.DigitalOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(extent = [40, -10;60,10]);
//           annotation(Diagram);
//           parameter Integer n(final min = 1) = 1 "signal width";
//           parameter Real upper_limit = 1 "upper limit";
//           parameter Real lower_limit = 0 "lower limit";
//           parameter Digital.Interfaces.Logic upper_value = L.'1' "output if input > upper_limit";
//           parameter Digital.Interfaces.Logic lower_value = L.'0' "output if input < lower_limit";
//           parameter Digital.Interfaces.Logic middle_value = L.'X' "output else";
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=if x[i] > upper_limit then upper_value else if x[i] < lower_limit then lower_value else middle_value;
// 
//           end for;
//         end RealToLogic;
//         block LogicToReal "Logic to Real converter"
//           import L = Modelica.Electrical.Digital.Interfaces.LogicValue;
//           Modelica.Electrical.Digital.Interfaces.DigitalInput x[n] annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y[n] annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {50.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <P>
// Conversion of a digital input into a Real output without any delay according to:
// </P>
// <pre>
//                           input                 output
//                           'U'  (coded by 1)     val_U
//                           'X'  (coded by 2)     val_X
//                           '0'  (coded by 3)     val_0
//                           '1'  (coded by 4)     val_1
//                           'Z'  (coded by 5)     val_Z
//                           'W'  (coded by 6)     val_W
//                           'L'  (coded by 7)     val_L
//                           'H'  (coded by 8)     val_H
//                           '-'  (coded by 9)     val_m
// </pre>
// <P>
// The values val... are given by parameters.</P>
// <P>If the signal width is greater than 1 this conversion is done for each signal.
// </P>
// </HTML>
// ", revisions = "<HTML>
// <ul>
// <li><i>September 15, 2004   </i>
//        by Christoph Clauss colors changed<br>
//        </li>
// <li><i>November 5, 2003</i>
//        by Christoph Clauss<br>
//        initially modelled.</li>
// </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {127,0,127}, fillColor = {127,0,127}, fillPattern = FillPattern.Solid, points = {{ -40.0,40.0},{40.0,40.0},{ -40.0, -40.0},{ -40.0,40.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -40.0, -40.0},{40.0, -40.0},{40.0,40.0},{ -40.0, -40.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -148.0, -100.0},{152.0, -40.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, lineThickness = 0.5, extent = {{ -40.0,40.0},{40.0, -40.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter Integer n(final min = 1) = 1 "signal width";
//           parameter Real value_U = 0.5 "value for digital U (uninitialized)";
//           parameter Real value_X = 0.5 "value for digital X (Forcing Unknown)";
//           parameter Real value_0 = 0 "value for digital 0   (Forcing 0)";
//           parameter Real value_1 = 1 "value for digital 1 (Forcing 1)";
//           parameter Real value_Z = 0.5 "value for digital Z (High Impedance)";
//           parameter Real value_W = 0.5 "value for digital W (Weak    Unknown)";
//           parameter Real value_L = 0 "value for digital L (Weak    0)";
//           parameter Real value_H = 1 "value for digital H (Weak    1)";
//           parameter Real value_m = 0.5 "value for digital m (Dont care)";
//         algorithm 
//           for i in 1:n loop
//                       y[i]:=if x[i] == L.'U' then value_U else if x[i] == L.'X' then value_X else if x[i] == L.'0' then value_0 else if x[i] == L.'1' then value_1 else if x[i] == L.'Z' then value_Z else if x[i] == L.'W' then value_W else if x[i] == L.'L' then value_L else if x[i] == L.'H' then value_H else value_m;
// 
//           end for;
//         end LogicToReal;
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{80.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100.0,50.0},{ -80.0,70.0},{100.0,70.0},{80.0,50.0},{ -100.0,50.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100.0,70.0},{100.0, -80.0},{80.0, -100.0},{80.0,50.0},{100.0,70.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85.0, -85.0},{65.0,35.0}}, textString = "Library", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -120.0,73.0},{120.0,122.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Converters;
//     end Digital;
//     package Machines "Library for electric machines"
//       extends Modelica.Icons.Library2;
//       annotation(version = "1.7.2", versionDate = "2006-02-10", Settings(NewStateSelection = true, Evaluate = true), preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains components to model electrical machines:
// <ul>
// <li>Examples: test examples</li>
// <li>BasicMachines: basic machine models</li>
// <li>Sensors: sensors, usefull when modelling machines</li>
// <li>SpacePhasors: an independent library for using space phasors</li>
// <li>Interfaces: Space phasor connector and partial machine models</li>
// </ul>
// </p>
// <p>
// <b>Limitations and assumptions:</b>
// <ul>
// <li>number of phases (of induction machines) is limited to 3, therefore definition as a constant m=3</li>
// <li>phase symmetric windings as well as symmetry of the whole machine structure</li>
// <li>all values are used in physical units, no scaling to p.u. is done</li>
// <li>only basic harmonics (in space) are taken into account</li>
// <li>waveform (with respect to time) of voltages and currents is not restricted</li>
// <li>constant parameters, i.e. no saturation, no skin effect</li>
// <li>no iron losses, eddy currents, friction losses;<br>
//     only ohmic losses in stator and rotor winding</li>
// </ul>
// You may have a look at a short summary of space phasor theory at <a href=\"http://www.haumer.at/refimg/SpacePhasors.pdf\">http://www.haumer.at/refimg/SpacePhasors.pdf</a>
// </p>
// <p>
// <b>Further development:</b>
// <ul>
// <li>generalizing space phasor theory to m phases with arbitrary spatial angle of the coils</li>
// <li>generalizing space phasor theory to arbitrary number of windings and winding factor of the coils</li>
// <li>MachineModels: other machine types</li>
// <li>effects: saturation, skin-effect, other losses than ohmic, ...</li>
// </ul>
// </p>
// <p>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </dl>
// </p>
// <p>
// Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// </HTML>", revisions = "<HTML>
//   <ul>
//   <li> v1.00  2004/09/16 Anton Haumer<br>
//        first stable release</li>
//   <li> v1.01  2004/09/18 Anton Haumer<br>
//        moved common equations from machine models to PartialMachine<br>
//        improved MoveToRotational</li>
//   <li> v1.02  2004/09/19 Anton Haumer<br>
//        new package structure for machine types<br>
//        added DC machine models</li>
//   <li> v1.03  2004/09/24 Anton Haumer<br>
//        added package Sensors<br>
//        added DC machine with series excitation<br>
//        debugged and improved MoveToRotational</li>
//   <li> v1.1   2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.2   2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.3   2004/11/05 Anton Haumer<br>
//        several improvements in SpacePhasors.Blocks</li>
//   <li> v1.3.1 2004/11/06 Anton Haumer<br>
//        small changes in Examples.Utilities.VfController</li>
//   <li> v1.3.2 2004/11/10 Anton Haumer<br>
//        ReluctanceRotor moved to SynchronousMachines</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   <li> v1.51  2005/02/01 Anton Haumer<br>
//        changed parameter polePairs to Integer</li>
//   <li> v1.52  2005/10/12 Anton Haumer<br>
//        added BasicMachines.SynchronousInductionMachines.SM_ElectricalExcitedDamperCage<br>
//        using new basicMachines.Components.ElectricalExcitation<br>
//        as well as a new exmaple.</li>
//   <li> v1.53  2005/10/14 Anton Haumer<br>
//        introduced unsymmetrical DamperCage for Synchronous Machines</li>
//   <li> v1.60  2005/11/04 Anton Haumer<br>
//        added SpacePhasors.Components.Rotator<br>
//        corrected consistent naming of parameters and variables</li>
//   <li> v1.6.1 2005/11/22 Anton Haumer<br>
//        improved Transformation and Rotation in SpacePhasor.<br>
//        introduced Examples.Utilities.TerminalBox</li>
//   <li> v1.6.2 2005/10/23 Anton Haumer<br>
//        selectable DamperCage for Synchronous Machines</li>
//   <li> v1.6.3 2005/11/25 Anton Haumer<br>
//        easier parametrisation of AsynchronousInductionMachines.AIM_SlipRing model</li>
//   <li> v1.7.0 2005/12/15 Anton Haumer<br>
//        back-changed the naming to ensure backward compatibility</li>
//   <li> v1.7.1 2006/02/06 Anton Haumer<br>
//        changed some naming of synchronous machines, not affecting existing models</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {0,127,255}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -60.0,60.0},{60.0, -60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -60.0,60.0},{ -80.0, -60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{60.0,10.0},{80.0, -10.0}}),Rectangle(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, extent = {{ -60.0,70.0},{20.0,50.0}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -70.0, -90.0},{ -60.0, -90.0},{ -30.0, -20.0},{20.0, -20.0},{50.0, -90.0},{60.0, -90.0},{60.0, -100.0},{ -70.0, -100.0},{ -70.0, -90.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Examples "Test examples"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains test examples of electric machines,<br>
// and a package utilities with components used for the examples.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.01 2004/09/18 Anton Haumer<br>
//        adapted to improved MoveToRotational</li>
//   <li> v1.02 2004/09/19 Anton Haumer<br>
//        added examples for DC machines</li>
//   <li> v1.03 2004/09/24 Anton Haumer<br>
//        usage of Sensors.CurrentRMSsensor<br>
//        added example for DC machine with series excitation</li>
//   <li> v1.1  2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.3.1 2004/11/06 Anton Haumer<br>
//        small changes in Utilities.VfController</li>
//   <li> v1.52 2005/10/12 Anton Haumer<br>
//        new example for electrical excited synchronous induction machine</li>
//   <li> v1.6.1 2004/11/22 Anton Haumer<br>
//        introduced Utilities.TerminalBox</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {128,128,128}, extent = {{ -80.0,44.0},{60.0, -96.0}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -40.0,36.0},{ -40.0, -88.0},{60.0, -26.0},{ -40.0,36.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model AIMC_DOL "Test example 1: AsynchronousInductionMachineSquirrelCage direct-on-line"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Time tStart1 = 0.1 "start time";
//           parameter Modelica.SIunits.Torque T_Load = 161.4 "nominal load torque";
//           parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmLoad = 1440.45 "nominal load speed";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>1st Test example: Asynchronous induction Machine with squirrel cage - direct on line starting</b><br>
// At start time tStart three phase voltage is supplied to the asynchronous induction machine with squirrel cage;
// the machine starts from standstill, accelerating inertias against load torque quadratic dependent on speed, finally reaching nominal speed.<br>
// Simulate for 1.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>AIMC1.rpm_mechanical: motor's speed</li>
// <li>AIMC1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>AIM_SquirrelCage</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage AIMC1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Sources.SineVoltage SineVoltage1(final m = m, freqHz = fill(fNominal, m), V = fill(sqrt(2 / 3) * VNominal, m)) annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep1[m](each startTime = tStart1) annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Ideal.IdealClosingSwitch IdealCloser1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -270)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque QuadraticLoadTorque1(w_nominal = Modelica.SIunits.Conversions.from_rpm(rpmLoad), tau_nominal =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1(StarDelta = "D") annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{ -10.0, -20.0},{0.0, -20.0},{0.0, -10.0}}, color = {0,0,255}));
//           connect(IdealCloser1.plug_n,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{0.0,20.0},{0.0,17.0},{0.0,17.0},{0.0,10.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,IdealCloser1.plug_p) annotation(Line(visible = true, points = {{0.0,70.0},{0.0,48.0},{0.0,46.0},{0.0,46.0},{0.0,40.0}}, color = {0,0,255}));
//           connect(BooleanStep1.y,IdealCloser1.control) annotation(Line(visible = true, points = {{ -59.0,40.0},{ -20.0,40.0},{ -20.0,30.0},{ -7.0,30.0}}, color = {255,0,255}));
//           connect(AIMC1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, origin = {20.0, -40.0}, points = {{ -20.0,0.0},{20.0,0.0}}));
//           connect(TerminalBox1.negativeMachinePlug,AIMC1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(TerminalBox1.positiveMachinePlug,AIMC1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(LoadInertia.flange_b,QuadraticLoadTorque1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(SineVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{0.0,50.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//         end AIMC_DOL;
//         model AIMC_YD "Test example 2: AsynchronousInductionMachineSquirrelCage Y-D"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Time tStart1 = 0.1 "start time";
//           parameter Modelica.SIunits.Time tStart2 = 2.0 "2nd start time";
//           parameter Modelica.SIunits.Torque T_Load = 161.4 "nominal load torque";
//           parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmLoad = 1440.45 "nominal load speed";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2.5, Interval = 0.001, Tolerance = 0.0001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>2nd Test example: Asynchronous induction Machine with squirrel cage - Y-D starting</b><br>
// At start time tStart three phase voltage is supplied to the asynchronous induction machine with squirrel cage, first star-connected, then delta-connetced; the machine starts from standstill, accelerating inertias against load torque quadratic dependent on speed, finally reaching nominal speed.<br>
// Simulate for 2.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>AIMC1.rpm_mechanical: motor's speed</li>
// <li>AIMC1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>AIM_SquirrelCage</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage AIMC1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep1[m](each startTime = tStart1) annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Ideal.IdealClosingSwitch IdealCloser1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.Machines.Examples.Utilities.SwitchYD SwitchYD1 annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep2[m](each startTime = tStart2) annotation(Placement(visible = true, transformation(origin = { -70.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque QuadraticLoadTorque1(w_nominal = Modelica.SIunits.Conversions.from_rpm(rpmLoad), tau_nominal =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.MultiPhase.Sources.SineVoltage SineVoltage1(final m = m, freqHz = fill(fNominal, m), V = fill(sqrt(2 / 3) * VNominal, m)) annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -450)));
// 
//         equation 
//           connect(BooleanStep2.y,SwitchYD1.control) annotation(Line(visible = true, origin = { -40.0, -20.0}, points = {{ -19.0,0.0},{19.0,0.0}}, color = {255,0,255}));
//           connect(CurrentRMSsensor1.plug_n,SwitchYD1.plug_P) annotation(Line(visible = true, points = {{0.0, -10.0},{0.0, -10.0},{0.0, -8.0},{0.0, -10.0}}, color = {0,0,255}));
//           connect(AIMC1.plug_sp,SwitchYD1.pug_PS) annotation(Line(visible = true, points = {{ -4.0, -30.0},{0.0, -30.0}}, color = {0,0,255}));
//           connect(SwitchYD1.plug_NS,AIMC1.plug_sn) annotation(Line(visible = true, points = {{ -20.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(AIMC1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, origin = {20.0, -40.0}, points = {{ -20.0,0.0},{20.0,0.0}}));
//           connect(IdealCloser1.plug_n,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{0.0,20.0},{ -0.0,18.0},{0.0,18.0},{0.0,10.0}}, color = {0,0,255}));
//           connect(BooleanStep1.y,IdealCloser1.control) annotation(Line(visible = true, points = {{ -59.0,40.0},{ -20.0,40.0},{ -20.0,30.0},{ -7.0,30.0}}, color = {255,0,255}));
//           connect(LoadInertia.flange_b,QuadraticLoadTorque1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{ -0.0,70.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,IdealCloser1.plug_p) annotation(Line(visible = true, points = {{0.0,50.0},{0.0,48.0},{0.0,46.0},{0.0,46.0},{0.0,40.0}}, color = {0,0,255}));
//         end AIMC_YD;
//         model AIMS_start "Test example 3: AsynchronousInductionMachineSlipRing"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Time tStart1 = 0.1 "1st start time";
//           parameter Modelica.SIunits.Resistance Rstart = 0.16 "starting resistance";
//           parameter Modelica.SIunits.Time tStart2 = 1.0 "2nd start time";
//           parameter Modelica.SIunits.Torque T_Load = 161.4 "nominal load torque";
//           parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmLoad = 1440.45 "nominal load speed";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>3rd Test example: Asynchronous induction Machine with slipring rotor - resistance starting</b><br>
// At start time tStart1 three phase voltage is supplied to the asynchronous induction machine with sliprings;
// the machine starts from standstill, accelerating inertias against load torque quadratic dependent on speed,
// using a starting resistance. At time tStart2 tStart2 is shortened, finally reaching nominal speed.<br>
// Simulate for 1.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>AIMS1.rpm_mechanical: motor's speed</li>
// <li>AIMS1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>AIM_SlipRing</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SlipRing AIMS1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Sources.SineVoltage SineVoltage1(final m = m, freqHz = fill(fNominal, m), V = fill(sqrt(2 / 3) * VNominal, m)) annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep1[m](each startTime = tStart1) annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Ideal.IdealClosingSwitch IdealCloser1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star3(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0, -90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Ideal.IdealCommutingSwitch IdealCommutingSwitch1(m = m) annotation(Placement(visible = true, transformation(origin = { -40.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Basic.Resistor Resistor1(m = m, R = fill(Rstart, m)) annotation(Placement(visible = true, transformation(origin = { -60.0, -70.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star4(final m = m) annotation(Placement(visible = true, transformation(origin = { -90.0, -70.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep2[m](each startTime = tStart2) annotation(Placement(visible = true, transformation(origin = { -70.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque QuadraticLoadTorque1(w_nominal = Modelica.SIunits.Conversions.from_rpm(rpmLoad), tau_nominal =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1(StarDelta = "D") annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Ground Ground3 annotation(Placement(visible = true, transformation(origin = { -90.0, -90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(Resistor1.plug_p,IdealCommutingSwitch1.plug_n1) annotation(Line(visible = true, origin = { -46.6667, -63.3333}, points = {{ -3.3333, -6.6667},{1.6667, -6.6667},{1.6667,13.3333}}, color = {0,0,255}));
//           connect(IdealCommutingSwitch1.plug_n2,AIMS1.plug_rn) annotation(Line(visible = true, points = {{ -40.0, -50.0},{ -28.0, -50.0},{ -28.0, -46.0},{ -20.0, -46.0}}, color = {0,0,255}));
//           connect(IdealCommutingSwitch1.plug_p,AIMS1.plug_rp) annotation(Line(visible = true, points = {{ -40.0, -30.0},{ -30.0, -30.0},{ -30.0, -34.0},{ -20.0, -34.0}}, color = {0,0,255}));
//           connect(BooleanStep2.y,IdealCommutingSwitch1.control) annotation(Line(visible = true, origin = { -53.5, -40.0}, points = {{ -5.5,0.0},{5.5,0.0}}, color = {255,0,255}));
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{ -10.0, -20.0},{ -0.0, -20.0},{0.0, -10.0}}, color = {0,0,255}));
//           connect(TerminalBox1.positiveMachinePlug,AIMS1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(TerminalBox1.negativeMachinePlug,AIMS1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(IdealCloser1.plug_n,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{0.0,20.0},{ -0.0,16.0},{0.0,16.0},{0.0,10.0}}, color = {0,0,255}));
//           connect(BooleanStep1.y,IdealCloser1.control) annotation(Line(visible = true, points = {{ -59.0,40.0},{ -20.0,40.0},{ -20.0,30.0},{ -7.0,30.0}}, color = {255,0,255}));
//           connect(AIMS1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(LoadInertia.flange_b,QuadraticLoadTorque1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(AIMS1.plug_rn,Star3.plug_p) annotation(Line(visible = true, points = {{ -20.0, -46.0},{ -20.0, -90.0},{ -50.0, -90.0}}, color = {0,0,255}));
//           connect(Star4.plug_p,Resistor1.plug_n) annotation(Line(visible = true, points = {{ -80.0, -70.0},{ -70.0, -70.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,IdealCloser1.plug_p) annotation(Line(visible = true, points = {{0.0,70.0},{0.0,48.0},{0.0,46.0},{0.0,46.0},{0.0,40.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{0.0,50.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//           connect(Star3.pin_n,Ground3.p) annotation(Line(visible = true, points = {{ -70.0, -90.0},{ -80.0, -90.0}}, color = {0,0,255}));
//         end AIMS_start;
//         model AIMC_Inverter "Test example 4: AsynchronousInductionMachineSquirrelCage with inverter"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Frequency f = 50 "actual frequency";
//           parameter Modelica.SIunits.Time tRamp = 1 "frequency ramp";
//           parameter Modelica.SIunits.Torque T_Load = 161.4 "nominal load torque";
//           parameter Modelica.SIunits.Time tStep = 1.2 "time of load torque step";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>4th Test example: Asynchronous induction Machine with squirrel cage fed by an ideal inverter</b><br>
// An ideal frequency inverter is modeled by using a VfController and a threephase SignalVoltage.<br>
// Frequency is raised by a ramp, causing the asynchronous induction machine with squirrel cage to start, 
// and accelerating inertias.<br>At time tStep a load step is applied.<br>
// Simulate for 1.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>AIMC1.rpm_mechanical: motor's speed</li>
// <li>AIMC1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>AIM_SquirrelCage</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Blocks.Sources.Ramp Ramp1(height = f, duration = tRamp) annotation(Placement(visible = true, transformation(origin = { -70.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.VfController VfController1(final m = m, VNominal = VNominal, fNominal = fNominal) annotation(Placement(visible = true, transformation(origin = { -30.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.TorqueStep TorqueStep1(startTime = tStep, stepTorque =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1 annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Sources.SignalVoltage SignalVoltage1(final m = m) annotation(Placement(visible = true, transformation(origin = { -0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -90)));
//           Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage AIMC1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{ -10.0, -20.0},{ -0.0, -20.0},{0.0, -10.0}}, color = {0,0,255}));
//           connect(TorqueStep1.flange,LoadInertia.flange_b) annotation(Line(visible = true, points = {{70.0, -40.0},{60.0, -40.0}}));
//           connect(Ramp1.y,VfController1.u) annotation(Line(visible = true, points = {{ -59.0,60.0},{ -42.0,60.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{ -0.0,70.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(VfController1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -19.0,60.0},{ -7.0,60.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.plug_p,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{ -0.0,50.0},{0.0,40.0},{0.0,40.0},{0.0,30.0},{0.0,10.0},{0.0,10.0}}, color = {0,0,255}));
//           connect(AIMC1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(TerminalBox1.negativeMachinePlug,AIMC1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(TerminalBox1.positiveMachinePlug,AIMC1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//         end AIMC_Inverter;
//         model SMR_Inverter "Test example 5: SynchronousInductionMachineReluctanceRotor with inverter"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Frequency f = 50 "actual frequency";
//           parameter Modelica.SIunits.Time tRamp = 1 "frequency ramp";
//           parameter Modelica.SIunits.Torque T_Load = 46 "nominal load torque";
//           parameter Modelica.SIunits.Time tStep = 1.2 "time of load torque step";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>5th Test example: Synchronous Induction Machine with Reluctance rotor fed by an ideal inverter</b><br>
// An ideal frequency inverter is modeled by using a VfController and a threephase SignalVoltage.<br>
// Frequency is raised by a ramp, causing the reluctance machine to start, 
// and accelerating inertias.<br>At time tStep a load step is applied.<br>
// Simulate for 1.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>SMRD1.rpm_mechanical: motor's speed</li>
// <li>SMRD1.tau_electrical: motor's torque</li>
// <li>RotorAngle.rotorAngle: rotor displacement angle</li>
// </ul>
// Default machine parameters of model <i>SM_ReluctanceRotorDamperCage</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ReluctanceRotorDamperCage SMR1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.Machines.Sensors.RotorAngle RotorAngle1(p = SMR1.p) annotation(Placement(visible = true, transformation(origin = { -10.0, -10.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -90)));
//           Modelica.Blocks.Sources.Ramp Ramp1(height = f, duration = tRamp) annotation(Placement(visible = true, transformation(origin = { -70.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.VfController VfController1(final m = m, VNominal = VNominal, fNominal = fNominal) annotation(Placement(visible = true, transformation(origin = { -30.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.TorqueStep TorqueStep1(startTime = tStep, stepTorque =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1 annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Sources.SignalVoltage SignalVoltage1(final m = m) annotation(Placement(visible = true, transformation(origin = { -0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{12.0, -28.0},{12.0,20.0},{0.0,20.0}}, color = {0,0,255}));
//           connect(TerminalBox1.negativeMachinePlug,SMR1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(TerminalBox1.positiveMachinePlug,SMR1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(SMR1.flange_a,RotorAngle1.flange) annotation(Line(visible = true, points = {{0.0, -40.0},{0.0, -10.0}}));
//           connect(SMR1.plug_sp,RotorAngle1.plug_p) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -25.0},{ -4.0, -20.0},{ -4.0, -20.0}}, color = {0,0,255}));
//           connect(SMR1.plug_sn,RotorAngle1.plug_n) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -20.0}}, color = {0,0,255}));
//           connect(LoadInertia.flange_b,TorqueStep1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(Ramp1.y,VfController1.u) annotation(Line(visible = true, points = {{ -59.0,60.0},{ -42.0,60.0}}, color = {0,0,255}));
//           connect(SMR1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(SignalVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{ -0.0,70.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(VfController1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -19.0,60.0},{ -7.0,60.0}}, color = {0,0,255}));
//           connect(CurrentRMSsensor1.plug_p,SignalVoltage1.plug_p) annotation(Line(visible = true, points = {{0.0,40.0},{0.0,42.5},{0.0,42.5},{0.0,45.0},{0.0,50.0},{ -0.0,50.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//         end SMR_Inverter;
//         model SMPM_Inverter "Test example 6: PermanentMagnetSynchronousInductionMachine with inverter"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Frequency f = 50 "actual frequency";
//           parameter Modelica.SIunits.Time tRamp = 1 "frequency ramp";
//           parameter Modelica.SIunits.Torque T_Load = 181.4 "nominal load torque";
//           parameter Modelica.SIunits.Time tStep = 1.2 "time of load torque step";
//           parameter Modelica.SIunits.Inertia J_Load = 0.29 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>6th Test example: Permanent Magnet Synchronous Induction Machine fed by an ideal inverter</b><br>
// An ideal frequency inverter is modeled by using a VfController and a threephase SignalVoltage.<br>
// Frequency is raised by a ramp, causing the permanent magnet synchronous induction machine to start, 
// and accelerating inertias.<br>At time tStep a load step is applied.<br>
// Simulate for 1.5 seconds and plot (versus time):
// <ul>
// <li>CurrentRMSsensor1.I: stator current RMS</li>
// <li>PMSMD1.rpm_mechanical: motor's speed</li>
// <li>PMSMD1.tau_electrical: motor's torque</li>
// <li>RotorAngle.rotorAngle: rotor displacement angle</li>
// </ul>
// Default machine parameters of model <i>SM_PermanentMagnetDamperCage</i> are used.
// </p>
// <p>
// <b>In practice it is nearly impossible to drive a PMSMD without current controller.</b>
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_PermanentMagnetDamperCage SMPM1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.Machines.Sensors.RotorAngle RotorAngle1(p = SMPM1.p) annotation(Placement(visible = true, transformation(origin = { -10.0, -10.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90)));
//           Modelica.Blocks.Sources.Ramp Ramp1(height = f, duration = tRamp) annotation(Placement(visible = true, transformation(origin = { -70.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.VfController VfController1(final m = m, VNominal = VNominal, fNominal = fNominal, BasePhase =  +Modelica.Constants.pi / 2) annotation(Placement(visible = true, transformation(origin = { -30.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.TorqueStep TorqueStep1(startTime = tStep, stepTorque =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1 annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.MultiPhase.Sources.SignalVoltage SignalVoltage1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{12.0, -28.0},{12.0,20.0},{0.0,20.0}}, color = {0,0,255}));
//           connect(TerminalBox1.positiveMachinePlug,SMPM1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(TerminalBox1.negativeMachinePlug,SMPM1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(SMPM1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(RotorAngle1.flange,SMPM1.flange_a) annotation(Line(visible = true, points = {{0.0, -10.0},{0.0, -40.0}}));
//           connect(RotorAngle1.plug_p,SMPM1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -20.0},{ -4.0, -25.0},{ -4.0, -25.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(RotorAngle1.plug_n,SMPM1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -20.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(LoadInertia.flange_b,TorqueStep1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(Ramp1.y,VfController1.u) annotation(Line(visible = true, points = {{ -59.0,60.0},{ -42.0,60.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{0.0,70.0},{ -0.0,90.0},{ -50.0,90.0}}, color = {0,0,255}));
//           connect(VfController1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -19.0,60.0},{ -7.0,60.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.plug_p,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{0.0,50.0},{0.0,50.0},{0.0,40.0},{0.0,40.0}}, color = {0,0,255}));
//         end SMPM_Inverter;
//         model SMEE_Gen "Test example 7: ElectricalExcitedSynchronousInductionMachine as Generator"
//           extends Modelica.Icons.Example;
//           constant Integer m = 3 "number of phases";
//           parameter Modelica.SIunits.Voltage VNominal = 100 "nominal RMS voltage per phase";
//           parameter Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//           parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpm = 1499 "nominal speed";
//           parameter Modelica.SIunits.Current Ie = 19 "excitation current";
//           parameter Modelica.SIunits.Current Ie0 = 10 "initial excitation current";
//           parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg gamma0 = 0 "initial rotor displacement angle";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 30, Interval = 0.005), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>7th Test example: Electrical Excited Synchronous Induction Machine as generator</b><br>
// An electrically excited synchronous generator is connected to the grid and driven with constant speed. 
// Since speed is slightly smaller than synchronous speed corresponding to mains frequency, 
// rotor angle is very slowly increased. This allows to see several charactersistics dependent on rotor angle.
// Simulate for 30 seconds and plot (versus RotorAngle1.rotorAngle):
// <ul>
// <li>SMEED1.tau_electrical</li>
// <li>CurrentRMSsensor1.I</li>
// <li>ElectricalPowerSensor1.P</li>
// <li>ElectricalPowerSensor1.Q</li>
// <li>MechanicalPowerSensor1.P</li>
// </ul>
// Default machine parameters of model <i>SM_ElectricalExcitedDamperCage</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ElectricalExcitedDamperCage SMEE1(phi_mechanical(start =  -(Modelica.Constants.pi + Modelica.SIunits.Conversions.from_deg(gamma0)) / SMEE1.p)) annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.RotorAngle RotorAngle1(p = SMEE1.p) annotation(Placement(visible = true, transformation(origin = { -10.0, -10.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90)));
//           Modelica.Mechanics.Rotational.ConstantSpeed ConstantSpeed1(final w_fixed = Modelica.SIunits.Conversions.from_rpm(rpm)) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.MechanicalPowerSensor MechanicalPowerSensor1 annotation(Placement(visible = true, transformation(origin = {20.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Sensors.CurrentRMSsensor CurrentRMSsensor1 annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Sources.SineVoltage SineVoltage1(final m = m, final V = fill(VNominal * sqrt(2), m), final freqHz = fill(fNominal, m)) annotation(Placement(visible = true, transformation(origin = { -30.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,90.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.Examples.Utilities.TerminalBox TerminalBox1 annotation(Placement(visible = true, transformation(origin = { -10.0, -20.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90.0,90.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Ground Ground3 annotation(Placement(visible = true, transformation(origin = { -90.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Sources.RampCurrent RampCurrent1(duration = 0.1, I = Ie - Ie0, offset = Ie0) annotation(Placement(visible = true, transformation(origin = { -50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -270)));
//           Modelica.Electrical.Machines.Sensors.ElectricalPowerSensor ElectricalPowerSensor1 annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(MechanicalPowerSensor1.flange_b,ConstantSpeed1.flange) annotation(Line(visible = true, origin = {50.0, -40.0}, points = {{ -20.0,0.0},{20.0,0.0}}));
//           connect(SMEE1.flange_a,MechanicalPowerSensor1.flange_a) annotation(Line(visible = true, origin = {5.0, -40.0}, points = {{ -5.0,0.0},{5.0,0.0}}));
//           connect(ElectricalPowerSensor1.plug_nv,RotorAngle1.plug_n) annotation(Line(visible = true, points = {{ -10.0,60.0},{ -20.0,60.0},{ -20.0, -20.0},{ -16.0, -20.0}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,ElectricalPowerSensor1.plug_p) annotation(Line(visible = true, origin = { -6.6667,83.3333}, points = {{ -13.3333,6.6667},{6.6667,6.6667},{6.6667, -13.3333}}, color = {0,0,255}));
//           connect(ElectricalPowerSensor1.plug_ni,CurrentRMSsensor1.plug_p) annotation(Line(visible = true, points = {{0.0,50.0},{0.0,46.0},{0.0,46.0},{0.0,40.0}}, color = {0,0,255}));
//           connect(TerminalBox1.plugToGrid,CurrentRMSsensor1.plug_n) annotation(Line(visible = true, points = {{ -10.0, -28.0},{10.0, -28.0},{10.0,20.0},{0.0,20.0}}, color = {0,0,255}));
//           connect(SMEE1.plug_sp,TerminalBox1.positiveMachinePlug) annotation(Line(visible = true, points = {{ -4.0, -30.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(SMEE1.plug_sn,TerminalBox1.negativeMachinePlug) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(Star1.plug_p,SineVoltage1.plug_n) annotation(Line(visible = true, points = {{ -50.0,90.0},{ -40.0,90.0}}, color = {0,0,255}));
//           connect(RotorAngle1.flange,SMEE1.flange_a) annotation(Line(visible = true, points = {{0.0, -10.0},{0.0, -40.0}}));
//           connect(RotorAngle1.plug_p,SMEE1.plug_sp) annotation(Line(visible = true, points = {{ -4.0, -20.0},{ -4.0, -25.0},{ -4.0, -25.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(RotorAngle1.plug_n,SMEE1.plug_sn) annotation(Line(visible = true, points = {{ -16.0, -20.0},{ -16.0, -30.0}}, color = {0,0,255}));
//           connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -70.0,90.0},{ -80.0,90.0}}, color = {0,0,255}));
//           connect(RampCurrent1.p,Ground3.p) annotation(Line(visible = true, points = {{ -50.0, -50.0},{ -80.0, -50.0}}, color = {0,0,255}));
//           connect(RampCurrent1.p,SMEE1.pin_en) annotation(Line(visible = true, points = {{ -50.0, -50.0},{ -40.0, -50.0},{ -40.0, -46.0},{ -20.0, -46.0}}, color = {0,0,255}));
//           connect(RampCurrent1.n,SMEE1.pin_ep) annotation(Line(visible = true, points = {{ -50.0, -30.0},{ -40.0, -30.0},{ -40.0, -34.0},{ -20.0, -34.0}}, color = {0,0,255}));
//         end SMEE_Gen;
//         model DCPM_start "Test example 8: DC with permanent magnet starting with voltage ramp"
//           extends Modelica.Icons.Example;
//           parameter Modelica.SIunits.Voltage Va = 100 "actual armature voltage";
//           parameter Modelica.SIunits.Time tStart = 0.2 "armature voltage ramp";
//           parameter Modelica.SIunits.Time tRamp = 0.8 "armature voltage ramp";
//           parameter Modelica.SIunits.Torque T_Load = 63.66 "nominal load torque";
//           parameter Modelica.SIunits.Time tStep = 1.5 "time of load torque step";
//           parameter Modelica.SIunits.Inertia J_Load = 0.15 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>8th Test example: Permanent magnet DC Machine started with an armature voltage ramp</b><br>
// A voltage ramp is applied to the armature, causing the DC machine to start, 
// and accelerating inertias.<br>At time tStep a load step is applied.<br>
// Simulate for 2 seconds and plot (versus time):
// <ul>
// <li>DCPM1.ia: armature current</li>
// <li>DCPM1.rpm_mechanical: motor's speed</li>
// <li>DCPM1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>DC_PermanentMagnet</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_PermanentMagnet DCPM1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp Ramp1(duration = tRamp, height = Va, startTime = tStart) annotation(Placement(visible = true, transformation(origin = { -70.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.TorqueStep TorqueStep1(startTime = tStep, stepTorque =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Sources.SignalVoltage SignalVoltage1 annotation(Placement(visible = true, transformation(origin = { -10.0,40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -360)));
// 
//         equation 
//           connect(LoadInertia.flange_b,TorqueStep1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(DCPM1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(Ramp1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -59.0,70.0},{ -10.0,70.0},{ -10.0,47.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.p,DCPM1.pin_ap) annotation(Line(visible = true, points = {{0.0,40.0},{0.0, -20.0},{ -4.0, -20.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.n,Ground1.p) annotation(Line(visible = true, points = {{ -20.0,40.0},{ -60.0,40.0}}, color = {0,0,255}));
//           connect(DCPM1.pin_an,SignalVoltage1.n) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -20.0},{ -20.0, -20.0},{ -20.0,40.0}}, color = {0,0,255}));
//         end DCPM_start;
//         model DCEE_start "Test example 9: DC with electrical ecxitation starting with voltage ramp"
//           extends Modelica.Icons.Example;
//           parameter Modelica.SIunits.Voltage Va = 100 "actual armature voltage";
//           parameter Modelica.SIunits.Time tStart = 0.2 "armature voltage ramp";
//           parameter Modelica.SIunits.Time tRamp = 0.8 "armature voltage ramp";
//           parameter Modelica.SIunits.Voltage Ve = 100 "actual excitation voltage";
//           parameter Modelica.SIunits.Torque T_Load = 63.66 "nominal load torque";
//           parameter Modelica.SIunits.Time tStep = 1.5 "time of load torque step";
//           parameter Modelica.SIunits.Inertia J_Load = 0.15 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>9th Test example: Electrically separate excited DC Machine started with an armature voltage ramp</b><br>
// A voltage ramp is applied to the armature, causing the DC machine to start, 
// and accelerating inertias.<br>At time tStep a load step is applied.<br>
// Simulate for 2 seconds and plot (versus time):
// <ul>
// <li>DCEE1.ia: armature current</li>
// <li>DCEE1.rpm_mechanical: motor's speed</li>
// <li>DCEE1.tau_electrical: motor's torque</li>
// <li>DCEE1.ie: excitation current</li>
// </ul>
// Default machine parameters of model <i>DC_ElectricalExcited</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Blocks.Sources.Ramp Ramp1(duration = tRamp, height = Va, startTime = tStart) annotation(Placement(visible = true, transformation(origin = { -70.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.TorqueStep TorqueStep1(startTime = tStep, stepTorque =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.ConstantVoltage ConstantVoltage1(V = Ve) annotation(Placement(visible = true, transformation(origin = { -40.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -450)));
//           Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_ElectricalExcited DCEE1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SignalVoltage SignalVoltage1 annotation(Placement(visible = true, transformation(origin = { -10.0,40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -720)));
//           Modelica.Electrical.Analog.Basic.Ground Grounda annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Ground Grounde annotation(Placement(visible = true, transformation(origin = { -70.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(LoadInertia.flange_b,TorqueStep1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(DCEE1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(DCEE1.pin_ep,ConstantVoltage1.p) annotation(Line(visible = true, points = {{ -20.0, -34.0},{ -30.0, -34.0},{ -30.0, -30.0},{ -40.0, -30.0}}, color = {0,0,255}));
//           connect(DCEE1.pin_en,ConstantVoltage1.n) annotation(Line(visible = true, points = {{ -20.0, -46.0},{ -30.0, -46.0},{ -30.0, -50.0},{ -40.0, -50.0}}, color = {0,0,255}));
//           connect(Ramp1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -59.0,70.0},{ -10.0,70.0},{ -10.0,47.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.p,DCEE1.pin_ap) annotation(Line(visible = true, points = {{0.0,40.0},{0.0, -20.0},{ -4.0, -20.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(SignalVoltage1.n,Grounda.p) annotation(Line(visible = true, points = {{ -20.0,40.0},{ -60.0,40.0}}, color = {0,0,255}));
//           connect(DCEE1.pin_an,Grounda.p) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -16.0, -20.0},{ -20.0, -20.0},{ -20.0,40.0},{ -60.0,40.0}}, color = {0,0,255}));
//           connect(ConstantVoltage1.n,Grounde.p) annotation(Line(visible = true, points = {{ -40.0, -50.0},{ -60.0, -50.0}}, color = {0,0,255}));
//         end DCEE_start;
//         model DCSE_start "Test example 10: DC with serial excitation starting with voltage ramp"
//           extends Modelica.Icons.Example;
//           parameter Modelica.SIunits.Voltage Va = 100 "actual armature voltage";
//           parameter Modelica.SIunits.Time tStart = 0.2 "armature voltage ramp";
//           parameter Modelica.SIunits.Time tRamp = 0.8 "armature voltage ramp";
//           parameter Modelica.SIunits.Torque T_Load = 63.66 "nominal load torque";
//           parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmLoad = 1402.5 "nominal load speed";
//           parameter Modelica.SIunits.Inertia J_Load = 0.15 "load's moment of inertia";
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2, Interval = 0.001), experimentSetupOutput(doublePrecision = true), Documentation(info = "<HTML>
// <p>
// <b>10th Test example: Series excited DC Machine started with an armature voltage ramp</b><br>
// A voltage ramp is applied to the armature, causing the DC machine to start, 
// and accelerating inertiasagainst load torque quadratic dependent on speed, finally reaching nominal speed.<br>
// Simulate for 2 seconds and plot (versus time):
// <ul>
// <li>DCSE1.ia: armature current</li>
// <li>DCSE1.rpm_mechanical: motor's speed</li>
// <li>DCSE1.tau_electrical: motor's torque</li>
// </ul>
// Default machine parameters of model <i>DC_SeriesExcited</i> are used.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_SeriesExcited DCSE1 annotation(Placement(visible = true, transformation(origin = { -10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp Ramp1(duration = tRamp, height = Va, startTime = tStart) annotation(Placement(visible = true, transformation(origin = { -70.0,70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SignalVoltage SignalVoltage1 annotation(Placement(visible = true, transformation(origin = { -10.0,40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia LoadInertia(J = J_Load) annotation(Placement(visible = true, transformation(origin = {50.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque QuadraticLoadTorque1(w_nominal = Modelica.SIunits.Conversions.from_rpm(rpmLoad), tau_nominal =  -T_Load) annotation(Placement(visible = true, transformation(origin = {80.0, -40.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground Grounda annotation(Placement(visible = true, transformation(origin = { -70.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(DCSE1.pin_en,SignalVoltage1.n) annotation(Line(visible = true, points = {{ -20.0, -46.0},{ -30.0, -46.0},{ -30.0, -20.0},{ -20.0, -20.0},{ -20.0,40.0}}, color = {0,0,255}));
//           connect(DCSE1.pin_an,DCSE1.pin_ep) annotation(Line(visible = true, points = {{ -16.0, -30.0},{ -20.0, -30.0},{ -20.0, -34.0}}, color = {0,0,255}));
//           connect(LoadInertia.flange_b,QuadraticLoadTorque1.flange) annotation(Line(visible = true, points = {{60.0, -40.0},{70.0, -40.0}}));
//           connect(SignalVoltage1.p,DCSE1.pin_ap) annotation(Line(visible = true, points = {{0.0,40.0},{0.0, -20.0},{ -4.0, -20.0},{ -4.0, -30.0}}, color = {0,0,255}));
//           connect(Ramp1.y,SignalVoltage1.v) annotation(Line(visible = true, points = {{ -59.0,70.0},{ -10.0,70.0},{ -10.0,47.0}}, color = {0,0,255}));
//           connect(DCSE1.flange_a,LoadInertia.flange_a) annotation(Line(visible = true, points = {{0.0, -40.0},{40.0, -40.0}}));
//           connect(SignalVoltage1.n,Grounda.p) annotation(Line(visible = true, points = {{ -20.0,40.0},{ -60.0,40.0}}, color = {0,0,255}));
//         end DCSE_start;
//         package Utilities "Library with auxiliary models for testing"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains components utility components for testing examples.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.1  2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.3.1 2004/11/06 Anton Haumer<br>
//        small changes in VfController</li>
//   <li> v1.6.1 2004/11/22 Anton Haumer<br>
//        introduced TerminalBox</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           block VfController "Voltage-Frequency-Controller"
//             extends Modelica.Blocks.Interfaces.SIMO(final nout = m, u(redeclare type SignalType = Modelica.SIunits.Frequency), y(redeclare type SignalType = Modelica.SIunits.Voltage));
//             constant Real pi = Modelica.Constants.pi;
//             parameter Integer m = 3 "number of phases";
//             parameter Modelica.SIunits.Voltage VNominal "nominal RMS voltage per phase";
//             parameter Modelica.SIunits.Frequency fNominal "nominal frequency";
//             parameter Modelica.SIunits.Angle BasePhase = 0 "common phase shift";
//             output Modelica.SIunits.Angle x(start = 0, fixed = true) "Integrator state";
//             output Modelica.SIunits.Voltage amplitude;
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Simple Voltage-Frequency-Controller.<br>
// Amplitude of voltage is linear dependent (VNominal/fNominal) on Frequency (input signal \"u\"), but limited by VNominal (nominal RMS voltage per phase).<br>
// m sine-waves with amplitudes as described above are provided as output signal \"y\".<br>
// The sine-waves are intended to feed a m-phase SignalVoltage.<br>
// Phase shifts between sine-waves may be choosen by the user; default values are <i>(k-1)/m*pi for k in 1:m</i>.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, origin = {10.0, -22.7276}, points = {{ -110.0, -77.2724},{ -3.6842,67.2714},{72.0068,67.2714}}, color = {0,0,255}),Line(visible = true, origin = { -10.0,0.0}, points = {{ -50.0,0.0},{ -25.0,70.0},{0.0,0.0},{25.0, -70.0},{50.0,0.0}}, color = {160,160,164}, smooth = Smooth.Bezier),Line(visible = true, origin = {10.0,0.0}, points = {{ -50.0,0.0},{ -25.0,70.0},{0.0,0.0},{25.0, -70.0},{50.0,0.0}}, color = {160,160,164}, smooth = Smooth.Bezier),Line(visible = true, origin = {30.0,0.0}, points = {{ -50.0,0.0},{ -25.0,70.0},{0.0,0.0},{25.0, -70.0},{50.0,0.0}}, color = {160,160,164}, smooth = Smooth.Bezier)}));
// 
//           equation 
//             amplitude = sqrt(2) * VNominal * (if abs(u) < fNominal then abs(u) / fNominal else 1);
//             der(x) = 2 * pi * u;
//             y = array(amplitude * sin(x + BasePhase - ((k - 1) * 2) / m * pi) for k in 1:m);
//           end VfController;
//           model SwitchYD "Y-D-switch"
//             constant Integer m = 3 "number of phases";
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_P(final m = m) annotation(Placement(visible = true, transformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug pug_PS(final m = m) annotation(Placement(visible = true, transformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_NS(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80.0,52.0},{ -40.0,0.0},{0.0,52.0},{ -40.0,0.0},{ -40.0, -52.0}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{0.0,40.0},{0.0, -40.0},{80.0,0.0},{0.0,40.0}}, color = {0,0,255}, thickness = 0.5)}), Documentation(info = "<HTML>
// <p>
// Simple Star-Delta-switch.<br>
// If <i>control</i> is false, plug_PS and plug_NS are star connected and plug_PS connected to plug_P.<br>
// If <i>control</i> is true, plug_PS and plug_NS are delta connected and they are connected to plug_P.
// </p>
// </HTML>"));
//             Modelica.Electrical.MultiPhase.Basic.Star star(final m = m) annotation(Placement(visible = true, transformation(origin = {70.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Delta delta(final m = m) annotation(Placement(visible = true, transformation(origin = {70.0, -70.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Ideal.IdealCommutingSwitch idealCommutingSwitch(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Blocks.Interfaces.BooleanInput control[m] annotation(Placement(visible = true, transformation(origin = { -110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(control,idealCommutingSwitch.control) annotation(Line(visible = true, points = {{ -110.0,0.0},{0.0,0.0},{0.0, -52.0}}, color = {255,0,255}));
//             connect(idealCommutingSwitch.plug_p,plug_NS) annotation(Line(visible = true, points = {{ -10.0, -60.0},{ -100.0, -60.0},{ -100.0, -100.0}}, color = {0,0,255}));
//             connect(idealCommutingSwitch.plug_n1,star.plug_p) annotation(Line(visible = true, points = {{10.0, -55.0},{10.0, -40.0},{60.0, -40.0}}, color = {0,0,255}));
//             connect(idealCommutingSwitch.plug_n2,delta.plug_n) annotation(Line(visible = true, points = {{10.0, -60.0},{10.0, -70.0},{60.0, -70.0}}, color = {0,0,255}));
//             connect(delta.plug_p,pug_PS) annotation(Line(visible = true, points = {{80.0, -70.0},{100.0, -70.0},{100.0, -100.0}}, color = {0,0,255}));
//             connect(delta.plug_p,plug_P) annotation(Line(visible = true, points = {{80.0, -70.0},{100.0, -70.0},{100.0,100.0}}, color = {0,0,255}));
//           end SwitchYD;
//           model TerminalBox
//             constant Integer m = 3 "number of phases";
//             parameter String StarDelta = "Y" annotation(choices(choice = "Y" "Star connection", choice = "D" "Delta connection"));
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug positiveMachinePlug(final m = m) annotation(Placement(visible = true, transformation(origin = {60.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {60.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.NegativePlug negativeMachinePlug(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -60.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Star star(final m = m) if StarDelta <> "D" annotation(Placement(visible = true, transformation(origin = { -70.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 180)));
//             Modelica.Electrical.MultiPhase.Basic.Delta delta(final m = m) if StarDelta == "D" annotation(Placement(visible = true, transformation(origin = { -30.0, -60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plugToGrid(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {0.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -80.0, -80.0},{ -80.0, -84.0},{ -80.0, -120.0},{ -40.0, -140.0},{40.0, -140.0},{80.0, -110.0},{80.0, -84.0},{76.0, -80.0},{ -80.0, -80.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0, -130.0},{40.0, -90.0}}, textString = "%StarDelta", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// TerminalBox: at the bottom connected to both machine plugs, connect at the top to the grid as usual,<br>
// choosing Y-connection (StarDelta=Y) or D-connection (StarDelta=D).
// </p>
// </html>"));
//             Modelica.Electrical.Analog.Interfaces.NegativePin starpoint if StarDelta <> "D" annotation(Placement(visible = true, transformation(origin = { -90.0, -80.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -90.0, -80.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             connect(star.pin_n,starpoint) annotation(Line(visible = true, points = {{ -80.0, -80.0},{ -90.0, -80.0}}, color = {0,0,255}));
//             connect(positiveMachinePlug,plugToGrid) annotation(Line(visible = true, points = {{60.0, -100.0},{0.0, -100.0},{0.0, -80.0}}, color = {0,0,255}));
//             connect(delta.plug_p,positiveMachinePlug) annotation(Line(visible = true, points = {{ -20.0, -60.0},{60.0, -60.0},{60.0, -100.0}}, color = {0,0,255}));
//             connect(negativeMachinePlug,delta.plug_n) annotation(Line(visible = true, points = {{ -60.0, -100.0},{ -40.0, -100.0},{ -40.0, -60.0}}, color = {0,0,255}));
//             connect(negativeMachinePlug,star.plug_p) annotation(Line(visible = true, points = {{ -60.0, -100.0},{ -60.0, -80.0}}, color = {0,0,255}));
//           end TerminalBox;
//         end Utilities;
//       end Examples;
//       package BasicMachines "Basic machine models"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains components for modeling electrical machines, specially threephase induction machines, based on space phasor theory:
// <ul>
// <li>package AsynchronousInductionMachines: models of three phase asynchronous induction machines</li>
// <li>package SynchronousInductionMachines: models of three phase synchronous induction machines</li>
// <li>package DCMachines: models of DC machines with different excitation</li>
// <li>package Components: components for modeling machines</li>
// </ul>
// The induction machine models use package SpacePhasors.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00  2004/09/16 Anton Haumer</li>
//   <li> v1.01  2004/09/18 Anton Haumer<br>
//        moved common equations from machine models to PartialMachine</li>
//   <li> v1.02  2004/09/19 Anton Haumer<br>
//        new package structure for machine types<br>
//        added DCMachine models</li>
//   <li> v1.03  2004/09/24 Anton Haumer<br>
//        added DC machine with series excitation</li>
//   <li> v1.1   2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.2   2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.3.2 2004/11/10 Anton Haumer<br>
//        ReluctanceRotor moved to SynchronousMachines</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   <li> v1.53  2005/10/14 Anton Haumer<br>
//        introduced unsymmetrical DamperCage for Synchronous Machines</li>
//   <li> v1.6.2 2005/10/23 Anton Haumer<br>
//        selectable DamperCage for Synchronous Machines</li>
//   <li> v1.6.3 2005/11/25 Anton Haumer<br>
//        easier parametrisation of AsynchronousInductionMachines.AIM_SlipRing model</li>
//   <li> v1.7.1 2006/02/06 Anton Haumer<br>
//        changed some naming of synchronous machines, not affecting existing models</li>
//   </ul>
// <HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {0,127,255}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -60.0, -60.0},{60.0,60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -80.0, -60.0},{ -60.0,60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{60.0, -10.0},{80.0,10.0}}),Rectangle(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, extent = {{ -59.66,50.0},{20.34,70.0}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -70.0, -90.0},{ -60.0, -90.0},{ -30.0, -20.0},{20.0, -20.0},{50.0, -90.0},{60.0, -90.0},{60.0, -100.0},{ -70.0, -100.0},{ -70.0, -90.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         package AsynchronousInductionMachines "Models of asynchronous induction machines"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains models of asynchronous induction machines, based on space phasor theory:
// <ul>
// <li>AIM_SquirrelCage: asynchronous induction machine with squirrel cage</li>
// <li>AIM_SlipRing: asynchronous induction machine with wound rotor</li>
// </ul>
// These models use package SpacePhasors.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.02 2004/09/19 Anton Haumer</li>
//   <li> v1.03 2004/09/24 Anton Haumer<br>
//        consistent naming of inductors and resistors in machine models</li>
//   <li> v1.1  2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.2  2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.3.2 2004/11/10 Anton Haumer<br>
//        ReluctanceRotor moved to SynchronousMachines</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   <li> v1.6.3 2005/11/25 Anton Haumer<br>
//        easier parametrisation of SlipRing model</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model AIM_SquirrelCage "Asynchronous induction machine with squirrel cage rotor"
//             extends Machines.Interfaces.PartialBasicInductionMachine;
//             constant Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//             parameter Modelica.SIunits.Resistance Rs = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//             parameter Modelica.SIunits.Inductance Lssigma = (3 * (1 - sqrt(1 - 0.0667))) / (2 * pi * fNominal) "|Nominal resistances and inductances|stator stray inductance per phase";
//             parameter Modelica.SIunits.Inductance Lm = (3 * sqrt(1 - 0.0667)) / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance";
//             parameter Modelica.SIunits.Inductance Lrsigma = (3 * (1 - sqrt(1 - 0.0667))) / (2 * pi * fNominal) "|Nominal resistances and inductances|rotor stray inductance";
//             parameter Modelica.SIunits.Resistance Rr = 0.04 "|Nominal resistances and inductances|warm rotor resistance";
//             output Modelica.SIunits.Current i_0_s(stateSelect = StateSelect.default) = spacePhasorS.zero.i "stator zero-sequence current";
//             output Modelica.SIunits.Current idq_ss[2] = airGapS.i_ss "stator space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_sr[2](each stateSelect = StateSelect.prefer) = airGapS.i_sr "stator space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current idq_rs[2] = airGapS.i_rs "rotor space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_rr[2](each stateSelect = StateSelect.prefer) = airGapS.i_rr "rotor space phasor current / rotor fixed frame";
//             Modelica.Electrical.MultiPhase.Basic.Resistor rs(final m = m, final R = fill(Rs, m)) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lssigma(final m = m, final L = fill(Lssigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "AIMC", Documentation(info = "<HTML>
// <p>
// <b>Model of a three phase asynchronous induction machine with squirrel cage.</b><br>
// Resistance and stray inductance of stator is modeled directly in stator phases, then using space phasor transformation. Resistance and stray inductance of rotor's squirrel cage is modeled in two axis of the rotor-fixed ccordinate system. Both together connected via a stator-fixed <i>AirGap</i> model. Only losses in stator and rotor resistance are taken into account.
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>number of pole pairs p</td>
// <td>2</td><td> </td>
// </tr>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal frequency fNominal</td>
// <td>50</td><td>Hz</td>
// </tr>
// <tr>
// <td>nominal voltage per phase</td>
// <td>100</td><td>V RMS</td>
// </tr>
// <tr>
// <td>nominal current per phase</td>
// <td>100</td><td>A RMS</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>161.4</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1440.45</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>24.346</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>92.7</td><td>%</td>
// </tr>
// <tr>
// <td>power factor</td>
// <td>0.875</td><td> </td>
// </tr>
// <tr>
// <td>stator resistance</td>
// <td>0.03</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>rotor resistance</td>
// <td>0.04</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>stator reactance Xs</td>
// <td>3</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>rotor reactance Xr</td>
// <td>3</td><td>Ohm</td>
// </tr>
// <tr>
// <td>total stray coefficient sigma</td>
// <td>0.0667</td><td> </td>
// </tr>
// <tr>
// <td>These values give the following inductances, <br>assuming equal stator and rotor stray inductances:</td>
// <td> </td><td> </td>
// </tr>
// <tr>
// <td>stator stray inductance per phase</td>
// <td>Xs * (1 - sqrt(1-sigma))/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>rotor stray inductance</td>
// <td>Xr * (1 - sqrt(1-sigma))/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance per phase</td>
// <td>sqrt(Xs*Xr * (1-sigma))/(2*pi*fNominal)</td><td> </td>
// </tr>
// </table>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorS annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapS airGapS(final p = p, final Lm = Lm) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage squirrelCageR(final Lrsigma = Lrsigma, final Rr = Rr) annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//           equation 
//             connect(airGapS.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapS.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{28.0,0.0},{28.0, -0.0},{60.0,0.0}}));
//             connect(spacePhasorS.plug_n,plug_sn) annotation(Line(visible = true, points = {{ -10.0,40.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_p,plug_sp) annotation(Line(visible = true, points = {{60.0,60.0},{60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_n,lssigma.plug_p) annotation(Line(visible = true, points = {{40.0,60.0},{30.0,60.0}}, color = {0,0,255}));
//             connect(lssigma.plug_n,spacePhasorS.plug_p) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}, color = {0,0,255}));
//             connect(spacePhasorS.ground,spacePhasorS.zero) annotation(Line(visible = true, points = {{ -10.0,20.0},{ -10.0,14.0},{ -0.0,14.0},{0.0,20.0}}, color = {0,0,255}));
//             connect(spacePhasorS.spacePhasor,airGapS.spacePhasor_s) annotation(Line(visible = true, points = {{10.0,20.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(airGapS.spacePhasor_r,squirrelCageR.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -20.0}}, color = {0,0,255}));
//           end AIM_SquirrelCage;
//           model AIM_SlipRing "Asynchronous induction machine with slipring rotor"
//             extends Interfaces.PartialBasicInductionMachine;
//             constant Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//             parameter Modelica.SIunits.Resistance Rs = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//             parameter Modelica.SIunits.Inductance Lssigma = (3 * (1 - sqrt(1 - 0.0667))) / (2 * pi * fNominal) "|Nominal resistances and inductances|stator stray inductance per phase";
//             parameter Modelica.SIunits.Inductance Lm = (3 * sqrt(1 - 0.0667)) / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance";
//             parameter Modelica.SIunits.Inductance Lrsigma = (3 * (1 - sqrt(1 - 0.0667))) / (2 * pi * fNominal) "|Nominal resistances and inductances|rotor stray inductance per phase";
//             parameter Modelica.SIunits.Resistance Rr = 0.04 "|Nominal resistances and inductances|warm rotor resistance per phase";
//             parameter Boolean useTurnsRatio = true "use TurnsRatio or calculate from locked-rotor voltage?";
//             parameter Real TurnsRatio(final min = Modelica.Constants.small) = 1 "(ws*xis) / (wr*xir)" annotation(Dialog(enable = useTurnsRatio));
//             parameter Modelica.SIunits.Voltage VsNom = 100 "Nominal stator voltage per phase" annotation(Dialog(enable = not useTurnsRatio));
//             parameter Modelica.SIunits.Voltage Vr_LR = (100 * 2 * pi * fNominal * Lm) / sqrt(Rs ^ 2 + (2 * pi * fNominal * (Lm + Lssigma)) ^ 2) "Locked-rotor voltage per phase" annotation(Dialog(enable = not useTurnsRatio));
//             output Modelica.SIunits.Current i_0_s(stateSelect = StateSelect.prefer) = spacePhasorS.zero.i "stator zero-sequence current";
//             output Modelica.SIunits.Current idq_ss[2] = airGapS.i_ss "stator space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_sr[2](each stateSelect = StateSelect.prefer) = airGapS.i_sr "stator space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current idq_rs[2] = airGapS.i_rs "rotor space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_rr[2](each stateSelect = StateSelect.prefer) = airGapS.i_rr "rotor space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current i_0_r = spacePhasorR.zero.i "rotor zero-sequence current";
//             output Modelica.SIunits.Voltage vr[m] = plug_rp.pin.v - plug_rn.pin.v "rotor instantaneous voltages";
//             output Modelica.SIunits.Current ir[m] = plug_rp.pin.i "rotor instantaneous currents";
//             Modelica.Electrical.MultiPhase.Basic.Resistor rs(final m = m, final R = fill(Rs, m)) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lssigma(final m = m, final L = fill(Lssigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Ideal.IdealTransformer IdealTransformer1(final m = m, final n = fill(1 / internalTurnsRatio, m)) annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.MultiPhase.Basic.Star Star1(final m = m) annotation(Placement(visible = true, transformation(origin = { -30.0, -50.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -50.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lrsigma(final m = m, final L = fill(Lrsigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0, -80.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Resistor rr(final m = m, final R = fill(Rr, m)) annotation(Placement(visible = true, transformation(origin = {50.0, -80.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_rp(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_rn(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0, -60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "AIMS", Documentation(info = "<HTML>
// <p>
// <b>Model of a three phase asynchronous induction machine with slipring rotor.</b><br>
// Resistance and stray inductance of stator and rotor are modeled directly in stator respectively rotor phases, then using space phasor transformation and a stator-fixed <i>AirGap</i> model. Only losses in stator and rotor resistance are taken into account.
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>number of pole pairs p</td>
// <td>2</td><td> </td>
// </tr>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal frequency fNominal</td>
// <td>50</td><td>Hz</td>
// </tr>
// <tr>
// <td>nominal voltage per phase</td>
// <td>100</td><td>V RMS</td>
// </tr>
// <tr>
// <td>nominal current per phase</td>
// <td>100</td><td>A RMS</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>161.4</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1440.45</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>24.346</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>92.7</td><td>%</td>
// </tr>
// <tr>
// <td>power factor</td>
// <td>0.875</td><td> </td>
// </tr>
// <tr>
// <td>stator resistance</td>
// <td>0.03</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>rotor resistance</td>
// <td>0.04</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>stator reactance Xs</td>
// <td>3</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>rotor reactance Xr</td>
// <td>3</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>total stray coefficient sigma</td>
// <td>0.0667</td><td> </td>
// </tr>
// <tr>
// <td>TurnsRatio</td>
// <td>1</td><td>effective ratio of stator and rotor current (ws*xis) / (wr*xir)</td>
// </tr>
// <tr>
// <td>These values give the following inductances:</td>
// <td> </td><td> </td>
// </tr>
// <tr>
// <td>stator stray inductance per phase</td>
// <td>Xs * (1 - sqrt(1-sigma))/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>rotor stray inductance</td>
// <td>Xr * (1 - sqrt(1-sigma))/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance per phase</td>
// <td>sqrt(Xs*Xr * (1-sigma))/(2*pi*f)</td><td> </td>
// </tr>
// </table>
// </p>
// <p>
// Parameter TurnsRatio could be obtained from the following relationship 
// at standstill with open rotor circuit at nominal voltage and nominal frequency, <br>
// using the locked-rotor voltage VR, no-load stator current I0 and powerfactor PF0:<br>
// TurnsRatio * <u>V</u><sub>R</sub> = <u>V</u><sub>s</sub> - (R<sub>s</sub> + j X<sub>s,sigma</sub>) <u>I</u><sub>0</sub>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100.0,50.0},{ -100.0,20.0},{ -60.0,20.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -50.0},{ -100.0, -20.0},{ -60.0, -20.0}}, color = {0,0,255})}));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorS annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapS airGapS(final p = p, final Lm = Lm) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorR annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation =  -450)));
//           protected 
//             parameter Real internalTurnsRatio = if useTurnsRatio then TurnsRatio else (VsNom / Vr_LR * 2 * pi * fNominal * Lm) / sqrt(Rs ^ 2 + (2 * pi * fNominal * (Lm + Lssigma)) ^ 2);
// 
//           equation 
//             connect(spacePhasorR.plug_p,IdealTransformer1.plug_p2) annotation(Line(visible = true, points = {{10.0, -40.0},{10.0, -50.0}}, color = {0,0,255}));
//             connect(spacePhasorR.plug_n,IdealTransformer1.plug_n2) annotation(Line(visible = true, origin = { -10.0, -45.0}, points = {{0.0,5.0},{ -0.0, -5.0}}, color = {0,0,255}));
//             connect(IdealTransformer1.plug_p1,lrsigma.plug_n) annotation(Line(visible = true, points = {{10.0, -70.0},{10.0, -80.0}}, color = {0,0,255}));
//             connect(Star1.plug_p,IdealTransformer1.plug_n2) annotation(Line(visible = true, points = {{ -20.0, -50.0},{ -10.0, -50.0}}, color = {0,0,255}));
//             connect(IdealTransformer1.plug_n1,plug_rn) annotation(Line(visible = true, points = {{ -10.0, -70.0},{ -10.0, -80.0},{ -60.0, -80.0},{ -60.0, -60.0},{ -100.0, -60.0}}, color = {0,0,255}));
//             connect(spacePhasorS.spacePhasor,airGapS.spacePhasor_s) annotation(Line(visible = true, origin = {10.0,15.0}, points = {{0.0,5.0},{0.0, -5.0}}, color = {0,0,255}));
//             connect(spacePhasorS.ground,spacePhasorS.zero) annotation(Line(visible = true, points = {{ -10.0,20.0},{ -10.0,14.0},{0.0,14.0},{0.0,20.0}}, color = {0,0,255}));
//             connect(lssigma.plug_n,spacePhasorS.plug_p) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}, color = {0,0,255}));
//             connect(plug_sn,spacePhasorS.plug_n) annotation(Line(visible = true, points = {{ -60.0,100.0},{ -60.0,60.0},{ -10.0,60.0},{ -10.0,40.0}}, color = {0,0,255}));
//             connect(airGapS.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapS.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{25.0,0.0},{25.0, -0.0},{60.0,0.0}}));
//             connect(rs.plug_p,plug_sp) annotation(Line(visible = true, points = {{60.0,60.0},{60.0,100.0}}, color = {0,0,255}));
//             connect(rr.plug_p,plug_rp) annotation(Line(visible = true, points = {{60.0, -80.0},{60.0, -90.0},{ -80.0, -90.0},{ -80.0,60.0},{ -100.0,60.0}}, color = {0,0,255}));
//             connect(Star1.pin_n,Ground1.p) annotation(Line(visible = true, points = {{ -40.0, -50.0},{ -50.0, -50.0}}, color = {0,0,255}));
//             connect(rr.plug_n,lrsigma.plug_p) annotation(Line(visible = true, points = {{40.0, -80.0},{30.0, -80.0}}, color = {0,0,255}));
//             connect(rs.plug_n,lssigma.plug_p) annotation(Line(visible = true, points = {{40.0,60.0},{30.0,60.0}}, color = {0,0,255}));
//             connect(spacePhasorR.ground,spacePhasorR.zero) annotation(Line(visible = true, points = {{ -10.0, -20.0},{ -10.0, -14.0},{ -0.0, -14.0},{ -0.0, -20.0}}, color = {0,0,255}));
//             connect(airGapS.spacePhasor_r,spacePhasorR.spacePhasor) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -20.0}}, color = {0,0,255}));
//           end AIM_SlipRing;
//         end AsynchronousInductionMachines;
//         package SynchronousInductionMachines "Models of synchronous induction machines"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains models of synchronous induction machines, based on space phasor theory:
// <ul>
// <li>SM_PermanentMagnetDamperCage: synchronous induction machine with permanent magnet excitation, with damper cage</li>
// <li>SM_ElectricalExcitedDamperCage: synchronous induction machine with electrical excitation 
//     and damper cage</li>
// <li>SM_ReluctanceRotorDamperCage: induction machine with reluctance rotor and damper cage<br>
// i.e. a squirrel cage rotor with magnetic poles due to different airgap width</li>
// </ul>
// These models use package SpacePhasors.
// </p>
// <p>
// <b>Please keep in mind:</b><br>
// <ul>
// <li>We keep the same reference system as for motors, i.e.:<br>
//     Positive RotorDisplacementAngle means acting as motor,<br>
//     with positive electric power consumption and positive mechanical power output.
// <li>ElectricalAngle = p * MechanicalAngle</li>
// <li>real axis = d-axis<br>
//     imaginary= q-axis</li>
// <li>Voltage induced by the magnet wheel (d-axis) is located in the q-axis.</li>
// </ul>
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.02  2004/09/19 Anton Haumer</li>
//   <li> v1.03  2004/09/24 Anton Haumer<br>
//        consistent naming of inductors and resistors in machine models</li>
//   <li> v1.1   2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.2   2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.3.2 2004/11/10 Anton Haumer<br>
//        ReluctanceRotor moved to SynchronousMachines</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   <li> v1.52  2005/10/12 Anton Haumer<br>
//        added SM_ElectricalExcited</li>
//   <li> v1.53  2005/10/14 Anton Haumer<br>
//        introduced unsymmetrical DamperCage for Synchronous Machines</li>
//   <li> v1.6.2 2005/10/23 Anton Haumer<br>
//        selectable DamperCage for Synchronous Machines</li>
//   <li> v1.7.1 2006/02/06 Anton Haumer<br>
//        changed some naming of synchronous machines, not affecting existing models</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model SM_PermanentMagnetDamperCage "Permanent magnet synchronous induction machine"
//             extends Interfaces.PartialBasicInductionMachine;
//             parameter Modelica.SIunits.Frequency fNominal = 50 "|Excitation|nominal frequency";
//             parameter Modelica.SIunits.Voltage V0 = 112.3 "|Excitation|no-load RMS voltage per phase @ fNominal";
//             parameter Modelica.SIunits.Resistance Rs = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//             parameter Modelica.SIunits.Inductance Lssigma = 0.1 / (2 * pi * fNominal) "|Nominal resistances and inductances|stator stray inductance per phase";
//             parameter Modelica.SIunits.Inductance Lmd = 0.3 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in d-axis";
//             parameter Modelica.SIunits.Inductance Lmq = 0.3 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in q-axis";
//             parameter Boolean DamperCage = true "damper cage is present?" annotation(Dialog(group = "DamperCage"));
//             parameter Modelica.SIunits.Inductance Lrsigma = 0.05 / (2 * pi * fNominal) "damper stray inductance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Inductance Lrsigmaq = Lrsigma "damper stray inductance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rr = 0.04 "warm damper resistance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rrq = Rr "warm damper resistance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             output Modelica.SIunits.Current i_0_s(stateSelect = StateSelect.default) = spacePhasorS.zero.i "stator zero-sequence current";
//             output Modelica.SIunits.Current idq_ss[2] = airGapR.i_ss "stator space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_sr[2](each stateSelect = StateSelect.prefer) = airGapR.i_sr "stator space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current idq_dr[2](each stateSelect = StateSelect.prefer) = damperCage.spacePhasor_r.i_ if DamperCage "damper space phasor current / rotor fixed frame";
//             Modelica.Electrical.MultiPhase.Basic.Resistor rs(final m = m, final R = fill(Rs, m)) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lssigma(final m = m, final L = fill(Lssigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "SMPM", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {0,255,0}, fillPattern = FillPattern.Solid, extent = {{ -130.0,10.0},{ -100.0, -10.0}}),Rectangle(visible = true, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -100.0,10.0},{ -70.0, -10.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -134.0,34.0},{ -66.0, -34.0}})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a three phase permanent magnet synchronous induction machine.</b><br>
// Resistance and stray inductance of stator is modeled directly in stator phases, then using space phasor transformation and a rotor-fixed <i>AirGap</i> model. Resistance and stray inductance of rotor's squirrel cage is modeled in two axis of the rotor-fixed ccordinate system. Permanent magnet excitation is modelled by a constant equivalent excitation current feeding the d-axis. Only losses in stator and damper resistance are taken into account.
// </p>
// <p>
// Whether a damper cage is present or not, can be selected with Boolean parameter DamperCage (default = true).
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>number of pole pairs p</td>
// <td>2</td><td> </td>
// </tr>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal frequency fNominal</td>
// <td>50</td><td>Hz</td>
// </tr>
// <tr>
// <td>nominal voltage per phase</td>
// <td>100</td><td>V RMS</td>
// </tr>
// <tr>
// <td>no-load voltage per phase</td>
// <td>112.3</td><td>V RMS @ nominal speed</td>
// </tr>
// <tr>
// <td>nominal current per phase</td>
// <td>100</td><td>A RMS</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>181.4</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1500</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>28.5</td><td>kW</td>
// </tr>
// <tr>
// <td>nominal rotor angle</td>
// <td>20.75</td><td>degree</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>95.0</td><td>%</td>
// </tr>
// <tr>
// <td>power factor</td>
// <td>0.98</td><td> </td>
// </tr>
// <tr>
// <td>stator resistance</td>
// <td>0.03</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>stator reactance Xd</td>
// <td>0.4</td><td>Ohm per phase in d-axis</td>
// </tr>
// <tr>
// <td>stator reactance Xq</td>
// <td>0.4</td><td>Ohm per phase in q-axis</td>
// </tr>
// <tr>
// <td>stator stray reactance Xss</td>
// <td>0.1</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>damper resistance in d-axis</td>
// <td>0.04</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>damper resistance in q-axis</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>damper stray reactance in d-axis XDds</td>
// <td>0.05</td><td>Ohm</td>
// </tr>
// <tr>
// <td>damper stray reactance in q-axis XDqs</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>These values give the following inductances:</td>
// <td> </td><td> </td>
// </tr>
// <tr>
// <td>main field inductance in d-axis</td>
// <td>(Xd - Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance in q-axis</td>
// <td>(Xq - Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>stator stray inductance per phase</td>
// <td>Xss/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>damper stray inductance in d-axis</td>
// <td>XDds/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>damper stray inductance in q-axis</td>
// <td>XDqs/(2*pi*fNominal)</td><td> </td>
// </tr>
// </table>
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorS annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapR airGapR(final p = p, final Lmd = Lmd, final Lmq = Lmq) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.BasicMachines.Components.DamperCage damperCage(final Lrsigma = Lrsigma, final Lrsigmaq = Lrsigmaq, final Rr = Rr, final Rrq = Rrq) if DamperCage annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.BasicMachines.Components.PermanentMagnet permanentMagnet(Ie = Ie) annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           protected 
//             parameter Modelica.SIunits.Current Ie = (sqrt(2) * V0) / (Lmd * 2 * pi * fNominal) "equivalent excitation current";
// 
//           equation 
//             connect(airGapR.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapR.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{25.0,0.0},{25.0, -0.0},{60.0,0.0}}));
//             connect(spacePhasorS.plug_n,plug_sn) annotation(Line(visible = true, points = {{ -10.0,40.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_p,plug_sp) annotation(Line(visible = true, points = {{60.0,60.0},{60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_n,lssigma.plug_p) annotation(Line(visible = true, points = {{40.0,60.0},{30.0,60.0}}, color = {0,0,255}));
//             connect(lssigma.plug_n,spacePhasorS.plug_p) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}, color = {0,0,255}));
//             connect(spacePhasorS.ground,spacePhasorS.zero) annotation(Line(visible = true, points = {{ -10.0,20.0},{ -10.0,14.0},{ -0.0,14.0},{0.0,20.0}}, color = {0,0,255}));
//             connect(spacePhasorS.spacePhasor,airGapR.spacePhasor_s) annotation(Line(visible = true, points = {{10.0,20.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(airGapR.spacePhasor_r,damperCage.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -20.0}}, color = {0,0,255}));
//             connect(airGapR.spacePhasor_r,permanentMagnet.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{20.0, -10.0},{20.0, -50.0},{10.0, -50.0}}, color = {0,0,255}));
//           end SM_PermanentMagnetDamperCage;
//           model SM_ElectricalExcitedDamperCage "Electrical excited synchronous induction machine with damper cage"
//             extends Interfaces.PartialBasicInductionMachine;
//             parameter Modelica.SIunits.Resistance Rs = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//             parameter Modelica.SIunits.Inductance Lssigma = 0.1 / (2 * pi * fNominal) "|Nominal resistances and inductances|stator stray inductance per phase";
//             parameter Modelica.SIunits.Inductance Lmd = 1.5 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in d-axis";
//             parameter Modelica.SIunits.Inductance Lmq = 1.5 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in q-axis";
//             parameter Boolean DamperCage = true "damper cage is present?" annotation(Dialog(group = "DamperCage"));
//             parameter Modelica.SIunits.Inductance Lrsigma = 0.05 / (2 * pi * fNominal) "damper stray inductance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Inductance Lrsigmaq = Lrsigma "damper stray inductance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rr = 0.04 "warm damper resistance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rrq = Rr "warm damper resistance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Voltage VNominal = 100 "|Excitation|nominal stator RMS voltage per phase";
//             parameter Modelica.SIunits.Frequency fNominal = 50 "|Excitation|nominal frequency";
//             parameter Modelica.SIunits.Current Ie0 = 10 "|Excitation|no-load excitation current @ nominal voltage and frequency";
//             parameter Modelica.SIunits.Resistance Re = 2.5 "|Excitation|warm excitation resistance";
//             parameter Real sigmae(min = 0, max = 1) = 0.025 "|Excitation|stray fraction of total excitation inductance";
//             output Modelica.SIunits.Current i_0_s(stateSelect = StateSelect.default) = spacePhasorS.zero.i "stator zero-sequence current";
//             output Modelica.SIunits.Current idq_ss[2] = airGapR.i_ss "stator space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_sr[2](each stateSelect = StateSelect.prefer) = airGapR.i_sr "stator space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current idq_dr[2](each stateSelect = StateSelect.prefer) = damperCage.spacePhasor_r.i_ if DamperCage "damper space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Voltage ve = pin_ep.v - pin_en.v "excitation voltage";
//             output Modelica.SIunits.Current ie = pin_ep.i "excitation current";
//             Modelica.Electrical.MultiPhase.Basic.Resistor rs(final m = m, final R = fill(Rs, m)) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lssigma(final m = m, final L = fill(Lssigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Resistor re(final R = Re) annotation(Placement(visible = true, transformation(origin = {50.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation =  -180)));
//             Modelica.Electrical.Analog.Basic.Inductor lesigma(final L = Lesigma) annotation(Placement(visible = true, transformation(origin = {20.0, -80.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ep annotation(Placement(visible = true, transformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_en annotation(Placement(visible = true, transformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "SMEE", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -134.0,34.0},{ -66.0, -34.0}}),Line(visible = true, points = {{ -100.0,50.0},{ -100.0,20.0},{ -130.0,20.0},{ -130.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -130.0, -4.0},{ -129.0,1.0},{ -125.0,5.0},{ -120.0,6.0},{ -115.0,5.0},{ -111.0,1.0},{ -110.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -110.0, -4.0},{ -109.0,1.0},{ -105.0,5.0},{ -100.0,6.0},{ -95.0,5.0},{ -91.0,1.0},{ -90.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -90.0, -4.0},{ -89.0,1.0},{ -85.0,5.0},{ -80.0,6.0},{ -75.0,5.0},{ -71.0,1.0},{ -70.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -50.0},{ -100.0, -20.0},{ -70.0, -20.0},{ -70.0, -2.0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a three phase electrical excited synchronous induction machine with damper cage.</b><br>
// Resistance and stray inductance of stator is modeled directly in stator phases, then using space phasor transformation and a rotor-fixed <i>AirGap</i> model. Resistance and stray inductance of rotor's squirrel cage is modeled in two axis of the rotor-fixed ccordinate system. Electrical excitation is modelled by converting excitation current and voltage to d-axis space phasors. Only losses in stator, damper and excitation resistance are taken into account.
// </p>
// <p>
// Whether a damper cage is present or not, can be selected with Boolean parameter DamperCage (default = true).
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>number of pole pairs p</td>
// <td>2</td><td> </td>
// </tr>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal frequency fNominal</td>
// <td>50</td><td>Hz</td>
// </tr>
// <tr>
// <td>nominal voltage per phase</td>
// <td>100</td><td>V RMS</td>
// </tr>
// <tr>
// <td>no-load excitation current<br>
//     @ nominal voltage and frequency</td>
// <td>10</td><td>A DC</td>
// </tr>
// <tr>
// <td>warm excitation resistance</td>
// <td>2.5</td><td>Ohm</td>
// </tr>
// <tr>
// <td>nominal current per phase</td>
// <td>100</td><td>A RMS</td>
// </tr>
// <tr>
// <td>nominal apparent power</td>
// <td>-30000</td><td>VA</td>
// </tr>
// <tr>
// <td>power factor</td>
// <td>-1.0</td><td>ind./cap.</td>
// </tr>
// <tr>
// <td>nominal excitation current</td>
// <td>19</td><td>A</td>
// </tr>
// <tr>
// <td>efficiency w/o excitation</td>
// <td>97.1</td><td>%</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>-196.7</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1500</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal rotor angle</td>
// <td>-57.23</td><td>degree</td>
// </tr>
// <tr>
// <td>stator resistance</td>
// <td>0.03</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>stator reactance Xd</td>
// <td>1.6</td><td>Ohm per phase in d-axis</td>
// </tr>
// <tr>
// <td>giving Kc</td>
// <td>0.625</td><td> </td>
// </tr>
// <tr>
// <td>stator reactance Xq</td>
// <td>1.6</td><td>Ohm per phase in q-axis</td>
// </tr>
// <tr>
// <td>stator stray reactance Xss</td>
// <td>0.1</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>damper resistance in d-axis</td>
// <td>0.04</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>damper resistance in q-axis</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>damper stray reactance in d-axis XDds</td>
// <td>0.1</td><td>Ohm</td>
// </tr>
// <tr>
// <td>damper stray reactance in q-axis XDqs</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>excitation stray inductance</td>
// <td>2.5</td><td>% of total excitation inductance</td>
// </tr>
// <tr>
// <td>These values give the following inductances:</td>
// <td> </td><td> </td>
// </tr>
// <tr>
// <td>main field inductance in d-axis</td>
// <td>(Xd - Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance in q-axis</td>
// <td>(Xq - Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>stator stray inductance per phase</td>
// <td>Xss/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>damper stray inductance in d-axis</td>
// <td>XDds/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>damper stray inductance in q-axis</td>
// <td>XDqs/(2*pi*fNominal)</td><td> </td>
// </tr>
// </table>
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorS annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapR airGapR(final p = p, final Lmd = Lmd, final Lmq = Lmq) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.BasicMachines.Components.DamperCage damperCage(final Lrsigma = Lrsigma, final Lrsigmaq = Lrsigmaq, final Rr = Rr, final Rrq = Rrq) if DamperCage annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -450)));
//             Modelica.Electrical.Machines.BasicMachines.Components.ElectricalExcitation electricalExcitation(final TurnsRatio = TurnsRatio) annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//           protected 
//             parameter Real TurnsRatio = (sqrt(2) * VNominal) / (2 * pi * fNominal * Lmd * Ie0) "stator current / excitation current";
//             parameter Modelica.SIunits.Inductance Lesigma = (Lmd * TurnsRatio ^ 2 * sigmae) / (1 - sigmae);
// 
//           equation 
//             connect(airGapR.spacePhasor_r,damperCage.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -20.0}}, color = {0,0,255}));
//             connect(airGapR.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapR.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{25.0,0.0},{25.0, -0.0},{60.0,0.0}}));
//             connect(spacePhasorS.plug_n,plug_sn) annotation(Line(visible = true, points = {{ -10.0,40.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_p,plug_sp) annotation(Line(visible = true, points = {{60.0,60.0},{60.0,100.0}}, color = {0,0,255}));
//             connect(lesigma.p,re.n) annotation(Line(visible = true, points = {{30.0, -80.0},{40.0, -80.0}}, color = {0,0,255}));
//             connect(pin_ep,re.p) annotation(Line(visible = true, points = {{ -100.0,60.0},{ -80.0,60.0},{ -80.0, -90.0},{60.0, -90.0},{60.0, -80.0}}, color = {0,0,255}));
//             connect(rs.plug_n,lssigma.plug_p) annotation(Line(visible = true, points = {{40.0,60.0},{30.0,60.0}}, color = {0,0,255}));
//             connect(lssigma.plug_n,spacePhasorS.plug_p) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}, color = {0,0,255}));
//             connect(spacePhasorS.ground,spacePhasorS.zero) annotation(Line(visible = true, points = {{ -10.0,20.0},{ -10.0,14.0},{ -0.0,14.0},{0.0,20.0}}, color = {0,0,255}));
//             connect(spacePhasorS.spacePhasor,airGapR.spacePhasor_s) annotation(Line(visible = true, points = {{10.0,20.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(electricalExcitation.pin_en,pin_en) annotation(Line(visible = true, points = {{ -10.0, -70.0},{ -70.0, -70.0},{ -70.0, -60.0},{ -100.0, -60.0}}, color = {0,0,255}));
//             connect(lesigma.n,electricalExcitation.pin_ep) annotation(Line(visible = true, points = {{10.0, -80.0},{10.0, -70.0}}, color = {0,0,255}));
//             connect(airGapR.spacePhasor_r,electricalExcitation.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{20.0, -10.0},{20.0, -50.0},{10.0, -50.0}}, color = {0,0,255}));
//           end SM_ElectricalExcitedDamperCage;
//           model SM_ReluctanceRotorDamperCage "Synchronous induction machine with reluctance rotor and damper cage"
//             extends Interfaces.PartialBasicInductionMachine;
//             constant Modelica.SIunits.Frequency fNominal = 50 "nominal frequency";
//             parameter Modelica.SIunits.Resistance Rs = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//             parameter Modelica.SIunits.Inductance Lssigma = 0.1 / (2 * pi * fNominal) "|Nominal resistances and inductances|stator stray inductance per phase";
//             parameter Modelica.SIunits.Inductance Lmd = 2.9 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in d-axis";
//             parameter Modelica.SIunits.Inductance Lmq = 0.9 / (2 * pi * fNominal) "|Nominal resistances and inductances|main field inductance in q-axis";
//             parameter Boolean DamperCage = true "damper cage is present?" annotation(Dialog(group = "DamperCage"));
//             parameter Modelica.SIunits.Inductance Lrsigma = 0.05 / (2 * pi * fNominal) "damper stray inductance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Inductance Lrsigmaq = Lrsigma "damper stray inductance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rr = 0.04 "warm damper resistance in d-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             parameter Modelica.SIunits.Resistance Rrq = Rr "warm damper resistance in q-axis" annotation(Dialog(group = "DamperCage", enable = DamperCage));
//             output Modelica.SIunits.Current i_0_s(stateSelect = StateSelect.default) = spacePhasorS.zero.i "stator zero-sequence current";
//             output Modelica.SIunits.Current idq_ss[2] = airGapR.i_ss "stator space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_sr[2](each stateSelect = StateSelect.prefer) = airGapR.i_sr "stator space phasor current / rotor fixed frame";
//             output Modelica.SIunits.Current idq_rs[2] = airGapR.i_rs if DamperCage "rotor space phasor current / stator fixed frame";
//             output Modelica.SIunits.Current idq_rr[2](each stateSelect = StateSelect.prefer) = airGapR.i_rr if DamperCage "rotor space phasor current / rotor fixed frame";
//             Modelica.Electrical.MultiPhase.Basic.Resistor rs(final m = m, final R = fill(Rs, m)) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Basic.Inductor lssigma(final m = m, final L = fill(Lssigma, m)) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "SMR", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -130.0,10.0},{ -100.0, -10.0}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0,10.0},{ -70.0, -10.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -134.0,34.0},{ -66.0, -34.0}})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a three phase synchronous induction machine with reluctance rotor and damper cage.</b><br>
// Resistance and stray inductance of stator is modeled directly in stator phases, then using space phasor transformation. Resistance and stray inductance of rotor's squirrel cage is modeled in two axis of the rotor-fixed ccordinate system. Both together connected via a rotor-fixed <i>AirGap</i> model. Only losses in stator and rotor resistance are taken into account.
// </p>
// <p>
// Whether a damper cage is present or not, can be selected with Boolean parameter DamperCage (default = true).
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>number of pole pairs p</td>
// <td>2</td><td> </td>
// </tr>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal frequency fNominal</td>
// <td>50</td><td>Hz</td>
// </tr>
// <tr>
// <td>nominal voltage per phase</td>
// <td>100</td><td>V RMS</td>
// </tr>
// <tr>
// <td>nominal current per phase</td>
// <td>50</td><td>A RMS</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td> 46</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1500</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td> 7.23</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>96.98</td><td>%</td>
// </tr>
// <tr>
// <td>power factor</td>
// <td>0.497</td><td> </td>
// </tr>
// <tr>
// <td>stator resistance</td>
// <td>0.03</td><td>Ohm per phase in warm condition</td>
// </tr>
// <tr>
// <td>rotor resistance in d-axis</td>
// <td>0.04</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>rotor resistance in q-axis</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>stator reactance Xsd in d-axis</td>
// <td>3</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>stator reactance Xsq in q-axis</td>
// <td>1</td><td>Ohm</td>
// </tr>
// <tr>
// <td>stator stray reactance Xss</td>
// <td>0.1</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>rotor stray reactance in d-axis Xrds</td>
// <td>0.1</td><td>Ohm per phase</td>
// </tr>
// <tr>
// <td>rotor stray reactance in q-axis Xrqs</td>
// <td>same as d-axis</td><td> </td>
// </tr>
// <tr>
// <td>These values give the following inductances:</td>
// <td> </td><td> </td>
// </tr>
// <tr>
// <td>stator stray inductance per phase</td>
// <td>Xss/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>rotor stray inductance in d-axis</td>
// <td>Xrds/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>rotor stray inductance in q-axis</td>
// <td>Xrqs/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance per phase in d-axis</td>
// <td>(Xsd-Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// <tr>
// <td>main field inductance per phase in q-axis</td>
// <td>(Xsq-Xss)/(2*pi*fNominal)</td><td> </td>
// </tr>
// </table>
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor spacePhasorS annotation(Placement(visible = true, transformation(origin = {0.0,30.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -270)));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapR airGapR(final p = p, final Lmd = Lmd, final Lmq = Lmq) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//             Modelica.Electrical.Machines.BasicMachines.Components.DamperCage damperCage(final Lrsigma = Lrsigma, final Lrsigmaq = Lrsigmaq, final Rr = Rr, final Rrq = Rrq) if DamperCage annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//           equation 
//             connect(airGapR.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -50.0, -0.0},{ -50.0,0.0},{ -90.0,0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapR.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{25.0,0.0},{25.0, -0.0},{60.0,0.0}}));
//             connect(spacePhasorS.plug_n,plug_sn) annotation(Line(visible = true, points = {{ -10.0,40.0},{ -12.0,40.0},{ -12.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_p,plug_sp) annotation(Line(visible = true, points = {{60.0,60.0},{60.0,100.0}}, color = {0,0,255}));
//             connect(rs.plug_n,lssigma.plug_p) annotation(Line(visible = true, points = {{40.0,60.0},{30.0,60.0}}, color = {0,0,255}));
//             connect(lssigma.plug_n,spacePhasorS.plug_p) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,40.0}}, color = {0,0,255}));
//             connect(spacePhasorS.ground,spacePhasorS.zero) annotation(Line(visible = true, points = {{ -10.0,20.0},{ -10.0,14.0},{ -0.0,14.0},{0.0,20.0}}, color = {0,0,255}));
//             connect(spacePhasorS.spacePhasor,airGapR.spacePhasor_s) annotation(Line(visible = true, points = {{10.0,20.0},{10.0,10.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(airGapR.spacePhasor_r,damperCage.spacePhasor_r) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -20.0}}, color = {0,0,255}));
//           end SM_ReluctanceRotorDamperCage;
//         end SynchronousInductionMachines;
//         package DCMachines "Models of DC machines"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains models of DC machines:
// <ul>
// <li>DC_PermanentMagnet: DC machine with permanent magnet excitation</li>
// <li>DC_ElectricalExcited: DC machine with electrical shunt or separate excitation</li>
// <li>DC_SeriesExcited: DC machine with series excitation</li>
// </ul>
// </p>
// 
// </HTML>
// ", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.02 2004/09/19 Anton Haumer</li>
//   <li> v1.03 2004/09/24 Anton Haumer<br>
//        added DC machine with series excitation</li>
//   <li> v1.1  2004/10/01 Anton Haumer<br>
//        changed naming and structure<br>
//        issued to Modelica Standard Library 2.1</li>
//   <li> v1.2  2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model DC_PermanentMagnet "Permanent magnet DC machine"
//             extends Interfaces.PartialBasicDCMachine;
//             parameter Modelica.SIunits.Voltage VaNominal = 100 "|Nominal parameters|nominal armature voltage";
//             parameter Modelica.SIunits.Current IaNominal = 100 "|Nominal parameters|nominal armature current";
//             parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmNominal = 1425 "|Nominal parameters|nominal speed";
//             parameter Modelica.SIunits.Resistance Ra = 0.05 "|Nominal resistances and inductances|warm armature resistance";
//             parameter Modelica.SIunits.Inductance La = 0.0015 "|Nominal resistances and inductances|armature inductance";
//             Modelica.Electrical.Analog.Basic.Resistor ra(final R = Ra) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Inductor la(final L = La) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground eGround annotation(Placement(visible = true, transformation(origin = { -10.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "DCPM", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {0,255,0}, fillPattern = FillPattern.Solid, extent = {{ -130.0,10.0},{ -100.0, -10.0}}),Rectangle(visible = true, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -100.0,10.0},{ -70.0, -10.0}})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a DC Machine with Permanent magnet.</b><br>
// Armature resistance and inductance are modeled directly after the armature pins, then using a <i>AirGapDC</i> model. Permanent magnet excitation is modelled by a constant equivalent excitation current feeding AirGapDC. Only losses in armature resistance are taken into account. No saturation is modelled.
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.15</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal armature voltage</td>
// <td>100</td><td>V</td>
// </tr>
// <tr>
// <td>nominal armature current</td>
// <td>100</td><td>A</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1425</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>63.66</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>9.5</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>95.0</td><td>%</td>
// </tr>
// <tr>
// <td>armature resistance</td>
// <td>0.05</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>armature inductance</td>
// <td>0.0015</td><td>H</td>
// </tr>
// </table>
// Armature resistance resp. inductance include resistance resp. inductance of commutating pole winding and compensation windig, if present.
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapDC airGapDC(final Le = Le, final TurnsRatio = TurnsRatio) annotation(Placement(visible = true, transformation(origin = { -0.0, -0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -450)));
//             Modelica.Electrical.Analog.Sources.ConstantCurrent ie(I = IeNominal) annotation(Placement(visible = true, transformation(origin = {10.0, -40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -270)));
//           protected 
//             constant Modelica.SIunits.Current IeNominal = 1 "equivalent excitation current";
//             constant Modelica.SIunits.Inductance Le = 1 "arbitrary excitation inductance";
//             parameter Real TurnsRatio = (VaNominal - Ra * IaNominal) / (Modelica.SIunits.Conversions.from_rpm(rpmNominal) * Le * IeNominal) "Ratio of armature turns over number of turns of the excitation winding";
// 
//           equation 
//             connect(airGapDC.pin_ep,ie.n) annotation(Line(visible = true, points = {{10.0, -10.0},{10.0, -30.0}}, color = {0,0,255}));
//             connect(airGapDC.pin_en,eGround.p) annotation(Line(visible = true, points = {{ -10.0, -10.0},{ -10.0, -50.0}}, color = {0,0,255}));
//             connect(la.n,airGapDC.pin_ap) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(airGapDC.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{24.0,0.0},{24.0,0.0},{60.0,0.0}}));
//             connect(airGapDC.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0, -0.0},{ -90.0,0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapDC.pin_an,pin_an) annotation(Line(visible = true, points = {{ -10.0,10.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(pin_ap,ra.p) annotation(Line(visible = true, points = {{60.0,100.0},{60.0,60.0}}, color = {0,0,255}));
//             connect(la.p,ra.n) annotation(Line(visible = true, points = {{30.0,60.0},{40.0,60.0}}, color = {0,0,255}));
//             connect(eGround.p,ie.p) annotation(Line(visible = true, points = {{ -10.0, -50.0},{10.0, -50.0}}, color = {0,0,255}));
//             assert(VaNominal > Ra * IaNominal, "VaNominal has to be > (Ra+Re)*IaNominal");
//           end DC_PermanentMagnet;
//           model DC_ElectricalExcited "Electrical shunt/separate excited linear DC machine"
//             extends Machines.Interfaces.PartialBasicDCMachine;
//             parameter Modelica.SIunits.Voltage VaNominal = 100 "|Nominal parameters|nominal armature voltage";
//             parameter Modelica.SIunits.Current IaNominal = 100 "|Nominal parameters|nominal armature current";
//             parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmNominal = 1425 "|Nominal parameters|nominal speed";
//             parameter Modelica.SIunits.Resistance Ra = 0.05 "|Nominal resistances and inductances|warm armature resistance";
//             parameter Modelica.SIunits.Inductance La = 0.0015 "|Nominal resistances and inductances|armature inductance";
//             parameter Modelica.SIunits.Current IeNominal = 1 "|Excitation|nominal excitation current";
//             parameter Modelica.SIunits.Resistance Re = 100 "|Excitation|warm field excitation resistance";
//             parameter Modelica.SIunits.Inductance Le = 1 "|Excitation|total field excitation inductance";
//             output Modelica.SIunits.Voltage ve = pin_ep.v - pin_en.v "Field excitation voltage";
//             output Modelica.SIunits.Current ie = pin_ep.i "Field excitation current";
//             Modelica.Electrical.Analog.Basic.Resistor ra(final R = Ra) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Inductor la(final L = La) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Resistor re(final R = Re) annotation(Placement(visible = true, transformation(origin = { -50.0, -40.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -180)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ep annotation(Placement(visible = true, transformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_en annotation(Placement(visible = true, transformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "DCEE", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -130.0, -4.0},{ -129.0,1.0},{ -125.0,5.0},{ -120.0,6.0},{ -115.0,5.0},{ -111.0,1.0},{ -110.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -110.0, -4.0},{ -109.0,1.0},{ -105.0,5.0},{ -100.0,6.0},{ -95.0,5.0},{ -91.0,1.0},{ -90.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -90.0, -4.0},{ -89.0,1.0},{ -85.0,5.0},{ -80.0,6.0},{ -75.0,5.0},{ -71.0,1.0},{ -70.0, -4.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -50.0},{ -100.0, -20.0},{ -70.0, -20.0},{ -70.0, -2.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,50.0},{ -100.0,20.0},{ -130.0,20.0},{ -130.0, -4.0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a DC Machine with Electrical shunt or separate excitation.</b><br>
// Armature resistance and inductance are modeled directly after the armature pins, then using a <i>AirGapDC</i> model.<br>
// Only losses in armature and excitation resistance are taken into account. No saturation is modelled.<br>
// Shunt or separate excitation is defined by the user's external circuit.
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.15</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal armature voltage</td>
// <td>100</td><td>V</td>
// </tr>
// <tr>
// <td>nominal armature current</td>
// <td>100</td><td>A</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>63.66</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1425</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>9.5</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>95.0</td><td>% only armature</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>94.06</td><td>% including excitation</td>
// </tr>
// <tr>
// <td>armature resistance</td>
// <td>0.05</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>aramture inductance</td>
// <td>0.0015</td><td>H</td>
// </tr>
// <tr>
// <td>nominal excitation voltage</td>
// <td>100</td><td>V</td>
// </tr>
// <tr>
// <td>nominal excitation current</td>
// <td>1</td><td>A</td>
// </tr>
// <tr>
// <td>excitation resistance</td>
// <td>100</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>excitation inductance</td>
// <td>1</td><td>H</td>
// </tr>
// </table>
// Armature resistance resp. inductance include resistance resp. inductance of commutating pole winding and 
// compensation windig, if present.<br>
// Armature current does not cover excitation current of a shunt excitation; in this case total current drawn from the grid = armature current + excitation current.
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapDC airGapDC(final Le = Le, final TurnsRatio = TurnsRatio) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           protected 
//             parameter Real TurnsRatio = (VaNominal - Ra * IaNominal) / (Modelica.SIunits.Conversions.from_rpm(rpmNominal) * Le * IeNominal) "Ratio of armature turns over number of turns of the excitation winding";
// 
//           equation 
//             connect(airGapDC.pin_an,pin_an) annotation(Line(visible = true, points = {{ -10.0,10.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(pin_ap,ra.p) annotation(Line(visible = true, points = {{60.0,100.0},{60.0,60.0}}, color = {0,0,255}));
//             connect(airGapDC.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapDC.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{26.0,0.0},{26.0, -0.0},{60.0,0.0}}));
//             connect(re.p,pin_ep) annotation(Line(visible = true, points = {{ -60.0, -40.0},{ -80.0, -40.0},{ -80.0,60.0},{ -100.0,60.0}}, color = {0,0,255}));
//             connect(la.p,ra.n) annotation(Line(visible = true, points = {{30.0,60.0},{40.0,60.0}}, color = {0,0,255}));
//             connect(la.n,airGapDC.pin_ap) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(re.n,airGapDC.pin_ep) annotation(Line(visible = true, points = {{ -40.0, -40.0},{10.0, -40.0},{10.0, -10.0}}, color = {0,0,255}));
//             connect(airGapDC.pin_en,pin_en) annotation(Line(visible = true, points = {{ -10.0, -10.0},{ -10.0, -60.0},{ -100.0, -60.0}}, color = {0,0,255}));
//             assert(VaNominal > Ra * IaNominal, "VaNominal has to be > (Ra+Re)*IaNominal");
//           end DC_ElectricalExcited;
//           model DC_SeriesExcited "Series excited linear DC machine"
//             extends Machines.Interfaces.PartialBasicDCMachine;
//             parameter Modelica.SIunits.Voltage VaNominal = 100 "|Nominal parameters|nominal armature voltage";
//             parameter Modelica.SIunits.Current IaNominal = 100 "|Nominal parameters|nominal armature current";
//             parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpmNominal = 1402.5 "|Nominal parameters|nominal speed";
//             parameter Modelica.SIunits.Resistance Ra = 0.05 "|Nominal resistances and inductances|warm armature resistance";
//             parameter Modelica.SIunits.Inductance La = 0.0015 "|Nominal resistances and inductances|armature inductance";
//             parameter Modelica.SIunits.Resistance Re = 0.01 "|Excitation|warm field excitation resistance";
//             parameter Modelica.SIunits.Inductance Le = 0.0005 "|Excitation|total field excitation inductance";
//             output Modelica.SIunits.Voltage ve = pin_ep.v - pin_en.v "Field excitation voltage";
//             output Modelica.SIunits.Current ie = pin_ep.i "Field excitation current";
//             Modelica.Electrical.Analog.Basic.Resistor ra(final R = Ra) annotation(Placement(visible = true, transformation(origin = {50.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Inductor la(final L = La) annotation(Placement(visible = true, transformation(origin = {20.0,60.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Resistor re(final R = Re) annotation(Placement(visible = true, transformation(origin = { -50.0, -40.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation =  -180)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ep annotation(Placement(visible = true, transformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0,60.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_en annotation(Placement(visible = true, transformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -60.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 0)));
//             annotation(defaultComponentName = "DCSE", Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100.0, -10.0},{ -105.0, -9.0},{ -109.0, -5.0},{ -110.0,0.0},{ -109.0,5.0},{ -105.0,9.0},{ -100.0,10.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -30.0},{ -105.0, -29.0},{ -109.0, -25.0},{ -110.0, -20.0},{ -109.0, -15.0},{ -105.0, -11.0},{ -100.0, -10.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,10.0},{ -105.0,11.0},{ -109.0,15.0},{ -110.0,20.0},{ -109.0,25.0},{ -105.0,29.0},{ -100.0,30.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,50.0},{ -100.0,30.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -30.0},{ -100.0, -50.0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// <b>Model of a DC Machine with Series excitation.</b><br>
// Armature resistance and inductance are modeled directly after the armature pins, then using a <i>AirGapDC</i> model.<br>
// Only losses in armature and excitation resistance are taken into account. No saturation is modelled.<br>
// Series excitation has to be connected by the user's external circuit.
// </p>
// <p>
// <b>Default values for machine's parameters (a realistic example) are:</b><br>
// <table>
// <tr>
// <td>stator's moment of inertia</td>
// <td>0.29</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>rotor's moment of inertia</td>
// <td>0.15</td><td>kg.m2</td>
// </tr>
// <tr>
// <td>nominal armature voltage</td>
// <td>100</td><td>V</td>
// </tr>
// <tr>
// <td>nominal armature current</td>
// <td>100</td><td>A</td>
// </tr>
// <tr>
// <td>nominal torque</td>
// <td>63.66</td><td>Nm</td>
// </tr>
// <tr>
// <td>nominal speed</td>
// <td>1410</td><td>rpm</td>
// </tr>
// <tr>
// <td>nominal mechanical output</td>
// <td>9.4</td><td>kW</td>
// </tr>
// <tr>
// <td>efficiency</td>
// <td>94.0</td><td>% only armature</td>
// </tr>
// <tr>
// <td>armature resistance</td>
// <td>0.05</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>aramture inductance</td>
// <td>0.0015</td><td>H</td>
// </tr>
// <tr>
// <td>excitation resistance</td>
// <td>0.01</td><td>Ohm in warm condition</td>
// </tr>
// <tr>
// <td>excitation inductance</td>
// <td>0.0005</td><td>H</td>
// </tr>
// </table>
// Armature resistance resp. inductance include resistance resp. inductance of commutating pole winding and 
// compensation windig, if present.<br>
// Parameter nominal armature voltage includes voltage drop of series excitation;<br>
// but for output the voltage is splitted into:<br>
// va = armature voltage without voltage drop of series excitation<br>
// ve = voltage drop of series excitation
// </p>
// </HTML>"));
//             Modelica.Electrical.Machines.BasicMachines.Components.AirGapDC airGapDC(final Le = Le, final TurnsRatio = TurnsRatio) annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           protected 
//             parameter Real TurnsRatio = (VaNominal - (Ra + Re) * IaNominal) / (Modelica.SIunits.Conversions.from_rpm(rpmNominal) * Le * IaNominal) "Ratio of armature turns over number of turns of the excitation winding";
// 
//           equation 
//             connect(airGapDC.pin_an,pin_an) annotation(Line(visible = true, points = {{ -10.0,10.0},{ -10.0,60.0},{ -60.0,60.0},{ -60.0,100.0}}, color = {0,0,255}));
//             connect(pin_ap,ra.p) annotation(Line(visible = true, points = {{60.0,100.0},{60.0,60.0}}, color = {0,0,255}));
//             connect(airGapDC.support,internalSupport) annotation(Line(visible = true, points = {{ -10.0,0.0},{ -90.0, -0.0},{ -90.0, -100.0},{20.0, -100.0}}));
//             connect(airGapDC.flange_a,inertiaRotor.flange_a) annotation(Line(visible = true, points = {{10.0,0.0},{25.0,0.0},{25.0, -0.0},{60.0,0.0}}));
//             connect(re.p,pin_ep) annotation(Line(visible = true, points = {{ -60.0, -40.0},{ -80.0, -40.0},{ -80.0,60.0},{ -100.0,60.0}}, color = {0,0,255}));
//             connect(la.p,ra.n) annotation(Line(visible = true, points = {{30.0,60.0},{40.0,60.0}}, color = {0,0,255}));
//             connect(la.n,airGapDC.pin_ap) annotation(Line(visible = true, points = {{10.0,60.0},{10.0,10.0}}, color = {0,0,255}));
//             connect(re.n,airGapDC.pin_ep) annotation(Line(visible = true, points = {{ -40.0, -40.0},{10.0, -40.0},{10.0, -10.0}}, color = {0,0,255}));
//             connect(airGapDC.pin_en,pin_en) annotation(Line(visible = true, points = {{ -10.0, -10.0},{ -10.0, -60.0},{ -100.0, -60.0}}, color = {0,0,255}));
//             assert(VaNominal > (Ra + Re) * IaNominal, "VaNominal has to be > (Ra+Re)*IaNominal");
//           end DC_SeriesExcited;
//         end DCMachines;
//         package Components "Machine components like AirGaps"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains components for modeling electrical machines, specially threephase induction machines, based on space phasor theory:
// <ul>
// <li>AirGapS: model of an airgap whose coordinate system is fixed to the stator</li>
// <li>AirGapR: model of an airgap whose coordinate system is fixed to the rotor</li>
// <li>SquirrelCage: model of a squirrel cage rotor</li>
// <li>PermanentMagnet: model of a permanent magnet excitation</li>
// <li>ElectricalExcitation: model of an electrical excitation (converting excitation to space phasor)</li>
// <li>AirGapDC: model of an airgap of DC machines</li>
// </ul>
// These models use package SpacePhasors.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.02 2004/09/19 Anton Haumer<br>
//        added AirGapDC models</li>
//   <li> v1.2  2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.52 2005/10/12 Anton Haumer<br>
//        added electrical excitation</li>
//   <li> v1.53 Beta 2005/10/14 Anton Haumer<br>
//        introduced unsymmetrical DamperCage for Synchronous Machines</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model AirGapS "Airgap in stator-fixed coordinate system"
//             constant Integer m = 3 "number of phases";
//             parameter Integer p(min = 1) "number of pole pairs";
//             parameter Modelica.SIunits.Inductance Lm "main field inductance";
//             output Modelica.SIunits.Torque tau_electrical;
//             Modelica.SIunits.Angle gamma "Rotor displacement angle";
//             Modelica.SIunits.Current i_ss[2] "Stator current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.Current i_sr[2] "Stator current space phasor with respect to the rotor fixed frame";
//             Modelica.SIunits.Current i_rs[2] "Rotor current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.Current i_rr[2] "Rotor current space phasor with respect to the rotor fixed frame";
//             Modelica.SIunits.Current i_ms[2] "Magnetizing current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.MagneticFlux psi_ms[2] "Magnetizing flux phasor with respect to the stator fixed frame";
//             Modelica.SIunits.MagneticFlux psi_mr[2] "Magnetizing flux phasor with respect to the rotor fixed frame";
//             Real RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a support "support at which the reaction torque is acting" annotation(Placement(visible = true, transformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_s annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90.0,90.0},{90.0, -92.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -80.0,80.0},{80.0, -80.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.VerticalCylinder, extent = {{ -10.0,90.0},{10.0, -80.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0, -40.0},{0.0,40.0}}, textString = "S", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Model of the airgap in stator-fixed coordinate system, using only equations.
// </p>
// </HTML>"));
//           protected 
//             parameter Modelica.SIunits.Inductance L[2,2] = {{Lm,0},{0,Lm}} "inductance matrix";
// 
//           equation 
//             gamma = p * (flange_a.phi - support.phi);
//             RotationMatrix = {{ +cos(gamma), -sin(gamma)},{ +sin(gamma), +cos(gamma)}};
//             i_ss = spacePhasor_s.i_;
//             i_ss = RotationMatrix * i_sr;
//             i_rr = spacePhasor_r.i_;
//             i_rs = RotationMatrix * i_rr;
//             i_ms = i_ss + i_rs;
//             psi_ms = L * i_ms;
//             psi_mr = transpose(RotationMatrix) * psi_ms;
//             spacePhasor_s.v_ = der(psi_ms);
//             spacePhasor_r.v_ = der(psi_mr);
//             tau_electrical = m / 2 * p * (spacePhasor_s.i_[2] * psi_ms[1] - spacePhasor_s.i_[1] * psi_ms[2]);
//             flange_a.tau =  -tau_electrical;
//             support.tau = tau_electrical;
//           end AirGapS;
//           model AirGapR "Airgap in rotor-fixed coordinate system"
//             constant Integer m = 3 "number of phases";
//             parameter Integer p(min = 1) "number of pole pairs";
//             parameter Modelica.SIunits.Inductance Lmd "main field inductance d-axis";
//             parameter Modelica.SIunits.Inductance Lmq "main field inductance q-axis";
//             output Modelica.SIunits.Torque tau_electrical;
//             Modelica.SIunits.Angle gamma "Rotor displacement angle";
//             Modelica.SIunits.Current i_ss[2] "Stator current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.Current i_sr[2] "Stator current space phasor with respect to the rotor fixed frame";
//             Modelica.SIunits.Current i_rs[2] "Rotor current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.Current i_rr[2] "Rotor current space phasor with respect to the rotor fixed frame";
//             Modelica.SIunits.Current i_mr[2] "Magnetizing current space phasor with respect to the stator fixed frame";
//             Modelica.SIunits.MagneticFlux psi_ms[2] "Magnetizing flux phasor with respect to the stator fixed frame";
//             Modelica.SIunits.MagneticFlux psi_mr[2] "Magnetizing flux phasor with respect to the rotor fixed frame";
//             Real RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a support "support at which the reaction torque is acting" annotation(Placement(visible = true, transformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_s annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90.0,90.0},{90.0, -92.0}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0,80.0},{80.0, -80.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.VerticalCylinder, extent = {{ -10.0,90.0},{10.0, -80.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{0.0, -40.0},{80.0,40.0}}, textString = "R", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Model of the airgap in rotor-fixed coordinate system, using only equations.
// </p>
// </HTML>"));
//           protected 
//             parameter Modelica.SIunits.Inductance L[2,2] = {{Lmd,0},{0,Lmq}} "inductance matrix";
// 
//           equation 
//             gamma = p * (flange_a.phi - support.phi);
//             RotationMatrix = {{ +cos(gamma), -sin(gamma)},{ +sin(gamma), +cos(gamma)}};
//             i_ss = spacePhasor_s.i_;
//             i_ss = RotationMatrix * i_sr;
//             i_rr = spacePhasor_r.i_;
//             i_rs = RotationMatrix * i_rr;
//             i_mr = i_sr + i_rr;
//             psi_mr = L * i_mr;
//             psi_ms = RotationMatrix * psi_mr;
//             spacePhasor_s.v_ = der(psi_ms);
//             spacePhasor_r.v_ = der(psi_mr);
//             tau_electrical = m / 2 * p * (spacePhasor_s.i_[2] * psi_ms[1] - spacePhasor_s.i_[1] * psi_ms[2]);
//             flange_a.tau =  -tau_electrical;
//             support.tau = tau_electrical;
//           end AirGapR;
//           model SquirrelCage "Squirrel Cage"
//             parameter Modelica.SIunits.Inductance Lrsigma "rotor stray inductance per phase translated to stator";
//             parameter Modelica.SIunits.Resistance Rr "warm rotor resistance per phase translated to stator";
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60.0,45.0},{ -30.0,75.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30.0,45.0},{0.0,75.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0.0,45.0},{30.0,75.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30.0,45.0},{60.0,75.0}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0,30.0},{60.0,60.0}}),Line(visible = true, points = {{ -100.0,60.0},{ -60.0,60.0}}, color = {0,0,255}),Line(visible = true, points = {{60.0,60.0},{80.0,60.0},{80.0,40.0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{60.0,40.0},{100.0, -40.0}}),Line(visible = true, points = {{80.0, -40.0},{80.0, -60.0}}, color = {0,0,255}),Line(visible = true, points = {{60.0, -60.0},{100.0, -60.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0, -80.0},{90.0, -80.0}}, color = {0,0,255}),Line(visible = true, points = {{66.0, -70.0},{94.0, -70.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100.0,90.0},{ -100.0,60.0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Model of a squirrel cage / damper cage in two axis.
// </p>
// </HTML>"));
// 
//           equation 
//             spacePhasor_r.v_ = Rr * spacePhasor_r.i_ + Lrsigma * der(spacePhasor_r.i_);
//           end SquirrelCage;
//           model DamperCage "Squirrel Cage"
//             parameter Modelica.SIunits.Inductance Lrsigma "stray inductance in d-axis per phase translated to stator";
//             parameter Modelica.SIunits.Inductance Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//             parameter Modelica.SIunits.Resistance Rr "warm resistance in d-axis per phase translated to stator";
//             parameter Modelica.SIunits.Resistance Rrq "warm resistance in q-axis per phase translated to stator";
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{60.0,60.0},{100.0,60.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,40.0},{90.0,40.0}}, color = {0,0,255}),Line(visible = true, points = {{66.0,50.0},{94.0,50.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60.0,90.0},{ -40.0,70.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -40.0,90.0},{ -20.0,70.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -20.0,90.0},{0.0,70.0}}),Line(visible = true, points = {{ -80.0,0.0},{ -80.0, -20.0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{20.0,90.0},{60.0,70.0}}),Line(visible = true, points = {{60.0,80.0},{80.0,80.0},{80.0,60.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,90.0},{ -100.0,80.0},{ -60.0,80.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0,90.0},{ -100.0,80.0},{ -80.0,80.0},{ -80.0,60.0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -90.0,60.0},{ -70.0,40.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -90.0,40.0},{ -70.0,20.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -90.0,20.0},{ -70.0,0.0}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0,0.0},{ -70.0,60.0}}),Line(visible = true, points = {{0.0,80.0},{20.0,80.0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -90.0, -20.0},{ -70.0, -60.0}}),Line(visible = true, points = {{ -100.0, -80.0},{ -60.0, -80.0}}, color = {0,0,255}),Line(visible = true, points = {{ -90.0, -100.0},{ -70.0, -100.0}}, color = {0,0,255}),Line(visible = true, points = {{ -94.0, -90.0},{ -66.0, -90.0}}, color = {0,0,255}),Line(visible = true, points = {{ -80.0, -60.0},{ -80.0, -80.0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{0.0,70.0},{ -60.0,80.0}})}), Documentation(info = "<HTML>
// <p>
// Model of an unsymmetrical damper cage cage in two axis.
// </p>
// </HTML>"));
// 
//           equation 
//             spacePhasor_r.v_[1] = Rr * spacePhasor_r.i_[1] + Lrsigma * der(spacePhasor_r.i_[1]);
//             spacePhasor_r.v_[2] = Rrq * spacePhasor_r.i_[2] + Lrsigmaq * der(spacePhasor_r.i_[2]);
//           end DamperCage;
//           model PermanentMagnet "Permanent magnet excitation"
//             parameter Modelica.SIunits.Current Ie "Equivalent excitation current";
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -60.0,60.0},{60.0,20.0}}),Ellipse(visible = true, lineColor = {0,255,0}, fillColor = {0,255,0}, fillPattern = FillPattern.Solid, extent = {{ -60.0, -20.0},{60.0, -60.0}}),Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, extent = {{ -60.0,40.0},{60.0,0.0}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -90.0,100.0},{ -70.0,106.0},{ -70.0,94.0},{ -90.0,100.0}}),Rectangle(visible = true, lineColor = {0,255,0}, fillColor = {0,255,0}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -60.0,0.0},{60.0, -40.0}}),Line(visible = true, points = {{ -60.0, -40.0},{ -60.0,0.0}}, color = {0,255,0}),Line(visible = true, points = {{60.0, -40.0},{60.0,0.0}}, color = {0,255,0}),Line(visible = true, points = {{0.0,100.0},{ -70.0,100.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0,100.0},{0.0,60.0}}, color = {255,0,0}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Model of a permanent magnet excitation, characterized by an equivalent excitation current.
// </p>
// </HTML>"));
// 
//           equation 
//             spacePhasor_r.i_ = { -Ie,0};
//           end PermanentMagnet;
//           model ElectricalExcitation "Electrical excitation"
//             parameter Real TurnsRatio = 1 "stator current / excitation current";
//             Modelica.SIunits.Current ie "excitation current";
//             Modelica.SIunits.Voltage ve "excitation voltage";
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -90.0,100.0},{ -70.0,106.0},{ -70.0,94.0},{ -90.0,100.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -70.0,40.0},{10.0, -40.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -10.0,40.0},{70.0, -40.0}}),Line(visible = true, points = {{ -30.0,0.0},{ -54.0,32.0},{ -50.0,20.0},{ -44.0,26.0},{ -54.0,32.0}}, color = {0,0,255}),Line(visible = true, points = {{ -30.0,0.0},{ -54.0, -32.0},{ -50.0, -20.0},{ -44.0, -26.0},{ -54.0, -32.0}}, color = {0,0,255}),Line(visible = true, points = {{ -54.0,32.0},{ -54.0,100.0},{ -70.0,100.0}}, color = {0,0,255}),Line(visible = true, points = {{90.0,100.0},{30.0,100.0},{30.0,40.0}}, color = {0,0,255}),Line(visible = true, points = {{30.0, -40.0},{30.0, -100.0},{90.0, -100.0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Model of an electrical excitation, converting excitation to space phasor.
// </p>
// </HTML>"));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ep annotation(Placement(visible = true, transformation(origin = {100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_en annotation(Placement(visible = true, transformation(origin = {100.0, -100.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -100.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
// 
//           equation 
//             pin_ep.i + pin_en.i = 0;
//             ie =  +pin_ep.i;
//             ve = pin_ep.v - pin_en.v;
//             spacePhasor_r.i_ = { -ie * TurnsRatio,0};
//             ve = spacePhasor_r.v_[1] * TurnsRatio;
//           end ElectricalExcitation;
//           model AirGapDC "Linear airgap model of a DC machine"
//             parameter Modelica.SIunits.Inductance Le "Excitation inductance";
//             parameter Real TurnsRatio "Ratio of armature turns over number of turns of the excitation winding";
//             Modelica.SIunits.AngularVelocity w "Angluar velocity";
//             Modelica.SIunits.Voltage vei "Voltage drop across field excitation inductance";
//             Modelica.SIunits.Current ie "Excitation current";
//             Modelica.SIunits.MagneticFlux psi_e "Excitation flux";
//             Modelica.SIunits.Voltage vai "Induced armature voltage";
//             Modelica.SIunits.Current ia "Armature current";
//             output Modelica.SIunits.Torque tau_electrical;
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {0.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Mechanics.Rotational.Interfaces.Flange_a support "support at which the reaction torque is acting" annotation(Placement(visible = true, transformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ap annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin pin_ep annotation(Placement(visible = true, transformation(origin = {100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {100.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_an annotation(Placement(visible = true, transformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin pin_en annotation(Placement(visible = true, transformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90.0,90.0},{90.0, -92.0}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0,80.0},{80.0, -80.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.VerticalCylinder, extent = {{ -10.0,90.0},{10.0, -80.0}}),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{0.0, -40.0},{80.0,40.0}}, textString = "E", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -160.0},{150.0, -100.0}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -80.0, -40.0},{0.0,40.0}}, textString = "A", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Linear model of the airgap (without saturation effects) of a DC machine, using only equations.<br>
// Induced excitation voltage is calculated from der(flux), where flux is defined by excitation inductance times excitation current.<br>
// Induced armature voltage is calculated from flux times angular velocity.
// </p>
// </HTML>"));
// 
//           equation 
//             vai = pin_ap.v - pin_an.v;
//             ia =  +pin_ap.i;
//             ia =  -pin_an.i;
//             vei = pin_ep.v - pin_en.v;
//             ie =  +pin_ep.i;
//             ie =  -pin_en.i;
//             psi_e = Le * ie;
//             vei = der(psi_e);
//             w = der(flange_a.phi) - der(support.phi);
//             vai = TurnsRatio * psi_e * w;
//             tau_electrical = TurnsRatio * psi_e * ia;
//             flange_a.tau =  -tau_electrical;
//             support.tau = tau_electrical;
//           end AirGapDC;
//         end Components;
//       end BasicMachines;
//       package Sensors "Sensors for machine modelling"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains sensors that are usefull when modelling machines.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.03 2004/09/24 Anton Haumer</li>
//   <li> v1.1  2004/10/01 Anton Haumer<br>
//        changed RotorAngle</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support, also in sensor RotorAngle<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -74.0,46.0},{66.0, -94.0}}),Line(visible = true, points = {{ -4.0,46.0},{ -4.0,16.0}}),Line(visible = true, points = {{18.9,8.8},{36.2,33.3}}),Line(visible = true, points = {{ -26.9,8.8},{ -44.2,33.3}}),Line(visible = true, points = {{33.6, -10.3},{61.8, -0.1}}),Line(visible = true, points = {{ -41.6, -10.3},{ -69.8, -0.1}}),Line(visible = true, points = {{ -4.0, -24.0},{5.02,4.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -4.48,7.6},{14.0,2.0},{14.0,33.2},{ -4.48,7.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -9.0, -19.0},{1.0, -29.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model VoltageRMSsensor
//           constant Integer m(final min = 1) = 3 "number of phases";
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Sensors.VoltageSensor VoltageSensor1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70.0,70.0},{70.0, -70.0}}),Line(visible = true, points = {{0.0,70.0},{0.0,40.0}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0.0,0.0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18.0,26.0},{18.0,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5.0,5.0},{5.0, -5.0}}),Line(visible = true, points = {{ -90.0,0.0},{ -70.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,0.0},{90.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0, -70.0},{0.0, -100.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0, -60.0},{40.0, -20.0}}, textString = "V RMS", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Measured 3-phase instantaneous voltages are transformed to the corresponding space phasor; <br>
// output is length of the space phasor divided by sqrt(2), thus giving in sinusoidal stationary state RMS voltage.
// </p>
// </HTML>"));
//           Modelica.Blocks.Math.Gain Gain1(final k = 1 / sqrt(2)) annotation(Placement(visible = true, transformation(origin = {0.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToPolar ToPolar1 annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor ToSpacePhasor1 annotation(Placement(visible = true, transformation(origin = {0.0,10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Blocks.Interfaces.RealOutput V(redeclare type SignalType = Modelica.SIunits.Voltage) annotation(Placement(visible = true, transformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90), iconTransformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(Gain1.y,V) annotation(Line(visible = true, origin = {0.0, -95.5}, points = {{0.0,14.5},{0.0, -14.5}}, color = {0,0,255}));
//           connect(ToPolar1.y[1],Gain1.u) annotation(Line(visible = true, origin = {0.0, -49.5}, points = {{0.0,8.5},{0.0, -8.5}}, color = {0,0,255}));
//           connect(ToSpacePhasor1.y,ToPolar1.u) annotation(Line(visible = true, origin = {0.0, -9.5}, points = {{0.0,8.5},{0.0, -8.5}}, color = {0,0,255}));
//           connect(VoltageSensor1.plug_n,plug_n) annotation(Line(visible = true, points = {{10.0,50.0},{100.0,50.0},{100.0,0.0}}, color = {0,0,255}));
//           connect(plug_p,VoltageSensor1.plug_p) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -100.0,50.0},{ -10.0,50.0}}, color = {0,0,255}));
//           connect(VoltageSensor1.v,ToSpacePhasor1.u) annotation(Line(visible = true, points = {{0.0,39.0},{0.0,22.0},{0.0,22.0}}, color = {0,0,255}));
//         end VoltageRMSsensor;
//         model CurrentRMSsensor
//           constant Integer m(final min = 1) = 3 "number of phases";
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Sensors.CurrentSensor CurrentSensor1(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0,50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70.0,70.0},{70.0, -70.0}}),Line(visible = true, points = {{0.0,70.0},{0.0,40.0}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0.0,0.0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18.0,26.0},{18.0,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5.0,5.0},{5.0, -5.0}}),Line(visible = true, points = {{ -90.0,0.0},{ -70.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,0.0},{90.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0, -70.0},{0.0, -100.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0, -60.0},{40.0, -20.0}}, textString = "A RMS", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Measured 3-phase instantaneous currents are transformed to the corresponding space phasor; <br>
// output is length of the space phasor divided by sqrt(2), thus giving in sinusoidal stationary state RMS current.
// </p>
// </HTML>"));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor ToSpacePhasor1 annotation(Placement(visible = true, transformation(origin = {0.0,10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToPolar ToPolar1 annotation(Placement(visible = true, transformation(origin = {0.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Blocks.Math.Gain Gain1(final k = 1 / sqrt(2)) annotation(Placement(visible = true, transformation(origin = { -0.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Blocks.Interfaces.RealOutput I(redeclare type SignalType = Modelica.SIunits.Current) annotation(Placement(visible = true, transformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90), iconTransformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(ToSpacePhasor1.y,ToPolar1.u) annotation(Line(visible = true, origin = {0.0, -9.5}, points = {{0.0,8.5},{0.0, -8.5}}, color = {0,0,255}));
//           connect(CurrentSensor1.i,ToSpacePhasor1.u) annotation(Line(visible = true, points = {{0.0,39.0},{0.0,22.0},{0.0,22.0}}, color = {0,0,255}));
//           connect(ToPolar1.y[1],Gain1.u) annotation(Line(visible = true, origin = {0.0, -49.5}, points = {{0.0,8.5},{0.0, -8.5}}, color = {0,0,255}));
//           connect(CurrentSensor1.plug_n,plug_n) annotation(Line(visible = true, points = {{10.0,50.0},{100.0,50.0},{100.0,0.0}}, color = {0,0,255}));
//           connect(plug_p,CurrentSensor1.plug_p) annotation(Line(visible = true, points = {{ -100.0,0.0},{ -100.0,50.0},{ -10.0,50.0}}, color = {0,0,255}));
//           connect(Gain1.y,I) annotation(Line(visible = true, points = {{ -0.0, -81.0},{0.0, -91.5},{0.0, -91.5},{0.0, -110.0}}, color = {0,0,255}));
//         end CurrentRMSsensor;
//         model ElectricalPowerSensor
//           constant Integer m(final min = 1) = 3 "number of phases";
//           Modelica.Blocks.Interfaces.RealOutput P(redeclare type SignalType = Modelica.SIunits.Power) annotation(Placement(visible = true, transformation(origin = { -50.0,110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90), iconTransformation(origin = { -50.0,110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90)));
//           Modelica.Blocks.Interfaces.RealOutput Q(redeclare type SignalType = Modelica.SIunits.Power) annotation(Placement(visible = true, transformation(origin = {50.0,110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90), iconTransformation(origin = {50.0,110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 90)));
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_ni(final m = m) annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_nv(final m = m) annotation(Placement(visible = true, transformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70.0,70.0},{70.0, -70.0}}),Line(visible = true, points = {{0.0,70.0},{0.0,40.0}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0.0,0.0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18.0,26.0},{18.0,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5.0,5.0},{5.0, -5.0}}),Line(visible = true, points = {{ -90.0,0.0},{ -70.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{70.0,0.0},{90.0,0.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0, -60.0},{40.0, -20.0}}, textString = "P Q", fontName = "Arial"),Line(visible = true, points = {{0.0, -70.0},{0.0, -90.0}}, color = {0,0,255}),Line(visible = true, points = {{ -10.0,70.0},{ -10.0,80.0},{ -50.0,80.0},{ -50.0,100.0}}, color = {0,0,255}),Line(visible = true, points = {{10.0,70.0},{10.0,80.0},{50.0,80.0},{50.0,100.0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// 3-phase instantaneous voltages (plug_p - plug_nv) and currents (plug_p - plug_ni) are transformed to the corresponding space phasors, <br>
// which are used to calculate power quantities:<br>
// P = instantaneous power, thus giving in stationary state active power.<br>
// Q = giving in stationary state reactive power.<br>
// </p>
// </HTML>"));
//         protected 
//           Modelica.SIunits.Voltage v_[2];
//           Modelica.SIunits.Current i_[2];
// 
//         equation 
//           plug_p.pin.v = plug_ni.pin.v;
//           plug_p.pin.i + plug_ni.pin.i = zeros(m);
//           plug_nv.pin.i = zeros(m);
//           v_ = Machines.SpacePhasors.Functions.ToSpacePhasor(plug_p.pin.v - plug_nv.pin.v);
//           i_ = Machines.SpacePhasors.Functions.ToSpacePhasor(plug_p.pin.i);
//           2 / 3 * P =  +v_[1] * i_[1] + v_[2] * i_[2];
//           2 / 3 * Q =  -v_[1] * i_[2] + v_[2] * i_[1];
//         end ElectricalPowerSensor;
//         model MechanicalPowerSensor
//           extends Modelica.Mechanics.Rotational.Interfaces.TwoFlanges;
//           Modelica.Blocks.Interfaces.RealOutput P(redeclare type SignalType = Modelica.SIunits.Power) annotation(Placement(visible = true, transformation(origin = {0.0, -110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation =  -90), iconTransformation(origin = {0.0, -110.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation =  -90)));
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70.0,70.0},{70.0, -70.0}}),Line(visible = true, points = {{0.0,70.0},{0.0,40.0}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0.0,0.0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18.0,26.0},{18.0,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5.0,5.0},{5.0, -5.0}}),Line(visible = true, points = {{ -70.0,0.0},{ -90.0,0.0}}),Line(visible = true, points = {{70.0,0.0},{90.0,0.0}}),Line(visible = true, points = {{0.0, -100.0},{0.0, -70.0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0, -60.0},{40.0, -20.0}}, textString = "Pmech", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Calculates (mechanical) power from torque times angular speed.
// </p>
// </HTML>"));
//           Modelica.Mechanics.Rotational.Sensors.TorqueSensor TorqueSensor1 annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Math.Product Product1 annotation(Placement(visible = true, transformation(origin = {0.0, -70.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Modelica.Mechanics.Rotational.Sensors.SpeedSensor SpeedSensor1 annotation(Placement(visible = true, transformation(origin = { -30.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//         equation 
//           connect(SpeedSensor1.w,Product1.u2) annotation(Line(visible = true, origin = { -18.0, -46.2488}, points = {{ -12.0,25.2488},{ -12.0, -6.7488},{12.0, -6.7488},{12.0, -11.7512}}, color = {0,0,255}));
//           connect(TorqueSensor1.tau,Product1.u1) annotation(Line(visible = true, origin = {14.0, -43.7488}, points = {{8.0,32.7488},{8.0, -9.2488},{ -8.0, -9.2488},{ -8.0, -14.2512}}, color = {0,0,255}));
//           connect(Product1.y,P) annotation(Line(visible = true, origin = {0.0, -95.5}, points = {{0.0,14.5},{0.0, -14.5}}, color = {0,0,255}));
//           connect(TorqueSensor1.flange_b,flange_b) annotation(Line(visible = true, points = {{40.0,0.0},{100.0,0.0}}));
//           connect(flange_a,TorqueSensor1.flange_a) annotation(Line(visible = true, points = {{ -100.0,0.0},{20.0,0.0}}));
//           connect(SpeedSensor1.flange_a,flange_a) annotation(Line(visible = true, points = {{ -30.0,0.0},{ -100.0,0.0}}));
//         end MechanicalPowerSensor;
//         model RotorAngle "Rotor lagging angle"
//           constant Integer m = 3 "number of phases";
//           parameter Integer p(min = 1) "number of pole pairs";
//           Modelica.Blocks.Interfaces.RealOutput rotorAngle(redeclare type SignalType = Modelica.SIunits.Angle) annotation(Placement(visible = true, transformation(origin = {110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Sensors.VoltageSensor VoltageSensor1(final m = m) annotation(Placement(visible = true, transformation(origin = { -80.0, -10.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation =  -90)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor ToSpacePhasorVS annotation(Placement(visible = true, transformation(origin = { -50.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Interfaces.Flange_a flange annotation(Placement(visible = true, transformation(origin = {0.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Sensors.RelAngleSensor relativeAngleSensor annotation(Placement(visible = true, transformation(origin = {30.0,80.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant constant_(final k = Modelica.Constants.pi / 2) annotation(Placement(visible = true, transformation(origin = { -40.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Math.Add add(final k2 = 1, final k1 = p) annotation(Placement(visible = true, transformation(origin = { -10.0,20.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 90)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.Rotator rotatorVS2R annotation(Placement(visible = true, transformation(origin = { -10.0, -10.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//           Modelica.Electrical.Machines.SpacePhasors.Blocks.ToPolar ToPolarVSR annotation(Placement(visible = true, transformation(origin = {30.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Routing.DeMultiplex2 deMultiplex2(final n1 = 1, final n2 = 1) annotation(Placement(visible = true, transformation(origin = {70.0, -10.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Fixed fixedHousing(final phi0 = 0) annotation(Placement(visible = true, transformation(origin = {60.0,80.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0,80.0},{60.0,40.0}}),Ellipse(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0, -40.0},{60.0, -80.0}}),Rectangle(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0,60.0},{60.0,40.0}}),Rectangle(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60.0, -40.0},{60.0, -60.0}}),Rectangle(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40.0,40.0},{40.0, -40.0}}),Line(visible = true, points = {{0.0,0.0},{ -80.0,80.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -80.0,80.0},{ -68.0,76.0},{ -76.0,68.0},{ -80.0,80.0}}),Line(visible = true, points = {{0.0,0.0},{0.0,80.0}}, color = {0,255,0}),Polygon(visible = true, lineColor = {0,255,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{0.0,84.0},{4.0,72.0},{ -4.0,72.0},{0.0,84.0}})}), Documentation(info = "<HTML>
// <p>
// Calculates rotor lagging angle by measuring the stator phase voltages, transforming them to the correspondig space phasor in stator-fixed coordinate system, <br>
// rotating the space phasor to the rotor-fixed coordinate system and calculating the angle of this space phasor.
// </p>
// <p>
// The sensor's housing is implicitely fixed.<br>
// Since the machine's stator also implicitely fixed, the angle at the flange 
// is equal to the angle of the machine's rotor against the stator.
// </p>
// </HTML>"));
// 
//         equation 
//           connect(constant_.y,add.u2) annotation(Line(visible = true, origin = { -20.3333,37.3333}, points = {{ -8.6667,2.6667},{4.3333,2.6667},{4.3333, -5.3333}}, color = {0,0,255}));
//           connect(add.y,rotatorVS2R.angle) annotation(Line(visible = true, origin = { -10.0,5.5}, points = {{0.0,3.5},{0.0, -3.5}}, color = {0,0,255}));
//           connect(relativeAngleSensor.phi_rel,add.u1) annotation(Line(visible = true, points = {{30.0,69.0},{30.0,40.0},{ -4.0,40.0},{ -4.0,32.0}}, color = {0,0,255}));
//           connect(plug_p,VoltageSensor1.plug_p) annotation(Line(visible = true, points = {{ -100.0,60.0},{ -80.0,60.0},{ -80.0,0.0}}, color = {0,0,255}));
//           connect(plug_n,VoltageSensor1.plug_n) annotation(Line(visible = true, points = {{ -100.0, -60.0},{ -80.0, -60.0},{ -80.0, -20.0}}, color = {0,0,255}));
//           connect(VoltageSensor1.v,ToSpacePhasorVS.u) annotation(Line(visible = true, origin = { -65.5, -10.0}, points = {{ -3.5,0.0},{3.5,0.0}}, color = {0,0,255}));
//           connect(relativeAngleSensor.flange_a,fixedHousing.flange_b) annotation(Line(visible = true, points = {{40.0,80.0},{60.0,80.0}}));
//           connect(relativeAngleSensor.flange_b,flange) annotation(Line(visible = true, points = {{20.0,80.0},{0.0,80.0},{0.0,100.0}}));
//           connect(deMultiplex2.y2[1],rotorAngle) annotation(Line(visible = true, points = {{81.0, -16.0},{90.0, -16.0},{90.0,0.0},{110.0,0.0}}, color = {0,0,255}));
//           connect(ToPolarVSR.y,deMultiplex2.u) annotation(Line(visible = true, points = {{41.0, -10.0},{58.0, -10.0}}, color = {0,0,255}));
//           connect(rotatorVS2R.y,ToPolarVSR.u) annotation(Line(visible = true, points = {{1.0, -10.0},{18.0, -10.0}}, color = {0,0,255}));
//           connect(ToSpacePhasorVS.y,rotatorVS2R.u) annotation(Line(visible = true, points = {{ -39.0, -10.0},{ -22.0, -10.0}}, color = {0,0,255}));
//         end RotorAngle;
//       end Sensors;
//       package SpacePhasors "Library with space phasor-models"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains components, blocks and functions to utilize space phasor theory.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.30 2004/11/05 Anton Haumer<br>
//        several improvements in SpacePhasors.Blocks</li>
//   <li> v1.60 2005/11/03 Anton Haumer<br>
//        added Components.Rotator</li>
//   <li> v1.6.1 2005/11/10 Anton Haumer<br>
//        improved Transformation and Rotation</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -8.0, -26.0},{64.0,46.0},{44.0,38.0},{56.0,26.0},{64.0,46.0}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -8.0, -26.0},{64.0, -98.0},{56.0, -78.0},{44.0, -90.0},{64.0, -98.0}}, color = {0,0,255}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         package Components "Basic space phasor models"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains basic space phasor models:
// <ul>
// <li>SpacePhasor: physical transformation of voltages and currents three phase <-> space phasors</li>
// </ul>
// Real and imaginary part of voltage space phasor are the potentials v_[2] of the space phasor connector; (implicit grounded).<br>
// Real and imaginary part of current space phasor are the currents i_[2] at the space phasor connector;
// a ground has to be used where necessary for currents flowing back.<br>
// Zero-sequence voltage and current are present at pin zero. An additional zero-sequence impedance could be connected between pin zero and pin ground.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.60 2005/11/03 Anton Haumer<br>
//        added Rotator</li>
//   <li> v1.6.1 2005/11/10 Anton Haumer<br>
//        improved Transformation and Rotation</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model SpacePhasor "Physical transformation: three phase <-> space phasors"
//             constant Integer m = 3 "number of phases";
//             constant Real pi = Modelica.Constants.pi;
//             Modelica.SIunits.Voltage v[m] "instantaneous phase voltages";
//             Modelica.SIunits.Current i[m] "instantaneous phase currents";
//             Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.PositivePin zero annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Interfaces.NegativePin ground annotation(Placement(visible = true, transformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             Modelica.Electrical.Analog.Basic.Ground gnd annotation(Placement(visible = true, transformation(origin = {70.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Physical transformation of voltages and currents: three phases <-> space phasors:<br>
// x[k] = X0 + {cos(-(k - 1)/m*2*pi),-sin(-(k - 1)/m*2*pi) * X[Re,Im]<br>
// and vice versa:<br>
// X0 = sum(x[k])/m<br>
// X[Re,Im] = sum(2/m*{cos((k - 1)/m*2*pi),sin((k - 1)/m*2*pi)}*x[k])<br>
// were x designates three phase values, X[Re,Im] designates the space phasor and X0 designates the zero sequence system.<br>
// <i>Physcial transformation</i> means that both voltages and currents are transformed in both directions.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, origin = {35.0,35.0}, points = {{ -35.0, -35.0},{35.0,35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = {35.0, -35.0}, points = {{ -35.0,35.0},{35.0, -35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = { -30.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = { -40.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = { -50.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Polygon(visible = true, origin = {70.0, -70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -10.0,0.0},{0.0,10.0},{10.0, -10.0}}),Polygon(visible = true, origin = {70.0,70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -10.0,0.0},{0.0, -10.0},{10.0,10.0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0,110.0},{150.0,150.0}}, textString = "%name", fontName = "Arial")}));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{90.0,90.0},{110.0,110.0}}, rotation = 0), iconTransformation(origin = {0.0,0.0}, extent = {{90.0,90.0},{110.0,110.0}}, rotation = 0)));
//           protected 
//             parameter Real TransformationMatrix[2,m] = 2 / m * {array(cos( +(k - 1) / m * 2 * pi) for k in 1:m),array( +sin( +(k - 1) / m * 2 * pi) for k in 1:m)};
//             parameter Real InverseTransformation[m,2] = array({cos( -(k - 1) / m * 2 * pi), -sin( -(k - 1) / m * 2 * pi)} for k in 1:m);
// 
//           equation 
//             connect(gnd.p,ground) annotation(Line(visible = true, points = {{70.0, -90.0},{100.0, -90.0},{100.0, -100.0}}, color = {0,0,255}));
//             v = plug_p.pin.v - plug_n.pin.v;
//             i =  +plug_p.pin.i;
//             i =  -plug_n.pin.i;
//             zero.v = 1 / m * sum(v);
//             spacePhasor.v_ = TransformationMatrix * v;
//              -zero.i = 1 / m * sum(i);
//              -spacePhasor.i_ = TransformationMatrix * i;
//           end SpacePhasor;
//           model Rotator "Rotates space phasor"
//             constant Real pi = Modelica.Constants.pi;
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_a annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -110.0,110.0},{ -90.0,90.0}}, rotation = 0), iconTransformation(origin = {0.0,0.0}, extent = {{ -110.0,110.0},{ -90.0,90.0}}, rotation = 0)));
//             Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_b annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{90.0,110.0},{110.0,90.0}}, rotation = 0), iconTransformation(origin = {0.0,0.0}, extent = {{90.0,110.0},{110.0,90.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Rotates space phasors of left connector to right connector by the angle provided by the input signal \"angle\" from one coordinate system into another.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -2.0, -50.0},{50.0, -2.0}}),Line(visible = true, points = {{0.0,0.0},{80.0,0.0},{60.0,10.0},{60.0, -10.0},{80.0,0.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0,0.0},{0.0,80.0},{ -10.0,60.0},{10.0,60.0},{0.0,80.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{50.0,0.0},{42.0,14.0},{54.0,16.0},{50.0,0.0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -50.0, -50.0},{50.0,50.0}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -75.0, -50.0},{ -2.0,54.63}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -75.0, -75.0},{53.6, -2.0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0,110.0},{150.0,150.0}}, textString = "%name", fontName = "Arial")}));
//             Modelica.Blocks.Interfaces.RealInput angle(redeclare type SignalType = Modelica.SIunits.Angle) annotation(Placement(visible = true, transformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90), iconTransformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90)));
//           protected 
//             Real RotationMatrix[2,2] = {{ +cos( -angle), -sin( -angle)},{ +sin( -angle), +cos( -angle)}};
// 
//           equation 
//             spacePhasor_b.v_ = RotationMatrix * spacePhasor_a.v_;
//             spacePhasor_b.i_ = RotationMatrix * spacePhasor_a.i_;
//           end Rotator;
//         end Components;
//         package Blocks "Blocks for space phasor transformation"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains space phasor transformation blocks for use in controllers:
// <ul>
// <li>ToSpacePhasor: transforms a set of threephase values to space phasor and zero sequence system</li>
// <li>FromSpacePhasor: transforms a space phasor and zero sequence system to a set of threephase values</li>
// <li>Rotator: rotates a space phasor (from one coordinate system into another)</li>
// <li>ToPolar: Converts a space phasor from rectangular coordinates to polar coordinates</li>
// <li>FromPolar: Converts a space phasor from polar coordinates to rectangular coordinates</li>
// </ul>
// </p>
// 
// </HTML>", revisions = "<HTML>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.30 2004/11/05 Anton Haumer<br>
//        several improvements in SpacePhasors.Blocks</li>
//   <li> v1.6.1 2005/11/10 Anton Haumer<br>
//        improved Transformation and Rotation</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           block ToSpacePhasor "Conversion: three phase -> space phasor"
//             extends Modelica.Blocks.Interfaces.MIMO(final nin = m, final nout = 2);
//             constant Integer m = 3 "number of phases";
//             constant Real pi = Modelica.Constants.pi;
//             Modelica.Blocks.Interfaces.RealOutput zero annotation(Placement(visible = true, transformation(origin = {110.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {110.0, -80.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Transformation of threephase values (voltages or currents) to space phasor and zero sequence value.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, origin = {35.0,35.0}, points = {{ -35.0, -35.0},{35.0,35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = {35.0, -35.0}, points = {{ -35.0,35.0},{35.0, -35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = { -30.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = { -40.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = { -50.0,0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Polygon(visible = true, origin = {70.0, -70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -10.0,0.0},{0.0,10.0},{10.0, -10.0}}),Polygon(visible = true, origin = {70.0,70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -10.0,0.0},{0.0, -10.0},{10.0,10.0}})}));
//           protected 
//             parameter Real TransformationMatrix[2,m] = 2 / m * {array(cos( +(k - 1) / m * 2 * pi) for k in 1:m),array( +sin( +(k - 1) / m * 2 * pi) for k in 1:m)};
//             parameter Real InverseTransformation[m,2] = array({cos( -(k - 1) / m * 2 * pi), -sin( -(k - 1) / m * 2 * pi)} for k in 1:m);
// 
//           equation 
//             zero = 1 / m * sum(u);
//             y = TransformationMatrix * u;
//           end ToSpacePhasor;
//           block FromSpacePhasor "Conversion: space phasor -> three phase"
//             extends Modelica.Blocks.Interfaces.MIMO(final nin = 2, final nout = m);
//             constant Integer m = 3 "number of phases";
//             constant Real pi = Modelica.Constants.pi;
//             Modelica.Blocks.Interfaces.RealInput zero annotation(Placement(visible = true, transformation(origin = { -120.0, -80.0}, extent = {{ -20.0,20.0},{20.0, -20.0}}, rotation = 0), iconTransformation(origin = { -120.0, -80.0}, extent = {{ -20.0,20.0},{20.0, -20.0}}, rotation = 0)));
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Transformation of space phasor and zero sequence value to threephase values (voltages or currents).
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, origin = { -35.0,35.0}, points = {{35.0, -35.0},{ -35.0,35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = { -35.0, -35.0}, points = {{35.0,35.0},{ -35.0, -35.0}}, color = {0,0,255}, arrowSize = 20),Line(visible = true, origin = {50.0, -0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = {40.0, -0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Line(visible = true, origin = {30.0, -0.0}, points = {{ -40.0,0.0},{ -20.0,30.0},{0.0,0.0},{20.0, -30.0},{40.0,0.0}}, color = {0,0,255}, smooth = Smooth.Bezier),Polygon(visible = true, origin = { -70.0,70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{10.0,0.0},{0.0, -10.0},{ -10.0,10.0}}),Polygon(visible = true, origin = { -70.0, -70.0}, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{10.0,0.0},{0.0,10.0},{ -10.0, -10.0}})}));
//           protected 
//             parameter Real TransformationMatrix[2,m] = 2 / m * {array(cos( +(k - 1) / m * 2 * pi) for k in 1:m),array( +sin( +(k - 1) / m * 2 * pi) for k in 1:m)};
//             parameter Real InverseTransformation[m,2] = array({cos( -(k - 1) / m * 2 * pi), -sin( -(k - 1) / m * 2 * pi)} for k in 1:m);
// 
//           equation 
//             y = fill(zero, m) + InverseTransformation * u;
//           end FromSpacePhasor;
//           block Rotator "Rotates space phasor"
//             extends Modelica.Blocks.Interfaces.MIMOs(final n = 2);
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Rotates a space phasor (voltage or current) by the angle provided by the input signal \"angle\" from one coordinate system into another.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0.0,0.0},{0.0,80.0},{ -10.0,60.0},{10.0,60.0},{0.0,80.0}}, color = {0,0,255}),Line(visible = true, points = {{0.0,0.0},{80.0,0.0},{60.0,10.0},{60.0, -10.0},{80.0,0.0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -50.0, -50.0},{50.0,50.0}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -51.89, -50.0},{ -2.0,51.54}}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{ -8.59, -52.23},{53.26, -1.718}}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{50.0,0.0},{42.0,14.0},{54.0,16.0},{50.0,0.0}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -88.0, -92.0},{84.0, -72.0}}, textString = "angle", fontName = "Arial")}));
//             Modelica.Blocks.Interfaces.RealInput angle(redeclare type SignalType = Modelica.SIunits.Angle) annotation(Placement(visible = true, transformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90), iconTransformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90)));
//           protected 
//             Real RotationMatrix[2,2] = {{ +cos( -angle), -sin( -angle)},{ +sin( -angle), +cos( -angle)}};
// 
//           equation 
//             y = RotationMatrix * u;
//           end Rotator;
//           block ToPolar "Converts a space phasor to polar coordinates"
//             extends Modelica.Blocks.Interfaces.MIMOs(final n = 2);
//             constant Real small = Modelica.Constants.small;
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Converts a space phasor from rectangular coordinates to polar coordinates.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60.0,60.0},{ -60.0, -60.0},{60.0, -60.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -100.0},{100.0,100.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, points = {{26.0,26.0},{14.0,20.0},{20.0,14.0},{26.0,26.0}}),Line(visible = true, points = {{ -18.0, -18.0},{ -14.0, -22.0},{ -10.0, -28.0},{ -6.0, -34.0},{ -2.0, -44.0},{0.0, -52.0},{0.0, -60.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, points = {{ -18.0, -18.0},{ -14.0, -26.0},{ -10.0, -22.0},{ -18.0, -18.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -6.0},{ -6.0,100.0}}, textString = "R", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{6.0, -100.0},{100.0,6.0}}, textString = "P", fontName = "Arial")}));
// 
//           equation 
//             y[1] = sqrt(u[1] ^ 2 + u[2] ^ 2);
//             y[2] = if noEvent(y[1] <= small) then 0 else Modelica.Math.atan2(u[2], u[1]);
//           end ToPolar;
//           block FromPolar "Converts a space phasor from polar coordinates"
//             extends Modelica.Blocks.Interfaces.MIMOs(final n = 2);
//             annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60.0,60.0},{ -60.0, -60.0},{60.0, -60.0}}, color = {0,0,255}),Line(visible = true, points = {{ -100.0, -100.0},{100.0,100.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, points = {{26.0,26.0},{14.0,20.0},{20.0,14.0},{26.0,26.0}}),Line(visible = true, points = {{ -18.0, -18.0},{ -14.0, -22.0},{ -10.0, -28.0},{ -6.0, -34.0},{ -2.0, -44.0},{0.0, -52.0},{0.0, -60.0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, points = {{ -18.0, -18.0},{ -14.0, -26.0},{ -10.0, -22.0},{ -18.0, -18.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -6.0},{ -6.0,100.0}}, textString = "P", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{6.0, -100.0},{100.0,6.0}}, textString = "R", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Converts a space phasor from polar coordinates to rectangular coordinates.
// </p>
// </HTML>"));
// 
//           equation 
//             y = u[1] * {cos(u[2]),sin(u[2])};
//           end FromPolar;
//         end Blocks;
//         package Functions "Functions for space phasor transformation"
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains space phasor transformation functions for use in calculations:
// <ul>
// <li>ToSpacePhasor: transforms a set of threephase values to space phasor and zero sequence system</li>
// <li>FromSpacePhasor: transforms a space phasor and zero sequence system to a set of threephase values</li>
// <li>Rotator: rotates a space phasor (from one coordinate system into another)</li>
// <li>ToPolar: Converts a space phasor from rectangular coordinates to polar coordinates</li>
// <li>FromPolar: Converts a space phasor from polar coordinates to rectangular coordinates</li>
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   </ul>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.6.1 2005/11/10 Anton Haumer<br>
//        improved Transformation and Rotation</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           function ToSpacePhasor "Conversion: three phase -> space phasor"
//             extends Modelica.Icons.Function;
//             constant Integer m = 3 "number of phases";
//             constant Real pi = Modelica.Constants.pi;
//             input Real x[3];
//             output Real y[2];
//             output Real y0;
//             annotation(Documentation(info = "<HTML>
// <p>
// Transformation of three phase values (voltages or currents) to space phasor and zero sequence value:<br>
// y[k] = X0 + {cos(-(k - 1)/m*2*pi),-sin(-(k - 1)/m*2*pi) * X[Re,Im]<br>
// were y designates three phase values, X[Re,Im] designates the space phasor and X0 designates the zero sequence system.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           algorithm 
//             y:=zeros(2);
//             for k in 1:m loop
//                           y:=y + 2 / m * { +cos((k - 1) / m * 2 * pi), +sin( +(k - 1) / m * 2 * pi)} * x[k];
// 
//             end for;
//             y0:=1 / m * sum(x);
//           end ToSpacePhasor;
//           function FromSpacePhasor "Conversion: space phasor -> three phase"
//             extends Modelica.Icons.Function;
//             constant Integer m = 3 "number of phases";
//             constant Real pi = Modelica.Constants.pi;
//             input Real x[2];
//             input Real x0;
//             output Real y[3];
//             annotation(Documentation(info = "<HTML>
// <p>
// Transformation of space phasor and zero sequence value to three phase values (voltages or currents):<br>
// Y0 = sum(x[k])/m<br>
// Y[Re,Im] = sum(2/m*{cos((k - 1)/m*2*pi),sin((k - 1)/m*2*pi)}*x[k])<br>
// were x designates three phase values, Y[Re,Im] designates the space phasor and Y0 designates the zero sequence system.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           algorithm 
//             for k in 1:m loop
//                           y[k]:=x0 + {cos( -(k - 1) / m * 2 * pi), -sin( -(k - 1) / m * 2 * pi)} * x;
// 
//             end for;
//           end FromSpacePhasor;
//           function Rotator "Rotates space phasor"
//             extends Modelica.Icons.Function;
//             input Real x[2];
//             input Modelica.SIunits.Angle angle;
//             output Real y[2];
//             annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           protected 
//             Real RotationMatrix[2,2] = {{ +cos( -angle), -sin( -angle)},{ +sin( -angle), +cos( -angle)}};
//             annotation(Documentation(info = "<HTML>
// <p>
// Rotates a space phasor (voltage or current) by the angle provided by input argument \"angle\" from one coordinate system into another:<br>
// y[Re,Im] := {{+cos(-angle),-sin(-angle)},{+sin(-angle),+cos(-angle)}}*x[Re,Im]<br>
// where y[Re,Im] designates the space phasor in the new coordinate system (twisted by angle against old coordinate system) and y[Re,Im] designates the space phasor in the old coordinate system.
// </p>
// </HTML>"));
//           algorithm 
//             y:=RotationMatrix * x;
//           end Rotator;
//           function ToPolar "Converts a space phasor to polar coordinates"
//             extends Modelica.Icons.Function;
//             constant Real small = Modelica.Constants.small;
//             input Real x[2];
//             output Real absolute;
//             output Modelica.SIunits.Angle angle;
//             annotation(Documentation(info = "<HTML>
// <p>
// Converts a space phasor from rectangular coordinates to polar coordinates, providing angle=0 for {0,0}.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           algorithm 
//             absolute:=sqrt(x[1] ^ 2 + x[2] ^ 2);
//             angle:=if absolute <= small then 0 else Modelica.Math.atan2(x[2], x[1]);
//           end ToPolar;
//           function FromPolar "Converts a space phasor from polar coordinates"
//             extends Modelica.Icons.Function;
//             constant Real pi = Modelica.Constants.pi;
//             constant Real small = Modelica.Constants.small;
//             input Real absolute;
//             input Modelica.SIunits.Angle angle;
//             output Real x[2];
//             annotation(Documentation(info = "<HTML>
// <p>
// Converts a space phasor from polar coordinates to rectangular coordinates.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           algorithm 
//             x:=absolute * {cos(angle),sin(angle)};
//           end FromPolar;
//         end Functions;
//       end SpacePhasors;
//       package Interfaces "SpacePhasor connector and PartialMachines"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains the space phasor connector and partial models for machine models.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// 
//   <ul>
//   <li> v1.00 2004/09/16 Anton Haumer</li>
//   <li> v1.01 2004/09/18 Anton Haumer<br>
//        moved common equations from machine models to PartialMachine</li>
//   <li> v1.02 2004/09/19 Anton Haumer<br>
//        added PartialDCMachine</li>
//   <li> v1.2  2004/10/27 Anton Haumer<br>
//        fixed a bug with support (formerly bearing)</li>
//   <li> v1.4   2004/11/11 Anton Haumer<br>
//        removed mechanical flange support<br>
//        to ease the implementation of a 3D-frame in a future release</li>
//   <li> v1.51 Beta 2005/02/01 Anton Haumer<br>
//        changed parameter polePairs to Integer</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -70.0, -30.0},{ -10.0,30.0},{50.0, -30.0},{ -10.0, -90.0},{ -70.0, -30.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector SpacePhasor "Connector for Space Phasors"
//           Modelica.SIunits.Voltage v_[2];
//           flow Modelica.SIunits.Current i_[2];
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{0.0,100.0},{ -100.0,0.0},{0.0, -100.0},{100.0,0.0},{0.0,100.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0, -90.0}}, textString = "%name", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{0.0,100.0},{ -100.0,0.0},{0.0, -100.0},{100.0,0.0},{0.0,100.0}})}), Documentation(info = "<HTML>
// <p>
// Connector for Space Phasors:
// <ul>
// <li>Voltage v_[2] ... Real and Imaginary part of voltage space phasor</li>
// <li>Current i_[2] ... Real and Imaginary part of current space phasor</li>
// </ul>
// </p>
// </HTML>"));
//         end SpacePhasor;
//         partial model PartialBasicMachine "Partial machine model"
//           parameter Modelica.SIunits.Inertia J_Rotor "rotor's moment of inertia";
//           output Modelica.SIunits.Angle phi_mechanical = flange_a.phi "mechanical angle of rotor against stator";
//           output Modelica.SIunits.AngularVelocity w_mechanical = der(phi_mechanical) "mechanical angular velocity of rotor against stator";
//           output Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm rpm_mechanical = Modelica.SIunits.Conversions.to_rpm(w_mechanical) "mechanical speed of rotor against stator [rpm]";
//           output Modelica.SIunits.Torque tau_electrical = inertiaRotor.flange_a.tau "electromagnetic torque";
//           output Modelica.SIunits.Torque tau_shaft =  -flange_a.tau "shaft torque";
//           Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia inertiaRotor(final J = J_Rotor) annotation(Placement(visible = true, transformation(origin = {70.0,0.0}, extent = {{10.0,10.0},{ -10.0, -10.0}}, rotation = 180)));
//           Modelica.Mechanics.Rotational.Fixed fixedHousing(final phi0 = 0) annotation(Placement(visible = true, transformation(origin = {40.0, -100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {0,127,255}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40.0,60.0},{80.0, -60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40.0,60.0},{ -60.0, -60.0}}),Rectangle(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.HorizontalCylinder, extent = {{80.0,10.0},{100.0, -10.0}}),Rectangle(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, extent = {{ -40.0,70.0},{40.0,50.0}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -50.0, -90.0},{ -40.0, -90.0},{ -10.0, -20.0},{40.0, -20.0},{70.0, -90.0},{80.0, -90.0},{80.0, -100.0},{ -50.0, -100.0},{ -50.0, -90.0}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -180.0},{150.0, -120.0}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         protected 
//           Modelica.Mechanics.Rotational.Interfaces.Flange_b internalSupport annotation(Placement(visible = true, transformation(origin = {20.0, -100.0}, extent = {{ -1.0, -1.0},{1.0,1.0}}, rotation = 0)));
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -40,60},{80, -60}}, lineColor = {0,0,0}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {0,127,255}),Rectangle(extent = {{ -40,60},{ -60, -60}}, lineColor = {0,0,0}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {128,128,128}),Rectangle(extent = {{80,10},{100, -10}}, lineColor = {0,0,0}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {128,128,128}),Rectangle(extent = {{ -40,70},{40,50}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Polygon(points = {{ -50, -90},{ -40, -90},{ -10, -20},{40, -20},{70, -90},{80, -90},{80, -100},{ -50, -100},{ -50, -90}}, lineColor = {0,0,0}, fillColor = {0,0,0}, fillPattern = FillPattern.Solid),Text(lineColor = {0,0,255}, extent = {{ -150, -120},{150, -180}}, fillColor = {0,0,255}, textString = "%name")}), Documentation(info = "<HTML>
// <p>
// Base partial model DC machines:
// <ul>
// <li>main parts of the icon</li>
// <li>mechanical flange</li>
// <li>mechanical support</li>
// </ul>
// </p>
// <p>
// The machine's stator is implicitely fixed. 
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(internalSupport,fixedHousing.flange_b) annotation(Line(visible = true, points = {{20.0, -100.0},{40.0, -100.0}}));
//           connect(inertiaRotor.flange_b,flange_a) annotation(Line(visible = true, points = {{80.0,0.0},{92.0,0.0},{92.0,0.0},{100.0,0.0}}));
//         end PartialBasicMachine;
//         partial model PartialBasicInductionMachine "Partial model for induction machine"
//           extends PartialBasicMachine(J_Rotor = 0.29);
//           constant Real pi = Modelica.Constants.pi;
//           constant Integer m = 3 "number of phases";
//           parameter Integer p(min = 1) = 2 "number of pole pairs (Integer)";
//           output Modelica.SIunits.Voltage vs[m] = plug_sp.pin.v - plug_sn.pin.v "stator instantaneous voltages";
//           output Modelica.SIunits.Current is[m] = plug_sp.pin.i "stator instantaneous currents";
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug plug_sp(final m = m) annotation(Placement(visible = true, transformation(origin = {60.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {60.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug plug_sn(final m = m) annotation(Placement(visible = true, transformation(origin = { -60.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -60.0,100.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Documentation(info = "<HTML>
// <p>
// Partial model for induction machine models, containing:
// <ul>
// <li>main parts of the icon</li>
// <li>stator plugs</li>
// <li>mechanical connectors</li>
// </ul>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -50.0,100.0},{ -20.0,100.0},{ -20.0,70.0}}, color = {0,0,255}),Line(visible = true, points = {{50.0,100.0},{20.0,100.0},{20.0,70.0}}, color = {0,0,255})}));
//         end PartialBasicInductionMachine;
//         partial model PartialBasicDCMachine "Partial model for DC machine"
//           extends PartialBasicMachine(J_Rotor = 0.15);
//           output Modelica.SIunits.Voltage va = pin_ap.v - pin_an.v "armature voltage";
//           output Modelica.SIunits.Current ia = pin_ap.i "armature current";
//           annotation(Documentation(info = "<HTML>
// <p>
// Partial model for DC machine models, containing:
// <ul>
// <li>main parts of the icon</li>
// <li>armature pins</li>
// <li>mechanical connectors</li>
// </ul>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -50.0,100.0},{ -20.0,100.0},{ -20.0,70.0}}, color = {0,0,255}),Line(visible = true, points = {{50.0,100.0},{20.0,100.0},{20.0,70.0}}, color = {0,0,255})}));
//           Modelica.Electrical.Analog.Interfaces.PositivePin pin_ap annotation(Placement(visible = true, transformation(origin = {60.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = {60.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin pin_an annotation(Placement(visible = true, transformation(origin = { -60.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -60.0,100.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//         end PartialBasicDCMachine;
//       end Interfaces;
//     end Machines;
//     package MultiPhase "Library for electrical components with 2, 3 or more phases"
//       extends Modelica.Icons.Library2;
//       annotation(version = "1.1", versionDate = "2006-01-12", classOrder = {"Examples","*"}, preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains packages for electrical multiphase components, based on Modelica.Electrical.Analog:
// <ul>
// <li>Basic: basic components (resistor, capacitor, inductor, ...)</li>
// <li>Ideal: ideal elements (switches, diode, transformer, ...)</li>
// <li>Sensors: sensors to measure potentials, voltages, and currents</li>
// <li>Sources: time-dependend and controlled voltage and current sources</li>
// </ul>
// This package is intended to be used the same way as Modelica.Electrical.Analog 
// but to make design of multiphase models easier.<br>
// The package is based on the plug: a composite connector containing m pins.<br>
// It is possible to connect plugs to plugs or single pins of a plug to single pins.<br>
// Potentials may be accessed as <tt>plug.pin[].v</tt>, currents may be accessed as <tt>plug.pin[].i</tt>.
// </p>
// <p>
// Further development:
// <ul>
// <li>temperature-dependent resistor</li>
// <li>lines (m-phase models)</li>
// </ul>
// </p>
// <dl>
// <p>
//   <dt><b>Main Author:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2005, Modelica Association and Anton Haumer.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>", revisions = "<html>
//   <ul>
//   <li>v1.0 2004/10/01 Anton Haumer</li>
//   <li>v1.1 2006/01/12 Anton Haumer<br>
//       added Sensors.PowerSensor</li>
//   </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -90},{40,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -34},{ -20, -14}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{0, -34},{20, -14}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -20, -74},{0, -54}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Basic "Basic components for electrical multiphase models"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains basic analog electrical multiphase components.
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.0 2004/10/01 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -80, -70},{60, -10}}),Line(visible = true, points = {{60, -40},{80, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -100, -40},{ -80, -40}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model Star "Star-connection"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Connects all pins of plug_p to pin_n, thus establishing a so-called star-connection.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{80,0},{0,0}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{0,0},{ -39,68}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{0,0},{ -38, -69}}, color = {0,0,255}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -110},{100, -70}}, textString = "m=%m", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{80,0},{90,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin pin_n annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           for j in 1:m loop
//           connect(plug_p.pin[j],pin_n);
// 
//           end for;
//         end Star;
//         model Delta "Delta (polygon) connection"
//           parameter Integer m(final min = 2) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Connects in a cyclic way plug_n.pin[j] to plug_p.pin[j+1], 
// thus establishing a so-called delta (or polygon) connection 
// when used in parallel to another component.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,60},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -40,68},{ -40, -70},{79,0},{ -40,68},{ -40,67}}, color = {0,0,255}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -110},{100, -70}}, textString = "m=%m", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{80,0},{90,0}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           for j in 1:m loop
//           if j < m then
//             connect(plug_n.pin[j],plug_p.pin[j + 1]);
// 
//           else
//             connect(plug_n.pin[j],plug_p.pin[1]);
// 
//           end if;
// 
//           end for;
//         end Delta;
//         model PlugToPin_p "Connect one (positive) Pin"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Integer k(final min = 1, final max = m) = 1 "phase index";
//           annotation(Documentation(info = "<HTML>
// <p>
// Connects pin <i>k</i> of plug_p to pin_p, leaving the other pins of plug_p unconnected.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "k = %k", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -100,10},{90,0},{ -100, -10},{ -100,10}})}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.PositivePin pin_p annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           pin_p.v = plug_p.pin[k].v;
//           for j in 1:m loop
//           plug_p.pin[j].i = if j == k then  -pin_p.i else 0;
// 
//           end for;
//         end PlugToPin_p;
//         model PlugToPin_n "Connect one (negative) Pin"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Integer k(final min = 1, final max = m) = 1 "phase index";
//           annotation(Documentation(info = "<HTML>
// <p>
// Connects pin <i>k</i> of plug_n to pin_n, leaving the other pins of plug_n unconnected.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{92,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "k = %k", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, points = {{ -100,10},{92,0},{ -100, -10},{ -100,10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Interfaces.NegativePin pin_n annotation(Placement(visible = true, transformation(origin = {102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {102,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           pin_n.v = plug_n.pin[k].v;
//           for j in 1:m loop
//           plug_n.pin[j].i = if j == k then  -pin_n.i else 0;
// 
//           end for;
//         end PlugToPin_n;
//         model Resistor "Ideal linear electrical resistors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance R[m] = fill(1, m) "Resistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m resistors (Modelica.Electrical.Analog.Basic.Resistor)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.Resistor resistor[m](final R = R) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(resistor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(resistor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//         end Resistor;
//         model Conductor "Ideal linear electrical conductors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance G[m] = fill(1, m) "Conductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m conductors (Modelica.Electrical.Analog.Basic.Conductor)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.Conductor conductor[m](final G = G) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(plug_n.pin,conductor.n) annotation(Line(visible = true, origin = {55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,conductor.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//         end Conductor;
//         model Capacitor "Ideal linear electrical capacitors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Capacitance C[m] = fill(1, m) "Capacitance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m capacitors (Modelica.Electrical.Analog.Basic.Capacitor)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -14,28},{ -14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{14,28},{14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{ -90,0},{ -14,0}}, color = {0,0,255}),Line(visible = true, points = {{14,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.Capacitor capacitor[m](final C = C) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(capacitor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(capacitor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//         end Capacitor;
//         model Inductor "Ideal linear electrical inductors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Inductance L[m] = fill(1, m) "Inductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m inductors (Modelica.Electrical.Analog.Basic.Inductor)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{60,0}}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -60,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.Inductor inductor[m](final L = L) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(inductor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(inductor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//         end Inductor;
//         model SaturatingInductor "Simple model of inductors with saturation"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Current Inom[m] = fill(1, m) "Nominal current";
//           parameter Modelica.SIunits.Inductance Lnom[m] = fill(1, m) "Nominal inductance at Nominal current";
//           parameter Modelica.SIunits.Inductance Lzer[m] = array(2 * Lnom[j] for j in 1:m) "Inductance near current=0";
//           parameter Modelica.SIunits.Inductance Linf[m] = array(Lnom[j] / 2 for j in 1:m) "Inductance at large currents";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m saturating inductors (Modelica.Electrical.Analog.Basic.SaturatingInductor)
// </p>
// <p>
// <b>Attention!!!</b><br>
// Each element of the array of saturatingInductors is only dependent on the current flowing through this element.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -20},{60,0}}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -60,0}}, color = {0,0,255}),Rectangle(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Sphere, extent = {{ -60, -20},{60, -10}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Basic.SaturatingInductor saturatingInductor[m](final Inom = Inom, final Lnom = Lnom, final Lzer = Lzer, final Linf = Linf) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(saturatingInductor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(saturatingInductor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//         end SaturatingInductor;
//         model Transformer "Multiphase Transformer"
//           extends Interfaces.FourPlug;
//           parameter Modelica.SIunits.Inductance L1[m] = fill(1, m) "Primary inductance";
//           parameter Modelica.SIunits.Inductance L2[m] = fill(1, m) "Secondary inductance";
//           parameter Modelica.SIunits.Inductance M[m] = fill(1, m) "Coupling inductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m transformers (Modelica.Electrical.Analog.Basic.Transformer)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -72, -60},{ -33,60}}),Line(visible = true, points = {{ -90,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{33, -60},{72,60}}),Line(visible = true, points = {{32,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{90, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -20},{ -58,20}}, textString = "L1", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{60, -20},{100,20}}, textString = "L2", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -20, -20},{20,20}}, textString = "M", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -80, -100},{80, -60}}, textString = "m=%m", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,50},{100,110}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.Transformer transformer[m](final L1 = L1, final L2 = L2, final M = M) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(plug_n2.pin,transformer.n2) annotation(Line(visible = true, points = {{100, -100},{10, -100},{10, -5}}, color = {0,0,255}));
//           connect(plug_n1.pin,transformer.n1) annotation(Line(visible = true, points = {{ -100, -100},{ -10, -100},{ -10, -5}}, color = {0,0,255}));
//           connect(plug_p2.pin,transformer.p2) annotation(Line(visible = true, points = {{100,100},{10,100},{10,5}}, color = {0,0,255}));
//           connect(plug_p1.pin,transformer.p1) annotation(Line(visible = true, points = {{ -100,100},{ -10,100},{ -10,5}}, color = {0,0,255}));
//         end Transformer;
//         model VariableResistor "Ideal linear electrical resistors with variable resistance"
//           extends Interfaces.TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m variable resistors (Modelica.Electrical.Analog.Basic.VariableResistor)
// </p>
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that none of the R_Port signals should not cross the zero value. 
//   Otherwise depending on the surrounding circuit the probability of singularities is high.
// </P>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,40},{100,80}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.VariableResistor variableResistor[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput R[m](redeclare type SignalType = Modelica.SIunits.Resistance) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(variableResistor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(variableResistor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(R,variableResistor.R) annotation(Line(visible = true, points = {{0,100},{0,11}}, color = {0,0,255}));
//         end VariableResistor;
//         model VariableConductor "Ideal linear electrical conductors with variable conductance"
//           extends Interfaces.TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m variable conductors (Modelica.Electrical.Analog.Basic.VariableConductor)
// </p>
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that none of the G_Port signals should not cross the zero value. 
//   Otherwise depending on the surrounding circuit the probability of singularities is high.
// </P>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -70,0}}, color = {0,0,255}),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -30},{70,30}}),Line(visible = true, points = {{70,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,40},{100,80}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Basic.VariableConductor variableConductor[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput G[m](redeclare type SignalType = Modelica.SIunits.Conductance) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(variableConductor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(variableConductor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(G,variableConductor.G) annotation(Line(visible = true, points = {{0,100},{0,11}}, color = {0,0,255}));
//         end VariableConductor;
//         model VariableCapacitor "Ideal linear electrical capacitors with variable capacitance"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Capacitance Cmin[m] = fill(Modelica.Constants.eps, m);
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m variable capacitors (Modelica.Electrical.Analog.Basic.VariableCapacitor)
// </p>
// <P>
// It is required that each C_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// C = Cmin, if 0 &le; C_Port.signal &lt; Cmin, where
// Cmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,90},{0,30}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,40},{100,80}}, textString = "m=%m", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -14,0}}, color = {0,0,255}),Line(visible = true, points = {{14,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -14,28},{ -14, -28}}, color = {0,0,255}, thickness = 0.5),Line(visible = true, points = {{14,28},{14, -28}}, color = {0,0,255}, thickness = 0.5)}));
//           Modelica.Electrical.Analog.Basic.VariableCapacitor variableCapacitor[m](final Cmin = Cmin) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput C[m](redeclare type SignalType = Modelica.SIunits.Capacitance) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(variableCapacitor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(variableCapacitor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(C,variableCapacitor.C) annotation(Line(visible = true, points = {{0,100},{0,11}}, color = {0,0,255}));
//         end VariableCapacitor;
//         model VariableInductor "Ideal linear electrical inductors with variable inductance"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Inductance Lmin[m] = fill(Modelica.Constants.eps, m);
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m variable inductors (Modelica.Electrical.Analog.Basic.VariableInductor)
// </p>
// <P>
// It is required that each L_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// L = Lmin, if 0 &le; L_Port.signal &lt; Lmin, where
// Lmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,40},{100,80}}, textString = "m=%m", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -60,0}}, color = {0,0,255}),Line(visible = true, points = {{60,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,8}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -15},{ -30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -30, -15},{0,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{0, -15},{30,15}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{30, -15},{60,15}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{60,0}})}));
//           Modelica.Electrical.Analog.Basic.VariableInductor variableInductor[m](final Lmin = Lmin) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput L[m](redeclare type SignalType = Modelica.SIunits.Inductance) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(variableInductor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(variableInductor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(L,variableInductor.L) annotation(Line(visible = true, points = {{0,100},{0,10.8}}, color = {0,0,255}));
//         end VariableInductor;
//       end Basic;
//       package Examples "Multiphase test examples"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains test examples of analog electrical multiphase circuits.
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.0 2004/10/01 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {128,128,128}, extent = {{ -60, -88},{40,12}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -30, -10},{ -30, -66},{28, -38},{ -30, -10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model TransformerYY "Test example with multiphase components"
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a Y-Y-transformer with internal impedance (RT, LT) a load resistor RT.<br>
// Using f=5 Hz LT=3mH defines nominal voltage drop of approximately 10 %.<br>
// Simulate for 1 second (2 periods) and compare voltages and currents of source, transformer and load.
// </p>
// </HTML>"), experiment(StopTime = 1.0), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance LT = 0.003 "Transformer stray inductance";
//           parameter Modelica.SIunits.Resistance RT = 0.05 "Transformer resistance";
//           parameter Modelica.SIunits.Resistance RL = 1 "Load Resistance";
//           Sources.SineVoltage SineVoltage1(V = fill(V, m), freqHz = fill(f, m), m = m) annotation(Placement(visible = true, transformation(origin = { -80,20}, extent = {{ -10, -10},{10,10}}, rotation = 180)));
//           Modelica.Electrical.Analog.Basic.Ground GroundS1 annotation(Placement(visible = true, transformation(origin = { -90, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Ideal.IdealTransformer IdealTransformer1(m = m) annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground GroundT2 annotation(Placement(visible = true, transformation(origin = { -20, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Resistor RT1(m = m, R = fill(RT, m)) annotation(Placement(visible = true, transformation(origin = {10,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Inductor LT1(m = m, L = fill(LT, m)) annotation(Placement(visible = true, transformation(origin = {40,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Resistor RL1(m = m, R = fill(RL, m)) annotation(Placement(visible = true, transformation(origin = {80,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground GroundT1 annotation(Placement(visible = true, transformation(origin = { -40, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Star StarT2(m = m) annotation(Placement(visible = true, transformation(origin = { -20, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarT1(m = m) annotation(Placement(visible = true, transformation(origin = { -40, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarS1(m = m) annotation(Placement(visible = true, transformation(origin = { -90, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarL1(m = m) annotation(Placement(visible = true, transformation(origin = {90, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(LT1.plug_n,RL1.plug_p) annotation(Line(visible = true, points = {{50,20},{70,20}}, color = {0,0,255}));
//           connect(RT1.plug_n,LT1.plug_p) annotation(Line(visible = true, points = {{20,20},{30,20}}, color = {0,0,255}));
//           connect(IdealTransformer1.plug_p2,RT1.plug_p) annotation(Line(visible = true, points = {{ -20,20},{0,20}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,IdealTransformer1.plug_p1) annotation(Line(visible = true, points = {{ -70,20},{ -40,20}}, color = {0,0,255}));
//           connect(StarT2.pin_n,GroundT2.p) annotation(Line(visible = true, points = {{ -20, -72.5},{ -20, -80}}, color = {0,0,255}));
//           connect(StarT2.plug_p,IdealTransformer1.plug_n2) annotation(Line(visible = true, points = {{ -20, -52.5},{ -20,0}}, color = {0,0,255}));
//           connect(StarT1.pin_n,GroundT1.p) annotation(Line(visible = true, points = {{ -40, -72.5},{ -40, -72},{ -40, -80}}, color = {0,0,255}));
//           connect(IdealTransformer1.plug_n1,StarT1.plug_p) annotation(Line(visible = true, points = {{ -40,0},{ -40, -52.5}}, color = {0,0,255}));
//           connect(StarS1.pin_n,GroundS1.p) annotation(Line(visible = true, points = {{ -90, -72.5},{ -90, -80}}, color = {0,0,255}));
//           connect(StarS1.plug_p,SineVoltage1.plug_n) annotation(Line(visible = true, points = {{ -90, -52.5},{ -90,20},{ -90,20}}, color = {0,0,255}));
//           connect(RL1.plug_n,StarL1.plug_p) annotation(Line(visible = true, points = {{90,20},{90, -52.5}}, color = {0,0,255}));
//         end TransformerYY;
//         model TransformerYD "Test example with multiphase components"
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance LT = 0.003 "Transformer stray inductance";
//           parameter Modelica.SIunits.Resistance RT = 0.05 "Transformer resistance";
//           parameter Modelica.SIunits.Resistance RL = 1 "Load Resistance";
//           parameter Real nT = 1 / sqrt((1 - cos((2 * Modelica.Constants.pi) / m)) ^ 2 + sin((2 * Modelica.Constants.pi) / m) ^ 2) "Transformer ratio";
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a Y-D-transformer with internal impedance (RT, LT) a load resistor RT.<br>
// Using f=5 Hz LT=3mH defines nominal voltage drop of approximately 10 %.<br>
// Simulate for 1 second (2 periods) and compare voltages and currents of source, transformer and load.
// </p>
// </HTML>"), experiment(StopTime = 1.0), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Sources.SineVoltage SineVoltage1(V = fill(V, m), freqHz = fill(f, m), m = m) annotation(Placement(visible = true, transformation(origin = { -80,20}, extent = {{ -10, -10},{10,10}}, rotation = 180)));
//           Modelica.Electrical.Analog.Basic.Ground GroundS1 annotation(Placement(visible = true, transformation(origin = { -90, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Ideal.IdealTransformer IdealTransformer1(m = m, n = fill(nT, m)) annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Delta Delta1(m = m) annotation(Placement(visible = true, transformation(origin = {50,10}, extent = {{10, -10},{ -10,10}}, rotation = 90)));
//           Modelica.Electrical.Analog.Basic.Ground GroundT1 annotation(Placement(visible = true, transformation(origin = { -40, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Resistor RT1(m = m, R = fill(RT / nT ^ 2, m)) annotation(Placement(visible = true, transformation(origin = {0,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Inductor LT1(m = m, L = fill(LT / nT ^ 2, m)) annotation(Placement(visible = true, transformation(origin = {30,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Resistor RL1(m = m, R = fill(RL, m)) annotation(Placement(visible = true, transformation(origin = {80,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground GroundL1 annotation(Placement(visible = true, transformation(origin = {90, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Basic.Star StarT1(m = m) annotation(Placement(visible = true, transformation(origin = { -40, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarL1(m = m) annotation(Placement(visible = true, transformation(origin = {90, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarS1(m = m) annotation(Placement(visible = true, transformation(origin = { -90, -62.5}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(Delta1.plug_p,RL1.plug_p) annotation(Line(visible = true, points = {{50,20},{70,20}}, color = {0,0,255}));
//           connect(Delta1.plug_n,IdealTransformer1.plug_n2) annotation(Line(visible = true, points = {{50,0},{ -20,0}}, color = {0,0,255}));
//           connect(LT1.plug_n,Delta1.plug_p) annotation(Line(visible = true, points = {{40,20},{50,20}}, color = {0,0,255}));
//           connect(RT1.plug_n,LT1.plug_p) annotation(Line(visible = true, points = {{10,20},{20,20}}, color = {0,0,255}));
//           connect(IdealTransformer1.plug_p2,RT1.plug_p) annotation(Line(visible = true, points = {{ -20,20},{ -10,20}}, color = {0,0,255}));
//           connect(SineVoltage1.plug_p,IdealTransformer1.plug_p1) annotation(Line(visible = true, points = {{ -70,20},{ -40,20}}, color = {0,0,255}));
//           connect(GroundT1.p,StarT1.pin_n) annotation(Line(visible = true, points = {{ -40, -80},{ -40, -72.5}}, color = {0,0,255}));
//           connect(IdealTransformer1.plug_n1,StarT1.plug_p) annotation(Line(visible = true, points = {{ -40,0},{ -40, -52.5}}, color = {0,0,255}));
//           connect(RL1.plug_n,StarL1.plug_p) annotation(Line(visible = true, points = {{90,20},{90, -52},{90, -52.5}}, color = {0,0,255}));
//           connect(StarL1.pin_n,GroundL1.p) annotation(Line(visible = true, points = {{90, -72.5},{90, -80}}, color = {0,0,255}));
//           connect(GroundS1.p,StarS1.pin_n) annotation(Line(visible = true, points = {{ -90, -80},{ -90, -72.5}}, color = {0,0,255}));
//           connect(StarS1.plug_p,SineVoltage1.plug_n) annotation(Line(visible = true, points = {{ -90, -52.5},{ -90,20},{ -90,20}}, color = {0,0,255}));
//         end TransformerYD;
//         model Rectifier "Test example with multiphase components"
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance L = 0.001 "Line Inductance";
//           parameter Modelica.SIunits.Resistance RL = 2 "Load Resistance";
//           parameter Modelica.SIunits.Capacitance C = 0.05 "Total DC-Capacitance";
//           parameter Modelica.SIunits.Resistance RE = 1000000.0 "Earthing Resistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a line reactor a diode bridge rectifier with a DC burden.<br>
// Using f=5 Hz, simulate for 1 second (2 periods) and compare voltages and currents of source and DC burden, 
// neglecting initial transient.
// </p>
// </HTML>"), experiment(StopTime = 1.0, NumberOfIntervals = 1000), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Sources.SineVoltage SineVoltage1(m = m, V = fill(V, m), freqHz = fill(f, m)) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Basic.Inductor L1(m = m, L = fill(L, m)) annotation(Placement(visible = true, transformation(origin = { -42,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.Ground GroundDC annotation(Placement(visible = true, transformation(origin = {90, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Ideal.IdealDiode IdealDiode1(m = m) annotation(Placement(visible = true, transformation(origin = {10,20}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Basic.Star Star1(m = m) annotation(Placement(visible = true, transformation(origin = {10,50}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Basic.Star Star2(m = m) annotation(Placement(visible = true, transformation(origin = {10, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Basic.Star StarS(m = m) annotation(Placement(visible = true, transformation(origin = { -90, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Ideal.IdealDiode IdealDiode2(m = m) annotation(Placement(visible = true, transformation(origin = {10, -20}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Modelica.Electrical.Analog.Basic.Resistor RLoad(R = RL) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor2(C = 2 * C) annotation(Placement(visible = true, transformation(origin = {70, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 2 * C) annotation(Placement(visible = true, transformation(origin = {70,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(SineVoltage1.plug_p,L1.plug_p) annotation(Line(visible = true, points = {{ -70,0},{ -52,0}}, color = {0,0,255}));
//           connect(IdealDiode1.plug_p,L1.plug_n) annotation(Line(visible = true, points = {{10,10},{10,0},{ -32,0}}, color = {0,0,255}));
//           connect(IdealDiode1.plug_n,Star1.plug_p) annotation(Line(visible = true, points = {{10,30},{10,40}}, color = {0,0,255}));
//           connect(StarS.plug_p,SineVoltage1.plug_n) annotation(Line(visible = true, points = {{ -90, -40},{ -90,0}}, color = {0,0,255}));
//           connect(IdealDiode2.plug_n,L1.plug_n) annotation(Line(visible = true, points = {{10, -10},{10,0},{ -32,0}}, color = {0,0,255}));
//           connect(IdealDiode2.plug_p,Star2.plug_p) annotation(Line(visible = true, points = {{10, -30},{10, -40}}, color = {0,0,255}));
//           connect(Star2.pin_n,RLoad.n) annotation(Line(visible = true, points = {{10, -60},{50, -60},{50, -10}}, color = {0,0,255}));
//           connect(Star1.pin_n,RLoad.p) annotation(Line(visible = true, points = {{10,60},{50,60},{50,10}}, color = {0,0,255}));
//           connect(Star2.pin_n,Capacitor2.n) annotation(Line(visible = true, points = {{10, -60},{70, -60},{70, -40}}, color = {0,0,255}));
//           connect(Capacitor1.n,Capacitor2.p) annotation(Line(visible = true, points = {{70,20},{70, -20}}, color = {0,0,255}));
//           connect(Capacitor1.n,GroundDC.p) annotation(Line(visible = true, points = {{70,20},{70,0},{90,0},{90, -60}}, color = {0,0,255}));
//           connect(Star1.pin_n,Capacitor1.p) annotation(Line(visible = true, points = {{10,60},{70,60},{70,40}}, color = {0,0,255}));
//         end Rectifier;
//       end Examples;
//       package Ideal "Multiphase components with idealized behaviour"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains analog electrical multiphase components with idealized behaviour, 
// like thyristor, diode, switch, transformer.
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.0 2004/10/01 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -40},{80, -40}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{20, -40},{ -40,0},{ -40, -80},{20, -40}}),Line(visible = true, points = {{20,0},{20, -80}}, color = {0,0,255})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model IdealThyristor "Multiphase ideal thyristor"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal thyristors (Modelica.Electrical.Analog.Ideal.IdealThyristor).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{60,30}}, color = {0,0,255}),Line(visible = true, points = {{30,20},{70,60},{70,90}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{60,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Ideal.IdealThyristor idealThyristor[m](final Ron = Ron, final Goff = Goff, final Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput fire[m] annotation(Placement(visible = true, transformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealThyristor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idealThyristor.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(fire,idealThyristor.fire) annotation(Line(visible = true, points = {{70,110},{70,80},{7,80},{7,11}}, color = {255,0,255}));
//         end IdealThyristor;
//         model IdealGTOThyristor "Multiphase ideal GTO thyristor"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal GTO thyristors (Modelica.Electrical.Analog.Ideal.IdealGTOThyristor).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{60,30}}, color = {0,0,255}),Line(visible = true, points = {{30,20},{70,60},{70,90}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{60,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Ideal.IdealGTOThyristor idealGTOThyristor[m](final Ron = Ron, final Goff = Goff, final Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput fire[m] annotation(Placement(visible = true, transformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {70,110}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealGTOThyristor.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(idealGTOThyristor.p,plug_p.pin) annotation(Line(visible = true, origin = { -55,0}, points = {{45,0},{ -45,0}}, color = {0,0,255}));
//           connect(fire,idealGTOThyristor.fire) annotation(Line(visible = true, points = {{70,110},{70,80},{7,80},{7,11}}, color = {255,0,255}));
//         end IdealGTOThyristor;
//         model IdealCommutingSwitch "Multiphase ideal commuting switch"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal commuting switches (Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255})}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n2(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n1(final m = m) annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch idealCommutingSwitch[m](final Ron = Ron, final Goff = Goff) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control[m] "true => p--n2 connected, false => p--n1 connected" annotation(Placement(visible = true, transformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealCommutingSwitch.n1,plug_n1.pin) annotation(Line(visible = true, points = {{10,5},{10,50},{100,50}}, color = {0,0,255}));
//           connect(idealCommutingSwitch.n2,plug_n2.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idealCommutingSwitch.p) annotation(Line(visible = true, points = {{ -100,0},{ -10,0}}, color = {0,0,255}));
//           connect(control,idealCommutingSwitch.control) annotation(Line(visible = true, points = {{0,80},{0,8}}, color = {255,0,255}));
//         end IdealCommutingSwitch;
//         model IdealIntermediateSwitch "Multiphase ideal intermediate switch"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal intermediate switches (Modelica.Electrical.Analog.Ideal.IdealIntermediateSwitch).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial"),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -4,22},{4,30}}),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,50},{ -44,50}}, color = {0,0,255}),Line(visible = true, points = {{ -44,0},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{ -44,50},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{0,90},{0,25}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255})}));
//           Interfaces.PositivePlug plug_p1(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.PositivePlug plug_p2(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n2(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n1(final m = m) annotation(Placement(visible = true, transformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealIntermediateSwitch idealIntermediateSwitch[m](final Ron = Ron, final Goff = Goff) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control[m] "true => p1--n2, p2--n1 connected, otherwise p1--n1, p2--n2 connected" annotation(Placement(visible = true, transformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,80}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealIntermediateSwitch.n1,plug_n1.pin) annotation(Line(visible = true, points = {{10,5},{10,50},{100,50}}, color = {0,0,255}));
//           connect(idealIntermediateSwitch.p1,plug_p1.pin) annotation(Line(visible = true, points = {{ -10,5},{ -10,50},{ -100,50}}, color = {0,0,255}));
//           connect(idealIntermediateSwitch.n2,plug_n2.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(plug_p2.pin,idealIntermediateSwitch.p2) annotation(Line(visible = true, points = {{ -100,0},{ -10,0}}, color = {0,0,255}));
//           connect(control,idealIntermediateSwitch.control) annotation(Line(visible = true, points = {{0,80},{0,8}}, color = {255,0,255}));
//         end IdealIntermediateSwitch;
//         model IdealDiode "Multiphase ideal diode"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed diode resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened diode conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal diodes (Modelica.Electrical.Analog.Ideal.IdealDiode).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{40,0}}, color = {0,0,255}),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{30,0},{ -30,40},{ -30, -40},{30,0}}),Line(visible = true, points = {{30,40},{30, -40}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -80,60},{80,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Ideal.IdealDiode idealDiode[m](final Ron = Ron, final Goff = Goff, final Vknee = Vknee) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(idealDiode.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idealDiode.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//         end IdealDiode;
//         model IdealTransformer "Multiphase ideal transformer"
//           extends Interfaces.FourPlug;
//           parameter Real n[m] = fill(1, m) "Turns ratio";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -50},{ -20, -25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45, -25},{ -20,0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,0},{ -20,25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -45,25},{ -20,50}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -72, -60},{ -33,60}}),Line(visible = true, points = {{ -90,50},{ -32,50}}, color = {0,0,255}),Line(visible = true, points = {{ -90, -50},{ -32, -50}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -50},{45, -25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20, -25},{45,0}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,0},{45,25}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{20,25},{45,50}}),Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{33, -60},{72,60}}),Line(visible = true, points = {{32,50},{90,50}}, color = {0,0,255}),Line(visible = true, points = {{32, -50},{90, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -80,60},{80,100}}, textString = "m=%m", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -100, -110},{100, -50}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Contains m ideal transformers (Modelica.Electrical.Analog.Ideal.IdealTransformer).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Ideal.IdealTransformer idealTransformer[m](final n = n) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(plug_n2.pin,idealTransformer.n2) annotation(Line(visible = true, points = {{100, -100},{10, -100},{10, -5}}, color = {0,0,255}));
//           connect(plug_n1.pin,idealTransformer.n1) annotation(Line(visible = true, points = {{ -100, -100},{ -10, -100},{ -10, -5}}, color = {0,0,255}));
//           connect(plug_p2.pin,idealTransformer.p2) annotation(Line(visible = true, points = {{100,100},{10,100},{10,5}}, color = {0,0,255}));
//           connect(plug_p1.pin,idealTransformer.p1) annotation(Line(visible = true, points = {{ -100,100},{ -10,100},{ -10,5}}, color = {0,0,255}));
//         end IdealTransformer;
//         model Idle "Multiphase idle branch"
//           extends Interfaces.TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m idles (Modelica.Electrical.Analog.Ideal.Idle)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{150,110}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial"),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -90,0},{ -41,0}}, color = {0,0,255}),Line(visible = true, points = {{91,0},{40,0}}, color = {0,0,255})}));
//           Modelica.Electrical.Analog.Ideal.Idle idle[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(idle.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idle.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//         end Idle;
//         model Short "Multiphase short cut branch"
//           extends Interfaces.TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m short cuts (Modelica.Electrical.Analog.Ideal.Short)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{150,110}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{100, -60}}, textString = "m=%m", fontName = "Arial"),Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -60},{60,60}}),Line(visible = true, points = {{ -90,0},{90,0}}, color = {0,0,255})}));
//           Modelica.Electrical.Analog.Ideal.Short short[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(short.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,short.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//         end Short;
//         model IdealOpeningSwitch "Multiphase ideal opener"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal opening switches (Modelica.Electrical.Analog.Ideal.IdealOpeningSwitch).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{0,88},{0,26}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial"),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255})}));
//           Modelica.Electrical.Analog.Ideal.IdealOpeningSwitch idealOpeningSwitch[m](final Ron = Ron, final Goff = Goff) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control[m] "true => switch open, false => p--n connected" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealOpeningSwitch.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idealOpeningSwitch.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(control,idealOpeningSwitch.control) annotation(Line(visible = true, points = {{0,70},{0,7}}, color = {255,0,255}));
//         end IdealOpeningSwitch;
//         model IdealClosingSwitch "Multiphase ideal closer"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m ideal closing switches (Modelica.Electrical.Analog.Ideal.IdealClosingSwitch).
// </p><
// /HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -100},{150, -40}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -44,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -44, -4},{ -36,4}}),Line(visible = true, points = {{ -37,2},{40,50}}, color = {0,0,255}),Line(visible = true, points = {{0,88},{0,26}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{90,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Ideal.IdealClosingSwitch idealClosingSwitch[m](final Ron = Ron, final Goff = Goff) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput control[m] "true => p--n connected, false => switch open" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(idealClosingSwitch.n,plug_n.pin) annotation(Line(visible = true, origin = {55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(plug_p.pin,idealClosingSwitch.p) annotation(Line(visible = true, origin = { -55,0}, points = {{ -45,0},{45,0}}, color = {0,0,255}));
//           connect(control,idealClosingSwitch.control) annotation(Line(visible = true, points = {{0,70},{0,7}}, color = {255,0,255}));
//         end IdealClosingSwitch;
//       end Ideal;
//       package Interfaces "Interfaces for electrical multiphase models"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains connectors and interfaces (partial models) for
// electrical multiphase components, based on Modelica.Electrical.Analog.
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.0 2004/10/01 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -60, -90},{40,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -34},{ -20, -14}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{0, -34},{20, -14}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -20, -74},{0, -54}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector Plug "Plug with m pins for an electric component"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Interfaces.Pin pin[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end Plug;
//         connector PositivePlug "Positive plug with m pins"
//           extends Plug;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -100, -179},{100, -99}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"));
//         end PositivePlug;
//         connector NegativePlug "Negative plug with m pins"
//           extends Plug;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -100, -180},{100, -100}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"));
//         end NegativePlug;
//         partial model TwoPlug "Component with one m-phase electric port"
//           parameter Integer m(min = 1) = 3 "number of phases";
//           Modelica.SIunits.Voltage v[m] "Voltage drops between the two plugs";
//           Modelica.SIunits.Current i[m] "Currents flowing into positive plugs";
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>two</b> electrical plugs: 
// the positive plug connector <i>plug_p</i>, and the negative plug connector <i>plug_n</i>. 
// The currents flowing into plug_p are provided explicitly as currents i[m].
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v = plug_p.pin.v - plug_n.pin.v;
//           i = plug_p.pin.i;
//         end TwoPlug;
//         partial model OnePort "Component with two electrical plugs and currents from plug_p to plug_n"
//           extends TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>two</b> electrical plugs: 
// the positive plug connector <i>plug_p</i>, and the negative plug connector <i>plug_n</i>. 
// The currents flowing into plug_p are provided explicitly as currents i[m]. 
// It is assumed that the currents flowing into plug_p are identical to the currents flowing out of plug_n.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           plug_p.pin.i + plug_n.pin.i = zeros(m);
//         end OnePort;
//         partial model FourPlug "Component with two m-phase electric ports"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           Modelica.SIunits.Voltage v1[m] "Voltage drops over the left port";
//           Modelica.SIunits.Voltage v2[m] "Voltage drops over the right port";
//           Modelica.SIunits.Current i1[m] "Current flowing into positive plug of the left port";
//           Modelica.SIunits.Current i2[m] "Current flowing into positive plug of the right port";
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>four</b> electrical plugs.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           PositivePlug plug_p1(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           PositivePlug plug_p2(final m = m) annotation(Placement(visible = true, transformation(origin = {100,100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePlug plug_n1(final m = m) annotation(Placement(visible = true, transformation(origin = { -100, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           NegativePlug plug_n2(final m = m) annotation(Placement(visible = true, transformation(origin = {100, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v1 = plug_p1.pin.v - plug_n1.pin.v;
//           v2 = plug_p2.pin.v - plug_n2.pin.v;
//           i1 = plug_p1.pin.i;
//           i2 = plug_p2.pin.i;
//         end FourPlug;
//         partial model TwoPort "Component with two m-phase electric ports, including currents"
//           extends FourPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>four</b> electrical plugs. 
// It is assumed that the currents flowing into plug_p1 are identical to the currents flowing out of plug_n1, 
// and that the currents flowing into plug_p2 are identical to the currents flowing out of plug_n2.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           plug_p1.pin.i + plug_n1.pin.i = zeros(m);
//           plug_p2.pin.i + plug_n2.pin.i = zeros(m);
//         end TwoPort;
//       end Interfaces;
//       package Sensors "Multiphase potential, voltage and current Sensors"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains multiphase potential, voltage, and current sensors.
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li>v1.0 2004/10/01 Anton Haumer</li>
//   <li>v1.1 2006/01/12 Anton Haumer<br>
//       added PowerSensor</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -90},{40,10}}),Line(visible = true, points = {{ -50, -16},{ -36, -25}}),Line(visible = true, points = {{ -35,0},{ -25, -14}}),Line(visible = true, points = {{ -10,7},{ -10, -10}}),Line(visible = true, points = {{15,0},{5, -14}}),Line(visible = true, points = {{30, -15},{16, -25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -15, -45},{ -5, -35}}),Line(visible = true, points = {{ -10, -40},{ -6, -26}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -12, -24},{ -0.5, -27},{2,1.5},{ -12, -24}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model PotentialSensor "Multiphase potential sensor"
//           extends Modelica.Icons.RotationalSensor;
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m potential sensors (Modelica.Electrical.Analog.Sensors.PotentialSensor), 
// thus measuring the m potentials <i>phi[m]</i> of the m pins of plug_p.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,255}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -110},{100, -70}}, textString = "m=%m", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.PositivePlug plug_p(m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput phi[m](redeclare type SignalType = Modelica.SIunits.ElectricPotential) "Absolute voltage potential as output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sensors.PotentialSensor potentialSensor[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(potentialSensor.phi,phi) annotation(Line(visible = true, points = {{11,0},{110,0}}, color = {0,0,255}));
//           connect(potentialSensor.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//         end PotentialSensor;
//         model VoltageSensor "Multiphase voltage sensor"
//           extends Modelica.Icons.RotationalSensor;
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m voltage sensors (Modelica.Electrical.Analog.Sensors.VoltageSensor), 
// thus measuring the m potential differences <i>v[m]</i> between the m pins of plug_p and plug_n. 
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "V", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -100,60},{100,120}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{ -20, -60}}, textString = "m=", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{20, -100},{100, -60}}, textString = "%m", fontName = "Arial")}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput v[m](redeclare type SignalType = Modelica.SIunits.Voltage) "Voltage between pin p and n (= p.v - n.v) as output signal" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(voltageSensor.v,v) annotation(Line(visible = true, points = {{0, -10},{0, -110}}, color = {0,0,255}));
//           connect(voltageSensor.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//           connect(voltageSensor.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//         end VoltageSensor;
//         model CurrentSensor "Multiphase current sensor"
//           extends Modelica.Icons.RotationalSensor;
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m current sensors (Modelica.Electrical.Analog.Sensors.CurrentSensor), 
// thus measuring the m currents <i>i[m]</i> flowing from the m pins of plug_p to the m pins of plug_n. 
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "A", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,120}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{ -20, -60}}, textString = "m=", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{20, -100},{100, -60}}, textString = "%m", fontName = "Arial")}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput i[m](redeclare type SignalType = Modelica.SIunits.Current) "current in the branch from p to n as output signal" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           connect(currentSensor.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(plug_p.pin,currentSensor.p) annotation(Line(visible = true, points = {{ -100,0},{ -10,0}}, color = {0,0,255}));
//           connect(currentSensor.i,i) annotation(Line(visible = true, points = {{0, -10},{0, -110}}, color = {0,0,255}));
//         end CurrentSensor;
//         model PowerSensor "Multiphase instantaneous power sensor"
//           parameter Integer m(min = 1) = 3 "number of phases";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html><p>
// This power sensor measures instantaneous electrical power of a multiphase system and has a separated voltage and current path. The plugs of the voltage path are <code>pv</code> and <code>nv</code>, the plugs of the current path are <code>pc</code> and <code>nc</code>. The internal resistance of each current path is zero, the internal resistance of each voltage path is infinite. 
// </p></html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,100},{0,70}}, color = {0,0,255}),Line(visible = true, points = {{0, -70},{0, -100}}, color = {0,0,255}),Line(visible = true, points = {{ -80, -100},{ -80,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,120},{150,160}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{0, -120},{140, -80}}, textString = "m=%m", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -29, -70},{30, -11}}, textString = "P", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{100,0}}, color = {0,0,255})}));
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug pc(final m = m) "Positive plug, current path" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug nc(final m = m) "Negative plug, current path" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.PositivePlug pv(final m = m) "Positive plug, voltage path" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.MultiPhase.Interfaces.NegativePlug nv(final m = m) "Negative plug, voltage path" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput power(redeclare type SignalType = Modelica.SIunits.Power) annotation(Placement(visible = true, transformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Modelica.Electrical.MultiPhase.Sensors.CurrentSensor currentSensor(final m = m) annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Math.Sum sum(final nin = m, final k = ones(m)) annotation(Placement(visible = true, transformation(origin = { -30, -70}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Modelica.Blocks.Math.Product product[m] annotation(Placement(visible = true, transformation(origin = { -30, -40}, extent = {{ -10, -10},{10,10}}, rotation =  -450)));
//           Modelica.Electrical.MultiPhase.Sensors.VoltageSensor voltageSensor(final m = m) annotation(Placement(visible = true, transformation(origin = {0, -20}, extent = {{10,10},{ -10, -10}}, rotation =  -270)));
// 
//         equation 
//           connect(sum.y,power) annotation(Line(visible = true, points = {{ -30, -81},{ -30, -90},{ -80, -90},{ -80, -110}}, color = {0,0,191}));
//           connect(currentSensor.plug_n,nc) annotation(Line(visible = true, points = {{ -30,0},{100,0}}, color = {0,0,255}));
//           connect(pc,currentSensor.plug_p) annotation(Line(visible = true, points = {{ -100,0},{ -50,0}}, color = {0,0,255}));
//           connect(currentSensor.i,product.u2) annotation(Line(visible = true, points = {{ -40, -11},{ -40, -20},{ -36, -20},{ -36, -28}}, color = {0,0,191}));
//           connect(product.y,sum.u) annotation(Line(visible = true, points = {{ -30, -51},{ -30, -58}}, color = {0,0,191}));
//           connect(voltageSensor.plug_p,pv) annotation(Line(visible = true, points = {{0, -10},{0, -10},{0,100}}, color = {0,0,255}));
//           connect(voltageSensor.plug_n,nv) annotation(Line(visible = true, points = {{0, -30},{0, -30},{0, -100}}, color = {0,0,255}));
//           connect(product.u1,voltageSensor.v) annotation(Line(visible = true, points = {{ -24, -28},{ -24, -20},{ -11, -20}}, color = {0,0,191}));
//         end PowerSensor;
//       end Sensors;
//       package Sources "Multiphase voltage and current sources"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains time-dependend and controlled multiphase voltage and current sources:
// <ul>
// <li>SignalVoltage: fed by Modelica.Blocks.Sources arbitrary waveforms of voltages are possible</li>
// <li>SineVoltage : phase shift between consecutive voltages by default <tt>= pi/m</tt></li>
// <li>SignalCurrent: fed by Modelica.Blocks.Sources arbitrary waveforms of currents are possible</li>
// <li>SineCurrent : phase shift between consecutive currents by default <tt>= pi/m</tt></li>
// </ul>
// </p>
// 
// </HTML>", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.0 2004/10/01 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2006, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -40},{ -60, -40}}, color = {0,0,255}),Line(visible = true, points = {{ -60, -40},{40, -40}}, color = {0,0,255}),Line(visible = true, points = {{40, -40},{80, -40}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -90},{40,10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model SignalVoltage "Multiphase signal voltage source"
//           parameter Integer m(min = 1) = 3 "number of phases";
//           Modelica.SIunits.Current i[m] "Currents flowing into positive plugs";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m signal controlled voltage sources (Modelica.Electrical.Analog.Sources.SignalVoltage)
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -50,0},{50,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial")}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput v[m](redeclare type SignalType = Modelica.SIunits.Voltage) "Voltage between pin p and n (= p.v - n.v) as input signal" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
//           Modelica.Electrical.Analog.Sources.SignalVoltage signalVoltage[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(signalVoltage.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//           connect(signalVoltage.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(v,signalVoltage.v) annotation(Line(visible = true, points = {{0,70},{0,7}}, color = {0,0,255}));
//           i = plug_p.pin.i;
//         end SignalVoltage;
//         model ConstantVoltage "Multiphase constant voltage source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Voltage V[m] = fill(1, m) "Value of constant voltage";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m constant voltage sources (Modelica.Electrical.Analog.Sources.ConstantVoltage) 
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -50,0},{50,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{100,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Sources.ConstantVoltage constantVoltage[m](final V = V) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(constantVoltage.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(constantVoltage.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//         end ConstantVoltage;
//         model SineVoltage "Multiphase sine voltage source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Voltage V[m] = fill(1, m) "Amplitudes of sine waves";
//           parameter Modelica.SIunits.Angle phase[m] =  -array((j - 1) / m * 2 * Modelica.Constants.pi for j in 1:m) "Phases of sine waves";
//           parameter Modelica.SIunits.Frequency freqHz[m] = fill(1, m) "Frequencies of sine waves";
//           parameter Modelica.SIunits.Voltage offset[m] = zeros(m) "Voltage offsets";
//           parameter Modelica.SIunits.Time startTime[m] = zeros(m) "Time offsets";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m sine voltage sources (Modelica.Electrical.Analog.Sources.SineVoltage) 
// with a default phase shift of -(j-1)/m * 2*pi for j in 1:m.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{ -50,0},{50,0}}, color = {0,0,255}),Line(visible = true, points = {{ -70,0},{ -60.2,29.9},{ -53.8,46.5},{ -48.2,58.1},{ -43.3,65.2},{ -38.3,69.2},{ -33.4,69.8},{ -28.5,67},{ -23.6,61},{ -18.6,52},{ -13,38.6},{ -5.98,18.6},{8.79, -26.9},{15.1, -44},{20.8, -56.2},{25.7, -64},{30.6, -68.6},{35.5, -70},{40.5, -67.9},{45.4, -62.5},{50.3, -54.1},{55.9, -41.3},{63, -21.7},{70,0}}, color = {192,192,192}, smooth = Smooth.Bezier),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{100,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Sources.SineVoltage sineVoltage[m](final V = V, final phase = phase, final freqHz = freqHz, final offset = offset, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(sineVoltage.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(sineVoltage.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//         end SineVoltage;
//         model SignalCurrent "Multiphase sine current source"
//           parameter Integer m(min = 1) = 3 "number of phases";
//           Modelica.SIunits.Voltage v[m] "Voltage drops between the two plugs";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m signal controlled current sources (Modelica.Electrical.Analog.Sources.SignalCurrent) 
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{0,50},{0, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{ -20,100}}, textString = "m=", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{20,60},{100,100}}, textString = "%m", fontName = "Arial")}));
//           Interfaces.PositivePlug plug_p(final m = m) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.NegativePlug plug_n(final m = m) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Sources.SignalCurrent signalCurrent[m] annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation =  -360)));
//           Modelica.Blocks.Interfaces.RealInput i[m](redeclare type SignalType = Modelica.SIunits.Current) "Current flowing from pin p to pin n as input signal" annotation(Placement(visible = true, transformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,70}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//         equation 
//           connect(signalCurrent.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10, -2.44921e-15},{ -100,0}}, color = {0,0,255}));
//           connect(signalCurrent.n,plug_n.pin) annotation(Line(visible = true, points = {{10,2.44921e-15},{100,0}}, color = {0,0,255}));
//           connect(i,signalCurrent.i) annotation(Line(visible = true, points = {{0,70},{ -1.71445e-15,7}}, color = {0,0,255}));
//           v = plug_p.pin.v - plug_n.pin.v;
//         end SignalCurrent;
//         model ConstantCurrent "Multiphase constant current source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Current I[m] = fill(1, m) "Value of constant current";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m constant current sources (Modelica.Electrical.Analog.Sources.ConstantCurrent) 
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{0,50},{0, -50}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{100,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Sources.ConstantCurrent constantCurrent[m](final I = I) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(constantCurrent.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(constantCurrent.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//         end ConstantCurrent;
//         model SineCurrent "Multiphase sine current source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Current I[m] = fill(1, m) "Amplitudes of sine waves";
//           parameter Modelica.SIunits.Angle phase[m] =  -array((j - 1) / m * 2 * Modelica.Constants.pi for j in 1:m) "Phases of sine waves";
//           parameter Modelica.SIunits.Frequency freqHz[m] = fill(1, m) "Frequencies of sine waves";
//           parameter Modelica.SIunits.Voltage offset[m] = zeros(m) "Voltage offsets";
//           parameter Modelica.SIunits.Time startTime[m] = zeros(m) "Time offsets";
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m sine current sources (Modelica.Electrical.Analog.Sources.SineCurrent) 
// with a default phase shift of -(j-1)/m * 2*pi for j in 1:m.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -50,0}}, color = {0,0,255}),Line(visible = true, points = {{50,0},{90,0}}, color = {0,0,255}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Line(visible = true, points = {{0,50},{0, -50}}, color = {0,0,255}),Line(visible = true, points = {{ -70,0},{ -60.2,29.9},{ -53.8,46.5},{ -48.2,58.1},{ -43.3,65.2},{ -38.3,69.2},{ -33.4,69.8},{ -28.5,67},{ -23.6,61},{ -18.6,52},{ -13,38.6},{ -5.98,18.6},{8.79, -26.9},{15.1, -44},{20.8, -56.2},{25.7, -64},{30.6, -68.6},{35.5, -70},{40.5, -67.9},{45.4, -62.5},{50.3, -54.1},{55.9, -41.3},{63, -21.7},{70,0}}, color = {192,192,192}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -50}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100,60},{100,100}}, textString = "m=%m", fontName = "Arial")}));
//           Modelica.Electrical.Analog.Sources.SineCurrent sineCurrent[m](final I = I, final phase = phase, final freqHz = freqHz, final offset = offset, final startTime = startTime) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(sineCurrent.n,plug_n.pin) annotation(Line(visible = true, points = {{10,0},{100,0}}, color = {0,0,255}));
//           connect(sineCurrent.p,plug_p.pin) annotation(Line(visible = true, points = {{ -10,0},{ -100,0}}, color = {0,0,255}));
//         end SineCurrent;
//       end Sources;
//     end MultiPhase;
//   end Electrical;
//   package Math "Mathematical functions (e.g., sin, cos) and operations on matrices (e.g., norm, solve, eig, exp)"
//     import SI = Modelica.SIunits;
//     extends Modelica.Icons.Library2;
//     annotation(preferedView = "info", Invisible = true, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -59, -56},{42, -9}}, textString = "f(x)", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This package contains <b>basic mathematical functions</b> (such as sin(..)),
// as well as functions operating on <b>matrices</b>.
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Function tempInterpol2 added.</li>
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Icons for icon and diagram level introduced.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package Matrices "Functions on matrices"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", version = "0.8.1", versionDate = "2004-08-21", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Library content</font></h3>
// <p>
// This library provides functions operating on matrices:
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><th><i>Function</i></th>
//       <th><i>Description</i></th>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.norm\">norm</a>(A)</td>
//       <td>1-, 2- and infinity-norm of matrix A</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)</td>
//       <td>determines whether two matrices have the same size and elements</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.solve\">solve</a>(A,b)</td>
//       <td>Solve real system of linear equations A*x=b with a b vector</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)</td>
//       <td>Solve overdetermined or underdetermined real system of <br>
//           linear equations A*x=b in a least squares sense</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)</td>
//       <td>Solve a linear equality constrained least squares problem:<br>
//           min|A*x-a|^2 subject to B*x=b</td>
//   </tr>
//   <tr><td>(LU,p,info) = <a href=\"Modelica:Modelica.Math.Matrices.LU\">LU</a>(A)</td>
//       <td>LU decomposition of square or rectangular matrix</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)</td>
//       <td>Solve real system of linear equations P*L*U*x=b with a<br>
//           b vector and an LU decomposition from \"LU(..)\"</td>
//   </tr>
//   <tr><td>(Q,R,p) = <a href=\"Modelica:Modelica.Math.Matrices.QR\">QR</a>(A)</td>
//       <td> QR decomposition with column pivoting of rectangular matrix (Q*R = A[:,p]) </td>
//   </tr>
//   <tr><td>eval = <a href=\"Modelica:Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)<br>
//           (eval,evec) = <a href=\"Modelica:Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)</td>
//       <td> compute eigenvalues and optionally eigenvectors<br>
//            for a real, nonsymmetric matrix </td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eigen)</td>
//       <td> return real valued block diagonal matrix J of eigenvalues of 
//             matrix A (A=V*J*Vinv) </td>
//   </tr>
//   <tr><td>sigma = <a href=\"Modelica:Modelica.Math.Matrices.singularValues\">singularValues</a>(A)<br>
//       (sigma,U,VT) = <a href=\"Modelica:Modelica.Math.Matrices.singularValues\">singularValues</a>(A)</td>
//       <td> compute singular values and optionally left and right singular vectors </td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.det\">det</a>(A)</td>
//       <td> determinant of a matrix (do <b>not</b> use; use rank(..))</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.inv\">inv</a>(A)</td>
//       <td> inverse of a matrix </td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.rank\">rank</a>(A)</td>
//       <td> rank of a matrix </td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.balance\">balance</a>(A)</td>
//       <td>balance a square matrix to improve the condition</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Math.Matrices.exp\">exp</a>(A)</td>
//       <td> compute the exponential of a matrix by adaptive Taylor series<br> 
//            expansion with scaling and balancing</td>
//   </tr>
//   <tr><td>(P, G) = <a href=\"Modelica:Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)</td>
//       <td> compute the exponential of a matrix and its integral</td>
//   </tr>
//   <tr><td>(P, G, GT) = <a href=\"Modelica:Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)</td>
//       <td> compute the exponential of a matrix and two integrals</td>
//   </tr>
// </table>
// 
// <p>
// Most functions are solely an interface to the external LAPACK library
// (<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>).
// The details of this library are described in:
// </p>
// 
// <dl>
// <dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
//     Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
// <dd> <b>Lapack Users' Guide</b>.
//      Third Edition, SIAM, 1999.</dd>
// </dl>
// 
// 
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function norm "Returns the norm of a matrix"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Input matrix";
//         input Real p(min = 1) = 2 "Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)";
//         output Real result = 0.0 "p-norm of matrix A";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>norm</b>(A);
// Matrices.<b>norm</b>(A, p=2);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// The function call \"<code>Matrices.norm(A)</code>\" returns the
// 2-norm of matrix A, i.e., the largest singular value of A.<br>
// The function call \"<code>Matrices.norm(A, p)</code>\" returns the
// p-norm of matrix A. The only allowed values for p are</p>
// <ul>
// <li> \"p=1\": the largest column sum of A</li>
// <li> \"p=2\": the largest singular value of A</li> 
// <li> \"p=Modelica.Constants.inf\": the largest row sum of A</li>
// </ul>
// <p>
// Note, for any matrices A1, A2 the following inequality holds:
// </p>
// <blockquote><pre>
// Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
// </pre></blockquote>
// <p>
// Note, for any matrix A and vector v the following inequality holds:
// </p>
// <blockquote><pre>
// Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
// </pre></blockquote>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         if p == 1 then 
//                 for i in 1:size(A, 2) loop
//                   result:=max(result, sum(abs(A[:,i])));
// 
//         end for;
//         elseif p == 2 then
//           result:=max(singularValues(A));
// 
//         elseif p == Modelica.Constants.inf then
//           for i in 1:size(A, 1) loop
//                       result:=max(result, sum(abs(A[i,:])));
// 
//           end for;
// 
// 
//         else         assert(false, "Optional argument \"p\" of function \"norm\" must be 
// 1, 2 or Modelica.Constants.inf");
// 
//         end if;
//       end norm;
//       function isEqual "Compare whether two Real matrices are identical"
//         extends Modelica.Icons.Function;
//         input Real M1[:,:] "First matrix";
//         input Real M2[:,:] "Second matrix (may have different size as M1";
//         input Real eps(min = 0) = 0 "Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) <= eps";
//         output Boolean result "= true, if matrices have the same size and the same elements";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>isEqual</b>(M1, M2);
// Matrices.<b>isEqual</b>(M1, M2, eps=0);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// The function call \"<code>Matrices.isEqual(M1, M2)</code>\" returns <b>true</b>, 
// if the two Real matrices M1 and M2 have the same dimensions and 
// the same elements. Otherwise the function
// returns <b>false</b>. Two elements e1 and e2 of the two matrices
// are checked on equality by the test \"abs(e1-e2) &le; eps\", where \"eps\"
// can be provided as third argument of the function. Default is \"eps = 0\".
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A1[2,2] = [1,2; 3,4];
//   Real A2[3,2] = [1,2; 3,4; 5,6];
//   Real A3[2,2] = [1,2, 3,4.0001];
//   Boolean result;
// <b>algorithm</b>
//   result := Matrices.isEqual(M1,M2);     // = <b>false</b>
//   result := Matrices.isEqual(M1,M3);     // = <b>false</b>
//   result := Matrices.isEqual(M1,M1);     // = <b>true</b>
//   result := Matrices.isEqual(M1,M3,0.1); // = <b>true</b>
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Vectors.isEqual\">Vectors.isEqual</a>, 
// <a href=\"Modelica:Modelica.Strings.isEqual\">Strings.isEqual</a>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer nrow = size(M1, 1) "Number of rows of matrix M1";
//         Integer ncol = size(M1, 2) "Number of columns of matrix M1";
//         Integer i = 1;
//         Integer j;
//       algorithm 
//         result:=false;
//         if size(M2, 1) == nrow and size(M2, 2) == ncol then 
//                 result:=true;
//         while (i <= nrow) loop
//                   j:=1;
//           while (j <= ncol) loop
//                       if abs(M1[i,j] - M2[i,j]) > eps then 
//                         result:=false;
//             i:=nrow;
//             j:=ncol;
// 
//             else 
//             end if;
//             j:=j + 1;
// 
//           end while;
//           i:=i + 1;
// 
//         end while;
// 
//         else 
//         end if;
//       end isEqual;
//       function solve "Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)] "Matrix A of A*x = b";
//         input Real b[size(A, 1)] "Vector b of A*x = b";
//         output Real x[size(b, 1)] "Vector x such that A*x = b";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>solve</b>(A,b);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function call returns the
// solution <b>x</b> of the linear system of equations
// </p>
// <blockquote>
// <p>
// <b>A</b>*<b>x</b> = <b>b</b>
// </p>
// </blockquote>
// <p>
// If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
// an exception is raised.
// </p>
// <p>
// Note, the solution is computed with the LAPACK function \"dgesv\",
// i.e., by Gaussian elemination with partial pivoting.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3; 
//                  3,4,5;
//                  2,1,4];
//   Real b[3] = {10,22,12};
//   Real x[3];
// <b>algorithm</b>
//   x := Matrices.solve(A,b);  // x = {3,2,1}
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.LU\">Matrices.LU</a>,
// <a href=\"Modelica:Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//       algorithm 
//         (x,info):=LAPACK.dgesv_vec(A, b);
//         assert(info == 0, "Solving a linear system of equations with function
// \"Matrices.solve\" is not possible, because the system has either 
// no or infinitely many solutions (A is singular).");
//       end solve;
//       function leastSquares "Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Matrix A";
//         input Real b[size(A, 1)] "Vector b";
//         output Real x[size(A, 2)] "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// x = Matrices.<b>leastSquares</b>(A,b);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// A linear system of equations A*x = b has no solutions or infinitely
// many solutions if A is not square. Function \"leastSquares\" returns
// a solution in a least squarse sense:
// </p>
// <pre>
//   size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
//   size(A,1) = size(A,2):  returns x such that A*x = b
//   size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all 
//                           vectors x that fulfill A*x = b
// </pre>
// <p>
// Note, the solution is computed with the LAPACK function \"dgelsx\",
// i.e., QR or LQ factorization of A with column pivoting. 
// If A does not have full rank,
// the solution is not unique and from the infinitely many solutions
// the one is selected that minimizes both |x|^2 and |A*x - b|^2.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//         Integer rank;
//         Real xx[max(size(A, 1), size(A, 2))];
//       algorithm 
//         (xx,info,rank):=LAPACK.dgelsx_vec(A, b, 100 * Modelica.Constants.eps);
//         x:=xx[1:size(A, 2)];
//         assert(info == 0, "Solving an overdetermined or underdetermined linear system of 
// equations with function \"Matrices.leastSquares\" failed.");
//       end leastSquares;
//       function equalityLeastSquares "Solve a linear equality constrained least squares problem"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Minimize |A*x - a|^2";
//         input Real a[size(A, 1)];
//         input Real B[:,size(A, 2)] "subject to B*x=b";
//         input Real b[size(B, 1)];
//         output Real x[size(A, 2)] "solution vector";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function returns the
// solution <b>x</b> of the linear equality-constrained least squares problem:
// </p>
// <blockquote>
// <p>
// min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
// </p>
// </blockquote>
// 
// <p>
// It is required that the dimensions of A and B fulfill the following
// relationship:
// </p>
// 
// <blockquote>
// size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
// </blockquote>
// 
// <p>
// Note, the solution is computed with the LAPACK function \"dgglse\"
// using the generalized RQ factorization under the assumptions that
// B has full row rank (= size(B,1)) and the matrix [A;B] has
// full column rank (= size(A,2)). In this case, the problem
// has a unique solution.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//       algorithm 
//         assert(size(A, 2) >= size(B, 1) and size(A, 2) <= size(A, 1) + size(B, 1), "It is required that size(B,1) <= size(A,2) <= size(A,1) + size(B,1)\n" + "This relationship is not fulfilled, since the matrices are declared as:\n" + "  A[" + String(size(A, 1)) + "," + String(size(A, 2)) + "], B[" + String(size(B, 1)) + "," + String(size(B, 2)) + "]\n");
//         (x,info):=LAPACK.dgglse_vec(A, a, B, b);
//         assert(info == 0, "Solving a linear equality-constrained least squares problem 
// with function \"Matrices.equalityLeastSquares\" failed.");
//       end equalityLeastSquares;
//       function LU "LU decomposition of square or rectangular matrix"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Square or rectangular matrix";
//         output Real LU[size(A, 1),size(A, 2)] = A "L,U factors (used with LU_solve(..))";
//         output Integer pivots[min(size(A, 1), size(A, 2))] "pivot indices (used with LU_solve(..))";
//         output Integer info "Information";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "FORTRAN 77" dgetrf(size(A, 1),size(A, 2),LU,size(A, 1),pivots,info)         annotation(Library = "Lapack");         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (LU, pivots)       = Matrices.<b>LU</b>(A);
// (LU, pivots, info) = Matrices.<b>LU</b>(A);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function call returns the
// LU decomposition of a \"Real[m,n]\" matrix A, i.e.,
// </p>
// <blockquote>
// <p>
// <b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
// </p>
// </blockquote>
// <p>
// where <b>P</b> is a permutation matrix (implicitely
// defined by vector <code>pivots</code>),
// <b>L</b> is a lower triangular matrix with unit
// diagonal elements (lower trapezoidal if m &gt; n), and
// <b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
// Matrices <b>L</b> and <b>U</b> are stored in the returned
// matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
// With the companion function 
// <a href=\"Modelica:Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
// this decomposition can be used to solve
// linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
// hand side vectors <b>b</b>. If a linear system of equations with
// just one right hand side vector <b>b</b> shall be solved, it is
// more convenient to just use the function
// <a href=\"Modelica:Modelica.Math.Matrices.solve\">Matrices.solve</a>.
// </p>
// <p>
// The optional third (Integer) output argument has the following meaning:
// <table border=0 cellspacing=0 cellpadding=2>
//   <tr><td>info = 0:</td
//       <td>successful exit</td></tr>
//   <tr><td>info &gt; 0:</td>
//       <td>if info = i, U[i,i] is exactly zero. The factorization
//           has been completed, <br> 
//           but the factor U is exactly
//           singular, and division by zero will occur<br> if it is used
//           to solve a system of equations.</td></tr>
// </table>
// </p>
// <p>
// The LU factorization is computed
// with the LAPACK function \"dgetrf\",
// i.e., by Gaussian elemination using partial pivoting
// with row interchanges. Vector \"pivots\" are the
// pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
// matrix A was interchanged with row pivots[i].
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3; 
//                  3,4,5;
//                  2,1,4];
//   Real b1[3] = {10,22,12};
//   Real b2[3] = { 7,13,10};
//   Real    LU[3,3];
//   Integer pivots[3];
//   Real    x1[3];
//   Real    x2[3];
// <b>algorithm</b>
//   (LU, pivots) := Matrices.LU(A);
//   x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
//   x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>, 
// <a href=\"Modelica:Modelica.Math.Matrices.solve\">Matrices.solve</a>,
// </HTML>"));
//       end LU;
//       function LU_solve "Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))"
//         extends Modelica.Icons.Function;
//         input Real LU[:,size(LU, 1)] "L,U factors of Matrices.LU(..) for a square matrix";
//         input Integer pivots[size(LU, 1)] "Pivots indices of Matrices.LU(..)";
//         input Real b[size(LU, 1)] "Right hand side vector of P*L*U*x=b";
//         output Real x[size(b, 1)] "Solution vector such that P*L*U*x = b";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>LU_solve</b>(LU, pivots, b);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function call returns the
// solution <b>x</b> of the linear systems of equations
// </p>
// <blockquote>
// <p>
// <b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
// </p>
// </blockquote>
// <p>
// where <b>P</b> is a permutation matrix (implicitely
// defined by vector <code>pivots</code>),
// <b>L</b> is a lower triangular matrix with unit
// diagonal elements (lower trapezoidal if m &gt; n), and
// <b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
// The matrices of this decomposition are computed with function
// <a href=\"Modelica:Modelica.Math.Matrices.LU\">Matrices.LU</a> that
// returns arguments <code>LU</code> and <code>pivots</code>
// used as input arguments of <code>Matrices.LU_solve</code>.
// With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
// it is possible to efficiently solve linear systems
// with different right hand side vectors. If a linear system of equations with
// just one right hand side vector shall be solved, it is
// more convenient to just use the function
// <a href=\"Modelica:Modelica.Math.Matrices.solve\">Matrices.solve</a>.
// </p>
// <p>
// If a unique solution <b>x</b> does not exist (since the 
// LU decomposition is singular), an exception is raised.
// </p>
// <p>
// The LU factorization is computed
// with the LAPACK function \"dgetrf\",
// i.e., by Gaussian elemination using partial pivoting
// with row interchanges. Vector \"pivots\" are the
// pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
// matrix A was interchanged with row pivots[i].
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3; 
//                  3,4,5;
//                  2,1,4];
//   Real b1[3] = {10,22,12};
//   Real b2[3] = { 7,13,10};
//   Real    LU[3,3];
//   Integer pivots[3];
//   Real    x1[3];
//   Real    x2[3];
// <b>algorithm</b>
//   (LU, pivots) := Matrices.LU(A);
//   x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
//   x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.LU\">Matrices.LU</a>, 
// <a href=\"Modelica:Modelica.Math.Matrices.solve\">Matrices.solve</a>,
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         for i in 1:size(LU, 1) loop
//                   assert(LU[i,i] <> 0, "Solving a linear system of equations with function
// \"Matrices.LU_solve\" is not possible, since the LU decomposition
// is singular, i.e., no unique solution exists.");
// 
//         end for;
//         x:=LAPACK.dgetrs_vec(LU, pivots, b);
//       end LU_solve;
//       function QR "QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Rectangular matrix with size(A,1) >= size(A,2)";
//         output Real Q[size(A, 1),size(A, 2)] "Rectangular matrix with orthonormal columns such that Q*R=A[:,p]";
//         output Real R[size(A, 2),size(A, 2)] "Square upper triangular matrix";
//         output Integer p[size(A, 2)] "Column permutation vector";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (Q,R,p) = Matrices.<b>QR</b>(A);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function returns the QR decomposition of
// a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
// must be less than or equal to the number of rows):
// </p>
// <blockquote>
// <p>
// <b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
// </p>
// </blockquote>
// <p>
// where <b>Q</b> is a rectangular matrix that has orthonormal columns and
// has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
// <b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
// vector. Matrix <b>R</b> has the following important properties:
// </p>
// <ul>
// <li> The absolute value of a diagonal element of <b>R</b> is the largest
//      value in this row, i.e.,
//      abs(R[i,i]) &ge; abs(R[i,j]).</li>
// <li> The diagonal elements of <b>R</b> are sorted according to size, such that
//      the largest absolute value is abs(R[1,1]) and
//      abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
// </ul>
// <p>
// This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
// for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
// small elements and can be treated as being zero. 
// This allows to, e.g., estimate the row-rank
// of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
// <b>R</b> can be partitioned in two parts
// </p>
// <blockquote>
// <pre>
//    <b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
//                  <b>0</b>,  <b>0</b>]
// </pre>
// </blockquote>
// <p>
// where <b>R</b><sub>1</sub> is a regular, upper triangular matrix. 
// </p>
// <p>
// Note, the solution is computed with the LAPACK functions \"dgeqpf\"
// and \"dorgqr\", i.e., by Housholder transformations with
// column pivoting. If <b>Q</b> is not needed, the function may be
// called as: <code>(,R,p) = QR(A)</code>.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3; 
//                  3,4,5;
//                  2,1,4];
//   Real R[3,3];
// <b>algorithm</b>
//   (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
//                                     0     , -1.73.., -0.23..;
//                                     0     ,  0     ,  0.65..];
// </pre></blockquote>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer nrow = size(A, 1);
//         Integer ncol = size(A, 2);
//         Real tau[ncol];
//       algorithm 
//         assert(nrow >= ncol, "\nInput matrix A[" + String(nrow) + "," + String(ncol) + "] has more columns as rows.
// This is not allowed when calling Modelica.Matrices.QR(A).");
//         (Q,tau,p):=LAPACK.dgeqpf(A);
//         R:=zeros(ncol, ncol);
//         for i in 1:ncol loop
//                   for j in i:ncol loop
//                       R[i,j]:=Q[i,j];
// 
//           end for;
// 
//         end for;
//         Q:=LAPACK.dorgqr(Q, tau);
//       end QR;
//       function eigenValues "Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)] "Matrix";
//         output Real eigenvalues[size(A, 1),2] "Eigenvalues of matrix A (Re: first column, Im: second column)";
//         output Real eigenvectors[size(A, 1),size(A, 2)] "Real-valued eigenvector matrix";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//                 eigenvalues = Matrices.<b>eigenValues</b>(A);
// (eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function call returns the eigenvalues and 
// optionally the (right) eigenvectors of a square matrix 
// <b>A</b>. The first column of \"eigenvalues\" contains the real and the
// second column contains the imaginary part of the eigenvalues.
// If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
// the corresponding real eigenvector. If the i-th eigenvalue
// has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
// eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
// imaginary part of the eigenvector of the i-th eigenvalue.
// With function 
// <a href=\"Modelica:Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
// a real block diagonal matrix is constructed from the eigenvalues 
// such that 
// </p>
// <blockquote>
// <pre>
// A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
// </pre>
// </blockquote>
// <p>
// provided the eigenvector matrix \"eigenvectors\" can be inverted
// (an inversion is possible, if all eigenvalues are different
// and no eigenvalue is zero).
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3; 
//                  3,4,5;
//                  2,1,4];
//   Real eval;
// <b>algorithm</b>
//   eval := Matrices.eigenValues(A);  // eval = [-0.618, 0; 
//                                     //          8.0  , 0;
//                                     //          1.618, 0];
// </pre>
// </blockquote>
// <p>
// i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
// </p>
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.eigenValueMatrix\">Matrices.eigenValueMatrix</a>,
// <a href=\"Modelica:Modelica.Math.Matrices.singularValues\">Matrices.singularValues</a>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//         Boolean onlyEigenvalues = false;
//       algorithm 
//         if onlyEigenvalues then 
//                 (eigenvalues[:,1],eigenvalues[:,2],info):=LAPACK.dgeev_eigenValues(A);
//         eigenvectors:=zeros(size(A, 1), size(A, 1));
// 
//         else         (eigenvalues[:,1],eigenvalues[:,2],eigenvectors,info):=LAPACK.dgeev(A);
// 
//         end if;
//         assert(info == 0, "Calculating the eigen values with function
// \"Matrices.eigenvalues\" is not possible, since the
// numerical algorithm does not converge.");
//       end eigenValues;
//       function eigenValueMatrix "Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)"
//         extends Modelica.Icons.Function;
//         input Real eigenValues[:,2] "Eigen values from function eigenValues(..) (Re: first column, Im: second column)";
//         output Real J[size(eigenValues, 1),size(eigenValues, 1)] "Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>eigenValueMatrix</b>(eigenvalues);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// The function call returns a block diagonal matrix <b>J</b>
// from the the two-column matrix <code>eigenvalues</code>
// (computed by function
// <a href=\"Modelica:Modelica.Math.Matrices.eigenValues\">Matrices.eigenValues</a>).
// Matrix <code>eigenvalues</code> must have the real part of the
// eigenvalues in the first column and the imaginary part in the
// second column. If an eigenvalue i has a vanishing imaginary
// part, then <b>J</b>[i,i] = eigenvalues[i,1], i.e., the diagonal
// element of <b>J</b> is the real eigenvalue. 
// Otherwise, eigenvalue i and conjugate complex eigenvalue i+1
// are used to construct a 2 by 2 diagonal block of <b>J</b>:
// </p>
// <blockquote>
// <pre>
//   J[i  , i]   := eigenvalues[i,1];
//   J[i  , i+1] := eigenvalues[i,2];
//   J[i+1, i]   := eigenvalues[i+1,2];
//   J[i+1, i+1] := eigenvalues[i+1,1];
// </pre>
// </blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.eigenValues\">Matrices.eigenValues</a>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer n = size(eigenValues, 1);
//         Integer i;
//       algorithm 
//         J:=zeros(n, n);
//         i:=1;
//         while (i <= n) loop
//                   if eigenValues[i,2] == 0 then 
//                     J[i,i]:=eigenValues[i,1];
//           i:=i + 1;
// 
//           else           J[i,i]:=eigenValues[i,1];
//           J[i,i + 1]:=eigenValues[i,2];
//           J[i + 1,i]:=eigenValues[i + 1,2];
//           J[i + 1,i + 1]:=eigenValues[i + 1,1];
//           i:=i + 2;
// 
//           end if;
// 
//         end while;
//       end eigenValueMatrix;
//       function singularValues "Compute singular values and left and right singular vectors"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Matrix";
//         output Real sigma[min(size(A, 1), size(A, 2))] "Singular values";
//         output Real U[size(A, 1),size(A, 1)] = zeros(size(A, 1), size(A, 1)) "Left orthogonal matrix";
//         output Real VT[size(A, 2),size(A, 2)] = zeros(size(A, 2), size(A, 2)) "Transposed right orthogonal matrix ";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//          sigma = Matrices.<b>singularValues</b>(A);
// (sigma, U, VT) = Matrices.<b>singularValues</b>(A);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function computes the singular values and optionally the
// singular vectors of matrix A. Basically the singular
// value decomposition of A is computed, i.e.,
// </p>
// <blockquote><pre>
// <b>A</b> = <b>U</b> <b><font face=\"Symbol\">S</font></b> <b>V</b><sup>T</sup>
//   = U*Sigma*VT
// </blockquote></pre>
// <p>
// where <b>U </b>and <b>V</b> are orthogonal matrices (<b>UU</b><sup>T</sup>=<b>I,
// </b><b>VV</b><sup>T</sup>=<b>I</b>). <b><font face=\"Symbol\">S
// </font></b> = diag(<font face=\"Symbol\">s</font><sub>i</sub>) 
// has the same size as matrix A with nonnegative diagonal elements 
// in decreasing order and with all other elements zero
// (<font face=\"Symbol\">s</font><sub>1</sub> is the largest element). The function
// returns the singular values <font face=\"Symbol\">s</font><sub>i</sub>
// in vector <tt>sigma</tt> and the orthogonal matrices in
// matrices <tt>U</tt> and <tt>V</tt>.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   A = [1, 2,  3,  4;
//        3, 4,  5, -2;
//       -1, 2, -3,  5];
//   (sigma, U, VT) = singularValues(A);
//   results in:
//      sigma = {8.33, 6.94, 2.31}; 
//   i.e.
//      Sigma = [8.33,    0,    0, 0;
//                  0, 6.94,    0, 0;
//                  0,    0, 2.31, 0]
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.eigenValues\">Matrices.eigenValues</a>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//         Integer n = min(size(A, 1), size(A, 2)) "Number of singular values";
//       algorithm 
//         (sigma,U,VT,info):=Matrices.LAPACK.dgesvd(A);
//         assert(info == 0, "The numerical algorithm to compute the
// singular value decomposition did not converge");
//       end singularValues;
//       function det "Determinant of a matrix (computed by LU decomposition)"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         output Real result "Determinant of matrix A";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Real LU[size(A, 1),size(A, 1)];
//         Integer pivots[size(A, 1)];
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Matrices.<b>det</b>(A);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function call returns the determinant of matrix A
// computed by a LU decomposition.
// Usally, this function should never be used, because
// there are nearly always better numerical algorithms
// as by computing the determinant. E.g., use function
// <a href=\"Modelica:Modelica.Math.Matrices.rank\">Matrices.rank</a>
// to compute the rank of a matrix.
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Math.Matrices.rank\">Matrices.rank</a>,
// <a href=\"Modelica:Modelica.Math.Matrices.solve\">Matrices.solve</a>
// </HTML>"));
//       algorithm 
//         (LU,pivots):=Matrices.LU(A);
//         result:=product(LU[i,i] for i in 1:size(A, 1)) * product(if pivots[i] == i then 1 else  -1 for i in 1:size(pivots, 1));
//       end det;
//       function inv "Inverse of a matrix (try to avoid, use function solve(..) instead)"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         output Real invA[size(A, 1),size(A, 2)] "Inverse of matrix A";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer info;
//         Integer pivots[size(A, 1)] "Pivot vector";
//         Real LU[size(A, 1),size(A, 2)] "LU factors of A";
//       algorithm 
//         (LU,pivots,info):=LAPACK.dgetrf(A);
//         assert(info == 0, "Calculating an inverse matrix with function
// \"Matrices.inv\" is not possible, since matrix A is singular.");
//         invA:=LAPACK.dgetri(LU, pivots);
//         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end inv;
//       function rank "Rank of a matrix (computed with singular values)"
//         extends Modelica.Icons.Function;
//         input Real A[:,:] "Matrix";
//         input Real eps = 0 "If eps > 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used";
//         output Integer result "Rank of matrix A";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer n = min(size(A, 1), size(A, 2));
//         Integer i = n;
//         Real sigma[n] = singularValues(A) "Singular values";
//         Real eps2 = if eps > 0 then eps else max(size(A)) * sigma[1] * Modelica.Constants.eps;
//       algorithm 
//         result:=n;
//         while (i > 0) loop
//                   if sigma[i] > eps2 then 
//                     result:=i;
//           i:=0;
// 
//           else 
//           end if;
//           i:=i - 1;
// 
//         end while;
//         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end rank;
//       function balance "Balancing of matrix A to improve the condition of A"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         output Real D[size(A, 1)] "diagonal(D)=T is transformation matrix, such that
//           T*A*inv(T) has smaller condition as A";
//         output Real B[size(A, 1),size(A, 1)] "Balanced matrix (= diagonal(D)*A*inv(diagonal(D)))";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer na = size(A, 1);
//         Integer radix = 2 "Radix of exponent representation must be 'radix'
//           or a multiple of 'radix'";
//         Integer radix2 = radix * radix;
//         Boolean noconv = true;
//         Integer i = 1;
//         Integer j = 1;
//         Real CO;
//         Real RO;
//         Real G;
//         Real F;
//         Real S;
//         annotation(Documentation(info = "<HTML>
// <p>
// The function transformates the matrix A, so that the norm of the i-th column
// is nearby the i-th row. (D,B)=Matrices.balance(A) returns a vector D, such
// that B=inv(diagonal(D))*A*diagonal(D) has better condition. The elements of D 
// are multiples of 2. Balancing attempts to make the norm of each row equal to the
// norm of the belonging column. <br>
// Balancing is used to minimize roundoff errors inducted
// through large matrix calculations like Taylor-series approximation
// or computation of eigenvalues.
// </p>
// <b>Example:</b><br><br>
// <pre>       - A = [1, 10,  1000; .01,  0,  10; .005,  .01,  10]
//        - Matrices.norm(A, 1);
//          = 1020.0
//        - (T,B)=Matrices.balance(A)
//        - T
//          = {256, 16, 0.5}
//        - B
//          =  [1,     0.625,   1.953125;
//              0.16,  0,       0.3125;
//              2.56,  0.32,   10.0]
//        - Matrices.norm(B, 1);
//          = 12.265625
// </pre>
// <p>
// The Algorithm is taken from
// <dl>
// <dt>H. D. Joos, G. Grbel:
// <dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
//     DLR - Control Systems Group 1991
// </dl>
// which based on the balanc function from EISPACK.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <li><i>July 5, 2002</i>
//        by H. D. Joos and Nico Walther<br>
//        Implemented.
// </li>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//       algorithm 
//         D:=ones(na);
//         B:=A;
//         while (noconv) loop
//                   noconv:=false;
//           for i in 1:na loop
//                       CO:=sum(abs(B[:,i])) - abs(B[i,i]);
//             RO:=sum(abs(B[i,:])) - abs(B[i,i]);
//             G:=RO / radix;
//             F:=1;
//             S:=CO + RO;
//             while (not (CO >= G or CO == 0)) loop
//                           F:=F * radix;
//               CO:=CO * radix2;
// 
//             end while;
//             G:=RO * radix;
//             while (not (CO < G or RO == 0)) loop
//                           F:=F / radix;
//               CO:=CO / radix2;
// 
//             end while;
//             if not (CO + RO) / F >= 0.95 * S then 
//                         G:=1 / F;
//             D[i]:=D[i] * F;
//             B[i,:]:=B[i,:] * G;
//             B[:,i]:=B[:,i] * F;
//             noconv:=true;
// 
//             else 
//             end if;
// 
//           end for;
// 
//         end while;
//       end balance;
//       function exp "Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         input Real T = 1;
//         output Real phi[size(A, 1),size(A, 1)] "= exp(A*T)";
//         annotation(Documentation(info = "<HTML>
// <p>This function computes</p>
// <pre>                            (<b>A</b>T)^2   (<b>A</b>T)^3 
//      <font size=4> <b>&Phi;</b></font> = e^(<b>A</b>T) = <b>I</b> + <b>A</b>T + ------ + ------ + ....
//                               2!       3!
// </pre>
// <p>where e=2.71828..., <b>A</b> is an n x n matrix with real elements and T is a real number, 
// e.g., the sampling time.
// <b>A</b> may be singular. With the exponential of a matrix it is, e.g., possible
// to compute the solution of a linear system of differential equations</p>
// <pre>    der(<b>x</b>) = <b>A</b>*<b>x</b>   ->   <b>x</b>(t0 + T) = e^(<b>A</b>T)*x(t0) 
// </pre>
// <p>
// The function is called as
// <pre>     Phi = Matrices.exp(A,T);</pre>
// or 
// <pre>       M = Matrices.exp(A);
// </pre>
// what calculates M as the exponential of matrix A.
// </p>
// <p><b>Algorithmic details:</b></p>
// <p>The algorithm is taken from </p>
// <dl>
// <dt>H. D. Joos, G. Gruebel:
// <dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
//     DLR - Control Systems Group 1991
// </dl>
// <p>The following steps are performed to calculate the exponential of A:</p>
// <ol>
//   <li>Matrix <b>A</b> is balanced <br>
//   (= is transformed with a diagonal matrix <b>D</b>, such that inv(<b>D</b>)*<b>A</b>*<b>D</b> 
//   has a smaller condition as <b>A</b>).</li>
//   <li>The scalar T is divided by a multiple of 2 such that norm(
//        inv(<b>D</b>)*<b>A</b>*<b>D</b>*T/2^k ) &lt; 0.5. Note, that (1) and (2) are implemented such that no round-off errors 
//   are introduced.</li>
//   <li>The matrix from (2) is approximated by explicitly performing the Taylor 
//   series expansion with a variable number of terms. 
//   Truncation occurs if a new term does no longer contribute to the value of <b>&Phi;</b>
//   from the previous iteration.</li>
//   <li>The resulting matrix is transformed back, by reverting the steps of (2) 
//   and (1).</li>
// </ol>
// <p>In several sources it is not recommended to use Taylor series expansion to 
// calculate the exponential of a matrix, such as in 'C.B. Moler and C.F. Van Loan: 
// Nineteen dubious ways to compute the exponential of a matrix. SIAM Review 20, 
// pp. 801-836, 1979' or in the documentation of m-file expm2 in Matlab version 6 
// (http://www.MathWorks.com) where it is stated that 'As a practical numerical 
// method, this is often slow and inaccurate'. These statements are valid for a 
// direct implementation of the Taylor series expansion, but <i>not</i> for the 
// implementation variant used in this function. 
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 5, 2002</i>
//        by H. D. Joos and Nico Walther<br>
//        Implemented.
// </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         parameter Integer nmax = 21;
//         parameter Integer na = size(A, 1);
//         Integer j = 1;
//         Integer k = 0;
//         Boolean done = false;
//         Real Anorm;
//         Real Tscaled = 1;
//         Real Atransf[na,na];
//         Real D[na,na];
//         Real M[na,na];
//         Real Diag[na];
//         encapsulated function columnNorm "Returns the column norm of a matrix"
//           input Real A[:,:] "Input matrix";
//           output Real result = 0.0 "1-norm of matrix A";
//         algorithm 
//           for i in 1:size(A, 2) loop
//                       result:=max(result, sum(abs(A[:,i])));
// 
//           end for;
//         end columnNorm;
//       algorithm 
//         (Diag,Atransf):=balance(A);
//         Tscaled:=T;
//         Anorm:=columnNorm(Atransf);
//         Anorm:=Anorm * T;
//         while (Anorm >= 0.5) loop
//                   Anorm:=Anorm / 2;
//           Tscaled:=Tscaled / 2;
//           k:=k + 1;
// 
//         end while;
//         M:=identity(na);
//         D:=M;
//         while (j < nmax and not done) loop
//                   M:=(Atransf * M * Tscaled) / j;
//           if columnNorm(D + M - D) == 0 then 
//                     done:=true;
// 
//           else           D:=M + D;
//           j:=j + 1;
// 
//           end if;
// 
//         end while;
//         for i in 1:k loop
//                   D:=D * D;
// 
//         end for;
//         for j in 1:na loop
//                   for k in 1:na loop
//                       phi[j,k]:=(D[j,k] * Diag[j]) / Diag[k];
// 
//           end for;
// 
//         end for;
//       end exp;
//       function integralExp "Computation of the transition-matrix phi and its integral gamma"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         input Real B[size(A, 1),:];
//         input Real T = 1;
//         output Real phi[size(A, 1),size(A, 1)] "= exp(A*T)";
//         output Real gamma[size(A, 1),size(B, 2)] "= integral(phi)*B";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         parameter Integer nmax = 21;
//         parameter Integer na = size(A, 1);
//         Integer j = 2;
//         Integer k = 0;
//         Boolean done = false;
//         Real Anorm;
//         Real Tscaled = 1;
//         Real Atransf[na,na];
//         Real Psi[na,na];
//         Real M[na,na];
//         Real Diag[na];
//         annotation(Documentation(info = "<HTML>
// <p>
// The function uses a Taylor series expansion with Balancing and
// scaling/squaring to approximate the integral <b>&Psi;</b> of the matrix
// exponential <b>&Phi;</b>=e^(AT):
// </p>
// <pre>                                 AT^2   A^2 * T^3          A^k * T^(k+1)
//         <b>&Psi;</b> = int(e^(As))ds = IT + ---- + --------- + ... + --------------
//                                   2!        3!                (k+1)!
// </pre>
// <p>
// <b>&Phi;</b> is calculated through <b>&Phi;</b> = I + A*<b>&Psi;</b>, so A may be singular. <b>&Gamma;</b> is
// simple <b>&Psi;</b>*B.
// </p>
// <p>The algorithm runs in the following steps: </p>
// <ol>
//   <li>Balancing</li>
//   <li>Scaling</li>
//   <li>Taylor series expansion</li>
//   <li>Re-scaling</li>
//   <li>Re-Balancing</li>
// </ol>
// <p>Balancing put the bad condition of a square matrix <i>A</i> into a diagonal
// transformation matrix <i>D</i>. This reduce the effort of following calculations.
// Afterwards the result have to be re-balanced by transformation D*A<small>transf</small>
//  *inv(D).<br>
// Scaling halfen T&nbsp; k-times, until the norm of A*T is less than 0.5. This
// garantees minumum rounding errors in the following series
// expansion. The re-scaling based on the equation&nbsp; exp(A*2T) = exp(AT)^2.
// The needed re-scaling formula for psi thus becomes:</p>
// <pre>         <b>&Phi;</b> = <b>&Phi;</b>'*<b>&Phi;</b>'
//    I + A*<b>&Psi;</b> = I + 2A*<b>&Psi;</b>' + A^2*<b>&Psi;</b>'^2
//          <b>&Psi;</b> = A*<b>&Psi;</b>'^2 + 2*<b>&Psi;</b>'
// </pre>
// <p>
// where psi' is the scaled result from the series expansion while psi is the
// re-scaled matrix.
// </p>
// <p>
// The function is normally used to discretize a state-space system as the
// zero-order-hold equivalent:
// </p>
// <pre>      x(k+1) = <b>&Phi;</b>*x(k) + <b>&Gamma;</b>*u(k)
//         y(k) = C*x(k) + D*u(k)
// </pre>
// <p>
// The zero-order-hold sampling, also known as step-invariant method, gives
// exact values of the state variables, under the assumption that the control
// signal u is constant between the sampling instants. Zero-order-hold sampling
// is discribed in
// </p>
// <dl>
// <dt>K. J. Astroem, B. Wittenmark:
// <dd><b>Computer Controlled Systems - Theory and Design</b><br>
//     Third Edition, p. 32
// </dl>
// <pre><b>Syntax:</b>
//       (phi,gamma) = Matrices.expIntegral(A,B,T)
//                        A,phi: [n,n] square matrices
//                      B,gamma: [n,m] input matrix
//                            T: scalar, e.g. sampling time
// </pre>
// <p>
// The Algorithm to calculate psi is taken from
// <dl>
// <dt>H. D. Joos, G. Gruebel:
// <dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
//     DLR - Control Systems Group 1991
// </dl>
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 5, 2002</i>
//        by H. D. Joos and Nico Walther<br>
//        Implemented.
// </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         encapsulated function columnNorm "Returns the column norm of a matrix"
//           input Real A[:,:] "Input matrix";
//           output Real result = 0.0 "1-norm of matrix A";
//         algorithm 
//           for i in 1:size(A, 2) loop
//                       result:=max(result, sum(abs(A[:,i])));
// 
//           end for;
//         end columnNorm;
//       algorithm 
//         (Diag,Atransf):=balance(A);
//         Tscaled:=T;
//         Anorm:=columnNorm(Atransf);
//         Anorm:=Anorm * T;
//         while (Anorm >= 0.5) loop
//                   Anorm:=Anorm / 2;
//           Tscaled:=Tscaled / 2;
//           k:=k + 1;
// 
//         end while;
//         M:=identity(na) * Tscaled;
//         Psi:=M;
//         while (j < nmax and not done) loop
//                   M:=(Atransf * M * Tscaled) / j;
//           if columnNorm(Psi + M - Psi) == 0 then 
//                     done:=true;
// 
//           else           Psi:=M + Psi;
//           j:=j + 1;
// 
//           end if;
// 
//         end while;
//         for j in 1:k loop
//                   Psi:=Atransf * Psi * Psi + 2 * Psi;
// 
//         end for;
//         for j in 1:na loop
//                   for k in 1:na loop
//                       Psi[j,k]:=(Psi[j,k] * Diag[j]) / Diag[k];
// 
//           end for;
// 
//         end for;
//         gamma:=Psi * B;
//         phi:=A * Psi + identity(na);
//       end integralExp;
//       function integralExpT "Computation of the transition-matrix phi and the integral gamma and gamma1"
//         extends Modelica.Icons.Function;
//         input Real A[:,size(A, 1)];
//         input Real B[size(A, 1),:];
//         input Real T = 1;
//         output Real phi[size(A, 1),size(A, 1)] "= exp(A*T)";
//         output Real gamma[size(A, 1),size(B, 2)] "= integral(phi)*B";
//         output Real gamma1[size(A, 1),size(B, 2)] "= integral((T-t)*exp(A*t))*B";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer nmax = 200;
//         parameter Integer na = size(A, 1);
//         parameter Integer nb = size(B, 2);
//         Integer j = 1;
//         Boolean done = false;
//         Real F[na + 2 * nb,na + 2 * nb];
//         annotation(Documentation(info = "<HTML>
// <p>
// The function calculates the matrices phi,gamma,gamma1 through the equation:
// </p>
// <pre>                                 [ A B 0 ]
// [phi gamma gamma1] = [I 0 0]*exp([ 0 0 I ]*T)
//                                  [ 0 0 0 ]
// </pre>
// <pre>
// <b>Syntax:</b><br>
//       (phi,gamma,gamma1) = Matrices.ExpIntegral2(A,B,T)
//                      A,phi: [n,n] square matrices
//             B,gamma,gamma1: [n,m] matrices
//                          T: scalar, e.g. sampling time
// </pre>
// <p>
// The matrices define the discretized first-order-hold equivalent of
// a state-space system:
// <pre>      x(k+1) = phi*x(k) + gamma*u(k) + gamma1/T*(u(k+1) - u(k))
// </pre>
// The first-order-hold sampling, also known as ramp-invariant method, gives
// more smooth control signals as the ZOH equivalent. First-order-hold sampling
// is discribed in
// <dl>
// <dt>K. J. Astroem, B. Wittenmark:
// <dd><b>Computer Controlled Systems - Theory and Design</b><br>
//     Third Edition, p. 256
// </dl>
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 31, 2002</i>
//        by Nico Walther<br>
//        Realized.
// </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//       algorithm 
//         F:=[A,B,zeros(na, nb);zeros(2 * nb, na),zeros(2 * nb, nb),[identity(nb);zeros(nb, nb)]];
//         F:=exp(F, T);
//         phi:=F[1:na,1:na];
//         gamma:=F[1:na,na + 1:na + nb];
//         gamma1:=F[1:na,na + nb + 1:na + 2 * nb];
//       end integralExpT;
//     protected 
//       package LAPACK "Interface to LAPACK library"
//         extends Modelica.Icons.Library;
//         function dgeev "Compute eigenvalues and (right) eigenvectors for real nonsymmetrix matrix A"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           output Real eigenReal[size(A, 1)] "Real part of eigen values";
//           output Real eigenImag[size(A, 1)] "Imaginary part of eigen values";
//           output Real eigenVectors[size(A, 1),size(A, 1)] "Right eigen vectors";
//           output Integer info;
//         protected 
//           Integer n = size(A, 1);
//           Integer lwork = 12 * n;
//           Real Awork[n,n] = A;
//           Real work[lwork];
//           annotation(Documentation(info = "Lapack documentation
//     Purpose   
//     =======   
//     DGEEV computes for an N-by-N real nonsymmetric matrix A, the   
//     eigenvalues and, optionally, the left and/or right eigenvectors.   
//     The right eigenvector v(j) of A satisfies   
//                      A * v(j) = lambda(j) * v(j)   
//     where lambda(j) is its eigenvalue.   
//     The left eigenvector u(j) of A satisfies   
//                   u(j)**H * A = lambda(j) * u(j)**H   
//     where u(j)**H denotes the conjugate transpose of u(j).   
//     The computed eigenvectors are normalized to have Euclidean norm   
//     equal to 1 and largest component real.   
//     Arguments   
//     =========   
//     JOBVL   (input) CHARACTER*1   
//             = 'N': left eigenvectors of A are not computed;   
//             = 'V': left eigenvectors of A are computed.   
//     JOBVR   (input) CHARACTER*1   
//             = 'N': right eigenvectors of A are not computed;   
//             = 'V': right eigenvectors of A are computed.   
//     N       (input) INTEGER   
//             The order of the matrix A. N >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the N-by-N matrix A.   
//             On exit, A has been overwritten.   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,N).   
//     WR      (output) DOUBLE PRECISION array, dimension (N)   
//     WI      (output) DOUBLE PRECISION array, dimension (N)   
//             WR and WI contain the real and imaginary parts,   
//             respectively, of the computed eigenvalues.  Complex   
//             conjugate pairs of eigenvalues appear consecutively   
//             with the eigenvalue having the positive imaginary part   
//             first.   
//     VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)   
//             If JOBVL = 'V', the left eigenvectors u(j) are stored one   
//             after another in the columns of VL, in the same order   
//             as their eigenvalues.   
//             If JOBVL = 'N', VL is not referenced.   
//             If the j-th eigenvalue is real, then u(j) = VL(:,j),   
//             the j-th column of VL.   
//             If the j-th and (j+1)-st eigenvalues form a complex   
//             conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and   
//             u(j+1) = VL(:,j) - i*VL(:,j+1).   
//     LDVL    (input) INTEGER   
//             The leading dimension of the array VL.  LDVL >= 1; if   
//             JOBVL = 'V', LDVL >= N.   
//     VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)   
//             If JOBVR = 'V', the right eigenvectors v(j) are stored one   
//             after another in the columns of VR, in the same order   
//             as their eigenvalues.   
//             If JOBVR = 'N', VR is not referenced.   
//             If the j-th eigenvalue is real, then v(j) = VR(:,j),   
//             the j-th column of VR.   
//             If the j-th and (j+1)-st eigenvalues form a complex   
//             conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and   
//             v(j+1) = VR(:,j) - i*VR(:,j+1).   
//     LDVR    (input) INTEGER   
//             The leading dimension of the array VR.  LDVR >= 1; if   
//             JOBVR = 'V', LDVR >= N.   
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) 
//   
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
//     LWORK   (input) INTEGER   
//             The dimension of the array WORK.  LWORK >= max(1,3*N), and   
//             if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good   
//             performance, LWORK must generally be larger.   
//     INFO    (output) INTEGER   
//             = 0:  successful exit   
//             < 0:  if INFO = -i, the i-th argument had an illegal value.   
//             > 0:  if INFO = i, the QR algorithm failed to compute all the 
//                   eigenvalues, and no eigenvectors have been computed;   
//                   elements i+1:N of WR and WI contain eigenvalues which   
//                   have converged.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "Fortran 77" dgeev("N","V",n,Awork,n,eigenReal,eigenImag,eigenVectors,n,eigenVectors,n,work,size(work, 1),info)           annotation(Library = "Lapack"); 
//         end dgeev;
//         function dgeev_eigenValues "Compute eigenvalues for real nonsymmetrix matrix A"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           output Real EigenReal[size(A, 1)];
//           output Real EigenImag[size(A, 1)];
//           output Integer info;
//         protected 
//           Integer lwork = 8 * size(A, 1);
//           Real Awork[size(A, 1),size(A, 1)] = A;
//           Real work[lwork];
//           Real EigenvectorsL[size(A, 1),size(A, 1)] = zeros(size(A, 1), size(A, 1));
//           annotation(Documentation(info = "Lapack documentation
//     Purpose   
//     =======   
//     DGEEV computes for an N-by-N real nonsymmetric matrix A, the   
//     eigenvalues and, optionally, the left and/or right eigenvectors.   
//     The right eigenvector v(j) of A satisfies   
//                      A * v(j) = lambda(j) * v(j)   
//     where lambda(j) is its eigenvalue.   
//     The left eigenvector u(j) of A satisfies   
//                   u(j)**H * A = lambda(j) * u(j)**H   
//     where u(j)**H denotes the conjugate transpose of u(j).   
//     The computed eigenvectors are normalized to have Euclidean norm   
//     equal to 1 and largest component real.   
//     Arguments   
//     =========   
//     JOBVL   (input) CHARACTER*1   
//             = 'N': left eigenvectors of A are not computed;   
//             = 'V': left eigenvectors of A are computed.   
//     JOBVR   (input) CHARACTER*1   
//             = 'N': right eigenvectors of A are not computed;   
//             = 'V': right eigenvectors of A are computed.   
//     N       (input) INTEGER   
//             The order of the matrix A. N >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the N-by-N matrix A.   
//             On exit, A has been overwritten.   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,N).   
//     WR      (output) DOUBLE PRECISION array, dimension (N)   
//     WI      (output) DOUBLE PRECISION array, dimension (N)   
//             WR and WI contain the real and imaginary parts,   
//             respectively, of the computed eigenvalues.  Complex   
//             conjugate pairs of eigenvalues appear consecutively   
//             with the eigenvalue having the positive imaginary part   
//             first.   
//     VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)   
//             If JOBVL = 'V', the left eigenvectors u(j) are stored one   
//             after another in the columns of VL, in the same order   
//             as their eigenvalues.   
//             If JOBVL = 'N', VL is not referenced.   
//             If the j-th eigenvalue is real, then u(j) = VL(:,j),   
//             the j-th column of VL.   
//             If the j-th and (j+1)-st eigenvalues form a complex   
//             conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and   
//             u(j+1) = VL(:,j) - i*VL(:,j+1).   
//     LDVL    (input) INTEGER   
//             The leading dimension of the array VL.  LDVL >= 1; if   
//             JOBVL = 'V', LDVL >= N.   
//     VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)   
//             If JOBVR = 'V', the right eigenvectors v(j) are stored one   
//             after another in the columns of VR, in the same order   
//             as their eigenvalues.   
//             If JOBVR = 'N', VR is not referenced.   
//             If the j-th eigenvalue is real, then v(j) = VR(:,j),   
//             the j-th column of VR.   
//             If the j-th and (j+1)-st eigenvalues form a complex   
//             conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and   
//             v(j+1) = VR(:,j) - i*VR(:,j+1).   
//     LDVR    (input) INTEGER   
//             The leading dimension of the array VR.  LDVR >= 1; if   
//             JOBVR = 'V', LDVR >= N.   
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) 
//   
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
//     LWORK   (input) INTEGER   
//             The dimension of the array WORK.  LWORK >= max(1,3*N), and   
//             if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good   
//             performance, LWORK must generally be larger.   
//     INFO    (output) INTEGER   
//             = 0:  successful exit   
//             < 0:  if INFO = -i, the i-th argument had an illegal value.   
//             > 0:  if INFO = i, the QR algorithm failed to compute all the 
//                   eigenvalues, and no eigenvectors have been computed;   
//                   elements i+1:N of WR and WI contain eigenvalues which   
//                   have converged.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "Fortran 77" dgeev("N","N",size(A, 1),Awork,size(A, 1),EigenReal,EigenImag,EigenvectorsL,size(EigenvectorsL, 1),EigenvectorsL,size(EigenvectorsL, 1),work,size(work, 1),info)           annotation(Library = "Lapack"); 
//         end dgeev_eigenValues;
//         function dgels_vec "Solves overdetermined or underdetermined real linear equations A*x=b with a b vector"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           input Real b[size(A, 1)];
//           output Real x[nx] = cat(1, b, zeros(nx - nrow)) "solution is in first size(A,2) rows";
//           output Integer info;
//         protected 
//           Integer nrow = size(A, 1);
//           Integer ncol = size(A, 2);
//           Integer nx = max(nrow, ncol);
//           Integer lwork = min(nrow, ncol) + nx;
//           Real work[lwork];
//           Real Awork[nrow,ncol] = A;
// 
//           external "FORTRAN 77" dgels("N",nrow,ncol,1,Awork,nrow,x,nx,work,lwork,info)           annotation(Library = "Lapack");           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.25, y = 0.3, width = 0.6, height = 0.6), Documentation(info = "Lapack documentation
//   Purpose                                                                 
//   =======                                                                 
//                                                                           
//   DGELS solves overdetermined or underdetermined real linear systems      
//   involving an M-by-N matrix A, or its transpose, using a QR or LQ        
//   factorization of A.  It is assumed that A has full rank.                
//                                                                           
//   The following options are provided:                                     
//                                                                           
//   1. If TRANS = 'N' and m >= n:  find the least squares solution of       
//      an overdetermined system, i.e., solve the least squares problem      
//                   minimize || B - A*X ||.                                 
//                                                                           
//   2. If TRANS = 'N' and m < n:  find the minimum norm solution of         
//      an underdetermined system A * X = B.                                 
//                                                                           
//   3. If TRANS = 'T' and m >= n:  find the minimum norm solution of        
//      an undetermined system A**T * X = B.                                 
//                                                                           
//   4. If TRANS = 'T' and m < n:  find the least squares solution of        
//      an overdetermined system, i.e., solve the least squares problem      
//                   minimize || B - A**T * X ||.                            
//                                                                           
//   Several right hand side vectors b and solution vectors x can be         
//   handled in a single call; they are stored as the columns of the         
//   M-by-NRHS right hand side matrix B and the N-by-NRHS solution           
//   matrix X.                                                               
//                                                                           
//   Arguments                                                               
//   =========                                                               
//                                                                           
//   TRANS   (input) CHARACTER                                               
//           = 'N': the linear system involves A;                            
//           = 'T': the linear system involves A**T.                         
//                                                                           
//   M       (input) INTEGER                                                 
//           The number of rows of the matrix A.  M >= 0.                    
//                                                                           
//   N       (input) INTEGER                                                 
//           The number of columns of the matrix A.  N >= 0.                 
//                                                                           
//   NRHS    (input) INTEGER                                                 
//           The number of right hand sides, i.e., the number of             
//           columns of the matrices B and X. NRHS >=0.                      
//                                                                           
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)        
//           On entry, the M-by-N matrix A.                                  
//           On exit,                                                        
//             if M >= N, A is overwritten by details of its QR              
//                        factorization as returned by DGEQRF;               
//             if M <  N, A is overwritten by details of its LQ              
//                        factorization as returned by DGELQF.               
//                                                                           
//   LDA     (input) INTEGER                                                 
//           The leading dimension of the array A.  LDA >= max(1,M).         
//                                                                           
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)     
//           On entry, the matrix B of right hand side vectors, stored       
//           columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS         
//           if TRANS = 'T'.                                                 
//           On exit, B is overwritten by the solution vectors, stored       
//           columnwise:  if TRANS = 'N' and m >= n, rows 1 to n of B        
//           contain the least squares solution vectors; the residual        
//           sum of squares for the solution in each column is given by      
//           the sum of squares of elements N+1 to M in that column;         
//           if TRANS = 'N' and m < n, rows 1 to N of B contain the          
//           minimum norm solution vectors;                                  
//           if TRANS = 'T' and m >= n, rows 1 to M of B contain the         
//           minimum norm solution vectors;                                  
//           if TRANS = 'T' and m < n, rows 1 to M of B contain the          
//           least squares solution vectors; the residual sum of squares     
//           for the solution in each column is given by the sum of          
//           squares of elements M+1 to N in that column.                    
//                                                                           
//   LDB     (input) INTEGER                                                 
//           The leading dimension of the array B. LDB >= MAX(1,M,N).        
//                                                                           
//   WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)           
//           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.        
//                                                                           
//   LWORK   (input) INTEGER                                                 
//           The dimension of the array WORK.                                
//           LWORK >= min(M,N) + MAX(1,M,N,NRHS).                            
//           For optimal performance,                                        
//           LWORK >= min(M,N) + MAX(1,M,N,NRHS) * NB                        
//           where NB is the optimum block size.                             
//                                                                           
//   INFO    (output) INTEGER                                                
//           = 0:  successful exit                                           
//           < 0:  if INFO = -i, the i-th argument had an illegal value      
//                                                                           "));
//         end dgels_vec;
//         function dgelsx_vec "Computes the minimum-norm solution to a real linear least squares problem with rank deficient A"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           input Real b[size(A, 1)];
//           input Real rcond = 0.0 "Reciprocal condition number to estimate rank";
//           output Real x[max(nrow, ncol)] = cat(1, b, zeros(max(nrow, ncol) - nrow)) "solution is in first size(A,2) rows";
//           output Integer info;
//           output Integer rank "Effective rank of A";
//         protected 
//           Integer nrow = size(A, 1);
//           Integer ncol = size(A, 2);
//           Integer nx = max(nrow, ncol);
//           Integer lwork = max(min(nrow, ncol) + 3 * ncol, 2 * min(nrow, ncol) + 1);
//           Real work[lwork];
//           Real Awork[nrow,ncol] = A;
//           Integer jpvt[ncol] = zeros(ncol);
// 
//           external "FORTRAN 77" dgelsx(nrow,ncol,1,Awork,nrow,x,nx,jpvt,rcond,rank,work,lwork,info)           annotation(Library = "Lapack");           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.25, y = 0.3, width = 0.6, height = 0.6), Documentation(info = "Lapack documentation
//   Purpose                                                               
//   =======                                                               
//                                                                         
//   DGELSX computes the minimum-norm solution to a real linear least      
//   squares problem:                                                      
//       minimize || A * X - B ||                                          
//   using a complete orthogonal factorization of A.  A is an M-by-N       
//   matrix which may be rank-deficient.                                   
//                                                                         
//   Several right hand side vectors b and solution vectors x can be       
//   handled in a single call; they are stored as the columns of the       
//   M-by-NRHS right hand side matrix B and the N-by-NRHS solution         
//   matrix X.                                                             
//                                                                         
//   The routine first computes a QR factorization with column pivoting:   
//       A * P = Q * [ R11 R12 ]                                           
//                   [  0  R22 ]                                           
//   with R11 defined as the largest leading submatrix whose estimated     
//   condition number is less than 1/RCOND.  The order of R11, RANK,       
//   is the effective rank of A.                                           
//                                                                         
//   Then, R22 is considered to be negligible, and R12 is annihilated      
//   by orthogonal transformations from the right, arriving at the         
//   complete orthogonal factorization:                                    
//      A * P = Q * [ T11 0 ] * Z                                          
//                  [  0  0 ]                                              
//   The minimum-norm solution is then                                     
//      X = P * Z' [ inv(T11)*Q1'*B ]                                      
//                 [        0       ]                                      
//   where Q1 consists of the first RANK columns of Q.                     
//                                                                         
//   Arguments                                                             
//   =========                                                             
//                                                                         
//   M       (input) INTEGER                                               
//           The number of rows of the matrix A.  M >= 0.                  
//                                                                         
//   N       (input) INTEGER                                               
//           The number of columns of the matrix A.  N >= 0.               
//                                                                         
//   NRHS    (input) INTEGER                                               
//           The number of right hand sides, i.e., the number of           
//           columns of matrices B and X. NRHS >= 0.                       
//                                                                         
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)      
//           On entry, the M-by-N matrix A.                                
//           On exit, A has been overwritten by details of its             
//           complete orthogonal factorization.                            
//                                                                         
//   LDA     (input) INTEGER                                               
//           The leading dimension of the array A.  LDA >= max(1,M).       
//                                                                         
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)   
//           On entry, the M-by-NRHS right hand side matrix B.             
//           On exit, the N-by-NRHS solution matrix X.                     
//           If m >= n and RANK = n, the residual sum-of-squares for       
//           the solution in the i-th column is given by the sum of        
//           squares of elements N+1:M in that column.                     
//                                                                         
//   LDB     (input) INTEGER                                               
//           The leading dimension of the array B. LDB >= max(1,M,N).      
//                                                                         
//   JPVT    (input/output) INTEGER array, dimension (N)                   
//           On entry, if JPVT(i) .ne. 0, the i-th column of A is an       
//           initial column, otherwise it is a free column.  Before        
//           the QR factorization of A, all initial columns are            
//           permuted to the leading positions; only the remaining         
//           free columns are moved as a result of column pivoting         
//           during the factorization.                                     
//           On exit, if JPVT(i) = k, then the i-th column of A*P          
//           was the k-th column of A.                                     
//                                                                         
//   RCOND   (input) DOUBLE PRECISION                                      
//           RCOND is used to determine the effective rank of A, which     
//           is defined as the order of the largest leading triangular     
//           submatrix R11 in the QR factorization with pivoting of A,     
//           whose estimated condition number < 1/RCOND.                   
//                                                                         
//   RANK    (output) INTEGER                                              
//           The effective rank of A, i.e., the order of the submatrix     
//           R11.  This is the same as the order of the submatrix T11      
//           in the complete orthogonal factorization of A.                
//                                                                         
//   WORK    (workspace) DOUBLE PRECISION array, dimension                 
//                       (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),           
//                                                                         
//   INFO    (output) INTEGER                                              
//           = 0:  successful exit                                         
//           < 0:  if INFO = -i, the i-th argument had an illegal value    "));
//         end dgelsx_vec;
//         function dgesv "Solve real system of linear equations A*X=B with a B matrix"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           input Real B[size(A, 1),:];
//           output Real X[size(A, 1),size(B, 2)] = B;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 1)] = A;
//           Integer ipiv[size(A, 1)];
//           annotation(Documentation(info = "Lapack documentation:
//     Purpose   
//     =======   
//     DGESV computes the solution to a real system of linear equations   
//        A * X = B,   
//     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.   
//     The LU decomposition with partial pivoting and row interchanges is   
//     used to factor A as   
//        A = P * L * U,   
//     where P is a permutation matrix, L is unit lower triangular, and U is 
//   
//     upper triangular.  The factored form of A is then used to solve the   
//     system of equations A * X = B.   
//     Arguments   
//     =========   
//     N       (input) INTEGER   
//             The number of linear equations, i.e., the order of the   
//             matrix A.  N >= 0.   
//     NRHS    (input) INTEGER   
//             The number of right hand sides, i.e., the number of columns   
//             of the matrix B.  NRHS >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the N-by-N coefficient matrix A.   
//             On exit, the factors L and U from the factorization   
//             A = P*L*U; the unit diagonal elements of L are not stored.   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,N).   
//     IPIV    (output) INTEGER array, dimension (N)   
//             The pivot indices that define the permutation matrix P;   
//             row i of the matrix was interchanged with row IPIV(i).   
//     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)   
//             On entry, the N-by-NRHS matrix of right hand side matrix B.   
//             On exit, if INFO = 0, the N-by-NRHS solution matrix X.   
//     LDB     (input) INTEGER   
//             The leading dimension of the array B.  LDB >= max(1,N).   
//     INFO    (output) INTEGER   
//             = 0:  successful exit   
//             < 0:  if INFO = -i, the i-th argument had an illegal value   
//             > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization 
//   
//                   has been completed, but the factor U is exactly   
//                   singular, so the solution could not be computed.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgesv(size(A, 1),size(B, 2),Awork,size(A, 1),ipiv,X,size(A, 1),info)           annotation(Library = "Lapack"); 
//         end dgesv;
//         function dgesv_vec "Solve real system of linear equations A*x=b with a b vector"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           input Real b[size(A, 1)];
//           output Real x[size(A, 1)] = b;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 1)] = A;
//           Integer ipiv[size(A, 1)];
//           annotation(Documentation(info = "
// Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
// For details of the arguments, see documentation of dgesv.
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgesv(size(A, 1),1,Awork,size(A, 1),ipiv,x,size(A, 1),info)           annotation(Library = "Lapack"); 
//         end dgesv_vec;
//         function dgesvx "Solve real system of linear equations A*X=B with a B matrix, error bounds and condition estimate"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           input Real B[size(A, 1),:];
//           output Real X[size(A, 1),size(B, 2)] = zeros(size(B, 1), size(B, 2));
//           output Real RCond;
//           output Real FErrBound;
//           output Real BErrBound;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Real Bwork[size(B, 1),size(B, 2)] = B;
//           Real AF[size(A, 1),size(A, 2)];
//           Integer ipiv[size(A, 1)];
//           String equed = StringAllocate(1);
//           Real R[size(A, 1)];
//           Real C[size(A, 1)];
//           Real work[4 * size(A, 1)];
//           Integer iwork[size(A, 1)];
//           annotation(Documentation(info = "Lapack documentation:
//     Purpose   
//     =======   
//     DGESVX uses the LU factorization to compute the solution to a real   
//     system of linear equations   
//        A * X = B,   
//     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.   
//     Error bounds on the solution and a condition estimate are also   
//     provided.   
//     Description   
//     ===========   
//     The following steps are performed:   
//     1. If FACT = 'E', real scaling factors are computed to equilibrate   
//        the system:   
//           TRANS = 'N':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B 
//   
//           TRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B 
//   
//           TRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B 
//   
//        Whether or not the system will be equilibrated depends on the   
//        scaling of the matrix A, but if equilibration is used, A is   
//        overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N') 
//   
//        or diag(C)*B (if TRANS = 'T' or 'C').   
//     2. If FACT = 'N' or 'E', the LU decomposition is used to factor the   
//        matrix A (after equilibration if FACT = 'E') as   
//           A = P * L * U,   
//        where P is a permutation matrix, L is a unit lower triangular   
//        matrix, and U is upper triangular.   
//     3. The factored form of A is used to estimate the condition number   
//        of the matrix A.  If the reciprocal of the condition number is   
//        less than machine precision, steps 4-6 are skipped.   
//     4. The system of equations is solved for X using the factored form   
//        of A.   
//     5. Iterative refinement is applied to improve the computed solution   
//        matrix and calculate error bounds and backward error estimates   
//        for it.   
//     6. If equilibration was used, the matrix X is premultiplied by   
//        diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so   
//        that it solves the original system before equilibration.   
//     Arguments   
//     =========   
//     FACT    (input) CHARACTER*1   
//             Specifies whether or not the factored form of the matrix A is 
//   
//             supplied on entry, and if not, whether the matrix A should be 
//   
//             equilibrated before it is factored.   
//             = 'F':  On entry, AF and IPIV contain the factored form of A. 
//   
//                     If EQUED is not 'N', the matrix A has been   
//                     equilibrated with scaling factors given by R and C.   
//                     A, AF, and IPIV are not modified.   
//             = 'N':  The matrix A will be copied to AF and factored.   
//             = 'E':  The matrix A will be equilibrated if necessary, then 
//   
//                     copied to AF and factored.   
//     TRANS   (input) CHARACTER*1   
//             Specifies the form of the system of equations:   
//             = 'N':  A * X = B     (No transpose)   
//             = 'T':  A**T * X = B  (Transpose)   
//             = 'C':  A**H * X = B  (Transpose)   
//     N       (input) INTEGER   
//             The number of linear equations, i.e., the order of the   
//             matrix A.  N >= 0.   
//     NRHS    (input) INTEGER   
//             The number of right hand sides, i.e., the number of columns   
//             of the matrices B and X.  NRHS >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the N-by-N matrix A.  If FACT = 'F' and EQUED is   
//             not 'N', then A must have been equilibrated by the scaling   
//             factors in R and/or C.  A is not modified if FACT = 'F' or   
//             'N', or if FACT = 'E' and EQUED = 'N' on exit.   
//             On exit, if EQUED .ne. 'N', A is scaled as follows:   
//             EQUED = 'R':  A := diag(R) * A   
//             EQUED = 'C':  A := A * diag(C)   
//             EQUED = 'B':  A := diag(R) * A * diag(C).   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,N).   
//     AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N) 
//   
//             If FACT = 'F', then AF is an input argument and on entry   
//             contains the factors L and U from the factorization   
//             A = P*L*U as computed by DGETRF.  If EQUED .ne. 'N', then   
//             AF is the factored form of the equilibrated matrix A.   
//             If FACT = 'N', then AF is an output argument and on exit   
//             returns the factors L and U from the factorization A = P*L*U 
//   
//             of the original matrix A.   
//             If FACT = 'E', then AF is an output argument and on exit   
//             returns the factors L and U from the factorization A = P*L*U 
//   
//             of the equilibrated matrix A (see the description of A for   
//             the form of the equilibrated matrix).   
//     LDAF    (input) INTEGER   
//             The leading dimension of the array AF.  LDAF >= max(1,N).   
//     IPIV    (input or output) INTEGER array, dimension (N)   
//             If FACT = 'F', then IPIV is an input argument and on entry   
//             contains the pivot indices from the factorization A = P*L*U   
//             as computed by DGETRF; row i of the matrix was interchanged   
//             with row IPIV(i).   
//             If FACT = 'N', then IPIV is an output argument and on exit   
//             contains the pivot indices from the factorization A = P*L*U   
//             of the original matrix A.   
//             If FACT = 'E', then IPIV is an output argument and on exit   
//             contains the pivot indices from the factorization A = P*L*U   
//             of the equilibrated matrix A.   
//     EQUED   (input or output) CHARACTER*1   
//             Specifies the form of equilibration that was done.   
//             = 'N':  No equilibration (always true if FACT = 'N').   
//             = 'R':  Row equilibration, i.e., A has been premultiplied by 
//   
//                     diag(R).   
//             = 'C':  Column equilibration, i.e., A has been postmultiplied 
//   
//                     by diag(C).   
//             = 'B':  Both row and column equilibration, i.e., A has been   
//                     replaced by diag(R) * A * diag(C).   
//             EQUED is an input argument if FACT = 'F'; otherwise, it is an 
//   
//             output argument.   
//     R       (input or output) DOUBLE PRECISION array, dimension (N)   
//             The row scale factors for A.  If EQUED = 'R' or 'B', A is   
//             multiplied on the left by diag(R); if EQUED = 'N' or 'C', R   
//             is not accessed.  R is an input argument if FACT = 'F';   
//             otherwise, R is an output argument.  If FACT = 'F' and   
//             EQUED = 'R' or 'B', each element of R must be positive.   
//     C       (input or output) DOUBLE PRECISION array, dimension (N)   
//             The column scale factors for A.  If EQUED = 'C' or 'B', A is 
//   
//             multiplied on the right by diag(C); if EQUED = 'N' or 'R', C 
//   
//             is not accessed.  C is an input argument if FACT = 'F';   
//             otherwise, C is an output argument.  If FACT = 'F' and   
//             EQUED = 'C' or 'B', each element of C must be positive.   
//     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)   
//             On entry, the N-by-NRHS right hand side matrix B.   
//             On exit,   
//             if EQUED = 'N', B is not modified;   
//             if TRANS = 'N' and EQUED = 'R' or 'B', B is overwritten by   
//             diag(R)*B;   
//             if TRANS = 'T' or 'C' and EQUED = 'C' or 'B', B is   
//             overwritten by diag(C)*B.   
//     LDB     (input) INTEGER   
//             The leading dimension of the array B.  LDB >= max(1,N).   
//     X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)   
//             If INFO = 0, the N-by-NRHS solution matrix X to the original 
//   
//             system of equations.  Note that A and B are modified on exit 
//   
//             if EQUED .ne. 'N', and the solution to the equilibrated   
//             system is inv(diag(C))*X if TRANS = 'N' and EQUED = 'C' or   
//             'B', or inv(diag(R))*X if TRANS = 'T' or 'C' and EQUED = 'R' 
//   
//             or 'B'.   
//     LDX     (input) INTEGER   
//             The leading dimension of the array X.  LDX >= max(1,N).   
//     RCOND   (output) DOUBLE PRECISION   
//             The estimate of the reciprocal condition number of the matrix 
//   
//             A after equilibration (if done).  If RCOND is less than the   
//             machine precision (in particular, if RCOND = 0), the matrix   
//             is singular to working precision.  This condition is   
//             indicated by a return code of INFO > 0, and the solution and 
//   
//             error bounds are not computed.   
//     FERR    (output) DOUBLE PRECISION array, dimension (NRHS)   
//             The estimated forward error bound for each solution vector   
//             X(j) (the j-th column of the solution matrix X).   
//             If XTRUE is the true solution corresponding to X(j), FERR(j) 
//   
//             is an estimated upper bound for the magnitude of the largest 
//   
//             element in (X(j) - XTRUE) divided by the magnitude of the   
//             largest element in X(j).  The estimate is as reliable as   
//             the estimate for RCOND, and is almost always a slight   
//             overestimate of the true error.   
//     BERR    (output) DOUBLE PRECISION array, dimension (NRHS)   
//             The componentwise relative backward error of each solution   
//             vector X(j) (i.e., the smallest relative change in   
//             any element of A or B that makes X(j) an exact solution).   
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (4*N)   
//             On exit, WORK(1) contains the reciprocal pivot growth   
//             factor norm(A)/norm(U). The \"max absolute element\" norm is   
//             used. If WORK(1) is much less than 1, then the stability   
//             of the LU factorization of the (equilibrated) matrix A   
//             could be poor. This also means that the solution X, condition 
//   
//             estimator RCOND, and forward error bound FERR could be   
//             unreliable. If factorization fails with 0<INFO<=N, then   
//             WORK(1) contains the reciprocal pivot growth factor for the   
//             leading INFO columns of A.   
//     IWORK   (workspace) INTEGER array, dimension (N)   
//     INFO    (output) INTEGER   
//             = 0:  successful exit   
//             < 0:  if INFO = -i, the i-th argument had an illegal value   
//             > 0:  if INFO = i, and i is   
//                   <= N:  U(i,i) is exactly zero.  The factorization has   
//                          been completed, but the factor U is exactly   
//                          singular, so the solution and error bounds   
//                          could not be computed.   
//                   = N+1: RCOND is less than machine precision.  The   
//                          factorization has been completed, but the   
//                          matrix is singular to working precision, and   
//                          the solution and error bounds have not been   
//                          computed.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgesvx("E","N",size(A, 1),size(B, 2),Awork,size(A, 1),AF,size(A, 1),ipiv,equed,R,C,Bwork,size(B, 1),X,size(X, 1),RCond,FErrBound,BErrBound,work,iwork,info)           annotation(Library = "Lapack"); 
//         end dgesvx;
//         function dgesvx_vec "Solve real system of linear equations A*x=b with a b vector, error bounds and condition estimate"
//           extends Modelica.Icons.Function;
//           input Real A[:,size(A, 1)];
//           input Real b[size(A, 1)];
//           output Real x[size(A, 1)] = zeros(size(A, 1));
//           output Real RCond;
//           output Real FErrBound;
//           output Real BErrBound;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Real Bwork[size(A, 1)] = b;
//           Real AF[size(A, 1),size(A, 2)];
//           Integer ipiv[size(A, 1)];
//           String equed = StringAllocate(1);
//           Real R[size(A, 1)];
//           Real C[size(A, 1)];
//           Real work[4 * size(A, 1)];
//           Integer iwork[size(A, 1)];
//           annotation(Documentation(info = "
// Same as function LAPACK.dgesvx, but right hand side is a vector and not a matrix.
// For details of the arguments, see documentation of dgesvx.
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgesvx("E","N",size(A, 1),1,Awork,size(A, 1),AF,size(A, 1),ipiv,equed,R,C,Bwork,size(b, 1),x,size(x, 1),RCond,FErrBound,BErrBound,work,iwork,info)           annotation(Library = "Lapack"); 
//         end dgesvx_vec;
//         function dgglse_vec "Solve a linear equality constrained least squares problem"
//           extends Modelica.Icons.Function;
//           input Real A[:,:] "Minimize |A*x - c|^2";
//           input Real c[size(A, 1)];
//           input Real B[:,size(A, 2)] "subject to B*x=d";
//           input Real d[size(B, 1)];
//           output Real x[size(A, 2)] "solution vector";
//           output Integer info;
//         protected 
//           Integer nrow_A = size(A, 1);
//           Integer nrow_B = size(B, 1);
//           Integer ncol_A = size(A, 2) "(min=nrow_B,max=nrow_A+nrow_B) required";
//           Real Awork[nrow_A,ncol_A] = A;
//           Real Bwork[nrow_B,ncol_A] = B;
//           Real cwork[nrow_A] = c;
//           Real dwork[nrow_B] = d;
//           Integer lwork = ncol_A + nrow_B + max(nrow_A, max(ncol_A, nrow_B)) * 5;
//           Real work[lwork];
// 
//           external "FORTRAN 77" dgglse(nrow_A,ncol_A,nrow_B,Awork,nrow_A,Bwork,nrow_B,cwork,dwork,x,work,lwork,info)           annotation(Library = "Lapack");           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "Lapack documentation
//  
//   Purpose
//   =======
//  
//   DGGLSE solves the linear equality constrained least squares (LSE)
//   problem:
//  
//           minimize || A*x - c ||_2   subject to B*x = d
//  
//   using a generalized RQ factorization of matrices A and B, where A is
//   M-by-N, B is P-by-N, assume P <= N <= M+P, and ||.||_2 denotes vector
//   2-norm. It is assumed that
//  
//                        rank(B) = P                                  (1)
//  
//   and the null spaces of A and B intersect only trivially, i.e.,
//  
//    intersection of Null(A) and Null(B) = {0} <=> rank( ( A ) ) = N  (2)
//                                                      ( ( B ) )
//  
//   where N(A) denotes the null space of matrix A. Conditions (1) and (2)
//   ensure that the problem LSE has a unique solution.
//  
//   Arguments
//   =========
//  
//   M       (input) INTEGER
//           The number of rows of the matrix A.  M >= 0.
//  
//   N       (input) INTEGER
//           The number of columns of the matrices A and B. N >= 0.
//           Assume that P <= N <= M+P.
//  
//   P       (input) INTEGER
//           The number of rows of the matrix B.  P >= 0.
//  
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//           On entry, the P-by-M matrix A.
//           On exit, A is destroyed.
//  
//   LDA     (input) INTEGER
//           The leading dimension of the array A. LDA >= max(1,M).
//  
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
//           On entry, the P-by-N matrix B.
//           On exit, B is destroyed.
//  
//   LDB     (input) INTEGER
//           The leading dimension of the array B. LDB >= max(1,P).
//  
//   C       (input/output) DOUBLE PRECISION array, dimension (M)
//           On entry, C contains the right hand side vector for the
//           least squares part of the LSE problem.
//           On exit, the residual sum of squares for the solution
//           is given by the sum of squares of elements N-P+1 to M of
//           vector C.
//  
//   D       (input/output) DOUBLE PRECISION array, dimension (P)
//           On entry, D contains the right hand side vector for the
//           constrained equation.
//           On exit, D is destroyed.
//  
//   X       (output) DOUBLE PRECISION array, dimension (N)
//           On exit, X is the solution of the LSE problem.
//  
//   WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
//  
//   LWORK   (input) INTEGER
//           The dimension of the array WORK. LWORK >= N+P+max(N,M,P).
//           For optimum performance LWORK >=
//           N+P+max(M,P,N)*max(NB1,NB2), where NB1 is the optimal
//           blocksize for the QR factorization of M-by-N matrix A.
//           NB2 is the optimal blocksize for the RQ factorization of
//           P-by-N matrix B.
//  
//   INFO    (output) INTEGER
//           = 0:  successful exit.
//           < 0:  if INFO = -i, the i-th argument had an illegal value.
// "), Window(x = 0.34, y = 0.06, width = 0.6, height = 0.6));
//         end dgglse_vec;
//         function dgtsv "Solve real system of linear equations A*X=B with B matrix and tridiagonal A"
//           extends Modelica.Icons.Function;
//           input Real superdiag[:];
//           input Real diag[size(superdiag, 1) + 1];
//           input Real subdiag[size(superdiag, 1)];
//           input Real B[size(diag, 1),:];
//           output Real X[size(B, 1),size(B, 2)] = B;
//           output Integer info;
//         protected 
//           Real superdiagwork[size(superdiag, 1)] = superdiag;
//           Real diagwork[size(diag, 1)] = diag;
//           Real subdiagwork[size(subdiag, 1)] = subdiag;
//           annotation(Documentation(info = "Lapack documentation:
//     Purpose   
//     =======   
//     DGTSV  solves the equation   
//        A*X = B,   
//     where A is an N-by-N tridiagonal matrix, by Gaussian elimination with 
//   
//     partial pivoting.   
//     Note that the equation  A'*X = B  may be solved by interchanging the 
//   
//     order of the arguments DU and DL.   
//     Arguments   
//     =========   
//     N       (input) INTEGER   
//             The order of the matrix A.  N >= 0.   
//     NRHS    (input) INTEGER   
//             The number of right hand sides, i.e., the number of columns   
//             of the matrix B.  NRHS >= 0.   
//     DL      (input/output) DOUBLE PRECISION array, dimension (N-1)   
//             On entry, DL must contain the (n-1) subdiagonal elements of   
//             A.   
//             On exit, DL is overwritten by the (n-2) elements of the   
//             second superdiagonal of the upper triangular matrix U from   
//             the LU factorization of A, in DL(1), ..., DL(n-2).   
//     D       (input/output) DOUBLE PRECISION array, dimension (N)   
//             On entry, D must contain the diagonal elements of A.   
//             On exit, D is overwritten by the n diagonal elements of U.   
//     DU      (input/output) DOUBLE PRECISION array, dimension (N-1)   
//             On entry, DU must contain the (n-1) superdiagonal elements   
//             of A.   
//             On exit, DU is overwritten by the (n-1) elements of the first 
//   
//             superdiagonal of U.   
//     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)   
//             On entry, the N-by-NRHS right hand side matrix B.   
//             On exit, if INFO = 0, the N-by-NRHS solution matrix X.   
//     LDB     (input) INTEGER   
//             The leading dimension of the array B.  LDB >= max(1,N).   
//     INFO    (output) INTEGER   
//             = 0:  successful exit   
//             < 0:  if INFO = -i, the i-th argument had an illegal value   
//             > 0:  if INFO = i, U(i,i) is exactly zero, and the solution   
//                   has not been computed.  The factorization has not been 
//   
//                   completed unless i = N.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgtsv(size(diag, 1),size(B, 2),subdiagwork,diagwork,superdiagwork,X,size(B, 1),info)           annotation(Library = "Lapack"); 
//         end dgtsv;
//         function dgtsv_vec "Solve real system of linear equations A*x=b with b vector and tridiagonal A"
//           extends Modelica.Icons.Function;
//           input Real superdiag[:];
//           input Real diag[size(superdiag, 1) + 1];
//           input Real subdiag[size(superdiag, 1)];
//           input Real b[size(diag, 1)];
//           output Real x[size(b, 1)] = b;
//           output Integer info;
//         protected 
//           Real superdiagwork[size(superdiag, 1)] = superdiag;
//           Real diagwork[size(diag, 1)] = diag;
//           Real subdiagwork[size(subdiag, 1)] = subdiag;
//           annotation(Documentation(info = "
// Same as function LAPACK.dgtsv, but right hand side is a vector and not a matrix.
// For details of the arguments, see documentation of dgtsv.
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgtsv(size(diag, 1),1,subdiagwork,diagwork,superdiagwork,x,size(b, 1),info)           annotation(Library = "Lapack"); 
//         end dgtsv_vec;
//         function dgbsv "Solve real system of linear equations A*X=B with a B matrix"
//           extends Modelica.Icons.Function;
//           input Integer n "Number of equations";
//           input Integer kLower "Number of lower bands";
//           input Integer kUpper "Number of upper bands";
//           input Real A[2 * kLower + kUpper + 1,n];
//           input Real B[n,:];
//           output Real X[n,size(B, 2)] = B;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Integer ipiv[n];
//           annotation(Documentation(info = "Lapack documentation:  
// Purpose
// =======
// DGBSV computes the solution to a real system of linear equations
// A * X = B, where A is a band matrix of order N with KL subdiagonals
// and KU superdiagonals, and X and B are N-by-NRHS matrices.
// The LU decomposition with partial pivoting and row interchanges is
// used to factor A as A = L * U, where L is a product of permutation
// and unit lower triangular matrices with KL subdiagonals, and U is
// upper triangular with KL+KU superdiagonals.  The factored form of A
// is then used to solve the system of equations A * X = B.
// Arguments
// =========
// N       (input) INTEGER
//         The number of linear equations, i.e., the order of the
//         matrix A.  N >= 0.
// KL      (input) INTEGER
//         The number of subdiagonals within the band of A.  KL >= 0.
// KU      (input) INTEGER
//         The number of superdiagonals within the band of A.  KU >= 0.
// NRHS    (input) INTEGER
//         The number of right hand sides, i.e., the number of columns
//         of the matrix B.  NRHS >= 0.
// AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
//         On entry, the matrix A in band storage, in rows KL+1 to
//         2*KL+KU+1; rows 1 to KL of the array need not be set.
//         The j-th column of A is stored in the j-th column of the
//         array AB as follows:
//         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
//         On exit, details of the factorization: U is stored as an
//         upper triangular band matrix with KL+KU superdiagonals in
//         rows 1 to KL+KU+1, and the multipliers used during the
//         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
//         See below for further details.
// LDAB    (input) INTEGER
//         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
// IPIV    (output) INTEGER array, dimension (N)
//         The pivot indices that define the permutation matrix P;
//         row i of the matrix was interchanged with row IPIV(i).
// B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//         On entry, the N-by-NRHS right hand side matrix B.
//         On exit, if INFO = 0, the N-by-NRHS solution matrix X.
// LDB     (input) INTEGER
//         The leading dimension of the array B.  LDB >= max(1,N).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
//               has been completed, but the factor U is exactly
//               singular, and the solution has not been computed.
// Further Details
// ===============
// The band storage scheme is illustrated by the following example, when
// M = N = 6, KL = 2, KU = 1:
// On entry:                       On exit:
//     *    *    *    +    +    +       *    *    *   u14  u25  u36
//     *    *    +    +    +    +       *    *   u13  u24  u35  u46
//     *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
//    a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
//    a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
//    a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
// Array elements marked * are not used by the routine; elements marked
// + need not be set on entry, but are required by the routine to store
// elements of U because of fill-in resulting from the row interchanges."), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgbsv(n,kLower,kUpper,size(B, 2),Awork,size(Awork, 1),ipiv,X,n,info)           annotation(Library = "Lapack"); 
//         end dgbsv;
//         function dgbsv_vec "Solve real system of linear equations A*x=b with a b vector"
//           extends Modelica.Icons.Function;
//           input Integer n "Number of equations";
//           input Integer kLower "Number of lower bands";
//           input Integer kUpper "Number of upper bands";
//           input Real A[2 * kLower + kUpper + 1,n];
//           input Real b[n];
//           output Real x[n] = b;
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Integer ipiv[n];
//           annotation(Documentation(info = "Lapack documentation:  
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgbsv(n,kLower,kUpper,1,Awork,size(Awork, 1),ipiv,x,n,info)           annotation(Library = "Lapack"); 
//         end dgbsv_vec;
//         function dgesvd "Determine singular value decomposition"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           output Real sigma[min(size(A, 1), size(A, 2))];
//           output Real U[size(A, 1),size(A, 1)] = zeros(size(A, 1), size(A, 1));
//           output Real VT[size(A, 2),size(A, 2)] = zeros(size(A, 2), size(A, 2));
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Integer lwork = 5 * size(A, 1) + 5 * size(A, 2);
//           Real work[lwork];
//           annotation(Documentation(info = "Lapack documentation:
//     Purpose   
//     =======   
//     DGESVD computes the singular value decomposition (SVD) of a real   
//     M-by-N matrix A, optionally computing the left and/or right singular 
//   
//     vectors. The SVD is written   
//          A = U * SIGMA * transpose(V)   
//     where SIGMA is an M-by-N matrix which is zero except for its   
//     min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and   
//     V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA   
//     are the singular values of A; they are real and non-negative, and   
//     are returned in descending order.  The first min(m,n) columns of   
//     U and V are the left and right singular vectors of A.   
//     Note that the routine returns V**T, not V.   
//     Arguments   
//     =========   
//     JOBU    (input) CHARACTER*1   
//             Specifies options for computing all or part of the matrix U: 
//   
//             = 'A':  all M columns of U are returned in array U:   
//             = 'S':  the first min(m,n) columns of U (the left singular   
//                     vectors) are returned in the array U;   
//             = 'O':  the first min(m,n) columns of U (the left singular   
//                     vectors) are overwritten on the array A;   
//             = 'N':  no columns of U (no left singular vectors) are   
//                     computed.   
//     JOBVT   (input) CHARACTER*1   
//             Specifies options for computing all or part of the matrix   
//             V**T:   
//             = 'A':  all N rows of V**T are returned in the array VT;   
//             = 'S':  the first min(m,n) rows of V**T (the right singular   
//                     vectors) are returned in the array VT;   
//             = 'O':  the first min(m,n) rows of V**T (the right singular   
//                     vectors) are overwritten on the array A;   
//             = 'N':  no rows of V**T (no right singular vectors) are   
//                     computed.   
//             JOBVT and JOBU cannot both be 'O'.   
//     M       (input) INTEGER   
//             The number of rows of the input matrix A.  M >= 0.   
//     N       (input) INTEGER   
//             The number of columns of the input matrix A.  N >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the M-by-N matrix A.   
//             On exit,   
//             if JOBU = 'O',  A is overwritten with the first min(m,n)   
//                             columns of U (the left singular vectors,   
//                             stored columnwise);   
//             if JOBVT = 'O', A is overwritten with the first min(m,n)   
//                             rows of V**T (the right singular vectors,   
//                             stored rowwise);   
//             if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A   
//                             are destroyed.   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,M).   
//     S       (output) DOUBLE PRECISION array, dimension (min(M,N))   
//             The singular values of A, sorted so that S(i) >= S(i+1).   
//     U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)   
//             (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.   
//             If JOBU = 'A', U contains the M-by-M orthogonal matrix U;   
//             if JOBU = 'S', U contains the first min(m,n) columns of U   
//             (the left singular vectors, stored columnwise);   
//             if JOBU = 'N' or 'O', U is not referenced.   
//     LDU     (input) INTEGER   
//             The leading dimension of the array U.  LDU >= 1; if   
//             JOBU = 'S' or 'A', LDU >= M.   
//     VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)   
//             If JOBVT = 'A', VT contains the N-by-N orthogonal matrix   
//             V**T;   
//             if JOBVT = 'S', VT contains the first min(m,n) rows of   
//             V**T (the right singular vectors, stored rowwise);   
//             if JOBVT = 'N' or 'O', VT is not referenced.   
//     LDVT    (input) INTEGER   
//             The leading dimension of the array VT.  LDVT >= 1; if   
//             JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).   
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) 
//   
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;   
//             if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged   
//             superdiagonal elements of an upper bidiagonal matrix B   
//             whose diagonal is in S (not necessarily sorted). B   
//             satisfies A = U * B * VT, so it has the same singular values 
//   
//             as A, and singular vectors related by U and VT.   
//     LWORK   (input) INTEGER   
//             The dimension of the array WORK. LWORK >= 1.   
//             LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).   
//             For good performance, LWORK should generally be larger.   
//     INFO    (output) INTEGER   
//             = 0:  successful exit.   
//             < 0:  if INFO = -i, the i-th argument had an illegal value.   
//             > 0:  if DBDSQR did not converge, INFO specifies how many   
//                   superdiagonals of an intermediate bidiagonal form B   
//                   did not converge to zero. See the description of WORK   
//                   above for details.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "Fortran 77" dgesvd("A","A",size(A, 1),size(A, 2),Awork,size(A, 1),sigma,U,size(A, 1),VT,size(A, 2),work,lwork,info)           annotation(Library = "Lapack"); 
//         end dgesvd;
//         function dgesvd_sigma "Determine singular values"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           output Real sigma[min(size(A, 1), size(A, 2))];
//           output Integer info;
//         protected 
//           Real Awork[size(A, 1),size(A, 2)] = A;
//           Real U[size(A, 1),size(A, 1)];
//           Real VT[size(A, 2),size(A, 2)];
//           Integer lwork = 5 * size(A, 1) + 5 * size(A, 2);
//           Real work[lwork];
//           annotation(Documentation(info = "Lapack documentation:
//     Purpose   
//     =======   
//     DGESVD computes the singular value decomposition (SVD) of a real   
//     M-by-N matrix A, optionally computing the left and/or right singular 
//   
//     vectors. The SVD is written   
//          A = U * SIGMA * transpose(V)   
//     where SIGMA is an M-by-N matrix which is zero except for its   
//     min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and   
//     V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA   
//     are the singular values of A; they are real and non-negative, and   
//     are returned in descending order.  The first min(m,n) columns of   
//     U and V are the left and right singular vectors of A.   
//     Note that the routine returns V**T, not V.   
//     Arguments   
//     =========   
//     JOBU    (input) CHARACTER*1   
//             Specifies options for computing all or part of the matrix U: 
//   
//             = 'A':  all M columns of U are returned in array U:   
//             = 'S':  the first min(m,n) columns of U (the left singular   
//                     vectors) are returned in the array U;   
//             = 'O':  the first min(m,n) columns of U (the left singular   
//                     vectors) are overwritten on the array A;   
//             = 'N':  no columns of U (no left singular vectors) are   
//                     computed.   
//     JOBVT   (input) CHARACTER*1   
//             Specifies options for computing all or part of the matrix   
//             V**T:   
//             = 'A':  all N rows of V**T are returned in the array VT;   
//             = 'S':  the first min(m,n) rows of V**T (the right singular   
//                     vectors) are returned in the array VT;   
//             = 'O':  the first min(m,n) rows of V**T (the right singular   
//                     vectors) are overwritten on the array A;   
//             = 'N':  no rows of V**T (no right singular vectors) are   
//                     computed.   
//             JOBVT and JOBU cannot both be 'O'.   
//     M       (input) INTEGER   
//             The number of rows of the input matrix A.  M >= 0.   
//     N       (input) INTEGER   
//             The number of columns of the input matrix A.  N >= 0.   
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
//             On entry, the M-by-N matrix A.   
//             On exit,   
//             if JOBU = 'O',  A is overwritten with the first min(m,n)   
//                             columns of U (the left singular vectors,   
//                             stored columnwise);   
//             if JOBVT = 'O', A is overwritten with the first min(m,n)   
//                             rows of V**T (the right singular vectors,   
//                             stored rowwise);   
//             if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A   
//                             are destroyed.   
//     LDA     (input) INTEGER   
//             The leading dimension of the array A.  LDA >= max(1,M).   
//     S       (output) DOUBLE PRECISION array, dimension (min(M,N))   
//             The singular values of A, sorted so that S(i) >= S(i+1).   
//     U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)   
//             (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.   
//             If JOBU = 'A', U contains the M-by-M orthogonal matrix U;   
//             if JOBU = 'S', U contains the first min(m,n) columns of U   
//             (the left singular vectors, stored columnwise);   
//             if JOBU = 'N' or 'O', U is not referenced.   
//     LDU     (input) INTEGER   
//             The leading dimension of the array U.  LDU >= 1; if   
//             JOBU = 'S' or 'A', LDU >= M.   
//     VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)   
//             If JOBVT = 'A', VT contains the N-by-N orthogonal matrix   
//             V**T;   
//             if JOBVT = 'S', VT contains the first min(m,n) rows of   
//             V**T (the right singular vectors, stored rowwise);   
//             if JOBVT = 'N' or 'O', VT is not referenced.   
//     LDVT    (input) INTEGER   
//             The leading dimension of the array VT.  LDVT >= 1; if   
//             JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).   
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) 
//   
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;   
//             if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged   
//             superdiagonal elements of an upper bidiagonal matrix B   
//             whose diagonal is in S (not necessarily sorted). B   
//             satisfies A = U * B * VT, so it has the same singular values 
//   
//             as A, and singular vectors related by U and VT.   
//     LWORK   (input) INTEGER   
//             The dimension of the array WORK. LWORK >= 1.   
//             LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).   
//             For good performance, LWORK should generally be larger.   
//     INFO    (output) INTEGER   
//             = 0:  successful exit.   
//             < 0:  if INFO = -i, the i-th argument had an illegal value.   
//             > 0:  if DBDSQR did not converge, INFO specifies how many   
//                   superdiagonals of an intermediate bidiagonal form B   
//                   did not converge to zero. See the description of WORK   
//                   above for details.   
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "Fortran 77" dgesvd("N","N",size(A, 1),size(A, 2),Awork,size(A, 1),sigma,U,size(A, 1),VT,size(A, 2),work,lwork,info)           annotation(Library = "Lapack"); 
//         end dgesvd_sigma;
//         function StringAllocate "Utility function to provide storage for characters"
//           extends Modelica.Icons.Function;
//           input Integer n;
//           output String s;
// 
//           external "C"           annotation(doNotDeclare);
//         end StringAllocate;
//         function dgetrf "Compute LU factorization of square or rectangular matrix A (A = P*L*U)"
//           extends Modelica.Icons.Function;
//           input Real A[:,:] "Square or rectangular matrix";
//           output Real LU[size(A, 1),size(A, 2)] = A;
//           output Integer pivots[min(size(A, 1), size(A, 2))] "Pivot vector";
//           output Integer info "Information";
//           annotation(Documentation(info = "Lapack documentation:
//   SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, M, N
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * )
//    ..
// Purpose
// =======
// DGETRF computes an LU factorization of a general M-by-N matrix A
// using partial pivoting with row interchanges.
// The factorization has the form
//    A = P * L * U
// where P is a permutation matrix, L is lower triangular with unit
// diagonal elements (lower trapezoidal if m > n), and U is upper
// triangular (upper trapezoidal if m < n).
// This is the right-looking Level 3 BLAS version of the algorithm.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix A.  M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix A.  N >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the M-by-N matrix to be factored.
//         On exit, the factors L and U from the factorization
//         A = P*L*U; the unit diagonal elements of L are not stored.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,M).
// IPIV    (output) INTEGER array, dimension (min(M,N))
//         The pivot indices; for 1 <= i <= min(M,N), row i of the
//         matrix was interchanged with row IPIV(i).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
//               has been completed, but the factor U is exactly
//               singular, and division by zero will occur if it is used
//               to solve a system of equations.
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
// 
//           external "FORTRAN 77" dgetrf(size(A, 1),size(A, 2),LU,size(A, 1),pivots,info)           annotation(Library = "Lapack"); 
//         end dgetrf;
//         function dgetrs_vec "Solves a system of linear equations with the LU decomposition from dgetrf(..)"
//           extends Modelica.Icons.Function;
//           input Real LU[:,size(LU, 1)] "LU factorization of dgetrf of a square matrix";
//           input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
//           input Real b[size(LU, 1)] "Right hand side vector b";
//           output Real x[size(b, 1)] = b;
//           annotation(Documentation(info = "Lapack documentation:
//   SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    CHARACTER          TRANS
//    INTEGER            INFO, LDA, LDB, N, NRHS
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
//    ..
// Purpose
// =======
// DGETRS solves a system of linear equations
//    A * X = B  or  A' * X = B
// with a general N-by-N matrix A using the LU factorization computed
// by DGETRF.
// Arguments
// =========
// TRANS   (input) CHARACTER*1
//         Specifies the form of the system of equations:
//         = 'N':  A * X = B  (No transpose)
//         = 'T':  A'* X = B  (Transpose)
//         = 'C':  A'* X = B  (Conjugate transpose = Transpose)
// N       (input) INTEGER
//         The order of the matrix A.  N >= 0.
// NRHS    (input) INTEGER
//         The number of right hand sides, i.e., the number of columns
//         of the matrix B.  NRHS >= 0.
// A       (input) DOUBLE PRECISION array, dimension (LDA,N)
//         The factors L and U from the factorization A = P*L*U
//         as computed by DGETRF.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,N).
// IPIV    (input) INTEGER array, dimension (N)
//         The pivot indices from DGETRF; for 1<=i<=N, row i of the
//         matrix was interchanged with row IPIV(i).
// B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//         On entry, the right hand side matrix B.
//         On exit, the solution matrix X.
// LDB     (input) INTEGER
//         The leading dimension of the array B.  LDB >= max(1,N).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         protected 
//           Real work[size(LU, 1),size(LU, 1)] = LU;
//           Integer info;
// 
//           external "FORTRAN 77" dgetrs("N",size(LU, 1),1,work,size(LU, 1),pivots,x,size(b, 1),info)           annotation(Library = "Lapack"); 
//         end dgetrs_vec;
//         function dgetri "Computes the inverse of a matrix using the LU factorization from dgetrf(..)"
//           extends Modelica.Icons.Function;
//           input Real LU[:,size(LU, 1)] "LU factorization of dgetrf of a square matrix";
//           input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
//           output Real inv[size(LU, 1),size(LU, 2)] = LU "Inverse of matrix P*L*U";
//           annotation(Documentation(info = "Lapack documentation:
//    SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, LWORK, N
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * ), WORK( LWORK )
//    ..
// Purpose
// =======
// DGETRI computes the inverse of a matrix using the LU factorization
// computed by DGETRF.
// This method inverts U and then computes inv(A) by solving the system
// inv(A)*L = inv(U) for inv(A).
// Arguments
// =========
// N       (input) INTEGER
//         The order of the matrix A.  N >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the factors L and U from the factorization
//         A = P*L*U as computed by DGETRF.
//         On exit, if INFO = 0, the inverse of the original matrix A.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,N).
// IPIV    (input) INTEGER array, dimension (N)
//         The pivot indices from DGETRF; for 1<=i<=N, row i of the
//         matrix was interchanged with row IPIV(i).
// WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
// LWORK   (input) INTEGER
//         The dimension of the array WORK.  LWORK >= max(1,N).
//         For optimal performance LWORK >= N*NB, where NB is
//         the optimal blocksize returned by ILAENV.
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
//               singular and its inverse could not be computed."), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         protected 
//           Integer lwork = min(10, size(LU, 1)) * size(LU, 1) "Length of work array";
//           Real work[lwork];
//           Integer info;
// 
//           external "FORTRAN 77" dgetri(size(LU, 1),inv,size(LU, 1),pivots,work,lwork,info)           annotation(Library = "Lapack"); 
//         end dgetri;
//         function dgeqpf "Compute QR factorization of square or rectangular matrix A with column pivoting (A(:,p) = Q*R)"
//           extends Modelica.Icons.Function;
//           input Real A[:,:] "Square or rectangular matrix";
//           output Real QR[size(A, 1),size(A, 2)] = A "QR factorization in packed format";
//           output Real tau[min(size(A, 1), size(A, 2))] "The scalar factors of the elementary reflectors of Q";
//           output Integer p[size(A, 2)] = zeros(size(A, 2)) "Pivot vector";
//           annotation(Documentation(info = "Lapack documentation:
//    SUBROUTINE DGEQPF( M, N, A, LDA, JPVT, TAU, WORK, INFO )
// -- LAPACK test routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, M, N
//    ..
//    .. Array Arguments ..
//    INTEGER            JPVT( * )
//    DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
//    ..
// Purpose
// =======
// DGEQPF computes a QR factorization with column pivoting of a
// real M-by-N matrix A: A*P = Q*R.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix A. M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix A. N >= 0
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the M-by-N matrix A.
//         On exit, the upper triangle of the array contains the
//         min(M,N)-by-N upper triangular matrix R; the elements
//         below the diagonal, together with the array TAU,
//         represent the orthogonal matrix Q as a product of
//         min(m,n) elementary reflectors.
// LDA     (input) INTEGER
//         The leading dimension of the array A. LDA >= max(1,M).
// JPVT    (input/output) INTEGER array, dimension (N)
//         On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
//         to the front of A*P (a leading column); if JPVT(i) = 0,
//         the i-th column of A is a free column.
//         On exit, if JPVT(i) = k, then the i-th column of A*P
//         was the k-th column of A.
// TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
//         The scalar factors of the elementary reflectors.
// WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
// Further Details
// ===============
// The matrix Q is represented as a product of elementary reflectors
//    Q = H(1) H(2) . . . H(n)
// Each H(i) has the form
//    H = I - tau * v * v'
// where tau is a real scalar, and v is a real vector with
// v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
// The matrix P is represented in jpvt as follows: If
//    jpvt(j) = i
// then the jth column of P is the ith canonical unit vector."), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         protected 
//           Integer info;
//           Integer ncol = size(A, 2) "Column dimension of A";
//           Real work[3 * ncol] "work array";
// 
//           external "FORTRAN 77" dgeqpf(size(A, 1),ncol,QR,size(A, 1),p,tau,work,info)           annotation(Library = "Lapack"); 
//         end dgeqpf;
//         function dorgqr "Generates a Real orthogonal matrix Q which is defined as the product of elementary reflectors as returned from dgeqpf"
//           extends Modelica.Icons.Function;
//           input Real QR[:,:] "QR from dgeqpf";
//           input Real tau[min(size(QR, 1), size(QR, 2))] "The scalar factors of the elementary reflectors of Q";
//           output Real Q[size(QR, 1),size(QR, 2)] = QR "Orthogonal matrix Q";
//           annotation(Documentation(info = "Lapack documentation:
//    SUBROUTINE DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, K, LDA, LWORK, M, N
//    ..
//    .. Array Arguments ..
//    DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( LWORK )
//    ..
// Purpose
// =======
// DORGQR generates an M-by-N real matrix Q with orthonormal columns,
// which is defined as the first N columns of a product of K elementary
// reflectors of order M
//       Q  =  H(1) H(2) . . . H(k)
// as returned by DGEQRF.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix Q. M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix Q. M >= N >= 0.
// K       (input) INTEGER
//         The number of elementary reflectors whose product defines the
//         matrix Q. N >= K >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the i-th column must contain the vector which
//         defines the elementary reflector H(i), for i = 1,2,...,k, as
//         returned by DGEQRF in the first k columns of its array
//         argument A.
//         On exit, the M-by-N matrix Q.
// LDA     (input) INTEGER
//         The first dimension of the array A. LDA >= max(1,M).
// TAU     (input) DOUBLE PRECISION array, dimension (K)
//         TAU(i) must contain the scalar factor of the elementary
//         reflector H(i), as returned by DGEQRF.
// WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
// LWORK   (input) INTEGER
//         The dimension of the array WORK. LWORK >= max(1,N).
//         For optimum performance LWORK >= N*NB, where NB is the
//         optimal blocksize.
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument has an illegal value
// "), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}})));
//         protected 
//           Integer info;
//           Integer lwork = min(10, size(QR, 2)) * size(QR, 2) "Length of work array";
//           Real work[lwork];
// 
//           external "FORTRAN 77" dorgqr(size(QR, 1),size(QR, 2),size(tau, 1),Q,size(Q, 1),tau,work,lwork,info)           annotation(Library = "Lapack"); 
//         end dorgqr;
//       end LAPACK;
//     end Matrices;
//     function sin "sine"
//       extends baseIcon1;
//       input SI.Angle u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{12,36},{84,84}}, textString = "sin", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,0},{ -68.7,34.2},{ -61.5,53.1},{ -55.1,66.4},{ -49.4,74.6},{ -43.8,79.1},{ -38.2,79.8},{ -32.6,76.6},{ -26.9,69.7},{ -21.3,59.4},{ -14.9,44.1},{ -6.83,21.2},{10.1, -30.8},{17.3, -50.2},{23.7, -64.2},{29.3, -73.1},{35, -78.4},{40.6, -80},{46.2, -77.6},{51.9, -71.5},{57.5, -61.9},{63.9, -47.2},{72, -24.8},{80,0}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -105,72},{ -85,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "2*pi", fontName = "Arial"),Text(visible = true, extent = {{ -105, -88},{ -85, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
// 
//       external "C" y = sin(u) ;
//     end sin;
//     function cos "cosine"
//       extends baseIcon1;
//       input SI.Angle u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80,80},{ -74.4,78.1},{ -68.7,72.3},{ -63.1,63},{ -56.7,48.7},{ -48.6,26.6},{ -29.3, -32.5},{ -22.1, -51.7},{ -15.7, -65.3},{ -10.1, -73.8},{ -4.42, -78.8},{1.21, -79.9},{6.83, -77.1},{12.5, -70.6},{18.1, -60.6},{24.5, -45.7},{32.6, -23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -36,34},{36,82}}, textString = "cos", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -105,72},{ -85,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -105, -88},{ -85, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "2*pi", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80,80},{ -74.4,78.1},{ -68.7,72.3},{ -63.1,63},{ -56.7,48.7},{ -48.6,26.6},{ -29.3, -32.5},{ -22.1, -51.7},{ -15.7, -65.3},{ -10.1, -73.8},{ -4.42, -78.8},{1.21, -79.9},{6.83, -77.1},{12.5, -70.6},{18.1, -60.6},{24.5, -45.7},{32.6, -23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},{75.2,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
// 
//       external "C" y = cos(u) ;
//     end cos;
//     function tan "tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
//       extends baseIcon2;
//       input SI.Angle u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -78.4, -68.4},{ -76.8, -59.7},{ -74.4, -50},{ -71.2, -40.9},{ -67.1, -33},{ -60.7, -24.8},{ -51.1, -17.2},{ -35.8, -9.98},{ -4.42, -1.07},{33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,47.4},{76,56.1},{77.6,63.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -90,24},{ -18,72}}, textString = "tan", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -37, -88},{ -17, -72}}, textString = "-5.8", fontName = "Arial"),Text(visible = true, extent = {{ -33,70},{ -13,86}}, textString = " 5.8", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "1.4", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -78.4, -68.4},{ -76.8, -59.7},{ -74.4, -50},{ -71.2, -40.9},{ -67.1, -33},{ -60.7, -24.8},{ -51.1, -17.2},{ -35.8, -9.98},{ -4.42, -1.07},{33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,47.4},{76,56.1},{77.6,63.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
// 
//       external "C" y = tan(u) ;
//     end tan;
//     function asin "inverse sine (-1 <= u <= 1)"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -72.8},{ -77.6, -67.5},{ -73.6, -59.4},{ -66.3, -49.8},{ -53.5, -37.3},{ -30.2, -19.7},{37.4,24.8},{57.5,40.8},{68.7,52.7},{75.2,62.2},{77.6,67.5},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -88,30},{ -16,78}}, textString = "asin", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -40, -88},{ -15, -72}}, textString = "-pi/2", fontName = "Arial"),Text(visible = true, extent = {{ -38,72},{ -13,88}}, textString = " pi/2", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "+1", fontName = "Arial"),Text(visible = true, extent = {{ -90,1},{ -70,21}}, textString = "-1", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -72.8},{ -77.6, -67.5},{ -73.6, -59.4},{ -66.3, -49.8},{ -53.5, -37.3},{ -30.2, -19.7},{37.4,24.8},{57.5,40.8},{68.7,52.7},{75.2,62.2},{77.6,67.5},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
// 
//       external "C" y = asin(u) ;
//     end asin;
//     function acos "inverse cosine (-1 <= u <= 1)"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -80},{68, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80},{68, -72},{68, -88},{90, -80}}),Line(visible = true, points = {{ -80,80},{ -79.2,72.8},{ -77.6,67.5},{ -73.6,59.4},{ -66.3,49.8},{ -53.5,37.3},{ -30.2,19.7},{37.4, -24.8},{57.5, -40.8},{68.7, -52.7},{75.2, -62.2},{77.6, -67.5},{80, -80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86, -62},{ -14, -14}}, textString = "acos", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -80},{84, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -80},{84, -74},{84, -86},{100, -80}}),Line(visible = true, points = {{ -80,80},{ -79.2,72.8},{ -77.6,67.5},{ -73.6,59.4},{ -66.3,49.8},{ -53.5,37.3},{ -30.2,19.7},{37.4, -24.8},{57.5, -40.8},{68.7, -52.7},{75.2, -62.2},{77.6, -67.5},{80, -80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -30,72},{ -5,88}}, textString = " pi", fontName = "Arial"),Text(visible = true, extent = {{ -94, -77},{ -74, -57}}, textString = "-1", fontName = "Arial"),Text(visible = true, extent = {{80, -65},{100, -45}}, textString = "+1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{90, -102},{110, -82}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"));
// 
//       external "C" y = acos(u) ;
//     end acos;
//     function atan "inverse tangent"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -52.7, -75.2},{ -37.4, -69.7},{ -26.9, -63},{ -19.7, -55.2},{ -14.1, -45.8},{ -10.1, -36.4},{ -6.03, -23.9},{ -1.21, -5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{69.5,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86,20},{ -14,68}}, textString = "atan", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -52.7, -75.2},{ -37.4, -69.7},{ -26.9, -63},{ -19.7, -55.2},{ -14.1, -45.8},{ -10.1, -36.4},{ -6.03, -23.9},{ -1.21, -5.06},{5.23,21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},{69.5,78.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -32,71},{ -12,91}}, textString = "1.4", fontName = "Arial"),Text(visible = true, extent = {{ -32, -91},{ -12, -71}}, textString = "-1.4", fontName = "Arial"),Text(visible = true, extent = {{73,10},{93,26}}, textString = " 5.8", fontName = "Arial"),Text(visible = true, extent = {{ -103,4},{ -83,20}}, textString = "-5.8", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"));
// 
//       external "C" y = atan(u) ;
//     end atan;
//     function atan2 "four quadrant inverse tangent"
//       extends baseIcon2;
//       input Real u1;
//       input Real u2;
//       output SI.Angle y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{0, -80},{8.93, -67.2},{17.1, -59.3},{27.3, -53.6},{42.1, -49.4},{69.9, -45.8},{80, -45.1}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80, -34.9},{ -46.1, -31.4},{ -29.4, -27.1},{ -18.3, -21.5},{ -10.3, -14.5},{ -2.03, -3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{62.1,33.5},{80,34.9}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80,45.1},{ -45.9,48.7},{ -29.1,52.9},{ -18.1,58.6},{ -10.2,65.8},{ -1.82,77.2},{0,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -90, -94},{ -18, -46}}, textString = "atan2", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{0, -80},{8.93, -67.2},{17.1, -59.3},{27.3, -53.6},{42.1, -49.4},{69.9, -45.8},{80, -45.1}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80, -34.9},{ -46.1, -31.4},{ -29.4, -27.1},{ -18.3, -21.5},{ -10.3, -14.5},{ -2.03, -3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{62.1,33.5},{80,34.9}}, smooth = Smooth.Bezier),Line(visible = true, points = {{ -80,45.1},{ -45.9,48.7},{ -29.1,52.9},{ -18.1,58.6},{ -10.2,65.8},{ -1.82,77.2},{0,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -30,70},{ -10,89}}, textString = "pi", fontName = "Arial"),Text(visible = true, extent = {{ -30, -88},{ -10, -69}}, textString = "-pi", fontName = "Arial"),Text(visible = true, extent = {{ -30,30},{ -10,49}}, textString = "pi/2", fontName = "Arial"),Line(visible = true, points = {{0,40},{ -8,40}}, color = {192,192,192}),Line(visible = true, points = {{0, -40},{ -8, -40}}, color = {192,192,192}),Text(visible = true, extent = {{ -30, -50},{ -10, -31}}, textString = "-pi/2", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<HTML>
// y = atan2(u1,u2) computes y such that tan(y) = u1/u2 and
// y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
// u1 is not zero.
// </HTML>
// "));
// 
//       external "C" y = atan2(u1,u2) ;
//     end atan2;
//     function sinh "hyperbolic sine"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -76, -65.4},{ -71.2, -51.4},{ -65.5, -38.8},{ -59.1, -28.1},{ -51.1, -18.7},{ -41.4, -11.4},{ -27.7, -5.5},{ -4.42, -0.653},{24.5,4.57},{39,10.1},{49.4,17.2},{57.5,25.9},{63.9,35.8},{69.5,47.4},{74.4,60.4},{78.4,73.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -88,32},{ -16,80}}, textString = "sinh", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -76, -65.4},{ -71.2, -51.4},{ -65.5, -38.8},{ -59.1, -28.1},{ -51.1, -18.7},{ -41.4, -11.4},{ -27.7, -5.5},{ -4.42, -0.653},{24.5,4.57},{39,10.1},{49.4,17.2},{57.5,25.9},{63.9,35.8},{69.5,47.4},{74.4,60.4},{78.4,73.8},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "27", fontName = "Arial"),Text(visible = true, extent = {{ -35, -88},{ -15, -72}}, textString = "-27", fontName = "Arial"),Text(visible = true, extent = {{70,5},{90,25}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -98,1},{ -78,21}}, textString = "-4", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"));
// 
//       external "C" y = sinh(u) ;
//     end sinh;
//     function cosh "hyperbolic cosine"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -86.083},{68, -86.083}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -86.083},{68, -78.083},{68, -94.083},{90, -86.083}}),Line(visible = true, points = {{ -80,80},{ -77.6,61.1},{ -74.4,39.3},{ -71.2,20.7},{ -67.1,1.29},{ -63.1, -14.6},{ -58.3, -29.8},{ -52.7, -43.5},{ -46.2, -55.1},{ -39, -64.3},{ -30.2, -71.7},{ -18.9, -77.1},{ -4.42, -79.9},{10.9, -79.1},{23.7, -75.2},{34.2, -68.7},{42.2, -60.6},{48.6, -51.2},{54.3, -40},{59.1, -27.5},{63.1, -14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{4,20},{66,66}}, textString = "cosh", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -86.083},{84, -86.083}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -86.083},{84, -80.083},{84, -92.083},{100, -86.083}}),Line(visible = true, points = {{ -80,80},{ -77.6,61.1},{ -74.4,39.3},{ -71.2,20.7},{ -67.1,1.29},{ -63.1, -14.6},{ -58.3, -29.8},{ -52.7, -43.5},{ -46.2, -55.1},{ -39, -64.3},{ -30.2, -71.7},{ -18.9, -77.1},{ -4.42, -79.9},{10.9, -79.1},{23.7, -75.2},{34.2, -68.7},{42.2, -60.6},{48.6, -51.2},{54.3, -40},{59.1, -27.5},{63.1, -14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "27", fontName = "Arial"),Text(visible = true, extent = {{76, -81},{96, -61}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -104, -83},{ -84, -63}}, textString = "-4", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{90, -108},{110, -88}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>
// "));
// 
//       external "C" y = cosh(u) ;
//     end cosh;
//     function tanh "hyperbolic tangent"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -47.8, -78.7},{ -35.8, -75.7},{ -27.7, -70.6},{ -22.1, -64.2},{ -17.3, -55.9},{ -12.5, -44.3},{ -7.64, -29.2},{ -1.21, -4.82},{6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},{45.4,78.4},{72,79.9},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -88,24},{ -16,72}}, textString = "tanh", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -47.8, -78.7},{ -35.8, -75.7},{ -27.7, -70.6},{ -22.1, -64.2},{ -17.3, -55.9},{ -12.5, -44.3},{ -7.64, -29.2},{ -1.21, -4.82},{6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},{45.4,78.4},{72,79.9},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{70,5},{90,25}}, textString = "4", fontName = "Arial"),Text(visible = true, extent = {{ -106,1},{ -86,21}}, textString = "-4", fontName = "Arial"),Text(visible = true, extent = {{ -29,72},{ -9,88}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{3, -88},{23, -72}}, textString = "-1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//    
// </html>"));
// 
//       external "C" y = tanh(u) ;
//     end tanh;
//     function exp "exponential, base e"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90, -80.3976},{68, -80.3976}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -80.3976},{68, -72.3976},{68, -88.3976},{90, -80.3976}}),Line(visible = true, points = {{ -80, -80},{ -31, -77.9},{ -6.03, -74},{10.9, -68.4},{23.7, -61},{34.2, -51.6},{43, -40.3},{50.3, -27.8},{56.7, -13.5},{62.3,2.23},{67.1,18.6},{72,38.2},{76,57.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -86,2},{ -14,50}}, textString = "exp", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -80.3976},{84, -80.3976}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100, -80.3976},{84, -74.3976},{84, -86.3976},{100, -80.3976}}),Line(visible = true, points = {{ -80, -80},{ -31, -77.9},{ -6.03, -74},{10.9, -68.4},{23.7, -61},{34.2, -51.6},{43, -40.3},{50.3, -27.8},{56.7, -13.5},{62.3,2.23},{67.1,18.6},{72,38.2},{76,57.6},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -31,72},{ -11,88}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -92, -103},{ -72, -83}}, textString = "-3", fontName = "Arial"),Text(visible = true, extent = {{70, -103},{90, -83}}, textString = "3", fontName = "Arial"),Text(visible = true, extent = {{ -18, -73},{2, -53}}, textString = "1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{96, -102},{116, -82}}, textString = "u", fontName = "Arial")}));
// 
//       external "C" y = exp(u) ;
//     end exp;
//     function log "natural (base e) logarithm (u shall be > 0)"
//       extends baseIcon1;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -6, -72},{66, -24}}, textString = "log", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -80, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{ -105,72},{ -85,88}}, textString = "3", fontName = "Arial"),Text(visible = true, extent = {{ -109, -88},{ -89, -72}}, textString = "-3", fontName = "Arial"),Text(visible = true, extent = {{70, -23},{90, -3}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -78, -21},{ -58, -1}}, textString = "1", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//     
// </html>"));
// 
//       external "C" y = log(u) ;
//     end log;
//     function log10 "base 10 logarithm (u shall be > 0)"
//       extends baseIcon1;
//       input Real u;
//       output Real y;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{68,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90,0},{68,8},{68, -8},{90,0}}),Line(visible = true, points = {{ -79.8, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {192,192,192}, extent = {{ -30, -70},{60, -22}}, textString = "log10", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{84,0}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{100,0},{84,6},{84, -6},{100,0}}),Line(visible = true, points = {{ -79.8, -80},{ -79.2, -50.6},{ -78.4, -37},{ -77.6, -28},{ -76.8, -21.3},{ -75.2, -11.4},{ -72.8, -1.31},{ -69.5,8.08},{ -64.7,17.9},{ -57.5,28},{ -47,38.1},{ -31.8,48.1},{ -10.1,58},{22.1,68},{68.7,78.1},{80,80}}, smooth = Smooth.Bezier),Text(visible = true, extent = {{70, -23},{90, -3}}, textString = "20", fontName = "Arial"),Text(visible = true, extent = {{ -78, -21},{ -58, -1}}, textString = "1", fontName = "Arial"),Text(visible = true, extent = {{ -109,72},{ -89,88}}, textString = " 1.3", fontName = "Arial"),Text(visible = true, extent = {{ -109, -88},{ -89, -72}}, textString = "-1.3", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{92, -22},{112, -2}}, textString = "u", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"));
// 
//       external "C" y = log10(u) ;
//     end log10;
//     partial function baseIcon1 "Basic icon for mathematical function with y-axis on left side"
//       annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,80},{ -88,80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -80},{ -88, -80}}, color = {192,192,192}),Line(visible = true, points = {{ -80, -90},{ -80,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -75,90},{ -55,110}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,100},{ -86,84},{ -74,84},{ -80,100}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -80, -80},{ -80,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}));
//     end baseIcon1;
//     partial function baseIcon2 "Basic icon for mathematical function with y-axis in middle"
//       annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0,80},{ -8,80}}, color = {192,192,192}),Line(visible = true, points = {{0, -80},{ -8, -80}}, color = {192,192,192}),Line(visible = true, points = {{0, -90},{0,84}}, color = {192,192,192}),Text(visible = true, fillColor = {160,160,160}, extent = {{5,90},{25,110}}, textString = "y", fontName = "Arial"),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,100},{ -6,84},{6,84},{0,100}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{0, -80},{0,68}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,90},{ -8,68},{8,68},{0,90}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial")}));
//     end baseIcon2;
//     function tempInterpol1 "temporary routine for linear interpolation (will be removed)"
//       extends Modelica.Icons.Function;
//       input Real u "input value (first column of table)";
//       input Real table[:,:] "table to be interpolated";
//       input Integer icol "column of table to be interpolated";
//       output Real y "interpolated input value (icol column of table)";
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     protected 
//       Integer i;
//       Integer n "number of rows of table";
//       Real u1;
//       Real u2;
//       Real y1;
//       Real y2;
//     algorithm 
//       n:=size(table, 1);
//       if n <= 1 then 
//             y:=table[1,icol];
// 
//       else       if u <= table[1,1] then 
//             i:=1;
// 
//       else       i:=2;
//       while (i < n and u >= table[i,1]) loop
//               i:=i + 1;
// 
//       end while;
//       i:=i - 1;
// 
//       end if;
//       u1:=table[i,1];
//       u2:=table[i + 1,1];
//       y1:=table[i,icol];
//       y2:=table[i + 1,icol];
//       assert(u2 > u1, "Table index must be increasing");
//       y:=y1 + ((y2 - y1) * (u - u1)) / (u2 - u1);
// 
//       end if;
//       annotation(Documentation(info = "<html>
//   
// </html>"));
//     end tempInterpol1;
//     function tempInterpol2 "temporary routine for vectorized linear interpolation (will be removed)"
//       extends Modelica.Icons.Function;
//       input Real u "input value (first column of table)";
//       input Real table[:,:] "table to be interpolated";
//       input Integer icol[:] "column(s) of table to be interpolated";
//       output Real y[1,size(icol, 1)] "interpolated input value(s) (column(s) icol of table)";
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     protected 
//       Integer i;
//       Integer n "number of rows of table";
//       Real u1;
//       Real u2;
//       Real y1[1,size(icol, 1)];
//       Real y2[1,size(icol, 1)];
//     algorithm 
//       n:=size(table, 1);
//       if n <= 1 then 
//             y:=transpose([table[1,icol]]);
// 
//       else       if u <= table[1,1] then 
//             i:=1;
// 
//       else       i:=2;
//       while (i < n and u >= table[i,1]) loop
//               i:=i + 1;
// 
//       end while;
//       i:=i - 1;
// 
//       end if;
//       u1:=table[i,1];
//       u2:=table[i + 1,1];
//       y1:=transpose([table[i,icol]]);
//       y2:=transpose([table[i + 1,icol]]);
//       assert(u2 > u1, "Table index must be increasing");
//       y:=y1 + ((y2 - y1) * (u - u1)) / (u2 - u1);
// 
//       end if;
//       annotation(Documentation(info = "<html>
//   
// </html>"));
//     end tempInterpol2;
//   end Math;
//   package Mechanics "Library to model 1-dim. and 3-dim. mechanical systems (multi-body, rotational, translational)"
//     extends Modelica.Icons.Library2;
//     annotation(preferedView = "info", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -5, -70},{45, -40}}),Ellipse(visible = true, extent = {{ -90, -60},{ -80, -50}}),Line(visible = true, points = {{ -85, -55},{ -60, -21}}, thickness = 0.5),Ellipse(visible = true, extent = {{ -65, -26},{ -55, -16}}),Line(visible = true, points = {{ -60, -21},{9, -55}}, thickness = 0.5),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{4, -60},{14, -50}}),Line(visible = true, points = {{ -10, -34},{72, -34},{72, -76},{ -10, -76}})}), Documentation(info = "<HTML>
// <p>
// This package contains components to model the movement
// of 1-dim. rotational, 1-dim. translational, and
// 3-dim. <b>mechanical systems</b>.
// </p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 23, 2004</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        included the Mechanics.MultiBody library 1.0 and adapted it to the new
//        Blocks connectors.</li>
// <li><i>Oct. 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Bearing torque computation added to package <b>Rotational</b>.</li>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New components and examples in package <b>Rotational</b>.</li>
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Changes according to the Twente meeting introduced. Especially,
//        package Rotational1D renamed to Rotational and package
//        Translational1D renamed to Translational. For the particular
//        changes in these packages, see the corresponding package
//        release notes.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version for 1-dimensional rotational mechanical
//        systems based on an existing Dymola library of Martin Otter and
//        Hilding Elmqvist.</li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package Rotational "Library to model 1-dimensional, rotational mechanical systems"
//       package UsersGuide "Users Guide"
//         annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Users Guide of package Rotational</font></h3>
// <p>
// Library <b>Rotational</b> is a <b>free</b> Modelica package providing
// 1-dimensional, rotational mechanical components to model in a convenient way
// drive trains with frictional losses.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         package Overview "Overview"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Overview</font></h3>
//  
// <p>
// This package contains components to model <b>1-dimensional rotational
// mechanical</b> systems, including different types of gearboxes,
// shafts with inertia, external torques, spring/damper elements,
// frictional elements, backlash, elements to measure angle, angular velocity,
// angular acceleration and the cut-torque of a flange. In sublibrary
// <b>Examples</b> several examples are present to demonstrate the usage of
// the elements. Just open the corresponding example model and simulate
// the model according to the provided description.
// </p>
// <p>
// A unique feature of this library is the <b>component-oriented</b>
// modeling of <b>Coulomb friction</b> elements, such as friction in bearings,
// clutches, brakes, and gear efficiency. Even (dynamically) coupled
// friction elements, e.g., as in automatic gearboxes, can be handeled
// <b>without</b> introducing stiffness which leads to fast simulations.
// The underlying theory is new and is based on the solution of mixed
// continuous/discrete systems of equations, i.e., equations where the
// <b>unknowns</b> are of type <b>Real</b>, <b>Integer</b> or <b>Boolean</b>.
// Provided appropriate numerical algorithms for the solution of such types of
// systems are available in the simulation tool, the simulation of
// (dynamically) coupled friction elements of this library is
// <b>efficient</b> and <b>reliable</b>.
// </p>
// <p><IMG SRC=\"../Images/drive1.png\" ALT=\"drive1\"></p>
// <p>
// A simple example of the usage of this library is given in the
// figure above. This drive consists of a shaft with inertia J1=0.2 which
// is connected via an ideal gearbox with gear ratio=5 to a second shaft
// with inertia J2=5. The left shaft is driven via an external,
// sinusoidal torque.
// The <b>filled</b> and <b>non-filled grey squares</b> at the left and
// right side of a component represent <b>mechanical flanges</b>.
// Drawing a line between such squares means that the corresponding
// flanges are <b>rigidly attached</b> to each other.
// By convention in this library, the connector characterized as a
// <b>filled</b> grey square is called <b>flange_a</b> and placed at the
// left side of the component in the \"design view\" and the connector
// characterized as a <b>non-filled</b> grey square is called <b>flange_b</b>
// and placed at the right side of the component in the \"design view\".
// The two connectors are completely <b>identical</b>, with the only
// exception that the graphical layout is a little bit different in order
// to distinguish them for easier access of the connector variables.
// For example, <tt>J1.flange_a.tau</tt> is the cut-torque in the connector
// <tt>flange_a</tt> of component <tt>J1</tt>.
// </p>
// <p>
// The components of this
// library can be <b>connected</b> together in an <b>arbitrary</b> way. E.g., it is
// possible to connect two springs or two shafts with inertia directly
// together, see figure below.
// </p>
// <p><IMG SRC=\"../Images/driveConnections.png\" ALT=\"driveConnections\"></p>
//  
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Overview;
//         package FlangeConnectors "Flange Connectors"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Flange connectors</font></h3>
//  
// <p>
// A flange is described by the connector class
// Interfaces.<b>Flange_a</b>
// or Interfaces.<b>Flange_b</b>. As already noted, the two connector
// classes are completely identical. There is only a difference in the icons,
// in order to easier identify a flange variable in a diagram.
// Both connector classes contain the following variables:
// </p>
// <pre>
//    SIunits.Angle       phi  \"absolute rotation angle of flange\";
//    <b>flow</b> SIunits.Torque tau  \"cut-torque in the flange\";
// </pre>
// <p>
// If needed, the angular velocity <tt>w</tt> and the
// angular acceleration <tt>a</tt> of a flange connector can be
// determined by differentiation of the flange angle <tt>phi</tt>:
// </p>
// <pre>
//      w = <b>der</b>(phi);    a = <b>der</b>(w);
// </pre>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end FlangeConnectors;
//         package SupportTorques "Support Torques"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Support Torques</font></h3>
//  
// <p>The following figure shows examples of components equipped with
// a bearing flange (framed flange in the lower center), which can be used
// to fix components on the ground or on other rotating elements or to combine
// them with force elements. If the bearing flange is not connected, the
// components are assumed to be mounted on the ground. Otherwise, the bearing
// connector offers the possibility to consider, e.g., gearboxes mounted on
// the ground via spring-damper-systems (cf. example <tt>ElasticBearing</tt>). Independently, these components
// provide a variable <tt>tau_support</tt> stating the support torque exerted
// on the bearing.</p>
// <p><IMG SRC=\"../Images/bearing.png\" ALT=\"bearing\"></p>
// <p>In general, it is not necessary to connect the bearing flange
// with a fixation, i.e., the two implementations in the following figure give
// identical results.</p>
// <p><IMG SRC=\"../Images/bearing2.png\" ALT=\"bearing2\"></p>
//  
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end SupportTorques;
//         package SignConventions "Sign Conventions"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Sign Conventions</font></h3>
//  
// <p>
// The variables of a component of this library can be accessed in the
// usual way. However, since most of these variables are basically elements
// of <b>vectors</b>, i.e., have a direction, the question arises how the
// signs of variables shall be interpreted. The basic idea is explained
// at hand of the following figure:
// </p>
// <p><IMG SRC=\"../Images/drive2.png\" ALT=\"drive2\"></p>
// <p>
// In the figure, three identical drive trains are shown. The only
// difference is that the gear of the middle drive train and the
// gear as well as the right inertia of the lower drive train
// are horizontally flipped with regards to the upper drive train.
// The signs of variables are now interpreted in the following way:
// Due to the 1-dimensional nature of the model, all components are
// basically connected together along one line (more complicated
// cases are discussed below). First, one has to define
// a <b>positive</b> direction of this line, called <b>axis of rotation</b>.
// In the top part of the figure this is characterized by an arrow
// defined as <tt>axis of rotation</tt>. The simple rule is now:
// If a variable of a component is positive and can be interpreted as
// the element of a vector (e.g. torque or angular velocity vector), the
// corresponding vector is directed into the positive direction
// of the axis of rotation. In the following figure, the right-most
// inertias of the figure above are displayed with the positive
// vector direction displayed according to this rule:
// </p>
// <p><IMG SRC=\"../Images/drive3.png\" ALT=\"drive3\"></p>
// <p>
// The cut-torques <tt>J2.flange_a.tau, J4.flange_a.tau, J6.flange_b.tau</tt>
// of the right inertias are all identical and are directed into the
// direction of rotation if the values are positive. Similiarily,
// the angular velocities <tt>J2.w, J4.w, J6.w</tt> of the right inertias
// are all identical and are also directed into the
// direction of rotation if the values are positive. Some special
// cases are shown in the next figure:
// </p>
// <p><IMG SRC=\"../Images/drive4.png\" ALT=\"drive4\"></p>
// <p>
// In the upper part of the figure, two variants of the connection of an
// external torque and an inertia are shown. In both cases, a positive
// signal input into the torque component accelerates the inertias
// <tt>inertia1, inertia2</tt> into the positive axis of rotation,
// i.e., the angular accelerations <tt>inertia1.a, inertia2.a</tt>
// are positive and are directed along the \"axis of rotation\" arrow.
// In the lower part of the figure the connection of inertias with
// a planetary gear is shown. Note, that the three flanges of the
// planetary gearbox are located along the axis of rotation and that
// the axis direction determines the positive rotation along these
// flanges. As a result, the positive rotation for <tt>inertia4, inertia6</tt>
// is as indicated with the additional grey arrows.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end SignConventions;
//         package UserDefinedComponents "User Defined Components"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>User Defined Components</font></h3>
// <p>
// In this section some hints are given to define your own
// 1-dimensional rotational components which are compatible with the
// elements of this package.
// It is convenient to define a new
// component by inheritance from one of the following base classes,
// which are defined in sublibrary Interfaces:
// </p>
// <table BORDER=1 CELLSPACING=0 CELLPADDING=2>
// <tr><th>Name</th><th>Description</th></tr>
// <tr><td><tt><b>Rigid</b></tt></td><td>Rigid connection of two rotational 1D flanges (used for elements with inertia).</td></tr>
// <tr><td><tt><b>Compliant</b></tt></td><td>Compliant connection of two rotational 1D flanges (used for force laws such as a spring or a damper).</td></tr>
// <tr><td><tt><b>TwoFlanges</b></tt></td><td>General connection of two rotational 1D flanges (used for gearboxes).</td></tr>
// <tr><td><tt><b>AbsoluteSensor</b></tt></td><td>Measure absolute flange variables.</td></tr>
// <tr><td><tt><b>RelativeSensor</b></tt></td><td>Measure relative flange variables.</td></tr>
// </table>
// <p>
// The difference between these base classes are the auxiliary
// variables defined in the model and the relations between
// the flange variables already defined in the base class.
// For example, in model <b>Rigid</b> the flanges flange_a and
// flange_b are rigidly connected, i.e., flange_a.phi = flange_b.phi,
// whereas in model <b>Compliant</b> the cut-torques are the
// same, i.e., flange_a.tau + flange_b.tau = 0.
// </p>
// <p>
// The equations of a mechanical component are vector equations, i.e.,
// they need to be expressed in a common coordinate system.
// Therefore, for a component a <b>local axis of rotation</b> has to be
// defined. All vector quantities, such as cut-torques or angular
// velocities have to be expressed according to this definition.
// Examples for such a definition are given in the following figure
// for an inertia component and a planetary gearbox:
// </p>
// <p><IMG SRC=\"../Images/driveAxis.png\" ALT=\"driveAxis\"></p>
// <p>
// As can be seen, all vectors are directed into the direction
// of the rotation axis. The angles in the flanges are defined
// correspondingly. For example, the angle <tt>sun.phi</tt> in the
// flange of the sun wheel of the planetary gearbox is positive,
// if rotated in mathematical positive direction (= counter clock
// wise) along the axis of rotation.
// </p>
// <p>
// On first view, one may assume that the selected local
// coordinate system has an influence on the usage of the
// component. But this is not the case, as shown in the next figure:
// </p>
// <p><IMG SRC=\"../Images/inertias.png\" ALT=\"inertias\"></p>
// <p>
// In the figure the <b>local</b> axes of rotation of the components
// are shown. The connection of two inertias in the left and in the
// right part of the figure are completely equivalent, i.e., the right
// part is just a different drawing of the left part. This is due to the
// fact, that by a connection, the two local coordinate systems are
// made identical and the (automatically) generated connection equations
// (= angles are identical, cut-torques sum-up to zero) are also
// expressed in this common coordinate system. Therefore, even if in
// the left figure it seems to be that the angular velocity vector of
// <tt>J2</tt> goes from right to left, in reality it goes from
// left to right as shown in the right part of the figure, where the
// local coordinate systems are drawn such that they are aligned.
// Note, that the simple rule stated in section 4 (Sign conventions)
// also determines that
// the angular velocity of <tt>J2</tt> in the left part of the
// figure is directed from left to right.
// </p>
// <p>
// To summarize, the local coordinate system selected for a component
// is just necessary, in order that the equations of this component
// are expressed correctly. The selection of the coordinate system
// is arbitrary and has no influence on the usage of the component.
// Especially, the actual direction of, e.g., a cut-torque is most
// easily determined by the rule of section 4. A more strict determination
// by aligning coordinate systems and then using the vector direction
// of the local coordinate systems, often requires a re-drawing of the
// diagram and is therefore less convenient to use.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end UserDefinedComponents;
//         package RequirementsForSimulationTool "Requirements for Simulation Tools"
//           annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Requirements for Simulation Tools</font></h3>
//  
// <p>
// This library is designed in a fully object oriented way in order that
// components can be connected together in every meaningful combination
// (e.g. direct connection of two springs or two inertias).
// As a consequence, most models lead to a system of
// differential-algebraic equations of <b>index 3</b> (= constraint
// equations have to be differentiated twice in order to arrive at
// a state space representation) and the Modelica translator or
// the simulator has to cope with this system representation.
// According to our present knowledge, this requires that the
// Modelica translator is able to symbolically differentiate equations
// (otherwise it is e.g. not possible to provide consistent initial
// conditions; even if consistent initial conditions are present, most
// numerical DAE integrators can cope at most with index 2 DAEs).
// </p>
// </p>
// The elements of this library can be connected together in an
// arbitrary way. However, difficulties may occur, if the elements which can <b>lock</b> the
// <b>relative motion</b> between two flanges are connected <b>rigidly</b>
// together such that essentially the <b>same relative motion</b> can be locked.
// The reason is
// that the cut-torque in the locked phase is not uniquely defined if the
// elements are locked at the same time instant (i.e., there does not exist a
// unique solution) and some simulation systems may not be
// able to handle this situation, since this leads to a singularity during
// simulation. Currently, this type of problem can occur with the
// Coulomb friction elements <b>BearingFriction, Clutch, Brake, LossyGear</b> when
// the elements become stuck:
// </p>
// <p><IMG SRC=\"../Images/driveConnections2.png\" ALT=\"driveConnections2\"></p>
// <p>
// In the figure above two typical situations are shown: In the upper part of
// the figure, the series connection of rigidly attached BearingFriction and
// Clutch components are shown. This does not hurt, because the BearingFriction
// element can lock the relative motion between the element and the housing,
// whereas the clutch element can lock the relative motion between the two
// connected flanges. Contrary, the drive train in the lower part of the figure
// may rise to simulation problems, because the BearingFriction element
// and the Brake element can lock the relative motion between a flange and
// the housing and these flanges are rigidly connected together, i.e.,
// essentially the same relative motion can be locked. These difficulties
// may be solved by either introducing a compliance between these flanges
// or by combining the BearingFriction and Brake element into
// one component and resolving the ambiguity of the frictional torque in the
// stuck mode. A tool may handle this situation also <b>automatically</b>,
// by picking one solution of the infinitely many, e.g., the one where
// the difference to the value of the previous time instant is as small
// as possible.
// </p>
//  
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end RequirementsForSimulationTool;
//         class ReleaseNotes "Release notes"
//           annotation(Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Release notes</font></h3>
//  
// <ul>
// <li><i>December 12, 2005</i> 
//     by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//     Package documentation split into several parts and provided
//     as Users Guide.</li>
//  
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Bearing flanges added for mounted components and support torque computation implemented.<br>
//        New component <tt>Torque2</tt> and new example <tt>ElasticBearing</tt>.
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New components <b>LossyGear</b> (with corresponding examples) and <b>Gear2</b>.<br>
//        Interface <b>FrictionBase</b> adapted to new initialization.</li>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New elements:<br><!-- silly construction follows as Dymola not able to handle nested lists -->
//        <tt>IdealGearR2T&nbsp;&nbsp;&nbsp;</tt> Ideal gear transforming rotational in translational motion<br>
//        <tt>Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> Forced movement of a flange with a reference angle given as input signal<br>
//        <tt>RelativeStates&nbsp;</tt> Definition of relative state variables<br>
//        Icon of Rotational.Torque changed.
//        Elements Acceleration, Torque, Fixed, Sensors ordered according
//        to the Translational library.</li>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Improved documentation and improved graphical layout of the diagram level.
//        Changes according to the Twente meeting introduced. Especially:
//        Alias names, instead of extends. Model Shaft renamed to Inertia.
//        Torque1D renamed to Torque.
//        AccMotion renamed to Accelerate. LockedL, LockedR replaced by Fixed.
//        SpeedSensor splitted into AngleSensor and
//        SpeedSensor. RelSpeedSensor splitted into RelAngleSensor and
//        RelSpeedSensor. Initialization of friction elements improved.
//        Flanges renamed to flange_a, flange_b. MoveAngle renamed to
//        KinematicPTP, vectorized and moved to Blocks.Sources.<br>
//        Advice given from P. Beater, H. Elmqvist, S.E. Mattsson, H. Olsson
//        is appreciated.</li>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Documentation and icons improved. Appropriate initial conditions
//        introduced as start values in the demo models. Bearing model
//        replaced by FixedRight and FixedLeft models; sensor elements replaced by
//        TorqueSensor, SpeedSensor, AccSensor; new sensor elements
//        RelSpeedSensor, RelAccSensor to measure relative kinematic quantitites.
//        New elements GearEfficiency and Gear.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version based on an existing Dymola library
//        of Martin Otter and Hilding Elmqvist.</li>
// </ul>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end ReleaseNotes;
//         class Contact "Contact"
//           annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// <dl>
// <dt><b>Main Authors:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
//     <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>
//     <br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br> 
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A>,
//            <A HREF=\"mailto:Christian.Schweiger@dlr.de\">Christian.Schweiger@dlr.de</A><br>
// </dl>
//  
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Contact;
//       end UsersGuide;
//       package Examples "Demonstration examples of the components of this package"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains example models to demonstrate the usage of the
// Modelica.Mechanics.Rotational package. Open the models and
// simulate them according to the provided description in the models.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         encapsulated model First "First example: simple drive train"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter Real amplitude = 10;
//           parameter SI.Frequency freqHz = 5;
//           parameter SI.Inertia Jmotor(min = 0) = 0.1;
//           parameter SI.Inertia Jload(min = 0) = 2;
//           parameter Real ratio = 10;
//           parameter Real damping = 10;
//           annotation(Documentation(info = "<html>
// <p>The drive train consists of a motor inertia which is driven by
// a sine-wave motor torque. Via a gearbox the rotational energy is
// transmitted to a load inertia. Elasticity in the gearbox is modeled
// by a spring element. A linear damper is used to model the
// damping in the gearbox bearing.</p>
// <p>Note, that a force component (like the damper of this example)
// which is acting between a shaft and the housing has to be fixed
// in the housing on one side via component Fixed.</p>
// <p>Simulate for 1 second and plot the following variables:<br>
//    angular velocities of inertias inertia2 and 3: inertia2.w, inertia3.w</p>
//  
// </HTML>"), experiment(StopTime = 1), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Rotational.Fixed fixed annotation(Placement(visible = true, transformation(origin = {46, -52}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Torque torque annotation(Placement(visible = true, transformation(origin = { -62,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Inertia inertia1(J = Jmotor) annotation(Placement(visible = true, transformation(origin = { -32,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.IdealGear idealGear(ratio = ratio) annotation(Placement(visible = true, transformation(origin = { -2,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Inertia inertia2(J = 2, phi(start = 0), w(start = 0)) annotation(Placement(visible = true, transformation(origin = {28,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Spring spring(c = 10000.0) annotation(Placement(visible = true, transformation(origin = {62,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Inertia inertia3(J = Jload, phi(start = 0), w(start = 0)) annotation(Placement(visible = true, transformation(origin = {92,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Sources.Sine sine(amplitude = amplitude, freqHz = freqHz) annotation(Placement(visible = true, transformation(origin = { -92,0}, extent = {{ -8, -8},{8,8}}, rotation = 0)));
//           Rotational.Damper damper(d = damping) annotation(Placement(visible = true, transformation(origin = {46, -28}, extent = {{ -8, -8},{8,8}}, rotation =  -90)));
// 
//         equation 
//           connect(sine.y,torque.tau) annotation(Line(visible = true, points = {{ -83.2,0},{ -71.6,0}}, color = {0,0,191}));
//           connect(spring.flange_b,inertia3.flange_a) annotation(Line(visible = true, points = {{70,0},{84,0}}));
//           connect(inertia2.flange_b,spring.flange_a) annotation(Line(visible = true, points = {{36,0},{54,0}}));
//           connect(idealGear.flange_b,inertia2.flange_a) annotation(Line(visible = true, points = {{6,0},{20,0}}));
//           connect(inertia1.flange_b,idealGear.flange_a) annotation(Line(visible = true, points = {{ -24,0},{ -10,0}}));
//           connect(torque.flange_b,inertia1.flange_a) annotation(Line(visible = true, points = {{ -54,0},{ -40,0}}));
//           connect(damper.flange_a,inertia2.flange_b) annotation(Line(visible = true, points = {{46, -20},{46,0},{36,0}}));
//           connect(damper.flange_b,fixed.flange_b) annotation(Line(visible = true, points = {{46, -36},{46, -52}}));
//         end First;
//         encapsulated model Friction "Drive train with clutch and brake"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Blocks.Math;
//           import Modelica.Mechanics.Rotational;
//           import Modelica.Constants.pi;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter SI.Time startTime = 0.5 "Start time of step";
//           output SI.Torque tMotor "driving torque of inertia3";
//           output SI.Torque tClutch "friction torque of clutch";
//           output SI.Torque tBrake "friction torque of brake";
//           output SI.Torque tSpring "spring torque";
//           annotation(Documentation(info = "<html>
// <p>This drive train contains a frictional <b>clutch</b> and a <b>brake</b>.
// Simulate the system for 1 second using the following initial
// values (defined already in the model):</p>
// <pre>   inertia1.w =  90 (or brake.w)
//    inertia2.w =  90
//    inertia3.w = 100
// </pre>
// <p>Plot the output signals</p>
// <pre>   tMotor      Torque of motor
//    tClutch     Torque in clutch
//    tBrake      Torque in brake
//    tSpring     Torque in spring
// </pre>
// <p>as well as the absolute angular velocities of the three inertia components
// (inertia1.w, inertia2.w, inertia3.w).</p>
//  
// </HTML>"), experiment(StopTime = 1), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Rotational.Torque torque annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia inertia3(J = 1, phi(start = 0), w(start = 100)) annotation(Placement(visible = true, transformation(origin = { -20,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Clutch clutch(fn_max = 160) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia inertia2(J = 0.05, phi(start = 0), w(start = 90)) annotation(Placement(visible = true, transformation(origin = {20,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.SpringDamper spring(c = 160, d = 1) annotation(Placement(visible = true, transformation(origin = {40,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia inertia1(J = 1, phi(start = 0), w(start = 90)) annotation(Placement(visible = true, transformation(origin = {80,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Brake brake(fn_max = 1600) annotation(Placement(visible = true, transformation(origin = {60,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Sources.Constant const(k = 1) annotation(Placement(visible = true, transformation(origin = {0,25}, extent = {{ -5, -5},{5,5}}, rotation =  -90)));
//           Sources.Step step(startTime = startTime) annotation(Placement(visible = true, transformation(origin = {60,25}, extent = {{ -5, -5},{5,5}}, rotation =  -90)));
//           Sources.Step step2(height =  -1, offset = 1, startTime = startTime) annotation(Placement(visible = true, transformation(origin = { -80, -10}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Sources.Sine sine(amplitude = 200, freqHz = 50 / pi) annotation(Placement(visible = true, transformation(origin = { -80,10}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Math.Product product annotation(Placement(visible = true, transformation(origin = { -60,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
// 
//         equation 
//           connect(step.y,brake.f_normalized) annotation(Line(visible = true, points = {{60,19.5},{60,5.5}}, color = {0,0,191}));
//           connect(const.y,clutch.f_normalized) annotation(Line(visible = true, points = {{0,19.5},{3.36767e-16,12.75},{0,12.75},{0,5.5}}, color = {0,0,191}));
//           connect(product.y,torque.tau) annotation(Line(visible = true, points = {{ -54.5,0},{ -46,0}}, color = {0,0,191}));
//           connect(step2.y,product.u2) annotation(Line(visible = true, points = {{ -74.5, -10},{ -70, -10},{ -70, -3},{ -66, -3}}, color = {0,0,191}));
//           connect(sine.y,product.u1) annotation(Line(visible = true, points = {{ -74.5,10},{ -70,10},{ -70,3},{ -66,3}}, color = {0,0,191}));
//           connect(brake.flange_b,inertia1.flange_a) annotation(Line(visible = true, points = {{65,0},{75,0}}));
//           connect(spring.flange_b,brake.flange_a) annotation(Line(visible = true, points = {{45,0},{55,0}}));
//           connect(inertia2.flange_b,spring.flange_a) annotation(Line(visible = true, points = {{25,0},{35,0}}));
//           connect(clutch.flange_b,inertia2.flange_a) annotation(Line(visible = true, points = {{5,0},{15,0}}));
//           connect(inertia3.flange_b,clutch.flange_a) annotation(Line(visible = true, points = {{ -15,0},{ -5,0}}));
//           connect(torque.flange_b,inertia3.flange_a) annotation(Line(visible = true, points = {{ -35,0},{ -25,0}}));
//           tMotor = torque.tau;
//           tClutch = clutch.tau;
//           tBrake = brake.tau;
//           tSpring = spring.tau;
//         end Friction;
//         encapsulated model CoupledClutches "Drive train with 3 dynamically coupled clutches"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter SI.Frequency freqHz = 0.2 "frequency of sine function to invoke clutch1";
//           parameter SI.Time T2 = 0.4 "time when clutch2 is invoked";
//           parameter SI.Time T3 = 0.9 "time when clutch3 is invoked";
//           annotation(Documentation(info = "<html>
// <p>This example demonstrates how variable structure
// drive trains are handeled. The drive train consists
// of 4 inertias and 3 clutches, where the clutches
// are controlled by input signals. The system has
// 2^3=8 different configurations and 3^3 = 27
// different states (every clutch may be in forward
// sliding, backward sliding or locked mode when the
// relative angular velocity is zero). By invoking the
// clutches at different time instances, the switching
// of the configurations can be studied.</p>
// <p>Simulate the system for 1.2 seconds with the
// following initial values:<br>
// J1.w = 10.</p>
// <p>Plot the following variables:<br>
// angular velocities of inertias (J1.w, J2.w, J3.w,
// J4.w), frictional torques of clutches (clutchX.tau),
// frictional mode of clutches (clutchX.mode) where
// mode = -1/0/+1 means backward sliding,
// locked, forward sliding.</p>
//  
// </HTML>"), experiment(StopTime = 1.2), Commands(file = "CoupledClutches.mos" "Plot inertias"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Rotational.Inertia J1(J = 1, phi(start = 0), w(start = 10)) annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Torque torque annotation(Placement(visible = true, transformation(origin = { -60,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Clutch clutch1(peak = 1.1, fn_max = 20) annotation(Placement(visible = true, transformation(origin = { -20,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Sources.Sine sin1(amplitude = 10, freqHz = 5) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia J2(J = 1) annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Clutch clutch2(peak = 1.1, fn_max = 20) annotation(Placement(visible = true, transformation(origin = {20,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia J3(J = 1) annotation(Placement(visible = true, transformation(origin = {40,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Clutch clutch3(peak = 1.1, fn_max = 20) annotation(Placement(visible = true, transformation(origin = {60,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Rotational.Inertia J4(J = 1) annotation(Placement(visible = true, transformation(origin = {80,0}, extent = {{ -5, -5},{5,5}}, rotation = 0)));
//           Sources.Sine sin2(amplitude = 1, freqHz = freqHz, phase = 1.57) annotation(Placement(visible = true, transformation(origin = { -20,20}, extent = {{ -5, -5},{5,5}}, rotation =  -90)));
//           Sources.Step step1(startTime = T2) annotation(Placement(visible = true, transformation(origin = {20,20}, extent = {{ -5, -5},{5,5}}, rotation =  -90)));
//           Sources.Step step2(startTime = T3) annotation(Placement(visible = true, transformation(origin = {60,20}, extent = {{ -5, -5},{5,5}}, rotation =  -90)));
// 
//         equation 
//           connect(sin1.y,torque.tau) annotation(Line(visible = true, points = {{ -74.5,0},{ -66,0}}, color = {0,0,191}));
//           connect(clutch3.flange_b,J4.flange_a) annotation(Line(visible = true, points = {{65,0},{75,0}}));
//           connect(J3.flange_b,clutch3.flange_a) annotation(Line(visible = true, points = {{45,0},{55,0}}));
//           connect(clutch2.flange_b,J3.flange_a) annotation(Line(visible = true, points = {{25,0},{35,0}}));
//           connect(J2.flange_b,clutch2.flange_a) annotation(Line(visible = true, points = {{5,0},{15,0}}));
//           connect(clutch1.flange_b,J2.flange_a) annotation(Line(visible = true, points = {{ -15,0},{ -5,0}}));
//           connect(J1.flange_b,clutch1.flange_a) annotation(Line(visible = true, points = {{ -35,0},{ -25,0}}));
//           connect(torque.flange_b,J1.flange_a) annotation(Line(visible = true, points = {{ -55,0},{ -45,0}}));
//           connect(sin2.y,clutch1.f_normalized) annotation(Line(visible = true, points = {{ -20,14.5},{ -20,5.5}}, color = {0,0,191}));
//           connect(step1.y,clutch2.f_normalized) annotation(Line(visible = true, points = {{20,14.5},{20,5.5}}, color = {0,0,191}));
//           connect(step2.y,clutch3.f_normalized) annotation(Line(visible = true, points = {{60,14.5},{60,5.5}}, color = {0,0,191}));
//         end CoupledClutches;
//         encapsulated model LossyGearDemo1 "Example to show that gear efficiency may lead to stuck motion"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           SI.Power PowerLoss "power lost in the gear";
//           annotation(Documentation(info = "<html>
// <p>
// This model contains two inertias which are connected by an ideal
// gear where the friction between the teeth of the gear is modeled in
// a physical meaningful way (friction may lead to stuck mode which
// locks the motion of the gear). The friction is defined by an
// efficiency factor (= 0.5) for forward and backward driving condition leading
// to a torque dependent friction loss. Simulate for about 0.5 seconds.
// The friction in the gear will take all modes
// (forward and backward rolling, as well as stuck).
// </p>
// <p>
// You may plot:
// </p>
// <pre>
// Inertia1.w,
// Inertia2.w : angular velocities of inertias
// powerLoss  : power lost in the gear
// gear.mode  :  1 = forward rolling
//               0 = stuck (w=0)
//              -1 = backward rolling
// </pre>
// </HTML>
// "), experiment(StopTime = 0.5), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Rotational.LossyGear gear(i = 2, lossTable = [0,0.5,0.5,0,0]) annotation(Placement(visible = true, transformation(origin = {0,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Inertia Inertia1 annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Inertia Inertia2(J = 1.5) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Torque torque1 annotation(Placement(visible = true, transformation(origin = { -60,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Torque torque2 annotation(Placement(visible = true, transformation(origin = {60,10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Sources.Sine DriveSine(amplitude = 10, freqHz = 1) annotation(Placement(visible = true, transformation(origin = { -90,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Ramp load(height = 5, duration = 2, offset =  -10) annotation(Placement(visible = true, transformation(origin = {90,10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
// 
//         equation 
//           connect(load.y,torque2.tau) annotation(Line(visible = true, points = {{79,10},{72,10}}, color = {0,0,191}));
//           connect(DriveSine.y,torque1.tau) annotation(Line(visible = true, points = {{ -79,10},{ -72,10}}, color = {0,0,191}));
//           connect(torque2.flange_b,Inertia2.flange_b) annotation(Line(visible = true, points = {{50,10},{40,10}}));
//           connect(torque1.flange_b,Inertia1.flange_a) annotation(Line(visible = true, points = {{ -50,10},{ -40,10}}));
//           connect(gear.flange_b,Inertia2.flange_a) annotation(Line(visible = true, points = {{10,10},{20,10}}));
//           connect(Inertia1.flange_b,gear.flange_a) annotation(Line(visible = true, points = {{ -20,10},{ -10,10}}));
//           PowerLoss = gear.flange_a.tau * der(gear.flange_a.phi) + gear.flange_b.tau * der(gear.flange_b.phi);
//         end LossyGearDemo1;
//         encapsulated model LossyGearDemo2 "Example to show combination of LossyGear and BearingFriction"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           SI.Power PowerLoss "power lost in the gear";
//           annotation(Documentation(info = "<html>
// <p>
// This model contains bearing friction and gear friction (= efficiency).
// If both friction models are stuck, there is no unique solution.
// Still a reliable Modelica simulator, such as Dymola, should
// be able to handle this situation.
// </p>
// <p>
// Simulate for about 0.5 seconds. The friction elements are
// in all modes (forward and backward rolling, as well as stuck).
// </p>
// <p>
// You may plot:
// </p>
// <pre>
// Inertia1.w,
// Inertia2.w          : angular velocities of inertias
// powerLoss           : power lost in the gear
// bearingFriction.mode:  1 = forward rolling
//                        0 = stuck (w=0)
//                       -1 = backward rolling
// gear.mode           :  1 = forward rolling
//                        0 = stuck (w=0)
//                       -1 = backward rolling
// </pre>
// <p>Note: This combination of LossyGear and BearingFriction is not recommended to use,
// as component LossyGear includes the functionality of component BearingFriction
// (only <i>peak</i> not supported).</p>
// </HTML>
// "), experiment(StopTime = 0.5), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Rotational.LossyGear gear(i = 2, lossTable = [0,0.5,0.5,0,0]) annotation(Placement(visible = true, transformation(origin = {0,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Inertia Inertia1 annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Inertia Inertia2(J = 1.5) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Rotational.Torque torque1 annotation(Placement(visible = true, transformation(origin = { -60,70}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Rotational.Torque torque2 annotation(Placement(visible = true, transformation(origin = {60,10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Sources.Sine DriveSine(amplitude = 10, freqHz = 1) annotation(Placement(visible = true, transformation(origin = { -30,70}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Sources.Ramp load(height = 5, duration = 2, offset =  -10) annotation(Placement(visible = true, transformation(origin = {90,10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Rotational.BearingFriction bearingFriction(tau_pos = [0,0.5;1,1]) annotation(Placement(visible = true, transformation(origin = { -60,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(load.y,torque2.tau) annotation(Line(visible = true, points = {{79,10},{72,10}}, color = {0,0,191}));
//           connect(DriveSine.y,torque1.tau) annotation(Line(visible = true, points = {{ -41,70},{ -48,70}}, color = {0,0,191}));
//           connect(bearingFriction.flange_a,torque1.flange_b) annotation(Line(visible = true, points = {{ -70,10},{ -80,10},{ -80,70},{ -70,70}}));
//           connect(Inertia1.flange_a,bearingFriction.flange_b) annotation(Line(visible = true, points = {{ -40,10},{ -50,10}}));
//           connect(gear.flange_a,Inertia1.flange_b) annotation(Line(visible = true, points = {{ -10,10},{ -20,10}}));
//           connect(Inertia2.flange_a,gear.flange_b) annotation(Line(visible = true, points = {{20,10},{10,10}}));
//           connect(torque2.flange_b,Inertia2.flange_b) annotation(Line(visible = true, points = {{50,10},{40,10}}));
//           PowerLoss = gear.flange_a.tau * der(gear.flange_a.phi) + gear.flange_b.tau * der(gear.flange_b.phi);
//         end LossyGearDemo2;
//         model ElasticBearing "Example to show possible usage of bearing flange"
//           extends Icons.Example;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<html>
// <p>
// This model demonstrates the usage of the bearing flange.
// The gearbox is not connected rigidly to the ground, but by
// a spring-damper-system. This allows examination of the gearbox
// housing dynamics.</p>
// <p>
// Simulate for about 10 seconds and plot the angular velocities of the inertias <tt>housing.w</tt>,
// <tt>shaft.w</tt> and <tt>load.w</tt>.</p>
// </html>
// "), experiment(StopTime = 10), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Mechanics.Rotational.Inertia shaft annotation(Placement(visible = true, transformation(origin = { -10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Inertia load(J = 50) annotation(Placement(visible = true, transformation(origin = {80,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Spring spring(c = 1000.0) annotation(Placement(visible = true, transformation(origin = {50,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Fixed fixed annotation(Placement(visible = true, transformation(origin = {20, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.SpringDamper springDamper(c = 100000.0, d = 5) annotation(Placement(visible = true, transformation(origin = {20, -30}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
//           Modelica.Mechanics.Rotational.Torque torque annotation(Placement(visible = true, transformation(origin = { -40,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp ramp(duration = 5, height = 100) annotation(Placement(visible = true, transformation(origin = { -80,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.IdealGear idealGear(ratio = 3) annotation(Placement(visible = true, transformation(origin = {20,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Inertia housing(J = 5) annotation(Placement(visible = true, transformation(origin = {20,10}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
// 
//         equation 
//           connect(ramp.y,torque.tau) annotation(Line(visible = true, points = {{ -69,50},{ -52,50}}, color = {0,0,191}));
//           connect(housing.flange_a,springDamper.flange_b) annotation(Line(visible = true, points = {{20,20},{20, -40}}));
//           connect(idealGear.bearing,housing.flange_b) annotation(Line(visible = true, points = {{20,40},{20,0}}));
//           connect(idealGear.flange_b,spring.flange_a) annotation(Line(visible = true, points = {{30,50},{40,50}}));
//           connect(shaft.flange_b,idealGear.flange_a) annotation(Line(visible = true, points = {{0,50},{10,50}}));
//           connect(springDamper.flange_a,fixed.flange_b) annotation(Line(visible = true, points = {{20, -20},{20, -70}}));
//           connect(spring.flange_b,load.flange_a) annotation(Line(visible = true, points = {{60,50},{70,50}}));
//           connect(torque.flange_b,shaft.flange_a) annotation(Line(visible = true, points = {{ -30,50},{ -20,50}}));
//         end ElasticBearing;
//       end Examples;
//       package Sensors "Sensors to measure variables in 1D rotational mechanical components"
//         model AngleSensor "Ideal sensor to measure the absolute flange angle"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angle phi</b> of a flange in an ideal
// way and provides the result as output signal <b>phi</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{100,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{70, -70},{120, -30}}, textString = "phi", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a "flange to be measured" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput phi(redeclare type SignalType = SI.Angle) "Absolute angle of flange" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           phi = flange_a.phi;
//           0 = flange_a.tau;
//         end AngleSensor;
//         model SpeedSensor "Ideal sensor to measure the absolute flange angular velocity"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angular velocity w</b> of a flange in an ideal
// way and provides the result as output signal <b>w</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{100,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{70, -70},{120, -30}}, textString = "w", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a "flange to be measured" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput w(redeclare type SignalType = SI.AngularVelocity) "Absolute angular velocity of flange" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           w = der(flange_a.phi);
//           0 = flange_a.tau;
//         end SpeedSensor;
//         model AccSensor "Ideal sensor to measure the absolute flange angular acceleration"
//           extends Modelica.Icons.RotationalSensor;
//           SI.AngularVelocity w "Absolute angular velocity of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angular acceleration a</b> of a flange in an ideal
// way and provides the result as output signal <b>a</b> (to be further processed with
// blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{100,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{70, -70},{120, -30}}, textString = "a", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a "flange to be measured" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput a(redeclare type SignalType = SI.AngularAcceleration) "Absolute angular acceleration of flange" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           w = der(flange_a.phi);
//           a = der(w);
//           0 = flange_a.tau;
//         end AccSensor;
//         extends Modelica.Icons.Library2;
//         model RelAngleSensor "Ideal sensor to measure the relative angle between two flanges"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angle phi_rel</b> between two flanges
// in an ideal way and provides the result as output signal <b>phi_rel</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{13,93},{ -7,98},{ -7,88},{13,93}}),Line(visible = true, points = {{ -77,93},{ -6,93}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{17,87},{85,100}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{20, -100},{160, -70}}, textString = "phi_rel", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,191})}));
//           Interfaces.Flange_a flange_a "driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput phi_rel(redeclare type SignalType = SI.Angle) "Relative angle between two flanges (= flange_b.phi - flange_a.phi)" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelAngleSensor;
//         model RelSpeedSensor "Ideal sensor to measure the relative angular velocity between two flanges"
//           extends Modelica.Icons.RotationalSensor;
//           SI.Angle phi_rel "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angular velocity w_rel</b> between two flanges
// in an ideal way and provides the result as output signal <b>w_rel</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{13,93},{ -7,98},{ -7,88},{13,93}}),Line(visible = true, points = {{ -77,93},{ -6,93}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{17,87},{85,100}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{0, -100},{0, -70}}),Line(visible = true, points = {{70,0},{90,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{20, -100},{160, -70}}, textString = "w_rel", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,191})}));
//           Interfaces.Flange_a flange_a "driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput w_rel(redeclare type SignalType = SI.AngularVelocity) "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi))" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           w_rel = der(phi_rel);
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelSpeedSensor;
//         model RelAccSensor "Ideal sensor to measure the relative angular acceleration between two flanges"
//           extends Modelica.Icons.RotationalSensor;
//           SI.Angle phi_rel "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//           SI.AngularVelocity w_rel "Relative angular velocity between two flanges";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angular acceleration a_rel</b> between two flanges
// in an ideal way and provides the result as output signal <b>a_rel</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{13,93},{ -7,98},{ -7,88},{13,93}}),Line(visible = true, points = {{ -77,93},{ -6,93}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{17,87},{85,100}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{20, -100},{160, -70}}, textString = "a_rel", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a "driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput a_rel(redeclare type SignalType = SI.AngularAcceleration) "Relative angular acceleration between two flanges" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           w_rel = der(phi_rel);
//           a_rel = der(w_rel);
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelAccSensor;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -56, -61},{ -56, -81}}),Line(visible = true, points = {{ -36, -61},{ -36, -81}}),Line(visible = true, points = {{ -16, -61},{ -16, -81}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -76, -81},{64, -1}}),Line(visible = true, points = {{4, -61},{4, -81}}),Line(visible = true, points = {{24, -61},{24, -81}}),Line(visible = true, points = {{44, -61},{44, -81}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -6, -61},{ -16, -37},{4, -37},{ -6, -61}}),Line(visible = true, points = {{ -6, -21},{ -6, -37}}),Line(visible = true, points = {{ -76, -21},{ -6, -21}}),Line(visible = true, points = {{ -56, -61},{ -56, -81}}),Line(visible = true, points = {{ -36, -61},{ -36, -81}}),Line(visible = true, points = {{ -16, -61},{ -16, -81}})}), Documentation(info = "<html>
// <p>
// This package contains ideal sensor components that provide
// the connector variables as signals for further processing with the
// Modelica.Blocks library.
// </p>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model TorqueSensor "Ideal sensor to measure the torque between two flanges (= flange_a.tau)"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>cut-torque between two flanges</b> in an ideal way
// and provides the result as output signal <b>tau</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{14,85},{ -6,90},{ -6,80},{14,85}}),Line(visible = true, points = {{ -76,85},{ -5,85}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{18,79},{86,92}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{96,0}}),Line(visible = true, points = {{ -80, -100},{ -80,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -50, -120},{50, -80}}, textString = "tau", fontName = "Arial"),Line(visible = true, points = {{ -80, -100},{ -80,0}}, color = {0,0,191}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput tau(redeclare type SignalType = SI.Torque) "Torque in flange flange_a and flange_b (= flange_a.tau = -flange_b.tau)" annotation(Placement(visible = true, transformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           flange_a.phi = flange_b.phi;
//           flange_a.tau = tau;
//           flange_b.tau =  -tau;
//         end TorqueSensor;
//         model PowerSensor "Ideal sensor to measure the power between two flanges (= flange_a.tau*der(flange_a.phi))"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>power between two flanges</b> in an ideal way
// and provides the result as output signal <b>power</b>
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{14,85},{ -6,90},{ -6,80},{14,85}}),Line(visible = true, points = {{ -76,85},{ -5,85}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{18,79},{86,92}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{96,0}}),Line(visible = true, points = {{ -80, -100},{ -80,0}})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -50, -120},{100, -80}}, textString = "power", fontName = "Arial"),Line(visible = true, points = {{ -80, -100},{ -80,0}}, color = {0,0,191}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}));
//           Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput power(redeclare type SignalType = SI.Power) "Power in flange flange_a" annotation(Placement(visible = true, transformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = { -80, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           flange_a.phi = flange_b.phi;
//           0 = flange_a.tau + flange_b.tau;
//           power = flange_a.tau * der(flange_a.phi);
//         end PowerSensor;
//       end Sensors;
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(preferedView = "info", Documentation(info = "<html>
//  
// <p>
// Library <b>Rotational</b> is a <b>free</b> Modelica package providing
// 1-dimensional, rotational mechanical components to model in a convenient way
// drive trains with frictional losses. A typical, simple example is shown
// in the next figure:
// </p>
//  
// <p><img src=\"../Images/Rotational/driveExample.png\"></p>
//  
// <p>
// For an introduction, have especially a look at:
// </p>
// <ul>
// <li> <a href=\"Modelica://Modelica.Mechanics.Rotational.UsersGuide\">Rotational.UsersGuide</a>
//      discusses the most important aspects how to use this library.</li>
// <li> <a href=\"Modelica://Modelica.Mechanics.Rotational.Examples\">Rotational.Examples</a>
//      contains examples that demonstrate the usage of this library.</li>
// </ul>
//  
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// ", revisions = ""), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -83, -66},{ -63, -66}}),Line(visible = true, points = {{36, -68},{56, -68}}),Line(visible = true, points = {{ -73, -66},{ -73, -91}}),Line(visible = true, points = {{46, -68},{46, -91}}),Line(visible = true, points = {{ -83, -29},{ -63, -29}}),Line(visible = true, points = {{36, -32},{56, -32}}),Line(visible = true, points = {{ -73, -9},{ -73, -29}}),Line(visible = true, points = {{46, -12},{46, -32}}),Line(visible = true, points = {{ -73, -91},{46, -91}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -47, -80},{27, -17}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -87, -54},{ -47, -41}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{27, -56},{66, -42}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Interfaces "Connectors and partial models for 1D rotational mechanical components"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains connectors and partial models for 1-dim.
// rotational mechanical components. The components of this package can
// only be used as basic building elements for models.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector Flange_a "1D rotational flange (filled square icon)"
//           SI.Angle phi "Absolute rotation angle of flange";
//           flow SI.Torque tau "Cut torque in the flange";
//           annotation(defaultComponentName = "flange_a", Documentation(info = "<HTML>
// <p>
// This is a connector for 1D rotational mechanical systems and models
// a mechanical flange. The following variables are defined in this connector:
// </p>
// <pre>
//    <b>phi</b>: Absolute rotation angle of the flange in [rad].
//    <b>tau</b>: Cut-torque in the flange in [Nm].
// </pre>
// <p>
// There is a second connector for flanges: Flange_b. The connectors
// Flange_a and Flange_b are completely identical. There is only a difference
// in the icons, in order to easier identify a flange variable in a diagram.
// For a discussion on the actual direction of the cut-torque tau and
// of the rotation angle, see the information text of package Rotational
// (section 4. Sign conventions).
// </p>
// <p>
// If needed, the absolute angular velocity w and the
// absolute angular acceleration a of the flange can be determined by
// differentiation of the flange angle phi:
// </p>
// <pre>
//      w = der(phi);    a = der(w)
// </pre>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -160,50},{40,90}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}})}));
//         end Flange_a;
//         connector Flange_b "1D rotational flange (non-filled square icon)"
//           SI.Angle phi "Absolute rotation angle of flange";
//           flow SI.Torque tau "Cut torque in the flange";
//           annotation(defaultComponentName = "flange_b", Documentation(info = "<HTML>
// <p>
// This is a connector for 1D rotational mechanical systems and models
// a mechanical flange. The following variables are defined in this connector:
// </p>
// <pre>
//    <b>phi</b>: Absolute rotation angle of the flange in [rad].
//    <b>tau</b>: Cut-torque in the flange in [Nm].
// </pre>
// <p>
// There is a second connector for flanges: Flange_a. The connectors
// Flange_a and Flange_b are completely identical. There is only a difference
// in the icons, in order to easier identify a flange variable in a diagram.
// For a discussion on the actual direction of the cut-torque tau and
// of the rotation angle, see the information text of package Rotational
// (section 4. Sign conventions).
// </p>
// <p>
// If needed, the absolute angular velocity w and the
// absolute angular acceleration a of the flange can be determined by
// differentiation of the flange angle phi:
// </p>
// <pre>
//      w = der(phi);    a = der(w)
// </pre>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -98, -100},{102,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, extent = {{ -40,50},{160,90}}, textString = "%name", fontName = "Arial")}));
//         end Flange_b;
//         partial model Rigid "Base class for the rigid connection of two rotational 1D flanges"
//           SI.Angle phi "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two rigidly connected flanges,
// i.e., flange_a.phi = flange_b.phi. It is used e.g. to built up components
// with inertia.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           flange_a.phi = phi;
//           flange_b.phi = phi;
//         end Rigid;
//         partial model Compliant "Base class for the compliant connection of two rotational 1D flanges"
//           SI.Angle phi_rel(start = 0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
//           SI.Torque tau "Torque between flanges (= flange_b.tau)";
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with a compliant connection of two
// rotational 1D flanges where inertial effects between the two
// flanges are neglected. The basic assumption is that the cut-torques
// of the two flanges sum-up to zero, i.e., they have the same absolute value
// but opposite sign: flange_a.tau + flange_b.tau = 0. This base class
// is used to built up force elements such as springs, dampers, friction.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           flange_b.tau = tau;
//           flange_a.tau =  -tau;
//         end Compliant;
//         partial model TwoFlanges "Base class for a component with two rotational 1D flanges"
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges.
// It is used e.g. to build up parts of a drive train consisting
// of several base components. There are specialized versions of this
// base class for rigidly connected flanges (Interfaces.Rigid) and
// for a compliant connection of flanges (Interfaces.Compliant).
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end TwoFlanges;
//         partial model Bearing "Base class for interface classes with bearing connector"
//           extends TwoFlanges;
//           SI.Torque tau_support;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}})}), Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is a superclass for the two components TwoFlangesAndBearing and TwoFlangesAndBearingH.</p>
//  
// </HTML>
// "));
//           Flange_a bearing annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end Bearing;
//         partial model TwoFlangesAndBearing "Base class for a equation-based component with two rotational 1D flanges and one rotational 1D bearing flange"
//           extends Bearing;
//           SI.Angle phi_a;
//           SI.Angle phi_b;
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is used e.g. to build up equation-based parts of a drive train.</p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           if cardinality(bearing) == 0 then
//             bearing.phi = 0;
// 
//           else
//             bearing.tau = tau_support;
// 
//           end if;
//           0 = flange_a.tau + flange_b.tau + tau_support;
//           phi_a = flange_a.phi - bearing.phi;
//           phi_b = flange_b.phi - bearing.phi;
//         end TwoFlangesAndBearing;
//         partial model TwoFlangesAndBearingH "Base class for a hierarchically composed component with two rotational 1D flanges and one rotational bearing flange"
//           extends Bearing;
//           encapsulated model Adapter
//             import Modelica.Mechanics.Rotational.Interfaces.TwoFlanges;
//             extends TwoFlanges;
//             parameter Boolean bearingConnected;
//             annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -90,10},{90, -10}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Text(extent = {{ -150,60},{150,20}}, textString = "%name")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           equation 
//             flange_a.phi = flange_b.phi;
//             if bearingConnected then
//               0 = flange_a.tau + flange_b.tau;
// 
//             else
//               0 = flange_a.phi;
// 
//             end if;
//           end Adapter;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Adapter adapter(bearingConnected = cardinality(bearing) > 1) annotation(Placement(visible = true, transformation(origin = {0, -60}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           encapsulated model Adapter
//             import Modelica.Mechanics.Rotational.Interfaces.TwoFlanges;
//             extends TwoFlanges;
//             parameter Boolean bearingConnected;
//             annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -90,10},{90, -10}}, fillPattern = FillPattern.Solid, lineColor = {192,192,192}, fillColor = {192,192,192}),Text(extent = {{ -150,60},{150,20}}, textString = "%name")}));
// 
//           equation 
//             flange_a.phi = flange_b.phi;
//             if bearingConnected then
//               0 = flange_a.tau + flange_b.tau;
// 
//             else
//               0 = flange_a.phi;
// 
//             end if;
//           end Adapter;
// 
//         equation 
//           connect(adapter.flange_a,bearing) annotation(Line(visible = true, points = {{0, -50},{0, -70},{0, -100}}));
//           tau_support =  -adapter.flange_b.tau;
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is used e.g. to build up parts of a drive train consisting
// of several base components.</p>
//  
// </HTML>
// "));
//         end TwoFlangesAndBearingH;
//         partial model FrictionBase "Base class of Coulomb friction elements"
//           parameter SI.AngularVelocity w_small = 10000000000.0 "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)" annotation(Dialog(tab = "Advanced"));
//           SI.AngularVelocity w_relfric "Relative angular velocity between frictional surfaces";
//           SI.AngularAcceleration a_relfric "Relative angular acceleration between frictional surfaces";
//           SI.Torque tau "Friction torque (positive, if directed in opposite direction of w_rel)";
//           SI.Torque tau0 "Friction torque for w=0 and forward sliding";
//           SI.Torque tau0_max "Maximum friction torque for w=0 and locked";
//           Boolean free "true, if frictional element is not active";
//           Real sa "Path parameter of friction characteristic tau = f(a_relfric)";
//           Boolean startForward(start = false, fixed = true) "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
//           Boolean startBackward(start = false, fixed = true) "true, if w_rel=0 and start of backward sliding or w_rel < -w_small";
//           Boolean locked(start = false) "true, if w_rel=0 and not sliding";
//           constant Integer Unknown = 3 "Value of mode is not known";
//           constant Integer Free = 2 "Element is not active";
//           constant Integer Forward = 1 "w_rel > 0 (forward sliding)";
//           constant Integer Stuck = 0 "w_rel = 0 (forward sliding, locked or backward sliding)";
//           constant Integer Backward =  -1 "w_rel < 0 (backward sliding)";
//           Integer mode(final min = Backward, final max = Unknown, start = Unknown, fixed = true);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         protected 
//           parameter Modelica.SIunits.AngularAcceleration unitAngularAcceleration = 1;
//           parameter Modelica.SIunits.Torque unitTorque = 1;
// 
//         equation 
//           startForward = pre(mode) == Stuck and (sa > tau0_max or pre(startForward) and sa > tau0) or pre(mode) == Backward and w_relfric > w_small or initial() and w_relfric > 0;
//           startBackward = pre(mode) == Stuck and (sa <  -tau0_max or pre(startBackward) and sa <  -tau0) or pre(mode) == Forward and w_relfric <  -w_small or initial() and w_relfric < 0;
//           locked = not free and not (pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//           a_relfric = unitAngularAcceleration * (if locked then 0 else if free then sa else if startForward then sa - tau0_max / unitTorque else if startBackward then sa + tau0_max / unitTorque else if pre(mode) == Forward then sa - tau0 / unitTorque else sa + tau0 / unitTorque);
//           mode = if free then Free else if (pre(mode) == Forward or pre(mode) == Free or startForward) and w_relfric > 0 then Forward else if (pre(mode) == Backward or pre(mode) == Free or startBackward) and w_relfric < 0 then Backward else Stuck;
//           annotation(Documentation(info = "<html>
// <p>
// Basic model for Coulomb friction that models the stuck
// phase in a reliable way.
// </p>
// </html>"));
//         end FrictionBase;
//         partial model AbsoluteSensor "Base class to measure a single absolute flange variable"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// This is the base class of a 1D rotational component with one flange and one
// output signal y in order to measure an absolute kinematic quantity in the flange
// and to provide the measured signal as output signal for further processing
// with the blocks of package Modelica.Blocks.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{ -150,80},{150,120}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}})}));
//           Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Base class to measure a single relative variable between two flanges"
//           extends Modelica.Icons.RotationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// This is a base class for 1D rotational components with two rigidly connected
// flanges and one output signal y in order to measure relative kinematic quantities
// between the two flanges or the cut-torque in the flange and
// to provide the measured signal as output signal for further processing
// with the blocks of package Modelica.Blocks.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,191}),Text(visible = true, extent = {{ -150,70},{150,110}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}})}));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//         end RelativeSensor;
//         partial model PartialSpeedDependentTorque "Partial model of a torque acting at the flange (accelerates the flange)"
//           Modelica.SIunits.AngularVelocity w = der(flange.phi) "Angular velocity at flange";
//           Modelica.SIunits.Torque tau = flange.tau "accelerating torque acting at flange";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Documentation(info = "<HTML>
// <p>
// Partial model of torque dependent on speed that accelerates the flange.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -96, -96},{96,96}}),Line(visible = true, points = {{ -30, -70},{30, -70}}),Line(visible = true, points = {{ -30, -90},{ -10, -70}}),Line(visible = true, points = {{ -10, -90},{10, -70}}),Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -140},{20, -100}}),Line(visible = true, points = {{10, -90},{30, -70}}),Line(visible = true, points = {{0, -70},{0, -110}}),Line(visible = true, points = {{ -92,0},{ -76,36},{ -54,62},{ -30,80},{ -14,88},{10,92},{26,90},{46,80},{64,62}}, smooth = Smooth.Bezier),Text(visible = true, fillColor = {0,0,255}, extent = {{ -150,100},{150,140}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{94,16},{80,74},{50,52},{94,16}})}));
//           Modelica.Mechanics.Rotational.Interfaces.Flange_b flange "Flange on which torque is acting" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Interfaces.Flange_a bearing "Bearing at which the reaction torque (i.e., -flange.tau) is acting" annotation(Placement(visible = true, transformation(origin = {0, -120}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -120}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           if cardinality(bearing) == 0 then
//             bearing.phi = 0;
// 
//           else
//             bearing.tau =  -flange.tau;
// 
//           end if;
//         end PartialSpeedDependentTorque;
//       end Interfaces;
//       model Inertia "1D-rotational component with inertia"
//         import SI = Modelica.SIunits;
//         import Modelica.Mechanics.Rotational.Types.Init;
//         import Modelica.Blocks.Types.StateSelection;
//         parameter SI.Inertia J(min = 0) = 1 "Moment of inertia";
//         parameter Init.Temp initType = Modelica.Mechanics.Rotational.Types.Init.NoInit "Type of initialization (defines usage of start values below)" annotation(Dialog(group = "Initialization"));
//         parameter SI.Angle phi_start = 0 "Initial or guess value of rotor rotation angle phi" annotation(Dialog(group = "Initialization"), Evaluate = false);
//         parameter SI.AngularVelocity w_start = 0 "Initial or guess value of angular velocity w = der(phi)" annotation(Dialog(group = "Initialization"), Evaluate = false);
//         parameter SI.AngularAcceleration a_start = 0 "Initial value of angular acceleration a = der(w)" annotation(Dialog(group = "Initialization", enable = initType >= Init.InitialAcceleration), Evaluate = false);
//         parameter StateSelection.Temp stateSelection = Modelica.Blocks.Types.StateSelection.Default "Priority to use phi and w as states" annotation(Dialog(tab = "Advanced"));
//         extends Interfaces.Rigid(phi(start = phi_start, stateSelect = if stateSelection == StateSelection.Never then StateSelect.never else if stateSelection == StateSelection.Avoid then StateSelect.avoid else if stateSelection == StateSelection.Default then StateSelect.default else if stateSelection == StateSelection.Prefer then StateSelect.prefer else StateSelect.always));
//         SI.AngularVelocity w(start = w_start, stateSelect = if stateSelection == StateSelection.Never then StateSelect.never else if stateSelection == StateSelection.Avoid then StateSelect.avoid else if stateSelection == StateSelection.Default then StateSelect.default else if stateSelection == StateSelection.Prefer then StateSelect.prefer else StateSelect.always) "Absolute angular velocity of component";
//         SI.AngularAcceleration a "Absolute angular acceleration of component";
//         annotation(Documentation(info = "<html>
// <p>
// Rotational component with <b>inertia</b> and two rigidly connected flanges.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -25},{ -60, -25}}),Line(visible = true, points = {{60, -25},{80, -25}}),Line(visible = true, points = {{ -70, -25},{ -70, -70}}),Line(visible = true, points = {{70, -25},{70, -70}}),Line(visible = true, points = {{ -80,25},{ -60,25}}),Line(visible = true, points = {{60,25},{80,25}}),Line(visible = true, points = {{ -70,45},{ -70,25}}),Line(visible = true, points = {{70,45},{70,25}}),Line(visible = true, points = {{ -70, -70},{70, -70}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50, -50},{50,50}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -50,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{50, -10},{96,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{0, -90},{ -20, -85},{ -20, -95},{0, -90}}),Line(visible = true, points = {{ -90, -90},{ -19, -90}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{4, -96},{72, -83}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{9,73},{19,70},{9,67},{9,73}}),Line(visible = true, points = {{9,70},{ -21,70}}),Text(visible = true, extent = {{25,65},{77,77}}, textString = "w = der(phi) ", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -50,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{50, -10},{100,10}}),Line(visible = true, points = {{ -80, -25},{ -60, -25}}),Line(visible = true, points = {{60, -25},{80, -25}}),Line(visible = true, points = {{ -70, -25},{ -70, -70}}),Line(visible = true, points = {{70, -25},{70, -70}}),Line(visible = true, points = {{ -80,25},{ -60,25}}),Line(visible = true, points = {{60,25},{80,25}}),Line(visible = true, points = {{ -70,45},{ -70,25}}),Line(visible = true, points = {{70,45},{70,25}}),Line(visible = true, points = {{ -70, -70},{70, -70}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50, -50},{50,50}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,100}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{ -150, -120},{150, -80}}, textString = "J=%J", fontName = "Arial")}));
// 
//       initial equation 
//         if initType == Init.SteadyState then
//           der(phi) = 0;
//           der(w) = 0;
// 
//         elseif initType == Init.InitialState then
//           phi = phi_start;
//           w = w_start;
// 
// 
//         elseif initType == Init.InitialAngle then
//           phi = phi_start;
// 
// 
//         elseif initType == Init.InitialSpeed then
//           w = w_start;
// 
// 
//         elseif initType == Init.InitialAcceleration then
//           a = a_start;
// 
// 
//         elseif initType == Init.InitialAngleAcceleration then
//           phi = phi_start;
//           a = a_start;
// 
// 
//         elseif initType == Init.InitialSpeedAcceleration then
//           w = w_start;
//           a = a_start;
// 
// 
//         elseif initType == Init.InitialAngleSpeedAcceleration then
//           phi = phi_start;
//           w = w_start;
//           a = a_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         w = der(phi);
//         a = der(w);
//         J * a = flange_a.tau + flange_b.tau;
//       end Inertia;
//       model IdealGear "Ideal gear without inertia"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real ratio = 1 "Transmission ratio (flange_a.phi/flange_b.phi)";
//         annotation(Documentation(info = "<html>
// <p>
// This element characterices any type of gear box which is fixed in the
// ground and which has one driving shaft and one driven shaft.
// The gear is <b>ideal</b>, i.e., it does not have inertia, elasticity, damping
// or backlash. If these effects have to be considered, the gear has to be
// connected to other elements in an appropriate way.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -20},{ -20,20}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40,20},{ -20,140}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20,60},{40,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -60},{40,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -40,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{96,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20,70},{20,90}}),Line(visible = true, points = {{ -90, -80},{ -20, -80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{0, -80},{ -20, -75},{ -20, -85},{0, -80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{34, -86},{34, -72}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -80,20},{ -60,20}}),Line(visible = true, points = {{ -80, -20},{ -60, -20}}),Line(visible = true, points = {{ -70, -20},{ -70, -70}}),Line(visible = true, points = {{70, -70},{ -70, -70}}),Line(visible = true, points = {{0,60},{0, -90}}),Line(visible = true, points = {{ -10,60},{10,60}}),Line(visible = true, points = {{ -10,100},{10,100}}),Line(visible = true, points = {{60,20},{80,20}}),Line(visible = true, points = {{60, -20},{80, -20}}),Line(visible = true, points = {{70, -20},{70, -70}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -20},{ -20,20}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40,20},{ -20,140}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20,60},{40,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -60},{40,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{100,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20,70},{20,90}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -40,10}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,140},{150,180}}, textString = "%name=%ratio", fontName = "Arial"),Line(visible = true, points = {{ -80,20},{ -60,20}}),Line(visible = true, points = {{ -80, -20},{ -60, -20}}),Line(visible = true, points = {{ -70, -20},{ -70, -70}}),Line(visible = true, points = {{0,60},{0, -90}}),Line(visible = true, points = {{ -10,60},{10,60}}),Line(visible = true, points = {{ -10,100},{10,100}}),Line(visible = true, points = {{60, -20},{80, -20}}),Line(visible = true, points = {{60,20},{80,20}}),Line(visible = true, points = {{70, -20},{70, -70}}),Line(visible = true, points = {{70, -70},{ -70, -70}})}));
// 
//       equation 
//         phi_a = ratio * phi_b;
//         0 = ratio * flange_a.tau + flange_b.tau;
//       end IdealGear;
//       model IdealPlanetary "Ideal planetary gear box"
//         parameter Real ratio = 100 / 50 "number of ring_teeth/sun_teeth (e.g. ratio=100/50)";
//         annotation(Documentation(info = "<HTML>
// <p>
// The IdealPlanetary gear box is an ideal gear without inertia,
// elasticity, damping or backlash consisting
// of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
// <b>planet</b> wheel located between sun and ring wheel. The bearing
// of the planet wheel shaft is fixed in the planet <b>carrier</b>.
// The component can be connected to other elements at the
// sun, ring and/or carrier flanges. It is not possible to connect
// to the planet wheel. If inertia shall not be neglected,
// the sun, ring and carrier inertias can be easily added by attaching
// inertias (= model Inertia) to the corresponding connectors.
// The inertias of the planet wheels are always neglected.
// </p>
// <p>
// The icon of the planetary gear signals that the sun and carrier
// flanges are on the left side and the ring flange is on the right side
// of the gear box. However, this component is generic and is valid
// independantly how the flanges are actually placed (e.g. sun wheel
// may be placed on the right side instead on the left side in reality).
// </p>
// <p>
// The ideal planetary gearbox is uniquely defined by the ratio
// of the number of ring teeth zr with respect to the number of
// sun teeth zs. For example, if there are 100 ring teeth and
// 50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
// zp has to fulfill the following relationship:
// </p>
// <pre>
//    <b>zp := (zr - zs) / 2</b>
// </pre>
// <p>
// Therefore, in the above example zp = 25 is required.
// </p>
// <p>
// According to the overall convention, the positive direction of all
// vectors, especially the absolute angular velocities and cut-torques
// in the flanges, are along the axis vector displayed in the icon.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -100},{50,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50,45},{ -10,85}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50, -30},{ -10,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -50,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{50, -10},{100,10}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -50,100},{50,105}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -50, -105},{50, -100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -80,60},{ -50,70}}),Line(visible = true, points = {{ -90,40},{ -70,40}}),Line(visible = true, points = {{ -80,50},{ -60,50}}),Line(visible = true, points = {{ -70,50},{ -70,40}}),Line(visible = true, points = {{ -80,80},{ -59,80}}),Line(visible = true, points = {{ -70,90},{ -70,80}}),Line(visible = true, points = {{ -26, -42},{ -32, -2}}, pattern = LinePattern.Dot),Line(visible = true, points = {{36, -26},{64, -60}}, pattern = LinePattern.Dot),Text(visible = true, extent = {{58, -78},{98, -66}}, textString = "ring gear", fontName = "Arial"),Text(visible = true, extent = {{ -112,87},{ -56,111}}, textString = "planet carrier ", fontName = "Arial"),Text(visible = true, extent = {{ -47, -56},{ -3, -42}}, textString = "sun gear", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{58,130},{28,140},{28,120},{58,130}}),Line(visible = true, points = {{ -52,130},{28,130}}),Line(visible = true, points = {{ -92,93},{ -70,80}}, pattern = LinePattern.Dot),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -7, -86},{ -27, -81},{ -27, -91},{ -7, -86}}),Line(visible = true, points = {{ -97, -86},{ -26, -86}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{ -96, -84},{ -28, -71}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -100},{50,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50,45},{ -10,85}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -50, -30},{ -10,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -50,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{50, -10},{100,10}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -50,100},{50,105}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -50, -105},{50, -100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -80,60},{ -50,70}}),Line(visible = true, points = {{ -90,40},{ -70,40}}),Line(visible = true, points = {{ -80,50},{ -60,50}}),Line(visible = true, points = {{ -70,50},{ -70,40}}),Line(visible = true, points = {{ -80,80},{ -59,80}}),Line(visible = true, points = {{ -70,100},{ -70,80}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,110},{150,150}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{ -150, -150},{150, -110}}, textString = "ratio=%ratio", fontName = "Arial")}));
//         Interfaces.Flange_a sun "sun flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.Flange_a carrier "carrier flange (flange axis directed INTO cut plane)" annotation(Placement(visible = true, transformation(origin = { -100,40}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.Flange_b ring "ring flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         (1 + ratio) * carrier.phi = sun.phi + ratio * ring.phi;
//         ring.tau = ratio * sun.tau;
//         carrier.tau =  -(1 + ratio) * sun.tau;
//       end IdealPlanetary;
//       model IdealGearR2T "Gearbox transforming rotational into translational motion"
//         parameter Real ratio(final unit = "rad/m") = 1 "transmission ratio (flange_a.phi/flange_b.s)";
//         SI.Torque tau_support;
//         SI.Force f_support;
//         annotation(Documentation(info = "<html>
// This is an ideal mass- and inertialess gearbox which transforms a
// 1D-rotational into a 1D-translational motion. If elasticity, damping
// or backlash has to be considered, this ideal gearbox has to be
// connected with corresponding elements.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -80, -120},{ -40, -80}}),Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{40, -120},{80, -80}}),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -40},{10,40}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -40, -10},{ -20,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -70,10}}),Rectangle(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -74, -80},{106, -60}}),Rectangle(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{95, -60},{106, -10}}),Text(visible = true, extent = {{ -100,40},{100,70}}, textString = "transform rotation into translation", fontName = "Arial"),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -74, -60},{ -54, -40},{ -34, -60},{ -14, -40},{6, -60},{26, -40},{46, -60},{66, -40},{86, -60},{ -74, -60}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{16,80},{ -4,85},{ -4,75},{16,80}}),Line(visible = true, points = {{ -74,80},{ -3,80}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{21,75},{89,88}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{40, -120},{80, -80}}),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -40},{10,40}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -40, -10},{ -20,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -70,10}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,50},{150,90}}, textString = "%name=%ratio", fontName = "Arial"),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -74, -60},{ -54, -40},{ -34, -60},{ -14, -40},{6, -60},{26, -40},{46, -60},{66, -40},{86, -60},{ -74, -60}}),Rectangle(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{95, -60},{106, -10}}),Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -80, -120},{ -40, -80}}),Rectangle(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -74, -80},{106, -60}})}));
//         Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Mechanics.Translational.Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//         Interfaces.Flange_a bearingR annotation(Placement(visible = true, transformation(origin = { -60, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -60, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Translational.Interfaces.Flange_a bearingT annotation(Placement(visible = true, transformation(origin = {60, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {60, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         flange_a.phi - bearingR.phi = ratio * (flange_b.s - bearingT.s);
//         0 = ratio * flange_a.tau + flange_b.f;
//         0 = flange_a.tau + tau_support;
//         0 = flange_b.f + f_support;
//         if cardinality(bearingR) == 0 then
//           bearingR.phi = 0;
// 
//         else
//           bearingR.tau = tau_support;
// 
//         end if;
//         if cardinality(bearingT) == 0 then
//           bearingT.s = 0;
// 
//         else
//           bearingT.f = f_support;
// 
//         end if;
//       end IdealGearR2T;
//       model Spring "Linear 1D rotational spring"
//         extends Interfaces.Compliant;
//         parameter Real c(final unit = "N.m/rad", final min = 0) "Spring constant";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         annotation(Documentation(info = "<html>
// <p>
// A <b>linear 1D rotational spring</b>. The component can be connected either
// between two inertias/gears to describe the shaft elasticity, or between
// a inertia/gear and the housing (component Fixed), to describe
// a coupling of the element with the housing via a spring.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -68,0},{ -68,65}}, color = {128,128,128}),Line(visible = true, points = {{72,0},{72,65}}, color = {128,128,128}),Line(visible = true, points = {{ -68,60},{72,60}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{62,63},{72,60},{62,57},{62,63}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -22,62},{18,87}}, textString = "phi_rel", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{12, -74},{80, -61}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{8, -68},{ -12, -63},{ -12, -73},{8, -68}}),Line(visible = true, points = {{ -82, -68},{ -11, -68}}, color = {128,128,128}),Line(visible = true, points = {{ -96,0},{ -60,0},{ -42, -32},{ -12,30},{18, -30},{48,28},{62,0},{96,0}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,80}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{ -150, -80},{150, -40}}, textString = "c=%c", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -58,0},{ -43, -30},{ -13,30},{17, -30},{47,30},{62,0},{100,0}})}));
// 
//       equation 
//         tau = c * (phi_rel - phi_rel0);
//       end Spring;
//       model Damper "Linear 1D rotational damper"
//         extends Interfaces.Compliant;
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         SI.AngularVelocity w_rel "Relative angular velocity between flange_b and flange_a";
//         annotation(Documentation(info = "<html>
// <p>
// <b>Linear, velocity dependent damper</b> element. It can be either connected
// between an inertia or gear and the housing (component Fixed), or
// between two inertia/gear elements.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -96,0},{ -60,0}}),Line(visible = true, points = {{ -60, -30},{ -60,30}}),Line(visible = true, points = {{ -60, -30},{60, -30}}),Line(visible = true, points = {{ -60,30},{60,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{30,30}}),Line(visible = true, points = {{30,0},{96,0}}),Line(visible = true, points = {{ -68,0},{ -68,65}}, color = {128,128,128}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -22,62},{18,87}}, textString = "phi_rel", fontName = "Arial"),Line(visible = true, points = {{ -68,60},{72,60}}, color = {128,128,128}),Line(visible = true, points = {{72,0},{72,65}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{62,63},{72,60},{62,57},{62,63}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10, -60},{ -10, -55},{ -10, -65},{10, -60}}),Line(visible = true, points = {{ -80, -60},{ -9, -60}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{14, -66},{82, -53}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -60,0}}),Line(visible = true, points = {{ -60, -30},{ -60,30}}),Line(visible = true, points = {{ -60, -30},{60, -30}}),Line(visible = true, points = {{ -60,30},{60,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{30,30}}),Line(visible = true, points = {{30,0},{90,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,80}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{ -150, -90},{150, -50}}, textString = "d=%d", fontName = "Arial")}));
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = d * w_rel;
//       end Damper;
//       model SpringDamper "Linear 1D rotational spring and damper in parallel"
//         import SI = Modelica.SIunits;
//         import Modelica.Mechanics.Rotational.Types.InitRel;
//         import Modelica.Blocks.Types.StateSelection;
//         parameter Real c(final unit = "N.m/rad", final min = 0) "Spring constant";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         parameter InitRel.Temp initType = Modelica.Mechanics.Rotational.Types.InitRel.NoInit "Type of initialization (defines usage of start values below)" annotation(Dialog(group = "Initialization"));
//         parameter SI.Angle phi_rel_start = 0 "Initial or guess value of relative rotation angle phi_rel" annotation(Dialog(group = "Initialization"), Evaluate = false);
//         parameter SI.AngularVelocity w_rel_start = 0 "Initial or guess value of relative angular velocity w_rel = der(phi_rel)" annotation(Dialog(group = "Initialization"), Evaluate = false);
//         parameter StateSelection.Temp stateSelection = Modelica.Blocks.Types.StateSelection.Default "Priority to use phi_rel and w_rel as states" annotation(Dialog(tab = "Advanced"));
//         extends Interfaces.Compliant(phi_rel(start = phi_rel_start, stateSelect = if stateSelection == StateSelection.Never then StateSelect.never else if stateSelection == StateSelection.Avoid then StateSelect.avoid else if stateSelection == StateSelection.Default then StateSelect.default else if stateSelection == StateSelection.Prefer then StateSelect.prefer else StateSelect.always));
//         SI.AngularVelocity w_rel(start = w_rel_start, stateSelect = if stateSelection == StateSelection.Never then StateSelect.never else if stateSelection == StateSelection.Avoid then StateSelect.avoid else if stateSelection == StateSelection.Default then StateSelect.default else if stateSelection == StateSelection.Prefer then StateSelect.prefer else StateSelect.always) "Relative angular velocity between flange_b and flange_a";
//         annotation(Documentation(info = "<html>
// <p>
// A <b>spring</b> and <b>damper</b> element <b>connected in parallel</b>.
// The component can be
// connected either between two inertias/gears to describe the shaft elasticity
// and damping, or between an inertia/gear and the housing (component Fixed),
// to describe a coupling of the element with the housing via a spring/damper.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,32},{ -58,32},{ -43,2},{ -13,62},{17,2},{47,62},{62,32},{80,32}}, thickness = 0.5),Line(visible = true, points = {{ -68,32},{ -68,97}}, color = {128,128,128}),Line(visible = true, points = {{72,32},{72,97}}, color = {128,128,128}),Line(visible = true, points = {{ -68,92},{72,92}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{62,95},{72,92},{62,89},{62,95}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -20,72},{20,97}}, textString = "phi_rel", fontName = "Arial"),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -52, -80},{38, -20}}),Line(visible = true, points = {{ -52, -80},{68, -80}}),Line(visible = true, points = {{ -52, -20},{68, -20}}),Line(visible = true, points = {{38, -50},{80, -50}}),Line(visible = true, points = {{ -80, -50},{ -52, -50}}),Line(visible = true, points = {{ -80,32},{ -80, -50}}),Line(visible = true, points = {{80,32},{80, -50}}),Line(visible = true, points = {{ -96,0},{ -80,0}}),Line(visible = true, points = {{96,0},{80,0}}),Text(visible = true, fillColor = {128,128,128}, extent = {{15, -100},{83, -87}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{11, -94},{ -9, -89},{ -9, -99},{11, -94}}),Line(visible = true, points = {{ -79, -94},{ -8, -94}}, color = {128,128,128})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,40},{ -60,40},{ -45,10},{ -15,70},{15,10},{45,70},{60,40},{80,40}}),Line(visible = true, points = {{ -80,40},{ -80, -70}}),Line(visible = true, points = {{ -80, -70},{ -52, -70}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -52, -100},{38, -40}}),Line(visible = true, points = {{ -52, -40},{68, -40}}),Line(visible = true, points = {{ -52, -100},{68, -100}}),Line(visible = true, points = {{38, -70},{80, -70}}),Line(visible = true, points = {{80,40},{80, -70}}),Line(visible = true, points = {{ -90,0},{ -80,0}}),Line(visible = true, points = {{80,0},{90,0}}),Text(visible = true, extent = {{ -101, -147},{98, -107}}, textString = "d=%d", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,70},{150,110}}, textString = "%name=%c", fontName = "Arial")}));
// 
//       initial equation 
//         if initType == InitRel.SteadyState then
//           der(phi_rel) = 0;
//           der(w_rel) = 0;
// 
//         elseif initType == InitRel.InitialState then
//           phi_rel = phi_rel_start;
//           w_rel = w_rel_start;
// 
// 
//         elseif initType == InitRel.InitialAngle then
//           phi_rel = phi_rel_start;
// 
// 
//         elseif initType == InitRel.InitialSpeed then
//           w_rel = w_rel_start;
// 
// 
//         else
// 
//         end if;
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = c * (phi_rel - phi_rel0) + d * w_rel;
//       end SpringDamper;
//       model ElastoBacklash "Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)"
//         extends Interfaces.Compliant;
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Spring constant (c > 0 required)";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         SI.AngularVelocity w_rel "Relative angular velocity between flange_b and flange_a";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,32},{ -58,32},{ -48,0},{ -34,61},{ -20,0},{ -8,60},{0,30},{20,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -80},{ -10, -20}}),Line(visible = true, points = {{ -52, -80},{0, -80}}),Line(visible = true, points = {{ -52, -20},{0, -20}}),Line(visible = true, points = {{ -10, -50},{20, -50}}),Line(visible = true, points = {{ -80, -50},{ -60, -50}}),Line(visible = true, points = {{ -80,32},{ -80, -50}}),Line(visible = true, points = {{20,30},{20, -50}}),Line(visible = true, points = {{ -90,0},{ -80,0}}),Line(visible = true, points = {{90,0},{80,0}}),Line(visible = true, points = {{20,0},{60,0},{60, -30}}),Line(visible = true, points = {{40, -12},{40, -40},{80, -40},{80,0}}),Text(visible = true, extent = {{ -150, -130},{150, -90}}, textString = "b=%b", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,100}}, textString = "%name=%c", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,32},{ -58,32},{ -48,0},{ -34,60},{ -20,0},{ -8,60},{0,30},{20,30}}, thickness = 0.5),Line(visible = true, points = {{ -68,32},{ -68,97}}, color = {128,128,128}),Line(visible = true, points = {{80,0},{80,96}}, color = {128,128,128}),Line(visible = true, points = {{ -68,92},{72,92}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{70,95},{80,92},{70,89},{70,95}}),Text(visible = true, fillColor = {128,128,128}, extent = {{ -10,70},{30,95}}, textString = "phi_rel", fontName = "Arial"),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -60, -80},{ -10, -20}}),Line(visible = true, points = {{ -52, -80},{0, -80}}, thickness = 0.5),Line(visible = true, points = {{ -52, -20},{0, -20}}, thickness = 0.5),Line(visible = true, points = {{ -10, -50},{20, -50}}, thickness = 0.5),Line(visible = true, points = {{ -80, -50},{ -60, -50}}, thickness = 0.5),Line(visible = true, points = {{ -80,32},{ -80, -50}}, thickness = 0.5),Line(visible = true, points = {{20,30},{20, -50}}, thickness = 0.5),Line(visible = true, points = {{ -96,0},{ -80,0}}),Line(visible = true, points = {{96,0},{80,0}}, thickness = 0.5),Line(visible = true, points = {{20,0},{60,0},{60, -30}}, thickness = 0.5),Line(visible = true, points = {{40, -12},{40, -40},{80, -40},{80,0}}, thickness = 0.5),Line(visible = true, points = {{30,0},{30,64}}, color = {128,128,128}),Line(visible = true, points = {{30,60},{80,60}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{70,63},{80,60},{70,57},{70,63}}),Text(visible = true, fillColor = {160,160,160}, extent = {{39,46},{68,60}}, textString = "b", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{15, -102},{83, -89}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{11, -96},{ -9, -91},{ -9, -101},{11, -96}}),Line(visible = true, points = {{ -79, -96},{ -8, -96}}, color = {128,128,128})}));
//       protected 
//         SI.Angle b2 = b / 2;
//         constant SI.Angle b_min = 1e-10 "minimum backlash";
//         annotation(Documentation(info = "<html>
// <p>
// This element consists of a <b>backlash</b> element <b>connected in series</b>
// to a <b>spring</b> and <b>damper</b> element which are <b>connected in parallel</b>.
// The spring constant shall be non-zero, otherwise the component cannot be used.
// </p>
// <p>
// In combination with components IdealGear, the ElastoBacklash model
// can be used to model a gear box with backlash, elasticity and damping.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,32},{ -58,32},{ -48,0},{ -34,61},{ -20,0},{ -8,60},{0,30},{20,30}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Rectangle(extent = {{ -60, -20},{ -10, -80}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, pattern = LinePattern.Solid, lineThickness = 0.25, fillColor = {192,192,192}),Line(points = {{ -52, -80},{0, -80}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -52, -20},{0, -20}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -10, -50},{20, -50}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -80, -50},{ -60, -50}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -80,32},{ -80, -50}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{20,30},{20, -50}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{ -90,0},{ -80,0}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{90,0},{80,0}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{20,0},{60,0},{60, -30}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Line(points = {{40, -12},{40, -40},{80, -40},{80,0}}, color = {0,0,0}, pattern = LinePattern.Solid, thickness = 0.25, arrow = {Arrow.None,Arrow.None}),Text(extent = {{ -150, -130},{150, -90}}, textString = "b=%b", fillColor = {0,0,0}),Text(extent = {{ -150,100},{150,60}}, textString = "%name=%c")}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Line(points = {{ -80,32},{ -58,32},{ -48,0},{ -34,60},{ -20,0},{ -8,60},{0,30},{20,30}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -68,32},{ -68,97}}, color = {128,128,128}),Line(points = {{80,0},{80,96}}, color = {128,128,128}),Line(points = {{ -68,92},{72,92}}, color = {128,128,128}),Polygon(points = {{70,95},{80,92},{70,89},{70,95}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Text(extent = {{ -10,70},{30,95}}, textString = "phi_rel", fillColor = {128,128,128}),Rectangle(extent = {{ -60, -20},{ -10, -80}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {192,192,192}),Line(points = {{ -52, -80},{0, -80}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -52, -20},{0, -20}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -10, -50},{20, -50}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -80, -50},{ -60, -50}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -80,32},{ -80, -50}}, color = {0,0,0}, thickness = 0.5),Line(points = {{20,30},{20, -50}}, color = {0,0,0}, thickness = 0.5),Line(points = {{ -96,0},{ -80,0}}, color = {0,0,0}),Line(points = {{96,0},{80,0}}, color = {0,0,0}, thickness = 0.5),Line(points = {{20,0},{60,0},{60, -30}}, color = {0,0,0}, thickness = 0.5),Line(points = {{40, -12},{40, -40},{80, -40},{80,0}}, color = {0,0,0}, thickness = 0.5),Line(points = {{30,0},{30,64}}, color = {128,128,128}),Line(points = {{30,60},{80,60}}, color = {128,128,128}),Polygon(points = {{70,63},{80,60},{70,57},{70,63}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Text(extent = {{39,60},{68,46}}, textString = "b", fillColor = {160,160,160}),Text(extent = {{15, -89},{83, -102}}, textString = "rotation axis", fillColor = {128,128,128}),Polygon(points = {{11, -96},{ -9, -91},{ -9, -101},{11, -96}}, fillPattern = FillPattern.Solid, lineColor = {128,128,128}, fillColor = {128,128,128}),Line(points = {{ -79, -96},{ -8, -96}}, color = {128,128,128})}));
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = if b2 > b_min then if phi_rel > b2 then c * (phi_rel - phi_rel0 - b2) + d * w_rel else if phi_rel <  -b2 then c * (phi_rel - phi_rel0 + b2) + d * w_rel else 0 else c * (phi_rel - phi_rel0) + d * w_rel;
//       end ElastoBacklash;
//       model BearingFriction "Coulomb friction in bearings "
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real tau_pos[:,:] = [0,1] "[w,tau] Positive sliding friction characteristic (w>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*tau_pos[1,2] = Maximum friction torque for w==0";
//         extends Interfaces.FrictionBase;
//         SI.Angle phi;
//         SI.AngularVelocity w "Absolute angular velocity of flange_a and flange_b";
//         SI.AngularAcceleration a "Absolute angular acceleration of flange_a and flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// This element describes <b>Coulomb friction</b> in <b>bearings</b>,
// i.e., a frictional torque acting between a flange and the housing.
// The positive sliding friction torque \"tau\" has to be defined
// by table \"tau_pos\" as function of the absolute angular velocity \"w\".
// E.g.
// <p>
// <pre>
//        w | tau
//       ---+-----
//        0 |   0
//        1 |   2
//        2 |   5
//        3 |   8
// </pre>
// <p>
// gives the following table:
// </p>
// <pre>
//    tau_pos = [0, 0; 1, 2; 2, 5; 3, 8];
// </pre>
// <p>
// Currently, only linear interpolation in the table is supported.
// Outside of the table, extrapolation through the last
// two table entries is used. It is assumed that the negative
// sliding friction force has the same characteristic with negative
// values. Friction is modelled in the following way:
// </p>
// <p>
// When the absolute angular velocity \"w\" is not zero, the friction torque
// is a function of w and of a constant normal force. This dependency
// is defined via table tau_pos and can be determined by measurements,
// e.g. by driving the gear with constant velocity and measuring the
// needed motor torque (= friction torque).
// </p>
// <p>
// When the absolute angular velocity becomes zero, the elements
// connected by the friction element become stuck, i.e., the absolute
// angle remains constant. In this phase the friction torque is
// calculated from a torque balance due to the requirement, that
// the absolute acceleration shall be zero.  The elements begin
// to slide when the friction torque exceeds a threshold value,
// called the maximum static friction torque, computed via:
// </p>
// <pre>
//    maximum_static_friction = <b>peak</b> * sliding_friction(w=0)  (<b>peak</b> >= 1)
// </pre>
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled which have to be solved by appropriate
// numerical methods. The method is described in:
// </p>
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
//  
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{96,10}}),Rectangle(visible = true, extent = {{ -60, -60},{60, -10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -25},{60, -10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -61},{60, -45}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50, -18}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{60, -60},{60, -70},{75, -70},{75, -80},{ -75, -80},{ -75, -70},{ -60, -70},{ -60, -60},{60, -60}}),Line(visible = true, points = {{ -75, -10},{ -75, -70}}),Line(visible = true, points = {{75, -10},{75, -70}}),Rectangle(visible = true, extent = {{ -60,10},{60,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60,45},{60,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60,10},{60,25}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50,19},{50,51}}),Line(visible = true, points = {{ -75,70},{ -75,10}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{60,60},{60,70},{75,70},{75,80},{ -75,80},{ -75,70},{ -60,70},{ -60,60},{60,60}}),Line(visible = true, points = {{75,70},{75,10}}),Line(visible = true, points = {{ -20, -24},{38, -24}}, color = {255,0,0}, thickness = 1),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -20, -19},{ -20, -29},{ -36, -24},{ -20, -19}}),Text(visible = true, fillColor = {255,0,0}, extent = {{ -45, -51},{49, -23}}, textString = "tau (friction torque)", fontName = "Arial"),Text(visible = true, fillColor = {128,128,128}, extent = {{14,84},{82,97}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,90},{ -10,95},{ -10,85},{10,90}}),Line(visible = true, points = {{ -80,90},{ -9,90}}, color = {128,128,128}),Line(visible = true, points = {{ -10, -90},{0, -80}}),Line(visible = true, points = {{ -5, -90},{5, -80}}),Line(visible = true, points = {{0, -90},{10, -80}}),Line(visible = true, points = {{5, -90},{10, -85}}),Line(visible = true, points = {{ -10, -85},{ -5, -80}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{100,10}}),Rectangle(visible = true, extent = {{ -60, -60},{60, -10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -25},{60, -10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -61},{60, -45}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50, -18}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{60, -60},{60, -70},{75, -70},{75, -80},{ -75, -80},{ -75, -70},{ -60, -70},{ -60, -60},{60, -60}}),Line(visible = true, points = {{ -75, -10},{ -75, -70}}),Line(visible = true, points = {{75, -10},{75, -70}}),Rectangle(visible = true, extent = {{ -60,10},{60,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60,45},{60,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60,10},{60,25}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50,19},{50,51}}),Line(visible = true, points = {{ -75,70},{ -75,10}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{60,60},{60,70},{75,70},{75,80},{ -75,80},{ -75,70},{ -60,70},{ -60,60},{60,60}}),Line(visible = true, points = {{75,70},{75,10}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,90},{150,130}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -10, -90},{0, -80}}),Line(visible = true, points = {{ -5, -90},{5, -80}}),Line(visible = true, points = {{0, -90},{10, -80}}),Line(visible = true, points = {{5, -90},{10, -85}}),Line(visible = true, points = {{ -10, -85},{ -5, -80}})}));
//       protected 
//         parameter Modelica.SIunits.Torque unitTorque = 1;
// 
//       equation 
//         tau0 = Modelica.Math.tempInterpol1(0, tau_pos, 2);
//         tau0_max = peak * tau0;
//         free = false;
//         phi = phi_a;
//         phi = phi_b;
//         w = der(phi);
//         a = der(w);
//         w_relfric = w;
//         a_relfric = a;
//         0 = flange_a.tau + flange_b.tau - tau;
//         tau = if locked then sa * unitTorque else if startForward then Modelica.Math.tempInterpol1(w, tau_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w, tau_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w, tau_pos, 2) else  -Modelica.Math.tempInterpol1( -w, tau_pos, 2);
//       end BearingFriction;
//       model Clutch "Clutch based on Coulomb friction "
//         extends Interfaces.Compliant;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         extends Interfaces.FrictionBase;
//         SI.AngularVelocity w_rel "Relative angular velocity (flange_b.w - flange_a.w)";
//         SI.AngularAcceleration a_rel "Relative angular acceleration (flange_b.a - flange_a.a)";
//         Real mue0 "Friction coefficient for w=0 and forward sliding";
//         SI.Force fn "Normal force (fn=fn_max*inPort.signal)";
//         annotation(Documentation(info = "<html>
// <p>
// This component models a <b>clutch</b>, i.e., a component with
// two flanges where friction is present between the two flanges
// and these flanges are pressed together via a normal force.
// The normal force fn has to be provided as input signal f_normalized in a normalized form
// (0 &le; f_normalized &le; 1),
// fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
// clutch is modelled in the following way:
// </p>
// <p>
// When the relative angular velocity is not zero, the friction torque is a
// function of the velocity dependent friction coefficient  mue(w_rel) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
// </pre>
// <p>
//    Typical values of coefficients of friction:
// </p>
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// </pre>
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w_rel),
//     w_rel >= 0, is defined via table mue_pos (first column = w_rel,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// <p>
//    When the relative angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the relative
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the relative acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
// <br>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{ -30,40},{ -60,50},{ -60,30},{ -30,40}}),Line(visible = true, points = {{0,90},{ -90,70},{ -90,40},{ -30,40}}, color = {0,0,191}),Line(visible = true, points = {{0,90},{90,70},{90,40},{30,40}}, color = {0,0,191}),Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{30,40},{60,50},{60,30},{30,40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -60},{30,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -30, -60},{ -10,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{30, -10},{100,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -30,10}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -70}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -30,40},{ -60,50},{ -60,30},{ -30,40}}),Line(visible = true, points = {{0,90},{ -90,70},{ -90,40},{ -30,40}}),Line(visible = true, points = {{0,90},{90,70},{90,40},{30,40}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30,40},{60,50},{60,30},{30,40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -60},{30,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -30, -60},{ -10,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{30, -10},{96,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -30,10}}),Text(visible = true, fillColor = {128,128,128}, extent = {{19, -103},{87, -90}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{15, -97},{ -5, -92},{ -5, -102},{15, -97}}),Line(visible = true, points = {{ -75, -97},{ -4, -97}}, color = {128,128,128})}));
//         Modelica.Blocks.Interfaces.RealInput f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)" annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90)));
//       protected 
//         parameter Modelica.SIunits.Torque unitTorque = 1;
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         w_relfric = w_rel;
//         a_relfric = a_rel;
//         fn = fn_max * f_normalized;
//         free = fn <= 0;
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = peak * tau0;
//         tau = if locked then sa * unitTorque else if free then 0 else cgeo * fn * (if startForward then Modelica.Math.tempInterpol1(w_rel, mue_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w_rel, mue_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w_rel, mue_pos, 2) else  -Modelica.Math.tempInterpol1( -w_rel, mue_pos, 2));
//       end Clutch;
//       model OneWayClutch "Series connection of freewheel and clutch"
//         extends Interfaces.Compliant;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         parameter SI.AngularVelocity w_small = 10000000000.0 "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)" annotation(Dialog(tab = "Advanced"));
//         SI.AngularVelocity w_rel "Relative angular velocity (flange_b.w - flange_a.w)";
//         SI.AngularAcceleration a_rel "Relative angular acceleration (flange_b.a - flange_a.a)";
//         Real u "normalized force input signal (0..1)";
//         SI.Force fn "Normal force (fn=fn_max*inPort.signal)";
//         Boolean startForward "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
//         Boolean locked "true, if w_rel=0 and not sliding";
//         Boolean stuck(final start = false) "w_rel=0 (forward sliding or locked)";
//         annotation(Documentation(info = "<html>
// <p>
// This component models a <b>one-way clutch</b>, i.e., a component with
// two flanges where friction is present between the two flanges
// and these flanges are pressed together via a normal force. These
// flanges maybe sliding with respect to each other
// Parallel connection of ClutchCombi and of FreeWheel.
//                      The element is introduced to resolve the ambiguity
//                      of the constraint torques of the elements.
// <p>
// A one-way-clutch is an element where a clutch is connected in parallel
// to a free wheel. This special element is provided, because such
// a parallel connection introduces an ambiguity into the model
// (the constraint torques are not uniquely defined when both
// elements are stuck) and this element resolves it by introducing
// <b>one</b> constraint torque and not two.
// </p>
// <p>
// Note, initial values have to be chosen for the model, such that the
// relative speed of the one-way-clutch >= 0. Otherwise, the configuration
// is physically not possible and an error occurs.
// </p>
// <p>
// The normal force fn has to be provided as input signal f_normalized in a normalized form
// (0 &le; f_normalized &le; 1),
// fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
// clutch is modelled in the following way:
// </p>
// <p>
// When the relative angular velocity is positive, the friction torque is a
// function of the velocity dependent friction coefficient  mue(w_rel) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
// </pre>
// <p>
//    Typical values of coefficients of friction:
// </p>
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// </pre>
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w_rel),
//     w_rel >= 0, is defined via table mue_pos (first column = w_rel,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// <p>
//    When the relative angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the relative
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the relative acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -30,40},{ -60,50},{ -60,30},{ -30,40}}),Line(visible = true, points = {{0,90},{ -90,70},{ -90,40},{ -30,40}}),Line(visible = true, points = {{0,90},{90,70},{90,40},{30,40}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{30,40},{60,50},{60,30},{30,40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -60},{30,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -30, -60},{ -10,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{30, -10},{96,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -30,10}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -10,30},{50,0},{ -10, -30},{ -10,30}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{ -30,40},{ -60,50},{ -60,30},{ -30,40}}),Line(visible = true, points = {{0,90},{ -90,70},{ -90,40},{ -30,40}}, color = {0,0,191}),Line(visible = true, points = {{0,90},{90,70},{90,40},{30,40}}, color = {0,0,191}),Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{30,40},{60,50},{60,30},{30,40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{10, -60},{30,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -30, -60},{ -10,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{30, -10},{100,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -30,10}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -110},{150, -70}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -10,30},{50,0},{ -10, -30},{ -10,30}})}));
//         Modelica.Blocks.Interfaces.RealInput f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)" annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90)));
//       protected 
//         SI.Torque tau0 "Friction torque for w=0 and sliding";
//         SI.Torque tau0_max "Maximum friction torque for w=0 and locked";
//         Real mue0 "Friction coefficient for w=0 and sliding";
//         Boolean free "true, if frictional element is not active";
//         Real sa "path parameter of tau = f(a_rel) Friction characteristic";
//         constant Real eps0 = 0.0001 "Relative hysteresis epsilon";
//         SI.Torque tau0_max_low "lowest value for tau0_max";
//         parameter Real peak2 = max([peak,1 + eps0]);
//         parameter SI.AngularAcceleration unitAngularAcceleration = 1;
//         parameter SI.Torque unitTorque = 1;
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         tau0_max_low = eps0 * mue0 * cgeo * fn_max;
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         u = f_normalized;
//         free = u <= 0;
//         fn = if free then 0 else fn_max * u;
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = if free then tau0_max_low else peak2 * tau0;
//         startForward = pre(stuck) and (sa > tau0_max / unitTorque or pre(startForward) and sa > tau0 / unitTorque or w_rel > w_small) or initial() and w_rel > 0;
//         locked = pre(stuck) and not startForward;
//         a_rel = unitAcceleration * (if locked then 0 else sa - tau0 / unitTorque);
//         tau = if locked then sa * unitTorque else if free then 0 else cgeo * fn * Modelica.Math.tempInterpol1(w_rel, mue_pos, 2);
//         stuck = locked or w_rel <= 0;
//       end OneWayClutch;
//       model Brake "Brake based on Coulomb friction "
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         extends Interfaces.FrictionBase;
//         SI.Angle phi;
//         SI.AngularVelocity w "Absolute angular velocity of flange_a and flange_b";
//         SI.AngularAcceleration a "Absolute angular acceleration of flange_a and flange_b";
//         Real mue0 "Friction coefficient for w=0 and forward sliding";
//         SI.Force fn "Normal force (=fn_max*inPort.signal)";
//         annotation(Documentation(info = "<html>
// <p>
// This component models a <b>brake</b>, i.e., a component where a frictional
// torque is acting between the housing and a flange and a controlled normal
// force presses the flange to the housing in order to increase friction.
// The normal force fn has to be provided as input signal f_normalized in a normalized form
// (0 &le; f_normalized &le; 1),
// fn = fn_max*f_normalized, where fn_max has to be provided as parameter.
// Friction in the brake is modelled in the following way:
// </p>
// <p>
// When the absolute angular velocity \"w\" is not zero, the friction torque
// is a function of the velocity dependent friction coefficient  mue(w) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w) * <b>fn</b>
// </pre>
// <p>
//    Typical values of coefficients of friction:
// </p>
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// </pre>
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w),
//     w >= 0, is defined via table mue_pos (first column = w,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// <p>
//    When the absolute angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the absolute
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the absolute acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -37, -55},{ -37, -90},{37, -90},{37, -55},{33, -55},{33, -86},{ -33, -86},{ -33, -55},{ -37, -55}}),Text(visible = true, fillColor = {128,128,128}, extent = {{14, -76},{82, -63}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{0, -70},{ -20, -65},{ -20, -75},{0, -70}}),Line(visible = true, points = {{ -90, -70},{ -19, -70}}, color = {128,128,128}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -20,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -10},{96,10}}),Line(visible = true, points = {{0,90},{ -80,70},{ -80, -40},{ -70, -40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20, -60},{20,60}}),Line(visible = true, points = {{0,90},{80,70},{80, -40},{70, -40}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{40, -40},{70, -30},{70, -50},{40, -40}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -40, -40},{ -70, -30},{ -70, -50},{ -40, -40}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -40, -55},{ -30, -25}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{30, -55},{40, -25}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -37, -55},{ -37, -90},{37, -90},{37, -55},{33, -55},{33, -86},{ -33, -86},{ -33, -55},{ -37, -55}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -20,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20, -60},{20,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -10},{100,10}}),Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{40, -40},{70, -30},{70, -50},{40, -40}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{30, -55},{40, -25}}),Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{ -40, -40},{ -70, -30},{ -70, -50},{ -40, -40}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -40, -55},{ -30, -25}}),Line(visible = true, points = {{0,90},{80,70},{80, -40},{70, -40}}, color = {0,0,191}),Line(visible = true, points = {{0,90},{ -80,70},{ -80, -40},{ -70, -40}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -180},{150, -140}}, textString = "%name", fontName = "Arial")}));
//         Modelica.Blocks.Interfaces.RealInput f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if > 0)" annotation(Placement(visible = true, transformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90), iconTransformation(origin = {0,110}, extent = {{ -20,20},{20, -20}}, rotation =  -90)));
//       protected 
//         parameter SI.Torque unitTorque = 1;
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         phi = phi_a;
//         phi = phi_b;
//         w = der(phi);
//         a = der(w);
//         w_relfric = w;
//         a_relfric = a;
//         0 = flange_a.tau + flange_b.tau - tau;
//         fn = fn_max * f_normalized;
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = peak * tau0;
//         free = fn <= 0;
//         tau = if locked then sa * unitTorque else if free then 0 else cgeo * fn * (if startForward then Modelica.Math.tempInterpol1(w, mue_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w, mue_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w, mue_pos, 2) else  -Modelica.Math.tempInterpol1( -w, mue_pos, 2));
//       end Brake;
//       model LossyGear "Gear with mesh efficiency and bearing friction (stuck/rolling possible)"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real i = 1 "Transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real lossTable[:,5] = [0,1,1,0,0] "Array for mesh efficiencies and bearing friction depending on speed";
//         Real sa "path parameter for acceleration and torque loss";
//         SI.AngularVelocity w_a "angular velocity of flange_a";
//         SI.AngularAcceleration a_a "angular acceleration of flange_a";
//         Real interpolation_result[1,size(lossTable, 2) - 1];
//         Real eta_mf1;
//         Real eta_mf2;
//         Real tau_bf1;
//         Real tau_bf2;
//         Real quadrant1;
//         Real quadrant2;
//         Real quadrant3;
//         Real quadrant4;
//         SI.Torque tauLoss "Torque loss due to friction in the gear teeth and in the bearings";
//         SI.Torque tauLossMax "Torque loss for positive speed";
//         SI.Torque tauLossMin "Torque loss for negative speed";
//         Boolean tau_aPos "true, if torque of flange_a is not negative";
//         Boolean startForward "true, if starting to roll forward";
//         Boolean startBackward "true, if starting to roll backward";
//         Boolean locked "true, if gear is locked";
//         Boolean ideal "true, if losses are neglected";
//         constant Integer Unknown = 3 "Value of mode is not known";
//         constant Integer Free = 2 "Element is not active";
//         constant Integer Forward = 1 "w_a > 0 (forward rolling)";
//         constant Integer Stuck = 0 "w_a = 0 (forward rolling, locked or backward rolling)";
//         constant Integer Backward =  -1 "w_a < 0 (backward rolling)";
//         Integer mode(final min = Backward, final max = Unknown, start = Free, fixed = true);
//         annotation(Documentation(info = "<HTML>
// <p>
// This component models the gear ratio and the <b>losses</b> of
// a standard gear box in a <b>reliable</b> way including the stuck phases
// that may occur at zero speed. The gear boxes that can
// be handeled are fixed in the ground, have one input and one
// output shaft, and are essentially described by the equations:
// </p>
// <pre>     flange_a.phi  = i*flange_b.phi
//    (-flange_b.tau) = i*(eta_mf*flange_a.tau - tau_bf)
// </pre>
// <p>
// where
// </p>
// <ul>
// <li><b>i</b> is the constant <b>gear ratio</b>,</li>
// <li><b>eta_mf</b> = eta_mf(w) is the <b>mesh efficiency</b> due to the
//    friction between the teeth of the gear wheels, </li>
// <li><b>tau_bf</b> = tau_bf(w) is the <b>bearing friction torque</b>, and</li>
// <li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
// </ul>
// <p>The loss terms \"eta_mf\" and \"tau_bf\" are functions of the
// <i>absolute value</i> of the input shaft speed w_a and of the energy
// flow direction. They are defined by parameter <b>lossTable[:,5]
// </b> where the columns of this table have the following
// meaning:</p>
// <p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
//   <tbody>
//     <tr>
//       <td>|w_a|</td>
//       <td>eta_mf1</td>
//       <td>eta_mf2</td>
//       <td>|tau_bf1|</td>
//       <td>|tau_bf2|</td>
//     </tr>
//     <tr>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//     </tr>
//     <tr>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//     </tr>
//   </tbody>
// </table></p>
// <p>with</p>
// <p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
//   <tbody>
//     <tr>
//       <td>|w_a|</td>
//       <td>Absolute value of angular velocity of input shaft flange_a</td>
//     </tr>
//     <tr>
//       <td>eta_mf1</td>
//       <td>Mesh efficiency in case of input shaft driving</td>
//     </tr>
//     <tr>
//       <td>eta_mf2</td>
//       <td>Mesh efficiency in case of output shaft driving</td>
//     </tr>
//     <tr>
//       <td>|tau_bf1|</td>
//       <td>Absolute bearing friction torque in case of input shaft driving</td>
//     </tr>
//     <tr>
//       <td>|tau_bf2|</td>
//       <td>Absolute bearing friction torque in case of output shaft driving</td>
//     </tr>
//   </tbody>
// </table></p>
// <p>
// With these variables, the mesh efficiency and the bearing friction
// are formally defined as:
// </p>
// <pre>  <b>if</b> flange_a.tau*w_a > 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a > 0 <b>then</b>
//      eta_mf := eta_mf1
//      tau_bf := tau_bf1
//   <b>elseif</b> flange_a.tau*w_a &lt; 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a &lt; 0 <b>then</b>
//      eta_mf := 1/eta_mf2
//      tau_bf := tau_bf2
//   <b>else</b> // w_a == 0
//      eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
//   <b>end if</b>;
// </pre>
// <p>Note, that the losses are modeled in a physically meaningful way taking
// into account that at zero speed the movement may be locked due
// to the friction in the gear teeth and/or in the bearings.
// Due to this important property, this component can be used in
// situations where the combination of the components
// Modelica.Mechanics.Rotational.IdealGear and
// Modelica.Mechanics.Rotational.GearEfficiency will fail because,
// e.g., chattering occurs when using the
// Modelica.Mechanics.Rotational.GearEfficiency model.
// </p>
// <p>
// <b>Acknowledgement:</b> The essential idea to model efficiency
// in this way is from Christoph Pelchen, ZF Friedrichshafen.
// </p>
// <p><b>For detailed information:</b></p>
// <p>Pelchen C.,
// <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
// and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
// &quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
// and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
// <I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
// pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
// Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -20},{ -20,20}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40,20},{ -20,140}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20,60},{40,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -60},{40,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -10},{ -40,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{96,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20,70},{20,90}}),Line(visible = true, points = {{ -94, -76},{ -23, -76}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -4, -76},{ -24, -71},{ -24, -81},{ -4, -76}}),Text(visible = true, fillColor = {128,128,128}, extent = {{19, -83},{87, -70}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -80,20},{ -60,20}}),Line(visible = true, points = {{ -80, -20},{ -60, -20}}),Line(visible = true, points = {{ -70, -20},{ -70, -70}}),Line(visible = true, points = {{70, -70},{ -70, -70}}),Line(visible = true, points = {{0,60},{0, -90}}),Line(visible = true, points = {{ -10,60},{10,60}}),Line(visible = true, points = {{ -10,100},{10,100}}),Line(visible = true, points = {{60,20},{80,20}}),Line(visible = true, points = {{60, -20},{80, -20}}),Line(visible = true, points = {{70, -20},{70, -70}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -20},{ -20,20}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40,20},{ -20,140}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20,60},{40,100}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{20, -60},{40,60}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{40, -10},{100,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -20,70},{20,90}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -40,10}}),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -111,30},{ -70,30},{ -70,100},{ -40,100},{ -60,121},{ -80,100},{ -49,100},{ -49,20},{ -111,20},{ -111,30}}),Line(visible = true, points = {{ -80,20},{ -60,20}}),Line(visible = true, points = {{ -80, -20},{ -60, -20}}),Line(visible = true, points = {{ -70, -20},{ -70, -70}}),Line(visible = true, points = {{70, -70},{ -70, -70}}),Line(visible = true, points = {{0,60},{0, -90}}),Line(visible = true, points = {{ -10,60},{10,60}}),Line(visible = true, points = {{ -10,100},{10,100}}),Line(visible = true, points = {{60,20},{80,20}}),Line(visible = true, points = {{60, -20},{80, -20}}),Line(visible = true, points = {{70, -20},{70, -70}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,140},{150,180}}, textString = "%name=%i", fontName = "Arial")}));
//       protected 
//         function equal "Compare whether two Real matrices are identical"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           input Real B[:,:];
//           input Real eps = Modelica.Constants.eps "two numbers r1, r2 are identical if abs(r1-r2) <= eps";
//           output Boolean result;
//         algorithm 
//           result:=false;
//           if size(A, 1) == size(B, 1) and size(A, 2) == size(B, 2) then 
//                     result:=true;
//           for i in 1:size(A, 1) loop
//                       for j in 1:size(A, 2) loop
//                           if abs(A[i,j] - B[i,j]) >= eps then 
//                             result:=false;
// 
//               else 
//               end if;
// 
//             end for;
// 
//           end for;
// 
//           else 
//           end if;
//           annotation(Documentation(info = "<HTML>
// <p>
// The function call
// </p>
// <pre>     equal(A1, A2);
// </pre>
// <p>
// returns <b>true</b>, if the two Real matrices A1 and A2 have the
// same dimensions and the same elements. Otherwise the function
// returns <b>false</b>. Two elements r1 and r2 of A1 and A2 respectively
// are checked on equality by the test 'eps >= abs(r1-r2)', where 'eps'
// can be provided as third argument of the function (the default is
// Modelica.Constants.eps).
// </p>
// </HTML>"));
//         end equal;
//         parameter SI.Torque unitTorque = 1;
//         parameter SI.AngularAcceleration unitAcceleration = 1;
// 
//       equation 
//         assert(abs(i) > 0, "Error in initialization of LossyGear: i may not be zero");
//         ideal = equal(lossTable, [0,1,1,0,0]);
//         interpolation_result = if ideal then [1,1,0,0] else Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
//         eta_mf1 = interpolation_result[1,1];
//         eta_mf2 = interpolation_result[1,2];
//         tau_bf1 = noEvent(abs(interpolation_result[1,3]));
//         tau_bf2 = noEvent(abs(interpolation_result[1,4]));
//         phi_a = i * phi_b;
//         0 = flange_b.tau + i * (flange_a.tau - tauLoss);
//         w_a = der(phi_a);
//         a_a = der(w_a);
//         quadrant1 = (1 - eta_mf1) * flange_a.tau + tau_bf1;
//         quadrant2 = (1 - 1 / eta_mf2) * flange_a.tau + tau_bf2;
//         quadrant4 = (1 - 1 / eta_mf2) * flange_a.tau - tau_bf2;
//         quadrant3 = (1 - eta_mf1) * flange_a.tau - tau_bf1;
//         tau_aPos = ideal or flange_a.tau >= 0;
//         tauLossMax = if tau_aPos then quadrant1 else quadrant2;
//         tauLossMin = if tau_aPos then quadrant4 else quadrant3;
//         startForward = pre(mode) == Stuck and sa > tauLossMax / unitTorque or initial() and w_a > 0;
//         startBackward = pre(mode) == Stuck and sa < tauLossMin / unitTorque or initial() and w_a < 0;
//         locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//         tauLoss = if ideal then 0 else if locked then sa * unitTorque else if startForward or pre(mode) == Forward then tauLossMax else tauLossMin;
//         a_a = unitAcceleration * (if locked then 0 else sa - tauLoss / unitTorque);
//         mode = if ideal then Free else if (pre(mode) == Forward or startForward) and w_a > 0 then Forward else if (pre(mode) == Backward or startBackward) and w_a < 0 then Backward else Stuck;
//       end LossyGear;
//       model GearEfficiency "Obsolete component (use model LossyGear instead)"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real eta(min = Modelica.Constants.small, max = 1) = 1 "Efficiency";
//         SI.Angle phi;
//         SI.Power power_a "Energy flowing into flange_a (= power)";
//         Boolean driving_a "True, if energy is flowing INTO and not out of flange flange_a";
//         annotation(obsolete = "This model can get stuck due when the torque direction varies, use LossyGear instead.", Documentation(info = "<html>
// <p>
// THIS COMPONENT IS <b>OBSOLETE</b> and should <b>no longer be used</b>. It is only
// kept for <b>backward compatibility</b> purposes. Use model
// Modelica.Mechanics.Rotational.LossyGear instead which implements
// gear efficiency in a much more reliable way.
// </p>
// <p>
// This component consists of two rigidly connected flanges flange_a and flange_b without
// inertia where an <b>efficency</b> coefficient <b>eta</b> reduces the driven
// torque as function of the driving torque depending on the direction
// of the energy flow, i.e., energy is always lost. This can be seen as a
// simple model of the Coulomb friction acting between the teeth of a
// gearbox.
// </p>
// <p>
// Note, that most gearbox manufacturers provide tables of the
// efficiency of a gearbox as function of the angular velocity
// (efficiency becomes zero, if the angular velocity is zero).
// However, such a table is practically useless for simulation purposes,
// because in gearboxes always two types of friction is present:
// (1) Friction in the <b>bearings</b> and (2) friction between
// the teeth of the gear. (1) leads to a velocity dependent, additive
// loss-torque, whereas (2) leads to a torque-dependent reduction of the
// driving torque. The gearbox manufacturers measure both effects
// together and determine the gear efficiency from it, although for
// simulation purposes the two effects need to be separated.
// Assume for example that only constant bearing friction, i.e.,
// bearingTorque=const., is present, i.e.,
// </p>
// <pre>
//    (1)  loadTorque = motorTorque - sign(w)*bearingTorque
// </pre>
// <p>
// Gearbox manufacturers use the loss-formula
// </p>
// <pre>
//    (2)  loadTorque = eta*motorTorque
// </pre>
// <p>
// Comparing (1) and (2) gives a formulat for the efficiency eta:
// </p>
// <pre>
//    eta = (1 - sign(w)*bearingTorque/motorTorque)
// </pre>
// <p>
// When the motorTorque becomes smaller as the bearingTorque,
// (2) is useless, because the efficiency is zero. To summarize,
// be careful to determine the gear <b>efficiency</b> of this element
// from tables of the gear manufacturers.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -96, -21},{96,20}}),Line(visible = true, points = {{ -30, -40},{30, -40}}),Line(visible = true, points = {{0,60},{0,40}}),Line(visible = true, points = {{ -30,40},{29,40}}),Line(visible = true, points = {{0, -40},{0, -90}}),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -30, -20},{60, -20},{60, -80},{70, -80},{50, -100},{30, -80},{40, -80},{40, -30},{ -30, -30},{ -30, -20},{ -30, -20}}),Text(visible = true, fillColor = {128,128,128}, extent = {{16,70},{84,83}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{12,76},{ -8,81},{ -8,71},{12,76}}),Line(visible = true, points = {{ -78,76},{ -7,76}}, color = {128,128,128}),Line(visible = true, points = {{30, -50},{20, -60}}),Line(visible = true, points = {{30, -40},{10, -60}}),Line(visible = true, points = {{20, -40},{0, -60}}),Line(visible = true, points = {{10, -40},{ -10, -60}}),Line(visible = true, points = {{0, -40},{ -20, -60}}),Line(visible = true, points = {{ -10, -40},{ -30, -60}}),Line(visible = true, points = {{ -20, -40},{ -30, -50}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,100}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -40},{30, -40}}),Line(visible = true, points = {{0, -40},{0, -90}}),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -30, -20},{60, -20},{60, -80},{70, -80},{50, -100},{30, -80},{40, -80},{40, -30},{ -30, -30},{ -30, -20},{ -30, -20}}),Text(visible = true, extent = {{ -150,20},{150,60}}, textString = "eta=%eta", fontName = "Arial"),Line(visible = true, points = {{30, -50},{20, -60}}),Line(visible = true, points = {{30, -40},{10, -60}}),Line(visible = true, points = {{20, -40},{0, -60}}),Line(visible = true, points = {{10, -40},{ -10, -60}}),Line(visible = true, points = {{0, -40},{ -20, -60}}),Line(visible = true, points = {{ -10, -40},{ -30, -60}}),Line(visible = true, points = {{ -20, -40},{ -30, -50}})}));
// 
//       equation 
//         phi = phi_a;
//         phi = phi_b;
//         power_a = flange_a.tau * der(phi);
//         driving_a = power_a >= 0;
//         flange_b.tau =  -(if driving_a then eta * flange_a.tau else flange_a.tau / eta);
//       end GearEfficiency;
//       model Gear "Realistic model of a gearbox"
//         extends Interfaces.TwoFlangesAndBearingH;
//         parameter Real ratio = 1 "transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real eta(min = Modelica.Constants.small, max = 1) = 1 "Gear efficiency";
//         parameter Real friction_pos[:,:] = [0,1] "[w,tau] positive sliding friction characteristic (w>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*friction_pos[1,2] = maximum friction torque at zero velocity";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Gear elasticity (spring constant)";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "(relative) gear damping";
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         annotation(Documentation(info = "<html>
// <p>
// This component models the essential effects of a gearbox, in particular
// gear <b>efficiency</b> due to friction between the teeth, <b>bearing friction</b>,
// gear <b>elasticity</b> and <b>damping</b>, <b>backlash</b>.
// The inertia of the gear wheels is not modeled. If necessary, inertia
// has to be taken into account by connecting components of model Inertia
// to the left and/or the right flange.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {128,128,128}, extent = {{2,22},{46,29}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{4,25},{ -4,27},{ -4,23},{4,25}}),Line(visible = true, points = {{ -36,25},{ -3,25}}, color = {128,128,128})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -60},{40,60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -60, -80},{ -46, -80},{ -20, -20},{20, -20},{46, -80},{60, -80},{60, -90},{ -60, -90},{ -60, -80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -60,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{60, -10},{100,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -60,10},{ -60,20},{ -40,40},{ -40, -40},{ -60, -20},{ -60,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{60,20},{40,40},{40, -40},{60, -20},{60,20}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,70},{150,110}}, textString = "%name=%ratio", fontName = "Arial"),Text(visible = true, extent = {{ -150, -160},{150, -120}}, textString = "c=%c", fontName = "Arial")}));
//         IdealGear gearRatio(final ratio = ratio) annotation(Placement(visible = true, transformation(origin = { -60,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         GearEfficiency gearEfficiency(final eta = eta) annotation(Placement(visible = true, transformation(origin = { -20,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         ElastoBacklash elastoBacklash(final b = b, final c = c, final phi_rel0 = 0, final d = d) annotation(Placement(visible = true, transformation(origin = {60,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         BearingFriction bearingFriction(final tau_pos = friction_pos, final peak = peak) annotation(Placement(visible = true, transformation(origin = {20,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(elastoBacklash.flange_b,flange_b) annotation(Line(visible = true, origin = {85,0}, points = {{ -15,0},{15,0}}));
//         connect(flange_a,gearRatio.flange_a) annotation(Line(visible = true, origin = { -85,0}, points = {{ -15,0},{15,0}}));
//         connect(bearingFriction.bearing,adapter.flange_b) annotation(Line(visible = true, points = {{20, -10},{20, -40},{6.12303e-16, -40},{0, -70}}));
//         connect(gearEfficiency.bearing,adapter.flange_b) annotation(Line(visible = true, points = {{ -20, -10},{ -20, -40},{6.12303e-16, -40},{0, -70}}));
//         connect(gearRatio.bearing,adapter.flange_b) annotation(Line(visible = true, points = {{ -60, -10},{ -60, -40},{6.12303e-16, -40},{0, -70}}));
//         connect(bearingFriction.flange_b,elastoBacklash.flange_a) annotation(Line(visible = true, points = {{30,0},{50,0}}));
//         connect(gearEfficiency.flange_b,bearingFriction.flange_a) annotation(Line(visible = true, points = {{ -10,0},{10,0}}));
//         connect(gearRatio.flange_b,gearEfficiency.flange_a) annotation(Line(visible = true, points = {{ -50,0},{ -30,0}}));
//       end Gear;
//       model Gear2 "Realistic model of a gearbox (based on LossyGear)"
//         extends Interfaces.TwoFlangesAndBearingH;
//         parameter Real i = 1 "transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real lossTable[:,5] = [0,1,1,0,0] "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Gear elasticity (spring constant)";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "(relative) gear damping";
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         annotation(Documentation(info = "<html>
// <p>This component models the essential effects of a gearbox, in
// particular</p>
// <ul>
//   <li>in component <b>lossyGear</b></li>
//     <ul>
//       <li>gear <b>efficiency</b> due to friction between the teeth</li>
//       <li><b>bearing friction</b></li>
//     </ul>
//   <li>in component <b>elastoBacklash</b></li>
//     <ul>
//       <li>gear <b>elasticity</b></li>
//       <li><b>damping</b></li>
//       <li><b>backlash</b></li>
//     </ul>
// </ul>
// <p>The inertia of the gear wheels is not modeled. If necessary,
// inertia has to be taken into account by connecting components of
// model Inertia to the left and/or the right flange of component
// GearNew.</p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {128,128,128}, extent = {{2,57},{46,64}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{4,60},{ -4,62},{ -4,58},{4,60}}),Line(visible = true, points = {{ -36,60},{ -3,60}}, color = {128,128,128})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -10},{ -60,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{60, -10},{100,10}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -60},{40,60}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -60,10},{ -60,20},{ -40,40},{ -40, -40},{ -60, -20},{ -60,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{60,20},{40,40},{40, -40},{60, -20},{60,20}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,70},{150,110}}, textString = "%name=%i", fontName = "Arial"),Text(visible = true, extent = {{ -150, -160},{150, -120}}, textString = "c=%c", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -60, -80},{ -46, -80},{ -20, -20},{20, -20},{46, -80},{60, -80},{60, -90},{ -60, -90},{ -60, -80}})}));
//         LossyGear lossyGear(final i = i, final lossTable = lossTable) annotation(Placement(visible = true, transformation(origin = { -40,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         ElastoBacklash elastoBacklash(final b = b, final c = c, final phi_rel0 = 0, final d = d) annotation(Placement(visible = true, transformation(origin = {40,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         connect(elastoBacklash.flange_b,flange_b) annotation(Line(visible = true, origin = {80,0}, points = {{ -20,0},{20,0}}));
//         connect(flange_a,lossyGear.flange_a) annotation(Line(visible = true, origin = { -80,0}, points = {{ -20,0},{20,0}}));
//         connect(lossyGear.bearing,adapter.flange_b) annotation(Line(visible = true, points = {{ -40, -20},{ -40, -40},{6.12303e-16, -40},{0, -70}}));
//         connect(lossyGear.flange_b,elastoBacklash.flange_a) annotation(Line(visible = true, points = {{ -20,0},{20,0}}));
//       end Gear2;
//       model Position "Forced movement of a flange according to a reference angle signal"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal" annotation(Dialog(enable = not exact));
//         output SI.Angle phi "absolute rotation angle of flange flange_b";
//         output SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         output SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>phi_ref</b> defines the <b>reference
// angle</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference angle is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference angle is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Line(visible = true, points = {{ -80,80},{ -10,80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,80},{ -10,85},{ -10,75},{10,80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{50,73},{50,87}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Text(visible = true, extent = {{ -172, -90},{ -56, -56}}, textString = "phi_ref", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,100}}, textString = "%name", fontName = "Arial")}));
//         Modelica.Blocks.Interfaces.RealInput phi_ref(redeclare type SignalType = SI.Angle) "reference angle of flange_b as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.Flange_a bearing annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         parameter Real w_crit = 2 * Modelica.Constants.pi * f_crit "critical frequency in [1/s]";
//         constant Real af = 1.3617 "s coefficient of Bessel filter";
//         constant Real bf = 0.618 "s*s coefficient of Bessel filter";
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         if exact then
//           phi = phi_ref;
// 
//         else
//           a = (((phi_ref - phi) * w_crit - af * w) * w_crit) / bf;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   phi = phi_ref;
//         end if;
//       end Position;
//       model Speed "Forced movement of a flange according to a reference angular velocity signal"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal";
//         SI.Angle phi_ref "reference angle defined by time integration of input signal";
//         SI.Angle phi "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>w_ref</b> defines the <b>reference
// angle</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference angle is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference angle is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>.<br>
//        Realized based on component <tt>Position</tt> (implemented by
//        <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>).</li>
// </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{30, -42},{20, -52}}),Text(visible = true, extent = {{ -158, -78},{ -54, -44}}, textString = "w_ref", fontName = "Arial"),Text(visible = true, extent = {{0,60},{0,120}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Line(visible = true, points = {{ -80,80},{ -10,80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,80},{ -10,85},{ -10,75},{10,80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{50,73},{50,87}}, textString = "rotation axis", fontName = "Arial")}));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Interfaces.RealInput w_ref(redeclare type SignalType = SI.AngularVelocity) "Reference angular velocity of flange_b as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_a bearing annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         parameter Real w_crit = 2 * Constants.pi * f_crit "critical frequency in [1/s]";
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         der(phi_ref) = w_ref;
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         if exact then
//           w = w_ref;
// 
//         else
//           a = (w_ref - w) * w_crit;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   w = w_ref;
//         end if;
//       end Speed;
//       model Accelerate "Forced movement of a flange according to an acceleration signal"
//         parameter SI.Angle phi_start = 0 "Start angle";
//         parameter SI.AngularVelocity w_start = 0 "Start angular velocity";
//         SI.Angle phi(final start = phi_start, final fixed = true) "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w(final start = w_start, final fixed = true) "absolute angular velocity of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         annotation(Documentation(info = "<html>
// <p>
// The input signal <b>a</b> defines an <b>angular acceleration</b>
// in [rad/s2]. Flange <b>flange_b</b> is <b>forced</b> to move with
// this acceleration. The angular velocity <b>w</b> and the rotation angle
// <b>phi</b> of the flange are automatically determined by integration of
// the acceleration.
// </p>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Line(visible = true, points = {{ -80,80},{ -10,80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,80},{ -10,85},{ -10,75},{10,80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{50,73},{50,87}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Text(visible = true, extent = {{ -144, -86},{ -84, -48}}, textString = "a", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,60},{150,100}}, textString = "%name", fontName = "Arial")}));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Blocks.Interfaces.RealInput a(redeclare type SignalType = SI.AngularAcceleration) "absolute angular acceleration of flange_b as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_a bearing annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//       end Accelerate;
//       model Move "Forced movement of a flange according to an angle, speed and angular acceleration signal"
//         SI.Angle phi "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         annotation(Documentation(info = "<html>
// <p>
// Flange <b>flange_b</b> is <b>forced</b> to move with a predefined motion
// according to the input signals:
// </p>
// <pre>
//     u[1]: angle of flange
//     u[2]: angular velocity of flange
//     u[3]: angular acceleration of flange
// </pre>
// <p>
// The user has to guarantee that the input signals are consistent to each other,
// i.e., that u[2] is the derivative of u[1] and that
// u[3] is the derivative of u[2]. There are, however,
// also applications where by purpose these conditions do not hold. For example,
// if only the position dependent terms of a mechanical system shall be
// calculated, one may provide angle = angle(t) and set the angular velocity
// and the angular acceleration to zero.
// </p>
// <p>
// The input signals can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </html>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Text(visible = true, fillColor = {128,128,128}, extent = {{50,73},{50,87}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,80},{ -10,85},{ -10,75},{10,80}}),Line(visible = true, points = {{ -80,80},{ -10,80}}, color = {128,128,128}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Text(visible = true, extent = {{ -100,40},{ -100,80}}, textString = "phi,w,a", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}}),Text(visible = true, extent = {{ -80, -100},{ -80, -60}}, textString = "phi,w,a", fontName = "Arial"),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -20},{100,20}}),Line(visible = true, points = {{ -30, -32},{30, -32}}),Line(visible = true, points = {{0,52},{0,32}}),Line(visible = true, points = {{ -29,32},{30,32}}),Line(visible = true, points = {{0, -32},{0, -90}}),Line(visible = true, points = {{30, -42},{20, -52}}),Line(visible = true, points = {{30, -32},{10, -52}}),Line(visible = true, points = {{20, -32},{0, -52}}),Line(visible = true, points = {{10, -32},{ -10, -52}}),Line(visible = true, points = {{0, -32},{ -20, -52}}),Line(visible = true, points = {{ -10, -32},{ -30, -52}}),Line(visible = true, points = {{ -20, -32},{ -30, -42}}),Text(visible = true, extent = {{ -150,60},{150,100}}, textString = "%name", fontName = "Arial")}));
//         Modelica.Blocks.Interfaces.RealInput u[3] "angle, angular velocity and angular acceleration of flange_b as input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b "Flange that is forced to move according to input signals u" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.Flange_a bearing "Bearing flange (if not connected, it is assumed that it is fixed on ground)" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         function position
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           output Real q;
//           annotation(derivative(noDerivative = q_qd_qdd) = position_der, InlineAfterIndexReduction = true);
//         algorithm 
//           q:=q_qd_qdd[1];
//         end position;
//         function position_der
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           input Real dummy_der;
//           output Real qd;
//           annotation(derivative(noDerivative = q_qd_qdd) = position_der2, InlineAfterIndexReduction = true);
//         algorithm 
//           qd:=q_qd_qdd[2];
//         end position_der;
//         function position_der2
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           input Real dummy_der;
//           input Real dummy_der2;
//           output Real qdd;
//         algorithm 
//           qdd:=q_qd_qdd[3];
//         end position_der2;
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi = flange_b.phi;
//         phi = position(u, time);
//         w = der(phi);
//         a = der(w);
//       end Move;
//       model Fixed "Flange fixed in housing at a given angle"
//         parameter SI.Angle phi0 = 0 "Fixed offset angle of housing";
//         annotation(Documentation(info = "<html>
// <p>
// The <b>flange</b> of a 1D rotational mechanical system is <b>fixed</b>
// at an angle phi0 in the <b>housing</b>. May be used:
// </p>
// <ul>
// <li> to connect a compliant element, such as a spring or a damper,
//      between an inertia or gearbox component and the housing.
// <li> to fix a rigid element, such as an inertia, with a specific
//      angle to the housing.
// </ul>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -40},{80, -40}}),Line(visible = true, points = {{80, -40},{40, -80}}),Line(visible = true, points = {{40, -40},{0, -80}}),Line(visible = true, points = {{0, -40},{ -40, -80}}),Line(visible = true, points = {{ -40, -40},{ -80, -80}}),Line(visible = true, points = {{0, -40},{0, -4}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{8,46},{ -12,51},{ -12,41},{8,46}}),Line(visible = true, points = {{ -82,46},{ -11,46}}, color = {128,128,128}),Text(visible = true, fillColor = {128,128,128}, extent = {{12,40},{80,53}}, textString = "rotation axis", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -130},{150, -90}}, textString = "%name=%phi0", fontName = "Arial"),Line(visible = true, points = {{ -80, -40},{80, -40}}),Line(visible = true, points = {{80, -40},{40, -80}}),Line(visible = true, points = {{40, -40},{0, -80}}),Line(visible = true, points = {{0, -40},{ -40, -80}}),Line(visible = true, points = {{ -40, -40},{ -80, -80}}),Line(visible = true, points = {{0, -40},{0, -10}})}));
//         Interfaces.Flange_b flange_b "(right) flange fixed in housing" annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {0,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
// 
//       equation 
//         flange_b.phi = phi0;
//       end Fixed;
//       model Torque "Input signal acting as external torque on a flange"
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>tau</b> defines an external
// torque in [Nm] which acts (with negative sign) at
// a flange connector, i.e., the component connected to this
// flange is driven by torque <b>tau</b>.</p>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of Modelica.Blocks.Sources.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,70},{150,110}}, textString = "%name", fontName = "Arial"),Text(visible = true, extent = {{ -141, -70},{ -62, -29}}, textString = "tau", fontName = "Arial"),Line(visible = true, points = {{ -88,0},{ -64,30},{ -36,52},{ -2,62},{28,56},{48,44},{64,28},{76,14},{86,0}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{86,0},{66,58},{37,27},{86,0}}),Rectangle(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -20, -120},{20, -80}}),Line(visible = true, points = {{ -30, -30},{30, -30}}),Line(visible = true, points = {{0, -30},{0, -90}}),Line(visible = true, points = {{ -30, -50},{ -10, -30}}),Line(visible = true, points = {{ -10, -50},{10, -30}}),Line(visible = true, points = {{10, -50},{30, -30}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {128,128,128}, extent = {{14,73},{82,86}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10,80},{ -10,85},{ -10,75},{10,80}}),Line(visible = true, points = {{ -80,80},{ -9,80}}, color = {128,128,128}),Line(visible = true, points = {{ -88,0},{ -64,30},{ -36,52},{ -2,62},{28,56},{48,44},{64,28},{76,14},{80,10}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{86,0},{66,58},{38,28},{86,0}})}));
//         Modelica.Blocks.Interfaces.RealInput tau(redeclare type SignalType = SI.Torque) "Torque driving the flange (a positive value accelerates the flange)" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b "(Right) flange" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.Flange_a bearing annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         flange_b.tau =  -tau;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau;
// 
//         end if;
//       end Torque;
//       model Torque2 "Input signal acting as torque on two flanges"
//         extends Interfaces.TwoFlanges;
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>tau</b> defines an external
// torque in [Nm] which acts at both flange connectors,
// i.e., the components connected to these flanges are driven by torque <b>tau</b>.</p>
// <p>The input signal can be provided from one of the signal generator
// blocks of Modelica.Blocks.Sources.</p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -80},{150, -40}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, lineThickness = 0.5, points = {{ -78,24},{ -69,17},{ -89,0},{ -78,24}}),Line(visible = true, points = {{ -74,20},{ -70,23},{ -65,26},{ -60,28},{ -56,29},{ -50,30},{ -41,30},{ -35,29},{ -31,28},{ -26,26},{ -21,23},{ -17,20},{ -13,15},{ -10,9}}, thickness = 0.5, smooth = Smooth.Bezier),Line(visible = true, points = {{74,20},{70,23},{65,26},{60,28},{56,29},{50,30},{41,30},{35,29},{31,28},{26,26},{21,23},{17,20},{13,15},{10,9}}, thickness = 0.5),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{89,0},{78,24},{69,17},{89,0}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {128,128,128}, extent = {{15, -84},{83, -71}}, textString = "rotation axis", fontName = "Arial"),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{11, -77},{ -9, -72},{ -9, -82},{11, -77}}),Line(visible = true, points = {{ -79, -77},{ -8, -77}}, color = {128,128,128}),Line(visible = true, points = {{ -75,20},{ -71,23},{ -66,26},{ -61,28},{ -57,29},{ -51,30},{ -42,30},{ -36,29},{ -32,28},{ -27,26},{ -22,23},{ -18,20},{ -14,15},{ -11,9}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, fillPattern = FillPattern.Solid, lineThickness = 0.5, points = {{ -79,24},{ -70,17},{ -90,0},{ -79,24}}),Line(visible = true, points = {{73,20},{69,23},{64,26},{59,28},{55,29},{49,30},{40,30},{34,29},{30,28},{25,26},{20,23},{16,20},{12,15},{9,9}}, thickness = 0.5, smooth = Smooth.Bezier),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{88,0},{77,24},{68,17},{88,0}})}));
//         Modelica.Blocks.Interfaces.RealInput tau(redeclare type SignalType = SI.Torque) "Torque driving the two flanges (a positive value accelerates the flange)" annotation(Placement(visible = true, transformation(origin = {0,40}, extent = {{ -20, -20},{20,20}}, rotation =  -90), iconTransformation(origin = {0,40}, extent = {{ -20, -20},{20,20}}, rotation =  -90)));
// 
//       equation 
//         flange_a.tau = tau;
//         flange_b.tau =  -tau;
//       end Torque2;
//       model LinearSpeedDependentTorque "Linear dependency of torque versus speed"
//         extends Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque;
//         parameter Modelica.SIunits.Torque tau_nominal "nominal torque (if negative, torque is acting as load)";
//         parameter Boolean TorqueDirection = true "same direction of torque in both directions of rotation";
//         parameter Modelica.SIunits.AngularVelocity w_nominal(min = Modelica.Constants.eps) "nominal speed";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -100},{100,100}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Model of torque, linearly dependent on angular velocity of flange.<br>
// Parameter TorqueDirection chooses whether direction of torque is the same in both directions of rotation or not.
// </p>
// </HTML>"));
// 
//       equation 
//         if TorqueDirection then
//           tau =  -tau_nominal * abs(w / w_nominal);
// 
//         else
//           tau =  -(tau_nominal * w) / w_nominal;
// 
//         end if;
//       end LinearSpeedDependentTorque;
//       model QuadraticSpeedDependentTorque "Quadratic dependency of torque versus speed"
//         extends Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque;
//         parameter Modelica.SIunits.Torque tau_nominal "nominal torque (if negative, torque is acting as load)";
//         parameter Boolean TorqueDirection = true "same direction of torque in both directions of rotation";
//         parameter Modelica.SIunits.AngularVelocity w_nominal(min = Modelica.Constants.eps) "nominal speed";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -100},{ -80, -98},{ -60, -92},{ -40, -82},{ -20, -68},{0, -50},{20, -28},{40, -2},{60,28},{80,62},{100,100}}, color = {0,0,255}, smooth = Smooth.Bezier)}), Documentation(info = "<HTML>
// <p>
// Model of torque, quadratic dependent on angular velocity of flange.<br>
// Parameter TorqueDirection chooses whether direction of torque is the same in both directions of rotation or not.
// </p>
// </HTML>"));
// 
//       equation 
//         if TorqueDirection then
//           tau =  -tau_nominal * (w / w_nominal) ^ 2;
// 
//         else
//           tau =  -tau_nominal * smooth(1, if w >= 0 then (w / w_nominal) ^ 2 else  -(w / w_nominal) ^ 2);
// 
//         end if;
//       end QuadraticSpeedDependentTorque;
//       model ConstantTorque "Constant torque, not dependent on speed"
//         extends Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque;
//         parameter Modelica.SIunits.Torque tau_constant "constant torque (if negative, torque is acting as load)";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -98,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Model of constant torque, not dependent on angular velocity of flange.<br>
// Positive torque acts accelerating.
// </p>
// </HTML>"));
// 
//       equation 
//         tau =  -tau_constant;
//       end ConstantTorque;
//       model ConstantSpeed "Constant speed, not dependent on torque"
//         extends Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque;
//         parameter Modelica.SIunits.AngularVelocity w_fixed "fixed speed (if negative, torque is acting as load)";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0, -100},{0,100}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// Model of <b>fixed</b> angular verlocity of flange, not dependent on torque.
// </p>
// </HTML>"));
// 
//       equation 
//         w = w_fixed;
//       end ConstantSpeed;
//       model TorqueStep "Constant torque, not dependent on speed"
//         extends Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque;
//         parameter Modelica.SIunits.Torque stepTorque = 1 "height of torque step (if negative, torque is acting as load)";
//         parameter Modelica.SIunits.Torque offsetTorque = 0 "offset of torque";
//         parameter Modelica.SIunits.Time startTime = 0 "output = offset for time < startTime";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -60},{0, -60},{0,60},{80,60}}, color = {0,0,255}),Text(visible = true, fillColor = {0,0,255}, extent = {{0, -60},{100, -40}}, textString = "time", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// Model of a torque step at time .<br>
// Positive torque acts accelerating.
// </p>
// </HTML>"));
// 
//       equation 
//         tau =  -offsetTorque - (if time < startTime then 0 else stepTorque);
//       end TorqueStep;
//       model RelativeStates "Definition of relative state variables"
//         extends Interfaces.TwoFlanges;
//         SI.Angle phi_rel(stateSelect = StateSelect.prefer) "relative rotation angle used as state variable";
//         SI.AngularVelocity w_rel(stateSelect = StateSelect.prefer) "relative angular velocity used as state variable";
//         SI.AngularAcceleration a_rel "relative angular acceleration";
//         annotation(Documentation(info = "<html>
// <p>
// Usually, the absolute angle and the absolute angular velocity of
// Modelica.Mechanics.Rotational.Inertia models are used as state variables.
// In some circumstances, relative quantities are better suited, e.g.,
// because it may be easier to supply initial values.
// In such cases, model <b>RelativeStates</b> allows the definition of state variables
// in the following way:
// </p>
// <ul>
// <li> Connect an instance of this model between two flange connectors.</li>
// <li> The <b>relative rotation angle</b> and the <b>relative angular velocity</b>
//      between the two connectors are used as <b>state variables</b>.
// </ul>
// <p>
// An example is given in the next figure
// </p>
// <IMG SRC=\"../Images/relativeStates.png\" ALT=\"relativeStates\">
// <p>
// Here, the relative angle and the relative angular velocity between
// the two inertias are used as state variables. Additionally, the
// simulator selects either the absolute angle and absolute angular
// velocity of model inertia1 or of model inertia2 as state variables.
// </p>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,255,255}, fillColor = {0,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, extent = {{ -40, -40},{40,40}}, textString = "S", fontName = "Arial"),Line(visible = true, points = {{40,0},{96,0}}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -100, -10},{ -100, -80}}, color = {160,160,160}),Line(visible = true, points = {{100, -10},{100, -80}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{80, -65},{80, -55},{100, -60},{80, -65}}),Line(visible = true, points = {{ -100, -60},{80, -60}}, color = {160,160,160}),Text(visible = true, extent = {{ -30, -90},{30, -70}}, textString = "w_rel", fontName = "Arial"),Line(visible = true, points = {{ -76,80},{ -5,80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{14,80},{ -6,85},{ -6,75},{14,80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{18,74},{86,87}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -96,0},{ -40,0}}, pattern = LinePattern.Dash)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,255,255}, fillColor = {0,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, extent = {{ -40, -40},{40,40}}, textString = "S", fontName = "Arial"),Line(visible = true, points = {{ -92,0},{ -42,0}}, pattern = LinePattern.Dot),Line(visible = true, points = {{40,0},{90,0}}, pattern = LinePattern.Dot),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -80},{150, -40}}, textString = "%name", fontName = "Arial")}));
// 
//       equation 
//         phi_rel = flange_b.phi - flange_a.phi;
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         flange_a.tau = 0;
//         flange_b.tau = 0;
//       end RelativeStates;
//       package Types "Constants and types with choices, especially to build menus"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// In this package <b>types</b> and <b>constants</b> are defined that are used
// in library Modelica.Blocks. The types have additional annotation choices
// definitions that define the menus to be built up in the graphical
// user interface when the type is used as parameter in a declaration.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         package Init "Type, constants and menu choices to define initialization of absolute rotational quantities"
//           extends Modelica.Icons.Enumeration;
//           constant Integer NoInit = 1 "no initialization (phi_start, w_start are guess values)";
//           constant Integer SteadyState = 2 "steady state initialization (der(phi)=der(w)=0)";
//           constant Integer InitialState = 3 "initialization with phi_start, w_start";
//           constant Integer InitialAngle = 4 "initialization with phi_start";
//           constant Integer InitialSpeed = 5 "initialization with w_start";
//           constant Integer InitialAcceleration = 6 "initialization with a_start";
//           constant Integer InitialAngleAcceleration = 7 "initialization with phi_start, a_start";
//           constant Integer InitialSpeedAcceleration = 8 "initialization with w_start, a_start";
//           constant Integer InitialAngleSpeedAcceleration = 9 "initialization with phi_start, w_start, a_start";
//           type Temp "Temporary type of absolute initialization with choices for menus (until enumerations are available)"
//             extends Modelica.Icons.TypeInteger(min = 1, max = 9);
//             annotation(Evaluate = true, choices(choice = Modelica.Mechanics.Rotational.Types.Init.NoInit "no initialization (phi_start, w_start are guess values)", choice = Modelica.Mechanics.Rotational.Types.Init.SteadyState "steady state initialization (der(phi)=der(w)=0)", choice = Modelica.Mechanics.Rotational.Types.Init.InitialState "initialization with phi_start, w_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialAngle "initialization with phi_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialSpeed "initialization with w_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialAcceleration "initialization with a_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialAngleAcceleration "initialization with phi_start, a_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialSpeedAcceleration "initialization with w_start, a_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialAngleSpeedAcceleration "initialization with phi_start, w_start, a_start"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           end Temp;
//           annotation(Documentation(info = "<html>
// <p>
// Type <b>Init</b> defines initialization of absolute rotational
// quantities.
// </p>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Init;
//         package InitRel "Type, constants and menu choices to define initialization of relative rotational quantities"
//           extends Modelica.Icons.Enumeration;
//           constant Integer NoInit = 1 "no initialization (phi_rel_start, w_rel_start are guess values)";
//           constant Integer SteadyState = 2 "steady state initialization (der(phi_rel)=der(w_rel)=0)";
//           constant Integer InitialState = 3 "initialization with phi_rel_start, w_rel_start";
//           constant Integer InitialAngle = 4 "initialization with phi_rel_start";
//           constant Integer InitialSpeed = 5 "initialization with w_rel_start";
//           type Temp "Temporary type of absolute initialization with choices for menus (until enumerations are available)"
//             extends Modelica.Icons.TypeInteger(min = 1, max = 5);
//             annotation(Evaluate = true, choices(choice = Modelica.Mechanics.Rotational.Types.Init.NoInit "no initialization (phi_rel_start, w_rel_start are guess values)", choice = Modelica.Mechanics.Rotational.Types.Init.SteadyState "steady state initialization (der(phi)=der(w)=0)", choice = Modelica.Mechanics.Rotational.Types.Init.InitialState "initialization with phi_rel_start, w_rel_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialAngle "initialization with phi_rel_start", choice = Modelica.Mechanics.Rotational.Types.Init.InitialSpeed "initialization with w_rel_start"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           end Temp;
//           annotation(Documentation(info = "<html>
// <p>
// Type <b>Init</b> defines initialization of relative rotational
// quantities.
// </p>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end InitRel;
//       end Types;
//     end Rotational;
//     package Translational "Library to model 1-dimensional, translational mechanical systems"
//       package Examples "Demonstration examples of the components of this package"
//         extends Modelica.Icons.Library;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains example models to demonstrate the usage of the
// Translational package. Open the models and
// simulate them according to the provided description in the models.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>First Version from December 7, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         encapsulated model SignConvention "Examples for the used sign conventions."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
// <p>
// If all arrows point in the same direction a positive force
// results in a positive acceleration a, velocity v and position s.
// </p>
// For a force of 1 N and a mass of 1 Kg this leads to
// <pre>
//         a = 1 m/s2
//         v = 1 m/s after 1 s (SlidingMass1.v)
//         s = 0.5 m after 1 s (SlidingMass1.s)
// </pre>
// The acceleration is not available for plotting.
// <p>
// </p>
// System 1) and 2) are equivalent. It doesn't matter whether the
// force pushes at flange_a in system 1 or pulls at flange_b in system 2.
// </p><p>
// It is of course possible to ignore the arrows and connect the models
// in an arbitrary way. But then it is hard see in what direction the
// force acts.
// </p><p>
// In the third system the two arrows are opposed which means that the
// force acts in the opposite direction (in the same direction as in
// the two other examples).
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// </html>"), experiment(StopTime = 1), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,60},{ -82,80}}, textString = "1)", fontName = "Arial"),Text(visible = true, extent = {{ -100,20},{ -82,40}}, textString = "2)", fontName = "Arial"),Text(visible = true, extent = {{ -100, -40},{ -82, -20}}, textString = "3)", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(Placement(visible = true, transformation(origin = {46,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force1 annotation(Placement(visible = true, transformation(origin = {6,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Constant Constant1 annotation(Placement(visible = true, transformation(origin = { -34,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass2(L = 1) annotation(Placement(visible = true, transformation(origin = {46,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force2 annotation(Placement(visible = true, transformation(origin = {6,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Constant Constant2 annotation(Placement(visible = true, transformation(origin = { -34,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass3(L = 1) annotation(Placement(visible = true, transformation(origin = { -30, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force3 annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Sources.Constant Constant3 annotation(Placement(visible = true, transformation(origin = {50, -30}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Constant3.y,Force3.f) annotation(Line(visible = true, points = {{39, -30},{22, -30}}, color = {0,0,191}));
//           connect(Constant2.y,Force2.f) annotation(Line(visible = true, points = {{ -23,30},{ -6,30}}, color = {0,0,191}));
//           connect(Constant1.y,Force1.f) annotation(Line(visible = true, points = {{ -23,70},{ -6,70}}, color = {0,0,191}));
//           connect(SlidingMass3.flange_b,Force3.flange_b) annotation(Line(visible = true, points = {{ -20, -30},{0, -30}}, color = {0,191,0}));
//           connect(Force2.flange_b,SlidingMass2.flange_b) annotation(Line(visible = true, points = {{16,30},{82,30},{82,10},{56,10}}, color = {0,191,0}));
//           connect(Force1.flange_b,SlidingMass1.flange_a) annotation(Line(visible = true, points = {{16,70},{36,70}}, color = {0,191,0}));
//         end SignConvention;
//         encapsulated model InitialConditions "Setting of initial conditions"
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html> 
// <p>
// There are several ways to set initial conditions.
// In the first system the position of the sliding mass m3 was defined
// by using the modifier s(start=4.5), the position of m5 by s(start=12.5).
// These positions were chosen such that the system is a rest. To calculate
// these values start at the left (Fixed1) with a value of 1 m. The spring
// has an unstreched length of 2 m and m3 an length of 3 m, which leads to
// </p>
// 
// <pre>
//         1   m (Fixed1)
//       + 2   m (Spring S2)
//       + 3/2 m (half of the length of SlidingMass m3)
//       -------
//         4,5 m = s(start = 4.5) for m3
//       + 3/2 m (half of the length of SlidingMass m3)
//       + 4   m (SpringDamper 4
//       + 5/2 m (half of length of SlidingMass m5)
//       -------
//        12,5 m = s(start = 12.5) for m5
// </pre>
// 
// <p>
// This selection of initial conditions has the effect that MathModelica selects
// those variables (m3.s and m5.s) as state variables.
// In the second example the length of the springs are given as start values
// but they cannot be used as state for pure springs (only for the spring/damper
// combination). In this case the system is not at rest.
// </p>
// 
// <p>
// <IMG SRC=../Images/Fig.translational.examples.InitialConditions.png> 
// </p>
// 
// 
// </html>
// ", revisions = "<html>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// <li><i>Parameters and documentation modified, July 17, 2001 by P. Beater </i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.SlidingMass M3(L = 3, s(start = 4.5)) annotation(Placement(visible = true, transformation(origin = { -10,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring S2(s_rel0 = 2, c = 1000.0) annotation(Placement(visible = true, transformation(origin = { -50,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed1(s0 = 1) annotation(Placement(visible = true, transformation(origin = { -90,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SpringDamper SD4(s_rel0 = 4, c = 111) annotation(Placement(visible = true, transformation(origin = {30,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass M5(L = 5, s(start = 12.5)) annotation(Placement(visible = true, transformation(origin = {70,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass M1(L = 1) annotation(Placement(visible = true, transformation(origin = { -10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring S1(s_rel0 = 1, c = 1000.0, s_rel(start = 1)) annotation(Placement(visible = true, transformation(origin = { -48, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed2(s0 =  -1) annotation(Placement(visible = true, transformation(origin = { -90, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SpringDamper SD1(s_rel0 = 1, c = 111, s_rel(start = 1)) annotation(Placement(visible = true, transformation(origin = {30, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass M2(L = 2) annotation(Placement(visible = true, transformation(origin = {70, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(SD1.flange_b,M2.flange_a) annotation(Line(visible = true, points = {{40, -10},{60, -10}}, color = {127,255,0}));
//           connect(M1.flange_b,SD1.flange_a) annotation(Line(visible = true, points = {{0, -10},{20, -10}}, color = {127,255,0}));
//           connect(S1.flange_b,M1.flange_a) annotation(Line(visible = true, points = {{ -38, -10},{ -20, -10}}, color = {127,255,0}));
//           connect(Fixed2.flange_b,S1.flange_a) annotation(Line(visible = true, points = {{ -90, -10},{ -58, -10}}, color = {127,255,0}));
//           connect(SD4.flange_b,M5.flange_a) annotation(Line(visible = true, points = {{40,70},{60,70}}, color = {127,255,0}));
//           connect(M3.flange_b,SD4.flange_a) annotation(Line(visible = true, points = {{0,70},{20,70}}, color = {127,255,0}));
//           connect(S2.flange_b,M3.flange_a) annotation(Line(visible = true, points = {{ -40,70},{ -20,70}}, color = {127,255,0}));
//           connect(Fixed1.flange_b,S2.flange_a) annotation(Line(visible = true, points = {{ -90,70},{ -60,70}}, color = {127,255,0}));
//         end InitialConditions;
//         encapsulated model WhyArrows "Use of arrows in Mechanics.Translational"
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
// <p>
// When using the models of the translational sublibrary
// it is recommended to make sure that all arrows point in
// the same direction because then all component have the
// same reference system.
// In the example the distance from flange_a of Rod1 to flange_b
// of Rod2 is 2 m. The distance from flange_a of Rad1 to flange_b
// of Rod3 is also 2 m though it is difficult to see that. Without
// the arrows it would be almost impossible to notice.
// That all arrows point in the same direction is a sufficient
// condition for an easy use of the library. There are cases
// where horizontally flipped models can be used without
// problems.
// </p>
// </html>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from July 17, 2001 by P. Beater </i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -80,0},{90,14}}, textString = "PositionSensor2.s = PositionSensor3.s", fontName = "Arial"),Text(visible = true, extent = {{ -84, -16},{88,4}}, textString = "PositionSensor3.s <> PositionSensor1.s", fontName = "Arial"),Text(visible = true, extent = {{ -82, -92},{94, -80}}, textString = "Both systems are equivalent", fontName = "Arial"),Line(visible = true, points = {{ -90, -28},{90, -28}}, thickness = 0.5)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.Fixed Fixed1 annotation(Placement(visible = true, transformation(origin = { -10,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod1(L = 1) annotation(Placement(visible = true, transformation(origin = { -38,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod2(L = 1) annotation(Placement(visible = true, transformation(origin = {30,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod3(L = 1) annotation(Placement(visible = true, transformation(origin = { -40,68}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Translational.Sensors.PositionSensor PositionSensor2 annotation(Placement(visible = true, transformation(origin = {70,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Sensors.PositionSensor PositionSensor1 annotation(Placement(visible = true, transformation(origin = { -70,30}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Translational.Sensors.PositionSensor PositionSensor3 annotation(Placement(visible = true, transformation(origin = { -70,68}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Translational.Fixed Fixed3(s0 =  -1.9) annotation(Placement(visible = true, transformation(origin = { -90, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring1(s_rel0 = 2, c = 11) annotation(Placement(visible = true, transformation(origin = { -64, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass1(L = 2) annotation(Placement(visible = true, transformation(origin = { -36, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed2(s0 =  -1.9) annotation(Placement(visible = true, transformation(origin = {14, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring2(s_rel0 = 2, c = 11) annotation(Placement(visible = true, transformation(origin = {40, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass2(L = 2) annotation(Placement(visible = true, transformation(origin = {68, -50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Spring2.flange_b,SlidingMass2.flange_b) annotation(Line(visible = true, points = {{50, -50},{58, -50}}, color = {0,191,0}));
//           connect(Fixed2.flange_b,Spring2.flange_a) annotation(Line(visible = true, points = {{14, -50},{30, -50}}, color = {0,191,0}));
//           connect(Spring1.flange_b,SlidingMass1.flange_b) annotation(Line(visible = true, points = {{ -54, -50},{ -54, -72},{ -26, -72},{ -26, -50}}, color = {0,191,0}));
//           connect(Fixed3.flange_b,Spring1.flange_a) annotation(Line(visible = true, points = {{ -90, -50},{ -74, -50}}, color = {0,191,0}));
//           connect(PositionSensor3.flange_a,Rod3.flange_b) annotation(Line(visible = true, points = {{ -60,68},{ -50,68}}, color = {0,191,0}));
//           connect(PositionSensor1.flange_a,Rod1.flange_a) annotation(Line(visible = true, points = {{ -60,30},{ -48,30}}, color = {0,191,0}));
//           connect(Rod2.flange_b,PositionSensor2.flange_a) annotation(Line(visible = true, points = {{40,30},{60,30}}, color = {0,191,0}));
//           connect(Rod3.flange_a,Fixed1.flange_b) annotation(Line(visible = true, points = {{ -30,68},{ -10,68},{ -10,30}}, color = {0,191,0}));
//           connect(Fixed1.flange_b,Rod2.flange_a) annotation(Line(visible = true, points = {{ -10,30},{20,30}}, color = {0,191,0}));
//           connect(Rod1.flange_b,Fixed1.flange_b) annotation(Line(visible = true, points = {{ -28,30},{ -10,30}}, color = {0,191,0}));
//         end WhyArrows;
//         encapsulated model Accelerate "Use of model accelerate."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.Accelerate Accelerate1 annotation(Placement(visible = true, transformation(origin = { -30,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(Placement(visible = true, transformation(origin = {50,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Constant Constant1 annotation(Placement(visible = true, transformation(origin = { -90,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Constant1.y,Accelerate1.a) annotation(Line(visible = true, points = {{ -79,30},{ -42,30}}, color = {0,0,191}));
//           connect(Accelerate1.flange_b,SlidingMass1.flange_a) annotation(Line(visible = true, points = {{ -20,30},{40,30}}, color = {0,191,0}));
//           annotation(Documentation(info = "<html>
//   
// </html>"), Diagram);
//         end Accelerate;
//         encapsulated model Damper "Use of damper models."
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
//   
// </html>", revisions = "<html>
// <pre>
// Release notes:
// --------------
// 2001 - 7  - 14: Damping parameters increased (from 1 to 25)
// </pre>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.SlidingMass SlidingMass1(L = 1, v(start = 10), s(start = 3)) annotation(Placement(visible = true, transformation(origin = { -70,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Damper Damper1(d = 25) annotation(Placement(visible = true, transformation(origin = { -10,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed1(s0 = 4.5) annotation(Placement(visible = true, transformation(origin = {32,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass2(L = 1, v(start = 10), s(start = 3)) annotation(Placement(visible = true, transformation(origin = { -70,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Damper Damper2(d = 25) annotation(Placement(visible = true, transformation(origin = { -10,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed2(s0 = 4.5) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass3(L = 1, v(start = 10), s(start = 3)) annotation(Placement(visible = true, transformation(origin = { -70, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed3(s0 = 4.5) annotation(Placement(visible = true, transformation(origin = {30, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring1(s_rel0 = 1) annotation(Placement(visible = true, transformation(origin = { -10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SpringDamper SpringDamper1(s_rel0 = 1, d = 25) annotation(Placement(visible = true, transformation(origin = { -10, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(SpringDamper1.flange_b,Fixed3.flange_b) annotation(Line(visible = true, points = {{0, -50},{30, -50}}, color = {0,191,0}));
//           connect(SlidingMass3.flange_b,SpringDamper1.flange_a) annotation(Line(visible = true, points = {{ -60, -50},{ -20, -50}}, color = {0,191,0}));
//           connect(Damper2.flange_a,Spring1.flange_a) annotation(Line(visible = true, points = {{ -20,10},{ -20, -10}}, color = {0,191,0}));
//           connect(Damper2.flange_b,Spring1.flange_b) annotation(Line(visible = true, points = {{0,10},{0, -10}}, color = {0,191,0}));
//           connect(Damper2.flange_b,Fixed2.flange_b) annotation(Line(visible = true, points = {{0,10},{30,10}}, color = {0,191,0}));
//           connect(SlidingMass2.flange_b,Damper2.flange_a) annotation(Line(visible = true, points = {{ -60,10},{ -20,10}}, color = {0,191,0}));
//           connect(Damper1.flange_b,Fixed1.flange_b) annotation(Line(visible = true, points = {{0,70},{32,70}}, color = {0,191,0}));
//           connect(SlidingMass1.flange_b,Damper1.flange_a) annotation(Line(visible = true, points = {{ -60,70},{ -20,70}}, color = {0,191,0}));
//         end Damper;
//         encapsulated model Oscillator "Oscillator demonstrates the use of initial conditions."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
// <p>
// A spring - mass system is a mechanical oscillator. If no
// damping is included and the system is excited at resonance
// frequency infinite amplitudes will result.
// The resonant frequency is given by
// omega_res = sqrt(c / m)
// with:
// </p>
// 
// <pre> 
//       c spring stiffness
//       m mass
// </pre>
// 
// <p>
// To make sure that the system is initially at rest the initial
// conditions s(start=0) and v(start=0) for the SlindingMass
// are set.
// If damping is added the amplitudes are bounded.
// </p>
// </html>
// 
// ", revisions = "<html>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// 
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.SlidingMass SlidingMass1(L = 1, s(start =  -0.5), v(start = 0.0)) annotation(Placement(visible = true, transformation(origin = { -10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring1(s_rel0 = 1, c = 10000) annotation(Placement(visible = true, transformation(origin = {30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed1(s0 = 1.0) annotation(Placement(visible = true, transformation(origin = {70,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force1 annotation(Placement(visible = true, transformation(origin = { -50,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Sine Sine1(freqHz = 15.9155) annotation(Placement(visible = true, transformation(origin = { -90,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass2(L = 1, s(start =  -0.5), v(start = 0.0)) annotation(Placement(visible = true, transformation(origin = { -10, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring2(s_rel0 = 1, c = 10000) annotation(Placement(visible = true, transformation(origin = {30, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed2(s0 = 1.0) annotation(Placement(visible = true, transformation(origin = {70, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force2 annotation(Placement(visible = true, transformation(origin = { -50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Sine Sine2(freqHz = 15.9155) annotation(Placement(visible = true, transformation(origin = { -90, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Damper Damper1(d = 10) annotation(Placement(visible = true, transformation(origin = {30, -26}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Sine2.y,Force2.f) annotation(Line(visible = true, points = {{ -79, -50},{ -62, -50}}, color = {0,0,191}));
//           connect(Sine1.y,Force1.f) annotation(Line(visible = true, points = {{ -79,50},{ -62,50}}, color = {0,0,191}));
//           connect(Spring2.flange_b,Fixed2.flange_b) annotation(Line(visible = true, points = {{40, -50},{70, -50}}, color = {0,191,0}));
//           connect(Damper1.flange_b,Spring2.flange_b) annotation(Line(visible = true, points = {{40, -26},{40, -50}}, color = {0,191,0}));
//           connect(SlidingMass2.flange_b,Spring2.flange_a) annotation(Line(visible = true, points = {{0, -50},{20, -50}}, color = {0,191,0}));
//           connect(Spring2.flange_a,Damper1.flange_a) annotation(Line(visible = true, points = {{20, -50},{20, -26}}, color = {0,191,0}));
//           connect(Force2.flange_b,SlidingMass2.flange_a) annotation(Line(visible = true, points = {{ -40, -50},{ -20, -50}}, color = {0,191,0}));
//           connect(SlidingMass1.flange_b,Spring1.flange_a) annotation(Line(visible = true, points = {{0,50},{20,50}}, color = {0,191,0}));
//           connect(Spring1.flange_b,Fixed1.flange_b) annotation(Line(visible = true, points = {{40,50},{70,50}}, color = {0,191,0}));
//           connect(Force1.flange_b,SlidingMass1.flange_a) annotation(Line(visible = true, points = {{ -40,50},{ -20,50}}, color = {0,191,0}));
//         end Oscillator;
//         encapsulated model Sensors "Sensors for translational systems."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
// <p>
// These sensors measure
// </p>
// 
// <pre>
//    force f in N
//    position s in m
//    velocity v in m/s
//    acceleration a in m/s2
// </pre>
// 
// <p>
// Dhe measured velocity and acceleration is independent on
// the flange the sensor is connected to. The position
// depends on the flange (flange_a or flange_b) and the
// length L of the component.
// Plot PositionSensor1.s, PositionSensor2.s and SlidingMass1.s
// to see the difference.
// </p>
// 
// ", revisions = "<html>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// 
// </html>"), experiment(StopTime = 2), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.Sensors.ForceSensor ForceSensor1 annotation(Placement(visible = true, transformation(origin = { -10,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Sensors.SpeedSensor SpeedSensor1 annotation(Placement(visible = true, transformation(origin = {30, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Sensors.PositionSensor PositionSensor1 annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Sensors.AccSensor AccSensor1 annotation(Placement(visible = true, transformation(origin = {30, -70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(Placement(visible = true, transformation(origin = {30,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force1 annotation(Placement(visible = true, transformation(origin = { -50,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Sine Sine1(amplitude = 10, freqHz = 4) annotation(Placement(visible = true, transformation(origin = { -90,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Sensors.PositionSensor PositionSensor2 annotation(Placement(visible = true, transformation(origin = {70,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Sine1.y,Force1.f) annotation(Line(visible = true, points = {{ -79,50},{ -62,50}}, color = {0,0,191}));
//           connect(SpeedSensor1.flange_a,AccSensor1.flange_a) annotation(Line(visible = true, points = {{20, -30},{20, -70}}, color = {0,191,0}));
//           connect(PositionSensor1.flange_a,SpeedSensor1.flange_a) annotation(Line(visible = true, points = {{20,10},{20, -30}}, color = {0,191,0}));
//           connect(SlidingMass1.flange_a,PositionSensor1.flange_a) annotation(Line(visible = true, points = {{20,50},{20,10}}, color = {0,191,0}));
//           connect(Force1.flange_b,ForceSensor1.flange_a) annotation(Line(visible = true, points = {{ -40,50},{ -20,50}}, color = {0,191,0}));
//           connect(SlidingMass1.flange_b,PositionSensor2.flange_a) annotation(Line(visible = true, points = {{40,50},{60,50}}, color = {0,191,0}));
//           connect(ForceSensor1.flange_b,SlidingMass1.flange_a) annotation(Line(visible = true, points = {{0,50},{20,50}}, color = {0,191,0}));
//         end Sensors;
//         encapsulated model Friction "Use of model Stop"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -56, -100},{62, -88}}, textString = "simulate 5 s", fontName = "Arial"),Text(visible = true, extent = {{ -100,60},{ -80,80}}, textString = "1)", fontName = "Arial"),Text(visible = true, extent = {{ -100,0},{ -80,20}}, textString = "2)", fontName = "Arial")}), Documentation(info = "<html>
// <ol>
// <li> Simulate and then plot Stop1.f as a function of Stop1.v
//      This gives the Stribeck curve.</li>
// <li> This model gives an example for a hard stop. However there
//      can arise some problems with the used modeling approach (use of
//      Reinit, convergence problems). In this case use the ElastoGap
//      to model a stop (see example Preload).</li>
// </ol>
// </html>
// ", revisions = "<html>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// 
// </html>"), experiment(StopTime = 5), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.Stop Stop1(L = 1) annotation(Placement(visible = true, transformation(origin = {70,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Force Force1 annotation(Placement(visible = true, transformation(origin = {28,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Sine Sine1(amplitude = 25, freqHz = 0.25) annotation(Placement(visible = true, transformation(origin = { -10,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Stop Stop2(L = 1, smax = 0.9, smin =  -0.9, F_Coulomb = 3, F_Stribeck = 5, s(start = 0), v(start =  -5)) annotation(Placement(visible = true, transformation(origin = {70,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring1(s_rel0 = 1, c = 500) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Fixed Fixed1(s0 =  -1.75) annotation(Placement(visible = true, transformation(origin = { -12,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Sine1.y,Force1.f) annotation(Line(visible = true, points = {{1,70},{16,70}}, color = {0,0,191}));
//           connect(Spring1.flange_b,Stop2.flange_a) annotation(Line(visible = true, points = {{40,10},{60,10}}, color = {0,191,0}));
//           connect(Fixed1.flange_b,Spring1.flange_a) annotation(Line(visible = true, points = {{ -12,10},{20,10}}, color = {0,191,0}));
//           connect(Force1.flange_b,Stop1.flange_a) annotation(Line(visible = true, points = {{38,70},{60,70}}, color = {0,191,0}));
//         end Friction;
//         encapsulated model PreLoad "Preload of a spool using ElastoGap models."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(experiment(StopTime = 100), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -98, -94},{102, -68}}, textString = "positive force => spool moves in positive direction ", fontName = "Arial"),Text(visible = true, extent = {{ -32, -62},{38, -46}}, textString = "Simulate for 100 s", fontName = "Arial"),Text(visible = true, extent = {{ -100, -80},{100, -54}}, textString = "plot Spool.s as a function of Force1.f", fontName = "Arial")}), Documentation(info = "<html>
// <p>
// When designing hydraulic valves it is often necessary to hold the spool in
// a certain position as long as an external force is below a threshold value.
// If this force exceeds the treshold value a linear relation between force
// and position is desired.
// There are designs that need only one spring to accomplish this task. Using
// the ElastoGap elements this design can be modelled easily.
// Drawing of spool.
// </p>
// 
// <p>
// <<IMG SRC=../Images/PreLoad.png>
// </p>
// 
// <p>
// <IMG SRC=../Images/PreLoad3.png>
// </p>
// 
// <p>
// <IMG SRC=../Images/PreLoad4.png>
// </p>
// 
// <p>
// Spool position s as a function of working force f.
// </p>
// 
// <p>
// <IMG SRC=../Images/PreLoad2.png> 
// </p>
// </html>
// 
// ", revisions = "<html>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// <li><i>July 17, 2001, parameters changed, by P. Beater </i> </li>
// <li><i>Ocotber 5, 2002, object diagram and parameters changed, by P. Beater </i> </li>
// </ul>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Translational.ElastoGap InnerContactA(s_rel0 = 0.001, c = 1000000.0, d = 250) annotation(Placement(visible = true, transformation(origin = { -58,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.ElastoGap InnerContactB(s_rel0 = 0.001, c = 1000000.0, d = 250) annotation(Placement(visible = true, transformation(origin = {64,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass Spool(L = 0.19, m = 0.15, s(start = 0.01475)) annotation(Placement(visible = true, transformation(origin = {26, -22}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Translational.Fixed FixedLe(s0 =  -0.0955) annotation(Placement(visible = true, transformation(origin = { -88,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SpringPlateA(L = 0.002, m = 0.01, s(start =  -0.093)) annotation(Placement(visible = true, transformation(origin = { -30,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.SlidingMass SpringPlateB(L = 0.002, m = 0.01, s(start =  -0.06925)) annotation(Placement(visible = true, transformation(origin = {36,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Spring Spring(c = 20000.0, s_rel0 = 0.025) annotation(Placement(visible = true, transformation(origin = {2,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.ElastoGap OuterContactA(s_rel0 = 0.0015, c = 1000000.0, d = 250) annotation(Placement(visible = true, transformation(origin = { -64,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.ElastoGap OuterContactB(c = 1000000.0, d = 250, s_rel0 = 0.0015) annotation(Placement(visible = true, transformation(origin = {70,68}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod1(L = 0.007) annotation(Placement(visible = true, transformation(origin = { -30,42}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Damper Friction(d = 2500) annotation(Placement(visible = true, transformation(origin = { -88,24}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Translational.Force Force1 annotation(Placement(visible = true, transformation(origin = { -22, -22}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Housing(L = 0.0305) annotation(Placement(visible = true, transformation(origin = {2,88}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod3(L = 0.00575) annotation(Placement(visible = true, transformation(origin = { -30,8}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod4(L = 0.00575) annotation(Placement(visible = true, transformation(origin = {36,8}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Translational.Rod Rod2(L = 0.007) annotation(Placement(visible = true, transformation(origin = {36,42}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Sources.Sine Sine1(amplitude = 150, freqHz = 0.01) annotation(Placement(visible = true, transformation(origin = { -66, -22}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           connect(Sine1.y,Force1.f) annotation(Line(visible = true, points = {{ -55, -22},{ -34, -22}}, color = {0,0,191}));
//           connect(Spool.flange_a,Rod4.flange_a) annotation(Line(visible = true, points = {{6, -22},{6,8},{26,8}}, color = {0,191,0}));
//           connect(Rod2.flange_b,SpringPlateB.flange_a) annotation(Line(visible = true, points = {{46,42},{46,54},{26,54},{26,68}}, color = {0,191,0}));
//           connect(Rod3.flange_b,Rod4.flange_a) annotation(Line(visible = true, points = {{ -20,8},{26,8}}, color = {0,191,0}));
//           connect(Force1.flange_b,Spool.flange_a) annotation(Line(visible = true, points = {{ -12, -22},{6, -22}}, color = {0,191,0}));
//           connect(Friction.flange_b,Rod3.flange_a) annotation(Line(visible = true, points = {{ -88,14},{ -88,8},{ -40,8}}, color = {0,191,0}));
//           connect(Rod4.flange_b,InnerContactB.flange_b) annotation(Line(visible = true, points = {{46,8},{80,8},{80,30},{74,30}}, color = {0,191,0}));
//           connect(Rod2.flange_a,InnerContactB.flange_a) annotation(Line(visible = true, points = {{26,42},{26,30},{54,30}}, color = {0,191,0}));
//           connect(InnerContactA.flange_b,Rod1.flange_b) annotation(Line(visible = true, points = {{ -48,30},{ -12,30},{ -12,42},{ -20,42}}, color = {0,191,0}));
//           connect(InnerContactA.flange_a,Rod3.flange_a) annotation(Line(visible = true, points = {{ -68,30},{ -80,30},{ -80,8},{ -40,8}}, color = {0,191,0}));
//           connect(SpringPlateA.flange_b,Rod1.flange_a) annotation(Line(visible = true, points = {{ -20,68},{ -20,52},{ -40,52},{ -40,42}}, color = {0,191,0}));
//           connect(OuterContactB.flange_b,Housing.flange_b) annotation(Line(visible = true, points = {{80,68},{80,88},{12,88}}, color = {0,191,0}));
//           connect(FixedLe.flange_b,Housing.flange_a) annotation(Line(visible = true, points = {{ -88,68},{ -88,88},{ -8,88}}, color = {0,191,0}));
//           connect(Friction.flange_a,FixedLe.flange_b) annotation(Line(visible = true, points = {{ -88,34},{ -88,68}}, color = {0,191,0}));
//           connect(FixedLe.flange_b,OuterContactA.flange_a) annotation(Line(visible = true, points = {{ -88,68},{ -74,68}}, color = {0,191,0}));
//           connect(SpringPlateB.flange_b,OuterContactB.flange_a) annotation(Line(visible = true, points = {{46,68},{60,68}}, color = {0,191,0}));
//           connect(Spring.flange_b,SpringPlateB.flange_a) annotation(Line(visible = true, points = {{12,68},{26,68}}, color = {0,191,0}));
//           connect(SpringPlateA.flange_b,Spring.flange_a) annotation(Line(visible = true, points = {{ -20,68},{ -8,68}}, color = {0,191,0}));
//           connect(OuterContactA.flange_b,SpringPlateA.flange_a) annotation(Line(visible = true, points = {{ -54,68},{ -40,68}}, color = {0,191,0}));
//         end PreLoad;
//       end Examples;
//       package Sensors "Sensors for 1-dim. translational mechanical quantities"
//         extends Modelica.Icons.Library2;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -76, -81},{64, -1}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -6, -61},{ -16, -37},{4, -37},{ -6, -61}}),Line(visible = true, points = {{ -6, -21},{ -6, -37}}),Line(visible = true, points = {{ -76, -21},{ -6, -21}}),Line(visible = true, points = {{ -56, -61},{ -56, -81}}),Line(visible = true, points = {{ -36, -61},{ -36, -81}}),Line(visible = true, points = {{ -16, -61},{ -16, -81}}),Line(visible = true, points = {{4, -61},{4, -81}}),Line(visible = true, points = {{24, -61},{24, -81}}),Line(visible = true, points = {{44, -61},{44, -81}})}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model ForceSensor "Ideal sensor to measure the force between two flanges"
//           extends Modelica.Icons.TranslationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <i>cut-force between two flanges</i> in an ideal way
// and provides the result as output signal (to be further processed
// with blocks of the Modelica.Blocks library).
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{40, -120},{120, -70}}, textString = "f", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -60}}, color = {0,0,191})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}),Line(visible = true, points = {{70,0},{96,0}}),Line(visible = true, points = {{0, -100},{0, -60}})}));
//           Interfaces.Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput f(redeclare type SignalType = SI.Force) "force in flange_a and flange_b (f = flange_a.f = -flange_b.f)" annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//         equation 
//           flange_a.s = flange_b.s;
//           flange_a.f = f;
//           flange_b.f =  -f;
//         end ForceSensor;
//         model PositionSensor "Ideal sensor to measure the absolute position"
//           extends Modelica.Icons.TranslationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <i>absolute position s</i> of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70.4,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{80, -62},{114, -28}}, textString = "s", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{100,0},{70,0}}),Line(visible = true, points = {{ -70,0},{ -96,0}}, color = {127,255,0})}));
//           Interfaces.Flange_a flange_a "flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput s(redeclare type SignalType = SI.Position) "Absolute position of flange as output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           s = flange_a.s;
//           0 = flange_a.f;
//         end PositionSensor;
//         model SpeedSensor "Ideal sensor to measure the absolute velocity"
//           extends Modelica.Icons.TranslationalSensor;
//           SI.Position s "Absolute position of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <i>absolute velocity v</i> of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70.4,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{80, -61},{111, -28}}, textString = "v", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -96,0}}, color = {127,255,0}),Line(visible = true, points = {{100,0},{70,0}})}));
//           Interfaces.Flange_a flange_a "flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput v(redeclare type SignalType = SI.Velocity) "Absolute velocity of flange as output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           s = flange_a.s;
//           v = der(s);
//           0 = flange_a.f;
//         end SpeedSensor;
//         model AccSensor "Ideal sensor to measure the absolute acceleration"
//           extends Modelica.Icons.TranslationalSensor;
//           SI.Velocity v "Absolute velocity of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <i>absolute acceleration a</i>
// of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70.4,0},{100,0}}, color = {0,0,191}),Text(visible = true, extent = {{80, -60},{115, -28}}, textString = "a", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -97,0}}, color = {127,255,0}),Line(visible = true, points = {{100,0},{70,0}})}));
//           Interfaces.Flange_a flange_a "flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput a(redeclare type SignalType = SI.Acceleration) "Absolute acceleration of flange as output signal" annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           v = der(flange_a.s);
//           a = der(v);
//           0 = flange_a.f;
//         end AccSensor;
//       end Sensors;
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(preferedView = "info", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -84, -73},{66, -73}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Sphere, extent = {{ -81, -65},{ -8, -22}}),Line(visible = true, points = {{ -8, -43},{ -1, -43},{6, -64},{17, -23},{29, -65},{40, -23},{50, -44},{61, -44}}),Line(visible = true, points = {{ -59, -73},{ -84, -93}}),Line(visible = true, points = {{ -11, -73},{ -36, -93}}),Line(visible = true, points = {{ -34, -73},{ -59, -93}}),Line(visible = true, points = {{14, -73},{ -11, -93}}),Line(visible = true, points = {{39, -73},{14, -93}}),Line(visible = true, points = {{63, -73},{38, -93}})}), Documentation(info = "<html>
// <p>
// This package contains components to model <i>1-dimensional translational
// mechanical</i> systems.
// </p>
// <p>
// The <i>filled</i> and <i>non-filled green squares</i> at the left and
// right side of a component represent <i>mechanical flanges</i>.
// Drawing a line between such squares means that the corresponding
// flanges are <i>rigidly attached</i> to each other. The components of this
// library can be usually connected together in an arbitrary way. E.g. it is
// possible to connect two springs or two sliding masses with inertia directly
// together.
// <p> The only <i>connection restriction</i> is that the Coulomb friction
// elements (Stop) should be only connected
// together provided a compliant element, such as a spring, is in between.
// The reason is that otherwise the frictional force is not uniquely
// defined if the elements are stuck at the same time instant (i.e., there
// does not exist a unique solution) and some simulation systems may not be
// able to handle this situation, since this leads to a singularity during
// simulation. It can only be resolved in a \"clean way\" by combining the
// two connected friction elements into
// one component and resolving the ambiguity of the frictional force in the
// stuck mode.
// </p>
// <p> Another restriction arises if the hard stops in model Stop are used, i. e.
// the movement of the mass is limited by a stop at smax or smin.
// <font color=\"#ff0000\"> <b>This requires the states Stop.s and Stop.v</b> </font>. If these states are eliminated during the index reduction
// the model will not work. To avoid this any inertias should be connected via springs
// to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided. </p>
// <p>
// In the <i>icon</i> of every component an <i>arrow</i> is displayed in grey
// color. This arrow characterizes the coordinate system in which the vectors
// of the component are resolved. It is directed into the positive
// translational direction (in the mathematical sense).
// In the flanges of a component, a coordinate system is rigidly attached
// to the flange. It is called <i>flange frame</i> and is directed in parallel
// to the component coordinate system. As a result, e.g., the positive
// cut-force of a \"left\" flange (flange_a) is directed into the flange, whereas
// the positive cut-force of a \"right\" flange (flange_b) is directed out of the
// flange. A flange is described by a Modelica connector containing
// the following variables:
// </p>
// <pre>
//    SIunits.Position s  \"absolute position of flange\";
//    <i>flow</i> Force f        \"cut-force in the flange\";
// </pre>
// 
// <p>
// This library is designed in a fully object oriented way in order that
// components can be connected together in every meaningful combination
// (e.g. direct connection of two springs or two shafts with inertia).
// As a consequence, most models lead to a system of
// differential-algebraic equations of <i>index 3</i> (= constraint
// equations have to be differentiated twice in order to arrive at
// a state space representation) and the Modelica translator or
// the simulator has to cope with this system representation.
// According to our present knowledge, this requires that the
// Modelica translator is able to symbolically differentiate equations
// (otherwise it is e.g. not possible to provide consistent initial
// conditions; even if consistent initial conditions are present, most
// numerical DAE integrators can cope at most with index 2 DAEs).
// </p>
// 
// <dl>
// <dt><b>Main Author:</b></dt>
// <dd>Peter Beater <br>
//     Universit&auml;t Paderborn, Abteilung Soest<br>
//     Fachbereich Maschinenbau/Automatisierungstechnik<br>
//     L&uuml;becker Ring 2 <br>
//     D 59494 Soest <br>
//     Germany <br>
//     email: <A HREF=\"mailto:Beater@mailso.uni-paderborn.de\">Beater@mailso.uni-paderborn.de</A><br>
// </dd>
// </dl>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and Universit&auml;t Paderborn, FB 12.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Version 1.0 (January 5, 2000)</i>
//        by Peter Beater <br>
//        Realized a first version based on Modelica library Mechanics.Rotational
//        by Martin Otter and an existing Dymola library onedof.lib by Peter Beater.
//        <br>
// <li><i>Version 1.01 (July 18, 2001)</i>
//        by Peter Beater <br>
//        Assert statement added to \"Stop\", small bug fixes in examples.
//        <br><br>
// </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Interfaces "Interfaces for 1-dim. translational mechanical components"
//         extends Modelica.Icons.Library;
//         connector Flange_a "(left) 1D translational flange (flange axis directed INTO cut plane, e. g. from left to right)"
//           annotation(defaultComponentName = "flange_a", Documentation(info = "<html>
// This is a flange for 1D translational mechanical systems. In the cut plane of
// the flange a unit vector n, called flange axis, is defined which is directed
// INTO the cut plane, i. e. from left to right. All vectors in the cut plane are
// resolved with respect to
// this unit vector. E.g. force f characterizes a vector which is directed in
// the direction of n with value equal to f. When this flange is connected to
// other 1D translational flanges, this means that the axes vectors of the connected
// flanges are identical.
// </p>
// <p>
// The following variables are transported through this connector:
// <pre>
//   s: Absolute position of the flange in [m]. A positive translation
//      means that the flange is translated along the flange axis.
//   f: Cut-force in direction of the flange axis in [N].
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, extent = {{ -160,50},{40,110}}, textString = "%name", fontName = "Arial")}));
//           SI.Position s "absolute position of flange";
//           flow SI.Force f "cut force directed into flange";
//         end Flange_a;
//         connector Flange_b "right 1D translational flange (flange axis directed OUT OF cut plane)"
//           SI.Position s "absolute position of flange";
//           flow SI.Force f "cut force directed into flange";
//           annotation(defaultComponentName = "flange_b", Documentation(info = "<html>
// This is a flange for 1D translational mechanical systems. In the cut plane of
// the flange a unit vector n, called flange axis, is defined which is directed
// OUT OF the cut plane. All vectors in the cut plane are resolved with respect to
// this unit vector. E.g. force f characterizes a vector which is directed in
// the direction of n with value equal to f. When this flange is connected to
// other 1D translational flanges, this means that the axes vectors of the connected
// flanges are identical.
// </p>
// <p>
// The following variables are transported through this connector:
// <pre>
//   s: Absolute position of the flange in [m]. A positive translation
//      means that the flange is translated along the flange axis.
//   f: Cut-force in direction of the flange axis in [N].
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,191,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,191,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, extent = {{ -40,50},{160,110}}, textString = "%name", fontName = "Arial")}));
//         end Flange_b;
//         partial model Rigid "Rigid connection of two translational 1D flanges "
//           SI.Position s "absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
//           parameter SI.Length L = 0 "length of component from left flange to right flange (= flange_b.s - flange_a.s)";
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D translational component with two <i>rigidly</i> connected flanges.
// The distance between the left and the right flange is always constant, i. e. L.
// The forces at the right and left flange can be different.
// It is used e.g. to built up sliding masses.
// </p>
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater  (based on Rotational.Rigid)</i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, i. e. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane, i. e. from right to left)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           flange_a.s = s - L / 2;
//           flange_b.s = s + L / 2;
//         end Rigid;
//         partial model Compliant "Compliant connection of two translational 1D flanges"
//           SI.Distance s_rel "relative distance (= flange_b.s - flange_a.s)";
//           SI.Force f "forcee between flanges (positive in direction of flange axis R)";
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D translational component with a <i>compliant </i>connection of two
// translational 1D flanges where inertial effects between the two
// flanges are not included. The absolute value of the force at the left and the right
// flange is the same. It is used to built up springs, dampers etc.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p>
// <b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Compliant)</i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           s_rel = flange_b.s - flange_a.s;
//           flange_b.f = f;
//           flange_a.f =  -f;
//         end Compliant;
//         partial model TwoFlanges "Component with two translational 1D flanges "
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D translational component with two flanges.
// It is used e.g. to built up parts of a drive train consisting
// of several base components.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.TwoFlanges)</i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end TwoFlanges;
//         partial model AbsoluteSensor "Device to measure a single absolute flange variable"
//           extends Modelica.Icons.TranslationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// This is the superclass of a 1D translational component with one flange and one
// output signal in order to measure an absolute kinematic quantity in the flange
// and to provide the measured signal as output signal for further processing
// with the Modelica.Blocks blocks.
// </p>
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version 1.0 (July 18, 1999)</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// <p><b>Copyright &copy; 1999-2006, Modelica Association and DLR.</b></p>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100, -90},{ -20, -90}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{10, -90},{ -20, -80},{ -20, -100},{10, -90}}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -118,40},{118,99}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}})}));
//           Interfaces.Flange_a flange_a "flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Device to measure a single relative variable between two flanges"
//           extends Modelica.Icons.TranslationalSensor;
//           annotation(Documentation(info = "<html>
// <p>
// This is a superclass for 1D translational components with two rigidly connected
// flanges and one output signal in order to measure relative kinematic quantities
// between the two flanges or the cut-force in the flange and
// to provide the measured signal as output signal for further processing
// with the Modelica.Blocks blocks.
// </p>
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version 1.0 (July 18, 1999)</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// <p><b>Copyright &copy; 1998-2006, Modelica Association and DLR.</b></p>
//  
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -51,34},{29,34}}),Polygon(visible = true, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{59,34},{29,44},{29,24},{59,34}}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -60}}, color = {0,0,191}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -117,52},{115,116}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -60}})}));
//           Interfaces.Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//         end RelativeSensor;
//         partial model FrictionBase "Base class of Coulomb friction elements"
//           extends Rigid;
//           parameter SI.Position smax = 25 "right stop for (right end of) sliding mass";
//           parameter SI.Position smin =  -25 "left stop for (left end of) sliding mass";
//           parameter SI.Velocity v_small = 0.001 "Relative velocity near to zero (see model info text)";
//           SI.Velocity v_relfric "Relative velocity between frictional surfaces";
//           SI.Acceleration a_relfric "Relative acceleration between frictional surfaces";
//           SI.Force f "Friction force (positive, if directed in opposite direction of v_rel)";
//           SI.Force f0 "Friction force for v=0 and forward sliding";
//           SI.Force f0_max "Maximum friction force for v=0 and locked";
//           Boolean free "true, if frictional element is not active";
//           Real sa "Path parameter of friction characteristic f = f(a_relfric)";
//           Boolean startForward "true, if v_rel=0 and start of forward sliding or v_rel > v_small";
//           Boolean startBackward "true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
//           Boolean locked "true, if v_rel=0 and not sliding";
//           constant Integer Unknown = 3 "Value of mode is not known";
//           constant Integer Free = 2 "Element is not active";
//           constant Integer Forward = 1 "v_rel > 0 (forward sliding)";
//           constant Integer Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
//           constant Integer Backward =  -1 "v_rel < 0 (backward sliding)";
//           Integer mode(final min = Backward, final max = Unknown, start = Unknown);
//           annotation(Documentation(info = "<html>
//   
// </html>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version from January 5, 2000 by P. Beater
// (based on Translational.FrictionBase from Martin Otter)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           startForward = pre(mode) == Stuck and (sa > f0_max and s < smax - L / 2 or pre(startForward) and sa > f0 and s < smax - L / 2) or pre(mode) == Backward and v_relfric > v_small or initial() and v_relfric > 0;
//           startBackward = pre(mode) == Stuck and (sa <  -f0_max and s > smin + L / 2 or pre(startBackward) and sa <  -f0 and s > smin + L / 2) or pre(mode) == Forward and v_relfric <  -v_small or initial() and v_relfric < 0;
//           locked = not free and not (pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//           a_relfric = if locked then 0 else if free then sa else if startForward then sa - f0_max else if startBackward then sa + f0_max else if pre(mode) == Forward then sa - f0 else sa + f0;
//           mode = if free then Free else if (pre(mode) == Forward or pre(mode) == Free or startForward) and v_relfric > 0 and s < smax - L / 2 then Forward else if (pre(mode) == Backward or pre(mode) == Free or startBackward) and v_relfric < 0 and s > smin + L / 2 then Backward else Stuck;
//         end FrictionBase;
//         annotation(Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Interfaces;
//       model SlidingMass "Sliding mass with inertia"
//         extends Interfaces.Rigid;
//         parameter SI.Mass m(min = 0) = 1 "mass of the sliding mass";
//         SI.Velocity v "absolute velocity of component";
//         SI.Acceleration a "absolute acceleration of component";
//         annotation(Documentation(info = "<html>
// <p>
// Sliding mass with <i>inertia, without friction</i> and two rigidly connected flanges.
// </p>
// <p>
// The sliding mass has the length L, the position coordinate s is in the middle.
// Sign convention: A positive force at flange flange_a moves the sliding mass in the positive direction.
// A negative force at flange flange_a moves the sliding mass to the negative direction.
// </p>
// 
// </html>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Shaft)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -55,0}}, color = {0,191,0}),Line(visible = true, points = {{55,0},{100,0}}, color = {0,191,0}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Sphere, extent = {{ -55, -30},{56,30}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -55,0}}, color = {0,191,0}),Line(visible = true, points = {{55,0},{100,0}}, color = {0,191,0}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Sphere, extent = {{ -55, -30},{55,30}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Line(visible = true, points = {{ -100, -29},{ -100, -61}}),Line(visible = true, points = {{100, -61},{100, -28}}),Line(visible = true, points = {{ -98, -60},{98, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -101, -60},{ -96, -59},{ -96, -61},{ -101, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{100, -60},{95, -61},{95, -59},{100, -60}}),Text(visible = true, extent = {{ -44, -57},{51, -41}}, textString = "Length L", fontName = "Arial"),Line(visible = true, points = {{0,30},{0,53}}),Line(visible = true, points = {{ -72,40},{1,40}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -7,42},{ -7,38},{ -1,40},{ -7,42}}),Text(visible = true, extent = {{ -61,42},{ -9,53}}, textString = "Position s", fontName = "Arial")}));
// 
//       equation 
//         v = der(s);
//         a = der(v);
//         m * a = flange_a.f + flange_b.f;
//       end SlidingMass;
//       model Stop "Sliding mass with hard stop and Stribeck friction"
//         extends Modelica.Mechanics.Translational.Interfaces.FrictionBase(s(stateSelect = StateSelect.always));
//         Modelica.SIunits.Velocity v(stateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
//         Modelica.SIunits.Acceleration a "Absolute acceleration of flange_a and flange_b";
//         parameter Modelica.SIunits.Mass m = 1 "mass";
//         parameter Real F_prop(final unit = "N/ (m/s)", final min = 0) = 1 "velocity dependent friction";
//         parameter Modelica.SIunits.Force F_Coulomb = 5 "constant friction: Coulomb force";
//         parameter Modelica.SIunits.Force F_Stribeck = 10 "Stribeck effect";
//         parameter Real fexp(final unit = "1/ (m/s)", final min = 0) = 2 "exponential decay";
//         annotation(Documentation(info = "
// <HTML>
// <P>This element describes the <i>Stribeck friction characteristics</i> of a sliding mass,
// i. e. the frictional force acting between the sliding mass and the support. Included is a
// <i>hard stop</i> for the position. <BR>
// The surface is fixed and there is friction between sliding mass and surface.
// The frictional force f is given for positive velocity v by:</P>
// <i><uL>
// f = F_Coulomb + F_prop * v + F_Stribeck * exp (-fexp * v)</i> </ul><br>
// <IMG SRC=../Images/Stribeck.png>
// <br><br>
// The distance between the left and the right connector is given by parameter L.
// The position of the center of gravity, coordinate s, is in the middle between
// the two flanges. </p>
// <p>
// There are hard stops at smax and smin, i. e. if <i><uL>
// flange_a.s &gt;= smin
// <ul>    and </ul>
// flange_b.s &lt;= xmax </ul></i>
// the sliding mass can move freely.</p>
// <p>When the absolute velocity becomes zero, the sliding mass becomes stuck, i.e., the absolute position remains constant. In this phase the
// friction force is calculated from a force balance due to the requirement that the
// absolute acceleration shall be zero. The elements begin to slide when the friction
// force exceeds a threshold value, called the maximum static friction force, computed via: </P>
// <i><uL>
//    maximum_static_friction =  F_Coulomb + F_Stribeck
// </i> </ul>
// <font color=\"#ff0000\"> <b>This requires the states Stop.s and Stop.v</b> </font>. If these states are eliminated during the index reduction
// the model will not work. To avoid this any inertias should be connected via springs
// to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided. </p>
// <p>For more details of the used friction model see the following reference: <br> <br>
// Beater P. (1999): <DD><a href=\"http://www.springer.de/cgi-bin/search_book.pl?isbn=3-540-65444-5\">
// Entwurf hydraulischer Maschinen</a>. Springer Verlag Berlin Heidelberg New York.</DL></P>
// <P>The friction model is implemented in a \"clean\" way by state events and leads to
// continuous/discrete systems of equations which have to be solved by appropriate
// numerical methods. The method is described in: </P>
// 
// <dl>
// Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <i><DD>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</i>. CACSD'99, Aug. 22.-26, Hawaii. </DD>
// </DL>
// <P>More precise friction models take into account the elasticity of the material when
// the two elements are \"stuck\", as well as other effects, like hysteresis. This has
// the advantage that the friction element can be completely described by a differential
// equation without events. The drawback is that the system becomes stiff (about 10-20 times
// slower simulation) and that more material constants have to be supplied which requires more
// sophisticated identification. For more details, see the following references, especially
// (Armstrong and Canudas de Witt 1996): </P>
// <dl>
// <dt>
// Armstrong B. (1991):</dt>
// <DD><i>Control of Machines with Friction</i>. Kluwer Academic Press, Boston MA.<BR>
// </DD>
// <DT>Armstrong B., and Canudas de Wit C. (1996): </DT>
// <DD><i>Friction Modeling and Compensation.</i> The Control Handbook, edited by W.S.Levine, CRC Press, pp. 1369-1382.<BR>
// </DD>
// <DT>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995): </DT>
// <DD>A<i> new model for control of systems with friction.</i> IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<BR>
// </DD>
// </DL>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 7, 1999 by P. Beater (based on Rotational.BearingFriction)</i> </li>
// <li><i>July 14, 2001 by P. Beater, assert on initialization added, diagram modified </i> </li>
// <li><i>October 11, 2001, by Hans Olsson, Dynasim, modified assert to handle start at stops,
// modified event logic such if you have friction parameters equal to zero you do not get events
// between the stops.</i> </li>
// <li><i>June 10, 2002 by P. Beater, StateSelect.always for variables s and v (instead of fixed=true). </i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Sphere, extent = {{ -30, -35},{35,30}}),Line(visible = true, points = {{ -90,0},{ -30,0}}, color = {0,191,0}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -70, -60},{74, -45}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -63, -45},{ -55, -15}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{60, -45},{69, -16}}),Line(visible = true, points = {{35,0},{90,0}}, color = {0,191,0}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Sphere, extent = {{ -30, -9},{35,26}}),Line(visible = true, points = {{ -90,0},{ -30,0}}, color = {0,191,0}),Line(visible = true, points = {{35,0},{90,0}}, color = {0,191,0}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -68, -29},{76, -14}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -119,17},{ -111,43}}),Line(visible = true, points = {{ -111,43},{ -111,50}}),Line(visible = true, points = {{ -151,49},{ -113,49}}),Text(visible = true, extent = {{ -149,51},{ -126,60}}, textString = "s min", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -121,52},{ -111,49},{ -121,46},{ -121,52}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{124,17},{132,42}}),Line(visible = true, points = {{124,39},{124,87}}),Line(visible = true, points = {{ -19,78},{121,78}}),Text(visible = true, extent = {{ -17,83},{6,92}}, textString = "s max", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{114,81},{124,78},{114,75},{114,81}}),Line(visible = true, points = {{5,26},{5,63}}),Line(visible = true, points = {{ -77,58},{ -1,58}}),Text(visible = true, extent = {{ -75,60},{ -38,71}}, textString = "Position s", fontName = "Arial"),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -5,61},{5,58},{ -5,55},{ -5,61}}),Line(visible = true, points = {{ -100, -10},{ -100, -60}}),Line(visible = true, points = {{100, -10},{100, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{90, -47},{100, -50},{90, -53},{90, -47}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -90, -47},{ -90, -53},{ -100, -50},{ -90, -47}}),Line(visible = true, points = {{ -90, -50},{92, -50}}),Text(visible = true, extent = {{ -11, -46},{26, -36}}, textString = "Length L", fontName = "Arial")}));
// 
//       equation 
//         f0 = F_Coulomb + F_Stribeck;
//         f0_max = f0 * 1.001;
//         free = f0 <= 0 and F_prop <= 0 and s > smin + L / 2 and s < smax - L / 2;
//         v = der(s);
//         a = der(v);
//         v_relfric = v;
//         a_relfric = a;
//         0 = flange_a.f + flange_b.f - f - m * der(v);
//         f = if locked then sa else if free then 0 else if startForward then F_prop * v + F_Coulomb + F_Stribeck else if startBackward then F_prop * v - F_Coulomb - F_Stribeck else if pre(mode) == Forward then F_prop * v + F_Coulomb + F_Stribeck * exp( -fexp * abs(v)) else F_prop * v - F_Coulomb - F_Stribeck * exp( -fexp * abs(v));
//       algorithm 
//         when initial() then
//                   assert(s > smin + L / 2 or s >= smin + L / 2 and v >= 0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//           assert(s < smax - L / 2 or s <= smax - L / 2 and v <= 0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//         
//         end when;
//         when not s < smax - L / 2 then
//                   reinit(s, smax - L / 2);
//           if not initial() or v > 0 then 
//                     reinit(v, 0);
// 
//           else 
//           end if;
//         
//         end when;
//         when not s > smin + L / 2 then
//                   reinit(s, smin + L / 2);
//           if not initial() or v < 0 then 
//                     reinit(v, 0);
// 
//           else 
//           end if;
//         
//         end when;
//       end Stop;
//       model Rod "Rod without inertia"
//         extends Interfaces.Rigid;
//         annotation(Documentation(info = "<html>
// <p>
// Rod <i>without inertia</i> and two rigidly connected flanges.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -55,0}}, color = {0,191,0}),Line(visible = true, points = {{53,0},{99,0}}, color = {0,191,0}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -55, -10},{53,10}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,40},{0,100}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -55,0}}, color = {0,191,0}),Line(visible = true, points = {{55,0},{100,0}}, color = {0,191,0}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Rectangle(visible = true, lineColor = {160,160,160}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -55, -4},{53,3}}),Line(visible = true, points = {{ -100, -29},{ -100, -61}}),Line(visible = true, points = {{100, -61},{100, -28}}),Line(visible = true, points = {{ -98, -60},{98, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -101, -60},{ -96, -59},{ -96, -61},{ -101, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{100, -60},{95, -61},{95, -59},{100, -60}}),Text(visible = true, extent = {{ -44, -57},{51, -41}}, textString = "Length L", fontName = "Arial")}));
// 
//       equation 
//         0 = flange_a.f + flange_b.f;
//       end Rod;
//       model Spring "Linear 1D translational spring"
//         extends Interfaces.Compliant;
//         parameter SI.Distance s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant ";
//         annotation(Documentation(info = "<html>
// <p>
// A <i>linear 1D translational spring</i>. The component can be connected either
// between two sliding masses, or between
// a sliding mass and the housing (model Fixed), to describe
// a coupling of the slidin mass with the housing via a spring.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Spring)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60, -90},{20, -90}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,50},{0,110}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -86,0},{ -60,0},{ -44, -30},{ -16,30},{14, -30},{44,30},{60,0},{84,0}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -100,65}}, color = {128,128,128}),Line(visible = true, points = {{100,0},{100,65}}, color = {128,128,128}),Line(visible = true, points = {{ -100,60},{100,60}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{90,63},{100,60},{90,57},{90,63}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -22,62},{18,87}}, textString = "s_rel", fontName = "Arial"),Line(visible = true, points = {{ -86,0},{ -60,0},{ -44, -30},{ -16,30},{14, -30},{44,30},{60,0},{84,0}})}));
// 
//       equation 
//         f = c * (s_rel - s_rel0);
//       end Spring;
//       model Damper "Linear 1D translational damper"
//         extends Interfaces.Compliant;
//         parameter Real d(final unit = "N/ (m/s)", final min = 0) = 0 "damping constant [N/ (m/s)]";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// <i>Linear, velocity dependent damper</i> element. It can be either connected
// between a sliding mass and the housing (model Fixed), or
// between two sliding masses.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Damper)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -60,0}}),Line(visible = true, points = {{ -60, -30},{ -60,30}}),Line(visible = true, points = {{ -60, -30},{60, -30}}),Line(visible = true, points = {{ -60,30},{60,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{30,30}}),Line(visible = true, points = {{30,0},{90,0}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,46},{0,106}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -60,0}}),Line(visible = true, points = {{ -60, -30},{ -60,30}}),Line(visible = true, points = {{ -60, -30},{60, -30}}),Line(visible = true, points = {{ -60,30},{60,30}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -60, -30},{30,30}}),Line(visible = true, points = {{30,0},{90,0}}),Line(visible = true, points = {{ -50,60},{50,60}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50,63},{60,60},{50,57},{50,63}}),Text(visible = true, fillColor = {128,128,128}, extent = {{ -40,68},{38,90}}, textString = "der(s_rel)", fontName = "Arial")}));
// 
//       equation 
//         v_rel = der(s_rel);
//         f = d * v_rel;
//       end Damper;
//       model SpringDamper "Linear 1D translational spring and damper in parallel"
//         extends Interfaces.Compliant;
//         parameter SI.Position s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant";
//         parameter Real d(final unit = "N/(m/s)", final min = 0) = 1 "damping constant";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// A <i>spring and damper element connected in parallel</i>.
// The component can be
// connected either between two sliding masses to describe the elasticity
// and damping, or between a sliding mass and the housing (model Fixed),
// to describe a coupling of the sliding mass with the housing via a spring/damper.
// <p>
// </HTML>
// ", revisions = "<html>
// <b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.SpringDamper)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,40},{ -60,40},{ -45,10},{ -15,70},{15,10},{45,70},{60,40},{80,40}}),Line(visible = true, points = {{ -80,40},{ -80, -70}}),Line(visible = true, points = {{ -80, -70},{ -52, -70}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -52, -91},{38, -49}}),Line(visible = true, points = {{ -52, -49},{68, -49}}),Line(visible = true, points = {{ -51, -91},{69, -91}}),Line(visible = true, points = {{38, -70},{80, -70}}),Line(visible = true, points = {{80,40},{80, -70}}),Line(visible = true, points = {{ -90,0},{ -80,0}}),Line(visible = true, points = {{80,0},{90,0}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{53, -18},{23, -8},{23, -28},{53, -18}}),Line(visible = true, points = {{ -57, -18},{23, -18}}),Text(visible = true, fillColor = {0,0,255}, extent = {{1,80},{1,140}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,32},{ -58,32},{ -43,2},{ -13,62},{17,2},{47,62},{62,32},{80,32}}, thickness = 0.5),Line(visible = true, points = {{ -100,31},{ -100,96}}, color = {128,128,128}),Line(visible = true, points = {{100,29},{100,94}}, color = {128,128,128}),Line(visible = true, points = {{ -98,82},{100,82}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{90,85},{100,82},{90,79},{90,85}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -21,61},{19,86}}, textString = "s_rel", fontName = "Arial"),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -52, -72},{38, -28}}),Line(visible = true, points = {{ -51, -72},{69, -72}}),Line(visible = true, points = {{ -52, -28},{68, -28}}),Line(visible = true, points = {{38, -50},{80, -50}}),Line(visible = true, points = {{ -80, -50},{ -52, -50}}),Line(visible = true, points = {{ -80,32},{ -80, -50}}),Line(visible = true, points = {{80,32},{80, -50}}),Line(visible = true, points = {{ -90,0},{ -80,0}}),Line(visible = true, points = {{90,0},{80,0}})}));
// 
//       equation 
//         v_rel = der(s_rel);
//         f = c * (s_rel - s_rel0) + d * v_rel;
//       end SpringDamper;
//       model ElastoGap "1D translational spring damper combination with gap"
//         extends Interfaces.Compliant;
//         parameter SI.Position s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant";
//         parameter Real d(final unit = "N/ (m/s)", final min = 0) = 1 "damping constant";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         Boolean Contact "false, if s_rel > l ";
//         annotation(Documentation(info = "<html>
// <p>
// A <i>linear translational spring damper combination that can lift off</i>.
// The component can be connected
// between
// a sliding mass and the housing (model Fixed), to describe
// the contact of a sliding mass with the housing.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100,0},{ -50,0}}, color = {0,191,0}),Line(visible = true, points = {{ -48,34},{ -48, -46}}, thickness = 1),Line(visible = true, points = {{8,40},{8,2}}),Line(visible = true, points = {{ -2,0},{38,0},{38,44},{ -2,44}}),Line(visible = true, points = {{38,22},{72,22}}),Line(visible = true, points = {{ -12, -38},{ -12,20}}, thickness = 1),Line(visible = true, points = {{ -12,22},{8,22}}),Line(visible = true, points = {{ -12, -38},{ -2, -38}}),Line(visible = true, points = {{72,0},{90,0}}, color = {0,191,0}),Line(visible = true, points = {{72,22},{72, -42}}),Line(visible = true, points = {{ -2, -38},{10, -28},{22, -48},{38, -28},{50, -48},{64, -28},{72, -40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{8,0},{38,44}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -28, -80},{12, -55}}, textString = "s_rel", fontName = "Arial"),Line(visible = true, points = {{ -100, -29},{ -100, -61}}),Line(visible = true, points = {{100, -61},{100, -28}}),Line(visible = true, points = {{ -98, -60},{98, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -101, -60},{ -96, -59},{ -96, -61},{ -101, -60}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{100, -60},{95, -61},{95, -59},{100, -60}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -98,0},{ -48,0}}, color = {0,191,0}),Line(visible = true, points = {{ -48,34},{ -48, -46}}, thickness = 1),Line(visible = true, points = {{8,40},{8,2}}),Line(visible = true, points = {{ -2,0},{38,0},{38,44},{ -2,44}}),Line(visible = true, points = {{38,22},{72,22}}),Line(visible = true, points = {{ -12, -38},{ -12,20}}, thickness = 1),Line(visible = true, points = {{ -12,22},{8,22}}),Line(visible = true, points = {{ -12, -38},{ -2, -38}}),Line(visible = true, points = {{72,0},{98,0}}, color = {0,191,0}),Line(visible = true, points = {{72,22},{72, -42}}),Line(visible = true, points = {{ -2, -38},{10, -28},{22, -48},{38, -28},{50, -48},{64, -28},{72, -40}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{8,0},{38,44}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,60},{0,120}}, textString = "%name", fontName = "Arial")}));
// 
//       equation 
//         v_rel = der(s_rel);
//         Contact = s_rel < s_rel0;
//         f = if Contact then c * (s_rel - s_rel0) + d * v_rel else 0;
//       end ElastoGap;
//       model Position "Forced movement of a flange according to a reference position"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal" annotation(Dialog(enable = not exact));
//         output SI.Position s "absolute position of flange_b";
//         output SI.Velocity v "absolute velocity of flange_b";
//         output SI.Acceleration a "absolute acceleration of flange_b";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>s_ref</b> defines the <b>reference
// position</b> in [m]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference position is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference position is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>.<br>
//        Realized.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -126, -78},{ -40, -40}}, textString = "s_ref", fontName = "Arial"),Line(visible = true, points = {{ -95,0},{90,0}}, color = {0,191,0}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,26},{0,86}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{46, -90},{26, -85},{26, -95},{46, -90}}),Line(visible = true, points = {{ -44, -90},{27, -90}}, color = {128,128,128})}));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput s_ref(redeclare type SignalType = SI.Position) "reference position of flange as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//       protected 
//         parameter Real w_crit = 2 * Modelica.Constants.pi * f_crit "critical frequency in [1/s]";
//         constant Real af = 1.3617 "s coefficient of Bessel filter";
//         constant Real bf = 0.618 "s*s coefficient of Bessel filter";
// 
//       equation 
//         s = flange_b.s;
//         v = der(s);
//         a = der(v);
//         if exact then
//           s = s_ref;
// 
//         else
//           a = (((s_ref - s) * w_crit - af * v) * w_crit) / bf;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   s = s_ref;
//         end if;
//       end Position;
//       model Speed "Forced movement of a flange according to a reference speed"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal" annotation(Dialog(enable = not exact));
//         parameter SI.Position s_start = 0 "Start position of flange_b";
//         output SI.Position s "absolute position of flange_b";
//         output SI.Velocity v "absolute velocity of flange_b";
//         annotation(Documentation(info = "<HTML>
// <p>
// The input signal <b>v_ref</b> defines the <b>reference
// speed</b> in [m/s]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference speed is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least once. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal once
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference speed is <b>filtered</b> and the first derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This first derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a first order filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -126, -78},{ -40, -40}}, textString = "v_ref", fontName = "Arial"),Line(visible = true, points = {{ -95,0},{90,0}}, color = {0,191,0}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,26},{0,86}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{46, -90},{26, -85},{26, -95},{46, -90}}),Line(visible = true, points = {{ -44, -90},{27, -90}}, color = {128,128,128})}));
//         Modelica.Blocks.Interfaces.RealInput v_ref(redeclare type SignalType = SI.Position) "reference speed of flange as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b "Flange that is forced to move according to input signals u" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         parameter Real w_crit = 2 * Modelica.Constants.pi * f_crit "critical frequency in [1/s]";
//         SI.Acceleration a "absolute acceleration of flange_b if exact=false (a=0, if exact=true)";
// 
//       equation 
//         s = flange_b.s;
//         v = der(s);
//         if exact then
//           v = v_ref;
//           a = 0;
// 
//         else
//           a = der(v);
//           a = (v_ref - v) * w_crit;
// 
//         end if;
// 
//       initial equation 
//         s = s_start;
// if not exact then
//                   v = v_ref;
//         end if;
//       end Speed;
//       model Accelerate "Forced movement of a flange according to an acceleration signal"
//         parameter SI.Position s_start = 0 "Start position";
//         parameter SI.Velocity v_start = 0 "Start velocity";
//         SI.Velocity v(final start = v_start, final fixed = true) "absolute velocity of flange_b";
//         SI.Position s(final start = s_start, final fixed = true) "absolute position of flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// The input signal <b>a</b> in [m/s2] moves the 1D translational flange
// connector flange_b with a predefined <i>acceleration</i>, i.e., the flange
// is <i>forced</i> to move with this acceleration. The velocity and the
// position of the flange are also predefined and are determined by
// integration of the acceleration.
// </p>
// <p>
// The acceleration \"a(t)\" can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Source.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.AccMotion)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -95,0},{90,0}}, color = {0,191,0}),Text(visible = true, extent = {{ -124, -58},{ -75, -18}}, textString = "a", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{0,20},{0,80}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}})}));
//         Modelica.Blocks.Interfaces.RealInput a(redeclare type SignalType = SI.Acceleration) "absolute acceleration of flange as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         s = flange_b.s;
//         v = der(s);
//         a = der(v);
//       end Accelerate;
//       model Move "Forced movement of a flange according to a position, velocity and acceleration signal"
//         SI.Position s "absolute position of flange_b";
//         SI.Velocity v "absolute velocity of flange_b";
//         SI.Acceleration a "absolute acceleration of flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// Flange <b>flange_b</b> is <b>forced</b> to move with a predefined motion
// according to the input signals:
// </p>
// <pre>
//     u[1]: position of flange
//     u[2]: velocity of flange
//     u[3]: acceleration of flange
// </pre>
// <p>
// The user has to guarantee that the input signals are consistent to each other,
// i.e., that u[2] is the derivative of u[1] and that
// u[3] is the derivative of u. There are, however,
// also applications where by purpose these conditions do not hold. For example,
// if only the position dependent terms of a mechanical system shall be
// calculated, one may provide position = position(t) and set the velocity
// and the acceleration to zero.
// </p>
// <p>
// The input signals can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
//  
// </html>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 25, 2001</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -140, -100},{20, -62}}, textString = "s,v,a", fontName = "Arial"),Line(visible = true, points = {{ -95,0},{90,0}}, color = {0,191,0}),Text(visible = true, fillColor = {0,0,255}, extent = {{0,20},{0,80}}, textString = "%name", fontName = "Arial")}));
//         Modelica.Blocks.Interfaces.RealInput u[3] "position, velocity and acceleration of flange as input signals" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         Interfaces.Flange_b flange_b "Flange that is forced to move according to input signals u" annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//       protected 
//         function position
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           output Real q;
//           annotation(derivative(noDerivative = q_qd_qdd) = position_der, InlineAfterIndexReduction = true);
//         algorithm 
//           q:=q_qd_qdd[1];
//         end position;
//         function position_der
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           input Real dummy_der;
//           output Real qd;
//           annotation(derivative(noDerivative = q_qd_qdd) = position_der2, InlineAfterIndexReduction = true);
//         algorithm 
//           qd:=q_qd_qdd[2];
//         end position_der;
//         function position_der2
//           input Real q_qd_qdd[3] "Required values for position, speed, acceleration";
//           input Real dummy "Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)";
//           input Real dummy_der;
//           input Real dummy_der2;
//           output Real qdd;
//         algorithm 
//           qdd:=q_qd_qdd[3];
//         end position_der2;
// 
//       equation 
//         s = flange_b.s;
//         s = position(u, time);
//         v = der(s);
//         a = der(v);
//       end Move;
//       model Fixed "Fixed flange"
//         parameter SI.Position s0 = 0 "fixed offset position of housing";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -40},{80, -40}}),Line(visible = true, points = {{80, -40},{40, -80}}),Line(visible = true, points = {{40, -40},{0, -80}}),Line(visible = true, points = {{0, -40},{ -40, -80}}),Line(visible = true, points = {{ -40, -40},{ -80, -80}}),Line(visible = true, points = {{0, -40},{0, -10}}),Text(visible = true, fillColor = {0,0,255}, extent = {{0, -150},{0, -90}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80, -40},{80, -40}}),Line(visible = true, points = {{80, -40},{40, -80}}),Line(visible = true, points = {{40, -40},{0, -80}}),Line(visible = true, points = {{0, -40},{ -40, -80}}),Line(visible = true, points = {{ -40, -40},{ -80, -80}}),Line(visible = true, points = {{0, -40},{0, -4}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}})}), Documentation(info = "<html>
// <p>
// The <i>flange</i> of a 1D translational mechanical system <i>fixed</i>
// at an position s0 in the <i>housing</i>. May be used:
// </p>
// <ul>
// <li> to connect a compliant element, such as a spring or a damper,
//      between a sliding mass and the housing.
// <li> to fix a rigid element, such as a sliding mass, at a specific
//      position.
// </ul>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.LockedR)</i> </li>
// </ul>
// </html>"));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {0,0}, extent = {{ -10,10},{10, -10}}, rotation =  -180), iconTransformation(origin = {0,0}, extent = {{ -10,10},{10, -10}}, rotation =  -180)));
// 
//       equation 
//         flange_b.s = s0;
//       end Fixed;
//       model Force "External force acting on a drive train element as input signal"
//         annotation(Documentation(info = "<html>
// <p>
// The input signal \"s\" in [N] characterizes an <i>external
// force</i> which acts (with positive sign) at a flange,
// i.e., the component connected to the flange is driven by force f.
// </p>
// <p>
// Input signal s can be provided from one of the signal generator
// blocks of Modelica.Blocks.Source.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Torque1D)</i> </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, fillPattern = FillPattern.Solid, points = {{ -100,10},{20,10},{20,41},{90,0},{20, -41},{20, -10},{ -100, -10},{ -100,10}}),Text(visible = true, extent = {{ -100, -88},{ -47, -40}}, textString = "f", fontName = "Arial"),Text(visible = true, fillColor = {0,0,255}, extent = {{0,49},{0,109}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{50, -90},{20, -80},{20, -100},{50, -90}}),Line(visible = true, points = {{ -60, -90},{20, -90}}),Polygon(visible = true, lineColor = {0,191,0}, fillColor = {0,191,0}, fillPattern = FillPattern.Solid, points = {{ -100,10},{20,10},{20,41},{90,0},{20, -41},{20, -10},{ -100, -10},{ -100,10}})}));
//         Interfaces.Flange_b flange_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput f(redeclare type SignalType = SI.Force) "driving force as input signal" annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         flange_b.f =  -f;
//       end Force;
//       model RelativeStates "Definition of relative state variables"
//         extends Interfaces.TwoFlanges;
//         SI.Position s_rel(stateSelect = StateSelect.prefer) "relative position used as state variable";
//         SI.Velocity v_rel(stateSelect = StateSelect.prefer) "relative velocity used as state variable";
//         SI.Acceleration a_rel "relative angular acceleration";
//         annotation(Documentation(info = "<html>
// <p>
// Usually, the absolute position and the absolute velocity of
// Modelica.Mechanics.Translational.Inertia models are used as state variables.
// In some circumstances, relative quantities are better suited, e.g.,
// because it may be easier to supply initial values.
// In such cases, model <b>RelativeStates</b> allows the definition of state variables
// in the following way:
// </p>
// <ul>
// <li> Connect an instance of this model between two flange connectors.</li>
// <li> The <b>relative position</b> and the <b>relative velocity</b>
//      between the two connectors are used as <b>state variables</b>.
// </ul>
// <p>
// An example is given in the next figure
// </p>
// <IMG SRC=\"../Images/relativeStates2.png\" ALT=\"relativeStates2\">
// <p>
// Here, the relative position and the relative velocity between
// the two masses are used as state variables. Additionally, the
// simulator selects either the absolute position and absolute
// velocity of model mass1 or of model mass2 as state variables.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,255,255}, fillColor = {0,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, extent = {{ -40, -40},{40,40}}, textString = "S", fontName = "Arial"),Line(visible = true, points = {{ -92,0},{ -42,0}}, pattern = LinePattern.Dot),Line(visible = true, points = {{40,0},{90,0}}, pattern = LinePattern.Dot),Text(visible = true, fillColor = {0,0,255}, extent = {{0,50},{0,110}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {0,255,255}, fillColor = {0,255,255}, fillPattern = FillPattern.Solid, extent = {{ -40, -40},{40,40}}),Text(visible = true, extent = {{ -40, -40},{40,40}}, textString = "S", fontName = "Arial"),Line(visible = true, points = {{40,0},{90,0}}, pattern = LinePattern.Dash),Line(visible = true, points = {{ -100, -10},{ -100, -80}}, color = {160,160,160}),Line(visible = true, points = {{100, -10},{100, -80}}, color = {160,160,160}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{80, -65},{80, -55},{100, -60},{80, -65}}),Line(visible = true, points = {{ -100, -60},{80, -60}}, color = {160,160,160}),Text(visible = true, extent = {{ -30, -90},{30, -70}}, textString = "w_rel", fontName = "Arial"),Line(visible = true, points = {{ -76,80},{ -5,80}}, color = {128,128,128}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{14,80},{ -6,85},{ -6,75},{14,80}}),Text(visible = true, fillColor = {128,128,128}, extent = {{18,74},{86,87}}, textString = "rotation axis", fontName = "Arial"),Line(visible = true, points = {{ -90,0},{ -40,0}}, pattern = LinePattern.Dash)}));
// 
//       equation 
//         s_rel = flange_b.s - flange_a.s;
//         v_rel = der(s_rel);
//         a_rel = der(v_rel);
//         flange_a.f = 0;
//         flange_b.f = 0;
//       end RelativeStates;
//     end Translational;
//   end Mechanics;
//   package Thermal "Library to model thermal systems (heat transfer, simple thermo-fluid pipe flow)"
//     extends Modelica.Icons.Library;
//     annotation(Documentation(info = "<html>
// <p>
// This package contains libraries to model heat transfer
// and fluid heat flow.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package FluidHeatFlow "Simple components for 1-dimensional incompressible thermo-fluid flow models"
//       extends Modelica.Icons.Library2;
//       annotation(version = "1.50", versionDate = "2005-09-07", preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains very simple-to-use components to model coolant flows as needed to simulate cooling e.g. of electric machines:
// <ul>
// <li>Components: components like different types of pipe models</li>
// <li>Examples: some test examples</li>
// <li>Interfaces: definition of connectors and partial models 
// (containing the core thermodynamic equations)</li>
// <li>Media: definition of media properties</li>
// <li>Sensors: various sensors for pressure, temperature, volume and enthalpy flow</li>
// <li>Sources: various flow sources</li>
// </ul>
// </p>
// <p>
// <b>Variables used in connectors:</b>
// <ul>
// <li>Pressure p</li>
// <li>flow MassFlowRate m_flow</li>
// <li>SpecificEnthalpy h</li>
// <li>flow EnthalpyFlowRate H_flow</li>
// </ul>
// EnthalpyFlowRate means the Enthalpy = cp<sub>constant</sub> * m * T that is carried by the medium's flow.
// </p>
// <p>
// <b>Limitations and assumptions:</b>
// <ul>
// <li>Splitting and mixing of coolant flows (media with the same cp) is possible.</li>
// <li>Reversing the direction of flow is possible.</li>
// <li>The medium is considered to be incompressible.</li>
// <li>No mixtures of media is taken into consideration.</li>
// <li>The medium may not change its phase.</li>
// <li>Medium properties are kept constant.</li>
// <li>Pressure changes are only due to pressure drop and geodetic height differnence rho*g*h (if h > 0).</li>
// <li>A user-defined part (0..1) of the friction losses (V_flow*dp) are fed to the medium.</li>
// <li><b>Note:</b> Connected flowPorts have the same temperature (mixing temperature)!<br>
// Since mixing may occur, the outlet temperature may be different from the connector's temperature.<br> 
// Outlet temperature is defined by variable T of the corresponding component.</li>
// </ul>
// </p>
// <p>
// <b>Further development:</b>
// <ul>
// <li>Additional components like tanks (if needed)</li>
// </ul>
// </p>
// <p>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// </HTML>", revisions = "<HTML>
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.10 2005/02/15 Anton Haumer<br>
//        reorganisation of the package</li>
//   <li> v1.11 2005/02/18 Anton Haumer<br>
//        corrected usage of cv and cp</li>
//   <li> v1.20 Beta 2005/02/18 Anton Haumer<br>
//        introduced geodetic height in Components.Pipes<br>
//        <i>new models: Components.Valve, Sources.IdealPump</i></li>
//   <li> v1.30 Beta 2005/06/02 Anton Haumer<br>
//        friction losses are fed to medium</li>
//   <li> v1.31 Beta 2005/06/04 Anton Haumer<br>
//        <i>new example: PumpAndValve</i><br>
//        <i>new example: PumpDropOut</i></li>
//   <li> v1.33 Beta 2005/06/07 Anton Haumer<br>
//        corrected usage of simpleFlow</li>
//   <li> v1.40 2005/06/13 Anton Haumer<br>
//        stable release</li>
//   <li> v1.42 Beta 2005/06/18 Anton Haumer<br>
//        <i>new test example: ParallelPumpDropOut</i></li>
//   <li> v1.43 Beta 2005/06/20 Anton Haumer<br>
//        Test of mixing / semiLinear<br>
//        <i>new test example: OneMass</i><br>
//        <i>new test example: TwoMass</i></li>
//   <li> v1.50 2005/09/07 Anton Haumer<br>
//        semiLinear works fine</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,127,255}, fillColor = {0,127,255}, fillPattern = FillPattern.Solid, points = {{ -80,10},{ -60, -10},{ -80, -30},{ -20, -30},{0, -10},{ -20,10},{ -80,10}}),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -40, -90},{ -20, -70},{0, -90},{0, -50},{ -20, -30},{ -40, -50},{ -40, -90}}),Polygon(visible = true, lineColor = {255,127,0}, fillColor = {255,127,0}, fillPattern = FillPattern.Solid, points = {{ -20,10},{0, -10},{ -20, -30},{40, -30},{60, -10},{40,10},{ -20,10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Examples "Examples that demonstrate the usage of the FluidHeatFlow components"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains test examples:
// <ul>
// <li>1.SimpleCooling: heat is dissipated through a media flow</li>
// <li>2.ParallelCooling: two heat sources dissipate through merged media flows</li>
// <li>3.IndirectCooling: heat is disspated through two cooling cycles</li>
// <li>4.PumpAndValve: demonstrates usage of an IdealPump and a Valve</li>
// <li>5.PumpDropOut: demonstrates shutdown and restart of a pump</li>
// <li>6.ParallelPumpDropOut: demonstrates shutdown and restart of a pump in a parallel circuit</li>
// <li>7.OneMass: cooling of a mass (thermal capacity) by a coolant flow</li>
// <li>8.TwoMass: cooling of two masses (thermal capacities) by two parallel coolant flows</li>
// </ul>
// </p>
// 
// </HTML>", revisions = "<HTML>
// <p>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.31 Beta 2005/06/04 Anton Haumer<br>
//        <i>new example: PumpAndValve</i><br>
//        <i>new example: PumpDropOut</i></li>
//   <li> v1.42 Beta 2005/06/18 Anton Haumer<br>
//        <i>new test example: ParallelPumpDropOut</i></li>
//   <li> v1.43 Beta 2005/06/20 Anton Haumer<br>
//        Test of mixing / semiLinear<br>
//        <i>new test example: OneMass</i><br>
//        <i>new test example: TwoMass</i></li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {128,128,128}, extent = {{ -60, -90},{40,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -30, -12},{ -30, -68},{28, -40},{ -30, -12}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model SimpleCooling
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 1st test example: SimpleCooling
// </p>
// <p>
// A prescribed heat source dissipates its heat through a thermal conductor to a coolant flow. The coolant flow is taken from an ambient and driven by a pump with prescribed mass flow.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td><b>output</b></td>
// <td><b>explanation</b></td>
// <td><b>formula</b></td>
// <td><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td>dTSource</td>
// <td>Source over Ambient</td>
// <td>dtCoolant + dtToPipe</td>
// <td>20 K</td>
// </tr>
// <tr>
// <td>dTtoPipe</td>
// <td>Source over Coolant</td>
// <td>Losses / ThermalConductor.G</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTCoolant</td>
// <td>Coolant's temperature increase</td>
// <td>Losses * cp * massFlow</td>
// <td>10 K</td>
// </tr>
// </table>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.0), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over Coolant";
//           output Modelica.SIunits.Temperature dTCoolant = Pipe1.dT "Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {40, -50}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant VolumeFlow(k = 1) annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow(k = 10) annotation(Placement(visible = true, transformation(origin = { -50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G(k = 1) annotation(Placement(visible = true, transformation(origin = { -20, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Convection Convection1 annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
// 
//         equation 
//           connect(VolumeFlow.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(HeatFlow.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -50},{ -30, -50}}, color = {0,0,255}));
//           connect(Pipe1.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{0,0}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(Convection1.solid,PrescribedHeatFlow1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{ -10, -50}}, color = {191,0,0}));
//           connect(Convection1.solid,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{30, -50}}, color = {191,0,0}));
//           connect(Pipe1.heatPort,Convection1.fluid) annotation(Line(visible = true, points = {{10, -10},{10, -20}}, color = {191,0,0}));
//           connect(G.y,Convection1.Gc) annotation(Line(visible = true, points = {{ -9, -30},{0, -30}}, color = {0,0,191}));
//         end SimpleCooling;
//         model ParallelCooling
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 2nd test example: ParallelCooling
// </p>
// <p>
// Two prescribed heat sources dissipate their heat through thermal conductors to coolant flows. The coolant flow is taken from an ambient and driven by a pump with prescribed mass flow, then splitted into two coolant flows connected to the two heat sources, and afterwards merged. Splitting of coolant flows is determined by pressure drop characteristic of the two pipes.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td><b>output</b></td>
// <td><b>explanation</b></td>
// <td><b>formula</b></td>
// <td><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td>dTSource1</td>
// <td>Source1 over Ambient</td>
// <td>dTCoolant1 + dTtoPipe1</td>
// <td>15 K</td>
// </tr>
// <tr>
// <td>dTtoPipe1</td>
// <td>Source1 over Coolant1</td>
// <td>Losses1 / ThermalConductor1.G</td>
// <td> 5 K</td>
// </tr>
// <tr>
// <td>dTCoolant1</td>
// <td>Coolant's temperature increase</td>
// <td>Losses * cp * totalMassFlow/2</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTSource2</td>
// <td>Source2 over Ambient</td>
// <td>dTCoolant2 + dTtoPipe2</td>
// <td>30 K</td>
// </tr>
// <tr>
// <td>dTtoPipe2</td>
// <td>Source2 over Coolant2</td>
// <td>Losses2 / ThermalConductor2.G</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTCoolant2</td>
// <td>Coolant's temperature increase</td>
// <td>Losses * cp * totalMassFlow/2</td>
// <td>20 K</td>
// </tr>
// <tr>
// <td>dTmixedCoolant</td>
// <td>mixed Coolant's temperature increase</td>
// <td>(dTCoolant1+dTCoolant2)/2</td>
// <td>15 K</td>
// </tr>
// </table>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.0), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource1 = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source1 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe1 = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source1 over Coolant1";
//           output Modelica.SIunits.Temperature dTCoolant1 = Pipe1.dT "Coolant1's temperature increase";
//           output Modelica.SIunits.Temperature dTSource2 = PrescribedHeatFlow2.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source2 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe2 = PrescribedHeatFlow2.port.T - Pipe2.heatPort.T "Source2 over Coolant2";
//           output Modelica.SIunits.Temperature dTCoolant2 = Pipe2.dT "Coolant2's temperature increase";
//           output Modelica.SIunits.Temperature dTmixedCoolant = Ambient2.T_port - Ambient1.T_port "mixed Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe2(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,10}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           FluidHeatFlow.Components.IsolatedPipe Pipe3(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {40, -60}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -60}, extent = {{10, -10},{ -10,10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow2 annotation(Placement(visible = true, transformation(origin = { -20,60}, extent = {{10,10},{ -10, -10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.Convection Convection2 annotation(Placement(visible = true, transformation(origin = {10,40}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Modelica.Blocks.Sources.Constant VolumeFlow(k = 1) annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow1(k = 5) annotation(Placement(visible = true, transformation(origin = { -50, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow2(k = 10) annotation(Placement(visible = true, transformation(origin = { -50,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G1(k = 1) annotation(Placement(visible = true, transformation(origin = { -20, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G2(k = 1) annotation(Placement(visible = true, transformation(origin = { -20,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor2(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {37.5,60}, extent = {{10,10},{ -10, -10}}, rotation =  -270)));
//           Modelica.Thermal.HeatTransfer.Convection Convection1 annotation(Placement(visible = true, transformation(origin = {10, -40}, extent = {{10,10},{ -10, -10}}, rotation =  -90)));
// 
//         equation 
//           connect(Pipe3.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{60,0},{80,0}}, color = {255,0,0}));
//           connect(Pipe1.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20, -10},{30, -10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Pipe2.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20,10},{30,10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Convection2.solid,PrescribedHeatFlow2.port) annotation(Line(visible = true, points = {{10,50},{10,60},{ -10,60}}, color = {191,0,0}));
//           connect(Convection2.fluid,Pipe2.heatPort) annotation(Line(visible = true, points = {{10,30},{10,20}}, color = {191,0,0}));
//           connect(G2.y,Convection2.Gc) annotation(Line(visible = true, points = {{ -9,40},{0,40}}, color = {0,0,191}));
//           connect(VolumeFlow.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(HeatFlow1.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -60},{ -30, -60}}, color = {0,0,255}));
//           connect(HeatFlow2.y,PrescribedHeatFlow2.Q_flow) annotation(Line(visible = true, points = {{ -39,60},{ -30,60}}, color = {0,0,255}));
//           connect(Pump1.flowPort_b,Pipe2.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10,10},{0,10}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10, -10},{0, -10}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(Convection2.solid,HeatCapacitor2.port) annotation(Line(visible = true, points = {{10,50},{10,60},{27.5,60}}, color = {191,0,0}));
//           connect(G1.y,Convection1.Gc) annotation(Line(visible = true, points = {{ -9, -40},{0, -40}}, color = {0,0,191}));
//           connect(Pipe1.heatPort,Convection1.fluid) annotation(Line(visible = true, points = {{10, -20},{10, -30}}, color = {191,0,0}));
//           connect(Convection1.solid,PrescribedHeatFlow1.port) annotation(Line(visible = true, points = {{10, -50},{10, -60},{ -10, -60}}, color = {191,0,0}));
//           connect(Convection1.solid,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -50},{10, -60},{30, -60}}, color = {191,0,0}));
//         end ParallelCooling;
//         model IndirectCooling
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 3rd test example: IndirectCooling
// </p>
// <p>
// A prescribed heat sources dissipates its heat through a thermal conductor to the inner coolant cycle. It is necessary to define the pressure level of the inner coolant cycle. The inner coolant cycle is coupled to the outer coolant flow through a thermal conductor.<br>
// Inner coolant's temperature rise near the source is the same as temperature drop near the cooler.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td><b>output</b></td>
// <td><b>explanation</b></td>
// <td><b>formula</b></td>
// <td><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td>dTSource</td>
// <td>Source over Ambient</td>
// <td>dtouterCoolant + dtCooler + dTinnerCoolant + dtToPipe</td>
// <td>40 K</td>
// </tr>
// <tr>
// <td>dTtoPipe</td>
// <td>Source over inner Coolant</td>
// <td>Losses / ThermalConductor.G</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTinnerColant</td>
// <td>inner Coolant's temperature increase</td>
// <td>Losses * cp * innerMassFlow</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTCooler</td>
// <td>Cooler's temperature rise between inner and outer pipes</td>
// <td>Losses * (innerGc + outerGc)</td>
// <td>10 K</td>
// </tr>
// <tr>
// <td>dTouterColant</td>
// <td>outer Coolant's temperature increase</td>
// <td>Losses * cp * outerMassFlow</td>
// <td>10 K</td>
// </tr>
// </table>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.5), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium outerMedium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter FluidHeatFlow.Media.Medium innerMedium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over inner Coolant";
//           output Modelica.SIunits.Temperature dTinnerCoolant = Pipe1.dT "inner Coolant's temperature increase";
//           output Modelica.SIunits.Temperature dTCooler = innerPipe.heatPort.T - outerPipe.heatPort.T "Cooler's temperature increase between inner and outer pipes";
//           output Modelica.SIunits.Temperature dTouterCoolant = outerPipe.dT "outer Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = outerMedium) annotation(Placement(visible = true, transformation(origin = { -70,70}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow outerPump(medium = outerMedium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = outerMedium) annotation(Placement(visible = true, transformation(origin = {50,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.05) annotation(Placement(visible = true, transformation(origin = {40, -90}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -90}, extent = {{10, -10},{ -10,10}}, rotation =  -180)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = innerMedium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb), V_flowLaminar = 1, dpLaminar = 1000, V_flowNominal = 2, dpNominal = 2000) annotation(Placement(visible = true, transformation(origin = {10, -40}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.AbsolutePressure AbsolutePressure1(p = 10000, medium = innerMedium) annotation(Placement(visible = true, transformation(origin = {50, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow(k = 10) annotation(Placement(visible = true, transformation(origin = { -50, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant outerVolumeFlow(k = 1) annotation(Placement(visible = true, transformation(origin = { -50,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant innerVolumeFlow(k = 1) annotation(Placement(visible = true, transformation(origin = { -50, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant outerGc(k = 2) annotation(Placement(visible = true, transformation(origin = { -30,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant innerGc(k = 2) annotation(Placement(visible = true, transformation(origin = { -30,10}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe outerPipe(medium = outerMedium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,70}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe innerPipe(medium = innerMedium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10, -20}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Convection innerConvection annotation(Placement(visible = true, transformation(origin = {10,10}, extent = {{10, -10},{ -10,10}}, rotation = 90)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow innerPump(medium = innerMedium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -20, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor1(G = 1) annotation(Placement(visible = true, transformation(origin = {10, -70}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
//           Modelica.Thermal.HeatTransfer.Convection outerConvection annotation(Placement(visible = true, transformation(origin = {10,40}, extent = {{10,10},{ -10, -10}}, rotation =  -90)));
// 
//         equation 
//           connect(innerGc.y,innerConvection.Gc) annotation(Line(visible = true, points = {{ -19,10},{0,10}}, color = {0,0,191}));
//           connect(innerConvection.fluid,innerPipe.heatPort) annotation(Line(visible = true, points = {{10,0},{10, -10}}, color = {191,0,0}));
//           connect(outerPipe.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{20,70},{40,70}}, color = {255,0,0}));
//           connect(outerPump.flowPort_b,outerPipe.flowPort_a) annotation(Line(visible = true, points = {{ -20,70},{0,70}}, color = {255,0,0}));
//           connect(innerPipe.flowPort_b,AbsolutePressure1.flowPort) annotation(Line(visible = true, points = {{20, -20},{40, -20},{40, -30}}, color = {255,0,0}));
//           connect(outerVolumeFlow.y,outerPump.VolumeFlow) annotation(Line(visible = true, points = {{ -39,90},{ -30,90},{ -30,80}}, color = {0,0,191}));
//           connect(HeatFlow.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -90},{ -30, -90}}, color = {0,0,255}));
//           connect(AbsolutePressure1.flowPort,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{40, -30},{40, -40},{20, -40}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,outerPump.flowPort_a) annotation(Line(visible = true, points = {{ -60,70},{ -40,70}}, color = {255,0,0}));
//           connect(Pipe1.flowPort_b,innerPump.flowPort_a) annotation(Line(visible = true, points = {{0, -40},{ -20, -40}}, color = {255,0,0}));
//           connect(innerVolumeFlow.y,innerPump.VolumeFlow) annotation(Line(visible = true, points = {{ -39, -30},{ -30, -30}}, color = {0,0,191}));
//           connect(innerPump.flowPort_b,innerPipe.flowPort_a) annotation(Line(visible = true, points = {{ -20, -20},{0, -20}}, color = {255,0,0}));
//           connect(PrescribedHeatFlow1.port,ThermalConductor1.port_a) annotation(Line(visible = true, points = {{ -10, -90},{10, -90},{10, -80}}, color = {191,0,0}));
//           connect(HeatCapacitor1.port,ThermalConductor1.port_a) annotation(Line(visible = true, points = {{30, -90},{10, -90},{10, -80}}, color = {191,0,0}));
//           connect(Pipe1.heatPort,ThermalConductor1.port_b) annotation(Line(visible = true, points = {{10, -50},{10, -60}}, color = {191,0,0}));
//           connect(outerPipe.heatPort,outerConvection.fluid) annotation(Line(visible = true, points = {{10,60},{10,50}}, color = {191,0,0}));
//           connect(outerConvection.solid,innerConvection.solid) annotation(Line(visible = true, points = {{10,30},{10,20}}, color = {191,0,0}));
//           connect(outerGc.y,outerConvection.Gc) annotation(Line(visible = true, points = {{ -19,40},{0,40}}, color = {0,0,191}));
//         end IndirectCooling;
//         model PumpAndValve
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 4th test example: PumpAndValve
// </p>
// <p>
// The pump is running with half speed for 0.4 s, 
// afterwards with full speed (using a ramp of 0.1 s).<br> 
// The valve is half open for 0.9 s, afterwards full open (using a ramp of 0.1 s).
// </p>
// <p>
// You may try to<br>
// <ul>
// <li>drive the pump with variable speed and let the valve full open 
//     to regulate the volume flow rate of coolant</li>
// <li>drive the pump with constant speed and throttle the valve 
//     to regulate the volume flow rate of coolant</li>
// </ul>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over Coolant";
//           output Modelica.SIunits.Temperature dTCoolant = Pipe1.dT "Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.IdealPump IdealPump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -50,0}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           FluidHeatFlow.Components.Valve Valve1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb), LinearCharacteristic = false) annotation(Placement(visible = true, transformation(origin = { -20,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, T0 = Modelica.SIunits.Conversions.from_degC(TAmb), m = 0.1) annotation(Placement(visible = true, transformation(origin = {10,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {40, -50}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow(k = 10) annotation(Placement(visible = true, transformation(origin = { -50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G(k = 1) annotation(Placement(visible = true, transformation(origin = { -20, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp speedRamp(height = 0.5, offset = 0.5, duration = 0.1, startTime = 0.4) annotation(Placement(visible = true, transformation(origin = { -70,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp valveRamp(height = 0.5, offset = 0.5, duration = 0.1, startTime = 0.9) annotation(Placement(visible = true, transformation(origin = {2,50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Mechanics.Rotational.Speed Speed1(exact = true) annotation(Placement(visible = true, transformation(origin = { -50,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.Convection Convection1 annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
// 
//         equation 
//           connect(valveRamp.y,Valve1.y) annotation(Line(visible = true, points = {{ -9,50},{ -20,50},{ -20,9}}, color = {0,0,191}));
//           connect(Valve1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -10,0},{0,0}}, color = {255,0,0}));
//           connect(IdealPump1.flowPort_b,Valve1.flowPort_a) annotation(Line(visible = true, points = {{ -40,0},{ -30,0}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,IdealPump1.flowPort_a) annotation(Line(visible = true, points = {{ -70,0},{ -60,0}}, color = {255,0,0}));
//           connect(HeatFlow.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -50},{ -30, -50}}, color = {0,0,255}));
//           connect(Pipe1.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {255,0,0}));
//           connect(Speed1.flange_b,IdealPump1.flange_a) annotation(Line(visible = true, points = {{ -50,20},{ -50,10}}));
//           connect(speedRamp.y,Speed1.w_ref) annotation(Line(visible = true, points = {{ -59,50},{ -50,50},{ -50,42}}, color = {0,0,191}));
//           connect(Convection1.solid,PrescribedHeatFlow1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{ -10, -50}}, color = {191,0,0}));
//           connect(Convection1.solid,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{30, -50}}, color = {191,0,0}));
//           connect(Pipe1.heatPort,Convection1.fluid) annotation(Line(visible = true, points = {{10, -10},{10, -20}}, color = {191,0,0}));
//           connect(G.y,Convection1.Gc) annotation(Line(visible = true, points = {{ -9, -30},{0, -30}}, color = {0,0,191}));
//         end PumpAndValve;
//         model PumpDropOut
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 5th test example: PumpDropOut
// </p>
// <p>
// Same as 1st test example, but with a drop out of the pump:<br>
// The pump is running for 0.2 s, then shut down (using a ramp of 0.2 s) for 0.2 s, 
// then started again (using a ramp of 0.2 s).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over Coolant";
//           output Modelica.SIunits.Temperature dTCoolant = Pipe1.dT "Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, T0 = Modelica.SIunits.Conversions.from_degC(TAmb), m = 0.1) annotation(Placement(visible = true, transformation(origin = {10,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {40, -50}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -50}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           Utilities.DoubleRamp VolumeFlow annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow(k = 10) annotation(Placement(visible = true, transformation(origin = { -50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G(k = 1) annotation(Placement(visible = true, transformation(origin = { -20, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Convection Convection1 annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
// 
//         equation 
//           connect(VolumeFlow.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(HeatFlow.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -50},{ -30, -50}}, color = {0,0,255}));
//           connect(Pipe1.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{0,0}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(Convection1.solid,PrescribedHeatFlow1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{ -10, -50}}, color = {191,0,0}));
//           connect(Convection1.solid,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -40},{10, -50},{30, -50}}, color = {191,0,0}));
//           connect(Pipe1.heatPort,Convection1.fluid) annotation(Line(visible = true, points = {{10, -10},{10, -20}}, color = {191,0,0}));
//           connect(G.y,Convection1.Gc) annotation(Line(visible = true, points = {{ -9, -30},{0, -30}}, color = {0,0,191}));
//         end PumpDropOut;
//         model ParallelPumpDropOut
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 6th test example: ParallelPumpDropOut
// </p>
// <p>
// Same as 2nd test example, but with a drop out of the pump:<br>
// The pump is running for 0.2 s, then shut down (using a ramp of 0.2 s) for 0.2 s, 
// then started again (using a ramp of 0.2 s).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 2, Algorithm = "Lsodar"), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           output Modelica.SIunits.Temperature dTSource1 = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source1 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe1 = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source1 over Coolant1";
//           output Modelica.SIunits.Temperature dTCoolant1 = Pipe1.dT "Coolant1's temperature increase";
//           output Modelica.SIunits.Temperature dTSource2 = PrescribedHeatFlow2.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source2 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe2 = PrescribedHeatFlow2.port.T - Pipe2.heatPort.T "Source2 over Coolant2";
//           output Modelica.SIunits.Temperature dTCoolant2 = Pipe2.dT "Coolant2's temperature increase";
//           output Modelica.SIunits.Temperature dTmixedCoolant = Ambient2.T_port - Ambient1.T_port "mixed Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe2(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,10}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           FluidHeatFlow.Components.IsolatedPipe Pipe3(medium = medium, T0 = Modelica.SIunits.Conversions.from_degC(TAmb), m = 0.1) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {40, -60}, extent = {{10, -10},{ -10,10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow1 annotation(Placement(visible = true, transformation(origin = { -20, -60}, extent = {{10, -10},{ -10,10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.PrescribedHeatFlow PrescribedHeatFlow2 annotation(Placement(visible = true, transformation(origin = { -20,60}, extent = {{10,10},{ -10, -10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.Convection Convection2 annotation(Placement(visible = true, transformation(origin = {10,40}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Utilities.DoubleRamp VolumeFlow annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow1(k = 5) annotation(Placement(visible = true, transformation(origin = { -50, -60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant HeatFlow2(k = 10) annotation(Placement(visible = true, transformation(origin = { -50,60}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G1(k = 1) annotation(Placement(visible = true, transformation(origin = { -20, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Constant G2(k = 1) annotation(Placement(visible = true, transformation(origin = { -20,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.Convection Convection1 annotation(Placement(visible = true, transformation(origin = {10, -40}, extent = {{10,10},{ -10, -10}}, rotation =  -90)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor2(T(start = Modelica.SIunits.Conversions.from_degC(TAmb)), C = 0.1) annotation(Placement(visible = true, transformation(origin = {38,60}, extent = {{10,10},{ -10, -10}}, rotation =  -270)));
// 
//         equation 
//           connect(VolumeFlow.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(Pipe3.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{60,0},{80,0}}, color = {255,0,0}));
//           connect(Pipe1.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20, -10},{30, -10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Pipe2.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20,10},{30,10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Convection2.solid,PrescribedHeatFlow2.port) annotation(Line(visible = true, points = {{10,50},{10,60},{ -10,60}}, color = {191,0,0}));
//           connect(Convection2.fluid,Pipe2.heatPort) annotation(Line(visible = true, points = {{10,30},{10,20}}, color = {191,0,0}));
//           connect(G2.y,Convection2.Gc) annotation(Line(visible = true, points = {{ -9,40},{0,40}}, color = {0,0,191}));
//           connect(HeatFlow1.y,PrescribedHeatFlow1.Q_flow) annotation(Line(visible = true, points = {{ -39, -60},{ -30, -60}}, color = {0,0,255}));
//           connect(HeatFlow2.y,PrescribedHeatFlow2.Q_flow) annotation(Line(visible = true, points = {{ -39,60},{ -30,60}}, color = {0,0,255}));
//           connect(Pump1.flowPort_b,Pipe2.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10,10},{0,10}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10, -10},{0, -10}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(G1.y,Convection1.Gc) annotation(Line(visible = true, points = {{ -9, -40},{0, -40}}, color = {0,0,191}));
//           connect(Pipe1.heatPort,Convection1.fluid) annotation(Line(visible = true, points = {{10, -20},{10, -30}}, color = {191,0,0}));
//           connect(Convection1.solid,PrescribedHeatFlow1.port) annotation(Line(visible = true, points = {{10, -50},{10, -60},{ -10, -60}}, color = {191,0,0}));
//           connect(Convection1.solid,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -50},{10, -60},{30, -60}}, color = {191,0,0}));
//           connect(Convection2.solid,HeatCapacitor2.port) annotation(Line(visible = true, points = {{10,50},{10,60},{28,60}}, color = {191,0,0}));
//         end ParallelPumpDropOut;
//         model OneMass
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 7th test example: OneMass
// </p>
// <p>
// A thermal capacity is coupled with a coolant flow. 
// Different inital temperatures of thermal capacity and pipe's coolant get ambient's temperature, 
// the time behaviour depending on coolant flow.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.0), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           parameter Modelica.SIunits.CelsiusTemperature TMass = 40 "inital temperature of mass";
//           output Modelica.SIunits.Temperature dTMass = HeatCapacitor1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Mass over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe = HeatCapacitor1.port.T - Pipe1.heatPort.T "Mass over Coolant";
//           output Modelica.SIunits.Temperature dTCoolant = Pipe1.dT "Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 0.1, T(start = Modelica.SIunits.Conversions.from_degC(TMass))) annotation(Placement(visible = true, transformation(origin = {10, -60}, extent = {{10, -10},{ -10,10}}, rotation =  -180)));
//           Utilities.DoubleRamp DoubleRamp1(offset = 0, height_1 = 1, height_2 =  -2) annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor1(G = 1) annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
// 
//         equation 
//           connect(DoubleRamp1.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(Pipe1.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{20,0},{40,0}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{0,0}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(ThermalConductor1.port_a,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -40},{10, -40},{10, -50},{10, -50}}, color = {191,0,0}));
//           connect(Pipe1.heatPort,ThermalConductor1.port_b) annotation(Line(visible = true, points = {{10, -10},{10, -20}}, color = {191,0,0}));
//         end OneMass;
//         model TwoMass
//           extends Modelica.Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// 8th test example: TwoMass
// </p>
// <p>
// Two thermal capacities are coupled with two parallel coolant flow. 
// Different inital temperatures of thermal capacities and pipe's coolants get ambient's temperature, 
// the time behaviour depending on coolant flow.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 1.0), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.CelsiusTemperature TAmb = 20 "ambient temperature";
//           parameter Modelica.SIunits.CelsiusTemperature TMass1 = 40 "inital temperature of mass1";
//           parameter Modelica.SIunits.CelsiusTemperature TMass2 = 60 "inital temperature of mass2";
//           output Modelica.SIunits.Temperature dTMass1 = HeatCapacitor1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Mass1 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe1 = HeatCapacitor1.port.T - Pipe1.heatPort.T "Mass1 over Coolant1";
//           output Modelica.SIunits.Temperature dTCoolant1 = Pipe1.dT "Coolant1's temperature increase";
//           output Modelica.SIunits.Temperature dTMass2 = HeatCapacitor2.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Mass2 over Ambient";
//           output Modelica.SIunits.Temperature dTtoPipe2 = HeatCapacitor2.port.T - Pipe2.heatPort.T "Mass2 over Coolant2";
//           output Modelica.SIunits.Temperature dTCoolant2 = Pipe2.dT "Coolant2's temperature increase";
//           output Modelica.SIunits.Temperature dTmixedCoolant = Ambient2.T_port - Ambient1.T_port "mixed Coolant's temperature increase";
//           FluidHeatFlow.Sources.Ambient Ambient1(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = { -70,0}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.PrescribedVolumeFlow Pump1(medium = medium, m = 0, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe1(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Components.HeatedPipe Pipe2(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {10,10}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           FluidHeatFlow.Components.IsolatedPipe Pipe3(medium = medium, m = 0.1, T0 = Modelica.SIunits.Conversions.from_degC(TAmb)) annotation(Placement(visible = true, transformation(origin = {50,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           FluidHeatFlow.Sources.Ambient Ambient2(T_Ambient = Modelica.SIunits.Conversions.from_degC(TAmb), medium = medium) annotation(Placement(visible = true, transformation(origin = {90,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 0.1, T(start = Modelica.SIunits.Conversions.from_degC(TMass1))) annotation(Placement(visible = true, transformation(origin = {10, -70}, extent = {{10, -10},{ -10,10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor2(C = 0.1, T(start = Modelica.SIunits.Conversions.from_degC(TMass2))) annotation(Placement(visible = true, transformation(origin = {10,70}, extent = {{10,10},{ -10, -10}}, rotation =  -180)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor2(G = 1) annotation(Placement(visible = true, transformation(origin = {10,40}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
//           Utilities.DoubleRamp DoubleRamp1(offset = 0, height_1 = 1, height_2 =  -2) annotation(Placement(visible = true, transformation(origin = { -50,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor1(G = 1) annotation(Placement(visible = true, transformation(origin = {10, -40}, extent = {{ -10, -10},{10,10}}, rotation =  -270)));
// 
//         equation 
//           connect(DoubleRamp1.y,Pump1.VolumeFlow) annotation(Line(visible = true, points = {{ -39,20},{ -30,20},{ -30,10}}, color = {0,0,191}));
//           connect(ThermalConductor2.port_b,Pipe2.heatPort) annotation(Line(visible = true, points = {{10,30},{10,20}}, color = {191,0,0}));
//           connect(HeatCapacitor2.port,ThermalConductor2.port_a) annotation(Line(visible = true, points = {{10,60},{10,55.5},{10,50},{10,50}}, color = {191,0,0}));
//           connect(Pipe3.flowPort_b,Ambient2.flowPort) annotation(Line(visible = true, points = {{60,0},{80,0}}, color = {255,0,0}));
//           connect(Pipe1.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20, -10},{30, -10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Pipe2.flowPort_b,Pipe3.flowPort_a) annotation(Line(visible = true, points = {{20,10},{30,10},{30,0},{40,0}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe2.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10,10},{0,10}}, color = {255,0,0}));
//           connect(Pump1.flowPort_b,Pipe1.flowPort_a) annotation(Line(visible = true, points = {{ -20,0},{ -10,0},{ -10, -10},{0, -10}}, color = {255,0,0}));
//           connect(Ambient1.flowPort,Pump1.flowPort_a) annotation(Line(visible = true, points = {{ -60,0},{ -40,0}}, color = {255,0,0}));
//           connect(Pipe1.heatPort,ThermalConductor1.port_b) annotation(Line(visible = true, points = {{10, -20},{10, -30}}, color = {191,0,0}));
//           connect(ThermalConductor1.port_a,HeatCapacitor1.port) annotation(Line(visible = true, points = {{10, -50},{10, -50},{10, -60},{10, -60}}, color = {191,0,0}));
//         end TwoMass;
//         package Utilities
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<html>
// <p>
// This package contains utility components used for the test examples.
// <p>
// 
// </html>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.41 Beta 2005/06/17 Anton Haumer<br>
//        first used</li>
//   </ul>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           model DoubleRamp
//             extends Modelica.Blocks.Interfaces.SO;
//             parameter Real offset = 1 "offset of ramps";
//             parameter Modelica.SIunits.Time startTime = 0.2 "startTime of 1st ramp";
//             parameter Modelica.SIunits.Time interval = 0.2 "interval between end of 1st and beginning of 2nd ramp";
//             parameter Real height_1 =  -1 "|1st ramp|Height of ramp";
//             parameter Modelica.SIunits.Time duration_1(min = Modelica.Constants.small) = 0.2 "|1st ramp|Duration of ramp";
//             parameter Real height_2 = 1 "|2nd ramp|Height of ramp";
//             parameter Modelica.SIunits.Time duration_2(min = Modelica.Constants.small) = 0.2 "|2nd ramp|Duration of ramp";
//             annotation(Documentation(info = "<HTML>
// <p>
// Block generating the sum of two ramps.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,68},{ -80, -80}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -80,90},{ -88,68},{ -72,68},{ -80,90}}),Line(visible = true, points = {{ -90, -70},{82, -70}}, color = {192,192,192}),Polygon(visible = true, lineColor = {192,192,192}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{90, -70},{68, -62},{68, -78},{90, -70}}),Line(visible = true, points = {{ -80, -60},{ -50, -60},{ -30,60},{10,60},{30, -20},{70, -20}})}));
//             Modelica.Blocks.Math.Add Add1 annotation(Placement(visible = true, transformation(origin = {20,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Blocks.Sources.Ramp Ramp1(final height = height_1, final duration = duration_1, final startTime = startTime, final offset = offset) annotation(Placement(visible = true, transformation(origin = { -20,20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Blocks.Sources.Ramp Ramp2(final height = height_2, final duration = duration_2, final startTime = startTime + duration_1 + interval, final offset = 0) annotation(Placement(visible = true, transformation(origin = { -20, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//           equation 
//             connect(Add1.y,y) annotation(Line(visible = true, points = {{31,0},{110,0}}, color = {0,0,191}));
//             connect(Ramp2.y,Add1.u2) annotation(Line(visible = true, points = {{ -9, -20},{0, -20},{0, -6},{8, -6}}, color = {0,0,191}));
//             connect(Ramp1.y,Add1.u1) annotation(Line(visible = true, points = {{ -9,20},{0,20},{0,6},{8,6}}, color = {0,0,191}));
//           end DoubleRamp;
//         end Utilities;
//       end Examples;
//       package Components "Basic components (pipes, valves)"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains components:
// <ul>
// <li>pipe without heat exchange</li>
// <li>pipe with heat exchange</li>
// <li>valve (simple controlled valve)</li>
// <ul>
// </p>
// <p>
// Pressure drop is taken from partial model SimpleFriction.<br>
// Thermodynamic equations are defined in partial models (package Partials).
// </p>
// <p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.20 Beta 2005/02/18 Anton Haumer<br>
//        introduced geodetic height in Components.Pipes<br>
//        <i>new models: Components.Valve</i></li>
//   <li> v1.30 Beta 2005/06/02 Anton Haumer<br>
//        friction losses are fed to medium</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {0,0,255}, fillColor = {0,127,255}, fillPattern = FillPattern.Solid, points = {{ -56,10},{ -56, -90},{ -6, -40},{44,10},{44, -90},{ -56,10}}),Polygon(visible = true, lineColor = {0,0,191}, fillColor = {0,0,191}, fillPattern = FillPattern.Solid, points = {{ -16,10},{4,10},{ -6, -10},{ -16,10}}),Line(visible = true, points = {{ -6, -10},{ -6, -40},{ -6, -38}}, color = {0,0,191})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model IsolatedPipe
//           annotation(Documentation(info = "<HTML>
// <p>
// Pipe without heat exchange.<br>
// Thermodynamic equations are defined by Partials.TwoPortMass(Q_flow = 0).
// </p>
// <p>
// <b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -20},{90,20}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial")}));
//           extends Interfaces.Partials.TwoPort;
//           extends Interfaces.Partials.SimpleFriction;
//           parameter Modelica.SIunits.Length h_g = 0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
// 
//         equation 
//           VolumeFlow = V_flow;
//           dp = pressureDrop + medium.rho * Modelica.Constants.g_n * h_g;
//           Q_flow = Q_friction;
//         end IsolatedPipe;
//         model HeatedPipe
//           annotation(Documentation(info = "<HTML>
// <p>
// Pipe with heat exchange.<br>
// Thermodynamic equations are defined by Partials.TwoPort.<br>
// Q_flow is defined by heatPort.Q_flow.
// </p>
// <p>
// <b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).
// </p>
// <p>
// <b>Note:</b> Injecting heat into a pipe with zero massflow causes 
// temperature rise defined by storing heat in medium's mass.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -20},{90,20}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150,40},{150,100}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -10, -90},{ -10, -40},{0, -20},{10, -40},{10, -90},{ -10, -90}})}));
//           extends Interfaces.Partials.TwoPort;
//           extends Interfaces.Partials.SimpleFriction;
//           parameter Modelica.SIunits.Length h_g = 0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           VolumeFlow = V_flow;
//           dp = pressureDrop + medium.rho * Modelica.Constants.g_n * h_g;
//           Q_flow = heatPort.Q_flow + Q_friction;
//           heatPort.T = T_q;
//         end HeatedPipe;
//         model Valve
//           annotation(Documentation(info = "<HTML>
// <p>
// Simple controlled valve.<br>
// Standard characteristic Kv=<i>f </i>(y) is given at standard conditions (dp0, rho0),<br> 
// <tt>
// <ul>
// <li>either linear : Kv/Kv1 = Kv0/Kv1 + (1-Kv0/Kv1) * y/Y1</li>
// <li>or exponential: Kv/Kv1 = Kv0/Kv1 * exp[Modelica.Math.log(Kv1/Kv0) * y/Y1]</li>
// </ul>
// where:
// <ul>
// <li>Kv0 ... min. flow @ y = 0</li>
// <li>Y1 .... max. valve opening</li>
// <li>Kv1 ... max. flow @ y = Y1</li>
// </ul>
// </tt>
// Flow resistance under real conditions is calculated by<br>
// <tt>V_flow**2 * rho / dp = Kv(y)**2 * rho0 / dp0</tt>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -150, -120},{150, -60}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -90,10},{ -60,10},{ -60,60},{0,0},{60,60},{60,10},{90,10},{90, -10},{60, -10},{60, -60},{0,0},{ -60, -60},{ -60, -10},{ -90, -10},{ -90,10}}),Line(visible = true, points = {{0,80},{0,0}}, color = {0,0,191})}));
//           extends Interfaces.Partials.TwoPort(m = 0);
//           parameter Boolean LinearCharacteristic = true "|standard characteristic|type of characteristic" annotation(choices(choice = true "Linear", choice = false "Exponential"));
//           parameter Real y1(min = small) = 1 "|standard characteristic|max. valve opening";
//           parameter Modelica.SIunits.VolumeFlowRate Kv1(min = small) = 1 "|standard characteristic|max. flow @ y = y1";
//           parameter Real kv0(min = small, max = 1 - small) = 0.01 "|standard characteristic|leakage flow / max.flow @ y = 0";
//           parameter Modelica.SIunits.Pressure dp0 = 1 "|standard characteristic|standard pressure drop";
//           parameter Modelica.SIunits.Density rho0 = 10 "|standard characteristic|standard medium's density";
//           parameter Real frictionLoss(min = 0, max = 1) = 0 "part of friction losses fed to medium";
//           Modelica.Blocks.Interfaces.RealInput y annotation(Placement(visible = true, transformation(origin = {0,90}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0,90}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         protected 
//           constant Real small = Modelica.Constants.small;
//           constant Real eps = Modelica.Constants.eps;
//           Real yLim = max(min(y, y1), 0) "limited valve opening";
//           Modelica.SIunits.VolumeFlowRate Kv "standard flow rate";
//         initial algorithm 
//           assert(y1 > small, "Valve characteristic: y1 has to be > 0 !");
//           assert(Kv1 > small, "Valve characteristic: Kv1 has to be > 0 !");
//           assert(kv0 > small, "Valve characteristic: kv0 has to be > 0 !");
//           assert(kv0 < 1 - eps, "Valve characteristic: kv0 has to be < 1 !");
// 
//         equation 
//           Kv / Kv1 = if LinearCharacteristic then kv0 + ((1 - kv0) * yLim) / y1 else kv0 * exp((Modelica.Math.log(1 / kv0) * yLim) / y1);
//           dp / dp0 = (medium.rho / rho0 * V_flow) / Kv * abs(V_flow / Kv);
//           Q_flow = frictionLoss * V_flow * dp;
//         end Valve;
//       end Components;
//       package Interfaces "Connectors and partial models"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains connectors and partial models:
// <ul>
// <li>FlowPort: basic definition of the connector.</li>
// <li>FlowPort_a & FlowPort_b: same as FlowPort with different icons to differentiate direction of flow</li>
// <li>package Partials (defining basic thermodynamic equations)</li>
// </ul>
// </p>
// <p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.10 2005/02/15 Anton Haumer<br>
//        moved Partials into Interfaces</li>
//   <li> v1.11 2005/02/18 Anton Haumer<br>
//        corrected usage of cv and cp</li>
//   <li> v1.30 Beta 2005/06/02 Anton Haumer<br>
//        friction losses are fed to medium</li>
//   <li> v1.33 Beta 2005/06/07 Anton Haumer<br>
//        corrected usage of simpleFlow</li>
//   <li> v1.43 Beta 2005/06/20 Anton Haumer<br>
//        Test of mixing / semiLinear</li>
//   <li> v1.50 2005/09/07 Anton Haumer<br>
//        semiLinear works fine</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, extent = {{ -60, -90},{40,10}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -58, -88},{38,8}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         connector FlowPort
//           annotation(Documentation(info = "<HTML>
// <p>
// Basic definition of the connector.
// </p>
// <p>
// <b>Variables:</b>
// <ul>
// <li>Pressure p</li>
// <li>flow MassFlowRate m_flow</li>
// <li>Specific Enthalpy h</li>
// <li>flow EnthaplyFlowRate H_flow</li>
// </ul>
// </p>
// <p>
// <p>
// If ports with different media are connected, the simulation is asserted due to the check of parameter.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter FluidHeatFlow.Media.Medium medium;
//           Modelica.SIunits.Pressure p;
//           flow Modelica.SIunits.MassFlowRate m_flow;
//           Modelica.SIunits.SpecificEnthalpy h;
//           flow Modelica.SIunits.EnthalpyFlowRate H_flow;
//         end FlowPort;
//         connector FlowPort_a
//           annotation(Documentation(info = "<HTML>
// <p>
// Same as FlowPort, but icon allows to differentiate direction of flow.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -98, -98},{98,98}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Ellipse(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -48, -48},{48,48}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -100,50},{100,110}}, textString = "%name", fontName = "Arial")}));
//           extends FlowPort;
//         end FlowPort_a;
//         connector FlowPort_b
//           annotation(Documentation(info = "<HTML>
// <p>
// Same as FlowPort, but icon allows to differentiate direction of flow.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -98, -98},{98,98}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Ellipse(visible = true, lineColor = {0,0,255}, extent = {{ -48, -48},{48,48}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -100,50},{100,110}}, textString = "%name", fontName = "Arial")}));
//           extends FlowPort;
//         end FlowPort_b;
//         package Partials
//           extends Modelica.Icons.Library;
//           annotation(Documentation(info = "<HTML>
// <p>
// This package contains partial models, defining in a very compact way the basic thermodynamic equations used by the different components.
// </p>
// <p>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// </HTML>", revisions = "<HTML>
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.10 2005/02/15 Anton Haumer<br>
//        moved Partials into Interfaces</li>
//   <li> v1.11 2005/02/18 Anton Haumer<br>
//        corrected usage of cv and cp</li>
//   <li> v1.30 Beta 2005/06/02 Anton Haumer<br>
//        friction losses are fed to medium</li>
//   <li> v1.31 Beta 2005/06/04 Anton Haumer<br>
//        searching solution for problems @ m_flow=0</li>
//   <li> v1.33 Beta 2005/06/07 Anton Haumer<br>
//        corrected usage of simpleFlow</li>
//   <li> v1.43 Beta 2005/06/20 Anton Haumer<br>
//        Test of mixing / semiLinear</li>
//   <li> v1.50 2005/09/07 Anton Haumer<br>
//        semiLinear works fine<br>
//        removed test-version of semiLinear</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           partial model SimpleFriction
//             annotation(Documentation(info = "<HTML>
// <p>
// Definition of relationship between pressure drop and volume flow rate:
// </p>
// <p>
// -V_flowLaminar &lt; VolumeFlow &lt; +V_flowLaminar: laminar i.e. linear dependency of pressure drop on volume flow.<br>
// -V_flowLaminar &gt; VolumeFlow or VolumeFlow &lt; +V_flowLaminar: turbulent i.e. quadratic dependency of pressure drop on volume flow.<br>
// Linear and quadratic dependency are coupled smoothly at V_flowLaminar / dpLaminar.<br>
// Quadratic dependency is defined by nominal volume flow and pressure drop (V_flowNominal / dpNominal).<br>
// See also sketch at diagram layer.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, color = {0,0,255}),Line(visible = true, points = {{0,80},{0, -80}}, color = {0,0,255}),Line(visible = true, points = {{40,20},{40,0}}, color = {0,0,255}),Line(visible = true, points = {{60,40},{60,0}}, color = {0,0,255}),Line(visible = true, points = {{40,20},{0,20}}, color = {0,0,255}),Line(visible = true, points = {{60,40},{3.553e-15,40}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{18, -20},{48,0}}, textString = "V_flowLaminar", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{50, -20},{80,0}}, textString = "V_flowNominal", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -30,10},{ -4,30}}, textString = "dpLaminar", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -30,30},{ -4,50}}, textString = "dpNominal", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{0,0},{30,20}}, textString = "dp ~ V_flow", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{30,40},{60,60}}, textString = "dp ~ V_flow", fontName = "Arial"),Line(visible = true, points = {{75,80},{70,60},{60,37.5},{35,15},{ -35, -15},{ -60, -37.5},{ -70, -60},{ -75, -80}}, color = {0,0,255}, smooth = Smooth.Bezier)}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             parameter Modelica.SIunits.VolumeFlowRate V_flowLaminar(min = Modelica.Constants.small) = 0.1 "|SimpleFriction|laminar volume flow";
//             parameter Modelica.SIunits.Pressure dpLaminar = 0.1 "|SimpleFriction|laminar pressure drop";
//             parameter Modelica.SIunits.VolumeFlowRate V_flowNominal = 1 "|SimpleFriction|nominal volume flow";
//             parameter Modelica.SIunits.Pressure dpNominal = 1 "|SimpleFriction|nominal pressure drop";
//             parameter Real frictionLoss(min = 0, max = 1) = 0 "|SimpleFriction|part of friction losses fed to medium";
//             Modelica.SIunits.Pressure pressureDrop;
//             Modelica.SIunits.VolumeFlowRate VolumeFlow;
//             Modelica.SIunits.Power Q_friction;
//           protected 
//             parameter Real k(fixed = false);
//           initial algorithm 
//             assert(V_flowNominal > V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//             k:=dpLaminar / V_flowLaminar * V_flowNominal;
//             assert(dpNominal >= k, "SimpleFriction: dpNominal has to be > dpLaminar*V_flowNominal/V_flowLaminar!");
//             k:=(dpNominal - k) / (V_flowNominal - V_flowLaminar) ^ 2;
// 
//           equation 
//             if VolumeFlow >  +V_flowLaminar then
//               pressureDrop =  +dpLaminar / V_flowLaminar * VolumeFlow + k * (VolumeFlow - V_flowLaminar) ^ 2;
// 
//             elseif VolumeFlow <  -V_flowLaminar then
//               pressureDrop =  +dpLaminar / V_flowLaminar * VolumeFlow - k * (VolumeFlow + V_flowLaminar) ^ 2;
// 
// 
//             else
//               pressureDrop = dpLaminar / V_flowLaminar * VolumeFlow;
// 
//             end if;
//             Q_friction = frictionLoss * VolumeFlow * pressureDrop;
//           end SimpleFriction;
//           partial model TwoPort
//             annotation(Documentation(info = "<HTML>
// <p>
// Partial model with two flowPorts.<br>
// Possible heat exchange with the ambient is defined by Q_flow; setting this = 0 means no energy exchange.<br>
// Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Mixing rule is applied.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//             parameter Modelica.SIunits.Mass m = 1 "mass of medium";
//             parameter Modelica.SIunits.Temperature T0 = Modelica.SIunits.Conversions.from_degC(20) "initial temperature of medium" annotation(Dialog(enable = m > Modelica.Constants.small));
//             Modelica.SIunits.Pressure dp = flowPort_a.p - flowPort_b.p "pressure drop a->b";
//             Modelica.SIunits.VolumeFlowRate V_flow = flowPort_a.m_flow / medium.rho "Volume flow a->b";
//             Modelica.SIunits.HeatFlowRate Q_flow "heat exchange with ambient";
//             output Modelica.SIunits.Temperature T(start = T0) "outlet temperature of medium";
//             output Modelica.SIunits.Temperature T_a = flowPort_a.h / medium.cp "temperature at flowPort_a";
//             output Modelica.SIunits.Temperature T_b = flowPort_b.h / medium.cp "temperature at flowPort_b";
//             output Modelica.SIunits.Temperature dT = if noEvent(V_flow >= 0) then T - T_a else T_b - T "temperature increase of coolant in flow direction";
//             Interfaces.FlowPort_a flowPort_a(final medium = medium) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.FlowPort_b flowPort_b(final medium = medium) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           protected 
//             Modelica.SIunits.SpecificEnthalpy h = medium.cp * T "medium's specific enthalpy";
//             Modelica.SIunits.Temperature T_q = T "temperature relevant for heat exchange with ambient";
// 
//           equation 
//             flowPort_a.m_flow + flowPort_b.m_flow = 0;
//             if m > Modelica.Constants.small then
//               flowPort_a.H_flow + flowPort_b.H_flow + Q_flow = m * medium.cv * der(T);
// 
//             else
//               flowPort_a.H_flow + flowPort_b.H_flow + Q_flow = 0;
// 
//             end if;
//             flowPort_a.H_flow = semiLinear(flowPort_a.m_flow, flowPort_a.h, h);
//             flowPort_b.H_flow = semiLinear(flowPort_b.m_flow, flowPort_b.h, h);
//           end TwoPort;
//           partial model Ambient
//             annotation(Documentation(info = "<HTML>
// <p>
// Partial model of (Infinite) ambient, defines pressure and temperature.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,90},{150,150}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//             output Modelica.SIunits.Temperature T "outlet temperature of medium";
//             output Modelica.SIunits.Temperature T_port = flowPort.h / medium.cp "temperature at flowPort_a";
//             Interfaces.FlowPort_a flowPort(final medium = medium) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           protected 
//             Modelica.SIunits.SpecificEnthalpy h = medium.cp * T;
// 
//           equation 
//             flowPort.H_flow = semiLinear(flowPort.m_flow, flowPort.h, h);
//           end Ambient;
//           partial model AbsoluteSensor
//             annotation(Documentation(info = "<HTML>
// <p>
// Partial model for an absolute sensor (pressure/temperature).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected.
// </p>
// </HTML>"));
//             parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{100,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,70},{150,130}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Interfaces.FlowPort_a flowPort(final medium = medium) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//           equation 
//             flowPort.m_flow = 0;
//             flowPort.H_flow = 0;
//           end AbsoluteSensor;
//           partial model RelativeSensor
//             annotation(Documentation(info = "<HTML>
// <p>
// Partial model for a relative sensor (pressure drop/temperature difference).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected.
// </p>
// </HTML>"));
//             parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,70},{150,130}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Interfaces.FlowPort_a flowPort_a(final medium = medium) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Interfaces.FlowPort_b flowPort_b(final medium = medium) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//             Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//           equation 
//             flowPort_a.m_flow = 0;
//             flowPort_b.m_flow = 0;
//             flowPort_a.H_flow = 0;
//             flowPort_b.H_flow = 0;
//           end RelativeSensor;
//           partial model FlowSensor
//             annotation(Documentation(info = "<HTML>
// <p>
// Partial model for a flow sensor (mass flow/heat flow).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected, but mixing rule is applied.
// </p>
// </HTML>"));
//             extends TwoPort(final m = 0, final T0 = 0);
//             annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}}),Line(visible = true, points = {{ -70,0},{ -90,0}}),Line(visible = true, points = {{70,0},{90,0}}),Line(visible = true, points = {{0, -100},{0, -70}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,70},{150,130}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//             Modelica.Blocks.Interfaces.RealOutput y annotation(Placement(visible = true, transformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -110}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//           equation 
//             dp = 0;
//             Q_flow = 0;
//           end FlowSensor;
//         end Partials;
//       end Interfaces;
//       package Media "Medium properties"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains definitions of medium properties.
// </p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.11 2005/02/18 Anton Haumer<br>
//        corrected usage of cv and cp</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,191}, fillColor = {127,191,255}, fillPattern = FillPattern.Solid, extent = {{ -80, -88},{60,8}}),Line(visible = true, points = {{ -10,8},{ -10, -88},{ -10, -88}}, color = {0,0,191}),Line(visible = true, points = {{ -80, -24},{60, -24}}, color = {0,0,191}),Line(visible = true, points = {{ -80, -56},{60, -56}}, color = {0,0,191})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         record Medium
//           extends Modelica.Icons.Record;
//           parameter Modelica.SIunits.Density rho = 1 "density";
//           parameter Modelica.SIunits.SpecificHeatCapacity cp = 1 "specific heat capacity at constant pressure";
//           parameter Modelica.SIunits.SpecificHeatCapacity cv = 1 "specific heat capacity at constant volume";
//           parameter Modelica.SIunits.ThermalConductivity lamda = 1 "thermal conductivity";
//           parameter Modelica.SIunits.KinematicViscosity nue = 1 "kinematic viscosity";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Medium;
//         record Air_30degC
//           extends Medium(rho = 1.149, cp = 1007, cv = 720, lamda = 0.0264, nue = 1.63e-05);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Air_30degC;
//         record Air_70degC
//           extends Medium(rho = 1.015, cp = 1010, cv = 723, lamda = 0.0293, nue = 2.03e-05);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Air_70degC;
//         record Water
//           extends Medium(rho = 995.6, cp = 4177, cv = 4177, lamda = 0.615, nue = 8e-07);
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end Water;
//       end Media;
//       package Sensors "Ideal sensors to measure port properties"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains sensors:
// <ul>
// <li>pSensor: absolute pressure</li>
// <li>TSensor: absolute temperature (Kelvin)</li>
// <li>dpSensor: pressure drop between flowPort_a and flowPort_b</li>
// <li>dTSensor: temperature difference between flowPort_a and flowPort_b</li>
// <li>m_flowSensor: measures mass flow rate</li>
// <li>V_flowSensor: measures volume flow rate</li>
// <li>H_flowSensor: measures enthalpy flow rate</li>
// </ul>
// </p>
// <p>
// Some of the sensors do not need access to medium properties for measuring, 
// but it is necessary to define the medium in the connector (check of connections).<br>
// Thermodynamic equations are defined in partial models (package Interfaces.Partials).<br>
// All sensors are considered massless, they do not change mass flow or enthalpy flow.
// </p>
// <p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -60, -90},{40,10}}),Line(visible = true, points = {{ -10,7},{ -10, -10}}),Line(visible = true, points = {{ -50, -16},{ -36, -25}}),Line(visible = true, points = {{30, -15},{16, -25}}),Line(visible = true, points = {{ -35,0},{ -25, -14}}),Line(visible = true, points = {{15,0},{5, -14}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -15, -45},{ -5, -35}}),Line(visible = true, points = {{ -10, -40},{ -6, -26}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -12, -24},{ -0.5, -27},{2,1.5},{ -12, -24}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model pSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// pSensor measures the absolute pressure.<br>
// Thermodynamic equations are defined by Partials.AbsoluteSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "p", fontName = "Arial")}));
//           extends Interfaces.Partials.AbsoluteSensor(y(redeclare type SignalType = Modelica.SIunits.Pressure));
// 
//         equation 
//           y = flowPort.p;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "p")}), Diagram);
//         end pSensor;
//         model TSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// TSensor measures the absolute temperature (Kelvin).<br>
// Thermodynamic equations are defined by Partials.AbsoluteSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "T", fontName = "Arial")}));
//           extends Interfaces.Partials.AbsoluteSensor(y(redeclare type SignalType = Modelica.SIunits.Temperature));
// 
//         equation 
//           medium.cp * y = flowPort.h;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "T")}));
//         end TSensor;
//         model dpSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// dpSensor measures the pressure drop between flowPort_a and flowPort_b.<br>
// Thermodynamic equations are defined by Partials.RelativeSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "dp", fontName = "Arial")}));
//           extends Interfaces.Partials.RelativeSensor(y(redeclare type SignalType = Modelica.SIunits.Pressure));
// 
//         equation 
//           y = flowPort_a.p - flowPort_b.p;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "dp")}));
//         end dpSensor;
//         model dTSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// dTSensor measures the temperature difference between flowPort_a and flowPort_b.<br>
// Thermodynamic equations are defined by Partials.RelativeSensor.
// </p>
// <ul>
// <li><b>Note:</b> Connected flowPorts have the same temperature (mixing temperature)!<br>
// Since mixing my occur, the outlet temperature of a component may be different from the connector's temperature.<br> 
// Outlet temperature is defined by variable T of the corresponding component.</li>
// </ul>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "dT", fontName = "Arial")}));
//           extends Interfaces.Partials.RelativeSensor(y(redeclare type SignalType = Modelica.SIunits.Temperature));
// 
//         equation 
//           medium.cp * y = flowPort_a.h - flowPort_b.h;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "dT")}));
//         end dTSensor;
//         model m_flowSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// m_flowSensor measures the mass flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "m", fontName = "Arial")}));
//           extends Interfaces.Partials.FlowSensor(y(redeclare type SignalType = Modelica.SIunits.MassFlowRate));
// 
//         equation 
//           y = V_flow * medium.rho;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "m")}));
//         end m_flowSensor;
//         model V_flowSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// V_flowSensor measures the volume flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "V", fontName = "Arial")}));
//           extends Interfaces.Partials.FlowSensor(y(redeclare type SignalType = Modelica.SIunits.VolumeFlowRate));
// 
//         equation 
//           y = V_flow;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "V")}));
//         end V_flowSensor;
//         model H_flowSensor
//           annotation(Documentation(info = "<HTML>
// <p>
// H_flowSensor measures the enthalpy flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -22, -60},{20, -20}}, textString = "H", fontName = "Arial")}));
//           extends Interfaces.Partials.FlowSensor(y(redeclare type SignalType = Modelica.SIunits.EnthalpyFlowRate));
// 
//         equation 
//           y = flowPort_a.H_flow;
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(lineColor = {0,0,255}, extent = {{ -22, -20},{20, -60}}, fillColor = {0,0,255}, textString = "H")}));
//         end H_flowSensor;
//       end Sensors;
//       package Sources "Ideal fluid sources, e.g., ambient, volume flow"
//         extends Modelica.Icons.Library2;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains different types of sources:
// <ul>
// <li>Ambient with constant pressure and temperature</li>
// <li>Ambient with prescribed pressure and temperature</li>
// <li>AbsolutePressure to define pressure level of a closed cooling cycle.</li>
// <li>Constant and prescribed volume flow</li>
// <li>Constant and prescribed pressure increase</li>
// <li>Simple pump with mechanical flange</li>
// <ul>
// </p>
// <p>
// Thermodynamic equations are defined in partial models (package Interfaces.Partials).<br>
// All fans / pumps are considered without losses, they do not change enthalpy flow.
// </p>
// <p>
// 
// </HTML>", revisions = "<HTML>
// <dl>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <p>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern, Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </p>
//   <p>
//   Dr.Christian Kral & Markus Plainer<br>
//   <a href=\"http://www.arsenal.ac.at/english/\">arsenal research</a><br>
//   Business Unit Monitoring, Energy and Drive Technologies<br>
//   A-1030 Vienna, Austria
//   </p>
//   </dd>
// </dl>
// </p>
// </dl>
// <p>
// Copyright &copy; 1998-2006, Modelica Association, Anton Haumer and arsenal research.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
//   <ul>
//   <li> v1.00 2005/02/01 Anton Haumer<br>
//        first stable official release</li>
//   <li> v1.20 Beta 2005/02/18 Anton Haumer<br>
//        <i>new model: IdealPump</i></li>
//   </ul>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, extent = {{ -60, -90},{40,10}}),Polygon(visible = true, lineColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -40,0},{ -40, -80},{38, -50},{38, -30},{ -40,0}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model Ambient
//           annotation(Documentation(info = "<HTML>
// <p>
// (Infinite) ambient with constant pressure and temperature.<br>
// Thermodynamic equations are defined by Partials.Ambient. 
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.Ambient;
//           parameter Modelica.SIunits.Pressure p_Ambient = 0;
//           parameter Modelica.SIunits.Temperature T_Ambient = Modelica.SIunits.Conversions.from_degC(20);
// 
//         equation 
//           flowPort.p = p_Ambient;
//           T = T_Ambient;
//         end Ambient;
//         model PrescribedAmbient
//           annotation(Documentation(info = "<HTML>
// <p>
// (Infinite) ambient with prescribed pressure and temperature.<br>
// Thermodynamic equations are defined by Partials.Ambient. 
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.Ambient;
//           Modelica.Blocks.Interfaces.RealInput p_Ambient(redeclare type SignalType = Modelica.SIunits.Pressure) annotation(Placement(visible = true, transformation(origin = {100,70}, extent = {{10, -10},{ -10,10}}, rotation = 0), iconTransformation(origin = {100,70}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput T_Ambient(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = {100, -70}, extent = {{10,10},{ -10, -10}}, rotation = 0), iconTransformation(origin = {100, -70}, extent = {{10,10},{ -10, -10}}, rotation = 0)));
// 
//         equation 
//           flowPort.p = p_Ambient;
//           T = T_Ambient;
//         end PrescribedAmbient;
//         model AbsolutePressure
//           annotation(Documentation(info = "<HTML>
// <p>
// AbsolutePressure to define pressure level of a closed cooling cycle. 
// Coolant's mass flow, temperature and enthalpy flow are not affected.<br>
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,90},{150,150}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}})}));
//           parameter FluidHeatFlow.Media.Medium medium = FluidHeatFlow.Media.Medium() annotation(choicesAllMatching = true);
//           parameter Modelica.SIunits.Pressure p = 0 "pressure ground";
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Ellipse(extent = {{ -90,90},{90, -90}}, fillPattern = FillPattern.Solid, lineColor = {255,0,0}, fillColor = {255,255,255})}));
//           Interfaces.FlowPort_a flowPort(final medium = medium) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           flowPort.p = p;
//           flowPort.H_flow = 0;
//         end AbsolutePressure;
//         model ConstantVolumeFlow
//           annotation(Documentation(info = "<HTML>
// <p>
// Fan resp. pump with constant volume flow rate. Pressure increase is the response of the whole system. 
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150, -150},{150, -90}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -60,68},{90,10},{90, -10},{ -60, -68},{ -60,68}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -40, -20},{0,20}}, textString = "V", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.TwoPort;
//           parameter Modelica.SIunits.VolumeFlowRate VolumeFlow = 1;
// 
//         equation 
//           Q_flow = 0;
//           V_flow = VolumeFlow;
//         end ConstantVolumeFlow;
//         model PrescribedVolumeFlow
//           annotation(Documentation(info = "<HTML>
// <p>
// Fan resp. pump with prescribed volume flow rate. Pressure increase is the response of the whole system. 
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150, -150},{150, -90}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -60,68},{90,10},{90, -10},{ -60, -68},{ -60,68}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -40, -20},{0,20}}, textString = "V", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.TwoPort;
//           Modelica.Blocks.Interfaces.RealInput VolumeFlow(redeclare type SignalType = Modelica.SIunits.VolumeFlowRate) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
// 
//         equation 
//           Q_flow = 0;
//           V_flow = VolumeFlow;
//         end PrescribedVolumeFlow;
//         model ConstantPressureIncrease
//           annotation(Documentation(info = "<HTML>
// <p>
// Fan resp. pump with constant pressure increase. Mass resp. volume flow is the response of the whole system. 
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150, -150},{150, -90}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -60,68},{90,10},{90, -10},{ -60, -68},{ -60,68}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -40, -20},{0,20}}, textString = "dp", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.TwoPort;
//           parameter Modelica.SIunits.Pressure PressureIncrease = 1;
// 
//         equation 
//           Q_flow = 0;
//           dp =  -PressureIncrease;
//         end ConstantPressureIncrease;
//         model PrescribedPressureIncrease
//           annotation(Documentation(info = "<HTML>
// <p>
// Fan resp. pump with prescribed pressure increase. Mass resp. volume flow is the response of the whole system. 
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </p>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150, -150},{150, -90}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, fillPattern = FillPattern.Solid, points = {{ -60,68},{90,10},{90, -10},{ -60, -68},{ -60,68}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -40, -20},{0,20}}, textString = "dp", fontName = "Arial")}));
//           extends Interfaces.Partials.TwoPort;
//           Modelica.Blocks.Interfaces.RealInput PressureIncrease(redeclare type SignalType = Modelica.SIunits.Pressure) annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 90), iconTransformation(origin = {0,100}, extent = {{ -10, -10},{10,10}}, rotation = 90)));
// 
//         equation 
//           Q_flow = 0;
//           dp =  -PressureIncrease;
//         end PrescribedPressureIncrease;
//         model IdealPump
//           annotation(Documentation(info = "<HTML>
// <p>
// Simple fan resp. pump where characteristic is dependent on shaft's speed, <br>
// torque * speed = pressure increase * volume flow (without losses)<br>
// Pressure increase versus volume flow is defined by a linear function, 
// from dp0(V_flow=0) to V_flow0(dp=0).<br>
// The axis intersections vary with speed as follows:<br>
// <ul>
// <li>dp prop. speed^2</li>
// <li>V_flow prop. speed</li>
// </ul>
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -90, -90},{90,90}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, extent = {{ -150,90},{150,150}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.VerticalCylinder, extent = {{ -10, -100},{10, -40}}),Polygon(visible = true, lineColor = {255,0,0}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -60,68},{90,10},{90, -10},{ -60, -68},{ -60,68}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           extends Interfaces.Partials.TwoPort;
//           parameter Modelica.SIunits.AngularVelocity w_Nominal = 1 "|pump characteristic|nominal speed";
//           parameter Modelica.SIunits.Pressure dp0 = 2 "|pump characteristic|max. pressure increase @ V_flow=0";
//           parameter Modelica.SIunits.VolumeFlowRate V_flow0 = 2 "|pump characteristic|max. volume flow rate @ dp=0";
//           Modelica.SIunits.AngularVelocity w = der(flange_a.phi) "speed";
//           Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         protected 
//           Modelica.SIunits.Pressure dp1;
//           Modelica.SIunits.VolumeFlowRate V_flow1;
// 
//         equation 
//           dp1 = dp0 * sign(w / w_Nominal) * (w / w_Nominal) ^ 2;
//           V_flow1 = (V_flow0 * w) / w_Nominal;
//           if noEvent(abs(w) < Modelica.Constants.small) then
//             dp = 0;
//             flange_a.tau = 0;
// 
//           else
//             dp =  -dp1 * (1 - noEvent(abs(V_flow / V_flow1)));
//             flange_a.tau * w =  -dp * V_flow;
// 
//           end if;
//           Q_flow = 0;
//         end IdealPump;
//       end Sources;
//     end FluidHeatFlow;
//     package HeatTransfer "1-dimensional heat transfer with lumped elements"
//       import Modelica.SIunits.Conversions.*;
//       import SI = Modelica.SIunits;
//       import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//       extends Modelica.Icons.Library2;
//       annotation(version = "1.1", versionDate = "2005-06-13", preferedView = "info", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {128,128,128}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -54, -6},{ -61, -7},{ -75, -15},{ -79, -24},{ -80, -34},{ -78, -42},{ -73, -49},{ -64, -51},{ -57, -51},{ -47, -50},{ -41, -43},{ -38, -35},{ -40, -27},{ -40, -20},{ -42, -13},{ -47, -7},{ -54, -5},{ -54, -6}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -75, -15},{ -79, -25},{ -80, -34},{ -78, -42},{ -72, -49},{ -64, -51},{ -57, -51},{ -47, -50},{ -57, -47},{ -65, -45},{ -71, -40},{ -74, -33},{ -76, -23},{ -75, -15},{ -75, -15}}),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{39, -6},{32, -7},{18, -15},{14, -24},{13, -34},{15, -42},{20, -49},{29, -51},{36, -51},{46, -50},{52, -43},{55, -35},{53, -27},{53, -20},{51, -13},{46, -7},{39, -5},{39, -6}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{18, -15},{14, -25},{13, -34},{15, -42},{21, -49},{29, -51},{36, -51},{46, -50},{36, -47},{28, -45},{22, -40},{19, -33},{17, -23},{18, -15},{18, -15}}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{ -9, -23},{ -9, -10},{18, -17},{ -9, -23}}),Line(visible = true, points = {{ -41, -17},{ -9, -17}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -17, -40},{15, -40}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{ -17, -46},{ -17, -34},{ -40, -40},{ -17, -46}})}), Documentation(info = "<HTML>
// <p>
// This package contains components to model <b>1-dimensional heat transfer</b>
// with lumped elements. This allows especially to model heat transfer in
// machines provided the parameters of the lumped elements, such as
// the heat capacity of a part, can be determined by measurements
// (due to the complex geometries and many materials used in machines,
// calculating the lumped element parameters from some basic analytic
// formulas is usually not possible).
// </p>
// <p>
// Example models how to use this library are given in subpackage <b>Examples</b>.<br>
// For a first simple example, see <b>Examples.TwoMasses</b> where two masses
// with different initial temperatures are getting in contact to each
// other and arriving after some time at a common temperature.<br>
// <b>Examples.ControlledTemperature</b> shows how to hold a temperature 
// within desired limits by switching on and off an electric resistor.<br>
// A more realistic example is provided in <b>Examples.Motor</b> where the
// heating of an electrical motor is modelled, see the following screen shot
// of this example:
// </p>
// <img src=\"../Images/driveWithHeatTransfer.png\" ALT=\"driveWithHeatTransfer\">
// <p>
// The <b>filled</b> and <b>non-filled red squares</b> at the left and
// right side of a component represent <b>thermal ports</b> (connector HeatPort).
// Drawing a line between such squares means that they are thermally connected.
// The variables of a HeatPort connector are the temperature <b>T</b> at the port
// and the heat flow rate <b>Q_flow</b> flowing into the component (if Q_flow is positive,
// the heat flows into the element, otherwise it flows out of the element):
// </p>
// <pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
//    Modelica.SIunits.HeatFlowRate Q_flow  \"flow rate at the port in Watt\";
// </pre>
// <p>
// Note, that all temperatures of this package, including initial conditions,
// are given in Kelvin. For convenience, in subpackages <b>HeatTransfer.Celsius</b>,
//  <b>HeatTransfer.Fahrenheit</b> and <b>HeatTransfer.Rankine</b> components are provided such that source and
// sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
// respectively. Additionally, in package <b>SIunits.Conversions</b> conversion
// functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
// provided. These functions may be used in the following way:
// </p>
// <pre>  <b>import</b> SI=Modelica.SIunits;
//   <b>import</b> Modelica.SIunits.Conversions.*;
//      ...
//   <b>parameter</b> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
// </pre>
// 
// <p>
// There are several other components available, such as AxialConduction (discretized PDE in
// axial direction), which have been temporarily removed from this library. The reason is that
// these components reference material properties, such as thermal conductivity, and currently
// the Modelica design group is discussing a general scheme to describe material properties.
// </p>
// <p>
// For technical details in the design of this library, see the following reference:<br>
// <b>Michael Tiller (2001)</b>: <a href=\"http://www.amazon.de\">
// Introduction to Physical Modeling with Modelica</a>.
// Kluwer Academic Publishers Boston.
// </p>
// <p>
// <b>Acknowledgements:</b><br>
// Several helpful remarks from the following persons are acknowledged:
// John Batteh, Ford Motors, Dearborn, U.S.A;
// <a href=\"http://www.haumer.at/\">Anton Haumer</a>, Technical Consulting & Electrical Engineering, Austria;
// Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
// Hans Olsson, Dynasim AB, Sweden;
// Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
// </p>
// <p><b>Copyright &copy; 2001-2006, Modelica Association, Michael Tiller and DLR.</b></p>
// <p><i>
// This Modelica package is free software; it can be redistributed and/or modified
// under the terms of the Modelica license, see the license conditions
// and the accompanying disclaimer in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>July 15, 2002</i>
//        by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Nikolaus.Schuermann/\">Nikolaus Sch&uuml;rmann</a>:<br>
//        Implemented.
// </li>
// <li><i>June 13, 2005</i>
//        by <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//        Refined placing of connectors (cosmetic).<br>
//        Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
//        Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
// </li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package Examples "Example models to demonstrate the usage of package Modelica.Thermal.HeatTransfer"
//         extends Modelica.Icons.Library2;
//         model TwoMasses "Simple conduction demo"
//           extends Modelica.Icons.Example;
//           parameter SI.Temperature T_final_K(fixed = false) "Projected final temperature";
//           parameter NonSI.Temperature_degC T_final_degC(fixed = false) "Projected final temperature";
//           annotation(Documentation(info = "<HTML>
// <p>
// This example demonstrates the thermal response of two masses connected by
// a conducting element. The two masses have the same heat capacity but different
// initial temperatures (T1=100 [degC], T2= 0 [degC]). The mass with the higher
// temperature will cool off while the mass with the lower temperature heats up.
// They will each asymptotically approach the calculated temperature <b>T_final_K</b>
// (<b>T_final_degC</b>) that results from dividing the total initial energy in the system by the sum
// of the heat capacities of each element.
// </p>
// <p>
// Simulate for 5 s and plot the variables<br>
// mass1.T, mass2.T, T_final_K or <br>
// Tsensor1.T, Tsensor2.T, T_final_degC
// </p>
// </HTML>
// "), experiment(StopTime = 5), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           HeatTransfer.HeatCapacitor mass1(C = 15, T(start = from_degC(100))) annotation(Placement(visible = true, transformation(origin = { -70,50}, extent = {{ -30, -30},{30,30}}, rotation = 0)));
//           HeatTransfer.HeatCapacitor mass2(C = 15, T(start = from_degC(0))) annotation(Placement(visible = true, transformation(origin = {70,50}, extent = {{ -30, -30},{30,30}}, rotation = 0)));
//           HeatTransfer.ThermalConductor conduction(G = 10) annotation(Placement(visible = true, transformation(origin = {0,10}, extent = {{ -30, -30},{30,30}}, rotation = 0)));
//           HeatTransfer.Celsius.TemperatureSensor Tsensor1 annotation(Placement(visible = true, transformation(origin = { -40, -60}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           HeatTransfer.Celsius.TemperatureSensor Tsensor2 annotation(Placement(visible = true, transformation(origin = {40, -60}, extent = {{20, -20},{ -20,20}}, rotation = 0)));
// 
//         equation 
//           connect(mass2.port,Tsensor2.port) annotation(Line(visible = true, points = {{70,20},{70, -60},{60, -60}}, color = {191,0,0}));
//           connect(mass1.port,Tsensor1.port) annotation(Line(visible = true, points = {{ -70,20},{ -70, -60},{ -60, -60}}, color = {191,0,0}));
//           connect(conduction.port_b,mass2.port) annotation(Line(visible = true, points = {{30,10},{70,10},{70,20}}, color = {191,0,0}));
//           connect(mass1.port,conduction.port_a) annotation(Line(visible = true, points = {{ -70,20},{ -70,10},{ -30,10}}, color = {191,0,0}));
// 
//         initial equation 
//           T_final_K = (mass1.port.T * mass1.C + mass2.port.T * mass2.C) / (mass1.C + mass2.C);
//           T_final_degC = to_degC(T_final_K);
//         end TwoMasses;
//         model ControlledTemperature "Control temperature of a resistor"
//           extends Modelica.Icons.Example;
//           parameter NonSI.Temperature_degC TAmb = 20 "Ambient Temperature";
//           parameter NonSI.Temperature_degC TDif = 2 "Error in Temperature";
//           output NonSI.Temperature_degC TRes = to_degC(HeatingResistor1.heatPort.T) "Resulting Temperature";
//           annotation(Documentation(info = "<HTML>
// <P>
// A constant voltage of 10 V is applied to a
// temperature dependent resistor of 10*(1+(T-20C)/(235+20C)) Ohms,
// whose losses v**2/r are dissipated via a
// thermal conductance of 0.1 W/K to ambient temperature 20 degree C.
// The resistor is assumed to have a thermal capacity of 1 J/K,
// having ambient temparature at the beginning of the experiment.
// The temperature of this heating resistor is held by an OnOff-controller
// at reference temperature within a given bandwith +/- 1 K
// by switching on and off the voltage source.
// The reference temperature starts at 25 degree C
// and rises between t = 2 and 8 seconds linear to 50 degree C.
// An approppriate simulating time would be 10 seconds.
// </P>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), experiment(StopTime = 10), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(Placement(visible = true, transformation(origin = { -90, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           HeatTransfer.HeatCapacitor HeatCapacitor1(C = 1, T(start = from_degC(TAmb))) annotation(Placement(visible = true, transformation(origin = {10, -70}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           HeatTransfer.Celsius.FixedTemperature FixedTemperature1(T = TAmb) annotation(Placement(visible = true, transformation(origin = {90, -50}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           HeatTransfer.Celsius.TemperatureSensor TemperatureSensor1 annotation(Placement(visible = true, transformation(origin = {10, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           HeatTransfer.ThermalConductor ThermalConductor1(G = 0.1) annotation(Placement(visible = true, transformation(origin = {50, -50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Ideal.IdealOpeningSwitch IdealSwitch1 annotation(Placement(visible = true, transformation(origin = { -60, -40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Sources.Ramp Ramp1(height = 25, duration = 6, offset = 25, startTime = 2) annotation(Placement(visible = true, transformation(origin = {30,10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Blocks.Logical.OnOffController OnOffController1(bandwidth = TDif) annotation(Placement(visible = true, transformation(origin = { -10, -10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Blocks.Logical.Not Not1 annotation(Placement(visible = true, transformation(origin = { -40, -10}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//           Modelica.Electrical.Analog.Basic.HeatingResistor HeatingResistor1(R_ref = 10, T_ref = from_degC(20), alpha = 1 / (235 + 20)) annotation(Placement(visible = true, transformation(origin = { -30, -50}, extent = {{10, -10},{ -10,10}}, rotation = 90)));
//           Modelica.Electrical.Analog.Sources.ConstantVoltage ConstantVoltage1(V = 10) annotation(Placement(visible = true, transformation(origin = { -90, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(Not1.y,IdealSwitch1.control) annotation(Line(visible = true, points = {{ -51, -10},{ -60, -10},{ -60, -33}}, color = {255,0,255}));
//           connect(OnOffController1.y,Not1.u) annotation(Line(visible = true, points = {{ -21, -10},{ -28, -10}}, color = {255,0,255}));
//           connect(TemperatureSensor1.T,OnOffController1.u) annotation(Line(visible = true, points = {{10, -40},{10, -16},{2, -16}}, color = {0,0,191}));
//           connect(Ramp1.y,OnOffController1.reference) annotation(Line(visible = true, points = {{19,10},{10,10},{10, -4},{2, -4}}, color = {0,0,191}));
//           connect(ThermalConductor1.port_b,FixedTemperature1.port) annotation(Line(visible = true, points = {{60, -50},{80, -50}}, color = {191,0,0}));
//           connect(HeatingResistor1.heatPort,ThermalConductor1.port_a) annotation(Line(visible = true, points = {{ -20.047, -49.937},{40, -50}}, color = {191,0,0}));
//           connect(HeatingResistor1.heatPort,TemperatureSensor1.port) annotation(Line(visible = true, points = {{ -20.047, -49.937},{10, -50},{10, -20}}, color = {191,0,0}));
//           connect(HeatingResistor1.heatPort,HeatCapacitor1.port) annotation(Line(visible = true, points = {{ -20.047, -49.937},{10, -50},{10, -60}}, color = {191,0,0}));
//           connect(IdealSwitch1.n,HeatingResistor1.p) annotation(Line(visible = true, points = {{ -50, -40},{ -30, -40}}, color = {0,0,255}));
//           connect(ConstantVoltage1.n,HeatingResistor1.n) annotation(Line(visible = true, points = {{ -90, -60},{ -30, -60}}, color = {0,0,255}));
//           connect(ConstantVoltage1.n,Ground1.p) annotation(Line(visible = true, points = {{ -90, -60},{ -90, -80}}, color = {0,0,255}));
//           connect(ConstantVoltage1.p,IdealSwitch1.p) annotation(Line(visible = true, points = {{ -90, -40},{ -70, -40}}, color = {0,0,255}));
//         end ControlledTemperature;
//         model Motor "Second order thermal model of a motor"
//           extends Modelica.Icons.Example;
//           parameter NonSI.Temperature_degC TAmb = 20 "Ambient temperature";
//           annotation(Documentation(info = "<HTML>
// <p>
// This example contains a simple second order thermal model of a motor. 
// The periodic power losses are described by table \"lossTable\":<br>
// <table>
// <tr><td>time</td><td>winding losses</td><td>core losses</td></tr>
// <tr><td>   0</td><td>           100</td><td>        500</td></tr>
// <tr><td> 360</td><td>           100</td><td>        500</td></tr>
// <tr><td> 360</td><td>          1000</td><td>        500</td></tr>
// <tr><td> 600</td><td>          1000</td><td>        500</td></tr>
// </table><br>
// Since constant speed is assumed, the core losses keep constant 
// whereas the winding losses are low for 6 minutes (no-load) and high for 4 minutes (over load).
// <br>
// The winding losses are corrected by (1 + alpha*(T - T_ref)) because the winding's resistance is temperature dependent whereas the core losses are kept constant (alpha = 0).
// </p>
// <p>
// The power dissipation to the environment is approximated by heat flow through 
// a thermal conductance between winding and core, 
// partially storage of the heat in the winding's heat capacity 
// as well as the core's heat capacity and finally by forced convection to the environment.<br>
// Since constant speed is assumed, the cinvective conductance keeps constant.<br>
// Using Modelica.Thermal.FluidHeatFlow it would be possible to model the coolant air flow, too 
// (instead of simple dissipation to a constant ambient's temperature).
// </p>
// <p>
// Simulate for 7200 s; plot Twinding.T and Tcore.T.
// </p>
// </HTML>
// "), experiment(StopTime = 7200), experimentSetupOutput, Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           HeatTransfer.HeatCapacitor winding(T(start = from_degC(TAmb)), C = 2500) annotation(Placement(visible = true, transformation(origin = { -80, -30}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           HeatTransfer.ThermalConductor winding2core(G = 10) annotation(Placement(visible = true, transformation(origin = { -40, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           HeatTransfer.HeatCapacitor core(T(start = from_degC(TAmb)), C = 25000) annotation(Placement(visible = true, transformation(origin = {0, -30}, extent = {{ -10,10},{10, -10}}, rotation = 0)));
//           HeatTransfer.Convection convection annotation(Placement(visible = true, transformation(origin = {40, -10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           HeatTransfer.Celsius.FixedTemperature environment(T = TAmb) annotation(Placement(visible = true, transformation(origin = {80, -10}, extent = {{ -10, -10},{10,10}}, rotation =  -180)));
//           Modelica.Blocks.Sources.Constant convectionConstant(k = 25) annotation(Placement(visible = true, transformation(origin = {40,30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           HeatTransfer.PrescribedHeatFlow coreLosses annotation(Placement(visible = true, transformation(origin = {0,10}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           HeatTransfer.PrescribedHeatFlow windingLosses(T_ref = from_degC(95), alpha = 0.00303) annotation(Placement(visible = true, transformation(origin = { -80,10}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           HeatTransfer.Celsius.TemperatureSensor Twinding annotation(Placement(visible = true, transformation(origin = { -60, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           HeatTransfer.Celsius.TemperatureSensor Tcore annotation(Placement(visible = true, transformation(origin = { -20, -50}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//           Modelica.Blocks.Sources.CombiTimeTable lossTable(extrapolation = Modelica.Blocks.Types.Extrapolation.Periodic, table = [0,100,500;360,100,500;360,1000,500;600,1000,500]) annotation(Placement(visible = true, transformation(origin = { -40,70}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//         equation 
//           connect(convection.fluid,environment.port) annotation(Line(visible = true, points = {{50, -10},{60, -10},{60, -10},{70, -10}}, color = {191,0,0}));
//           connect(winding2core.port_b,convection.solid) annotation(Line(visible = true, points = {{ -30, -10},{30, -10}}, color = {191,0,0}));
//           connect(winding2core.port_b,core.port) annotation(Line(visible = true, points = {{ -30, -10},{0, -10},{0, -20}}, color = {191,0,0}));
//           connect(winding.port,winding2core.port_a) annotation(Line(visible = true, points = {{ -80, -20},{ -80, -10},{ -50, -10}}, color = {191,0,0}));
//           connect(convectionConstant.y,convection.Gc) annotation(Line(visible = true, points = {{40,19},{40,0}}, color = {0,0,191}));
//           connect(coreLosses.port,core.port) annotation(Line(visible = true, points = {{0,0},{6.123e-16, -10},{0, -10},{0, -20}}, color = {191,0,0}));
//           connect(windingLosses.port,winding.port) annotation(Line(visible = true, points = {{ -80,0},{ -80, -20}}, color = {191,0,0}));
//           connect(winding.port,Twinding.port) annotation(Line(visible = true, points = {{ -80, -20},{ -80, -10},{ -60, -10},{ -60, -40}}, color = {191,0,0}));
//           connect(core.port,Tcore.port) annotation(Line(visible = true, points = {{0, -20},{0, -10},{ -20, -10},{ -20, -40}}, color = {191,0,0}));
//           connect(lossTable.y[1],windingLosses.Q_flow) annotation(Line(visible = true, points = {{ -40,59},{ -40,40},{ -80,40},{ -80,20}}, color = {0,0,191}));
//           connect(lossTable.y[2],coreLosses.Q_flow) annotation(Line(visible = true, points = {{ -40,59},{ -40,40},{ -6.123e-16,40},{0,20}}, color = {0,0,191}));
//         end Motor;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, lineColor = {128,128,128}, extent = {{ -60, -90},{40,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -30, -12},{ -30, -68},{28, -40},{ -30, -12}})}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Examples;
//       package Interfaces "Connectors and partial models"
//         extends Modelica.Icons.Library2;
//         partial connector HeatPort "Thermal port for 1-dim. heat transfer"
//           SI.Temperature T "Port temperature";
//           flow SI.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
//           annotation(Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         end HeatPort;
//         connector HeatPort_a "Thermal port for 1-dim. heat transfer (filled rectangular icon)"
//           extends HeatPort;
//           annotation(defaultComponentName = "port_a", Documentation(info = "<HTML>
// <p>This connector is used for 1-dimensional heat flow between components.
// The variables in the connector are:</p>
// <pre>   
//    T       Temperature in [Kelvin].
//    Q_flow  Heat flow rate in [Watt].
// </pre>
// <p>According to the Modelica sign convention, a <b>positive</b> heat flow
// rate <b>Q_flow</b> is considered to flow <b>into</b> a component. This
// convention has to be used whenever this connector is used in a model
// class.</p>
// <p>Note, that the two connector classes <b>HeatPort_a</b> and
// <b>HeatPort_b</b> are identical with the only exception of the different
// <b>icon layout</b>.</p></HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {191,0,0}, extent = {{ -120,60},{100,120}}, textString = "%name", fontName = "Arial")}));
//         end HeatPort_a;
//         connector HeatPort_b "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"
//           extends HeatPort;
//           annotation(defaultComponentName = "port_b", Documentation(info = "<HTML>
// <p>This connector is used for 1-dimensional heat flow between components.
// The variables in the connector are:</p>
// <pre>
//    T       Temperature in [Kelvin].
//    Q_flow  Heat flow rate in [Watt].
// </pre>
// <p>According to the Modelica sign convention, a <b>positive</b> heat flow
// rate <b>Q_flow</b> is considered to flow <b>into</b> a component. This
// convention has to be used whenever this connector is used in a model
// class.</p>
// <p>Note, that the two connector classes <b>HeatPort_a</b> and
// <b>HeatPort_b</b> are identical with the only exception of the different
// <b>icon layout</b>.</p></HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -50, -50},{50,50}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {191,0,0}, extent = {{ -100,60},{120,120}}, textString = "%name", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}));
//         end HeatPort_b;
//         partial model Element1D "Partial heat transfer element with two HeatPort connectors that does not store energy"
//           SI.HeatFlowRate Q_flow "Heat flow rate from port_a -> port_b";
//           SI.Temperature dT "port_a.T - port_b.T";
//           annotation(Documentation(info = "<HTML>
// <p>
// This partial model contains the basic connectors and variables to
// allow heat transfer models to be created that <b>do not store energy</b>,
// This model defines and includes equations for the temperature
// drop across the element, <b>dT</b>, and the heat flow rate
// through the element from port_a to port_b, <b>Q_flow</b>.
// </p>
// <p>
// By extending this model, it is possible to write simple
// constitutive equations for many types of heat transfer components.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           HeatPort_a port_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           HeatPort_b port_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           dT = port_a.T - port_b.T;
//           port_a.Q_flow = Q_flow;
//           port_b.Q_flow =  -Q_flow;
//         end Element1D;
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -60, -90},{40,10}})}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Interfaces;
//       model HeatCapacitor "Lumped thermal element storing heat"
//         parameter SI.HeatCapacity C "Heat capacity of part (= cp*m)";
//         parameter Boolean steadyStateStart = false "true, if component shall start in steady state";
//         SI.Temperature T(start = from_degC(20)) "Temperature of part";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, lineColor = {160,160,160}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,67},{ -20,63},{ -40,57},{ -52,43},{ -58,35},{ -68,25},{ -72,13},{ -76, -1},{ -78, -15},{ -76, -31},{ -76, -43},{ -76, -53},{ -70, -65},{ -64, -73},{ -48, -77},{ -30, -83},{ -18, -83},{ -2, -85},{8, -89},{22, -89},{32, -87},{42, -81},{54, -75},{56, -73},{66, -61},{68, -53},{70, -51},{72, -35},{76, -21},{78, -13},{78,3},{74,15},{66,25},{54,33},{44,41},{36,57},{26,65},{0,67}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -58,35},{ -68,25},{ -72,13},{ -76, -1},{ -78, -15},{ -76, -31},{ -76, -43},{ -76, -53},{ -70, -65},{ -64, -73},{ -48, -77},{ -30, -83},{ -18, -83},{ -2, -85},{8, -89},{22, -89},{32, -87},{42, -81},{54, -75},{42, -77},{40, -77},{30, -79},{20, -81},{18, -81},{10, -81},{2, -77},{ -12, -73},{ -22, -73},{ -30, -71},{ -40, -65},{ -50, -55},{ -56, -43},{ -58, -35},{ -58, -25},{ -60, -13},{ -60, -5},{ -60,7},{ -58,17},{ -56,19},{ -52,27},{ -48,35},{ -44,45},{ -40,57},{ -58,35}}),Ellipse(visible = true, lineColor = {255,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -6, -12},{6, -1}}),Text(visible = true, lineColor = {0,0,255}, extent = {{11, -25},{50,13}}, textString = "T", fontName = "Arial"),Line(visible = true, points = {{0, -12},{0, -96}}, color = {255,0,0})}), Documentation(info = "<HTML>
// <p>
// This is a generic model for the heat capacity of a material.
// No specific geometry is assumed beyond a total volume with
// uniform temperature for the entire volume.
// Furthermore, it is assumed that the heat capacity
// is constant (indepedent of temperature).
// </p>
// <p>
// The temperature T [Kelvin] of this component is a <b>state</b>.
// A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
// is used as start value for initialization.
// This usually means that at start of integration the temperature of this
// component is 25 degrees Celsius. You may, of course, define a different
// temperature as start value for initialization. Alternatively, it is possible
// to set parameter <b>steadyStateStart</b> to <b>true</b>. In this case
// the additional equation '<b>der</b>(T) = 0' is used during
// initialization, i.e., the temperature T is computed in such a way that
// the component starts in <b>steady state</b>. This is useful in cases,
// where one would like to start simulation in a suitable operating
// point without being forced to integrate for a long time to arrive
// at this point.
// </p>
// <p>
// Note, that parameter <b>steadyStateStart</b> is not available in
// the parameter menue of the simulation window, because its value
// is utilized during translation to generate quite different
// equations depending on its setting. Therefore, the value of this
// parameter can only be changed before translating the model.
// </p>
// <p>
// This component may be used for complicated geometries where
// the heat capacity C is determined my measurements. If the component
// consists mainly of one type of material, the <b>mass m</b> of the
// component may be measured or calculated and multiplied with the
// <b>specific heat capacity cp</b> of the component material to
// compute C:
// </p>
// <pre>
//    C = cp*m.
//    Typical values for cp at 20 degC in J/(kg.K):
//       aluminium   896
//       concrete    840
//       copper      383
//       iron        452
//       silver      235
//       steel       420 ... 500 (V2A)
//       wood       2500
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -129,70},{131,121}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {160,160,160}, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{0,67},{ -20,63},{ -40,57},{ -52,43},{ -58,35},{ -68,25},{ -72,13},{ -76, -1},{ -78, -15},{ -76, -31},{ -76, -43},{ -76, -53},{ -70, -65},{ -64, -73},{ -48, -77},{ -30, -83},{ -18, -83},{ -2, -85},{8, -89},{22, -89},{32, -87},{42, -81},{54, -75},{56, -73},{66, -61},{68, -53},{70, -51},{72, -35},{76, -21},{78, -13},{78,3},{74,15},{66,25},{54,33},{44,41},{36,57},{26,65},{0,67}}),Polygon(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, points = {{ -58,35},{ -68,25},{ -72,13},{ -76, -1},{ -78, -15},{ -76, -31},{ -76, -43},{ -76, -53},{ -70, -65},{ -64, -73},{ -48, -77},{ -30, -83},{ -18, -83},{ -2, -85},{8, -89},{22, -89},{32, -87},{42, -81},{54, -75},{42, -77},{40, -77},{30, -79},{20, -81},{18, -81},{10, -81},{2, -77},{ -12, -73},{ -22, -73},{ -30, -71},{ -40, -65},{ -50, -55},{ -56, -43},{ -58, -35},{ -58, -25},{ -60, -13},{ -60, -5},{ -60,7},{ -58,17},{ -56,19},{ -52,27},{ -48,35},{ -44,45},{ -40,57},{ -58,35}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -69, -24},{71,7}}, textString = "%C", fontName = "Arial")}));
//         Interfaces.HeatPort_a port annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -90), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
// 
//       equation 
//         T = port.T;
//         C * der(T) = port.Q_flow;
// 
//       initial equation 
// if steadyStateStart then
//                   der(T) = 0;
//         end if;
//       end HeatCapacitor;
//       model ThermalConductor "Lumped thermal element transporting heat without storing it"
//         extends Interfaces.Element1D;
//         parameter SI.ThermalConductance G "Constant thermal conductance of material";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80,0},{80,0}}, color = {255,0,0}, thickness = 0.5, arrow = {Arrow.None,Arrow.Filled}),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, extent = {{ -26, -39},{27, -10}}, textString = "Q_flow", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -80,20},{80,50}}, textString = "dT = port_a.T - port_b.T", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is a model for transport of heat without storing it.
// It may be used for complicated geometries where
// the thermal conductance G (= inverse of thermal resistance)
// is determined by measurements and is assumed to be constant
// over the range of operations. If the component consists mainly of
// one type of material and a regular geometry, it may be calculated,
// e.g., with one of the following equations:
// </p>
// <ul>
// <li><p>
//     Conductance for a <b>box</b> geometry under the assumption
//     that heat flows along the box length:</p>
//     <pre>
//     G = k*A/L
//     k: Thermal conductivity (material constant)
//     A: Area of box
//     L: Length of box
//     </pre>
//     </li>
// <li><p>
//     Conductance for a <b>cylindrical</b> geometry under the assumption
//     that heat flows from the inside to the outside radius
//     of the cylinder:</p>
//     <pre>
//     G = 2*pi*k*L/log(r_out/r_in)
//     pi   : Modelica.Constants.pi
//     k    : Thermal conductivity (material constant)
//     L    : Length of cylinder
//     log  : Modelica.Math.log;
//     r_out: Outer radius of cylinder
//     r_in : Inner radius of cylinder
//     </pre>
//     </li>
// </li>
// </ul>
// <pre>
//     Typical values for k at 20 degC in W/(m.K):
//       aluminium   220
//       concrete      1
//       copper      384
//       iron         74
//       silver      407
//       steel        45 .. 15 (V2A)
//       wood         0.1 ... 0.2
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -90, -70},{90,70}}),Line(visible = true, points = {{ -90,70},{ -90, -70}}, thickness = 0.5),Line(visible = true, points = {{90,70},{90, -70}}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -139,74},{141,134}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -115, -116},{113, -76}}, textString = "G=%G", fontName = "Arial")}));
// 
//       equation 
//         Q_flow = G * dT;
//       end ThermalConductor;
//       model Convection "Lumped thermal element for heat convection"
//         SI.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
//         SI.Temperature dT "= solid.T - fluid.T";
//         annotation(Documentation(info = "<HTML>
// <p>
// This is a model of linear heat convection, e.g., the heat transfer
// between a plate and the surrounding air. It may be used for complicated
// solid geometries and fluid flow over the solid by determining the
// convective thermal conductance Gc by measurements. The basic constitutive
// equation for convection is
// </p>
// <pre>
//    Q_flow = Gc*(solid.T - fluid.T);
//    Q_flow: Heat flow rate from connector 'solid' (e.g. a plate)
//       to connector 'fluid' (e.g. the surrounding air)
// </pre>
// <p>
// Gc = G.signal[1] is an input signal to the component, since Gc is
// nearly never constant in practice. For example, Gc may be a function
// of the speed of a cooling fan. For simple situations,
// Gc may be <i>calculated</i> according to
// </p>
// <pre>
//    Gc = A*h
//    A: Convection area (e.g. perimeter*length of a box)
//    h: Heat transfer coefficient
// </pre>
// <p>
// where the heat transfer coefficient h is calculated
// from properties of the fluid flowing over the solid. Examples:
// </p>
// <p>
// <b>Machines cooled by air</b> (empirical, very rough approximation according
// to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
// p. 378):
// </p>
// <pre>
//     h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
//       = 12         [W/(m2.K)] (free convection)
//     where
//       v: Air velocity in [m/s]
// </pre>
// <p><b>Laminar</b> flow with constant velocity of a fluid along a
// <b>flat plate</b> where the heat flow rate from the plate
// to the fluid (= solid.Q_flow) is kept constant
// (according to J.P.Holman: Heat Transfer, 8th edition,
// McGraw-Hill, 1997, p.270):
// </p>
// <pre>
//    h  = Nu*k/x;
//    Nu = 0.453*Re^(1/2)*Pr^(1/3);
//    where
//       h  : Heat transfer coefficient
//       Nu : = h*x/k       (Nusselt number)
//       Re : = v*x*rho/mue (Reynolds number)
//       Pr : = cp*mue/k    (Prandtl number)
//       v  : Absolute velocity of fluid
//       x  : distance from leading edge of flat plate
//       rho: density of fluid (material constant
//       mue: dynamic viscosity of fluid (material constant)
//       cp : specific heat capacity of fluid (material constant)
//       k  : thermal conductivity of fluid (material constant)
//    and the equation for h holds, provided
//       Re < 5e5 and 0.6 < Pr < 50
// </pre>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{ -90, -80},{ -60,80}}),Line(visible = true, points = {{100,0},{100,0}}, color = {0,127,255}),Line(visible = true, points = {{100,0},{100,0}}, color = {0,127,255}),Line(visible = true, points = {{100,0},{100,0}}, color = {0,127,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {255,0,0}, extent = {{ -35,20},{ -5,42}}, textString = "Q_flow", fontName = "Arial"),Line(visible = true, points = {{ -60,20},{76,20}}, color = {191,0,0}),Line(visible = true, points = {{ -60, -20},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{ -34,80},{ -34, -80}}, color = {0,127,255}),Line(visible = true, points = {{6,80},{6, -80}}, color = {0,127,255}),Line(visible = true, points = {{40,80},{40, -80}}, color = {0,127,255}),Line(visible = true, points = {{76,80},{76, -80}}, color = {0,127,255}),Line(visible = true, points = {{ -34, -80},{ -44, -60}}, color = {0,127,255}),Line(visible = true, points = {{ -34, -80},{ -24, -60}}, color = {0,127,255}),Line(visible = true, points = {{6, -80},{ -4, -60}}, color = {0,127,255}),Line(visible = true, points = {{6, -80},{16, -60}}, color = {0,127,255}),Line(visible = true, points = {{40, -80},{30, -60}}, color = {0,127,255}),Line(visible = true, points = {{40, -80},{50, -60}}, color = {0,127,255}),Line(visible = true, points = {{76, -80},{66, -60}}, color = {0,127,255}),Line(visible = true, points = {{76, -80},{86, -60}}, color = {0,127,255}),Line(visible = true, points = {{56, -30},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{56, -10},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{56,10},{76,20}}, color = {191,0,0}),Line(visible = true, points = {{56,30},{76,20}}, color = {191,0,0})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -62, -80},{98,80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{ -90, -80},{ -60,80}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -117, -128},{124, -88}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{100,0},{100,0}}, color = {0,127,255}),Line(visible = true, points = {{ -60,20},{76,20}}, color = {191,0,0}),Line(visible = true, points = {{ -60, -20},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{ -34,80},{ -34, -80}}, color = {0,127,255}),Line(visible = true, points = {{6,80},{6, -80}}, color = {0,127,255}),Line(visible = true, points = {{40,80},{40, -80}}, color = {0,127,255}),Line(visible = true, points = {{76,80},{76, -80}}, color = {0,127,255}),Line(visible = true, points = {{ -34, -80},{ -44, -60}}, color = {0,127,255}),Line(visible = true, points = {{ -34, -80},{ -24, -60}}, color = {0,127,255}),Line(visible = true, points = {{6, -80},{ -4, -60}}, color = {0,127,255}),Line(visible = true, points = {{6, -80},{16, -60}}, color = {0,127,255}),Line(visible = true, points = {{40, -80},{30, -60}}, color = {0,127,255}),Line(visible = true, points = {{40, -80},{50, -60}}, color = {0,127,255}),Line(visible = true, points = {{76, -80},{66, -60}}, color = {0,127,255}),Line(visible = true, points = {{76, -80},{86, -60}}, color = {0,127,255}),Line(visible = true, points = {{56, -30},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{56, -10},{76, -20}}, color = {191,0,0}),Line(visible = true, points = {{56,10},{76,20}}, color = {191,0,0}),Line(visible = true, points = {{56,30},{76,20}}, color = {191,0,0})}));
//         Interfaces.HeatPort_a solid annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.HeatPort_b fluid annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput Gc(redeclare type SignalType = SI.ThermalConductance) "Signal representing the convective thermal conductance in [W/K]" annotation(Placement(visible = true, transformation(origin = {0,100}, extent = {{ -20, -20},{20,20}}, rotation =  -450), iconTransformation(origin = {0,100}, extent = {{ -20, -20},{20,20}}, rotation =  -450)));
// 
//       equation 
//         dT = solid.T - fluid.T;
//         solid.Q_flow = Q_flow;
//         fluid.Q_flow =  -Q_flow;
//         Q_flow = Gc * dT;
//       end Convection;
//       model BodyRadiation "Lumped thermal element for radiation heat transfer"
//         extends Interfaces.Element1D;
//         parameter Real Gr(unit = "m2") "Net radiation conductance between two surfaces (see docu)";
//         annotation(Documentation(info = "<HTML>
// <p>
// This is a model describing the thermal radiation, i.e., electromagnetic
// radiation emitted between two bodies as a result of their temperatures.
// The following constitutive equation is used:
// </p>
// <pre>
//     Q_flow = Gr*sigma*(port_a.T^4 - port_b.T^4);
// </pre>
// <p>
// where Gr is the radiation conductance and sigma is the Stefan-Boltzmann
// constant (= Modelica.Constants.sigma). Gr may be determined by
// measurements and is assumed to be constant over the range of operations.
// </p>
// <p>
// For simple cases, Gr may be analytically computed. The analytical
// equations use epsilon, the emission value of a body which is in the
// range 0..1. Epsilon=1, if the body absorbs all radiation (= black body).
// Epsilon=0, if the body reflects all radiation and does not absorb any.
// </p>
// <pre>
//    Typical values for epsilon:
//    aluminium, polished    0.04
//    copper, polished       0.04
//    gold, polished         0.02
//    paper                  0.09
//    rubber                 0.95
//    silver, polished       0.02
//    wood                   0.85..0.9
// </pre>
// <p><b>Analytical Equations for Gr</b></p>
// <p>
// <b>Small convex object in large enclosure</b>
// (e.g., a hot machine in a room):
// </p>
// <pre>
//     Gr = e*A
//     where
//        e: Emission value of object (0..1)
//        A: Surface area of object where radiation
//           heat transfer takes place
// </pre>
// <p><b>Two parallel plates</b>:</p>
// <pre>
//     Gr = A/(1/e1 + 1/e2 - 1)
//     where
//        e1: Emission value of plate1 (0..1)
//        e2: Emission value of plate2 (0..1)
//        A : Area of plate1 (= area of plate2)
// </pre>
// <p><b>Two long cylinders in each other</b>, where radiation takes
// place from the inner to the outer cylinder):
// </p>
// <pre>
//     Gr = 2*pi*r1*L/(1/e1 + (1/e2 - 1)*(r1/r2))
//     where
//        pi: = Modelica.Constants.pi
//        r1: Radius of inner cylinder
//        r2: Radius of outer cylinder
//        L : Length of the two cylinders
//        e1: Emission value of inner cylinder (0..1)
//        e2: Emission value of outer cylinder (0..1)
// </pre>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{ -90, -80},{ -56,80}}),Line(visible = true, points = {{ -56,80},{ -56, -80}}, thickness = 1),Line(visible = true, points = {{50,80},{50, -80}}, thickness = 1),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{50, -80},{90,80}}),Line(visible = true, points = {{ -40,10},{40,10}}, color = {191,0,0}),Line(visible = true, points = {{ -40,10},{ -30,16}}, color = {191,0,0}),Line(visible = true, points = {{ -40,10},{ -30,4}}, color = {191,0,0}),Line(visible = true, points = {{ -40, -10},{40, -10}}, color = {191,0,0}),Line(visible = true, points = {{30, -16},{40, -10}}, color = {191,0,0}),Line(visible = true, points = {{30, -4},{40, -10}}, color = {191,0,0}),Line(visible = true, points = {{ -40, -30},{40, -30}}, color = {191,0,0}),Line(visible = true, points = {{ -40, -30},{ -30, -24}}, color = {191,0,0}),Line(visible = true, points = {{ -40, -30},{ -30, -36}}, color = {191,0,0}),Line(visible = true, points = {{ -40,30},{40,30}}, color = {191,0,0}),Line(visible = true, points = {{30,24},{40,30}}, color = {191,0,0}),Line(visible = true, points = {{30,36},{40,30}}, color = {191,0,0})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{50, -80},{90,80}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Backward, extent = {{ -90, -80},{ -50,80}}),Line(visible = true, points = {{ -36,10},{36,10}}, color = {191,0,0}),Line(visible = true, points = {{ -36,10},{ -26,16}}, color = {191,0,0}),Line(visible = true, points = {{ -36,10},{ -26,4}}, color = {191,0,0}),Line(visible = true, points = {{ -36, -10},{36, -10}}, color = {191,0,0}),Line(visible = true, points = {{26, -16},{36, -10}}, color = {191,0,0}),Line(visible = true, points = {{26, -4},{36, -10}}, color = {191,0,0}),Line(visible = true, points = {{ -36, -30},{36, -30}}, color = {191,0,0}),Line(visible = true, points = {{ -36, -30},{ -26, -24}}, color = {191,0,0}),Line(visible = true, points = {{ -36, -30},{ -26, -36}}, color = {191,0,0}),Line(visible = true, points = {{ -36,30},{36,30}}, color = {191,0,0}),Line(visible = true, points = {{26,24},{36,30}}, color = {191,0,0}),Line(visible = true, points = {{26,36},{36,30}}, color = {191,0,0}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -119, -125},{117, -86}}, textString = "G=%G", fontName = "Arial"),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -50, -80},{ -44,80}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{45, -80},{50,80}})}));
// 
//       equation 
//         Q_flow = Gr * Modelica.Constants.sigma * (port_a.T ^ 4 - port_b.T ^ 4);
//       end BodyRadiation;
//       model FixedTemperature "Fixed temperature boundary condition in Kelvin"
//         parameter SI.Temperature T "Fixed temperature at port";
//         annotation(Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in Kelvin,
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -101},{100,100}}),Line(visible = true, points = {{ -52,0},{56,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "K", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -121,102},{119,162}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -121, -151},{119, -105}}, textString = "T=%T", fontName = "Arial"),Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -52,0},{56,0}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{50, -20},{50,20},{90,0},{50, -20}})}));
//         Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         port.T = T;
//       end FixedTemperature;
//       model PrescribedTemperature "Variable temperature boundary condition in Kelvin"
//         annotation(Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition.
// The temperature in [K] is given as input signal <b>T</b>
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -125,102},{115,162}}, textString = "%name", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{50, -20},{50,20},{90,0},{50, -20}})}));
//         Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput T(redeclare type SignalType = SI.Temperature) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//       equation 
//         port.T = T;
//       end PrescribedTemperature;
//       model FixedHeatFlow "Fixed heat flow boundary condition"
//         parameter SI.HeatFlowRate Q_flow "Fixed heat flow rate at port";
//         parameter SI.Temperature T_ref = from_degC(20) "Reference temperature";
//         parameter Real alpha(unit = "1/K") = 0 "Temperature coefficient of heat flow rate";
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -36},{0,40}}, textString = "Q_flow=const.", fontName = "Arial"),Line(visible = true, points = {{ -48, -20},{60, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -48,20},{60,20}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{60,0},{60,40},{90,20},{60,0}}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{60, -40},{60,0},{90, -20},{60, -40}})}), Documentation(info = "<HTML>
// <p>
// This model allows a specified amount of heat flow rate to be \"injected\"
// into a thermal system at a given port.  The constant amount of heat
// flow rate Q_flow is given as a parameter. The heat flows into the
// component to which the component FixedHeatFlow is connected,
// if parameter Q_flow is positive.
// </p>
// <p>
// If parameter alpha is > 0, the heat flow is mulitplied by (1 + alpha*(port.T - T_ref)) 
// in order to simulate temperature dependent losses (which are given an reference temperature T_ref).
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -134,60},{132,120}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{ -137, -100},{133, -52}}, textString = "Q_flow=%Q_flow", fontName = "Arial"),Line(visible = true, points = {{ -100, -20},{48, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -100,20},{46,20}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{40,0},{40,40},{70,20},{40,0}}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{40, -40},{40,0},{70, -20},{40, -40}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{70, -40},{90,40}})}));
//         Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         port.Q_flow =  -Q_flow * (1 + alpha * (port.T - T_ref));
//       end FixedHeatFlow;
//       model PrescribedHeatFlow "Prescribed heat flow boundary condition"
//         parameter SI.Temperature T_ref = from_degC(20) "Reference temperature";
//         parameter Real alpha(unit = "1/K") = 0 "Temperature coefficient of heat flow rate";
//         annotation(Documentation(info = "<HTML>
// <p>
// This model allows a specified amount of heat flow rate to be \"injected\"
// into a thermal system at a given port.  The amount of heat
// is given by the input signal Q_flow into the model. The heat flows into the
// component to which the component PrescribedHeatFlow is connected,
// if the input signal is positive.
// </p>
// <p>
// If parameter alpha is > 0, the heat flow is mulitplied by (1 + alpha*(port.T - T_ref)) 
// in order to simulate temperature dependent losses (which are given an reference temperature T_ref).
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60, -20},{68, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -60,20},{68,20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -80,0},{ -60, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -80,0},{ -60,20}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{60,0},{60,40},{90,20},{60,0}}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{60, -40},{60,0},{90, -20},{60, -40}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -60, -20},{40, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -60,20},{40,20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -80,0},{ -60, -20}}, color = {191,0,0}, thickness = 0.5),Line(visible = true, points = {{ -80,0},{ -60,20}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{40,0},{40,40},{70,20},{40,0}}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{40, -40},{40,0},{70, -20},{40, -40}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{70, -40},{90,40}}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -134,60},{132,120}}, textString = "%name", fontName = "Arial")}));
//         Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealInput Q_flow(redeclare type SignalType = SI.HeatFlowRate) annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -20, -20},{20,20}}, rotation =  -360), iconTransformation(origin = { -100,0}, extent = {{ -20, -20},{20,20}}, rotation =  -720)));
// 
//       equation 
//         port.Q_flow =  -Q_flow * (1 + alpha * (port.T - T_ref));
//       end PrescribedHeatFlow;
//       model TemperatureSensor "Absolute temperature sensor in Kelvin"
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -94,0},{ -14,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{60, -78},{102, -28}}, textString = "K", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Kelvin as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{26, -120},{126, -20}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial")}));
//         Modelica.Blocks.Interfaces.RealOutput T(redeclare type SignalType = SI.Temperature) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.HeatPort_a port annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         T = port.T;
//         port.Q_flow = 0;
//       end TemperatureSensor;
//       model RelTemperatureSensor "Relative Temperature sensor"
//         extends Modelica.Icons.TranslationalSensor;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -70,0},{ -70,0}}, color = {191,0,0}),Line(visible = true, points = {{ -98,0},{ -70,0},{ -70,0}}, color = {191,0,0}),Line(visible = true, points = {{70,0},{94,0},{94,0}}, color = {191,0,0}),Line(visible = true, points = {{0, -30},{0, -80}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, extent = {{32, -102},{64, -74}}, textString = "K", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// The relative temperature \"port_a.T - port_b.T\" is determined between
// the two ports of this component and is provided as output signal in Kelvin.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -90,0},{ -70,0},{ -70,0}}, color = {191,0,0}),Line(visible = true, points = {{ -90,0},{ -70,0},{ -70,0}}, color = {191,0,0}),Line(visible = true, points = {{70,0},{90,0},{90,0}}, color = {191,0,0}),Line(visible = true, points = {{0, -30},{0, -80}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -140,34},{144,94}}, textString = "%name", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{34, -122},{92, -62}}, textString = "K", fontName = "Arial")}));
//         Interfaces.HeatPort_a port_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.HeatPort_b port_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput T_rel(redeclare type SignalType = SI.Temperature) annotation(Placement(visible = true, transformation(origin = {0, -90}, extent = {{ -10,10},{10, -10}}, rotation =  -90), iconTransformation(origin = {0, -90}, extent = {{ -10,10},{10, -10}}, rotation =  -90)));
// 
//       equation 
//         T_rel = port_a.T - port_b.T;
//         0 = port_a.Q_flow;
//         0 = port_b.Q_flow;
//       end RelTemperatureSensor;
//       model HeatFlowSensor "Heat flow rate sensor"
//         extends Modelica.Icons.RotationalSensor;
//         annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -70,0},{ -95,0}}, color = {191,0,0}),Line(visible = true, points = {{0, -70},{0, -90}}, color = {0,0,255}),Line(visible = true, points = {{94,0},{69,0}}, color = {191,0,0})}), Documentation(info = "<HTML>
// <p>
// This model is capable of monitoring the heat flow rate flowing through
// this component. The sensed value of heat flow rate is the amount that
// passes through this sensor while keeping the temperature drop across the
// sensor zero.  This is an ideal model so it does not absorb any energy
// and it has no direct effect on the thermal response of a system it is included in.
// The output signal is positive, if the heat flows from port_a
// to port_b.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{33, -116},{88, -58}}, textString = "Q_flow", fontName = "Arial"),Line(visible = true, points = {{ -70,0},{ -90,0}}, color = {191,0,0}),Line(visible = true, points = {{69,0},{90,0}}, color = {191,0,0}),Line(visible = true, points = {{0, -70},{0, -90}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial")}));
//         Interfaces.HeatPort_a port_a annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Interfaces.HeatPort_b port_b annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Interfaces.RealOutput Q_flow(redeclare type SignalType = SI.HeatFlowRate) "Heat flow from port_a to port_b" annotation(Placement(visible = true, transformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -450), iconTransformation(origin = {0, -100}, extent = {{ -10, -10},{10,10}}, rotation =  -450)));
// 
//       equation 
//         port_a.T = port_b.T;
//         port_a.Q_flow + port_b.Q_flow = 0;
//         Q_flow = port_a.Q_flow;
//       end HeatFlowSensor;
//       package Celsius "Components with Celsius input and/or output"
//         extends Modelica.Icons.Library2;
//         model ToKelvin "Conversion block from Celsius to Kelvin"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -99, -99},{ -40, -50}}, textString = "C", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{44, -100},{100, -47}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{41,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts an input signal from Celsius to Kelvin
// and provide is as output signal.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, extent = {{32, -120},{112, -40}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -111, -119},{ -31, -39}}, textString = "C", fontName = "Arial"),Line(visible = true, points = {{ -41,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{100,0},{40,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealInput Celsius(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degC) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Kelvin = from_degC(Celsius);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Celsius"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -101, -98},{ -42, -41}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -100},{100, -40}}, textString = "C", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts an input signal from Kelvin to Celsius
// and provides is as output signal.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -114, -122},{ -34, -42}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -119},{110, -39}}, textString = "C", fontName = "Arial"),Line(visible = true, points = {{ -40,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.RealInput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Celsius(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degC) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Celsius = to_degC(Kelvin);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in degree Celsius"
//           parameter NonSI.Temperature_degC T "Fixed Temperature at the port";
//           annotation(Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in [degC],
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "C", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -118,105},{122,165}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "C", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -145, -151},{135, -102}}, textString = "T=%T", fontName = "Arial"),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5)}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degC(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Celsius"
//           annotation(Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in [degC] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "C", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "C", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -122,103},{118,163}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput T(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degC) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degC(T);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Celsius units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit,
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degC(20));
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -62, -90},{38,10}}, textString = "C", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model TemperatureSensor "Absolute temperature sensor in Celsius"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -94,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{60, -74},{102, -22}}, textString = "C", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Celsius as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{26, -120},{126, -20}}, textString = "C", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealOutput T(redeclare type SignalType = NonSI.Temperature_degC) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.HeatPort_a port annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           T = to_degC(port.T);
//           port.Q_flow = 0;
//         end TemperatureSensor;
//       end Celsius;
//       package Fahrenheit "Components with Fahrenheit input and/or output"
//         extends Modelica.Icons.Library2;
//         model ToKelvin "Conversion block from Fahrenheit to Kelvin"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -99, -99},{ -40, -50}}, textString = "F", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{44, -100},{100, -47}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{41,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts a input signal from degree Fahrenheit to Kelvin
// and provides is as output signal.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, extent = {{32, -120},{112, -40}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -111, -119},{ -31, -39}}, textString = "F", fontName = "Arial"),Line(visible = true, points = {{ -41,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{100,0},{40,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealInput Fahrenheit(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degF) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Kelvin = from_degF(Fahrenheit);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Fahrenheit"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -101, -98},{ -42, -41}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -100},{100, -40}}, textString = "F", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Kelvin to Fahrenheit
// and provides them as output signals.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -114, -122},{ -34, -42}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -119},{110, -39}}, textString = "F", fontName = "Arial"),Line(visible = true, points = {{ -40,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.RealInput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Fahrenheit(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degF) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Fahrenheit = to_degF(Kelvin);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in Fahrenheit"
//           parameter NonSI.Temperature_degF T "Fixed Temperature at the port";
//           annotation(Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in [degF],
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "F", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -118,105},{122,165}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "F", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -145, -151},{135, -102}}, textString = "T=%T", fontName = "Arial"),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5)}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degF(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Fahrenheit"
//           annotation(Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in [degF] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "F", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "F", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -122,103},{118,163}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput T(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degF) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degF(T);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Fahrenheit units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degF(70));
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -60, -90},{40,10}}, textString = "F", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model TemperatureSensor "Absolute temperature sensor in Fahrenheit"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -94,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{60, -74},{102, -22}}, textString = "F", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Fahrenheit as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{26, -120},{126, -20}}, textString = "F", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealOutput T(redeclare type SignalType = NonSI.Temperature_degF) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.HeatPort_a port annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           T = to_degF(port.T);
//           port.Q_flow = 0;
//         end TemperatureSensor;
//       end Fahrenheit;
//       package Rankine "Components with Rankine input and/or output"
//         extends Modelica.Icons.Library2;
//         model ToKelvin "Conversion block from Rankine to Kelvin"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -99, -99},{ -40, -50}}, textString = "Rk", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{44, -100},{100, -47}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{41,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from degree Rankine to Kelvin
// and provides them as output signals.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, extent = {{32, -120},{112, -40}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -111, -119},{ -31, -39}}, textString = "Rk", fontName = "Arial"),Line(visible = true, points = {{ -41,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{100,0},{40,0}}, color = {0,0,255}),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealInput Rankine(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Kelvin = from_degRk(Rankine);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Rankine"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -101, -98},{ -42, -41}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -100},{100, -40}}, textString = "Rk", fontName = "Arial"),Line(visible = true, points = {{ -100,0},{ -40,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Kelvin to Rankine
// and provides them as output signals.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -137,49},{132,99}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -40, -40},{40,40}}),Text(visible = true, lineColor = {0,0,255}, lineThickness = 1, extent = {{ -114, -122},{ -34, -42}}, textString = "K", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, extent = {{30, -119},{110, -39}}, textString = "Rk", fontName = "Arial"),Line(visible = true, points = {{ -40,0},{ -100,0}}, color = {0,0,255}),Line(visible = true, points = {{40,0},{100,0}}, color = {0,0,255})}));
//           Modelica.Blocks.Interfaces.RealInput Kelvin(redeclare type SignalType = Modelica.SIunits.Temperature) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealOutput Rankine(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk) annotation(Placement(visible = true, transformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {110,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           Rankine = to_degRk(Kelvin);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in Rankine"
//           parameter NonSI.Temperature_degRk T "Fixed Temperature at the port";
//           annotation(Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in degree Rankine,
// [degRk], i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "Rk", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -118,105},{122,165}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "Rk", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}}),Text(visible = true, lineColor = {0,0,255}, extent = {{ -145, -151},{135, -102}}, textString = "T=%T", fontName = "Arial"),Line(visible = true, points = {{ -42,0},{66,0}}, color = {191,0,0}, thickness = 0.5)}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degRk(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Rankine"
//           annotation(Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in degree Rankine, [degRk] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "Rk", fontName = "Arial"),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {159,159,223}, pattern = LinePattern.None, fillPattern = FillPattern.Backward, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Text(visible = true, lineColor = {0,0,255}, extent = {{ -100, -100},{0,0}}, textString = "Rk", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -122,103},{118,163}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -102,0},{64,0}}, color = {191,0,0}, thickness = 0.5),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{52, -20},{52,20},{90,0},{52, -20}})}));
//           Interfaces.HeatPort_b port annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput T(redeclare type SignalType = Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk) annotation(Placement(visible = true, transformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0), iconTransformation(origin = { -120,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
// 
//         equation 
//           port.T = from_degRk(T);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Rankine units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degRk(500));
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineColor = {0,0,255}, extent = {{ -60, -90},{40,10}}, textString = "Rk", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         model TemperatureSensor "Absolute temperature sensor in Rankine"
//           annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -94,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{60, -74},{102, -22}}, textString = "Rk", fontName = "Arial")}), Documentation(info = "<HTML>
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Rankine as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -20, -98},{20, -60}}),Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, extent = {{ -12, -68},{12,40}}),Line(visible = true, points = {{12,0},{90,0}}, color = {0,0,255}),Line(visible = true, points = {{ -90,0},{ -12,0}}, color = {191,0,0}),Polygon(visible = true, lineThickness = 0.5, points = {{ -12,40},{ -12,80},{ -10,86},{ -6,88},{0,90},{6,88},{10,86},{12,80},{12,40},{ -12,40}}),Line(visible = true, points = {{ -12,40},{ -12, -64}}, thickness = 0.5),Line(visible = true, points = {{12,40},{12, -64}}, thickness = 0.5),Line(visible = true, points = {{ -40, -20},{ -12, -20}}),Line(visible = true, points = {{ -40,20},{ -12,20}}),Line(visible = true, points = {{ -40,60},{ -12,60}}),Text(visible = true, lineColor = {0,0,255}, extent = {{26, -120},{126, -20}}, textString = "Rk", fontName = "Arial"),Text(visible = true, lineColor = {0,0,255}, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -132,84},{108,144}}, textString = "%name", fontName = "Arial")}));
//           Modelica.Blocks.Interfaces.RealOutput T(redeclare type SignalType = NonSI.Temperature_degRk) annotation(Placement(visible = true, transformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = {100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//           Interfaces.HeatPort_a port annotation(Placement(visible = true, transformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0), iconTransformation(origin = { -100,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//         equation 
//           T = to_degRk(port.T);
//           port.Q_flow = 0;
//         end TemperatureSensor;
//       end Rankine;
//     end HeatTransfer;
//   end Thermal;
//   package Utilities "Utility functions especially for scripting (operating on files, streams, strings, system)"
//     extends Modelica.Icons.Library;
//     annotation(version = "1.0", versionDate = "2004-10-01", preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains Modelica <b>functions</b> that are
// especially suited for <b>scripting</b>. The functions might
// be used to work with strings, read data from file, write data
// to file or copy, move and remove files.
// </p>
// <p>
// For an introduction, have especially a look at:
// </p>
// <ul>
// <li> <a href=\"Modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.Users Guide</a>
//      discusses the most important aspects of this library.</li>
// <li> <a href=\"Modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
//      contains examples that demonstrate the usage of this library.</li>
// </ul>
// <p>
// The following main sublibraries are available:
// </p>
// <ul>
// <li> <a href=\"Modelica:Modelica.Utilities.Files\">Files</a>
//      provides functions to operate on files and directories, e.g.,
//      to copy, move, remove files.</li>
// <li> <a href=\"Modelica:Modelica.Utilities.Streams\">Streams</a>
//      provides functions to read from files and write to files.</li>
// <li> <a href=\"Modelica:Modelica.Utilities.Strings\">Strings</a>
//      provides functions to operate on strings. E.g.
//      substring, find, replace, sort, scanToken.</li>
// <li> <a href=\"Modelica:Modelica.Utilities.System\">System</a>
//      provides functions to interact with the environment. 
//      E.g., get or set the working directory or environment 
//      variables and to send a command to the default shell.</li>
// </ul>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association, DLR and Dynasim.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     package UsersGuide "Users Guide"
//       annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Users Guide of package Modelica.Utilities</font></h3>
// <p>
// Library <b>Modelica.Utilities</b> contains Modelica <b>functions</b> that are
// especially suited for <b>scripting</b>. Currently, only a rudimentary
// users guide is present. This will be improved in the next releases.
// The users guide has currently the following chapters:
// </p>
// <ol>
// <li>
// <a href=\"Modelica://Modelica.Utilities.UsersGuide.ReleaseNotes\">Release Notes</a>
//   summarizes the differences between different versions of this
//   library.
// </li>
// <li>
// <a href=\"Modelica://Modelica.Utilities.UsersGuide.ImplementationNotes\">ImplementationNotes</a>
//   describes design decisions for this library especially for
//   Modelica tool vendors.
// </li>
// <li>
// <a href=\"Modelica://Modelica.Utilities.UsersGuide.Contact\">Contact</a> provides
//   information about the authors of the library as well as acknowledgments.
// </li>
// </ol>
// <p>
// <b>Error handling</b><br>
// In case of error, all functions in this library use a Modelica \"assert(..)\"
// to provide an error message and to cancel all actions. This means that
// functions do not return, if an error is triggered inside the function.
// In the near future, an exception handling mechanism will be introduced
// in Modelica that will allow to catch errors at a defined place.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       class ImplementationNotes "Implementation Notes"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Implementation Notes</font></h3>
// <p>
// Below the major design decisions of this library are summarized.
// <p>
// <ul>
// <li> <b>C-Function Interface</b><br>
//      This library contains several interfaces to C-functions in order
//      to operate with the environment. As will become clear, it is usally
//      required that a Modelica tool vendor provides an implementation
//      of these C-functions that are suited for his environment.
//      In directory \"Modelica.Utilities\\C-Sources\" a reference implementation
//      is given for Microsoft Windows Systems and for POSIX environments.
//      The files \"ModelicaInternal.c\" and \"ModelicaStrings.c\" can be
//      used as a basis for the integration in the vendors environment.<br>&nbsp;</li>
// <li> <b>Character Encoding</b><br>
//      The representation of characters is different in operating systems.
//      The more modern ones (e.g. Windows-NT) use an early variant of 
//      Unicode (16 bit per character)
//      other (e.g. Windows-ME) use 8-bit encoding. Also 32 bit per character
//      and multi-byte representations are in use. This is important, since e.g.,
//      Japanese Modelica users need Unicode representation. The design in this
//      library is done in such a way that a basic set of calls to the operating
//      system hides the actual character representation. This means, that all
//      functions of this package can be used independent from the underlying
//      character representation.<br>
//      The C-interface of the Modelica language provides only an 8-bit
//      character encoding passing mechanism of strings. As a result, the
//      reference implementation in \"Modelica.Utilities\\C-Source\" needs to
//      be adapted to the character representation supported in the 
//      Modelica vendor environment.<br>&nbsp;</li>
// <li> <b>Internal String Representation</b><br>
//      The design of this package was made in order that string handling
//      is convenient. This is in contrast to, e.g., the C-language, where
//      string handling is inconvenient, cumbersome and error prone, but on the
//      other hand is in some sense \"efficient\". 
//      The standard reference implementation in \"Modelica.Utilities\\C-Source\"
//      is based on the standard C definition of a string, i.e., a pointer to
//      a sequence of characters, ended with a null terminating character.
//      In order that the string handling in this package is convenient,
//      some assumptions have been made, especially, that the access to
//      a substring is efficient (O(1) access instead of O(n) as in standard C).
//      This allows to hide string pointer arithmetic from the user.
//      In such a case, a similiar efficiency as in C can be expected for
//      most high level operations, such as find, sort, replace. 
//      The \"efficient character access\" can be reached if, e.g.,
//      the number of characters
//      are stored in a string, and the length of a character is fixed,
//      say 16 or 32 bit (if all Unicode characters shall be represented). 
//      A vendor should adapt the reference implementation in this
//      respect.<br>&nbsp;</li>
// <li> <b>String copy = pointer copy</b><br>
//      The Modelica language has no mechanism to change a character
//      of a string. When a string has to be modified, the only way
//      to achieve this is to generate it newly. The advantage is that
//      a Modelica tool can treat a string as a constant entity and
//      can replace (expensive) string copy operations by pointer
//      copy operations. For example, when sorting a set of strings
//      the following type of operations occur:
//      <pre>
//      String s[:], s_temp;
//       ...
//      s_temp := s[i];
//      s[i]   := s[j];
//      s[j]   := s_temp;
//      </pre>
//      Formally, three strings are copied. Due to the feature
//      sketched above, a Modelica tool can replace this
//      copy operation by pointer assignments, a very \"cheap\"
//      operation. The Modelica.Utilities functions will perform
//      efficiently, if such types of optimizations are supported
//      by the tool.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end ImplementationNotes;
//       class ReleaseNotes "Release notes"
//         annotation(Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Release notes</font></h3>
// <h3><font color=\"#008000\">Version 1.0, 2004-09-29</font></h3>
// <p>
// First version implemented.
// </p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end ReleaseNotes;
//       class Contact "Contact"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// <dl>
// <dt><b>Responsible for Library:</b>
// <dd>Dag Br&uuml;ck, Dynasim AB, Sweden.<br>
//     email: <A HREF=\"mailto:Dag@Dynasim.se\">Dag@Dynasim.se</A><br>
// </dl>
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> This library has been designed by:<br> 
//      <blockquote>
//      Dag Br&uuml;ck, Dynasim AB, Sweden <br>
//      Hilding Elmqvist, Dynasim AB, Sweden <br>
//      Hans Olsson, Dynasim AB, Sweden <br>
//      Martin Otter, DLR Oberpfaffenhofen, Germany.
//      </blockquote></li>
// <li> The library including the C reference implementation has
//      been implemented by Martin Otter and Dag Br&uuml;ck.</li>
// <li> The Examples.calculator demonstration to implement a calculator
//      with this library is from Hilding Elmqvist.</li>
// <li> Helpful comments from Kaj Nystr&ouml;m, PELAB, Link&ouml;ping, Sweden,
//      are appreciated, as well as discussions at the 34th, 36th, and 40th
//      Modelica Design Meetings in Vienna, Link&ouml;ping, and Dresden. </li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Contact;
//     end UsersGuide;
//     package Internal "Internal package as interface to the operating system"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// Package <b>Internal</b> is an internal package that contains 
// low level functions as interface to the operating system.
// These functions should not be called directly in a scripting
// environment since more convenient functions are provided
// in packages Files and Systems.
// </p>
// <p>
// Note, the functions in this package are direct interfaces to
// functions of POSIX and of the standard C library. Errors
// occuring in these functions are treated by triggering
// a Modelica assert. Therefore, the functions in this package
// return only for a successful operation. Furthermore, the
// representation of a string is hidden by this interface,
// especially if the operating system supports Unicode characters.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function mkdir "Make directory (POSIX: 'mkdir')"
//         extends Modelica.Icons.Function;
//         input String directoryName "Make a new directory";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_mkdir(directoryName) ; 
//       end mkdir;
//       function rmdir "Remove empty directory (POSIX function 'rmdir')"
//         extends Modelica.Icons.Function;
//         input String directoryName "Empty directory to be removed";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_rmdir(directoryName) ; 
//       end rmdir;
//       function stat "Inquire file information (POSIX function 'stat')"
//         extends Modelica.Icons.Function;
//         input String name "Name of file, directory, pipe etc.";
//         output Types.FileType.Type fileType "Type of file";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" fileType = ModelicaInternal_stat(name) ;
//       end stat;
//       function rename "Rename existing file or directory (C function 'rename')"
//         extends Modelica.Icons.Function;
//         input String oldName "Current name";
//         input String newName "New name";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_rename(oldName,newName) ; 
//       end rename;
//       function removeFile "Remove existing file (C function 'remove')"
//         extends Modelica.Icons.Function;
//         input String fileName "File to be removed";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_removeFile(fileName) ; 
//       end removeFile;
//       function copyFile "Copy existing file (C functions 'fopen', 'getc', 'putc', 'fclose')"
//         extends Modelica.Icons.Function;
//         input String fromName "Name of file to be copied";
//         input String toName "Name of copy of file";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_copyFile(fromName,toName) ; 
//       end copyFile;
//       function readDirectory "Read names of a directory (POSIX functions opendir, readdir, closedir)"
//         extends Modelica.Icons.Function;
//         input String directory "Name of the directory from which information is desired";
//         input Integer nNames "Number of names that are returned (inquire with getNumberOfFiles)";
//         output String names[nNames] "All file and directory names in any order from the desired directory";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_readDirectory(directory,nNames,names) ; 
//       end readDirectory;
//       function getNumberOfFiles "Get number of files and directories in a directory (POSIX functions opendir, readdir, closedir)"
//         extends Modelica.Icons.Function;
//         input String directory "Directory name";
//         output Integer result "Number of files and directories present in 'directory'";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" result = ModelicaInternal_getNumberOfFiles(directory) ;
//       end getNumberOfFiles;
//     end Internal;
//     package Examples "Examples to demonstrate the usage of package Modelica.Utilities"
//       annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains quite involved examples that demonstrate how to
// use the functions of package Modelica.Utilities. In particular
// the following examples are present.
// </p>
// <ul>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Examples.calculator\">calculator</a>
//      is an interpreter to evaluate 
//      expressions consisting of +,-,*,/,(),sin(), cos(), tan(), sqrt(), pi.
//      For example: calculator(\"1.5*sin(pi/6)\"); <br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Examples.expression\">expression</a>
//      is the basic function used in \"calculator\" to evaluate an expression.
//      It is useful if the expression interpreter is used in a larger
//      scan operation (such as readRealParameter below).<br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Examples.readRealParameter\">readRealParameter</a>
//      reads the value of a parameter
//      from file, given the file and the parameter name. The value
//      on file is interpreted with the Examples.expression function
//      and can therefore be an expression.<br>&nbsp;</li>
// <li> Model <a href=\"Modelica:Modelica.Utilities.Examples.readRealParameterModel\">readRealParameterModel</a>
//      is a test model to demonstrate the usage of \"readRealParameter\". The model
//      contains 3 parameters that are read from file \"Modelica.Utilities/data/Examples_readRealParameters.txt\".
//      </li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function calculator "Interpreter to evaluate simple expressions consisting of +,-,*,/,(),sin(), cos(), tan(), sqrt(), pi"
//         import Modelica.Utilities.Strings.*;
//         extends Modelica.Icons.Function;
//         input String string "Expression that is evaluated";
//         output Real result "Value of expression";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer nextIndex;
//       algorithm 
//         (result,nextIndex):=expression(string, 1);
//         Strings.scanNoToken(string, nextIndex);
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// result = <b>calculator</b>(expression);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function demonstrates how a simple expression calculator
// can be implemented in form of a recursive decent parser
// using basically the Strings.scanToken(..) and Strings.scanDelimiter(..)
// function. 
// </p>
// <p>
// The following operations are supported (pi=3.14.. is a predefined constant):
// </p>
// <pre>
//    +, -
//    *, /
//    (expression)
//    sin(expression)
//    cos(expression)
//    tan(expression)
//    sqrt(expression)
//    pi
// </pre>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   calculator(\"2+3*(4-1)\");  // returns 11
//   calculator(\"sin(pi/6)\");  // returns 0.5
// </pre></blockquote>
// </html>"));
//       end calculator;
//       function expression "Expression interpreter that returns with the position after the expression (expression may consist of +,-,*,/,(),sin(), cos(), tan(), sqrt(), pi"
//         import Modelica.Utilities.*;
//         import Modelica.Utilities.Types.TokenType;
//         extends Modelica.Icons.Function;
//         input String string "Expression that is evaluated";
//         input Integer startIndex = 1 "Start scanning of expression at character startIndex";
//         input String message = "" "Message used in error message if scan is not successful";
//         output Real result "Value of expression";
//         output Integer nextIndex "Index after the scanned expression";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         encapsulated function term "Evaluate term of an expression"
//           import Modelica.Utilities.Types;
//           import Modelica.Utilities.Strings;
//           import Modelica.Utilities.Examples.expression.primary;
//           import Modelica.Icons;
//           extends Icons.Function;
//           input String string;
//           input Integer startIndex;
//           input String message = "";
//           output Real result;
//           output Integer nextIndex;
//         protected 
//           Real result2;
//           Boolean scanning = true;
//           String operator;
//         algorithm 
//           (result,nextIndex):=primary(string, startIndex, message);
//           while (scanning) loop
//                       (operator,nextIndex):=Strings.scanDelimiter(string, nextIndex, {"*","/",""}, message);
//             if operator == "" then 
//                         scanning:=false;
// 
//             else             (result2,nextIndex):=primary(string, nextIndex, message);
//             result:=if operator == "*" then result * result2 else result / result2;
// 
//             end if;
// 
//           end while;
//         end term;
//         encapsulated function primary "Evaluate primary of an expression"
//           import Modelica.Math;
//           import Modelica.Constants;
//           import Modelica.Utilities.Types;
//           import Modelica.Utilities.Strings.*;
//           import Modelica.Utilities.Examples.expression;
//           import Modelica.Icons;
//           extends Icons.Function;
//           input String string;
//           input Integer startIndex;
//           input String message = "";
//           output Real result;
//           output Integer nextIndex;
//         protected 
//           Types.TokenValue token;
//           Real result2;
//           String delimiter;
//           String functionName;
//           Real pi = Constants.pi;
//         algorithm 
//           (token,nextIndex):=scanToken(string, startIndex, unsigned = true);
//           if token.tokenType == Types.TokenType.DelimiterToken and token.string == "(" then 
//                     (result,nextIndex):=expression(string, nextIndex, message);
//           (delimiter,nextIndex):=scanDelimiter(string, nextIndex, {")"}, message);
//           elseif token.tokenType == Types.TokenType.RealToken then
//             result:=token.real;
// 
//           elseif token.tokenType == Types.TokenType.IntegerToken then
//             result:=token.integer;
// 
//           elseif token.tokenType == Types.TokenType.IdentifierToken then
//             if token.string == "pi" then 
//                         result:=pi;
// 
//             else             functionName:=token.string;
//             (delimiter,nextIndex):=scanDelimiter(string, nextIndex, {"("}, message);
//             (result,nextIndex):=expression(string, nextIndex, message);
//             (delimiter,nextIndex):=scanDelimiter(string, nextIndex, {")"}, message);
//             if functionName == "sin" then 
//                         result:=Math.sin(result);
//             elseif functionName == "cos" then
//               result:=Math.cos(result);
// 
//             elseif functionName == "tan" then
//               result:=Math.tan(result);
// 
//             elseif functionName == "sqrt" then
//               if result < 0.0 then 
//                             syntaxError(string, startIndex, "Argument of call \"sqrt(" + String(result) + ")\" is negative.\n" + "Imaginary numbers are not supported by the calculator.\n" + message);
// 
//               else 
//               end if;
//               result:=sqrt(result);
// 
// 
//             else             syntaxError(string, startIndex, "Function \"" + functionName + "\" is unknown (not supported)\n" + message);
// 
//             end if;
// 
//             end if;
// 
// 
//           else           syntaxError(string, startIndex, "Invalid primary of expression.\n" + message);
// 
//           end if;
//         end primary;
//         Real result2;
//         String signOfNumber;
//         Boolean scanning = true;
//         String operator;
//       algorithm 
//         (signOfNumber,nextIndex):=Strings.scanDelimiter(string, startIndex, {"+","-",""}, message);
//         (result,nextIndex):=term(string, nextIndex, message);
//         if signOfNumber == "-" then 
//                 result:= -result;
// 
//         else 
//         end if;
//         while (scanning) loop
//                   (operator,nextIndex):=Strings.scanDelimiter(string, nextIndex, {"+","-",""}, message);
//           if operator == "" then 
//                     scanning:=false;
// 
//           else           (result2,nextIndex):=term(string, nextIndex, message);
//           result:=if operator == "+" then result + result2 else result - result2;
// 
//           end if;
// 
//         end while;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              result = <b>expression</b>(string);
// (result, nextIndex) = <b>expression</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function is nearly the same as Examples.<b>calculator</b>.
// The essential difference is that function \"expression\" might be
// used in other parsing operations: After the expression is 
// parsed and evaluated, the function returns with the value
// of the expression as well as the position of the character
// directly after the expression.
// </p>
// <p>
// This function demonstrates how a simple expression calculator
// can be implemented in form of a recursive decent parser
// using basically the Strings.scanToken(..) and scanDelimiters(..)
// function. There are 2 local functions (term, primary) that
// implement the corresponding part of the grammar.
// </p>
// <p>
// The following operations are supported (pi=3.14.. is a predefined constant):
// </p>
// <pre>
//    +, -
//    *, /
//    (expression)
//    sin(expression)
//    cos(expression)
//    tan(expression)
//    sqrt(expression)
//    pi
// </pre>
// <p>
// The optional argument \"startIndex\" defines at which position
// scanning of the expression starts.
// </p>
// <p>
// In case of error,
// the optional argument \"message\" is appended to the error
// message, in order to give additional information where
// the error occured.
// </p>
// <p>
// This function parses the following grammaer
// </p>
// <pre>
//   expression: [ add_op ] term { add_op term }
//   add_op    : \"+\" | \"-\"
//   term      : primary { mul_op primary }
//   mul_op    : \"*\" | \"/\"
//   primary   : UNSIGNED_NUMBER
//               | pi
//               | ( expression )
//               | functionName( expression )
//   function  :   sin
//               | cos
//               | tan
//               | sqrt
// </pre>
// <p>
// Note, in Examples.readRealParameter it is shown, how the expression
// function can be used as part of another scan operation.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   expression(\"2+3*(4-1)\");  // returns 11
//   expression(\"sin(pi/6)\");  // returns 0.5
// </pre></blockquote>
// </html>"));
//       end expression;
//       function readRealParameter "Read the value of a Real parameter from file"
//         import Modelica.Utilities.*;
//         extends Modelica.Icons.Function;
//         input String fileName "Name of file";
//         input String name "Name of parameter";
//         output Real result "Actual value of parameter on file";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         String line;
//         String identifier;
//         String delimiter;
//         Integer nextIndex;
//         Integer iline = 1;
//         Types.TokenValue token;
//         String message = "in file \"" + fileName + "\" on line ";
//         String message2;
//         Boolean found = false;
//         Boolean endOfFile = false;
//       algorithm 
//         (line,endOfFile):=Streams.readLine(fileName, iline);
//         while (not found and not endOfFile) loop
//                   (token,nextIndex):=Strings.scanToken(line);
//           (line,endOfFile):=Streams.readLine(fileName, iline);
// 
//         end while;
//         if not found then 
//                 Streams.error("Parameter \"" + name + "\" not found in file \"" + fileName + "\"");
// 
//         else 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// result = <b>readRealParameter</b>(fileName, name);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function demonstrates how a function can be implemented
// that reads the value of a parameter from file. The function
// performs the following actions:
// </p>
// <ol>
// <li> It opens file \"fileName\" and reads the lines of the file.</li>
// <li> In every line, Modelica line comments (\"// ... end-of-line\") 
//      are skipped </li>
// <li> If a line consists of \"name = expression\" and the \"name\"
//      in this line is identical to the second argument \"name\"
//      of the function call, the expression calculator Examples.expression
//      is used to evaluate the expression after the \"=\" character.
//      The expression can optionally be terminated with a \";\".</li>
// <li> The result of the expression evaluation is returned as
//      the value of the parameter \"name\". </li>
// </ol>
// <h3><font color=\"#008000\">Example</font></h3>
// <p>
// On file \"test.txt\" the following lines might be present:
// </p>
// <blockquote><pre>
// // Motor data
// J        = 2.3     // inertia
// w_rel0   = 1.5*2;  // relative angular velocity
// phi_rel0 = pi/3    
// </pre></blockquote>
// <p>
// The function returns the value \"3.0\" when called as:
// </p>
// <blockquote><pre>
// readRealParameter(\"test.txt\", \"w_rel0\")
// </pre></blockquote>
// </html>"));
//       end readRealParameter;
//       model readRealParameterModel "Demonstrate usage of Examples.readRealParameter/.expression"
//         import SI = Modelica.SIunits;
//         extends Modelica.Icons.Example;
//         parameter String file = classDirectory() + "data/Examples_readRealParameters.txt" "File on which data is present";
//         parameter SI.Inertia J = readRealParameter(file, "J");
//         parameter SI.Angle phi_rel0 = readRealParameter(file, "phi_rel0");
//         parameter SI.AngularVelocity w_rel0 = readRealParameter(file, "w_rel0");
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//       equation 
//         annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// Model that shows the usage of Examples.readRealParameter and Examples.expression.
// The model has 3 parameters and the values of these parameters are read
// from a file.
// </p>
// </html>"));
//       end readRealParameterModel;
//     end Examples;
//     package Files "Functions to work with files and directories"
//       function list "List content of file or directory"
//         extends Modelica.Icons.Function;
//         input String name "If name is a directory, list directory content. If it is a file, list the file content";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         encapsulated package Local "Local utility functions"
//           import Modelica.Utilities.*;
//           import Modelica.Utilities.Internal;
//           function listFile "List content of file"
//             input String name;
//           protected 
//             String file[Streams.countLines(name)] = Streams.readFile(name);
//           algorithm 
//             for i in 1:min(size(file, 1), 100) loop
//                           Streams.print(file[i]);
// 
//             end for;
//           end listFile;
//           function sortDirectory "Sort directory in directories and files with alphabetic order"
//             input String directory "Directory that was read (including a trailing '/')";
//             input String names[:] "File and directory names of a directory in any order";
//             output String orderedNames[size(names, 1)] "Names of directories followed by names of files";
//             output Integer nDirectories "The first nDirectories entries in orderedNames are directories";
//           protected 
//             Integer nEntries = size(names, 1);
//             Integer nFiles;
//             Integer lenDirectory = Strings.length(directory);
//             String directory2;
//           algorithm 
//             directory2:=if Strings.substring(directory, lenDirectory, lenDirectory) == "/" then directory else directory + "/";
//             nDirectories:=0;
//             nFiles:=0;
//             for i in 1:nEntries loop
//                           if Internal.stat(directory2 + names[i]) == Types.FileType.Directory then 
//                             nDirectories:=nDirectories + 1;
//               orderedNames[nDirectories]:=names[i];
// 
//               else               nFiles:=nFiles + 1;
//               orderedNames[nEntries - nFiles + 1]:=names[i];
// 
//               end if;
// 
//             end for;
//             if nDirectories > 0 then 
//                         orderedNames[1:nDirectories]:=Strings.sort(orderedNames[1:nDirectories], caseSensitive = false);
// 
//             else 
//             end if;
//             if nFiles > 0 then 
//                         orderedNames[nDirectories + 1:nEntries]:=Strings.sort(orderedNames[nDirectories + 1:nEntries], caseSensitive = false);
// 
//             else 
//             end if;
//           end sortDirectory;
//           function listDirectory "List content of directory"
//             input String directoryName;
//             input Integer nEntries;
//           protected 
//             String files[nEntries];
//             Integer nDirectories;
//           algorithm 
//             if nEntries > 0 then 
//                         Streams.print("\nDirectory \"" + directoryName + "\":");
//             files:=Internal.readDirectory(directoryName, nEntries);
//             (files,nDirectories):=sortDirectory(directoryName, files);
//             if nDirectories > 0 then 
//                         Streams.print("  Subdirectories:");
//             for i in 1:nDirectories loop
//                           Streams.print("    " + files[i]);
// 
//             end for;
//             Streams.print(" ");
// 
//             else 
//             end if;
//             if nDirectories < nEntries then 
//                         Streams.print("  Files:");
//             for i in nDirectories + 1:nEntries loop
//                           Streams.print("    " + files[i]);
// 
//             end for;
// 
//             else 
//             end if;
// 
//             else             Streams.print("... Directory\"" + directoryName + "\" is empty");
// 
//             end if;
//           end listDirectory;
//         end Local;
//         Types.FileType.Type fileType;
//       algorithm 
//         fileType:=Internal.stat(name);
//         if fileType == Types.FileType.RegularFile then 
//                 Local.listFile(name);
//         elseif fileType == Types.FileType.Directory then
//           Local.listDirectory(name, Internal.getNumberOfFiles(name));
// 
//         elseif fileType == Types.FileType.SpecialFile then
//           Streams.error("Cannot list file \"" + name + "\"\n" + "since it is not a regular file (pipe, device, ...)");
// 
// 
//         else         Streams.error("Cannot list file or directory \"" + name + "\"\n" + "since it does not exist");
// 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>list</b>(name);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// If \"name\" is a regular file, the content of the
// file is printed.
// </p>
// <p>
// If \"name\" is a directory, the directory and file names
// in the \"name\" directory are printed in sorted order.
// </p>
// </html>"));
//       end list;
//       extends Modelica.Icons.Library;
//       annotation(version = "0.8", versionDate = "2004-08-24", preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package contains functions to work with files and directories.
// As a general convention of this package, '/' is used as directory
// separator both for input and output arguments of all functions.
// For example:
// </p>
// <pre>
//    exist(\"Modelica/Mechanics/Rotational.mo\");
// </pre>
// <p>
// The functions provide the mapping to the directory separator of the
// underlying operating system. Note, that on Windows system the usage
// of '\\' as directory separator would be inconvenient, because this
// character is also the escape character in Modelica and C Strings.
// </p>
// <p>
// In the table below an example call to every function is given:
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.list\">list</a>(name)</td>
//       <td> List content of file or of directory.</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.copy\">copy</a>(oldName, newName)<br>
//           <a href=\"Modelica:Modelica.Utilities.Files.copy\">copy</a>(oldName, newName, replace=false)</td>
//       <td> Generate a copy of a file or of a directory.</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.move\">move</a>(oldName, newName)<br>
//           <a href=\"Modelica:Modelica.Utilities.Files.move\">move</a>(oldName, newName, replace=false)</td>
//       <td> Move a file or a directory to another place.</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.remove\">remove</a>(name)</td>
//       <td> Remove file or directory (ignore call, if it does not exist).</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.removeFile\">removeFile</a>(name)</td>
//       <td> Remove file (ignore call, if it does not exist)</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.createDirectory\">createDirectory</a>(name)</td>
//       <td> Create directory (if directory already exists, ignore call).</td>
//   </tr>
//   <tr><td>result = <a href=\"Modelica:Modelica.Utilities.Files.exist\">exist</a>(name)</td>
//       <td> Inquire whether file or directory exists.</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Files.assertNew\">assertNew</a>(name,message)</td>
//       <td> Trigger an assert, if a file or directory exists.</td>
//   </tr>
//   <tr><td>fullName = <a href=\"Modelica:Modelica.Utilities.Files.fullPathName\">fullPathName</a>(name)</td>
//       <td> Get full path name of file or directory name.</td>
//   </tr>
//   <tr><td>(directory, name, extension) = <a href=\"Modelica:Modelica.Utilities.Files.splitPathName\">splitPathName</a>(name)</td>
//       <td> Split path name in directory, file name kernel, file name extension.</td>
//   </tr>
//   <tr><td>fileName = <a href=\"Modelica:Modelica.Utilities.Files.temporaryFileName\">temporaryFileName</a>()</td>
//       <td> Return arbitrary name of a file that does not exist<br>
//            and is in a directory where access rights allow to <br>
//            write to this file (useful for temporary output of files).</td>
//   </tr>
// </table>
// </HTML>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function copy "Generate a copy of a file or of a directory"
//         extends Modelica.Icons.Function;
//         input String oldName "Name of file or directory to be copied";
//         input String newName "Name of copy of the file or of the directory";
//         input Boolean replace = false "= true, if an existing file may be replaced by the required copy";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         encapsulated function copyDirectory "Copy a directory"
//           import Modelica.Utilities.*;
//           import Modelica.Utilities.Internal;
//           input String oldName "Old directory name without trailing '/'; existance is guaranteed";
//           input String newName "New diretory name without trailing '/'; directory was already created";
//           input Boolean replace "= true, if an existing newName may be replaced";
//         protected 
//           Integer nNames = Internal.getNumberOfFiles(oldName);
//           String oldNames[nNames];
//           String oldName_i;
//           String newName_i;
//         algorithm 
//           oldNames:=Internal.readDirectory(oldName, nNames);
//           for i in 1:nNames loop
//                       oldName_i:=oldName + "/" + oldNames[i];
//             newName_i:=newName + "/" + oldNames[i];
//             Files.copy(oldName_i, newName_i, replace);
// 
//           end for;
//         end copyDirectory;
//         Integer lenOldName = Strings.length(oldName);
//         Integer lenNewName = Strings.length(newName);
//         String oldName2 = if Strings.substring(oldName, lenOldName, lenOldName) == "/" then Strings.substring(oldName, 1, lenOldName - 1) else oldName;
//         String newName2 = if Strings.substring(newName, lenNewName, lenNewName) == "/" then Strings.substring(newName, 1, lenNewName - 1) else newName;
//         Types.FileType.Type oldFileType = Internal.stat(oldName2);
//         Types.FileType.Type newFileType;
//       algorithm 
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>copy</b>(oldName, newName);
// Files.<b>copy</b>(oldName, newName, replace = true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>copy</b>(..) copies a file or a directory
// to a new location. Via the optional argument <b>replace</b>
// it can be defined whether an already existing file may
// be replaced by the required copy.
// </p>
// <p>
// If oldName/newName are directories, then the newName
// directory may exist. In such a case the content of oldName
// is copied into directory newName. If replace = <b>false</b>
// it is required that the existing files
// in newName are different from the existing files in 
// oldName.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   copy(\"C:/test1/directory1\", \"C:/test2/directory2\");
//      -> the content of directory1 is copied into directory2
//         if \"C:/test2/directory2\" does not exist, it is newly
//         created. If \"replace=true\", files in directory2
//         may be overwritten by their copy
//   copy(\"test1.txt\", \"test2.txt\")
//      -> make a copy of file \"test1.txt\" with the name \"test2.txt\"
//         in the current directory
// </pre></blockquote>
// </HTML>"));
//       end copy;
//       function move "Move a file or a directory to another place"
//         extends Modelica.Icons.Function;
//         input String oldName "Name of file or directory to be moved";
//         input String newName "New name of the moved file or directory";
//         input Boolean replace = false "= true, if an existing file or directory may be replaced";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         if Strings.find(oldName, "/") == 0 and Strings.find(newName, "/") == 0 then 
//                 Internal.rename(oldName, newName);
// 
//         else         Files.copy(oldName, newName, replace);
//         Files.remove(oldName);
// 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>move</b>(oldName, newName);
// Files.<b>move</b>(oldName, newName, replace = true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>move</b>(..) moves a file or a directory
// to a new location. Via the optional argument <b>replace</b>
// it can be defined whether an already existing file may
// be replaced.
// </p>
// <p>
// If oldName/newName are directories, then the newName
// directory may exist. In such a case the content of oldName
// is moved into directory newName. If replace = <b>false</b>
// it is required that the existing files
// in newName are different from the existing files in 
// oldName.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   move(\"C:/test1/directory1\", \"C:/test2/directory2\");
//      -> the content of directory1 is moved into directory2.
//         Afterwards directory1 is deleted.
//         if \"C:/test2/directory2\" does not exist, it is newly
//         created. If \"replace=true\", files in directory2
//         may be overwritten
//    move(\"test1.txt\", \"test2.txt\")
//      -> rename file \"test1.txt\" into \"test2.txt\"
//         within the current directory
// </pre></blockquote>
// </HTML>"));
//       end move;
//       function remove "Remove file or directory (ignore call, if it does not exist)"
//         extends Modelica.Icons.Function;
//         input String name "Name of file or directory to be removed";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         encapsulated function removeDirectory "Remove a directory, even if it is not empty"
//           import Modelica.Utilities.*;
//           import Modelica.Utilities.Internal;
//           input String name;
//         protected 
//           Integer nNames = Internal.getNumberOfFiles(name);
//           Integer lenName = Strings.length(name);
//           String fileNames[nNames];
//           String name2 = if Strings.substring(name, lenName, lenName) == "/" then Strings.substring(name, lenName - 1, lenName - 1) else name;
//         algorithm 
//           fileNames:=Internal.readDirectory(name2, nNames);
//           for i in 1:nNames loop
//                       Files.remove(name2 + "/" + fileNames[i]);
// 
//           end for;
//           Internal.rmdir(name2);
//         end removeDirectory;
//         String fullName = Files.fullPathName(name);
//         Types.FileType.Type fileType = Internal.stat(fullName);
//       algorithm 
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>remove</b>(name);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Removes the file or directory \"name\". If \"name\" does not exist,
// the function call is ignored. If \"name\" is a directory, first
// the content of the directory is removed and afterwards
// the directory itself.
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// </p>
// </html>"));
//       end remove;
//       function removeFile "Remove file (ignore call, if it does not exist)"
//         extends Modelica.Icons.Function;
//         input String fileName "Name of file that should be removed";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Types.FileType.Type fileType = Internal.stat(fileName);
//       algorithm 
//         if fileType == Types.FileType.RegularFile then 
//                 Internal.removeFile(fileName);
//         elseif fileType == Types.FileType.Directory then
//           Streams.error("File \"" + fileName + "\" should be removed.\n" + "This is not possible, because it is a directory");
// 
//         elseif fileType == Types.FileType.SpecialFile then
//           Streams.error("File \"" + fileName + "\" should be removed.\n" + "This is not possible, because it is a special file (pipe, device, etc.)");
// 
// 
//         else 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>removeFile</b>(fileName);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Removes the file \"fileName\". If \"fileName\" does not exist,
// the function call is ignored. If \"fileName\" exists but is
// no regular file (e.g., directory, pipe, device, etc.) an
// error is triggered. 
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// </p>
// </html>"));
//       end removeFile;
//       function createDirectory "Create directory (if directory already exists, ignore call)"
//         extends Modelica.Icons.Function;
//         input String directoryName "Name of directory to be created (if present, ignore call)";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         encapsulated package Local "Local utility functions"
//           import Modelica.Utilities.*;
//           import Modelica.Utilities.Internal;
//           function existDirectory "Inquire whether directory exists; if present and not a directory, trigger an error"
//             input String directoryName;
//             output Boolean exists "true if directory exists";
//           protected 
//             Types.FileType.Type fileType = Internal.stat(directoryName);
//           end existDirectory;
//           function assertCorrectIndex "Print error, if index to last essential character in directory is wrong"
//             input Integer index "Index must be > 0";
//             input String directoryName "Directory name for error message";
//           algorithm 
//             if index < 1 then 
//                         Streams.error("It is not possible to create the directory\n" + "\"" + directoryName + "\"\n" + "because this directory name is not valid");
// 
//             else 
//             end if;
//           end assertCorrectIndex;
//         end Local;
//         String fullName;
//         Integer index;
//         Integer oldIndex;
//         Integer lastIndex;
//         Boolean found;
//         Boolean finished;
//         Integer nDirectories = 0 "Number of directories that need to be generated";
//       algorithm 
//         if not Local.existDirectory(directoryName) then 
//                 fullName:=Files.fullPathName(directoryName);
//         index:=Strings.length(fullName);
//         if Strings.substring(fullName, index, index) == "/" then 
//                 index:=index - 1;
//         Local.assertCorrectIndex(index, fullName);
// 
//         else 
//         end if;
//         lastIndex:=index;
//         fullName:=Strings.substring(fullName, 1, index);
//         found:=false;
//         while (not found) loop
//                   oldIndex:=index;
//           index:=Strings.findLast(fullName, "/", startIndex = index);
//           if index == 0 then 
//                     index:=oldIndex;
//           found:=true;
// 
//           else           index:=index - 1;
//           Local.assertCorrectIndex(index, fullName);
//           found:=Local.existDirectory(Strings.substring(fullName, 1, index));
// 
//           end if;
// 
//         end while;
//         index:=oldIndex;
//         finished:=false;
//         while (not finished) loop
//                   Internal.mkdir(Strings.substring(fullName, 1, index));
// 
//         end while;
// 
//         else 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>createDirectory</b>(directoryName);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Creates directory \"directorName\". If this directory already exists,
// the function call is ignored. If several directories in \"directoryName\"
// do not exist, all of them are created. For example, assume
// that directory \"E:/test1\" exists and that directory
// \"E:/test1/test2/test3\" shall be created. In this case
// the directories \"test2\" in \"test1\" and \"test3\" in \"test2\"
// are created.
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// In case of error (e.g., \"directoryName\" is an existing regular
// file), an assert is triggered.
// </p>
// </html>"));
//       end createDirectory;
//       function exist "Inquire whether file or directory exists"
//         extends Modelica.Icons.Function;
//         input String name "Name of file or directory";
//         output Boolean result "= true, if file or directory exists";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         result:=Internal.stat(name) > Types.FileType.NoFile;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// result = Files.<b>exist</b>(name);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Returns true, if \"name\" is an existing file or directory.
// If this is not the case, the function returns false.
// </p>
// </html>"));
//       end exist;
//       function assertNew "Trigger an assert, if a file or directory exists"
//         extends Modelica.Icons.Function;
//         input String name "Name of file or directory";
//         input String message = "This is not allowed." "Message that should be printed after the default message in a new line";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Types.FileType.Type fileType = Internal.stat(name);
//       algorithm 
//         if fileType == Types.FileType.RegularFile then 
//                 Streams.error("File \"" + name + "\" already exists.\n" + message);
//         elseif fileType == Types.FileType.Directory then
//           Streams.error("Directory \"" + name + "\" already exists.\n" + message);
// 
//         elseif fileType == Types.FileType.SpecialFile then
//           Streams.error("A special file (pipe, device, etc.) \"" + name + "\" already exists.\n" + message);
// 
// 
//         else 
//         end if;
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Files.<b>assertNew</b>(name);
// Files.<b>assertNew</b>(name, message=\"This is not allowed\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Triggers an assert, if \"name\" is an existing file or
// directory. The error message has the following structure:
// </p>
// <pre>
//   File \"&lt;name&gt;\" already exists.
//   &lt;message&gt;
// </pre>
// </p>
// </html>"));
//       end assertNew;
//       function fullPathName "Get full path name of file or directory name"
//         extends Modelica.Icons.Function;
//         input String name "Absolute or relative file or directory name";
//         output String fullName "Full path of 'name'";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" fullName = ModelicaInternal_fullPathName(name) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// fullName = Files.<b>fullPathName</b>(name);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Returns the full path name of a file or directory \"name\".
// </p>
// </html>"));
//       end fullPathName;
//       function splitPathName "Split path name in directory, file name kernel, file name extension"
//         extends Modelica.Icons.Function;
//         input String pathName "Absolute or relative file or directory name";
//         output String directory "Name of the directory including a trailing '/'";
//         output String name "Name of the file without the extension";
//         output String extension "Extension of the file name. Starts with '.'";
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (directory, name, extension) = Files.<b>splitPathName</b>(pathName);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>splitPathName</b>(..) splits a path name into its parts.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <pre>
//   (directory, name, extension) = Files.splitPathName(\"C:/user/test/input.txt\")
//   
//   -> directory = \"C:/user/test/\"
//      name      = \"input\"
//      extension = \".txt\"
// </pre>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lenPath = Strings.length(pathName);
//         Integer i = lenPath;
//         Integer indexDot = 0;
//         Integer indexSlash = 0;
//         String c;
//       algorithm 
//         while (i >= 1) loop
//                   c:=Strings.substring(pathName, i, i);
// 
//         end while;
//       end splitPathName;
//       function temporaryFileName "Return arbitrary name of a file that does not exist and is in a directory where access rights allow to write to this file (useful for temporary output of files)"
//         extends Modelica.Icons.Function;
//         output String fileName "Full path name of temporary file";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" fileName = ModelicaInternal_temporaryFileName(0) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// fileName = Files.<b>temporaryFileName</b>();
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Return arbitrary name of a file that does not exist
// and is in a directory where access rights allow to 
// write to this file (useful for temporary output of files).
// </p>
// </html>"));
//       end temporaryFileName;
//     end Files;
//     package Streams "Read from files and write to files"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Library content</font></h3>
// <p>
// Package <b>Streams</b> contains functions to input and output strings
// to a message window or on files. Note that a string is interpreted 
// and displayed as html text (e.g., with print(..) or error(..))
// if it is enclosed with the Modelica html quotation, e.g.,
// </p>
// <center>
// string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\". 
// </center>
// <p>
// It is a quality of implementation, whether (a) all tags of html are supported
// or only a subset, (b) how html tags are interpreted if the output device
// does not allow to display formatted text.
// </p>
// <p>
// In the table below an example call to every function is given:
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Streams.print\">print</a>(string)<br>
//           <a href=\"Modelica:Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
//       <td> Print string \"string\" or vector of strings to message window or on
//            file \"fileName\".</td>
//   </tr>
//   <tr><td>stringVector = 
//          <a href=\"Modelica:Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
//       <td> Read complete text file and return it as a vector of strings.</td>
//   </tr>
//   <tr><td>(string, endOfFile) = 
//          <a href=\"Modelica:Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
//       <td>Returns from the file the content of line lineNumber.</td>
//   </tr>
//   <tr><td>lines = 
//          <a href=\"Modelica:Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
//       <td>Returns the number of lines in a file.</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Streams.error\">error</a>(string)</td>
//       <td> Print error message \"string\" to message window
//            and cancel all actions</td>
//   </tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
//       <td> Close file if it is still open. Ignore call if
//            file is already closed or does not exist. </td>
//   </tr>
// </table>
// <p>
// Use functions <b>scanXXX</b> from package 
// <a href=\"Modelica:Modelica.Utilities.Strings\">Strings</a>
// to parse a string.
// </p>
// <p>
// If Real, Integer or Boolean values shall be printed 
// or used in an error message, they have to be first converted
// to strings with the builtin operator 
// <a href=\"Modelica:ModelicaReference.Operators.string\">String</a>(...).
// Example:
// </p>
// <pre>
//   <b>if</b> x &lt; 0 <b>or</b> x &gt; 1 <b>then</b>
//      Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
//   <b>end if</b>;
// </pre>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function print "Print string to terminal or file"
//         extends Modelica.Icons.Function;
//         input String string = "" "String to be printed";
//         input String fileName = "" "File where to print (empty string is the terminal)";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_print(string,fileName) ;         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Streams.<b>print</b>(string);
// Streams.<b>print</b>(string,fileName);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>print</b>(..) opens automatically the given file, if
// it is not yet open. If the file does not exist, it is created.
// If the file does exist, the given string is appended to the file.
// If this is not desired, call \"Files.remove(fileName)\" before calling print
// (\"remove(..)\" is silent, if the file does not exist).
// The Modelica environment may close the file whenever appropriate.
// This can be enforced by calling <b>Streams.close</b>(fileName).
// After every call of \"print(..)\" a \"new line\" is printed automatically.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Streams.print(\"x = \" + String(x));
//   Streams.print(\"y = \" + String(y));
//   Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
// </pre></blockquote>
// <p>
// <h3><font color=\"#008000\">See also</font></h3>
// <p>
// <a href=\"Modelica:Modelica.Utilities.Streams\">Streams</a>,
// <a href=\"Modelica:Modelica.Utilities.Streams.error\">Streams.error</a>,
// <a href=\"Modelica:ModelicaReference.Operators.string\">String</a>
// </p>
// </HTML>"));
//       end print;
//       function readFile "Read content of a file and return it in a vector of strings"
//         extends Modelica.Icons.Function;
//         input String fileName "Name of the file that shall be read";
//         output String stringVector[countLines(fileName)] "Content of file";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// stringVector = Streams.<b>readFile</b>(fileName)
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>readFile</b>(..) opens the given file, reads the complete
// content, closes the file and returns the content as a vector of strings. Lines are separated by LF or CR-LF; the returned strings do not contain the line separators. 
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         for i in 1:size(stringVector, 1) loop
//                   stringVector[i]:=readLine(fileName, i);
// 
//         end for;
//         Streams.close(fileName);
//       end readFile;
//       function readLine "Reads a line of text from a file and returns it in a string"
//         extends Modelica.Icons.Function;
//         input String fileName "Name of the file that shall be read";
//         input Integer lineNumber(min = 1) "Number of line to read";
//         output String string "Line of text";
//         output Boolean endOfFile "If true, end-of-file was reached when trying to read line";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (string, endOfFile) = Streams.<b>readLine</b>(fileName, lineNumber)
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>readLine</b>(..) opens the given file, reads enough of the
// content to get the requested line, and returns the line as a string.
// Lines are separated by LF or CR-LF; the returned string does not 
// contain the line separator. The file might remain open after
// the call.
// </p>
// <p>
// If lineNumber > countLines(fileName), an empty string is returned 
// and endOfFile=true. Otherwise endOfFile=false.
// </p>
// </html>"));
//       end readLine;
//       function countLines "Returns the number of lines in a file"
//         extends Modelica.Icons.Function;
//         input String fileName "Name of the file that shall be read";
//         output Integer numberOfLines "Number of lines in file";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" numberOfLines = ModelicaInternal_countLines(fileName) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// numberOfLines = Streams.<b>countLines</b>(fileName)
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>countLines</b>(..) opens the given file, reads the complete
// content, closes the file and returns the number of lines. Lines are
// separated by LF or CR-LF.
// </p>
// </html>"));
//       end countLines;
//       function error "Print error message and cancel all actions"
//         extends Modelica.Icons.Function;
//         input String string "String to be printed to error message window";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaError(string) ;         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Streams.<b>error</b>(string);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Print the string \"string\" as error message and
// cancel all actions. Line breaks are characterized 
// by \"\\n\" in the string.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
// </pre></blockquote>
// <h3><font color=\"#008000\">See also</font></h3>
// <p>
// <a href=\"Modelica:Modelica.Utilities.Streams\">Streams</a>,
// <a href=\"Modelica:Modelica.Utilities.Streams.print\">Streams.print</a>,
// <a href=\"Modelica:ModelicaReference.Operators.string\">String</a>
// </p>
// </html>"));
//       end error;
//       function close "Close file"
//         extends Modelica.Icons.Function;
//         input String fileName "Name of the file that shall be closed";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaStreams_closeFile(fileName) ;         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Streams.<b>close</b>(fileName)
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Close file if it is open. Ignore call if
// file is already closed or does not exist.
// </p>
// </html>"));
//       end close;
//     end Streams;
//     package Strings "Operations on strings"
//       function length "Returns length of string"
//         extends Modelica.Icons.Function;
//         input String string;
//         output Integer result "Number of characters of string";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" result = ModelicaStrings_length(string) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>length</b>(string);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Returns the number of characters of \"string\".
// </p>
// </html>"));
//       end length;
//       function substring "Returns a substring defined by start and end index"
//         extends Modelica.Icons.Function;
//         input String string "String from which a substring is inquired";
//         input Integer startIndex(min = 1) "Character position of substring begin (index=1 is first character in string)";
//         input Integer endIndex(min = 1) "Character position of substring end";
//         output String result "String containing substring string[startIndex:endIndex]";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" result = ModelicaStrings_substring(string,startIndex,endIndex) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// string2 = Strings.<b>substring</b>(string, startIndex, endIndex);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// This function returns
// the substring from position startIndex
// up to and including position endIndex of \"string\" .
// </p>
// <p>
// If index, startIndex, or endIndex are not correct, e.g.,
// if endIndex &gt; length(string), an assert is triggered.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   string1 := \"This is line 111\";
//   string2 := Strings.substring(string1,9,12); // string2 = \"line\"
// </pre></blockquote>
// </html>"));
//       end substring;
//       function repeat "Repeat a string n times"
//         extends Modelica.Icons.Function;
//         input Integer n(min = 0) = 1 "Number of occurences";
//         input String string = " " "String that is repeated";
//         output String repeatedString "String containing n concatenated strings";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// string2 = Strings.<b>repeat</b>(n);
// string2 = Strings.<b>repeat</b>(n, string=\" \");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// The first form returns a string consisting of n blanks.
// </p>
// <p>
// The second form returns a string consisting of n substrings
// defined by the optional argument \"string\".
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         repeatedString:="";
//         for i in 1:n loop
//                   repeatedString:=repeatedString + string;
// 
//         end for;
//       end repeat;
//       function compare "Compare two strings lexicographically"
//         extends Modelica.Icons.Function;
//         input String string1;
//         input String string2;
//         input Boolean caseSensitive = true "= false, if case of letters is ignored";
//         output Modelica.Utilities.Types.Compare.Type result "Result of comparison";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" result = ModelicaStrings_compare(string1,string2,caseSensitive) ;        annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// result = Strings.<b>compare</b>(string1, string2);
// result = Strings.<b>compare</b>(string1, string2, caseSensitive=true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Compares two strings. If the optional argument caseSensitive=false,
// upper case letters are treated as if they would be lower case letters.
// The result of the comparison is returned as:
// </p>
// <pre>
//   result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
//          = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
//          = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
// </pre>
// <p>
// Comparison is with regards to lexicographical order,
// e.g., \"a\" &lt; \"b\";
// </p>
// </html>"));
//       end compare;
//       function isEqual "Determine whether two strings are identical"
//         extends Modelica.Icons.Function;
//         input String string1;
//         input String string2;
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored for the comparison";
//         output Boolean identical "True, if string1 is identical to string2";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>isEqual</b>(string1, string2);
// Strings.<b>isEqual</b>(string1, string2, caseSensitive=true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Compare whether two strings are identical,
// optionally ignoring case.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         identical:=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
//       end isEqual;
//       extends Modelica.Icons.Library;
//       annotation(version = "1.0", versionDate = "2004-10-01", preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Library content</font></h3>
// <p>
// Package <b>Strings</b> contains functions to manipulate strings.
// </p>
// <p>
// In the table below an example
// call to every function is given using the <b>default</b> options.
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><th><b><i>Function</i></b></th><th><b><i>Description</i></b></th></tr>
//   <tr><td>len = <a href=\"Modelica:Modelica.Utilities.Strings.length\">length</a>(string)</td>
//       <td>Returns length of string</td></tr>
//   <tr><td>string2 = <a href=\"Modelica:Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
//        </td>
//       <td>Returns a substring defined by start and end index</td></tr>
//   <tr><td>result = <a href=\"Modelica:Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
//  result = <a href=\"Modelica:Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
//       <td>Repeat a blank or a string n times.</td></tr>
//   <tr><td>result = <a href=\"Modelica:Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
//       <td>Compares two substrings with regards to alphabetical order</td></tr>
//   <tr><td>identical =
// <a href=\"Modelica:Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
//       <td>Determine whether two strings are identical</td></tr>
//   <tr><td>result = <a href=\"Modelica:Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
//       <td>Count the number of occurrences of a string</td></tr>
//   <tr>
// <td>index = <a href=\"Modelica:Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
//       <td>Find first occurrence of a string in another string</td></tr>
// <tr>
// <td>index = <a href=\"Modelica:Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
//       <td>Find last occurrence of a string in another string</td></tr>
//   <tr><td>string2 = <a href=\"Modelica:Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
//       <td>Replace one or all occurrences of a string</td></tr>
//   <tr><td>stringVector2 = <a href=\"Modelica:Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
//       <td>Sort vector of strings in alphabetic order</td></tr>
//   <tr><td>(token, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
//       <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
//   <tr><td>(number, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
//       <td>Scan for a Real constant</td></tr>
//   <tr><td>(number, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
//       <td>Scan for an Integer constant</td></tr>
//   <tr><td>(boolean, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
//       <td>Scan for a Boolean constant</td></tr>
//   <tr><td>(string2, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
//       <td>Scan for a String constant</td></tr>
//   <tr><td>(identifier, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
//       <td>Scan for an identifier</td></tr>
//   <tr><td>(delimiter, index) = <a href=\"Modelica:Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
//       <td>Scan for delimiters</td></tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
//       <td>Check that remaining part of string consists solely of <br>
//           white space or line comments (\"// ...\\n\").</td></tr>
//   <tr><td><a href=\"Modelica:Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
//       <td> Print a \"syntax error message\" as well as a string and the <br>
//            index at which scanning detected an error</td></tr>
// </table>
// <p>
// The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
// have the optional
// input argument <b>caseSensitive</b> with default <b>true</b>.
// If <b>false</b>, the operation is carried out without taking
// into account whether a character is upper or lower case.
// </p>
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function count "Count the number of non-overlapping occurrences of a string"
//         extends Modelica.Icons.Function;
//         input String string "String that is analyzed";
//         input String searchString "String that is searched for in string";
//         input Integer startIndex(min = 1) = 1 "Start search at index startIndex";
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored for count";
//         output Integer result "Number of occurrences of 'searchString' in 'string'";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>count</b>(string, searchString)
// Strings.<b>count</b>(string, searchString, startIndex=1,
//                      caseSensitive=true)
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Returns the number of non-overlapping occurrences of string \"searchString\"
// in \"string\". The search is started at index \"startIndex\" (default = 1).
// If the optional argument \"caseSensitive\" is false,
// for the counting it does not matter whether a letter is upper
// or lower case.
// /p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lenSearchString = length(searchString);
//         Integer i = startIndex;
//       algorithm 
//         result:=0;
//         while (i <> 0) loop
//                   i:=find(string, searchString, i, caseSensitive);
//           if i > 0 then 
//                     result:=result + 1;
//           i:=i + lenSearchString;
// 
//           else 
//           end if;
// 
//         end while;
//       end count;
//       function find "Find first occurrence of a string within another string"
//         extends Modelica.Icons.Function;
//         input String string "String that is analyzed";
//         input String searchString "String that is searched for in string";
//         input Integer startIndex(min = 1) = 1 "Start search at index startIndex";
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored for the search";
//         output Integer index "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// index = Strings.<b>find</b>(string, searchString);
// index = Strings.<b>find</b>(string, searchString, startIndex=1,
//                      caseSensitive=true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Finds first occurence of \"searchString\" within \"string\"
// and return the corresponding index.
// Start search at index \"startIndex\" (default = 1).
// If the optional argument \"caseSensitive\" is false, lower
// and upper case are ignored for the search.
// If \"searchString\" is not found, a value of \"0\" is returned.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lengthSearchString = length(searchString);
//         Integer len = lengthSearchString - 1;
//         Integer i = startIndex;
//         Integer i_max = length(string) - lengthSearchString + 1;
//       algorithm 
//         index:=0;
//         while (i <= i_max) loop
//                   if isEqual(substring(string, i, i + len), searchString, caseSensitive) then 
//                     index:=i;
//           i:=i_max + 1;
// 
//           else           i:=i + 1;
// 
//           end if;
// 
//         end while;
//       end find;
//       function findLast "Find last occurrence of a string within another string"
//         extends Modelica.Icons.Function;
//         input String string "String that is analyzed";
//         input String searchString "String that is searched for in string";
//         input Integer startIndex(min = 0) = 0 "Start search at index startIndex. If startIndex = 0, start at length(string)";
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored for the search";
//         output Integer index "Index of the beginning of the last occurrence of 'searchString' within 'string', or zero if not present";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// index = Strings.<b>findLast</b>(string, searchString);
// index = Strings.<b>findLast</b>(string, searchString,
//                          startIndex=length(string), caseSensitive=true,
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Finds first occurence of \"searchString\" within \"string\"
// when searching from the last character of \"string\"
// backwards, and return the corresponding index.
// Start search at index \"startIndex\" (default = length(string)).
// If the optional argument \"caseSensitive\" is false, lower
// and upper case are ignored for the search.
// If \"searchString\" is not found, a value of \"0\" is returned.
// </p>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lenString = length(string);
//         Integer lenSearchString = length(searchString);
//         Integer i;
//       algorithm 
//         i:=if startIndex == 0 then lenString - lenSearchString + 1 else startIndex;
//         index:=0;
//         while (i >= 1) loop
//                   if isEqual(substring(string, i, i + lenSearchString - 1), searchString, caseSensitive) then 
//                     index:=i;
//           i:=0;
// 
//           else           i:=i - 1;
// 
//           end if;
// 
//         end while;
//       end findLast;
//       function replace "Replace non-overlapping occurrences of a string from left to right"
//         extends Modelica.Icons.Function;
//         input String string "String to be modified";
//         input String searchString "Replace non-overlapping occurrences of 'searchString' in 'string' with 'replaceString'";
//         input String replaceString "String that replaces 'searchString' in 'string'";
//         input Integer startIndex = 1 "Start search at index startIndex";
//         input Boolean replaceAll = true "if false, replace only the first occurrence, otherwise all occurrences";
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored when searching for searchString";
//         output String result "Resultant string of replacement operation";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>replace</b>(string, searchString, replaceString);
// Strings.<b>replace</b>(string, searchString, replaceString,
//                 startIndex=1, replaceAll=true, caseSensitive=true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Search in \"string\" for \"searchString\" and replace the found
// substring by \"replaceString\".
// <p>
// <ul>
// <li> The search starts at the first character of \"string\",
//      or at character position \"startIndex\",
//      if this optional argument is provided.</li>
// <li> If the optional argument \"replaceAll\" is <b>true</b> (default),
//      all occurrences of \"searchString\" are replaced.
//      If the argument is <b>false</b>, only the first occurrence
//      is replaced. </li>
// <li> The search for \"searchString\" distinguishes upper and lower
//      case letters. If the optional argument \"caseSensitive\" is
//      <b>false</b>,
//      the search ignores whether letters are upper
//      or lower case. </li>
// </ul>
// <p>
// The function returns the \"string\" with the
// performed replacements.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lenString = length(string);
//         Integer lenSearchString = length(searchString);
//         Integer i = startIndex;
//         Integer i_found;
//       algorithm 
//         result:=if startIndex == 1 then "" else substring(string, 1, startIndex - 1);
//         while (i > 0) loop
//                   i_found:=find(string, searchString, i, caseSensitive);
// 
//         end while;
//       end replace;
//       function sort "Sort vector of strings in alphabetic order"
//         extends Modelica.Icons.Function;
//         input String stringVector1[:] "vector of strings";
//         input Boolean caseSensitive = true "= false, if lower and upper case are ignored when comparing elements of stringVector1";
//         output String stringVector2[size(stringVector1, 1)] "string1 sorted in alphabetical order";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer gap;
//         Integer i;
//         Integer j;
//         String tempString;
//         Integer nStringVector1 = size(stringVector1, 1);
//         Boolean swap;
//       algorithm 
//         stringVector2:=stringVector1;
//         gap:=div(nStringVector1, 2);
//         while (gap > 0) loop
//                   i:=gap;
//           while (i < nStringVector1) loop
//                       j:=i - gap;
//             if j >= 0 then 
//                         swap:=compare(stringVector2[j + 1], stringVector2[j + gap + 1], caseSensitive) == Modelica.Utilities.Types.Compare.Greater;
// 
//             else             swap:=false;
// 
//             end if;
//             while (swap) loop
//                           tempString:=stringVector2[j + 1];
//               stringVector2[j + 1]:=stringVector2[j + gap + 1];
//               stringVector2[j + gap + 1]:=tempString;
//               j:=j - gap;
//               if j >= 0 then 
//                             swap:=compare(stringVector2[j + 1], stringVector2[j + gap + 1], caseSensitive) == Modelica.Utilities.Types.Compare.Greater;
// 
//               else               swap:=false;
// 
//               end if;
// 
//             end while;
//             i:=i + 1;
// 
//           end while;
//           gap:=div(gap, 2);
// 
//         end while;
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// stringVector2 = Streams.<b>sort</b>(stringVector1);
// stringVector2 = Streams.<b>sort</b>(stringVector1, caseSensitive=true);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>sort</b>(..) sorts a string vector stringVector1
// in lexicographical order and returns the result in stringVector2.
// If the optional argument \"caseSensitive\" is <b>false</b>, lower
// and upper case letters are not distinguished.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   s1 = {\"force\", \"angle\", \"pressure\"};
//   s2 = Strings.sort(s1);
//        -> s2 = {\"angle\", \"force\", \"pressure\"};
// </pre></blockquote>
// </HTML>"));
//       end sort;
//       function scanToken "Scan for the next token and return it"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input Boolean unsigned = false "= true, if Real and Integer tokens shall not start with a sign";
//         output Types.TokenValue token "Scanned token";
//         output Integer nextIndex "Index of character after the found token; = 0, if NoToken";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (token, nextIndex) = Strings.<b>scanToken</b>(string, startIndex, unsigned=false);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanToken</b> scans the string starting at index
// \"startIndex\" and returns the next token, as well as the
// index directly after the token. The returned token is a record
// that holds the type of the token and the value of the token:
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td>token.tokenType</td>
//       <td>Type of the token, see below</td></tr>
//   <tr><td>token.real</td>
//       <td>Real value if tokenType == TokenType.RealToken</td></tr>
//   <tr><td>token.integer</td>
//       <td>Integer value if tokenType == TokenType.IntegerToken</td></tr>
//   <tr><td>token.boolean</td>
//       <td>Boolean value if tokenType == TokenType.BooleanToken</td></tr>
//   <tr><td>token.string</td>
//       <td>String value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken</td></tr>
// </table>
// <p>
// Variable token.tokenType is an enumeration (emulated as a package
// with constants) that can have the following values:
// </p>
// <pre>
//    import T = Modelica.Utilities.Types.TokenType;
// </pre>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td>T.RealToken</td>
//       <td>Modelica Real literal (e.g., 1.23e-4)</td></tr>
//   <tr><td>T.IntegerToken</td>
//       <td>Modelica Integer literal (e.g., 123)</td></tr>
//   <tr><td>T.BooleanToken</td>
//       <td>Modelica Boolean literal (e.g., false)</td></tr>
//   <tr><td>T.StringToken</td>
//       <td>Modelica String literal (e.g., \"string 123\")</td></tr>
//   <tr><td>T.IdentifierToken</td>
//       <td>Modelica identifier (e.g., \"force_a\")</td></tr>
//   <tr><td>T.DelimiterToken</td>
//       <td>any character without white space that does not appear<br>
//           as first character in the tokens above (e.g., \"&\")</td></tr>
//   <tr><td>T.NoToken</td>
//       <td>White space, line comments and no other token<br>
//           until the end of the string</td></tr>
// </table>
// <p>
// Modelica line comments (\"// ... end-of-line/end-of-string\")
// as well as white space is ignored.
// If \"unsigned=true\", a Real or Integer literal
// is not allowed to start with a \"+\" or \"-\" sign.
// </p>
// <h3><font color=\"#008000\">Example</font></h3>
// <blockquote><pre>
//   import Modelica.Utilities.Strings.*;
//   import T = Modelica.Utilities.Types.TokenType;
//   (token, index) := scanToken(string);
//   <b>if</b> token.tokenType == T.RealToken <b>then</b>
//      realValue := token.real;
//   <b>elseif</b> token.tokenType == T.IntegerToken <b>then</b>
//      integerValue := token.integer;
//   <b>elseif</b> token.tokenType == T.BooleanToken<b> then</b>
//      booleanValue := token.boolean;
//   <b>elseif</b> token.tokenType == T.Identifier <b>then</b>
//      name := token.string;
//   <b>else</b>
//      syntaxError(string,index,\"Expected Real, Integer, Boolean or identifier token\");
//   <b>end if</b>;
// </pre></blockquote>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer startTokenIndex;
//       algorithm 
//         token.real:=0.0;
//         token.integer:=0;
//         token.boolean:=false;
//         token.string:="";
//         startTokenIndex:=Advanced.skipLineComments(string, startIndex);
//         if startTokenIndex > length(string) then 
//                 token.tokenType:=Types.TokenType.NoToken;
//         nextIndex:=startTokenIndex;
// 
//         else         (nextIndex,token.integer):=Advanced.scanInteger(string, startTokenIndex, unsigned);
//         token.tokenType:=Types.TokenType.IntegerToken;
//         if nextIndex == startTokenIndex then 
//                 (nextIndex,token.real):=Advanced.scanReal(string, startTokenIndex, unsigned);
//         token.tokenType:=Types.TokenType.RealToken;
// 
//         else 
//         end if;
//         if nextIndex == startTokenIndex then 
//                 (nextIndex,token.string):=Advanced.scanString(string, startTokenIndex);
//         token.tokenType:=Types.TokenType.StringToken;
// 
//         else 
//         end if;
//         if nextIndex == startTokenIndex then 
//                 (nextIndex,token.string):=Advanced.scanIdentifier(string, startTokenIndex);
//         if nextIndex > startTokenIndex then 
//         
//         else 
//         end if;
// 
//         else 
//         end if;
//         if nextIndex == startTokenIndex then 
//                 token.string:=substring(string, startTokenIndex, startTokenIndex);
//         token.tokenType:=Types.TokenType.DelimiterToken;
//         nextIndex:=startTokenIndex + 1;
// 
//         else 
//         end if;
// 
//         end if;
//       end scanToken;
//       function scanReal "Scan for the next Real number and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input Boolean unsigned = false "= true, if Real token shall not start with a sign";
//         input String message = "" "Message used in error message if scan is not successful";
//         output Real number "Value of real number";
//         output Integer nextIndex "index of character after the found number";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              number = Strings.<b>scanReal</b>(string);
// (number, nextIndex) = Strings.<b>scanReal</b>(string, startIndex=1,
//                                             unsigned=false, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// The first form, \"scanReal(string)\", scans \"string\" for a
// Real number with leading white space and returns the value.
// </p>
// <p>
// The second form, \"scanReal(string,startIndex,unsigned)\",
// scans the string starting at index
// \"startIndex\", checks whether the next token is a Real literal
// and returns its value as a Real number, as well as the
// index directly after the Real number.
// If the optional argument \"unsigned\" is <b>true</b>,
// the real number shall not have a leading \"+\" or \"-\" sign.
// </p>
// <p>
// If the required Real number with leading white space
// is not present in \"string\",  an assert is triggered.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         (nextIndex,number):=Advanced.scanReal(string, startIndex, unsigned);
//         if nextIndex == startIndex then 
//                 nextIndex:=Advanced.skipWhiteSpace(string, startIndex);
//         if unsigned then 
//                 syntaxError(string, nextIndex, "Expected a Real number without a sign " + message);
// 
//         else         syntaxError(string, nextIndex, "Expected a Real number " + message);
// 
//         end if;
// 
//         else 
//         end if;
//       end scanReal;
//       function scanInteger "Scan for the next Integer number and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input Boolean unsigned = false "= true, if Integer token shall not start with a sign";
//         input String message = "" "Message used in error message if scan is not successful";
//         output Integer number "Value of Integer number";
//         output Integer nextIndex "Index of character after the found number";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              number = Strings.<b>scanInteger</b>(string);
// (number, nextIndex) = Strings.<b>scanInteger</b>(string, startIndex=1,
//                                                unsigned=false, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanInteger</b> scans the string starting at index
// \"startIndex\", checks whether the next token is an Integer literal
// and returns its value as an Integer number, as well as the
// index directly after the Integer number. An assert is triggered,
// if the scanned string does not contain an Integer literal with optional
// leading white space.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         (nextIndex,number):=Advanced.scanInteger(string, startIndex, unsigned);
//         if nextIndex == startIndex then 
//                 nextIndex:=Advanced.skipWhiteSpace(string, startIndex);
//         if unsigned then 
//                 syntaxError(string, nextIndex, "Expected an Integer number without a sign " + message);
// 
//         else         syntaxError(string, nextIndex, "Expected an Integer number " + message);
// 
//         end if;
// 
//         else 
//         end if;
//       end scanInteger;
//       function scanBoolean "Scan for the next Boolean number and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input String message = "" "Message used in error message if scan is not successful";
//         output Boolean number "Value of Boolean";
//         output Integer nextIndex "Index of character after the found number";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              number = Strings.<b>scanBoolean</b>(string);
// (number, nextIndex) = Strings.<b>scanBoolean</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanBoolean</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a Boolean literal
// (i.e., is either the string \"false\" or \"true\", if converted to lower case letters)
// and returns its value as a Boolean number, as well as the
// index directly after the Boolean number. An assert is triggered,
// if the scanned string does not contain a Boolean literal with optional
// leading white space.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         String identifier;
//       algorithm 
//         (nextIndex,identifier):=Advanced.scanIdentifier(string, startIndex);
//         if nextIndex > startIndex then 
//         
//         else 
//         end if;
//         if nextIndex == startIndex then 
//                 nextIndex:=Advanced.skipWhiteSpace(string, startIndex);
//         syntaxError(string, nextIndex, "Expected a Boolean constant, i.e., \"false\" or \"true\" " + message);
// 
//         else 
//         end if;
//       end scanBoolean;
//       function scanString "Scan for the next Modelica string and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input String message = "" "Message used in error message if scan is not successful";
//         output String result "Value of string";
//         output Integer nextIndex "Index of character after the found string";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              string2 = Strings.<b>scanString</b>(string);
// (string2, nextIndex) = Strings.<b>scanString</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanString</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a String literal
// and returns its value as a String, as well as the
// index directly after the String. An assert is triggered,
// if the scanned string does not contain a String literal with optional
// leading white space.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         (nextIndex,result):=Advanced.scanString(string, startIndex);
//         if nextIndex == startIndex then 
//                 nextIndex:=Advanced.skipWhiteSpace(string, startIndex);
//         syntaxError(string, nextIndex, "Expected a string enclosed in double quotes " + message);
// 
//         else 
//         end if;
//       end scanString;
//       function scanIdentifier "Scan for the next Identifier and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of identifier at character startIndex";
//         input String message = "" "Message used in error message if scan is not successful";
//         output String identifier "Value of Identifier";
//         output Integer nextIndex "Index of character after the found identifier";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              identifier = Strings.<b>scanIdentifier</b>(string);
// (identifier, nextIndex) = Strings.<b>scanIdentifier</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanIdentifier</b> scans the string starting at index
// \"startIndex\", checks whether the next token is an Identifier
// and returns its value as a string, as well as the
// index directly after the Identifier. An assert is triggered,
// if the scanned string does not contain an Identifier with optional
// leading white space.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         (nextIndex,identifier):=Advanced.scanIdentifier(string, startIndex);
//         if nextIndex == startIndex then 
//                 nextIndex:=Advanced.skipWhiteSpace(string, startIndex);
//         syntaxError(string, nextIndex, "Expected an identifier " + message);
// 
//         else 
//         end if;
//       end scanIdentifier;
//       function scanDelimiter "Scan for the next delimiter and trigger an assert if not present"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of delimiters at character startIndex";
//         input String requiredDelimiters[:] = {","} "Delimiters that are searched";
//         input String message = "" "Message used in error message if scan is not successful";
//         output String delimiter "Found delimiter";
//         output Integer nextIndex "Index of character after the found delimiter";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
//              delimiter = Strings.<b>scanDelimiter</b>(string);
// (delimiter, nextIndex) = Strings.<b>scanDelimiter</b>(string, startIndex=1,
//                                  requiredDelimiters={\",\"}, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanDelimiter</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a delimiter string
// and returns its value as a string, as well as the
// index directly after the delimiter. An assert is triggered,
// if the scanned string does not contain a delimiter out of the
// list of requiredDelimiters. Input argument requiredDelimiters is a vector
// of strings. The elements may have any length, including length 0.
// If an element of the requiredDelimiters is zero, white space
// is treated as delimiter. The function returns delimiter=\"\" and nextIndex
// is the index of the first non white space character.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer lenString = length(string);
//         Integer lenDelimiter;
//         Integer nDelimiters = size(requiredDelimiters, 1);
//         Integer endIndex;
//         Boolean found;
//         Integer i;
//         encapsulated function concatenate "Concatenate strings together"
//           input String strings[:];
//           output String string;
//         algorithm 
//           string:="{\"";
//           for i in 1:size(strings, 1) loop
//                       if i == 1 then 
//                         string:="{\"" + strings[1] + "\"";
// 
//             else             string:=string + ", \"" + strings[i] + "\"";
// 
//             end if;
// 
//           end for;
//           string:=string + "}";
//         end concatenate;
//       algorithm 
//         nextIndex:=Advanced.skipLineComments(string, startIndex);
//         found:=false;
//         i:=1;
//         while (not found and i <= nDelimiters) loop
//                   lenDelimiter:=length(requiredDelimiters[i]);
//           if lenDelimiter == 0 then 
//                     found:=true;
//           delimiter:="";
// 
//           else           endIndex:=nextIndex + lenDelimiter - 1;
//           if endIndex <= lenString then 
//                     if substring(string, nextIndex, endIndex) == requiredDelimiters[i] then 
//                     found:=true;
//           delimiter:=requiredDelimiters[i];
// 
//           else 
//           end if;
// 
//           else 
//           end if;
//           i:=i + 1;
// 
//           end if;
// 
//         end while;
//         if found then 
//                 nextIndex:=nextIndex + lenDelimiter;
// 
//         else         if size(requiredDelimiters, 1) == 1 then 
//                 syntaxError(string, nextIndex, "Expected delimiter \"" + requiredDelimiters[1] + "\"\n" + message);
// 
//         else         syntaxError(string, nextIndex, "Expected a delimiter out of " + concatenate(requiredDelimiters) + "\n" + message);
// 
//         end if;
// 
//         end if;
//       end scanDelimiter;
//       function scanNoToken "Scan string and check that it contains no more token"
//         extends Modelica.Icons.Function;
//         input String string "String to be scanned";
//         input Integer startIndex(min = 1) = 1 "Start scanning of string at character startIndex";
//         input String message = "" "Message used in error message if scan is not successful";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>scanNoToken</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>scanNoToken</b> scans the string starting at index
// \"startIndex\" and checks whether there is no more token in the
// string. An assert is triggered if this is not the case,
// using the \"message\" argument as additional explanation in
// the error text.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer nextIndex;
//       algorithm 
//         nextIndex:=Advanced.skipLineComments(string, startIndex);
//         if nextIndex <= length(string) then 
//                 syntaxError(string, nextIndex, "Expected no more token " + message);
// 
//         else 
//         end if;
//       end scanNoToken;
//       function syntaxError "Print an error message, a string and the index at which scanning detected an error"
//         extends Modelica.Icons.Function;
//         input String string "String that has an error at position index";
//         input Integer index "Index of string at which scanning detected an error";
//         input String message = "" "String printed at end of error message";
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// Strings.<b>syntaxError</b>(string, index, message);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Function <b>syntaxError</b> prints an error message in the
// following form:
// </p>
// <pre>
//    Syntax error at column &lt;index&gt; of
//    &lt;string&gt;
//        ^       // shows character that is wrong
//    &lt;message&gt;
// </pre>
// <p>
// where the strings withing &lt;..&gt; are the actual values of the
// input arguments of the function.
// </p>
// <p>
// If the given string is too long, only a relevant
// part of the string is printed.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       protected 
//         Integer maxIndex = 40;
//         Integer maxLenString = 60;
//         Integer lenString = length(string);
//         String errString;
//         Integer index2 = if index < 1 then 1 else if index > lenString then lenString else index;
//       algorithm 
//         if index2 <= maxIndex then 
//                 errString:=string;
// 
//         else         errString:="... " + substring(string, index2 - maxIndex, lenString);
//         index2:=maxIndex + 5;
// 
//         end if;
//         if length(errString) > maxLenString then 
//                 errString:=substring(errString, 1, maxLenString) + " ...";
// 
//         else 
//         end if;
//         Streams.error("Syntax error at character " + String(index) + " of\n" + errString + "\n" + repeat(index2 - 1, " ") + "*" + "\n" + message);
//       end syntaxError;
//       package Advanced "Advanced scanning functions"
//         annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Library content</font></h3>
// <p>
// Package <b>Strings.Advanced</b> contains basic scanning
// functions. These functions should be <b>not called</b> directly, because
// it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
// The functions of the \"Strings.Advanced\" library provide
// the basic interface in order to implement the higher level
// functions in package \"Strings\".
// </p>
// <p>
// Library \"Advanced\" provides the following functions:
// </p>
// <pre>
//   (nextIndex, realNumber)    = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
//   (nextIndex, integerNumber) = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
//   (nextIndex, string2)       = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
//   (nextIndex, identifier)    = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
//    nextIndex                 = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
//    nextIndex                 = <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
// </pre>
// <p>
// All functions perform the following actions:
// </p>
// <ol>
// <li> Scanning starts at character position \"startIndex\" of
//      \"string\" (startIndex has a default of 1).
// <li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
// <li> Afterwards, the required token is scanned.</li>
// <li> If successful, on return nextIndex = index of character
//      directly after the found token and the token value is returned
//      as second output argument.<br>
//      If not successful, on return nextIndex = startIndex.
//      </li>
// </ol>
// <p>
// The following additional rules apply for the scanning:
// </p>
// <ul>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
//      Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
//      according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
//      Real numbers, but \".1\" is not.
//      Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
//      Scans an Integer number including one optional leading \"+\"
//      or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
//      For example, \"+123\", \"20\" are Integer numbers.
//      Note, a Real number, such as \"123.4\" is not an Integer and
//      scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
//      Scans a String according to the Modelica (and C/C++) grammar, e.g.,
//      \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
//      Scans a Modelica identifier, i.e., the identifier starts either
//      with a letter, followed by letters, digits or \"_\".
//      For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
// <li> Function <a href=\"Modelica:Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
//      Skips white space and Modelica (C/C++) line comments iteratively.
//      A line comment starts with \"//\" and ends either with an
//      end-of-line (\"\\n\") or the end of the \"string\". </li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         function scanReal "Scans a signed real number"
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1 "Index where scanning starts";
//           input Boolean unsigned = false "= true, if number shall not start with '+' or '-'";
//           output Integer nextIndex "Index after the found token (success=true) or index at which scanning failed (success=false)";
//           output Real number "Value of Real number";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           external "C" ModelicaStrings_scanReal(string,startIndex,unsigned,nextIndex,number) ;           annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (nextIndex, realNumber) = <b>scanReal</b>(string, startIndex=1, unsigned=false);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a number
// of type Real with an optional sign according to the Modelica grammar:
// </p>
// <pre>
//     real     ::= [sign] unsigned [fraction] [exponent]
//     sign     ::= '+' | '-'
//     unsigned ::= digit [unsigned]
//     fraction ::= '.' [unsigned]
//     exponent ::= ('e' | 'E') [sign] unsigned
//     digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
// </pre>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found real number, as well as the value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is zero.
// </p>
// <p>
// If the optional argument \"unsigned\" is <b>true</b>, the number
// shall not start with '+' or '-'. The default of \"unsigned\" is <b>false</b>.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "));
//         end scanReal;
//         function scanInteger "Scans signed integer number"
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1;
//           input Boolean unsigned = false "= true, if number shall not start with '+' or '-'";
//           output Integer nextIndex "Index after the found token (success=true) or index at which scanning failed (success=false)";
//           output Integer number "Value of Integer number";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           external "C" ModelicaStrings_scanInteger(string,startIndex,unsigned,nextIndex,number) ;           annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (nextIndex, integerNumber) = <b>scanInteger</b>(string, startIndex=1, unsigned=false);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a signed number
// of type Integer. An Integer starts with an optional '+'
// or '-', immediately
// followed by a non-empty sequence of digits.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found Integer number, as well as the Integer value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is zero.
// </p>
// <p>
// Note, a Real number, such as \"123.4\", is not treated
// as an Integer number and scanInteger will return
// nextIndex = startIndex in this case.
// </p>
// <p>
// If the optional argument \"unsigned\" is <b>true</b>, the number
// shall not start with '+' or '-'. The default of \"unsigned\" is <b>false</b>.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "));
//         end scanInteger;
//         function scanString
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1 "Index where scanning starts";
//           output Integer nextIndex "Index after the found token (success=true) or index at which scanning failed (success=false)";
//           output String string2 "Value of String token";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           external "C" ModelicaStrings_scanString(string,startIndex,nextIndex,string2) ;           annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (nextIndex, string2) = <b>scanString</b>(string, startIndex=1);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a string
// according to the Modelica grammar, i.e., a string
// enclosed in double quotes.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found string, as well as the string value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is an empty string.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "));
//         end scanString;
//         function scanIdentifier "Scans simple identifiers"
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1 "Index where scanning starts";
//           output Integer nextIndex "Index after the found token (success=true) or index at which scanning failed (success=false)";
//           output String identifier "Value of identifier token";
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           external "C" ModelicaStrings_scanIdentifier(string,startIndex,nextIndex,identifier) ;           annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// (nextIndex, identifier) = <b>scanIdentifier</b>(string, startIndex=1);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a Modelica
// identifier, i.e., a sequence of characters starting with
// a letter (\"a\"..\"z\" or \"A\"..\"Z\") followed by letters,
// digits or underscores (\"_\").
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found identifier, as well as the identifier
// as string in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is an empty string.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "));
//         end scanIdentifier;
//         function skipWhiteSpace "Scans white space"
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1;
//           output Integer nextIndex;
//           annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//           external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string,startIndex) ;          annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// nextIndex = <b>skipWhiteSpace</b>(string, startIndex);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\" and
// skips white space. The function returns nextIndex = index of character
// of the first non white space character.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "));
//         end skipWhiteSpace;
//         function skipLineComments "Scans comments and white space"
//           extends Modelica.Icons.Function;
//           input String string;
//           input Integer startIndex(min = 1) = 1;
//           output Integer nextIndex;
//           annotation(preferedView = "info", Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// nextIndex = <b>skipLineComments</b>(string, startIndex);
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a Modelica (C/C++)
// line comment, i.e., a sequence of characters that
// starts with \"//\" and ends with an end-of-line \"\\n\" or
// with the end of the string. If end-of-line is reached,
// the function continues to skip white space and
// scanning of line comments until end-of-string is
// reached, or another token is detected.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found line comment.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex.
// </p>
// <h3><font color=\"#008000\">See also</font></h3>
// <a href=\"Modelica:Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         protected 
//           Integer lenString = length(string);
//           Boolean scanning;
//           Boolean lineComment;
//         algorithm 
//           nextIndex:=startIndex;
//           scanning:=true;
//           while (scanning) loop
//                       nextIndex:=Advanced.skipWhiteSpace(string, nextIndex);
//             if nextIndex + 1 <= lenString then 
//                         if substring(string, nextIndex, nextIndex + 1) == "//" then 
//                         nextIndex:=nextIndex + 2;
//             if nextIndex <= lenString then 
//                         lineComment:=true;
//             while (lineComment) loop
//                           if substring(string, nextIndex, nextIndex) == "\n" then 
//                             lineComment:=false;
// 
//               else 
//               end if;
//               nextIndex:=nextIndex + 1;
//               if nextIndex > lenString then 
//                             lineComment:=false;
//               scanning:=false;
// 
//               else 
//               end if;
// 
//             end while;
// 
//             else             scanning:=false;
// 
//             end if;
// 
//             else             scanning:=false;
// 
//             end if;
// 
//             else             scanning:=false;
// 
//             end if;
// 
//           end while;
//         end skipLineComments;
//       end Advanced;
//     end Strings;
//     package System "Interaction with environment"
//       extends Modelica.Icons.Library;
//       annotation(preferedView = "info", Documentation(info = "
// <HTML>
// <p>
// This package contains functions to interact with the environment.
// </p>
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       function getWorkDirectory "Get full path name of work directory"
//         extends Modelica.Icons.Function;
//         output String directory "Full path name of work directory";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" directory = ModelicaInternal_getcwd(0) ;        annotation(Documentation(info = "<html>
//  
// </html>"));
//       end getWorkDirectory;
//       function setWorkDirectory "Set work directory"
//         extends Modelica.Icons.Function;
//         input String directory "New work directory";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_chdir(directory) ;         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end setWorkDirectory;
//       function getEnvironmentVariable "Get content of environment variable"
//         extends Modelica.Icons.Function;
//         input String name "Name of environment variable";
//         input Boolean convertToSlash = false "True, if native directory separators in 'result' shall be changed to '/'";
//         output String content "Content of environment variable (empty, if not existent)";
//         output Boolean exist "= true, if environment variable exists; = false, if it does not exist";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_getenv(name,convertToSlash,content,exist) ;         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end getEnvironmentVariable;
//       function setEnvironmentVariable "Set content of local environment variable"
//         extends Modelica.Icons.Function;
//         input String name "Name of environment variable";
//         input String content "Value of the environment variable";
//         input Boolean convertFromSlash = false "True, if '/' in content shall be changed to the native directory separator";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_setenv(name,content,convertFromSlash) ;         annotation(Documentation(info = "<html>
//     
// </html>"));
//       end setEnvironmentVariable;
//       function command "Execute command in default shell"
//         extends Modelica.Icons.Function;
//         input String string "String to be passed to shell";
//         output Integer result "Return value from command (depends on environment)";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" result = system(string) ;        annotation(Documentation(info = "<html>
//  
// </html>"));
//       end command;
//       function exit "Terminate execution of Modelica environment"
//         extends Modelica.Icons.Function;
//         input Integer status = 0 "Result to be returned by environment (0 means success)";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         external "C" ModelicaInternal_exit(status) ; 
//       end exit;
//     end System;
//     package Types "Type definitions used in package Modelica.Utilities"
//       package Compare "Type and constants to compare two strings, as temporary solution until enumerations are available"
//         extends Modelica.Icons.Enumeration;
//         constant Integer Less = 1;
//         constant Integer Equal = 2;
//         constant Integer Greater = 3;
//         type Type = Integer annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// <b>TokenType</b>.Temp tokenType = TokenType.<b>RealToken</b>;
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Package <b>TokenType</b> is an emulation of the following enumeration
// </p>
// <pre>
//    enumeration TokenType = {RealToken, IntegerToken, BooleanToken,
//                             StringToken, IdentifierToken, DelimiterToken,
//                             NoToken);
// </pre>
// <p>
// since enumerations are not yet supported in available
// Modelica tools.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Compare;
//       package FileType "Type and constants to describe the type of a file, as temporary solution until enumerations are available"
//         extends Modelica.Icons.Enumeration;
//         constant Integer NoFile = 1 "no file exists";
//         constant Integer RegularFile = 2 "regular file";
//         constant Integer Directory = 3 "directory";
//         constant Integer SpecialFile = 4 "pipe, FIFO, device, etc.";
//         type Type = Integer annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// <b>FileType</b>.Type fileType = FileType.<b>RegularFile</b>;
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Package <b>FileType</b> is an emulation of the following enumeration
// </p>
// <pre>
//    enumeration FileType = {NoFile, RegularFile, Directory, SpecialFile};
// </pre>
// <p>
// since enumerations are not yet supported in available
// Modelica tools.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end FileType;
//       package TokenType "Type and constants for token types, as temporary solution until enumerations are available"
//         extends Modelica.Icons.Enumeration;
//         constant Integer RealToken = 1;
//         constant Integer IntegerToken = 2;
//         constant Integer BooleanToken = 3;
//         constant Integer StringToken = 4;
//         constant Integer IdentifierToken = 5;
//         constant Integer DelimiterToken = 6;
//         constant Integer NoToken = 7;
//         type Type = Integer annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\">Syntax</font></h3>
// <blockquote><pre>
// <b>TokenType</b>.Temp tokenType = TokenType.<b>RealToken</b>;
// </pre></blockquote>
// <h3><font color=\"#008000\">Description</font></h3>
// <p>
// Package <b>TokenType</b> is an emulation of the following enumeration
// </p>
// <pre>
//    enumeration TokenType = {RealToken, IntegerToken, BooleanToken,
//                             StringToken, IdentifierToken, DelimiterToken,
//                             NoToken);
// </pre>
// <p>
// since enumerations are not yet supported in available
// Modelica tools.
// </p>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end TokenType;
//       record TokenValue "Value of token"
//         extends Modelica.Icons.Record;
//         TokenType.Type tokenType "Type of token";
//         Real real "Value if tokenType == TokenType.RealToken";
//         Integer integer "Value if tokenType == TokenType.IntegerToken";
//         Boolean boolean "Value if tokenType == TokenType.BooleanToken";
//         String string "Value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken";
//         annotation(Documentation(info = "<html>
//    
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end TokenValue;
//       annotation(Documentation(info = "<html>
// <p>
// This package contains type definitions used in Modelica.Utilities.
// </p>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Types;
//   end Utilities;
//   package Constants "Mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
//     import SI = Modelica.SIunits;
//     import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//     extends Modelica.Icons.Library2;
//     constant Real e = Modelica.Math.exp(1.0);
//     constant Real pi = 2 * Modelica.Math.asin(1.0);
//     constant Real D2R = pi / 180 "Degree to Radian";
//     constant Real R2D = 180 / pi "Radian to Degree";
//     constant Real eps = 1e-15 "Biggest number such that 1.0 + eps = 1.0";
//     constant Real small = 1e-60 "Smallest number such that small and -small are representable on the machine";
//     constant Real inf = 1e+60 "Biggest Real number such that inf and -inf are representable on the machine";
//     constant Integer Integer_inf = 1073741823 "Biggest Integer number such that Integer_inf and -Integer_inf are representable on the machine";
//     constant SI.Velocity c = 299792458 "Speed of light in vacuum";
//     constant SI.Acceleration g_n = 9.80665 "Standard acceleration of gravity on earth";
//     constant Real G(final unit = "m3/(kg.s2)") = 6.6742e-11 "Newtonian constant of gravitation";
//     constant Real h(final unit = "J.s") = 6.6260693e-34 "Planck constant";
//     constant Real k(final unit = "J/K") = 1.3806505e-23 "Boltzmann constant";
//     constant Real R(final unit = "J/(mol.K)") = 8.314472 "Molar gas constant";
//     constant Real sigma(final unit = "W/(m2.K4)") = 5.6704e-08 "Stefan-Boltzmann constant";
//     constant Real N_A(final unit = "1/mol") = 6.0221415e+23 "Avogadro constant";
//     constant Real mue_0(final unit = "N/A2") = 4 * pi * 1e-07 "Magnetic constant";
//     constant Real epsilon_0(final unit = "F/m") = 1 / (mue_0 * c * c) "Electric constant";
//     constant NonSI.Temperature_degC T_zero =  -273.15 "Absolute zero temperature";
//     annotation(Documentation(info = "<html>
// <p>
// This package provides often needed constants from mathematics, machine
// dependent constants and constants from nature. The latter constants
// (name, value, description) are from the following source:
// </p>
// 
// <dl>
// <dt>Peter J. Mohr and Barry N. Taylor (1999):</dt>
// <dd><b>CODATA Recommended Values of the Fundamental Physical Constants: 1998</b>.
//     Journal of Physical and Chemical Reference Data, Vol. 28, No. 6, 1999 and
//     Reviews of Modern Physics, Vol. 72, No. 2, 2000. See also <a href=
// \"http://physics.nist.gov/cuu/Constants/\">http://physics.nist.gov/cuu/Constants/</a></dd>
// </dl>
// 
// <p>CODATA is the Committee on Data for Science and Technology.</p>
// 
// <dl>
// <dt><b>Main Author:</b></dt>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 11 16<br>
//     D-82230 We&szlig;ling<br>
//     email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
// </dl>
// 
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </html>
// ", revisions = "<html>
// <ul>
// <li><i>Nov 8, 2004</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Constants updated according to 2002 CODATA values.</li>
// <li><i>Dec 9, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Constants updated according to 1998 CODATA values. Using names, values
//        and description text from this source. Included magnetic and
//        electric constant.</li>
// <li><i>Sep 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Constants eps, inf, small introduced.</li>
// <li><i>Nov 15, 1997</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -34, -38},{12, -38}}, thickness = 0.5),Line(visible = true, points = {{ -20, -38},{ -24, -48},{ -28, -56},{ -34, -64}}, thickness = 0.5),Line(visible = true, points = {{ -2, -38},{2, -46},{8, -56},{14, -64}}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//   end Constants;
//   package Icons "Icon definitions"
//     annotation(preferedView = "info", Documentation(info = "<html>
// <p>
// This package contains definitions for the graphical layout of
// components which may be used in different libraries.
// The icons can be utilized by inheriting them in the desired class
// using \"extends\".
// </p>
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added new icons <b>Function</b>, <b>Enumerations</b> and <b>Record</b>.</li>
// <li><i>June 6, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Replaced <b>model</b> keyword by <b>package</b> if the main
//        usage is for inheriting from a package.<br>
//        New icons <b>GearIcon</b> and <b>MotorIcon</b>.</li>
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renaming package Icon to Icons.
//        Model Advanced removed (icon not accepted on the Modelica meeting).
//        New model Library2, which is the Library icon with enough place
//        to add library specific elements in the icon. Icon also used in diagram
//        level for models Info, TranslationalSensor, RotationalSensor.</li>
// <li><i>July 15, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Model Caution renamed to Advanced, model Sensor renamed to
//        TranslationalSensor, new model RotationalSensor.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version.</li>
// </ul>
// <br>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,70},{120,135}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, extent = {{ -90,10},{70,40}}, textString = "Library", fontName = "Arial"),Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {160,160,160}, extent = {{ -90,10},{70,40}}, textString = "Library", fontName = "Arial"),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{ -64, -20},{ -50, -4},{50, -4},{36, -20},{ -64, -20},{ -64, -20}}),Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -64, -84},{36, -20}}),Text(visible = true, fillColor = {128,128,128}, extent = {{ -60, -38},{32, -24}}, textString = "Library", fontName = "Arial"),Polygon(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, points = {{50, -4},{50, -70},{36, -84},{36, -20},{50, -4}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     partial model Info "Icon for an information class"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -100, -90},{80,80}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -100,80},{ -90,90},{90,90},{80,80},{ -100,80}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{80, -90},{90, -80},{90,90},{80,80},{80, -90}}),Text(visible = true, extent = {{ -80, -70},{60,70}}, textString = "Info", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, extent = {{ -100, -90},{80,80}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{ -100,80},{ -90,90},{90,90},{80,80},{ -100,80}}),Polygon(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, points = {{80, -90},{90, -80},{90,90},{80,80},{80, -90}}),Text(visible = true, extent = {{ -80, -70},{60,70}}, textString = "Info", fontName = "Arial")}));
//     end Info;
//     partial package Library "Icon for library"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {0,0,255}, extent = {{ -85, -85},{65,35}}, textString = "Library", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,73},{120,122}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Library;
//     partial package Library2 "Icon for library where additional icon elements shall be added"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {210,210,210}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,70},{120,125}}, textString = "%name", fontName = "Arial"),Text(visible = true, fillColor = {160,160,160}, fillPattern = FillPattern.Solid, extent = {{ -90,10},{70,40}}, textString = "Library", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Library2;
//     partial model Example "Icon for an example model"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{80,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{ -100,50},{ -80,70},{100,70},{80,50},{ -100,50}}),Polygon(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, points = {{100,70},{100, -80},{80, -100},{80,50},{100,70}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -85, -85},{65,35}}, textString = "Example", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{ -120,73},{120,132}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Example;
//     partial function Function "Icon for a function"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -140,102},{136,162}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {255,127,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {255,127,0}, extent = {{ -100, -100},{100,100}}, textString = "f", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Function;
//     partial record Record "Icon for a record"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,127}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,50}}),Text(visible = true, extent = {{ -127,55},{127,115}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{ -100, -50},{100, -50}}),Line(visible = true, points = {{ -100,0},{100,0}}),Line(visible = true, points = {{0,50},{0, -100}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Record;
//     partial class Enumeration "Icon for an enumeration (emulated by a package)"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -138,104},{138,164}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, lineColor = {255,0,127}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, fillColor = {255,0,127}, extent = {{ -100, -100},{100,100}}, textString = "e", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end Enumeration;
//     type TypeReal "Icon for a Real type"
//       extends Real;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -94, -94},{94,94}}, textString = "R", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end TypeReal;
//     type TypeInteger "Icon for an Integer type"
//       extends Integer;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -94, -94},{94,94}}, textString = "I", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end TypeInteger;
//     type TypeBoolean "Icon for a Boolean type"
//       extends Boolean;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -94, -94},{94,94}}, textString = "B", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end TypeBoolean;
//     type TypeString "Icon for a String type"
//       extends String;
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -94, -94},{94,94}}, textString = "S", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end TypeString;
//     partial model TranslationalSensor "Icon representing translational measurement device"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -60},{70,20}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{0, -40},{ -10, -16},{10, -16},{0, -40}}),Line(visible = true, points = {{0,0},{0, -16}}),Line(visible = true, points = {{ -70,0},{0,0}}),Line(visible = true, points = {{ -50, -40},{ -50, -60}}),Line(visible = true, points = {{ -30, -40},{ -30, -60}}),Line(visible = true, points = {{ -10, -40},{ -10, -60}}),Line(visible = true, points = {{10, -40},{10, -60}}),Line(visible = true, points = {{30, -40},{30, -60}}),Line(visible = true, points = {{50, -40},{50, -60}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -60},{70,20}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{0, -40},{ -10, -16},{10, -16},{0, -40}}),Line(visible = true, points = {{0,0},{0, -16}}),Line(visible = true, points = {{ -70,0},{0,0}}),Line(visible = true, points = {{ -50, -40},{ -50, -60}}),Line(visible = true, points = {{ -30, -40},{ -30, -60}}),Line(visible = true, points = {{ -10, -40},{ -10, -60}}),Line(visible = true, points = {{10, -40},{10, -60}}),Line(visible = true, points = {{30, -40},{30, -60}}),Line(visible = true, points = {{50, -40},{50, -60}})}));
//     end TranslationalSensor;
//     partial model RotationalSensor "Icon representing rotational measurement device"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -70, -70},{70,70}}),Line(visible = true, points = {{0,70},{0,40}}),Line(visible = true, points = {{22.9,32.8},{40.2,57.3}}),Line(visible = true, points = {{ -22.9,32.8},{ -40.2,57.3}}),Line(visible = true, points = {{37.6,13.7},{65.8,23.9}}),Line(visible = true, points = {{ -37.6,13.7},{ -65.8,23.9}}),Line(visible = true, points = {{0,0},{9.02,28.6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -0.48,31.6},{18,26},{18,57.2},{ -0.48,31.6}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -5},{5,5}})}));
//     end RotationalSensor;
//     partial model GearIcon "Icon for gearbox"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {192,192,192}, pattern = LinePattern.None, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -90, -10},{ -60,10}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{ -60,10},{ -60,20},{ -40,40},{ -40, -40},{ -60, -20},{ -60,10}}),Rectangle(visible = true, fillColor = {192,192,192}, pattern = LinePattern.None, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -40, -60},{40,60}}),Polygon(visible = true, lineColor = {128,128,128}, fillColor = {128,128,128}, fillPattern = FillPattern.Solid, points = {{60,20},{40,40},{40, -40},{60, -20},{60,20}}),Rectangle(visible = true, fillColor = {192,192,192}, pattern = LinePattern.None, fillPattern = FillPattern.HorizontalCylinder, extent = {{60, -10},{90,10}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -60, -90},{ -50, -90},{ -20, -30},{20, -30},{48, -90},{60, -90},{60, -100},{ -60, -100},{ -60, -90}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end GearIcon;
//     partial model MotorIcon "Icon for electrical motor"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,0,0}, pattern = LinePattern.None, fillPattern = FillPattern.HorizontalCylinder, extent = {{ -100, -50},{30,50}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -100, -90},{ -90, -90},{ -60, -20},{ -10, -20},{20, -90},{30, -90},{30, -100},{ -100, -100},{ -100, -90}}),Rectangle(visible = true, fillColor = {192,192,192}, pattern = LinePattern.None, fillPattern = FillPattern.HorizontalCylinder, extent = {{30, -10},{90,10}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     end MotorIcon;
//     connector SignalBus "Icon for signal bus"
//       annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -16,2},{16,2}}, thickness = 0.5),Polygon(visible = true, fillColor = {255,204,51}, fillPattern = FillPattern.Solid, points = {{ -80,50},{80,50},{100,30},{80, -40},{60, -50},{ -60, -50},{ -80, -40},{ -100,30}}, smooth = Smooth.Bezier),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -65,15},{ -55,25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5,15},{5,25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{55,15},{65,25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -35, -25},{ -25, -15}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{25, -25},{35, -15}})}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {255,204,51}, fillPattern = FillPattern.Solid, points = {{ -40,25},{40,25},{50,15},{40, -20},{30, -25},{ -30, -25},{ -40, -20},{ -50,15}}, smooth = Smooth.Bezier),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -32.5,7.5},{ -27.5,12.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -2.5,7.5},{2.5,12.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{27.5,7.5},{32.5,12.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -17.5, -12.5},{ -12.5, -7.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{12.5, -12.5},{17.5, -7.5}}),Text(visible = true, extent = {{ -150,40},{150,70}}, textString = "%name", fontName = "Arial")}));
//     end SignalBus;
//     connector SignalSubBus "Icon for signal sub-bus"
//       annotation(Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillColor = {255,204,51}, fillPattern = FillPattern.Solid, points = {{ -40,25},{40,25},{50,15},{40, -20},{30, -25},{ -30, -25},{ -40, -20},{ -50,15}}, smooth = Smooth.Bezier),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -22.5,7.5},{ -17.5,12.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{17.5,7.5},{22.5,12.5}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -2.5, -12.5},{2.5, -7.5}}),Text(visible = true, extent = {{ -150,40},{150,70}}, textString = "%name", fontName = "Arial")}), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -16,2},{16,2}}, thickness = 0.5),Rectangle(visible = true, lineColor = {191,127,255}, lineThickness = 0.5, extent = {{ -10,0},{8,8}}),Polygon(visible = true, fillColor = {255,204,51}, fillPattern = FillPattern.Solid, points = {{ -80,50},{80,50},{100,30},{80, -40},{60, -50},{ -60, -50},{ -80, -40},{ -100,30}}, smooth = Smooth.Bezier),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -55,15},{ -45,25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{45,15},{55,25}}),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -5, -25},{5, -15}})}));
//     end SignalSubBus;
//   end Icons;
//   package SIunits "Type and unit definitions based on SI units according to ISO 31-1992"
//     package UsersGuide "Users Guide"
//       annotation(DocumentationClass = true, Documentation(info = "<HTML>
// <h3><font color=\"#008000\" size=5>Users Guide of package SIunits</font></h3>
// <p>
// Library <b>SIunits</b> is a <b>free</b> Modelica package providing
// predefined types, such as <i>Mass</i>,
// <i>Length</i>, <i>Time</i>, based on the international standard
// on units.</p>
// 
// </HTML>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package HowToUseSIunits "How to use SIunits"
//         annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>How to use SIunits</font></h3>
// 
// <p>
// When implementing a Modelica model, every variable needs to
// be declared. Physical variables should be declared with a unit.
// The basic approach in Modelica is that the unit attribute of
// a variable is the <b>unit</b> in which the <b>equations</b> are <b>written</b>,
// for example:
// </p>
// 
// <pre>   <b>model</b> MassOnGround
//      <b>parameter</b> Real m(quantity=\"Mass\", unit=\"kg\") \"Mass\";
//      <b>parameter</b> Real f(quantity=\"Force\", unit=\"N\") \"Driving force\";
//      Real s(unit=\"m\") \"Position of mass\";
//      Real v(unit=\"m/s\") \"Velocity of mass\";
//    <b>equation</b>
//      <b>der</b>(s) = v;
//      m*<b>der</b>(v) = f;
//    <b>end</b> MassOnGround;
// </pre>
// 
// <p>
// This means that the equations in the equation section are only correct
// for the specified units. A different issue is the user interface, i.e.,
// in which unit the variable is presented to the user in graphical
// user interfaces, both for input (e.g., parameter menu), as well as
// for output (e.g., in the plot window). Preferably, the Modelica tool
// should provide a list of units from which the user can select, e.g.,
// \"m\", \"cm\", \"km\", \"inch\" for quantity \"Length\". When storing the value in
// the model as a Modelica modifier, it has to be converted to the unit defined
// in the declaration. Additionally, the unit used in the graphical
// user interface has to be stored. In order to have a standardized way
// of doing this, Modelica provides the following three attributs
// for a variable of type Real:
// </p>
// 
// <ul>
// <li><b>quantity</b> to define the physical quantity (e.g. \"Length\", or \"Energy\").</li>
// <li><b>unit</b> to define the unit that has to be used
//     in order that the equations are correct (e.g. \"N.m\").</li>
// <li><b>displayUnit</b> to define the unit used in the graphical 
//     user interface as default display unit for input and/or output.</li>
// </ul>
// 
// <p>
// Note, a unit, such as \"N.m\", is not sufficient to define uniquely the
// physical quantity, since, e.g., \"N.m\" might be either \"torque\" or
// \"energy\". The \"quantity\" attribute might therefore be used by a tool
// to select the corresponding menu from which the user can select
// a unit for the corresponding variable.
// </p>
// 
// <p>
// For example, after providing a value for \"m\" and \"f\" in a parameter 
// menu of an instance of MassOnGround, a tool might generate the following code:
// </p>
// 
// <pre>
//    MassOnGround myObject(m(displayUnit=\"g\")=2, f=3);
// </pre>
// 
// <p>
// The meaning is that in the equations a value of \"2\" is used
// and that in the graphical user interface a value of \"2000\" should be used,
// together with the unit \"g\" from the unit set \"Mass\" (= the quantity name). 
// Note, according to the Modelica specification
// a tool might ignore the \"displayUnit\" attribute.
// </p>
// 
// <p>
// In order to help the Modelica model developer, the Modelica.SIunits
// library provides about 450 predefined type names,
// together with values for the attributes <b>quantity</b>, <b>unit</b> and sometimes
// <b>displayUnit</b> and <b>min</b>. The unit is always selected as SI-unit according to the
// ISO standard. The type and the quantity names are the 
// quantity names used in the ISO standard. \"quantity\" and \"unit\" are defined
// as \"<b>final</b>\" in order that they cannot be modified. Attributes \"displayUnit\"
// and \"min\" can, however, be changed in a model via a modification. The example above,
// might therefore be alternatively also defined as:
// </p>
// 
// <pre>   <b>model</b> MassOnGround
//      <b>parameter</b> Modelica.SIunits.Mass  m \"Mass\";
//      <b>parameter</b> Modelica.SIunits.Force f \"Driving force\";
//      ...
//    <b>end</b> MassOnGround;
// </pre>
// 
// <p>
// or in a short hand notation as
// </p>
// 
// <pre>
//    <b>model</b> MassOnGround
//      <b>import</b> SI = Modelica.SIunits;
//      <b>parameter</b> SI.Mass  m \"Mass\";
//      <b>parameter</b> SI.Force f \"Driving force\";
//      ...
//    <b>end</b> MassOnGround;
// </pre>
// 
// <p>
// For some often
// used Non SI-units (like hour), some additional type definitions are
// present as Modelica.SIunits.Conversions.NonSIunits. If this is not sufficient,
// the user has to define its own types or use the attributes directly
// in the declaration as in the example at the beginning.
// </p>
// 
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end HowToUseSIunits;
//       package Conventions "Conventions"
//         annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Conventions</font></h3>
// 
// <p>The following conventions are used in package SIunits:</p>
// <ul>
// <li>Modelica quantity names are defined according to the recommendations
//     of ISO 31. Some of these name are rather long, such as
//     \"ThermodynamicTemperature\". Shorter alias names are defined, e.g.,
//     \"type Temp_K = ThermodynamicTemperature;\".</li>
// <li>Modelica units are defined according to the SI base units without
//     multiples (only exception \"kg\").</li>
// <li>For some quantities, more convenient units for an engineer are
//     defined as \"displayUnit\", i.e., the default unit for display
//     purposes (e.g., displayUnit=\"deg\" for quantity=\"Angle\").</li>
// <li>The type name is identical to the quantity name, following
//     the convention of type names.</li>
// <li>All quantity and unit attributes are defined as final in order
//     that they cannot be redefined to another value.</li>
// <li>Similiar quantities, such as \"Length, Breadth, Height, Thickness,
//     Radius\" are defined as the same quantity (here: \"Length\").</li>
// <li>The ordering of the type declarations in this package follows ISO 31:
// <pre>
//   Chapter  1: <b>Space and Time</b>
//   Chapter  2: <b>Periodic and Related Phenomena</b>
//   Chapter  3: <b>Mechanics</b>
//   Chapter  4: <b>Heat</b>
//   Chapter  5: <b>Electricity and Magnetism</b>
//   Chapter  6: <b>Light and Related Electro-Magnetic Radiations</b>
//   Chapter  7: <b>Acoustics</b>
//   Chapter  8: <b>Physical Chemistry</b>
//   Chapter  9: <b>Atomic and Nuclear Physics</b>
//   Chapter 10: <b>Nuclear Reactions and Ionizing Radiations</b>
//   Chapter 11: (not defined in ISO 31-1992)
//   Chapter 12: <b>Characteristic Numbers</b>
//   Chapter 13: <b>Solid State Physics</b>
// </pre>
// </li>
// <li>Conversion functions between SI and non-SI units are available in subpackage
//     <b>Conversions</b>.</li>
// </ul>
// </html>"), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Conventions;
//       class Literature "Literature"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Literature</font></h3>
// 
// <p> This package is based on the following references
// </p>
// 
// <dl>
// <dt>ISO 31-1992:</dt>
// <dd> <b>General principles concerning
//     quantities, units and symbols</b>.<br>&nbsp;</dd>
// 
// <dt>ISO 1000-1992:</dt>
// <dd> <b>SI units and recommendations for the use
//     of their multiples and of certain other units</b>.<br>&nbsp;</dd>
// 
// <dt>Cardarelli F.:</dt>
// <dd> <b>Scientific Unit Conversion - A Practical
//      Guide to Metrication</b>. Springer 1997.</dd>
// </dl>
// 
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Literature;
//       class Contact "Contact"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br> 
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// 
// 
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> Astrid Jaschinski, Hubertus Tummescheit and Christian Schweiger
//      contributed to the implementation of this package.</li>
// </ul>
// </html>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end Contact;
//     end UsersGuide;
//     extends Modelica.Icons.Library2;
//     annotation(preferedView = "info", Invisible = true, Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -63, -67},{45, -13}}, textString = "[kg.m2]", fontName = "Arial")}), Documentation(info = "<html>
// <p>This package provides predefined types, such as <i>Mass</i>,
// <i>Angle</i>, <i>Time</i>, based on the international standard
// on units, e.g., 
// </p>
// 
// <pre>   <b>type</b> Angle = Real(<b>final</b> quantity = \"Angle\",
//                      <b>final</b> unit     = \"rad\",
//                      displayUnit    = \"deg\");
// </pre>
// 
// <p>
// as well as conversion functions from non SI-units to SI-units
// and vice versa in subpackage 
// <a href=\"Modelica://Modelica.SIunits.Conversions\">Conversions</a>.
// </p>
// 
// <p>
// For an introduction how units are used in the Modelica standard library
// with package SIunits, have a look at:
// <a href=\"Modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
// </p>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR.
// </p>
// <p>
// <i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p>
// 
// </html>", revisions = "<html>
// <ul>
// <li><i>Dec. 14, 2005</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Add users guide and removed \"min\" values for Resistance and Conductance.</li>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added new package <b>Conversions</b>. Corrected typo <i>Wavelenght</i>.</li>
// <li><i>June 6, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Introduced the following new types<br>
//        type Temperature = ThermodynamicTemperature;<br>
//        types DerDensityByEnthalpy, DerDensityByPressure,
//        DerDensityByTemperature, DerEnthalpyByPressure,
//        DerEnergyByDensity, DerEnergyByPressure<br>
//        Attribute \"final\" removed from min and max values
//        in order that these values can still be changed to narrow
//        the allowed range of values.<br>
//        Quantity=\"Stress\" removed from type \"Stress\", in order
//        that a type \"Stress\" can be connected to a type \"Pressure\".</li>
// <li><i>Oct. 27, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New types due to electrical library: Transconductance, InversePotential,
//        Damping.</li>
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renamed from SIunit to SIunits. Subpackages expanded, i.e., the
//        SIunits package, does no longer contain subpackages.</li>
// <li><i>Aug 12, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Type \"Pressure\" renamed to \"AbsolutePressure\" and introduced a new
//        type \"Pressure\" which does not contain a minimum of zero in order
//        to allow convenient handling of relative pressure. Redefined
//        BulkModulus as an alias to AbsolutePressure instead of Stress, since
//        needed in hydraulics.</li>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Bug-fix: Double definition of \"Compressibility\" removed
//        and appropriate \"extends Heat\" clause introduced in
//        package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
// <li><i>April 8, 1998</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and Astrid Jaschinski:<br>
//        Complete ISO 31 chapters realized.</li>
// <li><i>Nov. 15, 1997</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a>:<br>
//        Some chapters realized.</li>
// </ul>
// </html>"), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, extent = {{169,86},{349,236}}),Polygon(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{169,236},{189,256},{369,256},{349,236},{169,236}}),Polygon(visible = true, fillColor = {235,235,235}, fillPattern = FillPattern.Solid, points = {{369,256},{369,106},{349,86},{349,236},{369,256}}),Text(visible = true, fillColor = {160,160,160}, extent = {{179,196},{339,226}}, textString = "Library", fontName = "Arial"),Text(visible = true, extent = {{206,119},{314,173}}, textString = "[kg.m2]", fontName = "Arial"),Text(visible = true, fillColor = {255,0,0}, extent = {{163,264},{406,320}}, textString = "Modelica.SIunits", fontName = "Arial")}));
//     package Conversions "Conversion functions to/from non SI units and type definitions of non SI units"
//       extends Modelica.Icons.Library2;
//       annotation(preferedView = "info", Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, lineThickness = 1, extent = {{ -92, -67},{ -33, -7}}, textString = "C", fontName = "Arial"),Text(visible = true, extent = {{22, -67},{82, -7}}, textString = "K", fontName = "Arial"),Line(visible = true, points = {{ -26, -36},{6, -36}}),Polygon(visible = true, pattern = LinePattern.None, fillPattern = FillPattern.Solid, points = {{6, -28},{6, -45},{26, -37},{6, -28}})}), Documentation(info = "<HTML>
// <p>This package provides conversion functions from the non SI Units
// defined in package Modelica.SIunits.Conversions.NonSIunits to the
// corresponding SI Units defined in package Modelica.SIunits and vice
// versa. It is recommended to use these functions in the following
// way (note, that all functions have one Real input and one Real output 
// argument):</p>
// <pre>
//   <b>import</b> SI = Modelica.SIunits;
//   <b>import</b> Modelica.SIunits.Conversions.*;
//      ...
//   <b>parameter</b> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
//   <b>parameter</b> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
//   <b>parameter</b> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
//                                                       // to radian per seconds
// </pre>
//  
// </HTML>
// "), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       package NonSIunits "Type definitions of non SI units"
//         extends Modelica.Icons.Library2;
//         type Temperature_degC = Real(final quantity = "ThermodynamicTemperature", final unit = "degC") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Temperature_degF = Real(final quantity = "ThermodynamicTemperature", final unit = "degF") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Temperature_degRk = Real(final quantity = "ThermodynamicTemperature", final unit = "degRk") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Angle_deg = Real(final quantity = "Angle", final unit = "deg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type AngularVelocity_rpm = Real(final quantity = "AngularVelocity", final unit = "rev/min") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Velocity_kmh = Real(final quantity = "Velocity", final unit = "km/h") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Time_day = Real(final quantity = "Time", final unit = "d") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Time_hour = Real(final quantity = "Time", final unit = "h") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Time_minute = Real(final quantity = "Time", final unit = "min") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Volume_litre = Real(final quantity = "Volume", final unit = "l") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Energy_kWh = Real(final quantity = "Energy", final unit = "kWh") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type Pressure_bar = Real(final quantity = "Pressure", final unit = "bar") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         type MassFlowRate_gps = Real(final quantity = "MassFlowRate", final unit = "g/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         annotation(preferedView = "info", Documentation(info = "<HTML>
// <p>
// This package provides predefined types, such as <b>Angle_deg</b> (angle in
// degree), <b>AngularVelocity_rpm</b> (angular velocity in revolutions per
// minute) or <b>Temperature_degF</b> (temperature in degree Fahrenheit),
// which are in common use but are not part of the international standard on
// units according to ISO 31-1992 \"General principles concerning quantities,
// units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
// the use of their multiples and of certain other units\".</p>
// <p>If possible, the types in this package should not be used. Use instead
// types of package Modelica.SIunits. For more information on units, see also
// the book of Francois Cardarelli <b>Scientific Unit Conversion - A
// Practical Guide to Metrication</b> (Springer 1997).</p>
// <p>Some units, such as <b>Temperature_degC/Temp_C</b> are both defined in
// Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
// definitions have been placed erroneously in Modelica.SIunits although they
// are not SIunits. For backward compatibility, these type definitions are
// still kept in Modelica.SIunits.</p>
// </HTML>
// "), Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -66, -67},{52, -13}}, textString = "[rev/min]", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end NonSIunits;
//       function to_degC "Convert from Kelvin to Celsius"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degC Celsius "Celsius value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "C", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Celsius:=Kelvin + Modelica.Constants.T_zero;
//       end to_degC;
//       function from_degC "Convert from Celsius to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degC Celsius "Celsius value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "C", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Kelvin:=Celsius - Modelica.Constants.T_zero;
//       end from_degC;
//       function to_degF "Convert from Kelvin to Fahrenheit"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degF Fahrenheit "Fahrenheit value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "F", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Fahrenheit:=((Kelvin + Modelica.Constants.T_zero) * 9) / 5 + 32;
//       end to_degF;
//       function from_degF "Convert from Fahrenheit to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degF Fahrenheit "Fahrenheit value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "F", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Kelvin:=((Fahrenheit - 32) * 5) / 9 - Modelica.Constants.T_zero;
//       end from_degF;
//       function to_degRk "Convert from Kelvin to Rankine"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degRk Rankine "Rankine value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "K", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "Rk", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Rankine:=9 / 5 * Kelvin;
//       end to_degRk;
//       function from_degRk "Convert from Rankine to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degRk Rankine "Rankine value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "Rk", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "K", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Kelvin:=5 / 9 * Rankine;
//       end from_degRk;
//       function to_deg "Convert from radian to degree"
//         extends ConversionIcon;
//         input Angle radian "radian value";
//         output NonSIunits.Angle_deg degree "degree value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "rad", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "deg", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         degree:=180.0 / Modelica.Constants.pi * radian;
//       end to_deg;
//       function from_deg "Convert from degree to radian"
//         extends ConversionIcon;
//         input NonSIunits.Angle_deg degree "degree value";
//         output Angle radian "radian value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "deg", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "rad", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         radian:=Modelica.Constants.pi / 180.0 * degree;
//       end from_deg;
//       function to_rpm "Convert from radian per second to revolutions per minute"
//         extends ConversionIcon;
//         input AngularVelocity rs "radian per second value";
//         output NonSIunits.AngularVelocity_rpm rpm "revolutions per minute value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "rad/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "rev/min", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         rpm:=30 / Modelica.Constants.pi * rs;
//       end to_rpm;
//       function from_rpm "Convert from revolutions per minute to radian per second"
//         extends ConversionIcon;
//         input NonSIunits.AngularVelocity_rpm rpm "revolutions per minute value";
//         output AngularVelocity rs "radian per second value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "rev/min", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "rad/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         rs:=Modelica.Constants.pi / 30 * rpm;
//       end from_rpm;
//       function to_kmh "Convert from metre per second to kilometre per hour"
//         extends ConversionIcon;
//         input Velocity ms "metre per second value";
//         output NonSIunits.Velocity_kmh kmh "kilometre per hour value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "m/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "km/h", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         kmh:=3.6 * ms;
//       end to_kmh;
//       function from_kmh "Convert from kilometre per hour to metre per second"
//         extends ConversionIcon;
//         input NonSIunits.Velocity_kmh kmh "kilometre per hour value";
//         output Velocity ms "metre per second value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "km/h", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "m/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         ms:=kmh / 3.6;
//       end from_kmh;
//       function to_day "Convert from second to day"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_day day "day value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "day", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         day:=s / 86400;
//       end to_day;
//       function from_day "Convert from day to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_day day "day value";
//         output Time s "second value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "day", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         s:=86400 * day;
//       end from_day;
//       function to_hour "Convert from second to hour"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_hour hour "hour value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "hour", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         hour:=s / 3600;
//       end to_hour;
//       function from_hour "Convert from hour to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_hour hour "hour value";
//         output Time s "second value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "hour", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         s:=3600 * hour;
//       end from_hour;
//       function to_minute "Convert from second to minute"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_minute minute "minute value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "minute", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         minute:=s / 60;
//       end to_minute;
//       function from_minute "Convert from minute to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_minute minute "minute value";
//         output Time s "second value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "minute", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         s:=60 * minute;
//       end from_minute;
//       function to_litre "Convert from cubic metre to litre"
//         extends ConversionIcon;
//         input Volume m3 "cubic metre value";
//         output NonSIunits.Volume_litre litre "litre value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "m3", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "litre", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         litre:=1000 * m3;
//       end to_litre;
//       function from_litre "Convert from litre to cubic metre"
//         extends ConversionIcon;
//         input NonSIunits.Volume_litre litre "litre value";
//         output Volume m3 "cubic metre value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "litre", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "m3", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         m3:=litre / 1000;
//       end from_litre;
//       function to_kWh "Convert from Joule to kilo Watt hour"
//         extends ConversionIcon;
//         input Energy J "Joule value";
//         output NonSIunits.Energy_kWh kWh "kWh value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "J", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "kWh", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         kWh:=J / 3600000.0;
//       end to_kWh;
//       function from_kWh "Convert from kilo Watt hour to Joule"
//         extends ConversionIcon;
//         input NonSIunits.Energy_kWh kWh "kWh value";
//         output Energy J "Joule value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "kWh", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "J", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         J:=3600000.0 * kWh;
//       end from_kWh;
//       function to_bar "Convert from Pascal to bar"
//         extends ConversionIcon;
//         input Pressure Pa "Pascal value";
//         output NonSIunits.Pressure_bar bar "bar value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "Pa", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "bar", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         bar:=Pa / 100000.0;
//       end to_bar;
//       function from_bar "Convert from bar to Pascal"
//         extends ConversionIcon;
//         input NonSIunits.Pressure_bar bar "bar value";
//         output Pressure Pa "Pascal value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "bar", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "Pa", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         Pa:=100000.0 * bar;
//       end from_bar;
//       function to_gps "Convert from kilogram per second to gram per second"
//         extends ConversionIcon;
//         input MassFlowRate kgps "kg/s value";
//         output NonSIunits.MassFlowRate_gps gps "g/s value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "kg/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "g/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         gps:=1000 * kgps;
//       end to_gps;
//       function from_gps "Convert from gram per second to kilogram per second"
//         extends ConversionIcon;
//         input NonSIunits.MassFlowRate_gps gps "g/s value";
//         output MassFlowRate kgps "kg/s value";
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -100,20},{ -20,100}}, textString = "g/s", fontName = "Arial"),Text(visible = true, extent = {{20, -100},{100, -20}}, textString = "kg/s", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       algorithm 
//         kgps:=gps / 1000;
//       end from_gps;
//       partial function ConversionIcon "Base icon for conversion functions"
//         annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {191,0,0}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Line(visible = true, points = {{ -90,0},{30,0}}, color = {191,0,0}),Polygon(visible = true, lineColor = {191,0,0}, fillColor = {191,0,0}, fillPattern = FillPattern.Solid, points = {{90,0},{30,20},{30, -20},{90,0}}),Text(visible = true, extent = {{ -115,105},{115,155}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       end ConversionIcon;
//     end Conversions;
//     type Angle = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SolidAngle = Real(final quantity = "SolidAngle", final unit = "sr") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Length = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PathLength = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Position = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Distance = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Breadth = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Height = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Thickness = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Radius = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Diameter = Length(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Area = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Volume = Real(final quantity = "Volume", final unit = "m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Time = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Duration = Time annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularVelocity = Real(final quantity = "AngularVelocity", final unit = "rad/s", displayUnit = "rev/min") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularAcceleration = Real(final quantity = "AngularAcceleration", final unit = "rad/s2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Velocity = Real(final quantity = "Velocity", final unit = "m/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Acceleration = Real(final quantity = "Acceleration", final unit = "m/s2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Period = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Frequency = Real(final quantity = "Frequency", final unit = "Hz") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Wavelength = Real(final quantity = "Wavelength", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Wavelenght = Wavelength annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type WaveNumber = Real(final quantity = "WaveNumber", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CircularWaveNumber = Real(final quantity = "CircularWaveNumber", final unit = "rad/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AmplitudeLevelDifference = Real(final quantity = "AmplitudeLevelDifference", final unit = "dB") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PowerLevelDifference = Real(final quantity = "PowerLevelDifference", final unit = "dB") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DampingCoefficient = Real(final quantity = "DampingCoefficient", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LogarithmicDecrement = Real(final quantity = "LogarithmicDecrement", final unit = "Np/S") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AttenuationCoefficient = Real(final quantity = "AttenuationCoefficient", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PhaseCoefficient = Real(final quantity = "PhaseCoefficient", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PropagationCoefficient = Real(final quantity = "PropagationCoefficient", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Damping = DampingCoefficient annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Mass = Real(quantity = "Mass", final unit = "kg", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Density = Real(final quantity = "Density", final unit = "kg/m3", displayUnit = "g/cm3", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativeDensity = Real(final quantity = "RelativeDensity", final unit = "1", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificVolume = Real(final quantity = "SpecificVolume", final unit = "m3/kg", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearDensity = Real(final quantity = "LinearDensity", final unit = "kg/m", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SurfaceDensity = Real(final quantity = "SurfaceDensity", final unit = "kg/m2", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Momentum = Real(final quantity = "Momentum", final unit = "kg.m/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Impulse = Real(final quantity = "Impulse", final unit = "N.s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularMomentum = Real(final quantity = "AngularMomentum", final unit = "kg.m2/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularImpulse = Real(final quantity = "AngularImpulse", final unit = "N.m.s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MomentOfInertia = Real(final quantity = "MomentOfInertia", final unit = "kg.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Inertia = MomentOfInertia annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Force = Real(final quantity = "Force", final unit = "N") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Weight = Force annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Torque = Real(final quantity = "Torque", final unit = "N.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MomentOfForce = Torque annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Pressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AbsolutePressure = Pressure(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BulkModulus = AbsolutePressure annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Stress = Real(final unit = "Pa") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NormalStress = Stress annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ShearStress = Stress annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Strain = Real(final quantity = "Strain", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearStrain = Strain annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ShearStrain = Strain annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type VolumeStrain = Real(final quantity = "VolumeStrain", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PoissonNumber = Real(final quantity = "PoissonNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ModulusOfElasticity = Stress annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ShearModulus = Stress annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SecondMomentOfArea = Real(final quantity = "SecondMomentOfArea", final unit = "m4") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SecondPolarMomentOfArea = SecondMomentOfArea annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SectionModulus = Real(final quantity = "SectionModulus", final unit = "m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CoefficientOfFriction = Real(final quantity = "CoefficientOfFriction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DynamicViscosity = Real(final quantity = "DynamicViscosity", final unit = "Pa.s", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type KinematicViscosity = Real(final quantity = "KinematicViscosity", final unit = "m2/s", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SurfaceTension = Real(final quantity = "SurfaceTension", final unit = "N/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Work = Real(final quantity = "Work", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Energy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PotentialEnergy = Energy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type KineticEnergy = Energy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Power = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnergyFlowRate = Power annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnthalpyFlowRate = Real(final quantity = "EnthalpyFlowRate", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Efficiency = Real(final quantity = "Efficiency", final unit = "1", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassFlowRate = Real(quantity = "MassFlowRate", final unit = "kg/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type VolumeFlowRate = Real(final quantity = "VolumeFlowRate", final unit = "m3/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MomentumFlux = Real(final quantity = "MomentumFlux", final unit = "N") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularMomentumFlux = Real(final quantity = "AngularMomentumFlux", final unit = "N.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermodynamicTemperature = Real(final quantity = "ThermodynamicTemperature", final unit = "K", min = 0, displayUnit = "degC") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Temp_K = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Temperature = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CelsiusTemperature = Real(final quantity = "CelsiusTemperature", final unit = "degC") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Temp_C = CelsiusTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearExpansionCoefficient = Real(final quantity = "LinearExpansionCoefficient", final unit = "1/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CubicExpansionCoefficient = Real(final quantity = "CubicExpansionCoefficient", final unit = "1/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativePressureCoefficient = Real(final quantity = "RelativePressureCoefficient", final unit = "1/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PressureCoefficient = Real(final quantity = "PressureCoefficient", final unit = "Pa/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Compressibility = Real(final quantity = "Compressibility", final unit = "1/Pa") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IsothermalCompressibility = Compressibility annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IsentropicCompressibility = Compressibility annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Heat = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HeatFlowRate = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HeatFlux = Real(final quantity = "HeatFlux", final unit = "W/m^2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DensityOfHeatFlowRate = Real(final quantity = "DensityOfHeatFlowRate", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalConductivity = Real(final quantity = "ThermalConductivity", final unit = "W/(m.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CoefficientOfHeatTransfer = Real(final quantity = "CoefficientOfHeatTransfer", final unit = "W/(m2.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SurfaceCoefficientOfHeatTransfer = CoefficientOfHeatTransfer annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalInsulance = Real(final quantity = "ThermalInsulance", final unit = "m2.K/W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalResistance = Real(final quantity = "ThermalResistance", final unit = "K/W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalConductance = Real(final quantity = "ThermalConductance", final unit = "W/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalDiffusivity = Real(final quantity = "ThermalDiffusivity", final unit = "m2/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HeatCapacity = Real(final quantity = "HeatCapacity", final unit = "J/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificHeatCapacity = Real(final quantity = "SpecificHeatCapacity", final unit = "J/(kg.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificHeatCapacityAtConstantPressure = SpecificHeatCapacity annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificHeatCapacityAtConstantVolume = SpecificHeatCapacity annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificHeatCapacityAtSaturation = SpecificHeatCapacity annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RatioOfSpecificHeatCapacities = Real(final quantity = "RatioOfSpecificHeatCapacities", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IsentropicExponent = Real(final quantity = "IsentropicExponent", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Entropy = Real(final quantity = "Entropy", final unit = "J/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificEntropy = Real(final quantity = "SpecificEntropy", final unit = "J/(kg.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type InternalEnergy = Heat annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Enthalpy = Heat annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HelmholtzFreeEnergy = Heat annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GibbsFreeEnergy = Heat annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificEnergy = Real(final quantity = "SpecificEnergy", final unit = "J/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificInternalEnergy = SpecificEnergy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificEnthalpy = SpecificEnergy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificHelmholtzFreeEnergy = SpecificEnergy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificGibbsFreeEnergy = SpecificEnergy annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassieuFunction = Real(final quantity = "MassieuFunction", final unit = "J/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PlanckFunction = Real(final quantity = "PlanckFunction", final unit = "J/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerDensityByEnthalpy = Real(final unit = "kg.s^2/m^5") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerDensityByPressure = Real(final unit = "s^2/m^2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerDensityByTemperature = Real(final unit = "kg/(m^3.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerEnthalpyByPressure = Real(final unit = "J.m.s^2/kg^2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerEnergyByDensity = Real(final unit = "J.m^3/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DerEnergyByPressure = Real(final unit = "J.m.s^2/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricCurrent = Real(final quantity = "ElectricCurrent", final unit = "A") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Current = ElectricCurrent annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricCharge = Real(final quantity = "ElectricCharge", final unit = "C") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Charge = ElectricCharge annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type VolumeDensityOfCharge = Real(final quantity = "VolumeDensityOfCharge", final unit = "C/m3", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SurfaceDensityOfCharge = Real(final quantity = "SurfaceDensityOfCharge", final unit = "C/m2", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricFieldStrength = Real(final quantity = "ElectricFieldStrength", final unit = "V/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricPotential = Real(final quantity = "ElectricPotential", final unit = "V") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Voltage = ElectricPotential annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PotentialDifference = ElectricPotential annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectromotiveForce = ElectricPotential annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricFluxDensity = Real(final quantity = "ElectricFluxDensity", final unit = "C/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricFlux = Real(final quantity = "ElectricFlux", final unit = "C") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Capacitance = Real(final quantity = "Capacitance", final unit = "F", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Permittivity = Real(final quantity = "Permittivity", final unit = "F/m", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PermittivityOfVacuum = Permittivity annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativePermittivity = Real(final quantity = "RelativePermittivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricSusceptibility = Real(final quantity = "ElectricSusceptibility", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricPolarization = Real(final quantity = "ElectricPolarization", final unit = "C/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Electrization = Real(final quantity = "Electrization", final unit = "V/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricDipoleMoment = Real(final quantity = "ElectricDipoleMoment", final unit = "C.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CurrentDensity = Real(final quantity = "CurrentDensity", final unit = "A/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearCurrentDensity = Real(final quantity = "LinearCurrentDensity", final unit = "A/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticFieldStrength = Real(final quantity = "MagneticFieldStrength", final unit = "A/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticPotential = Real(final quantity = "MagneticPotential", final unit = "A") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticPotentialDifference = Real(final quantity = "MagneticPotential", final unit = "A") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagnetomotiveForce = Real(final quantity = "MagnetomotiveForce", final unit = "A") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CurrentLinkage = Real(final quantity = "CurrentLinkage", final unit = "A") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticFluxDensity = Real(final quantity = "MagneticFluxDensity", final unit = "T") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticFlux = Real(final quantity = "MagneticFlux", final unit = "Wb") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticVectorPotential = Real(final quantity = "MagneticVectorPotential", final unit = "Wb/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Inductance = Real(final quantity = "Inductance", final unit = "H") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SelfInductance = Inductance(min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MutualInductance = Inductance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CouplingCoefficient = Real(final quantity = "CouplingCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LeakageCoefficient = Real(final quantity = "LeakageCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Permeability = Real(final quantity = "Permeability", final unit = "H/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PermeabilityOfVacuum = Permeability annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativePermeability = Real(final quantity = "RelativePermeability", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticSusceptibility = Real(final quantity = "MagneticSusceptibility", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectromagneticMoment = Real(final quantity = "ElectromagneticMoment", final unit = "A.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticDipoleMoment = Real(final quantity = "MagneticDipoleMoment", final unit = "Wb.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Magnetization = Real(final quantity = "Magnetization", final unit = "A/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticPolarization = Real(final quantity = "MagneticPolarization", final unit = "T") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectromagneticEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PoyntingVector = Real(final quantity = "PoyntingVector", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Resistance = Real(final quantity = "Resistance", final unit = "Ohm") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Resistivity = Real(final quantity = "Resistivity", final unit = "Ohm.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Conductivity = Real(final quantity = "Conductivity", final unit = "S/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Reluctance = Real(final quantity = "Reluctance", final unit = "H-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Permeance = Real(final quantity = "Permeance", final unit = "H") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PhaseDifference = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Impedance = Resistance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ModulusOfImpedance = Resistance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Reactance = Resistance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type QualityFactor = Real(final quantity = "QualityFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LossAngle = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Conductance = Real(final quantity = "Conductance", final unit = "S") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Admittance = Conductance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ModulusOfAdmittance = Conductance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Susceptance = Conductance annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type InstantaneousPower = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ActivePower = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ApparentPower = Real(final quantity = "Power", final unit = "VA") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReactivePower = Real(final quantity = "Power", final unit = "var") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PowerFactor = Real(final quantity = "PowerFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Transconductance = Real(final quantity = "Transconductance", final unit = "A/(V*V)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type InversePotential = Real(final quantity = "InversePotential", final unit = "1/V") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralRadiantEnergyDensity = Real(final quantity = "SpectralRadiantEnergyDensity", final unit = "J/m4") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantPower = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantEnergyFluenceRate = Real(final quantity = "RadiantEnergyFluenceRate", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantIntensity = Real(final quantity = "RadiantIntensity", final unit = "W/sr") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Radiance = Real(final quantity = "Radiance", final unit = "W/sr.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RadiantExtiance = Real(final quantity = "RadiantExtiance", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Irradiance = Real(final quantity = "Irradiance", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Emissivity = Real(final quantity = "Emissivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralEmissivity = Real(final quantity = "SpectralEmissivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DirectionalSpectralEmissivity = Real(final quantity = "DirectionalSpectralEmissivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LuminousIntensity = Real(final quantity = "LuminousIntensity", final unit = "cd") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LuminousFlux = Real(final quantity = "LuminousFlux", final unit = "lm") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type QuantityOfLight = Real(final quantity = "QuantityOfLight", final unit = "lm.s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Luminance = Real(final quantity = "Luminance", final unit = "cd/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LuminousExitance = Real(final quantity = "LuminousExitance", final unit = "lm/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Illuminance = Real(final quantity = "Illuminance", final unit = "lx") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LightExposure = Real(final quantity = "LightExposure", final unit = "lx.s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LuminousEfficacy = Real(final quantity = "LuminousEfficacy", final unit = "lm/W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralLuminousEfficacy = Real(final quantity = "SpectralLuminousEfficacy", final unit = "lm/W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LuminousEfficiency = Real(final quantity = "LuminousEfficiency", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralLuminousEfficiency = Real(final quantity = "SpectralLuminousEfficiency", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CIESpectralTristimulusValues = Real(final quantity = "CIESpectralTristimulusValues", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ChromaticityCoordinates = Real(final quantity = "CromaticityCoordinates", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralAbsorptionFactor = Real(final quantity = "SpectralAbsorptionFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralReflectionFactor = Real(final quantity = "SpectralReflectionFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralTransmissionFactor = Real(final quantity = "SpectralTransmissionFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralRadianceFactor = Real(final quantity = "SpectralRadianceFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearAttenuationCoefficient = Real(final quantity = "AttenuationCoefficient", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearAbsorptionCoefficient = Real(final quantity = "LinearAbsorptionCoefficient", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarAbsorptionCoefficient = Real(final quantity = "MolarAbsorptionCoefficient", final unit = "m2/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RefractiveIndex = Real(final quantity = "RefractiveIndex", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StaticPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundPressure = StaticPressure annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundParticleDisplacement = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundParticleVelocity = Real(final quantity = "Velocity", final unit = "m/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundParticleAcceleration = Real(final quantity = "Acceleration", final unit = "m/s2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type VelocityOfSound = Real(final quantity = "Velocity", final unit = "m/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundPower = Real(final quantity = "Power", final unit = "W") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundIntensity = Real(final quantity = "SoundIntensity", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AcousticImpedance = Real(final quantity = "AcousticImpedance", final unit = "Pa.s/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificAcousticImpedance = Real(final quantity = "SpecificAcousticImpedance", final unit = "Pa.s/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MechanicalImpedance = Real(final quantity = "MechanicalImpedance", final unit = "N.s/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundPressureLevel = Real(final quantity = "SoundPressureLevel", final unit = "dB") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundPowerLevel = Real(final quantity = "SoundPowerLevel", final unit = "dB") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DissipationCoefficient = Real(final quantity = "DissipationCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReflectionCoefficient = Real(final quantity = "ReflectionCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TransmissionCoefficient = Real(final quantity = "TransmissionCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AcousticAbsorptionCoefficient = Real(final quantity = "AcousticAbsorptionCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SoundReductionIndex = Real(final quantity = "SoundReductionIndex", final unit = "dB") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EquivalentAbsorptionArea = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReverberationTime = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LoundnessLevel = Real(final quantity = "LoundnessLevel", final unit = "phon") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Loundness = Real(final quantity = "Loundness", final unit = "sone") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativeAtomicMass = Real(final quantity = "RelativeAtomicMass", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativeMolecularMass = Real(final quantity = "RelativeMolecularMass", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NumberOfMolecules = Real(final quantity = "NumberOfMolecules", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AmountOfSubstance = Real(final quantity = "AmountOfSubstance", final unit = "mol", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarMass = Real(final quantity = "MolarMass", final unit = "kg/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarVolume = Real(final quantity = "MolarVolume", final unit = "m3/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarInternalEnergy = Real(final quantity = "MolarInternalEnergy", final unit = "J/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarHeatCapacity = Real(final quantity = "MolarHeatCapacity", final unit = "J/(mol.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarEntropy = Real(final quantity = "MolarEntropy", final unit = "J/(mol.K)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NumberDensityOfMolecules = Real(final quantity = "NumberDensityOfMolecules", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolecularConcentration = Real(final quantity = "MolecularConcentration", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassConcentration = Real(final quantity = "MassConcentration", final unit = "kg/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassFraction = Real(final quantity = "MassFraction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Concentration = Real(final quantity = "Concentration", final unit = "mol/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type VolumeFraction = Real(final quantity = "VolumeFraction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MoleFraction = Real(final quantity = "MoleFraction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ChemicalPotential = Real(final quantity = "ChemicalPotential", final unit = "J/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AbsoluteActivity = Real(final quantity = "AbsoluteActivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PartialPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Fugacity = Real(final quantity = "Fugacity", final unit = "Pa") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StandardAbsoluteActivity = Real(final quantity = "StandardAbsoluteActivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ActivityCoefficient = Real(final quantity = "ActivityCoefficient", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ActivityOfSolute = Real(final quantity = "ActivityOfSolute", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ActivityCoefficientOfSolute = Real(final quantity = "ActivityCoefficientOfSolute", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StandardAbsoluteActivityOfSolute = Real(final quantity = "StandardAbsoluteActivityOfSolute", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ActivityOfSolvent = Real(final quantity = "ActivityOfSolvent", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type OsmoticCoefficientOfSolvent = Real(final quantity = "OsmoticCoefficientOfSolvent", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StandardAbsoluteActivityOfSolvent = Real(final quantity = "StandardAbsoluteActivityOfSolvent", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type OsmoticPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0) annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StoichiometricNumber = Real(final quantity = "StoichiometricNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Affinity = Real(final quantity = "Affinity", final unit = "J/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassOfMolecule = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricDipoleMomentOfMolecule = Real(final quantity = "ElectricDipoleMomentOfMolecule", final unit = "C.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectricPolarizabilityOfAMolecule = Real(final quantity = "ElectricPolarizabilityOfAMolecule", final unit = "C.m2/V") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MicrocanonicalPartitionFunction = Real(final quantity = "MicrocanonicalPartitionFunction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CanonicalPartitionFunction = Real(final quantity = "CanonicalPartitionFunction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GrandCanonicalPartitionFunction = Real(final quantity = "GrandCanonicalPartitionFunction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolecularPartitionFunction = Real(final quantity = "MolecularPartitionFunction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StatisticalWeight = Real(final quantity = "StatisticalWeight", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MeanFreePath = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DiffusionCoefficient = Real(final quantity = "DiffusionCoefficient", final unit = "m2/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalDiffusionRatio = Real(final quantity = "ThermalDiffusionRatio", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalDiffusionFactor = Real(final quantity = "ThermalDiffusionFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalDiffusionCoefficient = Real(final quantity = "ThermalDiffusionCoefficient", final unit = "m2/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElementaryCharge = Real(final quantity = "ElementaryCharge", final unit = "C") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ChargeNumberOfIon = Real(final quantity = "ChargeNumberOfIon", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FaradayConstant = Real(final quantity = "FaradayConstant", final unit = "C/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IonicStrength = Real(final quantity = "IonicStrength", final unit = "mol/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DegreeOfDissociation = Real(final quantity = "DegreeOfDissociation", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectrolyticConductivity = Real(final quantity = "ElectrolyticConductivity", final unit = "S/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarConductivity = Real(final quantity = "MolarConductivity", final unit = "S.m2/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TransportNumberOfIonic = Real(final quantity = "TransportNumberOfIonic", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ProtonNumber = Real(final quantity = "ProtonNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronNumber = Real(final quantity = "NeutronNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NucleonNumber = Real(final quantity = "NucleonNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AtomicMassConstant = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassOfElectron = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassOfProton = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassOfNeutron = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HartreeEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticMomentOfParticle = Real(final quantity = "MagneticMomentOfParticle", final unit = "A.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BohrMagneton = MagneticMomentOfParticle annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NuclearMagneton = MagneticMomentOfParticle annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GyromagneticCoefficient = Real(final quantity = "GyromagneticCoefficient", final unit = "A.m2/(J.s)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GFactorOfAtom = Real(final quantity = "GFactorOfAtom", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GFactorOfNucleus = Real(final quantity = "GFactorOfNucleus", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LarmorAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NuclearPrecessionAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CyclotronAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NuclearQuadrupoleMoment = Real(final quantity = "NuclearQuadrupoleMoment", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NuclearRadius = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectronRadius = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ComptonWavelength = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassExcess = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassDefect = Real(final quantity = "Mass", final unit = "kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativeMassExcess = Real(final quantity = "RelativeMassExcess", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelativeMassDefect = Real(final quantity = "RelativeMassDefect", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PackingFraction = Real(final quantity = "PackingFraction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BindingFraction = Real(final quantity = "BindingFraction", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MeanLife = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LevelWidth = Real(final quantity = "LevelWidth", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Activity = Real(final quantity = "Activity", final unit = "Bq") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificActivity = Real(final quantity = "SpecificActivity", final unit = "Bq/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DecayConstant = Real(final quantity = "DecayConstant", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HalfLife = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AlphaDisintegrationEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MaximumBetaParticleEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BetaDisintegrationEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReactionEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ResonanceEnergy = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CrossSection = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalCrossSection = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AngularCrossSection = Real(final quantity = "AngularCrossSection", final unit = "m2/sr") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralCrossSection = Real(final quantity = "SpectralCrossSection", final unit = "m2/J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralAngularCrossSection = Real(final quantity = "SpectralAngularCrossSection", final unit = "m2/(sr.J)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MacroscopicCrossSection = Real(final quantity = "MacroscopicCrossSection", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalMacroscopicCrossSection = Real(final quantity = "TotalMacroscopicCrossSection", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ParticleFluence = Real(final quantity = "ParticleFluence", final unit = "m-2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ParticleFluenceRate = Real(final quantity = "ParticleFluenceRate", final unit = "s-1.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnergyFluence = Real(final quantity = "EnergyFluence", final unit = "J/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnergyFluenceRate = Real(final quantity = "EnergyFluenceRate", final unit = "W/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CurrentDensityOfParticles = Real(final quantity = "CurrentDensityOfParticles", final unit = "m-2.s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassAttenuationCoefficient = Real(final quantity = "MassAttenuationCoefficient", final unit = "m2/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MolarAttenuationCoefficient = Real(final quantity = "MolarAttenuationCoefficient", final unit = "m2/mol") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AtomicAttenuationCoefficient = Real(final quantity = "AtomicAttenuationCoefficient", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HalfThickness = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalLinearStoppingPower = Real(final quantity = "TotalLinearStoppingPower", final unit = "J/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalAtomicStoppingPower = Real(final quantity = "TotalAtomicStoppingPower", final unit = "J.m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalMassStoppingPower = Real(final quantity = "TotalMassStoppingPower", final unit = "J.m2/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MeanLinearRange = Real(final quantity = "Length", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MeanMassRange = Real(final quantity = "MeanMassRange", final unit = "kg/m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearIonization = Real(final quantity = "LinearIonization", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalIonization = Real(final quantity = "TotalIonization", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Mobility = Real(final quantity = "Mobility", final unit = "m2/V.s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IonNumberDensity = Real(final quantity = "IonNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RecombinationCoefficient = Real(final quantity = "RecombinationCoefficient", final unit = "m3/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronNumberDensity = Real(final quantity = "NeutronNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronSpeed = Real(final quantity = "Velocity", final unit = "m/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronFluenceRate = Real(final quantity = "NeutronFluenceRate", final unit = "s-1.m-2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type TotalNeutronSourceDensity = Real(final quantity = "TotalNeutronSourceDesity", final unit = "s-1.m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SlowingDownDensity = Real(final quantity = "SlowingDownDensity", final unit = "s-1.m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ResonanceEscapeProbability = Real(final quantity = "ResonanceEscapeProbability", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Lethargy = Real(final quantity = "Lethargy", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SlowingDownArea = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DiffusionArea = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MigrationArea = Real(final quantity = "Area", final unit = "m2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SlowingDownLength = Real(final quantity = "SLength", final unit = "m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DiffusionLength = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MigrationLength = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronYieldPerFission = Real(final quantity = "NeutronYieldPerFission", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeutronYieldPerAbsorption = Real(final quantity = "NeutronYieldPerAbsorption", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FastFissionFactor = Real(final quantity = "FastFissionFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermalUtilizationFactor = Real(final quantity = "ThermalUtilizationFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NonLeakageProbability = Real(final quantity = "NonLeakageProbability", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Reactivity = Real(final quantity = "Reactivity", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReactorTimeConstant = Real(final quantity = "Time", final unit = "s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EnergyImparted = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MeanEnergyImparted = Real(final quantity = "Energy", final unit = "J") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpecificEnergyImparted = Real(final quantity = "SpecificEnergy", final unit = "Gy") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AbsorbedDose = Real(final quantity = "AbsorbedDose", final unit = "Gy") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DoseEquivalent = Real(final quantity = "DoseEquivalent", final unit = "Sv") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AbsorbedDoseRate = Real(final quantity = "AbsorbedDoseRate", final unit = "Gy/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LinearEnergyTransfer = Real(final quantity = "LinearEnergyTransfer", final unit = "J/m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Kerma = Real(final quantity = "Kerma", final unit = "Gy") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type KermaRate = Real(final quantity = "KermaRate", final unit = "Gy/s") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MassEnergyTransferCoefficient = Real(final quantity = "MassEnergyTransferCoefficient", final unit = "m2/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type Exposure = Real(final quantity = "Exposure", final unit = "C/kg") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ExposureRate = Real(final quantity = "ExposureRate", final unit = "C/(kg.s)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ReynoldsNumber = Real(final quantity = "ReynoldsNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EulerNumber = Real(final quantity = "EulerNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FroudeNumber = Real(final quantity = "FroudeNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GrashofNumber = Real(final quantity = "GrashofNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type WeberNumber = Real(final quantity = "WeberNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MachNumber = Real(final quantity = "MachNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type KnudsenNumber = Real(final quantity = "KnudsenNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StrouhalNumber = Real(final quantity = "StrouhalNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FourierNumber = Real(final quantity = "FourierNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PecletNumber = Real(final quantity = "PecletNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RayleighNumber = Real(final quantity = "RayleighNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NusseltNumber = Real(final quantity = "NusseltNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BiotNumber = NusseltNumber annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StantonNumber = Real(final quantity = "StantonNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FourierNumberOfMassTransfer = Real(final quantity = "FourierNumberOfMassTransfer", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PecletNumberOfMassTransfer = Real(final quantity = "PecletNumberOfMassTransfer", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GrashofNumberOfMassTransfer = Real(final quantity = "GrashofNumberOfMassTransfer", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NusseltNumberOfMassTransfer = Real(final quantity = "NusseltNumberOfMassTransfer", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type StantonNumberOfMassTransfer = Real(final quantity = "StantonNumberOfMassTransfer", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PrandtlNumber = Real(final quantity = "PrandtlNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SchmidtNumber = Real(final quantity = "SchmidtNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LewisNumber = Real(final quantity = "LewisNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MagneticReynoldsNumber = Real(final quantity = "MagneticReynoldsNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AlfvenNumber = Real(final quantity = "AlfvenNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HartmannNumber = Real(final quantity = "HartmannNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CowlingNumber = Real(final quantity = "CowlingNumber", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type BraggAngle = Angle annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type OrderOfReflexion = Real(final quantity = "OrderOfReflexion", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ShortRangeOrderParameter = Real(final quantity = "RangeOrderParameter", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LongRangeOrderParameter = Real(final quantity = "RangeOrderParameter", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DebyeWallerFactor = Real(final quantity = "DebyeWallerFactor", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CircularWavenumber = Real(final quantity = "CircularWavenumber", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FermiCircularWavenumber = Real(final quantity = "FermiCircularWavenumber", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DebyeCircularWavenumber = Real(final quantity = "DebyeCircularWavenumber", final unit = "m-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DebyeCircularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DebyeTemperature = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SpectralConcentration = Real(final quantity = "SpectralConcentration", final unit = "s/m3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GrueneisenParameter = Real(final quantity = "GrueneisenParameter", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MadelungConstant = Real(final quantity = "MadelungConstant", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DensityOfStates = Real(final quantity = "DensityOfStates", final unit = "J-1/m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ResidualResistivity = Real(final quantity = "ResidualResistivity", final unit = "Ohm.m") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LorenzCoefficient = Real(final quantity = "LorenzCoefficient", final unit = "V2/K2") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HallCoefficient = Real(final quantity = "HallCoefficient", final unit = "m3/C") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThermoelectromotiveForce = Real(final quantity = "ThermoelectromotiveForce", final unit = "V") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type SeebeckCoefficient = Real(final quantity = "SeebeckCoefficient", final unit = "V/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type PeltierCoefficient = Real(final quantity = "PeltierCoefficient", final unit = "V") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ThomsonCoefficient = Real(final quantity = "ThomsonCoefficient", final unit = "V/K") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RichardsonConstant = Real(final quantity = "RichardsonConstant", final unit = "A/(m2.K2)") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FermiEnergy = Real(final quantity = "Energy", final unit = "eV") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type GapEnergy = Real(final quantity = "Energy", final unit = "eV") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DonorIonizationEnergy = Real(final quantity = "Energy", final unit = "eV") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AcceptorIonizationEnergy = Real(final quantity = "Energy", final unit = "eV") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FermiTemperature = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ElectronNumberDensity = Real(final quantity = "ElectronNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type HoleNumberDensity = Real(final quantity = "HoleNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type IntrinsicNumberDensity = Real(final quantity = "IntrinsicNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type DonorNumberDensity = Real(final quantity = "DonorNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type AcceptorNumberDensity = Real(final quantity = "AcceptorNumberDensity", final unit = "m-3") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type EffectiveMass = Mass annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type MobilityRatio = Real(final quantity = "MobilityRatio", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type RelaxationTime = Time annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CarrierLifeTime = Time annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type ExchangeIntegral = Real(final quantity = "Energy", final unit = "eV") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CurieTemperature = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type NeelTemperature = ThermodynamicTemperature annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LondonPenetrationDepth = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type CoherenceLength = Length annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type LandauGinzburgParameter = Real(final quantity = "LandauGinzburgParameter", final unit = "1") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     type FluxiodQuantum = Real(final quantity = "FluxiodQuantum", final unit = "Wb") annotation(Icon(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100,100},{100, -100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//     defineunit m;
//     defineunit kg;
//     defineunit s;
//     defineunit A;
//     defineunit K;
//     defineunit mol;
//     defineunit cd;
//     defineunit rad (exp = "m/m");
//     defineunit sr (exp = "m2/m2");
//     defineunit Hz (exp = "s-1", weight = 0.8);
//     defineunit N (exp = "m.kg.s-2");
//     defineunit Pa (exp = "N/m2");
//     defineunit W (exp = "J/s");
//     defineunit J (exp = "N.m");
//     defineunit C (exp = "s.A");
//     defineunit V (exp = "W/A");
//     defineunit F (exp = "C/V");
//     defineunit Ohm (exp = "V/A");
//     defineunit S (exp = "A/V");
//     defineunit Wb (exp = "V.s");
//     defineunit S (exp = "A/V");
//     defineunit Wb (exp = "V.s");
//     defineunit T (exp = "Wb/m2");
//     defineunit H (exp = "Wb/A");
//     defineunit lm (exp = "cd.sr");
//     defineunit lx (exp = "lm/m2");
//     defineunit Bq (exp = "s-1");
//     defineunit Gy (exp = "J/kg");
//     defineunit Sv (exp = "J/kg");
//     defineunit kat (exp = "s-1.mol");
//   end SIunits;
//   package StateGraph "Library to model discrete event and reactive systems by hierarchical state machines"
//     extends Modelica.Icons.Library2;
//     annotation(version = "0.87", versionDate = "2004-06-23", preferedView = "info", Documentation(info = "<html>
// <p>
// Library <b>StateGraph</b> is a <b>free</b> Modelica package providing
// components to model <b>discrete event</b> and <b>reactive</b>
// systems in a convenient
// way. It is based on the JGraphChart method and
// takes advantage of Modelica features for
// the \"action\" language. JGraphChart is a further development of 
// Grafcet to include elements of StateCharts that are not present
// in Grafcet/Sequential Function Charts. Therefore, the StateGraph
// library has a similar modeling power as StateCharts but avoids
// some deficiences of StateCharts.
// </p>
// <p>
// For an introduction, have especially a look at:
// </p>
// <ul>
// <li> <a href=\"Modelica:Modelica.StateGraph.UsersGuide\">StateGraph.UsersGuide</a>
//      discusses the most important aspects how to use this library.</li>
// <li> <a href=\"Modelica:Modelica.StateGraph.Examples\">StateGraph.Examples</a>
//      contains examples that demonstrate the usage of this library.</li>
// </ul>
// <p>
// A typical model generated with this library is shown
// in the next figure where on the left hand side a two-tank 
// system with a tank controller and on the right hand side the
// top-level part of the tank controller as a StateGraph is shown:
// </p>
// <p>
// <img src=\"Images/StateGraph/Examples/ControlledTanks1_small.png\"> 
// <img src=\"Images/StateGraph/Examples/ControlledTanks2_small.png\">
// </p>
// <p>
// The unique feature of the StateGraph library with respect to JGraphCharts,
// Grafcet, Sequential Function Charts, and StateCharts, is Modelica's
// \"single assignment rule\" that requires that every variable is defined
// by exactly one equation. This leads to a different \"action\" definition
// as in these formalisms. The advantage is that the translator can either
// determine a useful evaluation sequence by equation sorting or
// reports an error if this is not possible, e.g., because a model
// would lead to a non-determinism or to a dead-lock. As a side effect,
// this leads also to simpler and more easier to understand models and
// global variables are no longer needed (whereas in JGraphCharts,
// Grafcet, Sequential Function Charts and StateCharts global variables
// are nearly always needed).
// </p>
// <p>
// The StateGraph library is currently available in a beta release.
// The available components will most likely not be changed for the
// release version. It is planned to improve the convenience of
// building models with the StateGraph library for the release version
// (this may require to introduce some additional annotations).
// It is planned to include the StateGraph library in the
// Modelica standard library.
// It is most useful to combine this libray with the Modelica libraries
// </p>
// <ul>
// <li><b>Modelica.Blocks.Logical</b> that provides  
//     components available in PLCs (programmable logic controllers). </li>
// <li><b>UserInteraction</b> that provides components to 
//     interactively communicate with models in a running simulation.</li>
// </ul>
// 
// <p>
// Copyright &copy; 1998-2006, Modelica Association and DLR
// </p>
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// 
// </HTML>
// ", revisions = ""), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -88, -20},{ -50, -54}}, lineColor = {0,0,0}),Line(points = {{ -50, -38},{ -24, -38}}, color = {0,0,0}),Polygon(points = {{ -24, -32},{ -12, -38},{ -24, -44},{ -24, -32}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0}),Line(points = {{ -12, -6},{ -12, -76}}, color = {0,0,0}),Line(points = {{ -12, -38},{14, -38}}, color = {0,0,0}),Polygon(points = {{14, -32},{26, -38},{14, -44},{14, -32}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0}),Rectangle(extent = {{26, -22},{64, -56}}, lineColor = {0,0,0})}));
//     package UsersGuide "Users Guide"
//       annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Users Guide of package StateGraph</font></h3>
// <p>
// Library <b>StateGraph</b> is a <b>free</b> Modelica package providing
// components to model <b>discrete event</b> and <b>reactive</b> 
// systems in a convenient
// way. This package contains the <b>users guide</b> for 
// the library and has the following content:
// </p>
// <ol>
// <li><a href=\"Modelica://Modelica.StateGraph.UsersGuide.OverView\">Overview of library</a>
//      gives an overview of the library.</li>
// <li> <a href=\"Modelica://Modelica.StateGraph.UsersGuide.FirstExample\">A first example</a>
//      demonstrates at hand of a first example how to use this library.</li>
// <li> <a href=\"Modelica://Modelica.StateGraph.UsersGuide.ApplicationExample\">An 
//      application example</a> demonstrates varies features at hand of the
//      control of a two tank system.</li>
// <li><a href=\"Modelica://Modelica.StateGraph.UsersGuide.ReleaseNotes\">Release Notes</a>
//     summarizes the differences between different versions of this library.</li>
// <li><a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">Literature</a>
//     provides references that have been used to design and implement this 
//     library.</li>
// <li><a href=\"Modelica://Modelica.StateGraph.UsersGuide.Contact\">Contact</a> 
//     provides information about the authors of the library as well as
//     acknowledgments.</li>
// </ol>
// </html>"));
//       class OverView "Overview of library"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Overview of Library StateGraph</font></h3>
// <p>
// In this section, an overview of the most important features
// of this library is given.
// </p>
// <h4><font color=\"#008000\">Steps and Transitions</font></h4>
// <p>
// A <b>StateGraph</b> is an enhanced finite state machine.
// It is based on the JGraphChart method and
// takes advantage of Modelica features for
// the \"action\" language. JGraphChart is a further development of 
// Grafcet to include elements of StateCharts that are not present
// in Grafcet/Sequential Function Charts. Therefore, the StateGraph
// library has a similar modeling power as StateCharts but avoids
// some deficiences of StateCharts.
// </p>
// <p>
// The basic elements of StateGraphs are <b>steps</b> and <b>transitions</b>:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/StepAndTransition1.png\">
// </p>
// <p>
// <b>Steps</b> represent the possible states a StateGraph can have.
// If a step is active the Boolean variable <b>active</b> of
// the step is <b>true</b>. If it is deactivated,
// <b>active</b> = <b>false</b>. At the initial time, all \"usual\"
// steps are deactivated. The <b>InitialStep</b> objects are steps
// that are activated at the initial time. They are characterized
// by a double box (see figure above).
// </p>
// <p>
// <b>Transitions</b> are used to change the state of a StateGraph.
// When the step connected to the input of a transition is active,
// the step connected to the output of this transition is deactivated
// and the transition condition becomes true, then the
// transition fires. This means that the step connected to the input to the
// transition is deactivated and the step connected to the output
// of the transition is activated.
// </p>
// <p>
// The transition <b>condition</b> is defined via the <i>Variables</i> tab
// when selecting the transition object. Clicking on object \"transition1\" in
// the above figure, results in the following window:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/StepAndTransition2.png\">
// </p>
// <p>
// In the input field <i>Values</i> for \"<b>condition</b>\", any type of time varying
// Boolean expression can be given (in Modelica notation, this is
// a modification of the time varying variable <b>condition</b>).
// Whenever this condition is true, the transition can fire.
// Additionally, it is possible to activate a timer, via
// <b>enableTimer</b> (see Parameters window) and provide a 
// <b>waitTime</b>. In this case the firing of the transition
// is delayed according to the provided waitTime. The transition
// condition and the waitTime are displayed in the transition icon.
// </p>
// <p>
// In the above example, the simulation starts at <b>initialStep</b>.
// After 1 second, <b>transition1</b> fires and <b>step1</b> becomes
// active. After another second <b>transition2</b> fires and
// <b>initialStep</b> becomes again active. After a further
// second <b>step1</b> becomes again active, and so on.
// </p>
// <p>
// In JGrafcharts, Grafcet and Sequential Function Charts, the
// network of steps and transitions is drawn from top to bottom.
// In StateGraphs, no particular direction is defined, since 
// steps and transitions are blocks with input and output connectors
// that can be arbitrarily placed and connected. Usually, it is 
// most practical to define the network from left to right,
// as in the example above, since then it is easy to read the
// labels on the icons.
// </p>
// <h4><font color=\"#008000\">Conditions and Actions</font></h4>
// <p>
// With the block <b>TransitionWithSignal</b>, the firing condition
// can be provided as Boolean input signal, instead as entry in the
// menu of the transition. An example is given in the next
// figure:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/StepAndTransition3.png\">
// </p>
// <p>
// Component \"step\" is an instance of \"StepWithSignal\" that is
// a usual step where the active flag is available as Boolean
// output signal. To this output, component \"Timer\" from
// library \"Modelica.Blocks.Logical\" is connected. It measures the
// time from the time instant where the Boolean input (i.e., the
// active flag of the step) became true upto the current
// time instant. The timer is connected to a comparison
// component. The output is true, once the timer reaches
// 1 second. This signal is used as condition input of the
// transition. As a result, \"transition2\" fires, once step
// \"step\" has been active for 1 second.
// Of course, any other
// Modelica block with a Boolean output signal can be 
// connected to the condition input of such a transition block
// as well.
// </p>
// <p>
// Conditions of a transition can either be computed by
// a network of logical blocks from the Logical library as
// in the figure above, or via the \"SetBoolean\" component
// any type of logical expression can be defined in textual
// form, as shown in the next figure:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/StepAndTransition4.png\">
// </p>
// <p>
// With the block \"<b>SetBoolean</b>\", a time varying expression
// can be provided as modification to the output signal <b>y</b>
// (see block with icon text \"timer.y > 1\" in the figure above).
// The output signal can be in turn connected to the condition 
// input of a TransitionWithSignal block. 
// </p>
// <p>
// The \"<b>SetBoolean</b>\" block can also be used to
// compute a Boolean signal depending on the active step.
// In the figure above, the output of the block with the 
// icon text \"step.active\" is 
// true, when \"step\" is active, otherwise it is false
// (note, the icon text of \"SetBoolean\" displays the modification
// of the output signal \"y\").
// This signal can then be used to compute desired <b>actions</b> 
// in the physical systems model. For example, if a <b>valve</b>
// shall be open, when the StateGraph is in \"step1\" or
// in \"step4\", a \"SetBoolean\" block may be connected to the
// valve model using the following condition:
// </p>
// <pre>
//     valve = step1.active <b>or</b> step2.active
// </pre> 
// <p>
// Via the Modelica operators <b>edge</b>(..) and <b>change</b>(..),
// conditions depending on rising and falling edges of 
// Boolean expressions can be used when needed.
// </p>
// <p>
// In JGrafcharts, Grafcet, Sequential Function Charts and StateCharts,
// <b>actions</b> are formulated <b>within a step</b>. Such actions are 
// distinguished as <b>entry</b>, <b>normal</b>, <b>exit</b> and 
// <b>abort</b> actions. For example, a valve might be opened by
// an entry action of a step and might be closed by an exit
// action of the same step. In StateGraphs, this is (fortunately) 
// <b>not possible</b>
// due to Modelicas \"single assignment rule\" that requires that every
// variable is defined by exactly one equation. Instead, the
// approach explained above is used. For example, via the
// \"SetBoolean\" component, the valve variable is set to true
// when the StateGraph is in particular steps.
// </p>
// <p>
// This feature of a StateGraph is <b>very useful</b>, since it allows
// a Modelica translator to <b>guarantee</b> that a given StateGraph
// has always <b>deterministic</b> behaviour without conflicts.
// In the other methodologies this is much more cumbersome. For example,
// if two steps are executed in parallel and both step actions
// modify the same variable, the result is either non-deterministic
// or non-obvious rules have to be defined which action
// takes priority. In a StateGraph, such a situation is detected by
// the translator resulting in an error, since there are two equations
// to compute one variable. Additional benefits of the StateGraph
// approach are:
// </p>
// <ul>
// <li> A JGrafchart or a StateChart need to potentially access
//      variables in a step that are defined in 
//      higher hierarchical levels of a model. Therefore, mostly <b>global
//      variables</b> are used in the whole network, even if the
//      network is structured hierarchically. In StateGraphs this
//      is not necessary, since the physical systems outside
//      of a StateGraph might access the step or transition state
//      via a hierarchical name. This means that <b>no global variables</b>
//      are needed, because the local variables in the StateGraph
//      are accessed from local variables outside of the StateGraph. 
//      </li>
// <li> It is simpler for a user to understand the information that
//      is provided in the non-graphical definition, since every
//      variable is defined at exactly one place. In the other
//      methodologies, the setting and re-setting of the same
//      variable is cluttered within the whole network.
//     </li>
// </ul>
// <p>
// To emphasize this important difference between these methodologies,
// consider the case that a state machine has the following
// hierarchy:
// </p>
// <pre>
//    stateMachine.superstate1.superstate2.step1
// </pre>
// <p>
// Within \"step1\" a StateChart would, e.g., access variable
// \"stateMachine.openValve\", say as \"entry action: openValve = true\".
// This typical usage has the severe drawback that it is not possible
// to use the hierarchical state \"superstate1\" as component in another
// context, because \"step1\" references a particular name outside of this
// component. 
// </p>
// <p>
// In a StateGraph, there would be typically a \"SetBoolean\" component
// in the \"stateMachine\" component stating:
// </p>
// <pre>
//     openValve = superstate1.superstate2.step1.active;
// </pre>
// <p>
// As a result, the \"superstate1\" component can be used in 
// another context, because it does not depend on the environment
// where it is used.
// </p>
// <h4><font color=\"#008000\">Execution Model</font></h4>
// <p>
// The execution model of a StateGraph follows from its
// Modelica implementation: Given the states of all steps, i.e., 
// whether a step is active or not active, the equations of all
// steps, transitions, transition conditions, actions etc. are
// sorted resulting in an execution sequence to compute 
// essentially the new values of the steps. If conflicts occur,
// e.g., if there are more equations as variables, of if there
// are algebraic loops between Boolean variables, an exception
// is raised. Once all equations have been processed, the
// <b>active</b> variable of all steps are updated to the newly
// calculated values. Afterwards, the equations are again 
// evaluated. The iteration stops, once no step changes
// its state anymore, i.e., once no transition fires anymore.
// Then, simulation continuous until a new event is triggered,
// (when a relation changes its value).
// </p>
// <p>
// With the Modelica \"sampled(..)\" operator, a StateGraph might also
// be executed within a discrete controller that is called
// at regular time instants. In a future version of the StateGraph
// library, this might be more directly supported.
// </p>
// <h4><font color=\"#008000\">Parallel and Alternative Execution</font></h4>
// <p>
// Parallel activities can be defined by 
// component <b>Parallel</b> and alternative activities
// can be defined by component <b>Alternative</b>.
// An example for both components is given in the next figure.
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/Parallel1.png\">
// </p>
// <p>
// Here, the branch from \"step2\" to \"step5\" is executed in parallel
// to \"step1\". A transition connected to the output of a parallel 
// branch component can only fire if the final steps
// in all parallel branches are active simultaneously.
// </p>
// <p>
// The three branches within \"step2\" to \"step5\" are 
// executed alternatively, depending which transition condition
// of \"transition3\", \"transition4\", \"transition4a\" fires first.
// Since all three transitions fire after 1 second, they are all
// candidates for the active branch. If two or more transitions
// would fire at the same time instant, a priority selection
// is made: The alternative and parallel components have a
// vector of connectors. Every branch has to be connected to
// exactly one entry of the connector vector. The entry with
// the lowest number has the highest priority.
// </p>
// <p>
// Parallel, Alternative and Step components have vectors of
// connectors. The dimensions of these vectors are set in the
// corresponding Parameter window. E.g. in a \"Parallel\" component:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/Parallel2.png\">
// </p>
// <p>
// Currently in MathModelica the following menu pops up, when a branch
// is connected to a vector of components in order to define
// the vector index to which the component shall be connected:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/Parallel3.png\">
// </p>
// <h4><font color=\"#008000\">CompositeSteps, Suspend and Resume Port</font></h4>
// <p>
// A StateGraph can be hierarchically structured by using a <b>CompositeStep</b>.
// This is a component that inherits from <b>PartialCompositeStep</b>.
// An example is given in the next figure (from Examples.ControlledTanks):
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/UsersGuide/CompositeStep1.png\">
// </p>
// <p>
// The CompositeStep component contains a local StateGraph that is
// entered by one or more input transitions and that is left
// by one or more output transitions. Also, other needed signals
// may enter a CompositeStep. The CompositeStep has similiar properties
// as a \"usual\" step: The CompositeStep is <b>active</b> once at least
// one step within the CompositeStep is active. Variable <b>active</b>
// defines the state of the CompositeStep.
// </p>
// <p>
// Additionally, a CompositeStep has a <b>suspend</b> port. Whenever the
// transition connected to this port fires, the CompositeStep is left
// at once. When leaving the CompositeStep via the suspend port, the internal
// state of the CompositeStep is saved, i.e., the active flags of all
// steps within the CompositeStep. The CompositeStep might be entered via
// its <b>resume</b> port. In this case the internal state from the
// suspend transition is reconstructed and the CompositeStep continues
// the execution that it had before the suspend transition fired
// (this corresponds to the history ports of StateCharts or JGrafCharts).
// </p>
// <p>
// A CompositeStep may contain other CompositeSteps. At every level,
// a CompositeStep and all of its content can be left via its suspend ports 
// (actually, there
// is a vector of suspend connectors, i.e., a CompositeStep might
// be aborted due to different transitions).
// </p>
// </html>
// ", revisions = ""));
//       end OverView;
//       class FirstExample "A first example"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>A first example</font></h3>
// <p>
// A first example will be given here (not yet done).
// </p>
// </html>
// "));
//       end FirstExample;
//       class ApplicationExample "An application example"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>An application example</font></h3>
// <p>
// In this section a more realistic, still simple, application example
// is given, to demonstrate various features of the StateGraph library.
// This example shows the control of a two tank system from the master thesis 
// of Isolde Dressler
// (<a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">see literature</a>).
// </p>
// <p>
// In the following figure the top level of the model is shown.
// This model is available as StateGraph.Examples.ControlledTanks.
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/Examples/ControlledTanks1.png\">
// </p>
// <p>
// In the right part of the figure, two tanks are shown. At the top part,
// a large fluid source is present from which fluid can be filled in 
// <b>tank1</b> when <b>valve1</b> is open. Tank1 can be emptied via
// <b>valve2</b> that is located in the bottom of tank2 and
// fills a second <b>tank2</b> which in turn is emptied via 
// <b>valve3</b>. The actual levels of the tanks are measured
// and are provided as signals <b>level1</b> and <b>level2</b>
// to the <b>tankController</b>.
// </p>
// <p>
// The <b>tankController</b> is controlled by three buttons, 
// <b>start</b>, <b>stop</b> and <b>shut</b> (for shutdown)
// that are mutually exclusive. This means that whenever one button is
// pressed (i.e., its state is <b>true</b>) then the other two
// buttons are not pressed (i.e., their states are <b>false</b>).
// When button <b>start</b> is pressed, the \"normal\" operation
// to fill and to empty the two tanks is processed:
// </p>
// <ol>
// <li> Valve 1 is opened and tank 1 is filled.</li>
// <li> When tank 1 reaches its fill level limit, 
//      valve 1 is closed. </li>
// <li> After a waiting time, valve 2 is
//      opened and the fluid flows from tank 1 into tank 2.</li>
// <li> When tank 1 is empty, valve 2 is closed. </li>
// <li> After a waiting time, valve 3 is opened and
//      the fluid flows out of tank 2</li>
// <li> When tank 2 is empty, valve 3 is closed</liI>
// </ol>
// <p>
// The above \"normal\" process can be influenced by the following 
// buttons:
// </p>
// <ul>
// <li> Button <b>start</b> starts the above process.
//      When this button is pressed after a \"stop\" or
//      \"shut\" operation, the process operation continues.
//      </li>.
// <li> Button <b>stop</b> stops the above process by
//      closing all valves. Then, the controller waits for
//      further input (either \"start\" or \"shut\" operation).</li>
// <li> Button <b>shut</b> is used to shutdown the process, 
//      by emptying at once both tanks. When this is achieved,
//      the process goes back to its start configuration.
//      Clicking on \"start\", restarts the process.</li>
// </ul> 
// <p>
// The implementation of the <b>tankController</b> is shown in 
// the next figure:
// </p>
// <p align=\"center\">
// <img src=\"Images/StateGraph/Examples/ControlledTanks2.png\">
// </p>
// <p>
// When the \"<b>start</b>\" button is pressed, the stateGraph is
// within the CompositeStep \"<b>makeProduct</b>\". During normal
// operation this CompositeStep is only left, once tank2 is empty.
// Afterwards, the CompositeStep is at once re-entered.
// </p>
// <p>
// When the \"<b>stop</b>\" button is pressed, the \"makeProduct\"
// CompositeStep is at once terminated via the \"<b>suspend</b>\" port
// and the stateGraph waits in step \"<b>s2</b>\" for further
// commands. When the \"<b>start</b>\" button is pressed, the CompositeStep
// is re-entered via its <b>resume</b> port and the \"normal\"
// operation continues at the state where it was aborted by the
// suspend transition. If the \"<b>shut</b>\" button is pressed,
// the stateGraph waits in the \"<b>emptyTanks</b>\" step, until
// both tanks are empty and then waits at the initial step 
// \"<b>s1</b>\" for further input.
// </p>
// <p>
// The opening and closing of valves is <b>not</b> directly
// defined in the stateGraph. Instead via the \"<b>setValveX</b>\"
// components, the Boolean state of the valves are computed.
// For example, the output y of \"setValve2\" is computed as:
// </p>
// <pre>
//   y = makeProduct.fillTank2.active or emptyTanks.active
// </pre>
// <p>
// i.e., valve2 is open, when step \"makeProduct.fillTank2 or when
// step \"emptyTanks\" is active. Otherwise, valve2 is closed.
// </p>
// </html>
// ", revisions = ""));
//       end ApplicationExample;
//       class ReleaseNotes "Release notes"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Release notes</font></h3>
// <i>Changes by MathCore: Added stateGraphRoot component to each example. Updated pictures in documentation. Removed documentation about automatically adding inner component stateGraphRoot.</i>
// <h3><font color=\"#008000\">Version 0.87, 2004-06-23</font></h3>
// <ul>
// <li> Included in Modelica standard library 2.0 Beta 1 with the new block connectors.
//      Changed all the references to the block connectors and the Logical library
//      correspondingly.</li>
// </ul>
// <h3><font color=\"#008000\">Version 0.86, 2004-06-20</font></h3>
// <ul>
// <li> New components \"Alternative\" and \"Parallel\" for alternative and
//      parallel execution paths.</li>
// <li> A step has now a vector of input and output connectors in order
//      that multiple connections to and from a step are possible</li>
// <li> Removed components \"AlternativeSplit\", \"AlternativeJoin\",
//      \"ParallelSplit\" and \"ParallelJoin\" since the newly introduced
//      components (\"Alternative\", \"Parallel\", vector connectors of steps)
//      have the same modeling power but are safer and more convenient.</li>
// <li> Removed the timer in a step (attach instead Logical.Timer to
//      the \"active\" port of a \"StepWithSignal\" component). Note, that in
//      most cases it is more convenient and more efficient to use the
//      built-in timer of a transition.</li>
// <li> Component \"StepInitial\" renamed to \"InitialStep\".</li>
// <li> New component \"Timer\" within sublibrary Logical.</li>
// <li> Updated and improved documentation of the library.</li>
// </ul>
// <h3><font color=\"#008000\">Version 0.85, 2004-06-17</font></h3>
// <ul>
// <li> Renamed \"MacroStep\" to \"CompositeStep\" and the ports of the MacroStep
//      from \"abort\" to \"suspend\" and \"histoy\" to \"resume\".</li>
// <li> Nested \"CompositeStep\" components are supported, based on the
//      experimental feature of nested inner/outer components 
//      introduced by Dymola. This means that CompositeSteps can
//      be suspended and resumed at every level.</li>
// <li> New example \"Examples.ShowExceptions\" to demonstrate the new
//      feature of nested CompositeSteps.</li>
// <li> New package \"Logical\". It contains all components of
//      ModelicaAdditions.Blocks.Logical, but with new block connectors
//      and nicer icons. Additionally, logical blocks are also added.</li>
// <li> Improved icons for several components of the StateGraph library.</li>
// </ul>
// <h3><font color=\"#008000\">Version 0.83, 2004-05-21</font></h3>
// <ul>
// <li> The \"abort\" and \"history\" connectors are no longer visible in the
//      diagram layer of a CompositeStep since it is not allowed to connect
//      to them in a CompositeStep.</li>
// <li> Made the diagram/icon size of a CompositeStep smaller (from 200/-200 to
//      150/-150).</li>
// <li> Improved icons for \"SetBoolean/SetInteger/SetReal\" components.</li>
// <li> Renamed \"ParameterReal\" to \"SetRealParameter\".</li>
// </ul>
// <h3><font color=\"#008000\">Version 0.82, 2004-05-18</font></h3>
// <p>
// Implemented a first version that is provided to other people.
// </p>
// </html>
// ", revisions = ""));
//       end ReleaseNotes;
//       class Literature "Literature"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Literature</font></h3>
// <p>
// The StateGraph library is based on the following references:
// </p>
// <dl>
// <dt>Arzen K.-E. (2004):</dt>
// <dd> <b>JGrafchart User Manual. Version 1.5</b>.
//      Department of Automatic Control, Lund Institute of Technology,
//      Lund, Sweden, Feb. 13<br>&nbsp;</dd>
// <dt>Dressler I. (2004):</dt>
// <dd> <b>Code Generation From JGrafchart to Modelica</b>.
//      Master thesis, supervisor: Karl-Erik Arzen,
//      Department of Automatic Control, Lund Institute of Technology,
//      Lund, Sweden, March 30<br>&nbsp;</dd>
// <dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
// <dd> <b>Object-Oriented and Hybrid Modeling in Modelica</b>.
//      Journal Europeen des systemes automatises (JESA),
//      Volume 35 - n. 1.<br>&nbsp;</dd>
// <dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
// <dd> <b>Modeling Petri Nets as Local Constraint Equations for 
//      Hybrid Systems using Modelica</b>.
//      SCSC'98, Reno, Nevada, USA,
//      Society for Computer Simulation International, pp. 314-319.
//      </dd>
// </dl>
// </html>
// "));
//       end Literature;
//       class Contact "Contact"
//         annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br> 
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> The development of this library was strongly motivated by the
//      master thesis of Isolde Dressler
//      (<a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">see literature</a>),
//      in which
//      a compiler from JGrafChart to Modelica was designed and
//      implemented. This project was supervised by Karl-Erik Arzen
//      from Departement of Automatic Control, Lund Institut of
//      Technology, Lund, Sweden.</li>
// <li> This library profits also from the experience gained
//      in the focused research program (Schwerpunktprogramm) 
//      \"Continuous-Discrete Dynamic Systems\" (KONDISK), sponsored by the 
//      Deutsche Forschungsgemeinschaft under grants OT174/1-2 and EN152/22-2. 
//      This support is most gratefully acknowledged.
//  </li>
// <li> The implementation of the basic components of this library by describing
//      finite state machines with equations is based on
//      (Elmqvist, Mattsson and Otter, 2001),
//      which in turn uses ideas from (Mosterman, Otter and Elmqvist, 1998),
//      see <a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">literature</a></li>
// </ul>
// </html>
// "));
//       end Contact;
//     end UsersGuide;
//     package Examples "Examples to demonstrate the usage of the components of the StateGraph library"
//       model FirstExample "A first simple StateGraph example"
//         extends Modelica.Icons.Example;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         InitialStep initialStep annotation(Placement(visible = true, transformation(origin = { -38,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -10,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step annotation(Placement(visible = true, transformation(origin = {20,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition2(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {50,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(transition2.outPort,initialStep.inPort[1]) annotation(Line(visible = true, points = {{51.5,10},{70,10},{70,32},{ -62,32},{ -62,10},{ -49,10}}));
//         connect(step.outPort[1],transition2.inPort) annotation(Line(visible = true, points = {{30.5,10},{46,10}}));
//         connect(transition1.outPort,step.inPort[1]) annotation(Line(visible = true, points = {{ -8.5,10},{9,10}}));
//         connect(initialStep.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -27.5,10},{ -14,10}}));
//         annotation(structurallyIncomplete, experiment(StopTime = 5), experimentSetupOutput, Documentation(info = "<html>
//   
// </html>"));
//       end FirstExample;
//       model FirstExample_Variant2 "A variant of the first simple StateGraph example"
//         extends Modelica.Icons.Example;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         InitialStep initialStep annotation(Placement(visible = true, transformation(origin = { -60,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -32,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         StepWithSignal step annotation(Placement(visible = true, transformation(origin = { -4,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         TransitionWithSignal transition2 annotation(Placement(visible = true, transformation(origin = {62,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Logical.Timer timer annotation(Placement(visible = true, transformation(origin = {16, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqual(threshold = 1) annotation(Placement(visible = true, transformation(origin = {46, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(transition2.outPort,initialStep.inPort[1]) annotation(Line(visible = true, points = {{63.5,10},{82,10},{82,32},{ -80,32},{ -80,10},{ -71,10}}));
//         connect(greaterEqual.y,transition2.condition) annotation(Line(visible = true, points = {{57, -30},{62, -30},{62, -2}}, color = {255,0,255}));
//         connect(timer.y,greaterEqual.u) annotation(Line(visible = true, points = {{27, -30},{34, -30}}, color = {0,0,255}));
//         connect(step.outPort[1],transition2.inPort) annotation(Line(visible = true, points = {{6.5,10},{58,10}}));
//         connect(step.active,timer.u) annotation(Line(visible = true, points = {{ -4, -1},{ -4, -30},{4, -30}}, color = {255,0,255}));
//         connect(transition1.outPort,step.inPort[1]) annotation(Line(visible = true, points = {{ -30.5,10},{ -15,10}}));
//         connect(initialStep.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -49.5,10},{ -36,10}}));
//         annotation(structurallyIncomplete, experiment(StopTime = 5), experimentSetupOutput, Documentation(info = "<html>
//   
// </html>"));
//       end FirstExample_Variant2;
//       model FirstExample_Variant3 "A variant of the first simple StateGraph example"
//         extends Modelica.Icons.Example;
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         InitialStep initialStep annotation(Placement(visible = true, transformation(origin = { -60,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -32,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         StepWithSignal step annotation(Placement(visible = true, transformation(origin = { -4,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         TransitionWithSignal transition2 annotation(Placement(visible = true, transformation(origin = {66,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Logical.Timer timer annotation(Placement(visible = true, transformation(origin = { -4, -30}, extent = {{ -10, -10},{10,10}}, rotation =  -90)));
//         Modelica.Blocks.Sources.BooleanExpression SetBoolean1(y = timer.y > 1) annotation(Placement(visible = true, transformation(origin = {44, -30}, extent = {{ -16, -10},{16,10}}, rotation = 0)));
//         Modelica.Blocks.Sources.BooleanExpression SetBoolean2(y = step.active) annotation(Placement(visible = true, transformation(origin = { -52, -30}, extent = {{ -16, -10},{16,10}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(SetBoolean1.y,transition2.condition) annotation(Line(visible = true, points = {{61.6, -30},{66, -30},{66, -2}}, color = {255,0,255}));
//         connect(transition2.outPort,initialStep.inPort[1]) annotation(Line(visible = true, points = {{67.5,10},{82,10},{82,32},{ -80,32},{ -80,10},{ -71,10}}));
//         connect(step.outPort[1],transition2.inPort) annotation(Line(visible = true, points = {{6.5,10},{62,10}}));
//         connect(step.active,timer.u) annotation(Line(visible = true, points = {{ -4, -1},{ -4, -9.5},{ -4, -18},{ -4, -18}}, color = {255,0,255}));
//         connect(transition1.outPort,step.inPort[1]) annotation(Line(visible = true, points = {{ -30.5,10},{ -15,10}}));
//         connect(initialStep.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -49.5,10},{ -36,10}}));
//         annotation(structurallyIncomplete, experiment(StopTime = 5), experimentSetupOutput, Documentation(info = "<html>
//   
// </html>"));
//       end FirstExample_Variant3;
//       extends Modelica.Icons.Library;
//       model ExecutionPaths "Example to demonstrate parallel and alternative execution paths"
//         extends Modelica.Icons.Example;
//         annotation(structurallyIncomplete, Documentation(info = "<HTML>
// <p>
// This is an example to demonstrate in which way <b>parallel</b> activities
// can be modelled by a StateGraph. When transition1 fires
// (after 1 second), two branches are executed in parallel.
// After 6 seconds the two branches are synchronized in order to arrive
// at step6.
// </p>
// <p>
// Before simulating the model, try to figure out whether which branch
// of the alternative sequence is executed. Note, that alternatives
// have priorities according to the port index (alternative.split[1]
// has a higher priority to fire as alternative.split[2]).
// </p>
// </HTML>
// "), experiment(StopTime = 15), experimentSetupOutput, Diagram(coordinateSystem(extent = {{ -160, -160},{160,160}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         InitialStep step0 annotation(Placement(visible = true, transformation(origin = { -130, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -90, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step1 annotation(Placement(visible = true, transformation(origin = {0, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition2(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {100, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step6 annotation(Placement(visible = true, transformation(origin = {130, -90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step2 annotation(Placement(visible = true, transformation(origin = { -88,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition3(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -32,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition4(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -32,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step3 annotation(Placement(visible = true, transformation(origin = {2,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step4 annotation(Placement(visible = true, transformation(origin = {2,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition5(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {36,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition6(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {36,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step5 annotation(Placement(visible = true, transformation(origin = {90,50}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Modelica.Blocks.Sources.RealExpression setReal(y = time) annotation(Placement(visible = true, transformation(origin = {31, -150}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         TransitionWithSignal transition7 annotation(Placement(visible = true, transformation(origin = { -1, -124}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//         Modelica.Blocks.Sources.BooleanExpression setCondition(y = time > 7) annotation(Placement(visible = true, transformation(origin = { -48, -150}, extent = {{ -29, -10},{29,10}}, rotation = 0)));
//         Transition transition4a(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -32,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step4a annotation(Placement(visible = true, transformation(origin = {2,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition6a(enableTimer = true, waitTime = 2) annotation(Placement(visible = true, transformation(origin = {36,10}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         StateGraph.Temporary.NumericValue NumericValue1 annotation(Placement(visible = true, transformation(origin = {71, -150}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Alternative alternative(nBranches = 3) annotation(Placement(visible = true, transformation(origin = {1,50}, extent = {{ -71, -60},{71,60}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -150,150}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Parallel Parallel1 annotation(Placement(visible = true, transformation(origin = { -1,35}, extent = {{ -153, -85},{153,85}}, rotation = 0)));
// 
//       equation 
//         connect(step2.inPort[1],Parallel1.split[1]) annotation(Line(visible = true, points = {{ -99,50},{ -118,50},{ -119.575,50},{ -119.575,50},{ -119.575,35}}));
//         connect(step1.outPort[1],Parallel1.join[2]) annotation(Line(visible = true, points = {{10.5, -30},{118, -30},{118, -7.5},{117.575,35}}));
//         connect(transition1.outPort,Parallel1.inPort) annotation(Line(visible = true, points = {{ -88.5, -90},{ -70, -90},{ -70, -64},{ -174, -64},{ -174,35},{ -158.59,35}}));
//         connect(Parallel1.outPort,transition2.inPort) annotation(Line(visible = true, points = {{155.06,35},{168,35},{168, -60},{80, -60},{80, -90},{96, -90}}));
//         connect(step5.outPort[1],Parallel1.join[1]) annotation(Line(visible = true, points = {{100.5,50},{117.58,50},{117.58,46.5005},{117.575,35}}));
//         connect(Parallel1.split[2],step1.inPort[1]) annotation(Line(visible = true, origin = { -83.3833, -8.33333}, points = {{ -36.1917,43.3333},{ -36.1917, -21.6667},{72.3833, -21.6667}}));
//         connect(transition2.outPort,step6.inPort[1]) annotation(Line(visible = true, points = {{101.5, -90},{119, -90}}));
//         connect(step0.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -119.5, -90},{ -94, -90}}));
//         connect(alternative.outPort,step5.inPort[1]) annotation(Line(visible = true, points = {{73.42,50},{79,50}}));
//         connect(step2.outPort[1],alternative.inPort) annotation(Line(visible = true, points = {{ -77.5,50},{ -72.13,50}}));
//         connect(transition6a.outPort,alternative.join[3]) annotation(Line(visible = true, points = {{37.5,10},{57.09,10},{57.09,50}}));
//         connect(transition6.outPort,alternative.join[2]) annotation(Line(visible = true, points = {{37.5,50},{57.09,50}}));
//         connect(transition5.outPort,alternative.join[1]) annotation(Line(visible = true, points = {{37.5,90},{57.09,90},{57.09,50}}));
//         connect(transition4a.inPort,alternative.split[3]) annotation(Line(visible = true, points = {{ -36,10},{ -55,10},{ -55.09,50}}));
//         connect(transition4.inPort,alternative.split[2]) annotation(Line(visible = true, points = {{ -36,50},{ -55.09,50}}));
//         connect(transition3.inPort,alternative.split[1]) annotation(Line(visible = true, points = {{ -36,90},{ -55,90},{ -55.09,50}}));
//         connect(setReal.y,NumericValue1.Value) annotation(Line(visible = true, points = {{42, -150},{59, -150}}, color = {0,0,255}));
//         connect(setCondition.y,transition7.condition) annotation(Line(visible = true, points = {{ -16.1, -150},{ -1, -150},{ -1, -136}}, color = {255,0,255}));
//         connect(step4a.outPort[1],transition6a.inPort) annotation(Line(visible = true, points = {{12.5,10},{32,10}}));
//         connect(transition4a.outPort,step4a.inPort[1]) annotation(Line(visible = true, points = {{ -30.5,10},{ -9,10}}));
//         connect(step6.outPort[1],transition7.inPort) annotation(Line(visible = true, points = {{140.5, -90},{150, -90},{150, -124},{3, -124}}));
//         connect(transition7.outPort,step0.inPort[1]) annotation(Line(visible = true, points = {{ -2.5, -124},{ -149, -124},{ -149, -90},{ -141, -90}}));
//         connect(step4.outPort[1],transition6.inPort) annotation(Line(visible = true, points = {{12.5,50},{32,50}}));
//         connect(transition4.outPort,step4.inPort[1]) annotation(Line(visible = true, points = {{ -30.5,50},{ -9,50}}));
//         connect(step3.outPort[1],transition5.inPort) annotation(Line(visible = true, points = {{12.5,90},{32,90}}));
//         connect(transition3.outPort,step3.inPort[1]) annotation(Line(visible = true, points = {{ -30.5,90},{ -9,90}}));
//       end ExecutionPaths;
//       model ShowCompositeStep "Example to demonstrate parallel activities described by a StateGraph"
//         extends Modelica.Icons.Example;
//         annotation(structurallyIncomplete, Documentation(info = "<HTML>
// <p>
// This is the same example as \"ExecutionPaths\". The only difference
// is that the alternative paths are included in a \"CompositeStep\".
// </p>
// </HTML>
// "), experiment(StopTime = 15), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Utilities.CompositeStep compositeStep annotation(Placement(visible = true, transformation(origin = {5,20}, extent = {{ -15, -15},{15,15}}, rotation = 0)));
//         InitialStep step0 annotation(Placement(visible = true, transformation(origin = { -79,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -49,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step1 annotation(Placement(visible = true, transformation(origin = {6, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition2(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {55,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step6 annotation(Placement(visible = true, transformation(origin = {81,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         TransitionWithSignal transition7 annotation(Placement(visible = true, transformation(origin = {0, -60}, extent = {{10, -10},{ -10,10}}, rotation = 0)));
//         Parallel Parallel1 annotation(Placement(visible = true, transformation(origin = {3,0}, extent = {{ -33, -40},{33,40}}, rotation = 0)));
//         Modelica.Blocks.Sources.BooleanExpression setCondition(y = time > 7) annotation(Placement(visible = true, transformation(origin = { -25, -80}, extent = {{ -15, -10},{15,10}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(setCondition.y,transition7.condition) annotation(Line(visible = true, points = {{ -8.5, -80},{0, -80},{0, -72}}, color = {255,0,255}));
//         connect(step1.outPort[1],Parallel1.join[2]) annotation(Line(visible = true, points = {{16.5, -20},{28.575,0}}));
//         connect(step1.inPort[1],Parallel1.split[2]) annotation(Line(visible = true, points = {{ -5, -20},{ -22.575,0}}));
//         connect(compositeStep.outPort,Parallel1.join[1]) annotation(Line(visible = true, points = {{20.5,20},{28.575,0}}));
//         connect(compositeStep.inPort,Parallel1.split[1]) annotation(Line(visible = true, points = {{ -11,20},{ -22.575,0}}));
//         connect(Parallel1.outPort,transition2.inPort) annotation(Line(visible = true, points = {{36.66,0},{51,0}}));
//         connect(transition1.outPort,Parallel1.inPort) annotation(Line(visible = true, points = {{ -47.5,0},{ -30.99,0}}));
//         connect(transition2.outPort,step6.inPort[1]) annotation(Line(visible = true, points = {{56.5,0},{70,0}}));
//         connect(step6.outPort[1],transition7.inPort) annotation(Line(visible = true, points = {{91.5,0},{96,0},{96, -60},{4, -60}}));
//         connect(transition7.outPort,step0.inPort[1]) annotation(Line(visible = true, points = {{ -1.5, -60},{ -98, -60},{ -98,0},{ -90,0}}));
//         connect(step0.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -68.5,0},{ -53,0}}));
//       end ShowCompositeStep;
//       model ShowExceptions "Example to demonstrate how a hierarchically structured StateGraph can suspend and resume actions on different levels"
//         extends Modelica.Icons.Example;
//         annotation(structurallyIncomplete, Documentation(info = "<HTML>
// <p>
// CompositeStep \"compositeStep\" is a hierarchical StateGraph consisting of
// two other subgraphs. Whenever component \"compositeStep\" is suspended,
// all steps with in \"compositeStep\" are deactivated. By entering \"compositeStep\"
// via its \"resume\" port, all steps within \"compositeStep\" are activated
// according to their setting before leaving the \"compositeStep\" via its
// \"suspend\" port.
// </p>
// </HTML>
// "), experiment(StopTime = 20), experimentSetupOutput, Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Utilities.CompositeStep1 compositeStep annotation(Placement(visible = true, transformation(origin = { -5,40}, extent = {{ -15, -15},{15,15}}, rotation = 0)));
//         InitialStep initialStep annotation(Placement(visible = true, transformation(origin = { -70,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition1(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -40,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition2(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {30,40}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition3(enableTimer = true, waitTime = 2) annotation(Placement(visible = true, transformation(origin = { -45, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Step step1 annotation(Placement(visible = true, transformation(origin = { -14, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Transition transition4(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = {20, -20}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(transition3.outPort,step1.inPort[1]) annotation(Line(visible = true, points = {{ -43.5, -20},{ -25, -20}}));
//         connect(compositeStep.outPort,transition2.inPort) annotation(Line(visible = true, points = {{10.5,40},{26,40}}));
//         connect(initialStep.outPort[1],transition1.inPort) annotation(Line(visible = true, points = {{ -59.5,40},{ -44,40}}));
//         connect(transition1.outPort,compositeStep.inPort) annotation(Line(visible = true, points = {{ -38.5,40},{ -21,40}}));
//         connect(step1.outPort[1],transition4.inPort) annotation(Line(visible = true, points = {{ -3.5, -20},{16, -20}}));
//         connect(transition4.outPort,compositeStep.resume[1]) annotation(Line(visible = true, points = {{21.5, -20},{37.5, -20},{37.5,7.5},{2.5,7.5},{2.5,24}}));
//         connect(compositeStep.suspend[1],transition3.inPort) annotation(Line(visible = true, points = {{ -12.5,24.5},{ -12.5,7.5},{ -60,7.5},{ -60, -20},{ -49, -20}}));
//         connect(transition2.outPort,initialStep.inPort[1]) annotation(Line(visible = true, points = {{31.5,40},{45,40},{45,75},{ -90,75},{ -90,40},{ -81,40}}));
//       end ShowExceptions;
//       model ControlledTanks "Demonstrating the controller of a tank filling/emptying system"
//         extends Modelica.Icons.Example;
//         annotation(structurallyIncomplete, experiment(StopTime = 100), experimentSetupOutput, Documentation(info = "<html>
// <p>
// With this example the controller of a tank filling/emptying system
// is demonstrated. This example is from Dressler (2004),
// see <a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">Literature</a>. 
// The basic operation is to fill and empty the two tanks:
// </p>
// <ol>
// <li> Valve 1 is opened and tank 1 is filled.</li>
// <li> When tank 1 reaches its fill level limit, 
//      valve 1 is closed. </li>
// <li> After a waiting time, valve 2 is
//      opened and the fluid flows from tank 1 into tank 2.</li>
// <li> When tank 1 is empty, valve 2 is closed. </li>
// <li> After a waiting time, valve 3 is opened and
//      the fluid flows out of tank 2</li>
// <li> When tank 2 is empty, valve 3 is closed</liI>
// </ol>
// <p>
// The above \"normal\" process can be influenced by three 
// buttons:
// </p>
// <ul>
// <li> Button <b>start</b> starts the above process.
//      When this button is pressed after a \"stop\" or
//      \"shut\" operation, the process operation continues.
//      </li>.
// <li> Button <b>stop</b> stops the above process by
//      closing all valves. Then, the controller waits for
//      further input (either \"start\" or \"shut\" operation).</li>
// <li> Button <b>shut</b> is used to shutdown the process, 
//      by emptying at once both tanks. When this is achieved,
//      the process goes back to its start configuration.
//      Clicking on \"start\", restarts the process.</li>
// </ul> 
//      
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Utilities.TankController tankController annotation(Placement(visible = true, transformation(origin = { -30,0}, extent = {{ -20, -20},{20,20}}, rotation = 0)));
//         StateGraph.Temporary.RadioButton start(reset = {stop.on,shut.on}, buttonTimeTable = {1,13,15,19}) annotation(Placement(visible = true, transformation(origin = { -80,30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         StateGraph.Temporary.RadioButton stop(reset = {start.on,shut.on}, buttonTimeTable = {13,15,19,21}) annotation(Placement(visible = true, transformation(origin = { -80,0}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         StateGraph.Temporary.RadioButton shut(reset = {start.on,stop.on}, buttonTimeTable = {21,100}) annotation(Placement(visible = true, transformation(origin = { -80, -30}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Utilities.Tank tank1 annotation(Placement(visible = true, transformation(origin = {35,45}, extent = {{ -25, -25},{25,25}}, rotation = 0)));
//         Utilities.Tank tank2 annotation(Placement(visible = true, transformation(origin = {59, -35}, extent = {{ -25, -25},{25,25}}, rotation = 0)));
//         Utilities.valve valve1 annotation(Placement(visible = true, transformation(origin = {22.5,72}, extent = {{ -5.5, -5.5},{5.5,5.5}}, rotation =  -90)));
//         Utilities.Source source annotation(Placement(visible = true, transformation(origin = {22.5,90.5}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
//         Utilities.valve valve2 annotation(Placement(visible = true, transformation(origin = {46.5,13}, extent = {{ -8, -7},{8,7}}, rotation =  -90)));
//         Utilities.valve valve3 annotation(Placement(visible = true, transformation(origin = {73.5, -77}, extent = {{ -8, -7},{8,7}}, rotation =  -90)));
//         inner Modelica.StateGraph.StateGraphRoot stateGraphRoot annotation(Placement(visible = true, transformation(origin = { -90,90}, extent = {{ -10, -10},{10,10}}, rotation = 0)));
// 
//       equation 
//         connect(source.outflow1,valve1.outflow1) annotation(Line(visible = true, points = {{22.5,85.5},{22.5,74.75}}, thickness = 0.5));
//         connect(tankController.valve3,valve3.valveControl) annotation(Line(visible = true, points = {{ -9, -12},{23, -12},{23, -77},{67.9, -77}}, color = {255,0,255}));
//         connect(tankController.valve2,valve2.valveControl) annotation(Line(visible = true, points = {{ -9,0},{30,0},{30,13},{40.9,13}}, color = {255,0,255}));
//         connect(tankController.valve1,valve1.valveControl) annotation(Line(visible = true, points = {{ -9,12},{10,12},{10,72},{18.1,72}}, color = {255,0,255}));
//         connect(tank2.levelSensor,tankController.level2) annotation(Line(visible = true, points = {{41.25, -40},{ -18, -40},{ -18, -22}}, color = {0,0,255}));
//         connect(tank1.levelSensor,tankController.level1) annotation(Line(visible = true, points = {{17.25,40},{ -30,40},{ -30,60},{ -97,60},{ -97, -50},{ -42, -50},{ -42, -22}}, color = {0,0,255}));
//         connect(start.on,tankController.start) annotation(Line(visible = true, points = {{ -69,30},{ -60,30},{ -60,12},{ -52,12}}, color = {255,0,255}));
//         connect(stop.on,tankController.stop) annotation(Line(visible = true, points = {{ -69,0},{ -52,0}}, color = {255,0,255}));
//         connect(shut.on,tankController.shut) annotation(Line(visible = true, points = {{ -69, -30},{ -62, -30},{ -62, -12},{ -52, -12}}, color = {255,0,255}));
//         connect(tank1.inflow1,valve1.inflow1) annotation(Line(visible = true, points = {{22.5,61.25},{22.5,69.25}}, thickness = 0.5));
//         connect(tank2.outflow1,valve3.outflow1) annotation(Line(visible = true, points = {{74, -46.25},{74, -73.5},{73.5, -73}}, thickness = 0.5));
//         connect(tank2.inflow1,valve2.inflow1) annotation(Line(visible = true, points = {{46.5, -18.75},{46.5,9}}, thickness = 0.5));
//         connect(tank1.outflow1,valve2.outflow1) annotation(Line(visible = true, points = {{50,33.75},{50,26.875},{46.5,26.875},{46.5,17}}, thickness = 0.5));
//       end ControlledTanks;
//       package Utilities "Utility components for the examples"
//         model TankController "Controller for tank system"
//           extends StateGraph.Interfaces.PartialStateGraphIcon;
//           annotation(structurallyIncomplete, Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, lineColor = {0,0,0})}), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -100.0,54.0},{ -32.0,68.0}}, textString = "start", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -100.0, -8.0},{ -32.0,6.0}}, textString = "stop", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -100.0, -68.0},{ -32.0, -54.0}}, textString = "shut", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -94.0, -96.0},{ -18.0, -82.0}}, textString = "level1", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{24.0, -96.0},{96.0, -84.0}}, textString = "level2", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{31.0,54.0},{99.0,68.0}}, textString = "valve1", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{33.0, -5.0},{101.0,9.0}}, textString = "valve2", fontName = "Arial"),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{34.0, -67.0},{102.0, -53.0}}, textString = "valve3", fontName = "Arial")}));
//           parameter Temporary.SetRealParameter limit = 0.98 "Limit level of tank 1" annotation(Placement(visible = true, transformation(origin = { -54.0,86.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Temporary.SetRealParameter waitTime = 3 "Wait time" annotation(Placement(visible = true, transformation(origin = { -81.0,86.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           InitialStep s1(nIn = 2) annotation(Placement(visible = true, transformation(origin = { -62.0,40.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           MakeProduct makeProduct(limit = limit, waitTime = waitTime) annotation(Placement(visible = true, transformation(origin = { -5.0,40.0}, extent = {{ -15.0, -15.0},{15.0,15.0}}, rotation = 0)));
//           Transition T1(condition = start) annotation(Placement(visible = true, transformation(origin = { -40.0,40.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//           Transition T2(condition = level2 < 0.001) annotation(Placement(visible = true, transformation(origin = {37.0,40.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//           Transition T3(condition = stop) annotation(Placement(visible = true, transformation(origin = { -23.0, -1.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90)));
//           Step s2(nOut = 2) annotation(Placement(visible = true, transformation(origin = { -40.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T4(condition = start) annotation(Placement(visible = true, transformation(origin = {10.0, -1.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
//           Transition T5(condition = shut) annotation(Placement(visible = true, transformation(origin = {4.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step emptyTanks annotation(Placement(visible = true, transformation(origin = {32.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T6(condition = level1 + level2 < 0.001) annotation(Placement(visible = true, transformation(origin = {55.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput start annotation(Placement(visible = true, transformation(origin = { -110.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -110.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput stop annotation(Placement(visible = true, transformation(origin = { -110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanInput shut annotation(Placement(visible = true, transformation(origin = { -110.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -110.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput level1 annotation(Placement(visible = true, transformation(origin = { -60.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90), iconTransformation(origin = { -60.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90)));
//           Modelica.Blocks.Interfaces.RealInput level2 annotation(Placement(visible = true, transformation(origin = {60.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90), iconTransformation(origin = {60.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90)));
//           Modelica.Blocks.Interfaces.BooleanOutput valve1 annotation(Placement(visible = true, transformation(origin = {105.0,60.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = {105.0,60.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanOutput valve2 annotation(Placement(visible = true, transformation(origin = {105.0,0.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = {105.0,0.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.BooleanOutput valve3 annotation(Placement(visible = true, transformation(origin = {105.0, -60.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = {105.0, -60.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanExpression setValve1(y = makeProduct.fillTank1.active) annotation(Placement(visible = true, transformation(origin = {50.0,82.5}, extent = {{ -30.0, -9.5},{30.0,9.5}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanExpression setValve2(y = makeProduct.fillTank2.active or emptyTanks.active) annotation(Placement(visible = true, transformation(origin = {27.5, -78.5}, extent = {{ -52.5, -10.5},{52.5,10.5}}, rotation = 0)));
//           Modelica.Blocks.Sources.BooleanExpression setValve3(y = makeProduct.emptyTank2.active or emptyTanks.active) annotation(Placement(visible = true, transformation(origin = {27.0, -90.0}, extent = {{ -53.0, -10.0},{53.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(T6.outPort,s1.inPort[2]) annotation(Line(visible = true, points = {{56.5, -50.0},{70.0, -50.0},{70.0,70.0},{ -84.0,70.0},{ -84.0,40.0},{ -74.0,40.0},{ -73.0,40.0}}));
//           connect(T2.outPort,s1.inPort[1]) annotation(Line(visible = true, points = {{38.5,40.0},{70.0,40.0},{70.0,70.0},{ -84.0,70.0},{ -84.0,40.0},{ -73.0,40.0},{ -73.0,40.0}}));
//           connect(s2.outPort[2],T4.inPort) annotation(Line(visible = true, points = {{ -29.5, -50.0},{ -29.0, -50.0},{ -8.0, -50.0},{ -8.0, -25.0},{10.0, -25.0},{10.0,3.0}}));
//           connect(s2.outPort[1],T5.inPort) annotation(Line(visible = true, points = {{ -29.5, -50.0},{ -30.0, -49.75},{ -30.0, -50.0},{0.0, -50.0}}));
//           connect(level1,makeProduct.level1) annotation(Line(visible = true, points = {{ -60.0, -110.0},{ -60.0, -80.0},{ -80.0, -80.0},{ -80.0,20.0},{ -30.0,20.0},{ -30.0,28.0},{ -22.0,28.0}}, color = {0,0,255}));
//           connect(T4.outPort,makeProduct.resume[1]) annotation(Line(visible = true, points = {{10.0, -2.5},{10.0,15.0},{2.5,15.0},{2.5,24.0}}));
//           connect(T3.outPort,s2.inPort[1]) annotation(Line(visible = true, points = {{ -23.0,0.5},{ -23.0, -20.0},{ -66.0, -20.0},{ -66.0, -50.0},{ -51.0, -50.0}}));
//           connect(makeProduct.suspend[1],T3.inPort) annotation(Line(visible = true, points = {{ -12.5,24.5},{ -12.5,12.0},{ -23.0,12.0},{ -23.0, -5.0}}));
//           connect(setValve3.y,valve3) annotation(Line(visible = true, points = {{85.3, -90.0},{95.0, -90.0},{95.0, -60.0},{105.0, -60.0}}, color = {255,0,255}));
//           connect(setValve2.y,valve2) annotation(Line(visible = true, points = {{85.25, -78.5},{90.0, -78.5},{90.0,0.0},{105.0,0.0}}, color = {255,0,255}));
//           connect(setValve1.y,valve1) annotation(Line(visible = true, points = {{83.0,82.5},{90.0,82.5},{90.0,60.0},{105.0,60.0}}, color = {255,0,255}));
//           connect(emptyTanks.outPort[1],T6.inPort) annotation(Line(visible = true, points = {{42.5, -50.0},{51.0, -50.0}}));
//           connect(T5.outPort,emptyTanks.inPort[1]) annotation(Line(visible = true, points = {{5.5, -50.0},{21.0, -50.0}}));
//           connect(makeProduct.outPort,T2.inPort) annotation(Line(visible = true, points = {{10.5,40.0},{33.0,40.0}}));
//           connect(T1.outPort,makeProduct.inPort) annotation(Line(visible = true, points = {{ -38.5,40.0},{ -21.0,40.0}}));
//           connect(s1.outPort[1],T1.inPort) annotation(Line(visible = true, points = {{ -51.5,40.0},{ -44.0,40.0}}));
//         end TankController;
//         model MakeProduct
//           extends StateGraph.PartialCompositeStep;
//           annotation(Diagram(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           parameter StateGraph.Temporary.SetRealParameter limit = 0.98 "Limit level of tank 1" annotation(Placement(visible = true, transformation(origin = { -40.0,50.0}, extent = {{ -20.0, -10.0},{20.0,10.0}}, rotation = 0)));
//           parameter StateGraph.Temporary.SetRealParameter waitTime = 3 "Wait time" annotation(Placement(visible = true, transformation(origin = { -100.0,50.0}, extent = {{ -20.0, -10.0},{20.0,10.0}}, rotation = 0)));
//           Modelica.Blocks.Interfaces.RealInput level1 annotation(Placement(visible = true, transformation(origin = { -170.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0), iconTransformation(origin = { -170.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//           Step fillTank1 annotation(Placement(visible = true, transformation(origin = { -130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T1(condition = level1 > limit) annotation(Placement(visible = true, transformation(origin = { -100.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step fillTank2 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T3(condition = level1 < 0.001) annotation(Placement(visible = true, transformation(origin = {30.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step emptyTank2 annotation(Placement(visible = true, transformation(origin = {130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step wait1 annotation(Placement(visible = true, transformation(origin = { -70.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T2(enableTimer = true, waitTime = waitTime) annotation(Placement(visible = true, transformation(origin = { -40.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step wait2 annotation(Placement(visible = true, transformation(origin = {64.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition T4(enableTimer = true, waitTime = waitTime) annotation(Placement(visible = true, transformation(origin = {92.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(fillTank1.inPort[1],inPort) annotation(Line(visible = true, points = {{ -141.0,0.0},{ -160.0,0.0}}));
//           connect(fillTank1.outPort[1],T1.inPort) annotation(Line(visible = true, points = {{ -119.5,0.0},{ -104.0,0.0}}));
//           connect(fillTank2.outPort[1],T3.inPort) annotation(Line(visible = true, points = {{10.5,0.0},{26.0,0.0}}));
//           connect(emptyTank2.outPort[1],outPort) annotation(Line(visible = true, points = {{140.5,0.0},{155.0,0.0}}));
//           connect(wait1.outPort[1],T2.inPort) annotation(Line(visible = true, points = {{ -59.5,0.0},{ -44.0,0.0}}));
//           connect(T2.outPort,fillTank2.inPort[1]) annotation(Line(visible = true, points = {{ -38.5,0.0},{ -11.0,0.0}}));
//           connect(T1.outPort,wait1.inPort[1]) annotation(Line(visible = true, points = {{ -98.5,0.0},{ -81.0,0.0}}));
//           connect(wait2.outPort[1],T4.inPort) annotation(Line(visible = true, points = {{74.5,0.0},{88.0,0.0}}));
//           connect(T3.outPort,wait2.inPort[1]) annotation(Line(visible = true, points = {{31.5,0.0},{53.0,0.0}}));
//           connect(T4.outPort,emptyTank2.inPort[1]) annotation(Line(visible = true, points = {{93.5,0.0},{119.0,0.0}}));
//         end MakeProduct;
//         connector inflow "Inflow connector (this is a copy from Isolde Dressler's master thesis project)"
//           import Units = Modelica.SIunits;
//           Units.VolumeFlowRate Fi "inflow";
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100, -100},{0,100},{100, -100},{ -100, -100}}, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {255,255,255}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100, -100},{0,100},{100, -100},{ -100, -100}}, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {255,255,255}, fillPattern = FillPattern.Solid)}));
//         end inflow;
//         connector outflow "Outflow connector (this is a copy from Isolde Dressler's master thesis project)"
//           import Units = Modelica.SIunits;
//           Units.VolumeFlowRate Fo "outflow";
//           Boolean open "valve open";
//           annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{0, -100},{100,100},{ -100,100}}, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {255,255,255}, fillPattern = FillPattern.Solid)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{0, -100},{100,100},{ -100,100}}, lineColor = {0,0,0}, lineThickness = 0.5, fillColor = {255,255,255}, fillPattern = FillPattern.Solid)}));
//         end outflow;
//         model valve "Simple valve model (this is a copy from Isolde Dressler's master thesis project)"
//           annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{0.0, -60.0},{0.0,0.0}}, color = {255,0,255})}), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{20.0,20.0},{20.0,20.0}}, thickness = 0.5),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -131.0,67.0},{136.0,125.0}}, textString = "%name", fontName = "Arial"),Line(visible = true, points = {{0.0,0.0},{0.0, -60.0}}, color = {255,0,255})}));
//           Modelica.Blocks.Interfaces.BooleanInput valveControl annotation(Placement(visible = true, transformation(origin = {0.0, -80.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90), iconTransformation(origin = {0.0, -80.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90)));
//           inflow inflow1 annotation(Placement(visible = true, transformation(origin = {50.0,0.0}, extent = {{ -50.0, -50.0},{50.0,50.0}}, rotation = 90), iconTransformation(origin = {50.0,0.0}, extent = {{ -50.0, -50.0},{50.0,50.0}}, rotation = 90)));
//           outflow outflow1 annotation(Placement(visible = true, transformation(origin = { -50.0,0.0}, extent = {{ -50.0, -50.0},{50.0,50.0}}, rotation = 90), iconTransformation(origin = { -50.0,0.0}, extent = {{ -50.0, -50.0},{50.0,50.0}}, rotation = 90)));
// 
//         equation 
//           outflow1.Fo = inflow1.Fi;
//           outflow1.open = valveControl;
//         end valve;
//         model Tank "Simple tank model (this is a copy from Isolde Dressler's master thesis project)"
//           Modelica.Blocks.Interfaces.RealOutput levelSensor annotation(Placement(visible = true, transformation(origin = { -70.0, -20.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0), iconTransformation(origin = { -70.0, -20.0}, extent = {{10.0, -10.0},{ -10.0,10.0}}, rotation = 0)));
//           inflow inflow1 annotation(Placement(visible = true, transformation(origin = { -50.0,65.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = { -50.0,65.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//           outflow outflow1 annotation(Placement(visible = true, transformation(origin = {60.0, -45.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = {60.0, -45.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{ -122.0, -82.0},{88.0, -42.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -60.0, -40.0},{80.0,60.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Real level "Tank level in % of max height";
//           parameter Real A = 1 "ground area of tank in m";
//           parameter Real a = 0.2 "area of drain hole in m";
//           parameter Real hmax = 1 "max height of tank in m";
//           constant Real g = Modelica.Constants.g_n;
// 
//         equation 
//           der(level) = (inflow1.Fi - outflow1.Fo) / (hmax * A);
//           if outflow1.open then
//             outflow1.Fo = sqrt(2 * g * hmax * level) * a;
// 
//           else
//             outflow1.Fo = 0;
// 
//           end if;
//           levelSensor = level;
//         end Tank;
//         model Source "Simple source model (this is a copy from Isolde Dressler's master thesis project)"
//           outflow outflow1 annotation(Placement(visible = true, transformation(origin = {0.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {0.0, -50.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Real maxflow = 1 "maximal flow out of source";
//           annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, lineThickness = 0.5, extent = {{ -80.0, -10.0},{80.0,40.0}}),Text(visible = true, extent = {{ -144.0,54.0},{152.0,114.0}}, textString = "%name", fontName = "Arial")}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
// 
//         equation 
//           if outflow1.open then
//             outflow1.Fo = maxflow;
// 
//           else
//             outflow1.Fo = 0;
// 
//           end if;
//         end Source;
//         model CompositeStep
//           extends StateGraph.PartialCompositeStep;
//           annotation(Diagram(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Transition transition3(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -54.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition4(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -54.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step step3 annotation(Placement(visible = true, transformation(origin = {0.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step step4 annotation(Placement(visible = true, transformation(origin = {0.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition5(enableTimer = true, waitTime = 2) annotation(Placement(visible = true, transformation(origin = {46.0,60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition6(enableTimer = true, waitTime = 2) annotation(Placement(visible = true, transformation(origin = {46.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition4a(enableTimer = true, waitTime = 1) annotation(Placement(visible = true, transformation(origin = { -54.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step step4a annotation(Placement(visible = true, transformation(origin = {0.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition6a(enableTimer = true, waitTime = 2) annotation(Placement(visible = true, transformation(origin = {46.0, -60.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step initStep annotation(Placement(visible = true, transformation(origin = { -130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step exitStep annotation(Placement(visible = true, transformation(origin = {130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Alternative Alternative1(nBranches = 3) annotation(Placement(visible = true, transformation(origin = { -2.0,0.0}, extent = {{ -98.0, -90.0},{98.0,90.0}}, rotation = 0)));
// 
//         equation 
//           connect(transition3.outPort,step3.inPort[1]) annotation(Line(visible = true, points = {{ -52.5,60.0},{ -11.0,60.0}}));
//           connect(step3.outPort[1],transition5.inPort) annotation(Line(visible = true, points = {{10.5,60.0},{42.0,60.0}}));
//           connect(transition4.outPort,step4.inPort[1]) annotation(Line(visible = true, points = {{ -52.5,0.0},{ -11.0,0.0}}));
//           connect(step4.outPort[1],transition6.inPort) annotation(Line(visible = true, points = {{10.5,0.0},{42.0,0.0}}));
//           connect(transition4a.outPort,step4a.inPort[1]) annotation(Line(visible = true, points = {{ -52.5, -60.0},{ -11.0, -60.0}}));
//           connect(step4a.outPort[1],transition6a.inPort) annotation(Line(visible = true, points = {{10.5, -60.0},{42.0, -60.0}}));
//           connect(initStep.inPort[1],inPort) annotation(Line(visible = true, points = {{ -141.0,0.0},{ -160.0,0.0}}));
//           connect(exitStep.outPort[1],outPort) annotation(Line(visible = true, points = {{140.5,0.0},{155.0,0.0}}));
//           connect(initStep.outPort[1],Alternative1.inPort) annotation(Line(visible = true, points = {{ -119.5,0.0},{ -102.94,0.0}}));
//           connect(Alternative1.outPort,exitStep.inPort[1]) annotation(Line(visible = true, points = {{97.96,0.0},{119.0,0.0}}));
//           connect(transition3.inPort,Alternative1.split[1]) annotation(Line(visible = true, points = {{ -58.0,60.0},{ -79.42,0.0}}));
//           connect(transition4.inPort,Alternative1.split[2]) annotation(Line(visible = true, points = {{ -58.0,0.0},{ -67.975,0.0},{ -67.975, -0.0},{ -79.42,0.0}}));
//           connect(transition4a.inPort,Alternative1.split[3]) annotation(Line(visible = true, points = {{ -58.0, -60.0},{ -67.975, -60.0},{ -67.975, -60.0},{ -79.42,0.0}}));
//           connect(transition5.outPort,Alternative1.join[1]) annotation(Line(visible = true, points = {{47.5,60.0},{75.42,0.0}}));
//           connect(transition6.outPort,Alternative1.join[2]) annotation(Line(visible = true, points = {{47.5,0.0},{60.725,0.0},{60.725, -0.0},{75.42,0.0}}));
//           connect(transition6a.outPort,Alternative1.join[3]) annotation(Line(visible = true, points = {{47.5, -60.0},{60.725, -60.0},{60.725, -60.0},{75.42,0.0}}));
//         end CompositeStep;
//         model CompositeStep1
//           extends PartialCompositeStep;
//           Transition transition1(enableTimer = false, waitTime = 0, condition = time > 8) annotation(Placement(visible = true, transformation(origin = { -50.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step initStep annotation(Placement(visible = true, transformation(origin = { -130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step exitStep annotation(Placement(visible = true, transformation(origin = {120.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           annotation(Diagram(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           CompositeStep2 compositeStep11(waitTime = 3) annotation(Placement(visible = true, transformation(origin = { -5.0,30.0}, extent = {{ -15.0, -15.0},{15.0,15.0}}, rotation = 0)));
//           CompositeStep2 compositeStep12(waitTime = 2) annotation(Placement(visible = true, transformation(origin = { -5.0, -30.0}, extent = {{ -15.0, -15.0},{15.0,15.0}}, rotation = 0)));
//           Transition transition2(condition = time > 4, enableTimer = false, waitTime = 0) annotation(Placement(visible = true, transformation(origin = { -51.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition3(enableTimer = false, waitTime = 0) annotation(Placement(visible = true, transformation(origin = {39.0,30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Transition transition4(enableTimer = false, waitTime = 0) annotation(Placement(visible = true, transformation(origin = {39.0, -30.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Alternative Alternative1 annotation(Placement(visible = true, transformation(origin = { -5.5,0.0}, extent = {{ -94.5, -60.0},{94.5,60.0}}, rotation = 0)));
// 
//         equation 
//           connect(exitStep.outPort[1],outPort) annotation(Line(visible = true, points = {{130.5,0.0},{155.0,0.0}}));
//           connect(initStep.inPort[1],inPort) annotation(Line(visible = true, points = {{ -141.0,0.0},{ -160.0,0.0}}));
//           connect(transition1.outPort,compositeStep11.inPort) annotation(Line(visible = true, origin = { -34.75,30.0}, points = {{ -13.75,0.0},{13.75,0.0}}));
//           connect(transition2.outPort,compositeStep12.inPort) annotation(Line(visible = true, origin = { -35.25, -30.0}, points = {{ -14.25,0.0},{14.25,0.0}}));
//           connect(compositeStep11.outPort,transition3.inPort) annotation(Line(visible = true, origin = {22.75,30.0}, points = {{ -12.25,0.0},{12.25,0.0}}));
//           connect(compositeStep12.outPort,transition4.inPort) annotation(Line(visible = true, origin = {22.75, -30.0}, points = {{ -12.25,0.0},{12.25,0.0}}));
//           connect(initStep.outPort[1],Alternative1.inPort) annotation(Line(visible = true, points = {{ -119.5,0.0},{ -102.835,0.0}}));
//           connect(Alternative1.outPort,exitStep.inPort[1]) annotation(Line(visible = true, points = {{90.89,0.0},{109.0,0.0}}));
//           connect(transition1.inPort,Alternative1.split[1]) annotation(Line(visible = true, points = {{ -54.0,30.0},{ -80.155,0.0}}));
//           connect(transition2.inPort,Alternative1.split[2]) annotation(Line(visible = true, points = {{ -55.0, -30.0},{ -80.155,0.0}}));
//           connect(transition3.outPort,Alternative1.join[1]) annotation(Line(visible = true, points = {{40.5,30.0},{69.155,0.0}}));
//           connect(transition4.outPort,Alternative1.join[2]) annotation(Line(visible = true, points = {{40.5, -30.0},{69.155,0.0}}));
//         end CompositeStep1;
//         model CompositeStep2
//           extends PartialCompositeStep;
//           annotation(Diagram(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})), Icon(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//           Transition transition(enableTimer = true, waitTime = waitTime) annotation(Placement(visible = true, transformation(origin = { -20.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step initStep annotation(Placement(visible = true, transformation(origin = { -130.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           Step exitStep annotation(Placement(visible = true, transformation(origin = {120.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//           parameter Temporary.SetRealParameter waitTime = 2 "waiting time in this composite step" annotation(Placement(visible = true, transformation(origin = { -65.0,40.0}, extent = {{ -15.0, -10.0},{15.0,10.0}}, rotation = 0)));
// 
//         equation 
//           connect(exitStep.outPort[1],outPort) annotation(Line(visible = true, points = {{130.5,0.0},{155.0,0.0}}));
//           connect(initStep.inPort[1],inPort) annotation(Line(visible = true, points = {{ -141.0,0.0},{ -160.0,0.0}}));
//           connect(initStep.outPort[1],transition.inPort) annotation(Line(visible = true, points = {{ -119.5,0.0},{ -24.0,0.0}}));
//           connect(transition.outPort,exitStep.inPort[1]) annotation(Line(visible = true, points = {{ -18.5,0.0},{109.0,0.0}}));
//         end CompositeStep2;
//       end Utilities;
//       annotation(Documentation(info = "<html>
//   
// </html>"));
//     end Examples;
//     package Interfaces "Connectors and partial models"
//       extends Modelica.Icons.Library;
//       connector Step_in "Input port of a step"
//         output Boolean occupied "true, if step is active" annotation(Hide = true);
//         input Boolean set "true, if transition fires and step is activated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{0.0,50.0},{100.0,0.0},{0.0, -50.0},{0.0,50.0}}),Text(visible = true, origin = { -20.5,80.0}, extent = {{ -120.5, -20.0},{120.5,20.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
//       end Step_in;
//       connector Step_out "Output port of a step"
//         output Boolean available "true, if step is active" annotation(Hide = true);
//         input Boolean reset "true, if transition fires and step is deactivated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -50.0},{0.0,50.0}}),Text(visible = true, origin = {42.1245,80.0}, extent = {{ -142.1245, -20.0},{143.8755,22.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
//       end Step_out;
//       connector Transition_in "Input port of a transition"
//         input Boolean available "true, if step connected to the transition input is active" annotation(Hide = true);
//         output Boolean reset "true, if transition fires and the step connected to the transition input is deactivated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{0.0,50.0},{100.0,0.0},{0.0, -50.0},{0.0,50.0}}),Text(visible = true, origin = { -20.5,80.0}, extent = {{ -120.5, -20.0},{120.5,20.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
//       end Transition_in;
//       connector Transition_out "Output port of a transition"
//         input Boolean occupied "true, if step connected to the transition output is active" annotation(Hide = true);
//         output Boolean set "true, if transition fires and step connected to the transition output becomes active" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, origin = {23.0,80.0}, extent = {{ -123.0, -20.0},{123.0,20.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -50.0},{0.0,50.0}})}), Documentation(info = "<html>
//  
// </html>"));
//       end Transition_out;
//       connector CompositeStep_resume "Input port of a step (used for resume connector of a CompositeStep)"
//         output Boolean occupied "true, if step is active" annotation(Hide = true);
//         input Boolean set "true, if transition fires and step is activated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Polygon(points = {{ -100,100},{100,0},{ -100, -100},{ -100,100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {0,0,0})}), Documentation(info = "<html>
//   
// </html>"));
//       end CompositeStep_resume;
//       connector CompositeStep_suspend "Output port of a step (used for suspend connector of a CompositeStep)"
//         output Boolean available "true, if step is active" annotation(Hide = true);
//         input Boolean reset "true, if transition fires and step is deactived" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}})}));
//       end CompositeStep_suspend;
//       connector CompositeStepStatePort_in "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are inputs)"
//         annotation(structurallyIncomplete, Documentation(info = "<html>
//   
// </html>"));
//         input Boolean suspend "= true, if suspend transition of CompositeStep fires";
//         input Boolean resume "= true, if resume transition of CompositeStep fires";
//         flow output Real activeSteps "Number of active steps in the CompositeStep";
//       end CompositeStepStatePort_in;
//       connector CompositeStepStatePort_out "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are outputs)"
//         annotation(structurallyIncomplete, Documentation(info = "<html>
//  
// </html>"));
//         output Boolean suspend "= true, if suspend transition of CompositeStep fires";
//         output Boolean resume "= true, if resume transition of CompositeStep fires";
//         flow input Real activeSteps "Number of active steps in the CompositeStep";
//         annotation(Icon, Diagram);
//       end CompositeStepStatePort_out;
//       partial block PartialStep "Partial step with one input and one output transition port"
//         annotation(structurallyIncomplete, Documentation(info = "<html>
//  
// </html>"));
//         parameter Integer nIn(min = 0) = 1 "Number of input connections";
//         parameter Integer nOut(min = 0) = 1 "Number of output connections";
//         output Boolean localActive "= true if step is active, otherwise the step is not active" annotation(Hide = true);
//         Interfaces.Step_in inPort[nIn] "Vector of step input connectors" annotation(Placement(visible = true, transformation(origin = { -110.0,0.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -110.0,0.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//         Interfaces.Step_out outPort[nOut] "Vector of step output connectors" annotation(Placement(visible = true, transformation(origin = {105.0,0.0}, extent = {{ -5.0,5.0},{5.0, -5.0}}, rotation = 0), iconTransformation(origin = {105.0,0.0}, extent = {{ -5.0,5.0},{5.0, -5.0}}, rotation = 0)));
//       protected 
//         outer Interfaces.CompositeStepState stateGraphRoot;
//         CompositeStepStatePort_in subgraphStatePort;
//         Boolean newActive "Value of active in the next iteration" annotation(Hide = true);
//         Boolean oldActive "Value of active when CompositeStep was aborted";
// 
//       initial equation 
//         pre(newActive) = pre(localActive);
//         pre(oldActive) = pre(localActive);
// 
//       equation 
//         connect(subgraphStatePort,stateGraphRoot.subgraphStatePort);
//         for i in 1:nIn loop
//         assert(cardinality(inPort[i]) <= 1, "Connector inPort[" + String(i) + "] of the step is connected to more than one transition");
// 
//         end for;
//         for i in 1:nOut loop
//         assert(cardinality(outPort[i]) <= 1, "Connector outPort[" + String(i) + "] of the step is connected to more than one transition");
// 
//         end for;
//         localActive = pre(newActive);
//         newActive = if subgraphStatePort.resume then oldActive else (StateGraph.Temporary.anyTrue(inPort.set) or localActive and not StateGraph.Temporary.anyTrue(outPort.reset)) and not subgraphStatePort.suspend;
//         when subgraphStatePort.suspend then
//                   oldActive = localActive;
//         
//         end when;
//         subgraphStatePort.activeSteps = if localActive then 1.0 else 0.0;
//         for i in 1:nIn loop
//         inPort[i].occupied = if i == 1 then localActive else inPort[i - 1].occupied or inPort[i - 1].set;
// 
//         end for;
//         for i in 1:nOut loop
//         outPort[i].available = if i == 1 then localActive else outPort[i - 1].available and not outPort[i - 1].reset;
// 
//         end for;
//         for i in 1:nIn loop
// if cardinality(inPort[i]) == 0 then
//                   inPort[i].set = false;
//         end if;
// 
//         end for;
//         for i in 1:nOut loop
// if cardinality(outPort[i]) == 0 then
//                   outPort[i].reset = false;
//         end if;
// 
//         end for;
//         annotation(Icon);
//       end PartialStep;
//       partial block PartialTransition "Partial transition with input and output connections"
//         input Boolean localCondition "= true, if transition may fire" annotation(Hide = true);
//         parameter Boolean enableTimer = false "= true, if timer is enabled" annotation(Dialog(group = "Timer"), Evaluate = true);
//         parameter Modelica.SIunits.Time waitTime(min = 0) = 0 "Wait time before transition fires" annotation(Dialog(group = "Timer", enable = enableTimer));
//         output Modelica.SIunits.Time t "= actual waiting time (transition will fire when t > waitTime)";
//         output Boolean enableFire "= true, if all firing conditions are true";
//         output Boolean fire "= true, if transition fires" annotation(Hide = true);
//         StateGraph.Interfaces.Transition_in inPort "Vector of transition input connectors" annotation(Placement(visible = true, transformation(origin = { -40.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = { -40.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//         StateGraph.Interfaces.Transition_out outPort "Vector of transition output connectors" annotation(Placement(visible = true, transformation(origin = {15.0,0.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0), iconTransformation(origin = {15.0,0.0}, extent = {{ -5.0, -5.0},{5.0,5.0}}, rotation = 0)));
//       protected 
//         Modelica.SIunits.Time t_start "Time instant at which the transition would fire, if waitTime would be zero";
//         Real t_dummy;
// 
//       initial equation 
//         pre(enableFire) = false;
// 
//       equation 
//         assert(cardinality(inPort) == 1, "Connector inPort is not connected to exactly one other connector");
//         assert(cardinality(outPort) == 1, "Connector outPort is not connected to exactly one other connector");
//         if enableTimer then
//           when enableFire then
//                       t_start = time;
//           
//           end when;
//           t_dummy = time - t_start;
//           t = if enableFire then t_dummy else 0;
//           fire = enableFire and time >= t_start + waitTime;
// 
//         else
//           t_start = 0;
//           t_dummy = 0;
//           t = 0;
//           fire = enableFire;
// 
//         end if;
//         enableFire = localCondition and inPort.available and not outPort.occupied;
//         inPort.reset = fire;
//         outPort.set = fire;
//         annotation(Icon, Documentation(info = "<html>
//  
// </html>"));
//       end PartialTransition;
//       partial block PartialStateGraphIcon "Icon for a StateGraph object"
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}}),Text(visible = true, fillPattern = FillPattern.Solid, extent = {{ -160.0,110.0},{160.0,150.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//  
// </html>"));
//       end PartialStateGraphIcon;
//       block CompositeStepState "Communication channel between CompositeSteps and steps in the CompositeStep"
//         output Boolean suspend = false;
//         output Boolean resume = false;
//         StateGraph.Interfaces.CompositeStepStatePort_out subgraphStatePort;
//         annotation(defaultComponentName = "stateGraphRoot", defaultComponentPrefixes = "inner", missingInnerMessage = "A \"stateGraphRoot\" component was automatically introduced.", Documentation(info = "<html>
//  
// </html>"));
// 
//       equation 
//         suspend = subgraphStatePort.suspend;
//         resume = subgraphStatePort.resume;
//       end CompositeStepState;
//       annotation(Documentation(info = "<html>
//  
// </html>"));
//     end Interfaces;
//     block InitialStep "Initial step (= step that is active when simulation starts)"
//       output Boolean active "= true if step is active, otherwise the step is not active";
//       extends Interfaces.PartialStep(localActive = active);
//       annotation(structurallyIncomplete, Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -100.0, -100.0},{100.0,100.0}}),Rectangle(visible = true, extent = {{ -80.0, -80.0},{80.0,80.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200,110},{200,150}}, textString = "%name"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Rectangle(visible = true, extent = {{ -80, -80},{80,80}})}));
// 
//     initial equation 
//       active = true;
//     end InitialStep;
//     block InitialStepWithSignal "Initial step (= step that is active when simulation starts). Connector 'active' is true when the step is active"
//       extends Interfaces.PartialStep(localActive = active);
//       annotation(structurallyIncomplete, Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200.0,110.0},{200.0,150.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}}),Text(visible = true, extent = {{ -92.0, -68.0},{94.0, -50.0}}, textString = "active", fontName = "Arial"),Rectangle(visible = true, extent = {{ -80.0, -80.0},{80.0,80.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//       Modelica.Blocks.Interfaces.BooleanOutput active annotation(Placement(visible = true, transformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90), iconTransformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90)));
// 
//     initial equation 
//       active = true;
//     end InitialStepWithSignal;
//     block Step "Ordinary step (= step that is not active when simulation starts)"
//       output Boolean active "= true if step is active, otherwise the step is not active";
//       extends Interfaces.PartialStep(localActive = active);
//       annotation(structurallyIncomplete, Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200,110},{200,150}}, textString = "%name"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}})}));
// 
//     initial equation 
//       active = false;
//     end Step;
//     block StepWithSignal "Ordinary step (= step that is not active when simulation starts). Connector 'active' is true when the step is active"
//       extends Interfaces.PartialStep(localActive = active);
//       annotation(structurallyIncomplete, Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -100.0, -100.0},{100.0,100.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200.0,110.0},{200.0,150.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100.0, -100.0},{100.0,100.0}}),Text(visible = true, extent = {{ -92.0, -92.0},{94.0, -74.0}}, textString = "active", fontName = "Arial")}));
//       Modelica.Blocks.Interfaces.BooleanOutput active annotation(Placement(visible = true, transformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90), iconTransformation(origin = {0.0, -110.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation =  -90)));
// 
//     initial equation 
//       active = false;
//     end StepWithSignal;
//     block Transition "Transition where the fire condition is set by a modification of variable condition"
//       input Boolean condition = true "= true, if transition may fire (time varying expression)" annotation(Dialog(group = "Fire condition"));
//       extends Interfaces.PartialTransition(final localCondition = condition);
//       annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -31.0,0.0},{ -11.0,0.0}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -10.0, -100.0},{10.0,100.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -10, -100},{10,100}}),Line(visible = true, points = {{ -30,0},{ -10,0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200,110},{200,150}}, textString = "%name"),Text(visible = true, extent = {{20,20},{200,45}}, textString = "%waitTime"),Text(visible = true, extent = {{ -200, -145},{200, -120}}, textString = "%condition")}));
//     end Transition;
//     block TransitionWithSignal "Transition where the fire condition is set by a Boolean input signal"
//       Modelica.Blocks.Interfaces.BooleanInput condition annotation(Placement(visible = true, transformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90), iconTransformation(origin = {0.0, -120.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 90)));
//       extends Interfaces.PartialTransition(final localCondition = condition);
//       annotation(Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -31.0,0.0},{ -11.0,0.0}}),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -10.0, -100.0},{10.0,100.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, extent = {{20.0,20.0},{200.0,45.0}}, textString = "%waitTime", fontName = "Arial"),Rectangle(visible = true, fillPattern = FillPattern.Solid, extent = {{ -10.0, -100.0},{10.0,100.0}}),Line(visible = true, points = {{ -30.0,0.0},{ -10.0,0.0}}),Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200.0,110.0},{200.0,150.0}}, textString = "%name", fontName = "Arial"),Ellipse(visible = true, fillPattern = FillPattern.Solid, extent = {{ -7.0, -95.0},{7.0, -81.0}})}));
//     end TransitionWithSignal;
//     block Alternative "Alternative splitting of execution path (use component between two steps)"
//       annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -80.0,100.0},{80.0,100.0}}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -80.0, -100.0},{80.0, -100.0}}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}),Line(visible = true, points = {{80.0,0.0},{100.0,0.0}})}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}),Line(visible = true, points = {{80.0,0.0},{100.0,0.0}})}), Documentation(info = "<html>
//   
// </html>"));
//       parameter Integer nBranches(min = 1) = 2 "Number of alternative branches";
//       Interfaces.Transition_in inPort annotation(Placement(visible = true, transformation(origin = { -103.0,0.0}, extent = {{ -3.0, -3.0},{3.0,3.0}}, rotation = 0), iconTransformation(origin = { -103.0,0.0}, extent = {{ -3.0, -3.0},{3.0,3.0}}, rotation = 0)));
//       Interfaces.Transition_out outPort annotation(Placement(visible = true, transformation(origin = {102.0,0.0}, extent = {{ -2.0, -2.0},{2.0,2.0}}, rotation = 0), iconTransformation(origin = {102.0,0.0}, extent = {{ -2.0, -2.0},{2.0,2.0}}, rotation = 0)));
//       Step_in_forAlternative join[nBranches] annotation(Placement(visible = true, transformation(origin = {79.0,0.0}, extent = {{ -1.0,100.0},{1.0, -100.0}}, rotation = 0), iconTransformation(origin = {79.0,0.0}, extent = {{ -1.0,100.0},{1.0, -100.0}}, rotation = 0)));
//       Step_out_forAlternative split[nBranches] annotation(Placement(visible = true, transformation(origin = { -79.0,0.0}, extent = {{1.0,100.0},{ -1.0, -100.0}}, rotation = 0), iconTransformation(origin = { -79.0,0.0}, extent = {{1.0,100.0},{ -1.0, -100.0}}, rotation = 0)));
//     protected 
//       connector Step_in_forAlternative "Input port of a step (has special icon for usage in component 'Alternative')"
//         output Boolean occupied "true, if step is active" annotation(Hide = true);
//         input Boolean set "true, if transition fires and step is activated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {160,160,160})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {160,160,160})}));
//       end Step_in_forAlternative;
//       connector Step_out_forAlternative "Output port of a step (has special icon for usage in component 'Alternative')"
//         output Boolean available "true, if step is active" annotation(Hide = true);
//         input Boolean reset "true, if transition fires and step is deactivated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {160,160,160})}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {160,160,160})}));
//       end Step_out_forAlternative;
// 
//     equation 
//       assert(cardinality(inPort) == 1, "Connector inPort is not connected to exactly one other connector");
//       assert(cardinality(outPort) == 1, "Connector outPort is not connected to exactly one other connector");
//       for i in 1:nBranches loop
//       assert(cardinality(split[i]) == 1, "Connector split[" + String(i) + "] is not connected to exactly one other connector");
//       assert(cardinality(join[i]) == 1, "Connector join[" + String(i) + "] is not connected to exactly one other connector");
// 
//       end for;
//       for i in 1:nBranches loop
//       split[i].available = if i == 1 then inPort.available else split[i - 1].available and not split[i - 1].reset;
// 
//       end for;
//       join.occupied = fill(outPort.occupied, nBranches);
//       inPort.reset = StateGraph.Temporary.anyTrue(split.reset);
//       outPort.set = StateGraph.Temporary.anyTrue(join.set);
//     end Alternative;
//     block Parallel "Parallel splitting of execution path (use component between two transitions)"
//       annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}),Line(visible = true, points = {{80.0,0.0},{100.0,0.0}}),Line(visible = true, points = {{ -80.0,100.0},{80.0,100.0}}, pattern = LinePattern.Dot),Line(visible = true, points = {{ -80.0, -100.0},{80.0, -100.0}}, pattern = LinePattern.Dot)}), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Line(visible = true, points = {{ -100.0,0.0},{ -80.0,0.0}}),Line(visible = true, points = {{80.0,0.0},{100.0,0.0}})}), Documentation(info = "<html>
//   
// </html>"));
//       parameter Integer nBranches(min = 1) = 2 "Number of parallel branches that are executed in parallel";
//       Interfaces.Step_in inPort annotation(Placement(visible = true, transformation(origin = { -103.0,0.0}, extent = {{ -3.0, -3.0},{3.0,3.0}}, rotation = 0), iconTransformation(origin = { -103.0,0.0}, extent = {{ -3.0, -3.0},{3.0,3.0}}, rotation = 0)));
//       Interfaces.Step_out outPort annotation(Placement(visible = true, transformation(origin = {102.0,0.0}, extent = {{ -2.0, -2.0},{2.0,2.0}}, rotation = 0), iconTransformation(origin = {102.0,0.0}, extent = {{ -2.0, -2.0},{2.0,2.0}}, rotation = 0)));
//       Transition_in_forParallel join[nBranches] annotation(Placement(visible = true, transformation(origin = {77.5,0.0}, extent = {{ -2.5,100.0},{2.5, -100.0}}, rotation = 0), iconTransformation(origin = {77.5,0.0}, extent = {{ -2.5,100.0},{2.5, -100.0}}, rotation = 0)));
//       Transition_out_forParallel split[nBranches] annotation(Placement(visible = true, transformation(origin = { -77.5,0.0}, extent = {{2.5,100.0},{ -2.5, -100.0}}, rotation = 0), iconTransformation(origin = { -77.5,0.0}, extent = {{2.5,100.0},{ -2.5, -100.0}}, rotation = 0)));
//     protected 
//       connector Transition_in_forParallel "Input port of a transition (has special icon for usage in component 'Parallel')"
//         input Boolean available "true, if step connected to the transition input is active" annotation(Hide = true);
//         output Boolean reset "true, if transition fires and the step connected to the transition input is deactivated" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {255,255,255}),Rectangle(extent = {{ -100,100},{100, -100}}, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid),Line(points = {{ -100,100},{ -100, -100}}, color = {0,0,0}, thickness = 0.5),Line(points = {{100,100},{100, -100}}, color = {0,0,0}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {255,255,255}, fillColor = {255,255,255}),Line(points = {{ -100,100},{ -100, -100}}, color = {0,0,0}, thickness = 0.5),Line(points = {{100,100},{100, -100}}, color = {0,0,0}, thickness = 0.5)}));
//       end Transition_in_forParallel;
//       connector Transition_out_forParallel "Output port of a transition (has special icon for usage in component 'Parallel')"
//         input Boolean occupied "true, if step connected to the transition output is active" annotation(Hide = true);
//         output Boolean set "true, if transition fires and step connected to the transition output becomes active" annotation(Hide = true);
//         annotation(Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {0,0,0}, fillColor = {255,255,255}),Rectangle(extent = {{ -100,100},{100, -100}}, lineColor = {255,255,255}, fillColor = {255,255,255}, fillPattern = FillPattern.Solid),Line(points = {{ -100,100},{ -100, -100}}, color = {0,0,0}, thickness = 0.5),Line(points = {{100,100},{100, -100}}, color = {0,0,0}, thickness = 0.5)}), Diagram(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(extent = {{ -100,100},{100, -100}}, fillPattern = FillPattern.Solid, lineColor = {255,255,255}, fillColor = {255,255,255}),Line(points = {{ -100,100},{ -100, -100}}, color = {0,0,0}, thickness = 0.5),Line(points = {{100,100},{100, -100}}, color = {0,0,0}, thickness = 0.5)}));
//       end Transition_out_forParallel;
// 
//     equation 
//       assert(cardinality(inPort) == 1, "Connector inPort is not connected to exactly one other connector");
//       assert(cardinality(outPort) == 1, "Connector outPort is not connected to exactly one other connector");
//       for i in 1:nBranches loop
//       assert(cardinality(split[i]) == 1, "Connector split[" + String(i) + "] is not connected to exactly one other connector");
//       assert(cardinality(join[i]) == 1, "Connector join[" + String(i) + "] is not connected to exactly one other connector");
// 
//       end for;
//       split.set = fill(inPort.set, nBranches);
//       join.reset = fill(outPort.reset, nBranches);
//       inPort.occupied = StateGraph.Temporary.anyTrue(split.occupied);
//       outPort.available = StateGraph.Temporary.allTrue(join.available);
//     end Parallel;
//     partial block PartialCompositeStep "Superclass of a subgraph, i.e., a composite step that has internally a StateGraph"
//       parameter Integer nSuspend = 1 "Number of suspend ports" annotation(Dialog(group = "Exception connections"));
//       parameter Integer nResume = 1 "Number of resume ports" annotation(Dialog(group = "Exception connections"));
//       inner outer StateGraph.Interfaces.CompositeStepState stateGraphRoot(suspend = StateGraph.Temporary.anyTrue(suspend.reset) or outerState.subgraphStatePort.suspend, resume = StateGraph.Temporary.anyTrue(resume.set) or outerState.subgraphStatePort.resume) "Communication port between the CompositeStep and the steps within the CompositeStep";
//       output Boolean active "= true if step is active, otherwise the step is not active";
//       annotation(structurallyIncomplete, Diagram(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, extent = {{ -150.0, -150.0},{150.0,150.0}})}), Documentation(info = "<html>
//   
// </html>"), Icon(coordinateSystem(extent = {{ -150.0, -150.0},{150.0,150.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -250.0,160.0},{250.0,200.0}}, textString = "%name", fontName = "Arial"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -150.0, -150.0},{150.0,150.0}}),Text(visible = true, extent = {{4.0, -130.0},{145.0, -115.0}}, textString = "resume", fontName = "Arial"),Text(visible = true, extent = {{ -144.0, -129.0},{ -3.0, -114.0}}, textString = "suspend", fontName = "Arial")}));
//       block OuterState
//         Interfaces.CompositeStepStatePort_in subgraphStatePort "port connected to outer stateGraphRoot";
//       end OuterState;
//       OuterState outerState;
//       StateGraph.Interfaces.Step_in inPort annotation(Placement(visible = true, transformation(origin = { -160.0,0.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0), iconTransformation(origin = { -160.0,0.0}, extent = {{ -10.0,10.0},{10.0, -10.0}}, rotation = 0)));
//       StateGraph.Interfaces.Step_out outPort annotation(Placement(visible = true, transformation(origin = {155.0,0.0}, extent = {{ -5.0,5.0},{5.0, -5.0}}, rotation = 0), iconTransformation(origin = {155.0,0.0}, extent = {{ -5.0,5.0},{5.0, -5.0}}, rotation = 0)));
//       StateGraph.Interfaces.CompositeStep_suspend suspend[nSuspend] annotation(Placement(visible = true, transformation(origin = { -75.0, -155.0}, extent = {{5.0, -5.0},{ -5.0,5.0}}, rotation = 90), iconTransformation(origin = { -75.0, -155.0}, extent = {{5.0, -5.0},{ -5.0,5.0}}, rotation = 90)));
//       StateGraph.Interfaces.CompositeStep_resume resume[nResume] annotation(Placement(visible = true, transformation(origin = {75.0, -160.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90), iconTransformation(origin = {75.0, -160.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 90)));
//     protected 
//       model InnerState
//         outer Interfaces.CompositeStepState stateGraphRoot;
//       end InnerState;
//       InnerState innerState;
//       Boolean newActive "Value of active in the next iteration" annotation(Hide = true);
//       Integer activeSteps "Number of active steps within the CompositeStep";
// 
//     initial equation 
//       pre(newActive) = pre(active);
// 
//     equation 
//       connect(outerState.subgraphStatePort,stateGraphRoot.subgraphStatePort);
//       outerState.subgraphStatePort.activeSteps = if active then 1.0 else 0.0;
//       activeSteps =  -integer(innerState.stateGraphRoot.subgraphStatePort.activeSteps);
//       active = pre(newActive);
//       newActive = activeSteps > 0 and not StateGraph.Temporary.anyTrue(suspend.reset) and not outerState.subgraphStatePort.suspend or StateGraph.Temporary.anyTrue(resume.set) or outerState.subgraphStatePort.resume;
//       for i in 1:nResume loop
//       resume[i].occupied = if i == 1 then active else resume[i - 1].occupied or resume[i - 1].set;
// 
//       end for;
//       for i in 1:nSuspend loop
//       suspend[i].available = if i == 1 then active else suspend[i - 1].available and not suspend[i - 1].reset;
// 
//       end for;
//       for i in 1:nSuspend loop
//       assert(cardinality(suspend[i]) <= 1, "Connector suspend[" + String(i) + "] of the CompositeStep is connected to more than one transition");
// if cardinality(suspend[i]) == 0 then
//               suspend[i].reset = false;
//       end if;
// 
//       end for;
//       for i in 1:nResume loop
//       assert(cardinality(resume[i]) <= 1, "Connector resume[" + String(i) + "] of the CompositeStep is connected to more than one transition");
// if cardinality(resume[i]) == 0 then
//               resume[i].set = false;
//       end if;
// 
//       end for;
// if cardinality(inPort) < 2 then
//               inPort.occupied = false;
//         inPort.set = false;
//       end if;
// if cardinality(outPort) < 2 then
//               outPort.available = false;
//         outPort.reset = false;
//       end if;
//       assert(cardinality(inPort) <= 2, "Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.");
//       assert(cardinality(outPort) <= 2, "Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.");
//     end PartialCompositeStep;
//     block StateGraphRoot "Root of a StateGraph (has to be present on the highest level of a StateGraph)"
//       extends StateGraph.Interfaces.CompositeStepState;
//       output Integer activeSteps "Number of active steps within the stategraph";
//       annotation(defaultComponentName = "stateGraphRoot", defaultComponentPrefixes = "inner", Documentation(info = "<html>
// <p>
// On the highest level of a StateGraph, an instance of StateGraphRoot
// has to be present. 
// Practically, this means that it need not be present in a
// StateGraph model.
// </p>
// <p>
// The StateGraphRoot object is needed, since all Step objects have
// an \"outer\" reference to communicate with the \"nearest\" CompositeStep
// (which inherits from PartialCompositeStep), especially to abort
// a CompositeStep via the \"suspend\" port. Even if no \"CompositeStep\" is present,
// on highest level a corresponding \"inner\" definition is needed
// and is provided by the StateGraphRoot object.
// </p>
// </html>", revisions = ""), Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Text(visible = true, fillColor = {0,0,255}, fillPattern = FillPattern.Solid, extent = {{ -200,110},{200,150}}, textString = "%name"),Rectangle(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Solid, extent = {{ -100, -100},{100,100}}),Text(visible = true, extent = {{ -92,34},{96,78}}, textString = "root"),Rectangle(visible = true, extent = {{ -82, -40},{ -44, -6}}),Line(visible = true, points = {{0,10},{0, -60}}),Rectangle(visible = true, extent = {{48, -40},{86, -6}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{ -12, -16},{0, -22},{ -12, -28},{ -12, -16}}),Line(visible = true, points = {{ -44, -22},{ -12, -22}}),Polygon(visible = true, fillPattern = FillPattern.Solid, points = {{36, -16},{48, -22},{36, -28},{36, -16}}),Line(visible = true, points = {{0, -22},{36, -22}})}));
// 
//     equation 
//       activeSteps =  -integer(subgraphStatePort.activeSteps);
//     end StateGraphRoot;
//     package Temporary "Components that will be provided by other libraries in the future"
//       type SetRealParameter = Real "Define Real parameter (GUI not yet satisfactory)" annotation(Dialog, defaultComponentName = "name", defaultComponentPrefixes = "parameter", Icon(coordinateSystem(extent = {{ -100, -100},{100,100}}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100, -40},{100,40}}),Text(visible = true, extent = {{ -150,50},{150,90}}, textString = "%name ="),Text(visible = true, extent = {{ -96, -15},{96,15}}, textString = "%value")}), Documentation(info = "<html>
// <p>
// This is an <b>experimental component</b> to define a 
// <b>Real parameter</b>
// in the <b>diagram layer</b>. The idea is to drag the icon from the 
// package browser into the diagram layer. Then a window pops
// up in which the properties of this parameter can be defined
// (such as the default value). The name and default value of the
// parameter are displayed in the icon of this component. Whenever
// clicking on it, the dialog to change parameter settings pops-up.
// </p>
// <p>
// In Dymola, the described property is not fully available.
// Currently, when dragging this component in the diagram layer,
// a dialog pops up in which the properties of the parameter
// can be defined. However, afterwards, the parameter is not
// visible in the diagram layer. Making it visible requires to
// go into the text layer and add an annotation with the
// component size, resulting for example in:
// </p>
// <pre>
//   <b>parameter</b> StateGraph.SetRealParameter name = 2 
//                        <b>annotation</b>(extent=[-10,-10; 10,10]);
// </pre>
// <p>
// This change makes the parameter icon visible in the
// diagram layer. However, clicking on this icon has no
// effect. Changing parameter properties, such as the default
// value, still requires to go in to the text layer.
// </p>
// </html>"));
//       extends Modelica.Icons.Library;
//       function anyTrue "Returns true, if at least on element of the Boolean input vector is true"
//         extends Modelica.Icons.Function;
//         input Boolean b[:];
//         output Boolean result;
//       algorithm 
//         result:=false;
//         for i in 1:size(b, 1) loop
//                   result:=result or b[i];
// 
//         end for;
//         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end anyTrue;
//       function allTrue "Returns true, if all elements of the Boolean input vector are true"
//         extends Modelica.Icons.Function;
//         input Boolean b[:];
//         output Boolean result;
//       algorithm 
//         result:=true;
//         for i in 1:size(b, 1) loop
//                   result:=result and b[i];
// 
//         end for;
//         annotation(Documentation(info = "<html>
//   
// </html>"));
//       end allTrue;
//       block RadioButton "Button that sets its output to true when pressed and is reset when an element of 'reset' becomes true"
//         parameter Modelica.SIunits.Time buttonTimeTable[:] = {0} "Time instants where button is pressend and released";
//         input Boolean reset[:] = {false} "Reset button to false, if an element of reset becomes true" annotation(Dialog(group = "Time varying expressions"));
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, fillColor = {210,210,210}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100.0, -100.0},{100.0,100.0}}),Text(visible = true, extent = {{ -80.0, -40.0},{80.0,40.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.BooleanOutput on annotation(Placement(visible = true, transformation(origin = {110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0), iconTransformation(origin = {110.0,0.0}, extent = {{ -10.0, -10.0},{10.0,10.0}}, rotation = 0)));
//       protected 
//         Modelica.Blocks.Sources.BooleanTable table(table = buttonTimeTable);
//       algorithm 
//         on:=table.y;
//         when pre(reset) then
//                   on:=false;
//         
//         end when;
//       end RadioButton;
//       model NumericValue "Show value of Real input signal dynamically"
//         parameter Integer precision(min = 0) = 3 "Number of significant digits to be shown";
//         parameter Boolean hideConnector = false "= true, if connector is not shown in the dynamic object diagram";
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Rectangle(visible = true, lineColor = {0,0,255}, fillColor = {236,233,216}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, lineThickness = 4, borderPattern = BorderPattern.Raised, extent = {{ -100.0, -50.0},{100.0,50.0}})}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.RealInput Value "Real value to be shown in icon" annotation(Placement(visible = true, transformation(origin = { -120.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0), iconTransformation(origin = { -120.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//       end NumericValue;
//       model IndicatorLamp "Dynamically show Boolean input signal (false/true = white/green color)"
//         annotation(Icon(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10}), graphics = {Ellipse(visible = true, fillColor = {255,255,255}, fillPattern = FillPattern.Sphere, extent = {{ -100.0, -100.0},{100.0,100.0}}),Text(visible = true, extent = {{ -150.0,110.0},{150.0,150.0}}, textString = "%name", fontName = "Arial")}), Documentation(info = "<html>
//   
// </html>"), Diagram(coordinateSystem(extent = {{ -100.0, -100.0},{100.0,100.0}}, preserveAspectRatio = true, initialScale = 0.1, grid = {10,10})));
//         Modelica.Blocks.Interfaces.BooleanInput u annotation(Placement(visible = true, transformation(origin = { -120.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0), iconTransformation(origin = { -120.0,0.0}, extent = {{ -20.0, -20.0},{20.0,20.0}}, rotation = 0)));
//       end IndicatorLamp;
//       annotation(Documentation(info = "<html>
// <p>
// This library is just temporarily present. The components of
// this library will be present in the future in the Modelica
// standard library (with the new block connectors) and in the
// UserInteraction library that is currently under development.
// </p>
// </html>"));
//     end Temporary;
//   end StateGraph;
// end Modelica;
// 
// "
// endResult
