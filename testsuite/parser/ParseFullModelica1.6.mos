// name:     ParseFullModelica1.6
// keywords: parse
// status:   correct
// env: OPENMODELICALIBRARY=../../libraries/msl16
// 
// Parse/Unparse entire MSL 1.6
//

loadModel(Modelica);
getErrorString();
list();

// Result:
// true
// ""
// "package Modelica "Modelica Standard Library"
//   extends Icons.Library;
//   annotation(Window(x = 0.02, y = 0.01, width = 0.2, height = 0.57, library = 1, autolayout = 1), version = "1.6", versionDate = "2004-06-30", Dymola(checkSum = "1560322557:4250690600"), Documentation(info = "<HTML>
// <p>
// Package <b>Modelica</b> is a <b>standardized</b> and <b>pre-defined</b> package
// that is developed together with the Modelica language from the
// Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// It is also called <b>Modelica Standard Library</b>.
// It provides constants, types, connectors, partial models and model
// components
// in various disciplines.
// </p>
// 
// <p>
// For an introduction, have especially a look at:
// </p>
// <ul>
// <li> <a href=\"Modelica:Modelica.UsersGuide\">Modelica.UsersGuide</a>
//      discusses the most important aspects of this library.</li>
// <li> Packages <b>Examples</b> in the various subpackages, provide
//      demos of the corresponding subpackage.</li>
// </ul>
// 
// <p>
// The Modelica package consists currently of the following subpackages
// </p>
// <pre>
//    <b>Constants</b>   Mathematical and physical constants (pi, eps, h, ...)
//    <b>Icons</b>       Icon definitions of general interest
//    <b>Math</b>        Mathematical functions (such as sin, cos)
//    <b>SIunits</b>     SI-unit type definitions (such as Voltage, Torque)
//    <b>Blocks</b>      Input/output blocks.
//    <b>Electrical</b>  Electric and electronic components.
//    <b>Mechanics</b>   Mechanical components
//                (currently: 1D-rotational and 1D-translational components)
//    <b>Thermal</b>     Thermal components
//                (currently: 1-D heat transfer with lumped elements)
// </pre>
// 
// <p>
// Copyright &copy; 1998-2004, Modelica Association.
// </p>
// 
// <p>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> 
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">here</a>.</i>
// </p><br>
// </HTML>
// "));
//   package UsersGuide "Users Guide"
//     annotation(DocumentationClass = true, Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Users Guide of the Modelica Standard Library</font></h3>
// <p>
// Package <b>Modelica</b> is a <b>standardized</b> and <b>pre-defined</b> package
// that is developed together with the Modelica language from the
// Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// It is also called <b>Modelica Standard Library</b>.
// It provides constants, types, connectors, partial models and model
// components in various disciplines.
// </p>
// <p>
// This package contains the <b>users guide</b> for 
// the library and has the following content
// (this users guide will be improved in the future):
// </p>
// <ol>
// <li><a href=\"Modelica://Modelica.UsersGuide.OverView\">Overview of library</a>
//      gives an overview of the library.</li>
// <li><a href=\"Modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
//     summarizes the differences between different versions of this library.</li>
// <li><a href=\"Modelica://Modelica.UsersGuide.Contact\">Contact</a> 
//     provides information about the authors of the library as well as
//     acknowledgments.</li>
// <li><a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense\">ModelicaLicense</a> 
//     defines the license conditions for using this library.</li>
// </ol>
// </html>"));
//     class OverView "Overview of library"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Overview of Library Modelica</font></h3>
// 
// <p>
// An overview of the Modelica Standard Library
// will be given here.
// </p>
// 
// <p>
// <br><br><br>
// </p>
// 
// <p>
// In the Modelica package the following conventions are used:
// </p>
// <ul>
// <li>
// Class and instance names are written in upper and lower case
// letters, e.g., \"ElectricCurrent\". An underscore is only used
// at the end of a name to characterize a lower or upper index,
// e.g., body_low_up.<br><br>
// </li>
// <li>
// Type names start always with an upper case letter.
// Instance names start always with a lower case letter with only
// a few exceptions, such as \"T\" for a temperature instance,
// if this is common sense.<br><br>
// </li>
// <li>
// A package XXX has its interface definitions in subpackage
// XXX.Interfaces, e.g., Electrical.Interfaces. <br><br>
// </li>
// <li>
// Preferred instance names for connectors:
// <pre>
//   p,n: positive and negative side of a partial model.
//   a,b: side \"a\" and side \"b\" of a partial model
//        (= connectors are completely equivalent).
// </pre>
// </li>
// </ul>
// 
// </html>
// "));
//     end OverView;
//     class ReleaseNotes "Release notes"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Release notes</font></h3>
// 
// <h3><font color=\"#008000\">Version 1.6 (June 30, 2004)</font></h3>
// 
// <p> Added 1 new library (Electrical.MultiPhase), 17 new components, 
//     improved 3 existing components
//     in the Modelica.Electrical library and improved 3 types
//     in the Modelica.SIunits library. Furthermore,
//     this Users Guide has been started. The improvements
//     in more detail:
// </p>
// 
// <p>
// <b>New components</b>
// </p>
// 
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
//   <tr><td>SaturatingInductor</td>
//       <td>Simple model of an inductor with saturation</td></tr>
//   <tr><td>VariableResistor</td>
//       <td>Ideal linear electrical resistor with variable resistance</td></tr>
//   <tr><td>VariableConductor</td>
//       <td>Ideal linear electrical conductor with variable conductance</td></tr>
//   <tr><td>VariableCapacitor</td>
//       <td>Ideal linear electrical capacitor with variable capacitance</td></tr>
//   <tr><td>VariableInductor</td>
//       <td>Ideal linear electrical inductor with variable inductance</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors.</b></td></tr>
//   <tr><td>HeadingDiode</td>
//       <td>Simple diode with heating port</td></tr>
//   <tr><td>HeadingNMOS</td>
//       <td>Simple MOS Transistor with heating port</td></tr>
//   <tr><td>HeadingPMOS</td>
//       <td>Simple PMOS Transistor with heating port</td></tr>
//   <tr><td>HeadingNPN</td>
//       <td>Simple NPN BJT according to Ebers-Moll with heating port</td></tr>
//   <tr><td>HeadingPNP</td>
//       <td>Simple PNP BJT according to Ebers-Moll with heating port</td></tr>
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase</b><br>
//       A new library for multi-phase electrical circuits</td></tr>
// </table>
// 
// <p>
// <b>New examples</b>
// </p>
// 
// <p>
// The following new examples have been added to 
// Modelica.Electrical.Analog.Examples:
// </p>
// 
// <p>
// CharacteristicThyristors, 
// CharacteristicIdealDiodes,
// HeatingNPN_OrGate,
// HeatingMOSInverter,
// HeatingRectifier,
// Rectifier,
// ShowSaturatingInductor
// ShowVariableResistor
// </p>
// 
// <p>
// <b>Improved existing components</b>
// </p>
// 
// <p>In the library Modelica.Electrical.Analog.Ideal,
//    a knee voltage has been introduced for the components
//    IdealThyristor, IdealGTOThyristor, IdealDiode in order
//    that the approximation of these ideal elements is improved
//    with not much computational effort.</p>
// 
// <p> In the Modelica.SIunits library, the following changes
//     have been made:</p>
// 
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td>Inductance</td>
//       <td>min=0 removed</td></tr>
//   <tr><td>SelfInductance</td>
//       <td>min=0 added</td></tr>
//   <tr><td>ThermodynamicTemperature</td>
//       <td>min=0 added</td></tr>
// </table>
// 
// 
// 
// <h3><font color=\"#008000\">Version 1.5 (December 16, 2002)</font></h3>
// 
// <p> Added 55 new components. In particular, added new package
//     <b>Thermal.HeatTransfer</b> for modeling of lumped
//     heat transfer, added model <b>LossyGear</b> in Mechanics.Rotational
//     to model gear efficiency and bearing friction according to a new
//     theory in a robust way, added 10 new models in Electrical.Analog and 
//     added several other new models and improved existing models. 
// </p>
// 
// 
// <p>
// <b>New components</b>
// </p>
// 
// <table border=\"1\" cellspacing=0 cellpadding=2>
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.</b></td></tr>
//   <tr><td>Continuous.Der</td><td>Derivative of input (= analytic differentations)</td></tr>
//   <tr><td><b><i>Examples</i></b></td><td>Demonstration examples of the components of this package</td></tr>
//   <tr><td>Nonlinear.VariableLimiter</td><td>Limit the range of a signal with variable limits</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Interfaces.</b></td></tr>
//   <tr><td>RealPort</td><td>Real port (both input/output possible)</td></tr>
//   <tr><td>IntegerPort</td><td>Integer port (both input/output possible)</td></tr>
//   <tr><td>BooleanPort</td><td>Boolean port (both input/output possible)</td></tr>
//   <tr><td>SIMO</td><td>Single Input Multiple Output continuous control block</td></tr>
//   <tr><td>IntegerBlockIcon</td><td>Basic graphical layout of Integer block</td></tr>
//   <tr><td>IntegerMO</td><td>Multiple Integer Output continuous control block</td></tr>
//   <tr><td>IntegerSignalSource</td><td>Base class for continuous Integer signal source</td></tr>
//   <tr><td>IntegerMIBooleanMOs</td><td>Multiple Integer Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
//   <tr><td>BooleanMIMOs</td><td>Multiple Input Multiple Output continuous control block with same number of inputs and outputs of boolean type</td></tr>
//   <tr><td><b><i>BusAdaptors</i></b></td><td>Components to send signals to the bus or receive signals from the bus</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
//   <tr><td>RealToInteger</td><td>Convert real to integer signals</td></tr>
//   <tr><td>IntegerToReal</td><td>Convert integer to real signals</td></tr>
//   <tr><td>Max</td><td>Pass through the largest signal</td></tr>
//   <tr><td>Min</td><td>Pass through the smallest signal</td></tr>
//   <tr><td>Edge</td><td>Indicates rising edge of boolean signal</td></tr>
//   <tr><td>BooleanChange</td><td>Indicates boolean signal changing</td></tr>
//   <tr><td>IntegerChange</td><td>Indicates integer signal changing</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
//   <tr><td>IntegerConstant</td><td>Generate constant signals of type Integer</td></tr>
//   <tr><td>IntegerStep</td><td>Generate step signals of type Integer</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
//   <tr><td>HeatingResistor</td><td>Temperature dependent electrical resistor</td></tr>
//   <tr><td>OpAmp</td><td>Simple nonideal model of an OpAmp with limitation</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Ideal.</b></td></tr>
//   <tr><td>IdealCommutingSwitch</td><td>Ideal commuting switch</td></tr>
//   <tr><td>IdealIntermediateSwitch</td><td>Ideal intermediate switch</td></tr>
//   <tr><td>ControlledIdealCommutingSwitch</td><td>Controlled ideal commuting switch</td></tr>
//   <tr><td>ControlledIdealIntermediateSwitch</td><td>Controlled ideal intermediate switch</td></tr>
//   <tr><td>IdealOpAmpLimited</td><td>Ideal operational amplifier with limitation</td></tr>
//   <tr><td>IdealOpener</td><td>Ideal opener</td></tr>
//   <tr><td>IdealCloser</td><td>Ideal closer</td></tr>
//   <tr><td>ControlledIdealOpener</td><td>Controlled ideal opener</td></tr>
//   <tr><td>ControlledIdealCloser</td><td>Controlled ideal closer</td></tr>
//   
//   <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Lines.</b></td></tr>
//   <tr><td>TLine1</td><td>Lossless transmission line (Z0, TD)</td></tr>
//   <tr><td>TLine2</td><td>Lossless transmission line (Z0, F, NL)</td></tr>
//   <tr><td>TLine2</td><td>Lossless transmission line (Z0, F)</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
//   <tr><td>Function</td><td>Icon for a function</td></tr>
//   <tr><td>Record</td><td>Icon for a record</td></tr>
//   <tr><td>Enumeration</td><td>Icon for an enumeration</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Math.</b></td></tr>
//   <tr><td>tempInterpol2</td><td>temporary routine for vectorized linear interpolation (will be removed)</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
//   <tr><td>Examples.LossyGearDemo1</td><td>Example to show that gear efficiency may lead to stuck motion</td></tr>
//   <tr><td>Examples.LossyGearDemo2</td><td>Example to show combination of LossyGear and BearingFriction</td></tr>
//   <tr><td>LossyGear</td><td>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</td></tr>
//   <tr><td>Gear2</td><td>Realistic model of a gearbox (based on LossyGear)</td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
//   <tr><td><b><i>Conversions</i></b></td><td>Conversion functions to/from non SI units and type definitions of non SI units</td></tr>
//   <tr><td>EnergyFlowRate</td><td>Same definition as <i>Power</i></td></tr>
//   <tr><td>EnthalpyFlowRate</td><td><tt>Real (final quantity=\"EnthalpyFlowRate\", final unit=\"W\")</tt></td></tr>
// 
//   <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
//   <tr><td><b><i>Thermal.HeatTransfer</i></b></td><td>1-dimensional heat transfer with lumped elements</td></tr>
// 
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Discrete.</b></td></tr>
//   <tr><td>TriggeredSampler</td><td>Triggered sampling of continuous signals</td></tr>
//   <tr><td>TriggeredMax</td><td>Compute maximum, absolute value of continuous signal at trigger instants</td></tr>
// 
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.Interfaces.</b></td></tr>
//   <tr><td>BooleanMIRealMOs</td><td>Multiple Boolean Input Multiple Real Output continuous control block with same number of inputs and outputs</td></tr>
//   <tr><td>RealMIBooleanMOs</td><td>Multiple Real Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
// 
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.</b></td></tr>
//   <tr><td>TriggeredTrapezoid</td><td>Triggered trapezoid generator</td></tr>
//   <tr><td>Hysteresis</td><td>Transform Real to Boolean with Hysteresis</td></tr>
//   <tr><td>OnOffController</td><td>On-off controller</td></tr>
//   <tr><td>Compare</td><td>True, if signal of inPort1 is larger than signal of inPort2</td></tr>
//   <tr><td>ZeroCrossing</td><td>Trigger zero crossing of input signal</td></tr>
// 
//   <tr><td colspan=\"2\"><b>ModelicaAdditions.</b></td></tr>
//   <tr><td>Blocks.Multiplexer.Extractor</td><td>Extract scalar signal out of signal vector dependent on IntegerInPort index</td></tr>
//   <tr><td>Tables.CombiTable1Ds</td><td>Table look-up in one dimension (matrix/file) with only single input</td></tr>
// </table>
// 
// <p>
// <b>Package-specific Changes</b>
// </p>
// 
// <ul>
//   <li>All example models made <b>encapsulated</b></li>
//   <li>Upper case constants changed to lower case (cf. Modelica.Constants)</li>
//   <li>Introduced Modelica.SIunits.Wavelength due to typo \"Wavelenght\"</li>
//   <li>Introduced ModelicaAdditions.Blocks.Logical.Interfaces.Comparison due to typo \"Comparision\"</li>
//   <li>Changed these components of *.Blocks to <tt>block</tt> class, which have not been already of block type</li>
//   <li>Changed *.Interfaces.RelativeSensor to <tt>partial</tt> models</li>
// </ul>
// 
// <p>
// <b>Class-specific Changes</b>
// </p>
// 
// <p>
// <i>Modelica.SIunits</i>
// </p>
// 
// <p>Removed <tt>final</tt> from quantity attribute for <i>Mass</i> and <i>MassFlowRate</i>.</p>
// 
// <p>
// <i>Modelica.Blocks.Math.Sum</i>
// </p>
// 
// <p>Implemented avoiding algorithm section, which would lead to expensive function calls.</p>
// 
// <p><i>Modelica.Blocks.Sources.Step</i></p>
// <pre>
//   block Step \"Generate step signals of type Real\"
//     parameter Real height[:]={1} \"Heights of steps\";
// <b> // parameter Real offset[:]={0} \"Offsets of output signals\";
//  // parameter SIunits.Time startTime[:]={0} \"Output = offset for time < startTime\";
//  // extends Interfaces.MO          (final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));
//     extends Interfaces.SignalSource(final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));</b>
// </pre>
// 
// <p><i>Modelica.Blocks.Sources.Exponentials</i></p>
// 
// <p>Replaced usage of built-in function <tt>exp</tt> by Modelica.Math.exp.</p>
// 
// <p><i>Modelica.Blocks.Sources.TimeTable</i></p>
// 
// <p>Interface definition changed from</p>
// 
// <pre>    parameter Real table[:, :]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// 
// <p>to</p>
// 
// <pre>    parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// 
// <p>Did the same for subfunction <i>getInterpolationCoefficients</i>.</p>
// 
// <p>Bug in <i>getInterpolationCoefficients</i> for startTime <> 0 fixed:</p>
// 
// <pre>        ...
//         end if;
//       end if;
//       <b>// Take into account startTime \"a*(time - startTime) + b\"
//       b := b - a*startTime;</b>
//     end getInterpolationCoefficients;
// </pre>
// 
// <p><i>Modelica.Blocks.Sources.BooleanStep</i></p>
// 
// <pre>
//   block BooleanStep \"Generate step signals of type Boolean\"
//     parameter SIunits.Time startTime[:]={0} \"Time instants of steps\";
//     <b>parameter Boolean startValue[size(startTime, 1)]=fill(false, size(startTime, 1)) \"Output before startTime\";</b>
//     extends Interfaces.BooleanSignalSource(final nout=size(startTime, 1));
//   equation
//     for i in 1:nout loop
//  <b>//   outPort.signal[i] = time >= startTime[i];
//       outPort.signal[i] = if time >= startTime[i] then not startValue[i] else startValue[i];</b>
//     end for;
//   end BooleanStep;
// </pre>
// 
// <p>
// <i>Modelica.Electrical.Analog</i></p>
// 
// <p>Corrected table of values and default for Beta by dividing them by 1000
// (consistent with the values used in the NAND-example model):
// </p>
// <ul>
// <li>Semiconductors.PMOS</li>
// <li>Semiconductors.NMOS</li>
// </ul>
// <p>Corrected parameter defaults, unit and description for TrapezoidCurrent.
// This makes the parameters consistent with their use in the model.
// 
// Models specifying parameter values are not changed.
// Models not specifying parameter values did not generate trapezoids previously.
// </p>
// 
// <p>Icon layer background changed from transparent to white:</p>
// 
// <ul>
//   <li>Basic.Gyrator</li>
//   <li>Basic.EMF</li>
//   <li>Ideal.Idle</li>
//   <li>Ideal.Short</li>
// </ul>
// 
// <p>Basic.Transformer: Replaced invalid escape characters '\\ ' and '\\[newline]' in documentation by '|'.</p>
// 
// 
// <p><i>Modelica.Mechanics.Rotational</i></p>
// 
// <p>Removed arrows and names documentation from flanges in diagram layer</p>
// 
// <p><i>Modelica.Mechanics.Rotational.Interfaces.FrictionBase</i></p>
// 
// <p><i>Modelica.Mechanics.Rotational.Position</i></p>
// 
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// 
// <p><i>Modelica.Mechanics.Rotational.RelativeStates/i></p>
// 
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// 
// <p><i>Modelica.Mechanics.Translational.Interfaces.flange_b</i></p>
// 
// <p>Attribute <b>fillColor=7</b> added to Rectangle on Icon layer, i.e. it is now
// filled with white and not transparent any more.</p>
// 
// <p><i>Modelica.Mechanics.Translational.Position</i></p>
// 
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// 
// <p><i>Modelica.Mechanics.Translational.RelativeStates</i></p>
// 
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// 
// <p><i>Modelica.Mechanics.Translational.Stop</i></p>
// 
// <p>Use <tt>stateSelect = StateSelect.prefer</tt>.</p>
// 
// <p><i>Modelica.Mechanics.Translational.Examples.PreLoad</i></p>
// 
// <p>Improved documentation and coordinate system used for example.</p>
// 
// <p><i>ModelicaAdditions.Blocks.Nonlinear.PadeDelay</i></p>
// 
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// 
// <p><i>ModelicaAdditions.HeatFlow1D.Interfaces</i></p>
// 
// <p>Definition of connectors <i>Surface_a</i> and <i>Surface_b</i>:<br>
// <tt>flow SIunits.HeatFlux q;</tt> changed to <tt>flow SIunits.HeatFlowRate q;</tt></p>
// 
// <p><i>MultiBody.Parts.InertialSystem</i></p>
// 
// <p>Icon corrected.</p>
// 
// 
// 
// <h3><font color=\"#008000\">Version 1.4.1 (June 28, 2001)</font></h3>
// 
// <ul>
// <li>Several minor bugs fixed. </li>
// <li>New models:<br>
//     Modelica.Blocks.Interfaces.IntegerInPort/IntegerOutPort,<br>
//     Modelica.Blocks.Math.TwoInputs/TwoOutputs<br>
//     Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin,<br>
//     Modelica.Mechanics.Rotational.Move,<br>
//     Modelica.Mechanics.Translational.Move.<br>
//     </li>
// </ul>
// 
// 
// <h3><font color=\"#008000\">Version 1.4.1beta1 (February 12, 2001)</font></h3>
// 
// <p> Adapted to Modelica 1.4</p>
// 
// 
// <h3><font color=\"#008000\">Version 1.3.2beta2 (June 20, 2000)</font></h3>
// <ul>
//     <li>New subpackage Modelica.Mechanics.<b>Translational</b></li>
//     <li>Changes to Modelica.Mechanics.<b>Rotational</b>:<br>
//        New elements:
// <pre>
//    IdealGearR2T    Ideal gear transforming rotational in translational motion.
//    Position        Forced movement of a flange with a reference angle
//                    given as input signal
//    RelativeStates  Definition of relative state variables
// </pre>
// </li>
// 
//     <li>Changes to Modelica.<b>SIunits</b>:<br>
//       Introduced new types:<br>
//       type Temperature = ThermodynamicTemperature;<br>
//       types DerDensityByEnthalpy, DerDensityByPressure,
//       DerDensityByTemperature, DerEnthalpyByPressure,
//       DerEnergyByDensity, DerEnergyByPressure<br>
//       Attribute \"final\" removed from min and max values
//       in order that these values can still be changed to narrow
//       the allowed range of values.<br>
//       Quantity=\"Stress\" removed from type \"Stress\", in order
//       that a type \"Stress\" can be connected to a type \"Pressure\".</li>
// 
//     <li>Changes to Modelica.<b>Icons</b>:<br>
//        New icons for motors and gearboxes.</li>
// 
//     <li>Changes to Modelica.<b>Blocks.Interfaces</b>:<br>
//        Introduced a replaceable signal type into
//        Blocks.Interfaces.InPort/OutPort:
// <pre>
//    replaceable type SignalType = Real
// </pre>
//        in order that the type of the signal of an input/output block
//        can be changed to a physical type, for example:
// 
// <pre>
//    Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
// </pre>
//       </li></ul>
// </li>
// </ul>
// 
// 
// <h3><font color=\"#008000\">Version 1.3.1 (Dec. 13, 1999)</font></h3>
// 
// <p>
// First official release of the library.
// </p>
// 
// </html>
// "));
//     end ReleaseNotes;
//     class Contact "Contact"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>Contact</font></h3>
// 
// <dl>
// <dt>The development of the Modelica package is organized by</dt>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br> 
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br></dd>
// </dl>
// 
// <p>
// This library is developed by several people from
// the Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// In particular, the following people have contributed:
// </p>
// 
// 
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td><b>Peter Beater</b> </td
//       <td> University of Paderborn, Germany</td>
//       <td> Modelica.Mechanics.Translational </td>
//   </tr>
// 
//   <tr><td><b>Christoph Clau&szlig;</b> </td
//       <td> Fraunhofer Institute for Integrated Circuits, Dresden, Germany</td>
//       <td> Modelica.Electrical </td>
//   </tr>
// 
//   <tr><td><b>Anton Haumer</b> </td
//       <td> Consultant, St.Andrae-Woerdern, Austria</td>
//       <td> Modelica.Electrical </td>
//   </tr>
// 
//   <tr><td><b>Martin Otter</b> </td
//       <td> DLR, German Aerospace Center, Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Blocks<br> 
//            Modelica.Mechanics.Rotational<br>
//            Modelica.Math<br>
//            Modelica.SIunits<br>
//            Modelica.Thermal</td>
//   </tr>
// 
//   <tr><td><b>Andr&eacute; Schneider</b> </td
//       <td> Fraunhofer Institute for Integrated Circuits, Dresden, Germany</td>
//       <td> Modelica.Electrical </td>
//   </tr>
// 
//   <tr><td><b>Christian Schweiger</b> </td
//       <td> DLR, German Aerospace Center, Oberpfaffenhofen, Germany</td>
//       <td> Modelica.Mechanics.Rotational</td>
//   </tr>
// 
//   <tr><td><b>Michael Tiller</b> </td
//       <td> Ford Motor Company, Dearborn, MI, U.S.A </td>
//       <td> Modelica.Thermal</td>
//   </tr>
// 
//   <tr><td><b>Hubertus Tummescheit</b> </td
//       <td> Scynamics, Lund, Sweden</td>
//       <td> Modelica.Thermal</td>
//   </tr>
// </table>
// 
// </html>
// "));
//     end Contact;
//     class ModelicaLicense "Modelica License"
//       annotation(Documentation(info = "<html>
// <h3><font color=\"#008000\" size=5>The Modelica License 
// (Version 1.1 of June 30, 2000) </font></h3>
// 
// <p>Redistribution and use in source and binary forms, with or without
// modification are permitted, provided that the following conditions are met:
// <ol>
// <li>
// The author and copyright notices in the source files, these license conditions
// and the disclaimer below are (a) retained and (b) reproduced in the documentation
// provided with the distribution.</li>
// 
// <li>
// Modifications of the original source files are allowed, provided that a
// prominent notice is inserted in each changed file and the accompanying
// documentation, stating how and when the file was modified, and provided
// that the conditions under (1) are met.</li>
// 
// <li>
// It is not allowed to charge a fee for the original version or a modified
// version of the software, besides a reasonable fee for distribution and support.
// Distribution in aggregate with other (possibly commercial) programs
// as part of a larger (possibly commercial) software distribution is permitted,
// provided that it is not advertised as a product of your own.</li>
// </ol>
// 
// <h4><font color=\"#008000\">Disclaimer</font></h4>
// 
// <p>The software (sources, binaries, etc.) in their original or in a modified
// form are provided
// \"as is\" and the copyright holders assume no responsibility for its contents
// what so ever. Any express or implied warranties, including, but not
// limited to, the implied warranties of merchantability and fitness for a
// particular purpose are <b>disclaimed</b>. <b>In no event</b> shall the
// copyright holders, or any party who modify and/or redistribute the package,
// <b>be liable</b> for any direct, indirect, incidental, special, exemplary, or
// consequential damages, arising in any way out of the use of this software,
// even if advised of the possibility of such damage.
// </p>
// 
// </html>
// "));
//     end ModelicaLicense;
//   end UsersGuide;
//   package Blocks "Library for basic input/output control blocks"
//     import SI = Modelica.SIunits;
//     extends Modelica.Icons.Library2;
//     annotation(Window(x = 0.03, y = 0.05, width = 0.21, height = 0.48, library = 1, autolayout = 1), Icon(Rectangle(extent = [ -32, -6;16, -35], style(color = 0)), Rectangle(extent = [ -32, -56;16, -85], style(color = 0)), Line(points = [16, -20;49, -20;49, -71;16, -71], style(color = 0)), Line(points = [ -32, -72; -64, -72; -64, -21; -32, -21], style(color = 0)), Polygon(points = [16, -71;29, -67;29, -74;16, -71], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [ -32, -21; -46, -17; -46, -25; -32, -21], style(color = 0, fillColor = 0, fillPattern = 1))), Documentation(info = "<html>
// <p>
// This library contains input/output blocks to build up block diagrams.
// The library is structured in the following sublibraries:
// </p>
// 
// <pre>
//   Interfaces    Connectors and partial models for block diagram components
//   Examples      Demonstration examples
//   Continuous    Basic continuous input/output blocks
//   Discrete      Discrete control blocks (not yet available)
//   Logical       Logical and relational operations on Boolean signals
//                 (not yet available)
//   Nonlinear     Discontinuous or non-differentiable algebraic
//                 control blocks
//   Math          Mathematical functions as input/output blocks
//   Sources       Sources such as signal generators
// </pre>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New subpackage Examples, additional components.
//        </li>
// <li><i>June 20, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
//        Michael Tiller:<br>
//        Introduced a replaceable signal type into
//        Blocks.Interfaces.InPort/OutPort:
// <pre>
//    replaceable type SignalType = Real
// </pre>
//        in order that the type of the signal of an input/output block
//        can be changed to a physical type, for example:
// 
// <pre>
//    Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
// </pre>
//       </li>
// 
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renamed to Blocks. New subpackages Math, Nonlinear.
//        Additional components in subpackages Interfaces, Continuous
//        and Sources. </li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// 
// </HTML>
// "));
//     package Continuous "Continuous control blocks with internal states"
//       extends Modelica.Icons.Library;
//       annotation(Window(x = 0.05, y = 0.09, width = 0.35, height = 0.74, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains basic <b>continuous</b> input/output blocks.
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.
// </li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       block Integrator "Output the integral of the input signals"
//         parameter Real k[:] = {1} "Integrator gains";
//         parameter Real y0[:] = zeros(size(k, 1)) "Start values of integrators";
//         extends Interfaces.MIMOs(final n = size(k, 1), y(start = y0));
//         annotation(Documentation(info = "<html>
// <p>
// This blocks computes output <b>y</b>=outPort.signal element-wise as
// <i>integral</i> of the input <b>u</b>=inPort.signal multiplied with
// the gain <i>k</i>:
// </p>
// 
// <pre>
//              k[i]
//      y[i] = ------ u[i]
//               s
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [0, -10;60, -70], string = "I", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0)), Line(points = [ -80, -80;80,80])), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0]), Text(extent = [ -36,60;32,2], string = "k", style(color = 0)), Text(extent = [ -32,0;36, -58], string = "s", style(color = 0)), Line(points = [ -46,0;46,0], style(color = 0))));
// 
//       equation 
//         for i in 1:size(k, 1) loop
//         der(y[i]) = k[i] * u[i];
// 
//         end for;
//       end Integrator;
//       block LimIntegrator "Integrator with limited values of the outputs"
//         parameter Real k[:] = {1} "Integrator gains";
//         parameter Real outMax[:] = {1} "Upper limits of outputs";
//         parameter Real outMin[:] =  -outMax "Lower limits of outputs";
//         parameter Real y0[:] = zeros(size(k, 1)) "Start values of integrators";
//         extends Interfaces.MIMOs(final n = max([size(k, 1);size(outMax, 1);size(outMin, 1)]), y(start = y0));
//       protected 
//         parameter Real p_k[n] = if size(k, 1) == 1 then ones(n) * k[1] else k;
//         parameter Real p_outMax[n] = if size(outMax, 1) == 1 then ones(n) * outMax[1] else outMax;
//         parameter Real p_outMin[n] = if size(outMin, 1) == 1 then ones(n) * outMin[1] else outMin;
//         annotation(Documentation(info = "<html>
// <p>
// This blocks computes <b>y</b>=outPort.signal element-wise as <i>integral</i>
// of the input <b>u</b>=inPort.signal multiplied with the gain <i>k</i>. If the
// integral reaches a given upper or lower <i>limit</i> and the
// input will drive the integral outside of this bound, the
// integration is halted and only restarted if the input drives
// the integral away from the bounds.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80;20,20;80,20]), Text(extent = [0, -10;60, -70], string = "I", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0))), Diagram(Rectangle(extent = [ -60,60;60, -60]), Text(extent = [ -54,46; -4, -48], string = "lim", style(color = 0)), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0]), Text(extent = [ -8,60;60,2], string = "k", style(color = 0)), Text(extent = [ -8, -2;60, -60], string = "s", style(color = 0)), Line(points = [4,0;46,0], style(color = 0))));
// 
//       equation 
//         for i in 1:n loop
//         der(y[i]) = if y[i] < p_outMin[i] and u[i] < 0 or y[i] > p_outMax[i] and u[i] > 0 then 0 else p_k[i] * u[i];
// 
//         end for;
//       end LimIntegrator;
//       block Derivative "Approximated derivative block"
//         parameter Real k[:] = {1} "Gains";
//         parameter SI.Time T[:](min = fill(Modelica.Constants.small, size(T, 1))) = {0.01} "Time constants (T>0 required; T=0 is ideal derivative block)";
//         extends Interfaces.MIMOs(final n = max([size(k, 1);size(T, 1)]));
//         output Real x[n] "State of block";
//       protected 
//         parameter Real p_k[n] = if size(k, 1) == 1 then ones(n) * k[1] else k;
//         parameter Real p_T[n] = if size(T, 1) == 1 then ones(n) * T[1] else T;
//         annotation(Documentation(info = "<html>
// <p>
// This blocks defines the transfer function between the
// input u=inPort.signal and the output y=outPort.signal
// element-wise as <i>approximated derivative</i>:
// </p>
// 
// <pre>
//              k[i] * s
//      y[i] = ------------ * u[i]
//             T[i] * s + 1
// </pre>
// 
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general block <b>TransferFunction</b> instead
// and model a derivative block with parameters<br>
// b = {k,0}, a = {T, 1}.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 15, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Special handling, if k is zero. Introduced, in order that
//        the D-part of the PID controllers can be set to zero without
//        introducing numerical problems.</li>
// 
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,60; -70,17.95; -60, -11.46; -50, -32.05; -40, -46.45; -30, -56.53; -20, -63.58; -10, -68.51;0, -71.96;10, -74.37;20, -76.06;30, -77.25;40, -78.07;50, -78.65;60, -79.06]), Text(extent = [0,0;60,60], string = "DT1", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0))), Diagram(Text(extent = [ -54,52;50,10], string = "k s", style(color = 0)), Text(extent = [ -54, -6;52, -52], string = "T s + 1", style(color = 0)), Line(points = [ -50,0;50,0], style(color = 0)), Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0])), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.17, y = 0.03, width = 0.5, height = 0.61));
// 
//       equation 
//         for i in 1:n loop
//         der(x[i]) = if noEvent(abs(p_k[i]) >= Modelica.Constants.eps) then (u[i] - x[i]) / p_T[i] else 0;
//         y[i] = if noEvent(abs(p_k[i]) >= Modelica.Constants.eps) then p_k[i] / p_T[i] * (u[i] - x[i]) else 0;
// 
//         end for;
//       end Derivative;
//       block FirstOrder "First order transfer function block (= 1 pole)"
//         parameter Real k[:] = {1} "Gain";
//         parameter SI.Time T[:] = {1} "Time Constant";
//         extends Interfaces.MIMOs(final n = max([size(k, 1);size(T, 1)]));
//       protected 
//         parameter Real p_k[n] = if size(k, 1) == 1 then ones(n) * k[1] else k;
//         parameter Real p_T[n] = if size(T, 1) == 1 then ones(n) * T[1] else T;
//         annotation(Documentation(info = "<html>
// <p>
// This blocks defines the transfer function between the input u=inPort.signal
// and the output y=outPort.signal element-wise as <i>first order</i> system:
// </p>
// 
// <pre>
//                k[i]
//      y[i] = ------------ * u[i]
//             T[i] * s + 1
// </pre>
// 
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general block <b>TransferFunction</b> instead
// and model a first order SISO system with parameters<br>
// b = {k}, a = {T, 1}.
// </p>
// 
// <pre>
// Example:
// 
//    parameter: k = {0.3}, T = {0.4}
// 
//    results in:
// 
//              0.3
//       y = ----------- * u
//           0.4 s + 1.0
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized.</li>
// 
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,88; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -80; -70, -45.11; -60, -19.58; -50, -0.9087; -40,12.75; -30,22.75; -20,30.06; -10,35.41;0,39.33;10,42.19;20,44.29;30,45.82;40,46.94;50,47.76;60,48.36;70,48.8;80,49.12]), Text(extent = [0,0;60, -60], string = "PT1", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "T=%T", style(color = 0))), Diagram(Text(extent = [ -48,52;50,8], string = "k", style(color = 0)), Text(extent = [ -54, -6;56, -56], string = "T s + 1", style(color = 0)), Line(points = [ -50,0;50,0], style(color = 0)), Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0])), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.15, y = 0.04, width = 0.52, height = 0.55));
// 
//       equation 
//         for i in 1:n loop
//         der(y[i]) = (p_k[i] * u[i] - y[i]) / p_T[i];
// 
//         end for;
//       end FirstOrder;
//       block SecondOrder "Second order transfer function block (= 2 poles)"
//         parameter Real k[:] = {1} "Gain";
//         parameter Real w[:] = {1} "Angular frequency";
//         parameter Real D[:] = {1} "Damping";
//         extends Interfaces.MIMOs(final n = max([size(k, 1);size(w, 1);size(D, 1)]));
//         output Real yd[n] "Derivative of y";
//       protected 
//         parameter Real p_k[n] = if size(k, 1) == 1 then ones(n) * k[1] else k;
//         parameter Real p_w[n] = if size(w, 1) == 1 then ones(n) * w[1] else w;
//         parameter Real p_D[n] = if size(D, 1) == 1 then ones(n) * D[1] else D;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.1, width = 0.54, height = 0.49), Documentation(info = "<html>
// <p>
// This blocks defines the transfer function between the input u=inPort.signal and
// the output y=outPort.signal element-wise as <i>second order</i> system:
// </p>
// 
// <pre>
//                              k[i]
//      y[i] = ---------------------------------------- * u[i]
//             ( s / w[i] )^2 + 2*D[i]*( s / w[i] ) + 1
// 
// </pre>
// 
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general model class <b>TransferFunction</b>
// instead and model a second order SISO system with parameters<br>
// b = {k}, a = {1/w^2, 2*D/w, 1}.
// </p>
// 
// <pre>
// Example:
// 
//    parameter: k =  {0.3},  w = {0.5},  D = {0.4}
// 
//    results in:
// 
//                   0.3
//       y = ------------------- * u
//           4.0 s^2 + 1.6 s + 1
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized and state space representation changed, such
//        that the output and its derivative are used as state.</li>
// 
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,88; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -80; -72, -68.53; -64, -39.5; -56, -2.522; -48,32.75; -40,58.8; -32,71.51; -24,70.49; -16,58.45; -8,40.06;0,20.55;8,4.459;16, -5.271;24, -7.629;32, -3.428;40,5.21;48,15.56;56,25.03;64,31.66;72,34.5;80,33.61]), Text(extent = [0, -10;60, -70], string = "PT2", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "w=%w", style(color = 0))), Diagram(Rectangle(extent = [ -60,60;60, -60]), Text(extent = [ -60,60;60,14], string = "k", style(color = 0)), Text(extent = [ -60,8; -32, -20], string = "s", style(color = 0)), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0]), Line(points = [ -50,14;50,14], style(color = 0)), Line(points = [ -54, -20; -38, -20], style(color = 0)), Text(extent = [ -52, -26; -36, -48], string = "w", style(color = 0)), Line(points = [ -50,2; -56, -8; -56, -28; -52, -46], style(color = 0)), Line(points = [ -40,2; -34, -10; -34, -30; -38, -46], style(color = 0)), Text(extent = [ -34,8; -22, -10], string = "2", style(color = 0)), Text(extent = [ -34, -6;6, -36], string = "+2D", style(color = 0)), Text(extent = [2,8;30, -20], string = "s", style(color = 0)), Line(points = [8, -20;24, -20], style(color = 0)), Text(extent = [10, -26;26, -48], string = "w", style(color = 0)), Line(points = [12,2;6, -8;6, -28;10, -46], style(color = 0)), Line(points = [22,2;28, -10;28, -30;24, -46], style(color = 0)), Text(extent = [30,2;58, -42], string = "+1", style(color = 0))));
// 
//       equation 
//         for i in 1:n loop
//         der(y[i]) = yd[i];
//         der(yd[i]) = p_w[i] * (p_w[i] * (p_k[i] * u[i] - y[i]) - 2 * p_D[i] * yd[i]);
// 
//         end for;
//       end SecondOrder;
//       block PI "Proportional-Integral controller"
//         parameter Real k[:] = {1} "Gain";
//         parameter SI.Time T[:] = {1} "Time Constant (T>0 required)";
//         extends Interfaces.MIMOs(final n = max([size(k, 1);size(T, 1)]));
//         output Real x[n] "State of block";
//       protected 
//         parameter Real p_k[n] = if size(k, 1) == 1 then ones(n) * k[1] else k;
//         parameter Real p_T[n] = if size(T, 1) == 1 then ones(n) * T[1] else T;
//         annotation(Documentation(info = "<html>
// <p>
// This blocks defines the transfer function between the input u=inPort.signal and
// the output y=outPort.signal element-wise as <i>PI</i> system:
// </p>
// 
// <pre>
//                         1
//    y[i] = k[i] * (1 + ------ ) * u[i]
//                       T[i]*s
// 
//                  T[i]*s + 1
//         = k[i] * ----------- * u[i]
//                     T[i]*s
// </pre>
// 
// <p>
// If you would like to be able to change easily between different
// transfer functions (FirstOrder, SecondOrder, ... ) by changing
// parameters, use the general model class <b>TransferFunction</b>
// instead and model a PI SISO system with parameters<br>
// b = {k*T, k}, a = {T, 0}.
// </p>
// 
// <pre>
// Example:
// 
//    parameter: k = {0.3},  T = {0.4}
// 
//    results in:
// 
//                0.4 s + 1
//       y = 0.3 ----------- * u
//                  0.4 s
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized.</li>
// 
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,88; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -80; -80, -20;60,80], style(thickness = 1)), Text(extent = [0,6;60, -56], string = "PI", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "T=%T", style(color = 0))), Diagram(Rectangle(extent = [ -60,60;60, -60]), Text(extent = [ -68,24; -24, -18], string = "k", style(color = 0)), Text(extent = [ -32,48;60,0], string = "T s + 1", style(color = 0)), Text(extent = [ -30, -8;52, -40], string = "T s", style(color = 0)), Line(points = [ -24,0;54,0], style(color = 0)), Line(points = [ -100,0; -60,0]), Line(points = [62,0;100,0])));
// 
//       equation 
//         for i in 1:n loop
//         der(x[i]) = u[i] / p_T[i];
//         y[i] = p_k[i] * (x[i] + u[i]);
// 
//         end for;
//       end PI;
//       block PID "PID-controller in additive description form"
//         extends Interfaces.SISO;
//         parameter Real k = 1 "Gain";
//         parameter SI.Time Ti(min = Modelica.Constants.small) = 0.5 "Time Constant of Integrator";
//         parameter SI.Time Td(min = 0) = 0.1 "Time Constant of Derivative block";
//         parameter Real Nd(min = Modelica.Constants.small) = 10 "The higher Nd, the more ideal the derivative block";
//         annotation(Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,50; -80, -20;60,80]), Text(extent = [ -20, -20;80, -60], string = "PID", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "Ti=%Ti", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This is the text-book version of a PID-controller.
// For a more practically useful PID-controller, use
// block LimPID.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Aug. 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// </HTML>
// "));
//         Math.Gain P "Proportional part of PID controller" annotation(extent = [ -60,60; -20,100]);
//         Integrator I(k = {1 / Ti}) "Integral part of PID controller" annotation(extent = [ -60, -20; -20,20]);
//         Derivative D(k = {Td}, T = {max([Td / Nd,100 * Modelica.Constants.eps])}) "Derivative part of PID controller" annotation(extent = [ -60, -100; -20, -60]);
//         Math.Gain Gain(k = {k}) "Gain of PID controller" annotation(extent = [60, -10;80,10]);
//         Math.Add3 Add annotation(extent = [20, -10;40,10]);
// 
//       equation 
//         connect(P.outPort,Add.inPort1) annotation(points = [ -20,80;0,80;0,8;20,8]);
//         connect(I.outPort,Add.inPort2) annotation(points = [ -20,0;20,0]);
//         connect(D.outPort,Add.inPort3) annotation(points = [ -20, -80;0, -80;0, -8;20, -8]);
//         connect(Add.outPort,Gain.inPort) annotation(points = [40,0;60,0]);
//         connect(outPort,Gain.outPort) annotation(points = [100,0;80,0]);
//         connect(inPort,I.inPort) annotation(points = [ -100,0; -60,0]);
//         connect(inPort,P.inPort) annotation(points = [ -100,0; -80,0; -80,80; -60,80]);
//         connect(inPort,D.inPort) annotation(points = [ -100,0; -80,0; -80, -80; -60, -80]);
//       end PID;
//       block LimPID "PID controller with limited output, anti-windup compensation and setpoint weighting"
//         extends Interfaces.SVcontrol;
//         parameter Real k(min = 0) = 1 "Gain of PID block";
//         parameter SI.Time Ti(min = Modelica.Constants.small) = 0.5 "Time constant of Integrator block";
//         parameter SI.Time Td(min = 0) = 0.1 "Time constant of Derivative block";
//         parameter Real yMax = 1 "Upper limit of output";
//         parameter Real yMin =  -yMax "Lower limit of output";
//         parameter Real wp(min = 0) = 1 "Set-point weight for Proportional block (0..1)";
//         parameter Real wd(min = 0) = 0 "Set-point weight for Derivative block (0..1)";
//         parameter Real Ni(min = 100 * Modelica.Constants.eps) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
//         parameter Real Nd(min = 100 * Modelica.Constants.eps) = 10 "The higher Nd, the more ideal the derivative block";
//         Nonlinear.Limiter limiter(uMax = {yMax}, uMin = {yMin}) annotation(extent = [70, -10;90,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.22, y = 0.02, width = 0.6, height = 0.72), Icon(Line(points = [ -80,78; -80, -90], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -80;82, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,50; -80, -20;30,60;80,60]), Text(extent = [ -20, -20;80, -60], string = "PID", style(color = 8))), Documentation(info = "<HTML>
// <p>
// This is a PID controller incorporating several practical aspects.
// It is designed according to chapter 3 of the book
// </p>
// 
// <pre>
//    K. Astroem, T. Haegglund: PID Controllers: Theory, Design, and Tuning.
//                              2nd edition, 1995.
// </pre>
// 
// <p>
// Besides the additive <b>proportional, integral</b> and <b>derivative</b>
// part of this controller, the following practical aspects are included:
// </p>
// 
// <ul>
// <li> The output of this controller is limited. If the controller is
//      in its limits, anti-windup compensation is activated to drive
//      the integrator state to zero. </li>
// 
// <li> The high-frequency gain of the derivative part is limited
//      to avoid excessive amplification of measurement noise.</li>
// 
// <li> Setpoint weighting is present, which allows to weight
//      the setpoint in the proportional and the derivative part
//      independantly from the measurement. The controller will respond
//      to load disturbances and measurement noise independantly of this setting
//      (parameters wp, wd). However, setpoint changes will depend on this
//      setting. For example, it is useful to set the setpoint weight wd
//      for the derivative part to zero, if steps may occur in the
//      setpoint signal.</li>
// </ul>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Aug. 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "));
//         Math.Add addP(k1 = wp, k2 =  -1) annotation(extent = [ -80,40; -60,60]);
//         Math.Add addD(k1 = wd, k2 =  -1) annotation(extent = [ -80, -10; -60,10]);
//         Math.Gain P annotation(extent = [ -40,40; -20,60]);
//         Integrator I(k = {1 / Ti}) annotation(extent = [ -40, -60; -20, -40]);
//         Derivative D(k = {Td}, T = {max([Td / Nd,1e-14])}) annotation(extent = [ -40, -10; -20,10]);
//         Math.Gain gainPID(k = {k}) annotation(extent = [30, -10;50,10]);
//         Math.Add3 addPID annotation(extent = [0, -10;20,10]);
//         Math.Add3 addI(k2 =  -1) annotation(extent = [ -80, -60; -60, -40]);
//         Math.Add addSat(k2 =  -1) annotation(extent = [70, -60;90, -40], rotation =  -90);
//         Math.Gain gainTrack(k = {1 / (k * Ni)}) annotation(extent = [40, -80;20, -60]);
// 
//       equation 
//         assert(yMax >= yMin, "PID: Limits must be consistent");
//         connect(inPort_s,addP.inPort1) annotation(points = [ -102,0; -96,0; -96,56; -80,56]);
//         connect(inPort_m,addP.inPort2) annotation(points = [0, -100;0, -92; -92, -92; -92,44; -80,44], style(thickness = 2));
//         connect(inPort_s,addD.inPort1) annotation(points = [ -102,0; -96,0; -96,6; -82,6]);
//         connect(inPort_m,addD.inPort2) annotation(points = [0, -100;0, -92; -92, -92; -92, -6; -82, -6; -82, -6], style(thickness = 2));
//         connect(inPort_s,addI.inPort1) annotation(points = [ -100,0; -96,0; -96, -42; -82, -42]);
//         connect(inPort_m,addI.inPort2) annotation(points = [0, -104;0, -92; -92, -92; -92, -50; -80, -50], style(thickness = 2));
//         connect(gainTrack.outPort,addI.inPort3) annotation(points = [20, -70; -88, -70; -88, -58; -80, -58]);
//         connect(addP.outPort,P.inPort) annotation(points = [ -60,50; -40,50; -40,50]);
//         connect(addD.outPort,D.inPort) annotation(points = [ -60,0; -50,0]);
//         connect(addI.outPort,I.inPort) annotation(points = [ -58, -50; -40, -50]);
//         connect(P.outPort,addPID.inPort1) annotation(points = [ -18,50; -10,50; -10,8;0,8]);
//         connect(D.outPort,addPID.inPort2) annotation(points = [ -20,0; -2,0; -2,0]);
//         connect(I.outPort,addPID.inPort3) annotation(points = [ -18, -50; -10, -50; -10, -8; -2, -8; -2, -8]);
//         connect(addPID.outPort,gainPID.inPort) annotation(points = [21,0;28,0]);
//         connect(gainPID.outPort,addSat.inPort2) annotation(points = [50,0;60,0;60, -30;74, -30;74, -40]);
//         connect(addSat.outPort,gainTrack.inPort) annotation(points = [80, -62;80, -70;42, -70]);
//         connect(gainPID.outPort,limiter.inPort) annotation(points = [50,0;70,0]);
//         connect(limiter.outPort,outPort) annotation(points = [90,0;100,0]);
//         connect(limiter.outPort,addSat.inPort1) annotation(points = [90,0;94,0;94, -20;86, -20;86, -40]);
//       end LimPID;
//       block TransferFunction "Linear transfer function"
//         extends Interfaces.SISO;
//         parameter Real b[:] = {1} "Numerator coefficients of transfer function.";
//         parameter Real a[:] = {1,1} "Denominator coefficients of transfer function.";
//         output Real x[size(a, 1) - 1] "State of transfer function from controller canonical form";
//       protected 
//         parameter Integer na = size(a, 1) "Size of Denominator of transfer function.";
//         parameter Integer nb(max = na) = size(b, 1) "Size of Numerator of transfer function.";
//         parameter Integer nx = size(a, 1) - 1;
//         Real x1dot "Derivative of first state of TransferFcn";
//         Real xn "Highest order state of TransferFcn";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.39, y = 0.09, width = 0.58, height = 0.77), Documentation(info = "<html>
// <p>
// This block defines the transfer function between the input
// u=inPort.signal[1] and the output y=outPort.signal[1]
// as (nb = dimension of b, na = dimension of a):
// </p>
// 
// <pre>
//            b[1]*s^[nb-1] + b[2]*s^[nb-2] + ... + b[nb]
//    y(s) = --------------------------------------------- * u(s)
//            a[1]*s^[na-1] + a[2]*s^[na-2] + ... + a[na]
// </pre>
// 
// <p>
// State variables <b>x</b> are defined according to <b>controller canonical</b>
// form. Initial values of the states can be set as start values of <b>x</b>.
// <p>
// 
// <p>
// Example:
// </p>
// 
// <pre>
//      TransferFunction g(b = {2,4}, a = {1,3});
// </pre>
// 
// <p>
// results in the following transfer function:
// </p>
// 
// <pre>
//         2*s + 4
//    y = --------- * u
//          s + 3
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized based on a realization of the corresponding
//        Dymola library of Hilding Elmqvist.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,0;80,0]), Text(extent = [ -90,10;90,90], string = "b(s)"), Text(extent = [ -90, -10;90, -90], string = "a(s)")), Diagram(Line(points = [40,0; -40,0], style(color = 0)), Text(extent = [ -55,55;55,5], string = "b(s)", style(color = 0)), Text(extent = [ -55, -5;55, -55], string = "a(s)", style(color = 0)), Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0])));
// 
//       equation 
//         [der(x);xn] = [x1dot;x];
//         [u] = transpose([a]) * [x1dot;x];
//         [y] = transpose([zeros(na - nb, 1);b]) * [x1dot;x];
//       end TransferFunction;
//       block StateSpace "Linear state space system"
//         parameter Real A[:,size(A, 1)] = [1,0;0,1] "Matrix A of state space model";
//         parameter Real B[size(A, 1),:] = [1;1] "Matrix B of state space model";
//         parameter Real C[:,size(A, 1)] = [1,1] "Matrix C of state space model";
//         parameter Real D[size(C, 1),size(B, 2)] = zeros(size(C, 1), size(B, 2)) "Matrix D of state space model";
//         extends Interfaces.MIMO(final nin = size(B, 2), final nout = size(C, 1));
//         output Real x[size(A, 1)] "State vector";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.2, y = 0.03, width = 0.64, height = 0.73), Documentation(info = "<html>
// <p>
// The State Space block defines the relation
// between the input u=inPort.signal and the output
// y=outPort.signal in state space form:
// </p>
// 
// <pre>
// 
//     der(x) = A * x + B * u
//         y  = C * x + D * u
// 
// </pre>
// 
// <p>
// The input is a vector of length nu, the output is a vector
// of length ny and nx is the number of states. Accordingly
// </p>
// <pre>
//         A has the dimension: A(nx,nx),
//         B has the dimension: B(nx,nu),
//         C has the dimension: C(ny,nx),
//         D has the dimension: D(ny,nu)
// </pre>
// 
// <p>
// Example:
// </p>
// <pre>
//      parameter: A = [0.12, 2;3, 1.5]
//      parameter: B = [2, 7;3, 1]
//      parameter: C = [0.1, 2]
//      parameter: D = zeros(ny,nu)
// results in the following equations:
// 
//   [der(x[1])]   [0.12  2.00] [x[1]]   [2.0  7.0] [u[1]]
//   [         ] = [          ]*[    ] + [        ]*[    ]
//   [der(x[2])]   [3.00  1.50] [x[2]]   [0.1  2.0] [u[2]]
// 
//                              [x[1]]            [u[1]]
//        y[1]   = [0.1  2.0] * [    ] + [0  0] * [    ]
//                              [x[2]]            [u[2]]
// </pre>
// </HTML>
// "), Icon(Text(extent = [ -90,10; -10,90], string = "A"), Text(extent = [10,10;90,90], string = "B"), Text(extent = [ -90, -10; -10, -90], string = "C"), Text(extent = [10, -10;90, -90], string = "D"), Line(points = [0, -90;0,90], style(color = 8)), Line(points = [ -90,0;90,0], style(color = 8))), Diagram(Rectangle(extent = [ -60,60;60, -60]), Text(extent = [ -60,40;60,0], string = "sx=Ax+Bu", style(color = 0)), Text(extent = [ -60,0;60, -40], string = " y=Cx+Du", style(color = 0)), Line(points = [ -100,0; -60,0]), Line(points = [60,0;100,0])));
// 
//       equation 
//         der(x) = A * x + B * u;
//         y = C * x + D * u;
//       end StateSpace;
//       block Der "Derivative of input (= analytic differentations)"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Text(extent = [ -80,76;80, -82], string = "der()")), Documentation(info = "<HTML>
// <p>
// Defines that the output (= outPort.signal) is the <i>derivative</i>
// of the input (=inPort.signal). Note, that Modelica.Blocks.Continuous.Derivative
// computes the derivative in an approximate sense, where this block computes
// the derivative exactly. This requires that the input signals are differentiated
// by the Modelica translator, if these derivatives are not yet present in
// the model.
// </p>
// </HTML>"));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = der(u[i]);
// 
//         end for;
//       end Der;
//     end Continuous;
//     package Examples "Demonstration examples of the components of this package"
//       extends Icons.Library;
//       encapsulated model BusUsage "Demonstration of signal bus usage"
//         import Modelica.Icons;
//         import Modelica.Blocks.Interfaces.BusAdaptors;
//         import Modelica.Blocks.Sources;
//         extends Icons.Example;
//         annotation(Documentation(info = "<HTML>
// <p><b>Signal bus concept</b></p>
// 
// <p>
// In technical systems, such as vehicles, robots or satellites, many signals
// are exchanged between components. In a simulation system, these signals 
// are  usually modelled by signal connections of input/output blocks.
// Unfortunately, the signal connection structure may become very complicated,
// especially for hierarchical models.
// </p>
// 
// <p>
// The same is also true for real technical systems. To reduce complexity
// and get higher flexibility, many technical systems use data buses to 
// exchange data between components. For the same reasons, it is often better
// to use a \"signal bus\" concept also in a Modelica model. This is demonstrated
// at hand of this model (Modelica.Blocks.Examples.BusUsage), see diagram layer:
// </p>
// 
// <ul>
// <li>The thick line in the middle called \"bus\" is just a connector instance
//     which is drawn such that it looks like a \"usual\" bus representation. </li>
// <li>A component, such as \"part\", can be directly connected to the \"bus\", 
//     provided it has also a bus connector, or the \"part\" connector is a 
//     sub-connector contained in the \"bus\". </li>
// </ul>
// 
// <p>
// Difficulties arise if the input or output connector of an 
// input/output block shall be connected directly to a variable 
// of a bus because connections can only be performed between 
// connectors but not between variables. For convenience, 
// single variable connectors for Real, Integer and Boolean 
// variables are provided as Modelica.Blocks.Interfaces.<b>RealPort</b>, 
// Modelica.Blocks.Interfaces.<b>IntegerPort</b>, 
// Modelica.Blocks.Interfaces.<b>BooleanPort</b>.
// For example, the RealPort connector is basically defined as:
// </p>
// <pre>  <b>connector</b> RealPort = Real;
// </pre>
// 
// <p>
// This allows a definition of a bus in the form:
// </p>
// 
// <pre>   <b>connector</b> Bus
//       RealPort r1;
//       RealPort r2;
//         ...
//    <b>end</b> Bus;
// </pre>
// 
// <p>
// and a connection to r1 and r2 is possible since these are connectors. 
// Unfortunately, signals defined in this way have, by default, no unit. 
// To improve this situation, a RealPort is actually defined as
// </p>
// 
// <pre>   <b>connector</b> RealPort 
//       <b>replaceable type</b> SignalType = Real;
//       <b>extends</b> SignalType;
//    <b>end</b> RealPort;
// </pre>
// 
// <p>
// This allows a redeclaration of the Real type to the desired type, such as:
// </p>
// 
// <pre>   <b>connector</b> Bus
//       <b>import</b> SI=Modelica.SIunits;
//       RealPort v(<b>redeclare</b> SignalType=SI.Velocity);
//       RealPort p(<b>redeclare</b> SignalType=SI.Pressure);
//       ...
//    <b>end</b> Bus;
// </pre>
// 
// <p>
// In order to connect from a RealPort connector to an InPort or OutPort 
// connector of a block from the Modelica.Blocks package, an adaptor block 
// is needed, since the two connectors are not compatible. Appropriate adaptors 
// are provided in Modelica.Blocks.Interfaces.<b>BusAdaptors</b>. The usage can 
// be seen in the diagram layer of the model at hand
// (Modelica.Blocks.Examples.BusUsage). 
// </p>
// 
// <p>
// If a bus connector contains many signals it is no longer so easy 
// to test just one part of a system, because all parts of 
// the bus connector must get a value. To simplify this, 
// it is practical to provide a <b>RestBus</b> component which 
// sets all parts of a bus to a default value when selected 
// via the parameter menu. This is also demonstrated in the example 
// model (see diagram layer).
// </p>
// 
// <p>Simulate the system for 1 s. The outputs of the 'receive' signal
// blocks should be the same as the inputs of the 'send' signal blocks.
// </p>
// </HTML>"));
//       protected 
//         Interfaces.Bus bus annotation(extent = [ -80, -20;80, -14]);
//       public 
//         BusAdaptors.SendReal putRealSignal1 annotation(extent = [ -60,0; -40,20], rotation =  -90);
//         BusAdaptors.SendBoolean putBooleanSignal annotation(extent = [ -20,0;0,20], rotation =  -90);
//         BusAdaptors.SendInteger putIntegerSignal annotation(extent = [20,0;40,20], rotation =  -90);
//         BusAdaptors.ReceiveReal getRealSignal1 annotation(extent = [ -40, -80; -20, -60], rotation =  -90);
//         BusAdaptors.ReceiveBoolean getBooleanSignal annotation(extent = [0, -80;20, -60], rotation =  -90);
//         BusAdaptors.ReceiveInteger getIntegerSignal annotation(extent = [40, -80;60, -60], rotation =  -90);
//         RestBus restBus(set_realSignal2 = true) annotation(extent = [60,20;80,40]);
//         Sources.IntegerStep generateIntegerSignal(height = {1}, offset = {2}, startTime = {0.5}) annotation(extent = [20,60;40,80], rotation = 270);
//         Sources.BooleanStep generateBooleanSignal(startTime = {0.5}) annotation(extent = [ -20,60;0,80], rotation = 270);
//         Sources.Sine generateRealSignal1 annotation(extent = [ -60,60; -40,80], rotation = 270);
//         encapsulated package Interfaces "Interfaces specialised for this example"
//           connector MultiPort "Combined port of real and boolean signal"
//             Real myRealSignal;
//             Boolean myBooleanSignal;
//             annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(fillColor = 76, fillPattern = 1))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(fillColor = 76, fillPattern = 1))));
//           end MultiPort;
//           connector Bus "Signal bus"
//             import SI = Modelica.SIunits;
//             import Modelica.Blocks.Interfaces.*;
//             RealPort realSignal1(redeclare type SignalType = SI.AngularVelocity) "First Real signal (angular velocity)";
//             RealPort realSignal2 "Second Real signal";
//             IntegerPort integerSignal "Integer signal";
//             BooleanPort booleanSignal "Boolean signal";
//             MultiPort multiSignal "Combined signal";
//             annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -134,168;134,108], string = "%name", style(color = 77))), Diagram(Text(extent = [ -134,168;134,108], string = "%name", style(color = 77)), Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1))), Documentation(info = "<HTML>
// <p>Defines connector for signalbus.</p>
// </HTML>
// "));
//           end Bus;
//         end Interfaces;
//         encapsulated model Part "Component with MultiPort connector"
//           import Modelica.Blocks.Examples;
//           Examples.BusUsage.Interfaces.MultiPort multiSignal annotation(extent = [100, -10;120,10]);
//           annotation(Icon(Rectangle(extent = [ -100,60;100, -60], style(fillColor = 76, fillPattern = 1)), Text(extent = [ -106,124;114,68], style(fillColor = 76, fillPattern = 1), string = "%name")));
// 
//         equation 
//           multiSignal.myRealSignal = time;
//           multiSignal.myBooleanSignal = time > 0.5;
//         end Part;
//         encapsulated model RestBus "Set default values for bus variables that are not defined elsewhere"
//           import Modelica.Blocks.Examples;
//           parameter Boolean set_realSignal1 = false "Set dummy value for desiredThrottle";
//           parameter Boolean set_realSignal2 = false "Set dummy value for brake";
//           parameter Boolean set_integerSignal = false "Set dummy value for controlLeverPosition";
//           parameter Boolean set_booleanSignal = false "Set dummy value for desiredGear";
//           parameter Boolean set_multiSignal = false "Set dummy value for ignition";
//           annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(fillColor = 7, fillPattern = 1)), Text(extent = [ -100,156;100,96], string = "%name", style(pattern = 0)), style(color = 77), Text(extent = [46, -10;88, -40], style(color = 0), string = "0"), Text(extent = [ -82,62;38,34], style(color = 0), string = "false"), Line(points = [ -28,24; -28, -66;0, -66;0, -104;0, -102], style(color = 77, fillColor = 7, fillPattern = 1)), Line(points = [68, -46;68, -66;0, -66;0, -108], style(color = 77, fillColor = 7, fillPattern = 1)), Rectangle(extent = [ -90,78;46,24], style(color = 0)), Rectangle(extent = [40, -4;92, -46], style(color = 0))));
//           Examples.BusUsage.Interfaces.Bus bus annotation(extent = [ -10, -120;10, -100], rotation = 90);
// 
//         equation 
// if set_realSignal1 then
//                       bus.realSignal1 = 0;
//           end if;
// if set_realSignal2 then
//                       bus.realSignal2 = 0;
//           end if;
// if set_integerSignal then
//                       bus.integerSignal = 0;
//           end if;
// if set_booleanSignal then
//                       bus.booleanSignal = false;
//           end if;
// if set_multiSignal then
//                       bus.multiSignal.myRealSignal = 0;
//             bus.multiSignal.myBooleanSignal = false;
//           end if;
//         end RestBus;
//         Part part annotation(extent = [ -100, -60; -80, -40]);
// 
//       equation 
//         connect(putRealSignal1.toBus,bus.realSignal1) annotation(points = [ -50, -2; -50, -16], style(color = 77));
//         connect(putIntegerSignal.toBus,bus.integerSignal) annotation(points = [30, -2;30, -16], style(color = 77));
//         connect(generateRealSignal1.outPort,putRealSignal1.inPort) annotation(points = [ -50,58; -50,24], style(color = 3));
//         connect(generateBooleanSignal.outPort,putBooleanSignal.inPort) annotation(points = [ -10,58; -10,24], style(color = 5));
//         connect(generateIntegerSignal.outPort,putIntegerSignal.inPort) annotation(points = [30,58;30,24], style(color = 45));
//         connect(getRealSignal1.fromBus,bus.realSignal1) annotation(points = [ -30, -58; -30, -18], style(color = 77));
//         connect(getIntegerSignal.fromBus,bus.integerSignal) annotation(points = [50, -60;50, -18], style(color = 77));
//         connect(restBus.bus,bus) annotation(points = [70,20;70, -18], style(color = 77));
//         connect(putBooleanSignal.toBus,bus.booleanSignal) annotation(points = [ -10, -2; -10, -16], style(color = 77));
//         connect(getBooleanSignal.fromBus,bus.booleanSignal) annotation(points = [10, -60;10, -18], style(color = 77));
//         connect(part.multiSignal,bus.multiSignal) annotation(points = [ -78, -50; -70, -50; -70, -18]);
//       end BusUsage;
//       annotation(Documentation(info = "<html>
// <p>
// This package contains currently one example model to demonstrate the usage of the
// signal bus concept provided by the Modelica.Blocks package.
// </p>
// 
// <p><b>Copyright &copy; 2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//     end Examples;
//     package Interfaces "Connectors and partial models for input/output blocks"
//       extends Modelica.Icons.Library;
//       annotation(Window(x = 0.05, y = 0.09, width = 0.72, height = 0.71, library = 1, autolayout = 1), Documentation(info = "<HTML>
// <p>
// This package contains interface definitions for
// <b>continuous</b> input/output blocks. In particular it
// contains the following <b>connector</b> classes:
// </p>
// 
// <pre>
//   <b>InPort</b>           Connector with input        signals of type Real.
//   <b>OutPort</b>          Connector with output       signals of type Real.
//   <b>BooleanInPort</b>    Connector with input        signals of type Boolean.
//   <b>BooleanOutPort</b>   Connector with output       signals of type Boolean.
//   <b>IntegerInPort</b>    Connector with input        signals of type Integer.
//   <b>IntegerOutPort</b>   Connector with output       signals of type Integer.
// 
//   <b>RealPort</b>         Connector with input/output signals of type Real.
//   <b>BooleanPort</b>      Connector with input/output signals of type Real.
//   <b>IntegerPort</b>      Connector with input/output signals of type Real.
// </pre>
// 
// <p>The following <b>partial</b> block classes are provided
// to model <b>continuous</b> control blocks:</p>
// 
// <pre>
//   <b>BlockIcon</b>     Basic graphical layout of continuous block
//   <b>SO</b>            Single Output continuous control block
//   <b>MO</b>            Multiple Output continuous control block
//   <b>SISO</b>          Single Input Single Output continuous control block
//   <b>SI2SO</b>         2 Single Input / 1 Single Output continuous control block
//   <b>SIMO</b>          Single Input Multiple Output continuous control block
//   <b>MISO</b>          Multiple Input Single Output continuous control block
//   <b>MIMO</b>          Multiple Input Multiple Output continuous control block
//   <b>MIMOs</b>         Multiple Input Multiple Output continuous control block
//                 with same number of inputs and outputs
//   <b>MI2MO</b>         2 Multiple Input / Multiple Output continuous
//                 control block
//   <b>SignalSource</b>  Base class for continuous signal sources
//   <b>SVcontrol</b>     Single-Variable continuous controller
//   <b>MVcontrol</b>     Multi-Variable continuous controller
// </pre>
// 
// <p>
// The following <b>partial</b> block classes are provided
// to model <b>Boolean</b> control blocks:
// </p>
// 
// <pre>
//   <b>BooleanBlockIcon</b>     Basic graphical layout of Boolean block
//   <b>BooleanSISO</b>          Single Input Single Output control block
//                        with signals of type Boolean
//   <b>BooleanMIMOs</b>         Multiple Input Multiple Output control block
//                        with same number of inputs and outputs
//   <b>MI2BooleanMOs</b>        2 Multiple Input / Boolean Multiple Output
//                        block with same signal lengths
//   <b>BooleanSignalSource</b>  Base class for Boolean signal sources
//   <b>IntegerMIBooleanMOs</b>  Multiple Integer Input Multiple Boolean Output control block
//                        with same number of inputs and outputs
// </pre>
// 
// <p>
// The following <b>partial</b> block classes are provided
// to model <b>Integer</b> control blocks:
// </p>
// 
// <pre>
//   <b>IntegerBlockIcon</b>     Basic graphical layout of Integer block
//   <b>IntegerMO</b>            Multiple Output control block
//   <b>IntegerSignalSource</b>  Base class for Integer signal sources
// </pre>
// 
// <p>In addition, a subpackage <b>BusAdaptors</b> is temporarily provided
// in order to make a signal bus concept available. It will be removed,
// when the package Block is revised exploiting new Modelica features.</p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added several new interfaces. <a href=\"../Documentation/ChangeNotes1.5.html\">Detailed description</a> available.
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        RealInputSignal renamed to InPort. RealOutputSignal renamed to
//        OutPort. GraphBlock renamed to BlockIcon. SISOreal renamed to
//        SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
//        SignalGenerator renamed to SignalSource. Introduced the following
//        new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
//        DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
//        BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       connector InPort "Connector with input signals of type Real"
//         parameter Integer n = 1 "Dimension of signal vector";
//         replaceable type SignalType = Real "type of signal";
//         input SignalType signal[n] "Real input signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100]), Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 3))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 3)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 3))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 3))));
//       end InPort;
//       connector OutPort "Connector with output signals of type Real"
//         parameter Integer n = 1 "Dimension of signal vector";
//         replaceable type SignalType = Real "type of signal";
//         output SignalType signal[n] "Real output signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100]), Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 7))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 7)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 3))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 3, fillColor = 7))));
//       end OutPort;
//       connector BooleanInPort "Connector with input signals of type Boolean"
//         parameter Integer n = 1 "Dimension of signal vector";
//         input Boolean signal[n] "Boolean input signals";
//         annotation(Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 5))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 5)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 5))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 5))));
//       end BooleanInPort;
//       connector BooleanOutPort "Connector with output signals of type Boolean"
//         parameter Integer n = 1 "Dimension of signal vector";
//         output Boolean signal[n] "Boolean output signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100]), Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 7))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 7)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 5))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 7))));
//       end BooleanOutPort;
//       connector IntegerInPort "Connector with input signals of type Integer"
//         parameter Integer n = 1 "Dimension of signal vector";
//         input Integer signal[n] "Integer input signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 45, fillColor = 45))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 45, fillColor = 45)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 45))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 5))), Window(x = 0.4, y = 0.4, width = 0.6, height = 0.6));
//       end IntegerInPort;
//       connector IntegerOutPort "Connector with output signals of type Integer"
//         parameter Integer n = 1 "Dimension of signal vector";
//         output Integer signal[n] "Integer output signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 45, fillColor = 7))), Diagram(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 45, fillColor = 7)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 45))), Terminal(Polygon(points = [ -100,100;100,0; -100, -100; -100,100], style(color = 5, fillColor = 7))), Window(x = 0.4, y = 0.4, width = 0.6, height = 0.6));
//       end IntegerOutPort;
//       partial block BlockIcon "Basic graphical layout of continuous block"
//         annotation(Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Text(extent = [ -150,150;150,110], string = "%name")));
//       end BlockIcon;
//       partial block SO "Single Output continuous control block"
//         extends BlockIcon;
//         OutPort outPort(final n = 1) "Connector of Real output signal" annotation(extent = [100, -10;120,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.25, y = 0.02, width = 0.6, height = 0.6), Diagram);
//         output Real y;
// 
//       equation 
//         y = outPort.signal[1];
//       end SO;
//       partial block MO "Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nout(min = 1) = 1 "Number of outputs";
//         OutPort outPort(final n = nout) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.13, y = 0.03, width = 0.6, height = 0.6), Documentation(info = "
// "));
//         output Real y[nout];
// 
//       equation 
//         y = outPort.signal;
//       end MO;
//       partial block SISO "Single Input Single Output continuous control block"
//         extends BlockIcon;
//         InPort inPort(final n = 1) "Connector of Real input signal" annotation(extent = [ -140, -20; -100,20]);
//         OutPort outPort(final n = 1) "Connector of Real output signal" annotation(extent = [100, -10;120,10]);
//         output Real y;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.32, y = 0.07, width = 0.6, height = 0.6));
//       protected 
//         Real u = inPort.signal[1];
// 
//       equation 
//         y = outPort.signal[1];
//       end SISO;
//       partial block SI2SO "2 Single Input / 1 Single Output continuous control block"
//         extends BlockIcon;
//         InPort inPort1(final n = 1) "Connector of Real input signal 1" annotation(extent = [ -140,40; -100,80]);
//         InPort inPort2(final n = 1) "Connector of Real input signal 2" annotation(extent = [ -140, -80; -100, -40]);
//         OutPort outPort(final n = 1) "Connector of Real output signal" annotation(extent = [100, -10;120,10]);
//         output Real y "Output signal";
//         annotation(Documentation(info = "<html><p>
// Block has two Input vectors inPort1.signal and inPort2.signal and one
// output vector outPort.signal. All vectors have one element.</p></html>
// "));
//       protected 
//         Real u1 = inPort1.signal[1] "Input signal 1";
//         Real u2 = inPort2.signal[1] "Input signal 2";
// 
//       equation 
//         y = outPort.signal[1];
//       end SI2SO;
//       partial block SIMO "Single Input Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nout = 1 "Number of outputs";
//         InPort inPort(final n = 1) "Connector of Real input signal" annotation(extent = [ -140, -20; -100,20]);
//         OutPort outPort(final n = nout) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         output Real y[nout] "Output signals";
//         annotation(Documentation(info = "<HTML>
// <p>Block has one continuous input signal and a vector of continuous output
// signals.</p>
// </HTML>
// "));
//       protected 
//         Real u = inPort.signal[1] "Input signal";
// 
//       equation 
//         y = outPort.signal;
//       end SIMO;
//       partial block MISO "Multiple Input Single Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nin = 1 "Number of inputs";
//         InPort inPort(final n = nin) "Connector of Real input signals" annotation(extent = [ -140, -20; -100,20]);
//         OutPort outPort(final n = 1) "Connector of Real output signal" annotation(extent = [100, -10;120,10]);
//         output Real y "Output signal";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a vector of continuous input signals and
// one continuous output signal.
// </p>
// </HTML>
// "));
//       protected 
//         Real u[:] = inPort.signal "Input signals";
// 
//       equation 
//         y = outPort.signal[1];
//       end MISO;
//       partial block MIMO "Multiple Input Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer nin = 1 "Number of inputs";
//         parameter Integer nout = 1 "Number of outputs";
//         InPort inPort(final n = nin) "Connector of Real input signals" annotation(extent = [ -140, -20; -100,20]);
//         OutPort outPort(final n = nout) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         output Real y[nout] "Output signals";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous input and a continuous output signal vector.
// The signal sizes of the input and output vector may be different.
// </p>
// </HTML>
// "));
//       protected 
//         Real u[:] = inPort.signal "Input signals";
// 
//       equation 
//         y = outPort.signal;
//       end MIMO;
//       partial block MIMOs "Multiple Input Multiple Output continuous control block with same number of inputs and outputs"
//         extends BlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         InPort inPort(final n = n) "Connector of Real input signals" annotation(extent = [ -140, -20; -100,20]);
//         OutPort outPort(final n = n) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         output Real y[n] "Output signals";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous input and a continuous output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.28, y = 0.16, width = 0.6, height = 0.6));
//       protected 
//         Real u[:] = inPort.signal "Input signals";
// 
//       equation 
//         y = outPort.signal;
//       end MIMOs;
//       partial block MI2MO "2 Multiple Input / Multiple Output continuous control block"
//         extends BlockIcon;
//         parameter Integer n = 1 "Dimension of input and output vectors.";
//         InPort inPort1(final n = n) "Connector 1 of Real input signals" annotation(extent = [ -140,40; -100,80]);
//         InPort inPort2(final n = n) "Connector 2 of Real input signals" annotation(extent = [ -140, -80; -100, -40]);
//         OutPort outPort(final n = n) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         output Real y[n] "Output signals";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.31, y = 0.07, width = 0.6, height = 0.6), Documentation(info = "
// Block has two Input vectors inPort1.signal and inPort2.signal and one
// output vector outPort.signal. All vectors have the same number of elements.
// "));
//       protected 
//         Real u1[:] = inPort1.signal "Input signals 1";
//         Real u2[:] = inPort2.signal "Input signals 2";
// 
//       equation 
//         y = outPort.signal;
//       end MI2MO;
//       partial block SignalSource "Base class for continuous signal source"
//         extends MO;
//         parameter Real offset[:] = {0} "offset of output signal";
//         parameter SI.Time startTime[:] = {0} "output = offset for time < startTime";
//       end SignalSource;
//       partial block SVcontrol "Single-Variable continuous controller"
//         extends BlockIcon;
//       protected 
//         Real u_s "Scalar setpoint input signal";
//         Real u_m "Scalar measurement input signal";
//       public 
//         InPort inPort_s(final n = 1) "Connector of setpoint input signal" annotation(extent = [ -140, -20; -100,20]);
//         InPort inPort_m(final n = 1) "Connector of measurement input signal" annotation(extent = [20, -100; -20, -140], rotation =  -90);
//         OutPort outPort(final n = 1) "Connector of actuator output signal" annotation(extent = [100, -10;120,10]);
//         output Real y "Scalar actuator output signal";
//         annotation(Diagram(Text(extent = [ -102,34; -142,24], string = "(setpoint)"), Text(extent = [100,24;140,14], string = "(actuator)"), Text(extent = [ -83, -112; -33, -102], string = " (measurement)")), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.19, y = 0.21, width = 0.6, height = 0.46));
// 
//       equation 
//         u_s = inPort_s.signal[1];
//         u_m = inPort_m.signal[1];
//         y = outPort.signal[1];
//       end SVcontrol;
//       partial block MVcontrol "Multi-Variable continuous controller"
//         extends BlockIcon;
//         parameter Integer nu_s = 1 "Number of setpoint inputs";
//         parameter Integer nu_m = 1 "Number of measurement inputs";
//         parameter Integer ny = 1 "Number of actuator outputs";
//         InPort inPort_s(final n = nu_s) "Connector of setpoint input signals" annotation(extent = [ -140, -20; -100,20]);
//         InPort inPort_m(final n = nu_m) "Connector of measurement input signals" annotation(extent = [20, -100; -20, -140], rotation =  -90);
//         OutPort outPort(final n = ny) "Connector of actuator output signals" annotation(extent = [100, -10;120,10]);
//         annotation(Diagram(Text(extent = [ -100,36; -140,26], string = "(setpoint)"), Text(extent = [102,24;142,14], string = "(actuator)"), Text(extent = [ -75, -108; -25, -98], string = " (measurement)")));
//       end MVcontrol;
//       partial block BooleanBlockIcon "Basic graphical layout of Boolean block"
//         annotation(Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 5, fillColor = 7)), Text(extent = [ -150,150;150,110], string = "%name")));
//       end BooleanBlockIcon;
//       partial block BooleanSISO "Single Input Single Output control block with signals of type Boolean"
//         extends BooleanBlockIcon;
//       public 
//         BooleanInPort inPort(final n = 1) "Connector of Boolean input signal" annotation(extent = [ -140, -20; -100,20]);
//         BooleanOutPort outPort(final n = 1) "Connector of Boolean output signal" annotation(extent = [100, -10;120,10]);
//         output Boolean y;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.37, y = 0.14, width = 0.6, height = 0.6));
//       protected 
//         Boolean u = inPort.signal[1];
// 
//       equation 
//         y = outPort.signal[1];
//       end BooleanSISO;
//       partial block BooleanMIMOs "Multiple Input Multiple Output continuous control block with same number of inputs and outputs of boolean type"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         BooleanInPort inPort(final n = n) "Connector of Boolean input signals" annotation(extent = [ -140, -20; -100,20]);
//         BooleanOutPort outPort(final n = n) "Connector of Boolean output signals" annotation(extent = [100, -10;120,10]);
//         output Boolean y[n] "Output signals";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous input and a continuous output signal vector
// where the signal sizes of the input and output vector are identical
// and of type boolean.
// </p>
// </HTML>
// "));
//       protected 
//         Boolean u[:] = inPort.signal "Input signals";
// 
//       equation 
//         y = outPort.signal;
//       end BooleanMIMOs;
//       partial block MI2BooleanMOs "2 Multiple Input / Boolean Multiple Output block with same signal lengths"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Dimension of input and output vectors.";
//         InPort inPort1(final n = n) "Connector 1 of Boolean input signals" annotation(extent = [ -140,40; -100,80]);
//         InPort inPort2(final n = n) "Connector 2 of Boolean input signals" annotation(extent = [ -140, -80; -100, -40]);
//         BooleanOutPort outPort(final n = n) "Connector of Boolean output signals" annotation(extent = [100, -10;120,10]);
//         annotation(Documentation(info = "<html>
// <p>Block has two Boolean input vectors u1 and u2 and one Boolean output
// vector y. All vectors have the same number of elements.</p>
// </html>
// "));
//       end MI2BooleanMOs;
//       partial block BooleanSignalSource "Base class for Boolean signal sources"
//         extends BooleanBlockIcon;
//         parameter Integer nout(min = 1) = 1 "Number of Boolean outputs";
//         BooleanOutPort outPort(final n = nout) "Connector of Boolean output signal" annotation(extent = [100, -10;120,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.13, y = 0.03, width = 0.6, height = 0.6), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;68, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8))));
//       end BooleanSignalSource;
//       partial block IntegerBlockIcon "Basic graphical layout of Integer block"
//         annotation(Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 45, fillColor = 7)), Text(extent = [ -150,150;150,110], string = "%name")));
//       end IntegerBlockIcon;
//       partial block IntegerMO "Multiple Integer Output continuous control block"
//         extends IntegerBlockIcon;
//         parameter Integer nout(min = 1) = 1 "Number of outputs";
//         IntegerOutPort outPort(final n = nout) "Connector of Integer output signals" annotation(extent = [100, -10;120,10]);
//         output Integer y[nout];
// 
//       equation 
//         y = outPort.signal;
//       end IntegerMO;
//       partial block IntegerSignalSource "Base class for continuous Integer signal source"
//         extends IntegerMO;
//         parameter Integer offset[:] = {0} "offset of output signal";
//         parameter SI.Time startTime[:] = {0} "output = offset for time < startTime";
//       end IntegerSignalSource;
//       partial block IntegerMIBooleanMOs "Multiple Integer Input Multiple Boolean Output continuous control block with same number of inputs and outputs"
//         extends BooleanBlockIcon;
//         parameter Integer n = 1 "Number of inputs (= number of outputs)";
//         IntegerInPort inPort(final n = n) "Connector of Integer input signals" annotation(extent = [ -140, -20; -100,20]);
//         BooleanOutPort outPort(final n = n) "Connector of Boolean output signals" annotation(extent = [100, -10;120,10]);
//         output Boolean y[n] "Boolean output signals";
//         annotation(Documentation(info = "<HTML>
// <p>
// Block has a continuous integer input and a continuous boolean output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// "));
//       protected 
//         Integer u[n] = inPort.signal "Input signals";
// 
//       equation 
//         y = outPort.signal;
//       end IntegerMIBooleanMOs;
//       connector RealPort "Real port (both input/output possible)"
//         replaceable type SignalType = Real;
//         extends SignalType;
//       end RealPort;
//       connector BooleanPort = Boolean "Boolean port (both input/output possible)";
//       connector IntegerPort = Integer "Integer port (both input/output possible)";
//       package BusAdaptors "Components to send signals to the bus or receive signals from the bus"
//         extends Modelica.Icons.Library;
//         block SendReal "Send Real signal to bus"
//           Internal.OutputReal toBus annotation(extent = [100, -10;120,10]);
//           InPort inPort(final n = 1) annotation(extent = [ -140, -20; -100,20]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 73, fillColor = 7)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0)), Text(extent = [ -100,30;100, -30], string = "send", style(color = 73, fillColor = 42))), Documentation(info = "<HTML>
// <p>
// Converts an InPort connector to a signal which can be connected to the
// signal bus. Connect connector 'toBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the InPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           toBus = inPort.signal[1];
//         end SendReal;
//         block SendBoolean "Send Boolean signal to bus"
//           Internal.OutputBoolean toBus annotation(extent = [100, -10;120,10]);
//           BooleanInPort inPort(final n = 1) annotation(extent = [ -140, -20; -100,20]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 81, fillColor = 7)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0)), Text(extent = [ -100,30;100, -30], string = "send", style(color = 81, fillColor = 42))), Documentation(info = "<HTML>
// <p>
// Converts a BooleanInPort connector to a signal which can be connected to the
// signal bus. Connect connector 'toBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the BooleanInPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           toBus = inPort.signal[1];
//         end SendBoolean;
//         block SendInteger "Send Integer signal to bus"
//           Internal.OutputInteger toBus annotation(extent = [100, -10;120,10]);
//           IntegerInPort inPort(final n = 1) annotation(extent = [ -140, -20; -100,20]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 45, fillColor = 7)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0)), Text(extent = [ -100,30;100, -30], string = "send", style(color = 45, fillColor = 42))), Documentation(info = "<HTML>
// <p>
// Converts an IntegerInPort connector to a signal which can be connected to the
// signal bus. Connect connector 'toBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the IntegerInPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           toBus = inPort.signal[1];
//         end SendInteger;
//         block ReceiveReal "Receive Real signal from bus"
//           Internal.InputReal fromBus annotation(extent = [ -120, -10; -100,10]);
//           OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 73, fillColor = 7)), Text(extent = [ -100,30;100, -30], string = "receive", style(color = 73, fillColor = 42)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0))), Documentation(info = "<HTML>
// <p>
// Converts a signal from the signal bus to an OutPort connector. Use this
// element by connecting connector 'fromBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the OutPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           fromBus = outPort.signal[1];
//         end ReceiveReal;
//         block ReceiveBoolean "Receive Boolean signal from bus"
//           Internal.InputBoolean fromBus annotation(extent = [ -120, -10; -100,10]);
//           BooleanOutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 81, fillColor = 7)), Text(extent = [ -100,30;100, -30], string = "receive", style(color = 81, fillColor = 42)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0))), Documentation(info = "<HTML>
// <p>
// Converts a signal from the signal bus to a BooleanOutPort connector. Use this
// element by connecting connector 'fromBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the BooleanOutPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           fromBus = outPort.signal[1];
//         end ReceiveBoolean;
//         block ReceiveInteger "Receive Integer signal from bus"
//           Internal.InputInteger fromBus annotation(extent = [ -120, -10; -100,10]);
//           IntegerOutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Icon(Rectangle(extent = [ -100,40;100, -40], style(color = 45, fillColor = 7)), Text(extent = [ -100,30;100, -30], string = "receive", style(color = 45, fillColor = 42)), Text(extent = [ -144,96;144,46], string = "%name", style(color = 0))), Documentation(info = "<HTML>
// <p>
// Converts a signal from the signal bus to an IntegerOutPort connector. Use this
// element by connecting connector 'fromBus' with the signal bus. A pop-up
// dialog appears which allows to specify the signal from the bus
// which is set equal to the signal of the IntegerOutPort connector.
// </p>
// 
// </HTML>
// "));
// 
//         equation 
//           fromBus = outPort.signal[1];
//         end ReceiveInteger;
//         package Internal "Internal connector definitions only to be used from models of package BusAdaptors"
//           extends Modelica.Icons.Library;
//           connector InputReal = input Real "'input Real' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//           connector InputBoolean = input Boolean "'input Boolean' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//           connector InputInteger = input Integer "'input Integer' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//           connector OutputReal = output Real "'output Real' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//           connector OutputBoolean = output Boolean "'output Boolean' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//           connector OutputInteger = output Integer "'output Integer' variable as connector" annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 77, fillColor = 77, fillPattern = 1)), Text(extent = [ -132, -100;132, -198], string = "%name", style(color = 77))));
//         end Internal;
//       end BusAdaptors;
//     end Interfaces;
//     package Math "Mathematical functions as input/output blocks"
//       extends Modelica.Icons.Library;
//       annotation(Window(x = 0.05, y = 0.09, width = 0.44, height = 0.71, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains basic <b>mathematical operations</b>,
// such as summation and multiplication, and basic <b>mathematical
// functions</b>, such as <b>sqrt</b> and <b>sin</b>, as
// input/output blocks. All blocks of this library can be either
// connected with continuous blocks or with sampled-data blocks.
// In particular the following operations and functions are
// provided:
// </p>
// 
// <pre>   <b>TwoInputs</b>     Change causality of input signals.
//    <b>TwoOutputs</b>    Change causality of output signals.
//    <b>Gain</b>          Output the input multiplied by a scalar gain
//    <b>MatrixGain</b>    Output the product of a gain matrix with the input
//    <b>Sum</b>           Output the sum of the elements of the input vector
//    <b>Feedback</b>      Output difference between commanded and feedback input
//    <b>Add</b>           Output the sum of the two inputs
//    <b>Add3</b>          Output the sum of the three inputs
//    <b>Product</b>       Output product of the two inputs
//    <b>Division</b>      Output first input divided by second input
//    <b>Abs</b>           Output the absolute value of the input
//    <b>Sign</b>          Output the sign of the input
//    <b>Sqrt</b>          Output the square root of the input
//    <b>Sin</b>           Output the sine of the input
//    <b>Cos</b>           Output the cosine of the input
//    <b>Tan</b>           Output the tangent of the input
//    <b>Asin</b>          Output the arc sine of the input
//    <b>Acos</b>          Output the arc cosine of the input
//    <b>Atan</b>          Output the arc tangent of the input
//    <b>Atan2</b>         Output atan(u1/u2) of the inputs u1 and u2
//    <b>Sinh</b>          Output the hyperbolic sine of the input
//    <b>Cosh</b>          Output the hyperbolic cosine of the input
//    <b>Tanh</b>          Output the hyperbolic tangent of the input
//    <b>Exp</b>           Output the exponential (base e) of the input
//    <b>Log</b>           Output the natural (base e) logarithm of the input
//    <b>Log10</b>         Output the base 10 logarithm of the input
//    <b>RealToInteger</b> Output the nearest Integer value to the input
//    <b>IntegerToReal</b> Output the input as Real value
//    <b>Max</b>           Output the maximum of the two inputs
//    <b>Min</b>           Output the minimum of the two inputs
//    <b>Edge</b>          Set output to true at rising edge of the input
//    <b>BooleanChange</b> Set output to true when Boolean input changes
//    <b>IntegerChange</b> Set output to true when Integer input changes
// </pre>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized (partly based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist).
// </li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       block TwoInputs "Change causality of input signals (e.g. for inverse models)"
//         extends Interfaces.BlockIcon;
//         parameter Integer n = 1 "number of input signals";
//         annotation(Documentation(info = "<html>
// <p>This block is used to enable assignment of values to
// variables preliminary defined as outputs (e.g. useful for
// inverse model generation).</p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 28, 2001</i>
//        by Michael Th&uuml;mmel:<br>
//        Realized.</li>
// </ul>
// </HTML>"));
//         Interfaces.InPort inPort1(n = n) annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.InPort inPort2(n = n) annotation(extent = [100, -20;140,20], rotation = 180);
// 
//       equation 
//         inPort1.signal = inPort2.signal;
//       end TwoInputs;
//       block TwoOutputs "Change causality of output signals (e.g. for inverse models)"
//         extends Interfaces.BlockIcon;
//         parameter Integer n = 1 "number of input signals";
//         annotation(Documentation(info = "<html>
// <p>This block is used to enable assignment of values to
// variables preliminary defined as inputs (e.g. useful for
// inverse model generation).</p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 28, 2001</i>
//        by Michael Th&uuml;mmel:<br>
//        Realized.</li>
// </ul>
// </HTML>"));
//         Interfaces.OutPort OutPort1(n = n) annotation(extent = [100, -10;120,10]);
//         Interfaces.OutPort OutPort2(n = n) annotation(extent = [ -120, -10; -100,10], rotation = 180);
// 
//       equation 
//         OutPort1.signal = OutPort2.signal;
//       end TwoOutputs;
//       block Gain "Output the element-wise product of a gain vector with the input signal vector"
//         parameter Real k[:] = {1} "Gain vector multiplied element-wise with input vector";
//       protected 
//         Real u[size(k, 1)] "Input signals";
//         Real y[size(k, 1)] "Output signals";
//       public 
//         Interfaces.InPort inPort(final n = size(k, 1)) "Input signal connector" annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.OutPort outPort(final n = size(k, 1)) "Output signal connector" annotation(extent = [100, -10;120,10]);
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal as
// <i>element-wise product</i> of gain <i>k</i> with the
// input <b>u</b> = inPort.signal:
// </p>
// 
// <pre>    y[i] = k[i] * u[i];
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Polygon(points = [ -100, -100; -100,100;100,0; -100, -100], style(color = 3, fillColor = 7)), Text(extent = [ -150, -140;150, -100], string = "k=%k", style(color = 0)), Text(extent = [ -150,140;150,100], string = "%name")), Diagram(Polygon(points = [ -100, -100; -100,100;100,0; -100, -100], style(color = 3, fillColor = 7)), Text(extent = [ -76,38;0, -34], string = "k")));
// 
//       equation 
//         u = inPort.signal;
//         y = outPort.signal;
//         for i in 1:size(k, 1) loop
//         y[i] = k[i] * u[i];
// 
//         end for;
//       end Gain;
//       block MatrixGain "Output the product of a gain matrix with the input signal vector"
//         parameter Real K[:,:] = [1,0;0,1] "Gain matrix which is multiplied with the input";
//         extends Interfaces.MIMO(final nin = size(K, 2), final nout = size(K, 1));
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal as <i>product</i> of the
// gain matrix <b>K</b> with the input signal vector <b>u</b> = inPort.signal:
// </p>
// 
// <pre>    <b>y</b> = <b>K</b> * <b>u</b>;
// </pre>
// 
// <p>
// Example:
// </p>
// 
// <pre>   parameter: <b>K</b> = [0.12 2; 3 1.5]
// 
//    results in the following equations:
// 
//      | y[1] |     | 0.12  2.00 |   | u[1] |
//      |      |  =  |            | * |      |
//      | y[2] |     | 3.00  1.50 |   | u[2] |
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [ -90, -60;90,60], string = "*K", style(color = 9)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Text(extent = [ -90, -60;90,60], string = "*K", style(color = 9))));
// 
//       equation 
//         y = K * u;
//       end MatrixGain;
//       block Sum "Output the sum of the elements of the input vector"
//         extends Interfaces.MISO;
//         parameter Real k[nin] = ones(nin) "Optional: sum coefficients";
//         annotation(Documentation(info = "<html>
// <p>This block computes the output y=outPort.signal[1] as
// <i>sum</i> of the elements of the input signal vector
// <b>u</b>=inPort.signal:</p>
// 
// <pre>    y = u[1] + u[2] + ... + u[nin];
// </pre>
// 
// <p>Example: With parameter <tt>nin = 3</tt> results the following equation:</p>
// 
// <pre>    y = u[1] + u[2] + u[3];
// </pre>
// 
// <p>Optionally, the <tt>parameter Real k[nin]=ones(nin)</tt> could be
// changed to weight the sum elements in order to calculate the scalar
// product</p>
// 
// <pre>    y = <b>k</b>*<b>u</b> = k[1]*u[1] + k[2]*u[2] + ... + k[nin]*u[nin]  .
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Oct. 25, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized an improved implementation with avoidance of an
//        algorithm section, which would lead to expensive function calls.</li>
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [26,38;26,42; -34,42;6,0; -34, -42;26, -42;26, -38], style(color = 0, thickness = 1)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Line(points = [26,38;26,42; -34,42;6,0; -34, -42;26, -42;26, -38], style(color = 0, thickness = 1))));
// 
//       equation 
//         y = k * u;
//       end Sum;
//       block Feedback "Output difference between commanded and feedback input"
//         parameter Integer n = 1 "size of input and feedback signal";
//         Interfaces.InPort inPort1(final n = n) annotation(extent = [ -100, -20; -60,20]);
//         Interfaces.InPort inPort2(final n = n) annotation(extent = [ -20, -100;20, -60], rotation = 90);
//         Interfaces.OutPort outPort(final n = n) annotation(extent = [80, -10;100,10]);
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal as <i>difference</i> of the
// commanded input <b>u1</b>=inPort1.signal and the feedback
// input <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    <b>y</b> = <b>u1</b> - <b>u2</b>;
// </pre>
// 
// <p>
// Example:
// </p>
// 
// <pre>     parameter:   n = 2
// 
//   results in the following equations:
// 
//      y[1] = u1[1] - u2[1]
//      y[2] = u1[2] - u2[2]
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Ellipse(extent = [ -20,20;20, -20], style(pattern = 1, thickness = 1, fillColor = 30, fillPattern = 1)), Line(points = [ -60,0; -20,0]), Line(points = [20,0;80,0]), Line(points = [0, -20;0, -60]), Text(extent = [ -12,10;84, -84], string = "-", style(color = 0)), Text(extent = [ -100,110;100,60], string = "%name")), Diagram(Ellipse(extent = [ -20,20;20, -20], style(pattern = 1, thickness = 1, fillColor = 30, fillPattern = 1)), Line(points = [ -60,0; -20,0]), Line(points = [20,0;80,0]), Line(points = [0, -20;0, -60]), Text(extent = [ -12,10;84, -84], string = "-", style(color = 0))));
// 
//       equation 
//         outPort.signal = inPort1.signal - inPort2.signal;
//       end Feedback;
//       block Add "Output the sum of the two inputs"
//         extends Interfaces.MI2MO;
//         parameter Real k1 =  +1 "Gain of upper input";
//         parameter Real k2 =  +1 "Gain of lower input";
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal as <i>sum</i> of the
// two input signals <b>u1</b>=inPort1.signal and <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b>;
// </pre>
// 
// <p>
// Example:
// </p>
// 
// <pre>     parameter:   n = 2, k1= +2, k2= -3
// 
//   results in the following equations:
// 
//      y[1] = 2 * u1[1] - 3 * u2[1]
//      y[2] = 2 * u1[2] - 3 * u2[2]
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [ -98, -52;7, -92], string = "%k2", style(color = 0)), Text(extent = [ -100,90;5,50], string = "%k1", style(color = 0)), Text(extent = [ -150,150;150,110], string = "%name"), Line(points = [ -100,60; -40,60; -30,40]), Ellipse(extent = [ -50,50;50, -50]), Line(points = [ -100, -60; -40, -60; -30, -40]), Line(points = [ -15, -25.99;15,25.99], style(color = 0)), Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Line(points = [50,0;100,0]), Line(points = [ -100,60; -74,24; -44,24]), Line(points = [ -100, -60; -74, -28; -42, -28]), Ellipse(extent = [ -50,50;50, -50]), Line(points = [50,0;100,0]), Text(extent = [ -38,34;38, -34], string = "+", style(color = 0)), Text(extent = [ -100,52;5,92], string = "%k1", style(color = 0)), Text(extent = [ -100, -52;5, -92], string = "%k2", style(color = 0))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Text(extent = [ -98, -52;7, -92], string = "%k2", style(color = 0)), Text(extent = [ -100,90;5,50], string = "%k1", style(color = 0)), Line(points = [ -100,60; -40,60; -30,40]), Ellipse(extent = [ -50,50;50, -50]), Line(points = [ -100, -60; -40, -60; -30, -40]), Line(points = [ -15, -25.99;15,25.99], style(color = 0)), Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Line(points = [50,0;100,0]), Line(points = [ -100,60; -74,24; -44,24]), Line(points = [ -100, -60; -74, -28; -42, -28]), Ellipse(extent = [ -50,50;50, -50]), Line(points = [50,0;100,0]), Text(extent = [ -38,34;38, -34], string = "+", style(color = 0)), Text(extent = [ -100,52;5,92], string = "k1", style(color = 0)), Text(extent = [ -100, -52;5, -92], string = "k2", style(color = 0))));
// 
//       equation 
//         y = k1 * u1 + k2 * u2;
//       end Add;
//       block Add3 "Output the sum of the three inputs"
//         extends Interfaces.BlockIcon;
//         parameter Real k1 =  +1 "Gain of upper input";
//         parameter Real k2 =  +1 "Gain of middle input";
//         parameter Real k3 =  +1 "Gain of lower input";
//         parameter Integer n = 1 "Dimension of input and output vectors.";
//         Interfaces.InPort inPort1(final n = n) "Connector 1 of Real input signals" annotation(extent = [ -140,60; -100,100]);
//         Interfaces.InPort inPort2(final n = n) "Connector 2 of Real input signals" annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.InPort inPort3(final n = n) "Connector 3 of Real input signals" annotation(extent = [ -140, -100; -100, -60]);
//         Interfaces.OutPort outPort(final n = n) "Connector of Real output signals" annotation(extent = [100, -10;120,10]);
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal as <i>sum</i> of the
// three input signals <b>u1</b>=inPort1.signal, <b>u2</b>=inPort2.signal
// and <b>u3</b>=inPort3.signal:
// </p>
// 
// <pre>    <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b> + k3*<b>u3</b>;
// </pre>
// 
// <p>
// Example:
// </p>
// 
// <pre>     parameter:   n = 2, k1= +2, k2= -3, k3=1;
// 
//   results in the following equations:
// 
//      y[1] = 2 * u1[1] - 3 * u2[1] + u3[1];
//      y[2] = 2 * u1[2] - 3 * u2[2] + u3[2];
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [ -100,50;5,90], string = "%k1", style(color = 0)), Text(extent = [ -100, -20;5,20], string = "%k2", style(color = 0)), Text(extent = [ -100, -50;5, -90], string = "%k3", style(color = 0)), Text(extent = [2,36;100, -44], string = "+", style(color = 0))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Text(extent = [ -100,50;5,90], string = "%k1", style(color = 0)), Text(extent = [ -100, -20;5,20], string = "%k2", style(color = 0)), Text(extent = [ -100, -50;5, -90], string = "%k3", style(color = 0)), Text(extent = [2,36;100, -44], string = "+", style(color = 0)), Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Text(extent = [ -100,50;5,90], string = "k1", style(color = 0)), Text(extent = [ -100, -20;5,20], string = "k2", style(color = 0)), Text(extent = [ -100, -50;5, -90], string = "k3", style(color = 0)), Text(extent = [2,36;100, -44], string = "+", style(color = 0))));
// 
//       equation 
//         outPort.signal = k1 * inPort1.signal + k2 * inPort2.signal + k3 * inPort3.signal;
//       end Add3;
//       block Product "Output product of the two inputs"
//         extends Interfaces.MI2MO;
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>product</i> of the corresponding elements of
// the two inputs <b>u1</b>=inPort1.signal and <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    y[i] = u1[i] * u2[i];
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -100,60; -40,60; -30,40]), Line(points = [ -100, -60; -40, -60; -30, -40]), Line(points = [50,0;100,0]), Line(points = [ -30,0;30,0], style(color = 0)), Line(points = [ -15,25.99;15, -25.99], style(color = 0)), Line(points = [ -15, -25.99;15,25.99], style(color = 0)), Ellipse(extent = [ -50,50;50, -50])), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Line(points = [ -100,60; -40,60; -30,40]), Line(points = [ -100, -60; -40, -60; -30, -40]), Line(points = [50,0;100,0]), Line(points = [ -30,0;30,0], style(color = 0)), Line(points = [ -15,25.99;15, -25.99], style(color = 0)), Line(points = [ -15, -25.99;15,25.99], style(color = 0)), Ellipse(extent = [ -50,50;50, -50])));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = u1[i] * u2[i];
// 
//         end for;
//       end Product;
//       block Division "Output first input divided by second input"
//         extends Interfaces.MI2MO;
//         annotation(Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// by <i>dividing</i> the corresponding elements of
// the two inputs <b>u1</b>=inPort1.signal and <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    y[i] = u1[i] / u2[i];
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [50,0;100,0]), Line(points = [ -30,0;30,0], style(color = 0)), Ellipse(extent = [ -5,20;5,30], style(color = 0, fillColor = 0)), Ellipse(extent = [ -5, -20;5, -30], style(color = 0, fillColor = 0)), Ellipse(extent = [ -50,50;50, -50]), Text(extent = [ -150,150;150,110], string = "%name"), Line(points = [ -100,60; -66,60; -40,30]), Line(points = [ -100, -60;0, -60;0, -50])), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, fillColor = 7)), Line(points = [50,0;100,0]), Line(points = [ -30,0;30,0], style(color = 0)), Ellipse(extent = [ -5,20;5,30], style(color = 0, fillColor = 0)), Ellipse(extent = [ -5, -20;5, -30], style(color = 0, fillColor = 0)), Ellipse(extent = [ -50,50;50, -50]), Line(points = [ -100,60; -66,60; -40,30]), Line(points = [ -100, -60;0, -60;0, -50])));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = u1[i] / u2[i];
// 
//         end for;
//       end Division;
//       block Abs "Output the absolute value of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [92,0;70,8;70, -8;92,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80;0,0;80,80], style(color = 0)), Line(points = [0, -14;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [ -34, -28;38, -76], string = "abs", style(color = 8)), Line(points = [ -88,0;76,0], style(color = 8))), Diagram(Line(points = [ -100,0;76,0], style(color = 8)), Polygon(points = [92,0;76,6;76, -6;92,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80;0,0;80,80], style(color = 0)), Line(points = [0, -80;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [7,98;34,78], string = "outPort", style(color = 9)), Text(extent = [74, -8;96, -28], string = "inPort", style(color = 9)), Text(extent = [52, -3;72, -23], string = "1"), Text(extent = [ -86, -1; -66, -21], string = "-1"), Text(extent = [ -28,79; -8,59], string = "1")), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>absolute value</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>abs</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = abs(u);
//       end Abs;
//       block Sign "Output the sign of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80;0, -80], style(color = 0)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Text(extent = [ -90,72; -18,24], string = "sign", style(color = 8)), Line(points = [0,80;80,80], style(color = 0)), Rectangle(extent = [ -2,2;2, -4], style(color = 0, fillColor = 0, fillPattern = 1))), Diagram(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80;0, -80], style(color = 0)), Line(points = [ -0.01,0;0.01,0], style(color = 0)), Line(points = [0,80;80,80], style(color = 0)), Rectangle(extent = [ -2,2;2, -4], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [7,102;32,82], string = "outPort", style(color = 9)), Text(extent = [70, -6;94, -26], string = "inPort", style(color = 9)), Text(extent = [ -25,86; -5,70], string = "1"), Text(extent = [5, -72;25, -88], string = "-1")), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <b>sign</b> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>            1  <b>if</b> u[i] > 0
//     y[i] =  0  <b>if</b> u[i] == 0
//            -1  <b>if</b> u[i] < 0
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = sign(u);
//       end Sign;
//       block Sqrt "Output the square root of the input (input >= 0 required)"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Line(points = [ -90, -80;68, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -68.7; -78.4, -64; -76.8, -57.3; -73.6, -47.9; -67.9, -36.1; -59.1, -22.2; -46.2, -6.49; -28.5,10.7; -4.42,30;27.7,51.3;69.5,74.7;80,80], style(color = 0)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80, -88; -80,68], style(color = 8)), Text(extent = [ -8, -4;64, -52], string = "sqrt", style(color = 8))), Diagram(Line(points = [ -92, -80;84, -80], style(color = 8)), Polygon(points = [100, -80;84, -74;84, -86;100, -80], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -68.7; -78.4, -64; -76.8, -57.3; -73.6, -47.9; -67.9, -36.1; -59.1, -22.2; -46.2, -6.49; -28.5,10.7; -4.42,30;27.7,51.3;69.5,74.7;80,80], style(color = 0)), Polygon(points = [ -80,98; -86,82; -74,82; -80,98], style(color = 8, fillColor = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -71,98; -44,78], string = "outPort", style(color = 9)), Text(extent = [60, -52;84, -72], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>square root</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = sqrt( u[i] );
// </pre>
// 
// <p>
// All elements of the input vector shall be zero or positive.
// Otherwise an error occurs.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = sqrt(u);
//       end Sqrt;
//       block Sin "Output the sine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,68], style(color = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Line(points = [ -80,0; -68.7,34.2; -61.5,53.1; -55.1,66.4; -49.4,74.6; -43.8,79.1; -38.2,79.8; -32.6,76.6; -26.9,69.7; -21.3,59.4; -14.9,44.1; -6.83,21.2;10.1, -30.8;17.3, -50.2;23.7, -64.2;29.3, -73.1;35, -78.4;40.6, -80;46.2, -77.6;51.9, -71.5;57.5, -61.9;63.9, -47.2;72, -24.8;80,0], style(color = 0)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Text(extent = [12,84;84,36], string = "sin", style(color = 8))), Diagram(Line(points = [ -80,80; -88,80], style(color = 8)), Line(points = [ -80, -80; -88, -80], style(color = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -75,98; -46,78], string = "outPort", style(color = 9)), Polygon(points = [ -80,96; -86,80; -74,80; -80,96], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80,0; -68.7,34.2; -61.5,53.1; -55.1,66.4; -49.4,74.6; -43.8,79.1; -38.2,79.8; -32.6,76.6; -26.9,69.7; -21.3,59.4; -14.9,44.1; -6.83,21.2;10.1, -30.8;17.3, -50.2;23.7, -64.2;29.3, -73.1;35, -78.4;40.6, -80;46.2, -77.6;51.9, -71.5;57.5, -61.9;63.9, -47.2;72, -24.8;80,0], style(color = 0)), Text(extent = [ -105,72; -85,88], string = "1"), Text(extent = [70,25;90,5], string = "2*pi"), Text(extent = [ -105, -72; -85, -88], string = "-1"), Text(extent = [76, -10;98, -30], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <b>sine</b> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>sin</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.sin(u);
//       end Sin;
//       block Cos "Output the cosine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,68], style(color = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -74.4,78.1; -68.7,72.3; -63.1,63; -56.7,48.7; -48.6,26.6; -29.3, -32.5; -22.1, -51.7; -15.7, -65.3; -10.1, -73.8; -4.42, -78.8;1.21, -79.9;6.83, -77.1;12.5, -70.6;18.1, -60.6;24.5, -45.7;32.6, -23;50.3,31.3;57.5,50.7;63.9,64.6;69.5,73.4;75.2,78.6;80,80], style(color = 0)), Text(extent = [ -36,82;36,34], string = "cos", style(color = 8))), Diagram(Line(points = [ -80,80; -88,80], style(color = 8)), Line(points = [ -80, -80; -88, -80], style(color = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -75,102; -48,82], string = "outPort", style(color = 9)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Text(extent = [ -103,72; -83,88], string = "1"), Text(extent = [ -79, -72; -59, -88], string = "-1"), Text(extent = [70,25;90,5], string = "2*pi"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -74.4,78.1; -68.7,72.3; -63.1,63; -56.7,48.7; -48.6,26.6; -29.3, -32.5; -22.1, -51.7; -15.7, -65.3; -10.1, -73.8; -4.42, -78.8;1.21, -79.9;6.83, -77.1;12.5, -70.6;18.1, -60.6;24.5, -45.7;32.6, -23;50.3,31.3;57.5,50.7;63.9,64.6;69.5,73.4;75.2,78.6;80,80], style(color = 0)), Text(extent = [74, -4;98, -24], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <b>cos</b> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>cos</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.cos(u);
//       end Cos;
//       block Tan "Output the tangent of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Line(points = [ -80, -80; -78.4, -68.4; -76.8, -59.7; -74.4, -50; -71.2, -40.9; -67.1, -33; -60.7, -24.8; -51.1, -17.2; -35.8, -9.98; -4.42, -1.07;33.4,9.12;49.4,16.2;59.1,23.2;65.5,30.6;70.4,39.1;73.6,47.4;76,56.1;77.6,63.8;80,80], style(color = 0)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Text(extent = [ -90,72; -18,24], string = "tan", style(color = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -88;0,86], style(color = 8)), Text(extent = [11,100;38,80], string = "outPort", style(color = 9)), Polygon(points = [0,102; -6,86;6,86;0,102], style(color = 8, fillColor = 8)), Text(extent = [ -37, -72; -17, -88], string = "-5.8"), Text(extent = [ -33,86; -13,70], string = " 5.8"), Text(extent = [70,25;90,5], string = "1.4"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -78.4, -68.4; -76.8, -59.7; -74.4, -50; -71.2, -40.9; -67.1, -33; -60.7, -24.8; -51.1, -17.2; -35.8, -9.98; -4.42, -1.07;33.4,9.12;49.4,16.2;59.1,23.2;65.5,30.6;70.4,39.1;73.6,47.4;76,56.1;77.6,63.8;80,80], style(color = 0)), Text(extent = [70, -6;94, -26], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <b>tan</b> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>tan</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.tan(u);
//       end Tan;
//       block Asin "Output the arc sine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Line(points = [ -80, -80; -79.2, -72.8; -77.6, -67.5; -73.6, -59.4; -66.3, -49.8; -53.5, -37.3; -30.2, -19.7;37.4,24.8;57.5,40.8;68.7,52.7;75.2,62.2;77.6,67.5;80,80], style(color = 0)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Text(extent = [ -88,78; -16,30], string = "asin", style(color = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [9,102;36,82], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Text(extent = [ -40, -72; -15, -88], string = "-pi/2"), Text(extent = [ -38,88; -13,72], string = " pi/2"), Text(extent = [70,25;90,5], string = "+1"), Text(extent = [ -90,21; -70,1], string = "-1"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -72.8; -77.6, -67.5; -73.6, -59.4; -66.3, -49.8; -53.5, -37.3; -30.2, -19.7;37.4,24.8;57.5,40.8;68.7,52.7;75.2,62.2;77.6,67.5;80,80], style(color = 0)), Text(extent = [74, -4;100, -26], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>sine-inverse</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>asin</b>( u[i] );
// </pre>
// 
// <p>
// The absolute values of the elements of the input <b>u</b> need to
// be less or equal to one (<b>abs</b>( u[i] ) <= 1).
// Otherwise an error occurs.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.asin(u);
//       end Asin;
//       block Acos "Output the arc cosine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -79.2,72.8; -77.6,67.5; -73.6,59.4; -66.3,49.8; -53.5,37.3; -30.2,19.7;37.4, -24.8;57.5, -40.8;68.7, -52.7;75.2, -62.2;77.6, -67.5;80, -80], style(color = 0)), Line(points = [0, -88;0,68], style(color = 8)), Line(points = [ -90, -80;68, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Text(extent = [ -86, -14; -14, -62], string = "acos", style(color = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [13,100;42,82], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100, -80;84, -80], style(color = 8)), Polygon(points = [100, -80;84, -74;84, -86;100, -80], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -79.2,72.8; -77.6,67.5; -73.6,59.4; -66.3,49.8; -53.5,37.3; -30.2,19.7;37.4, -24.8;57.5, -40.8;68.7, -52.7;75.2, -62.2;77.6, -67.5;80, -80], style(color = 0)), Text(extent = [ -30,88; -5,72], string = " pi"), Text(extent = [ -94, -57; -74, -77], string = "-1"), Text(extent = [80, -45;100, -65], string = "+1"), Text(extent = [76, -84;102, -102], string = "inPort", style(color = 9))), Documentation(info = "<html>
// 
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>cosine-inverse</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>acos</b>( u[i] );
// </pre>
// 
// <p>
// The absolute values of the elements of the input <b>u</b> need to
// be less or equal to one (<b>abs</b>( u[i] ) <= 1).
// Otherwise an error occurs.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.acos(u);
//       end Acos;
//       block Atan "Output the arc tangent of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Line(points = [ -80, -80; -52.7, -75.2; -37.4, -69.7; -26.9, -63; -19.7, -55.2; -14.1, -45.8; -10.1, -36.4; -6.03, -23.9; -1.21, -5.06;5.23,21;9.25,34.1;13.3,44.2;18.1,52.9;24.5,60.8;33.4,67.6;47,73.6;69.5,78.6;80,80], style(color = 0)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Text(extent = [ -86,68; -14,20], string = "atan", style(color = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [13,102;42,82], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -52.7, -75.2; -37.4, -69.7; -26.9, -63; -19.7, -55.2; -14.1, -45.8; -10.1, -36.4; -6.03, -23.9; -1.21, -5.06;5.23,21;9.25,34.1;13.3,44.2;18.1,52.9;24.5,60.8;33.4,67.6;47,73.6;69.5,78.6;80,80], style(color = 0)), Text(extent = [ -32,91; -12,71], string = "1.4"), Text(extent = [ -32, -71; -12, -91], string = "-1.4"), Text(extent = [73,26;93,10], string = " 5.8"), Text(extent = [ -103,20; -83,4], string = "-5.8"), Text(extent = [66, -8;94, -28], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>tangent-inverse</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>atan</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.atan(u);
//       end Atan;
//       block Atan2 "Output atan(u1/u2) of the inputs u1 and u2"
//         extends Interfaces.MI2MO;
//         annotation(Icon(Text(extent = [ -150,150;150,110], string = "%name"), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -34.9; -46.1, -31.4; -29.4, -27.1; -18.3, -21.5; -10.3, -14.5; -2.03, -3.17;7.97,11.6;15.5,19.4;24.3,25;39,30;62.1,33.5;80,34.9], style(color = 0)), Line(points = [ -80,45.1; -45.9,48.7; -29.1,52.9; -18.1,58.6; -10.2,65.8; -1.82,77.2;0,80], style(color = 0)), Line(points = [0, -80;8.93, -67.2;17.1, -59.3;27.3, -53.6;42.1, -49.4;69.9, -45.8;80, -45.1], style(color = 0)), Text(extent = [ -90, -46; -18, -94], string = "atan2", style(color = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [11,98;42,78], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [0, -80;8.93, -67.2;17.1, -59.3;27.3, -53.6;42.1, -49.4;69.9, -45.8;80, -45.1], style(color = 0)), Line(points = [ -80, -34.9; -46.1, -31.4; -29.4, -27.1; -18.3, -21.5; -10.3, -14.5; -2.03, -3.17;7.97,11.6;15.5,19.4;24.3,25;39,30;62.1,33.5;80,34.9], style(color = 0)), Line(points = [ -80,45.1; -45.9,48.7; -29.1,52.9; -18.1,58.6; -10.2,65.8; -1.82,77.2;0,80], style(color = 0)), Text(extent = [ -30,89; -10,70], string = "pi"), Text(extent = [ -30, -69; -10, -88], string = "-pi"), Text(extent = [ -30,49; -10,30], string = "pi/2"), Line(points = [0,40; -8,40], style(color = 8)), Line(points = [0, -40; -8, -40], style(color = 8)), Text(extent = [ -30, -31; -10, -50], string = "-pi/2"), Text(extent = [48,0;100, -34], string = "inPort1 / inPort2", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>tangent-inverse</i> of the input <b>u1</b>=inPort1.signal divided by
// input <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    y[i] = <b>atan2</b>( u1[i], u2[i] );
// </pre>
// 
// <p>
// u1[i] and u2[i] shall not be zero at the same time instant.
// <b>Atan2</b> uses the sign of u1[i] and u2[i] in order to construct
// the solution in the range -180 deg <= y[i] <= 180 deg, whereas
// block <b>Atan</b> gives a solution in the range
// -90 deg <= y[i] <= 90 deg.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.atan2(u1, u2);
//       end Atan2;
//       block Sinh "Output the hyperbolic sine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [ -86,80; -14,32], string = "sinh", style(color = 8)), Line(points = [0, -80;0,68], style(color = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Line(points = [ -80, -80; -76, -65.4; -71.2, -51.4; -65.5, -38.8; -59.1, -28.1; -51.1, -18.7; -41.4, -11.4; -27.7, -5.5; -4.42, -0.653;24.5,4.57;39,10.1;49.4,17.2;57.5,25.9;63.9,35.8;69.5,47.4;74.4,60.4;78.4,73.8;80,80], style(color = 0)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [9,98;34,78], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -76, -65.4; -71.2, -51.4; -65.5, -38.8; -59.1, -28.1; -51.1, -18.7; -41.4, -11.4; -27.7, -5.5; -4.42, -0.653;24.5,4.57;39,10.1;49.4,17.2;57.5,25.9;63.9,35.8;69.5,47.4;74.4,60.4;78.4,73.8;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "27"), Text(extent = [ -35, -88; -15, -72], string = "-27"), Text(extent = [70,25;90,5], string = "4"), Text(extent = [ -98,21; -78,1], string = "-4"), Text(extent = [72, -6;96, -26], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>hyperbolic sine</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>sinh</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.sinh(u);
//       end Sinh;
//       block Cosh "Output the hyperbolic cosine of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [0, -80;0,68], style(color = 8)), Text(extent = [4,66;66,20], string = "cosh", style(color = 8)), Line(points = [ -80,80; -77.6,61.1; -74.4,39.3; -71.2,20.7; -67.1,1.29; -63.1, -14.6; -58.3, -29.8; -52.7, -43.5; -46.2, -55.1; -39, -64.3; -30.2, -71.7; -18.9, -77.1; -4.42, -79.9;10.9, -79.1;23.7, -75.2;34.2, -68.7;42.2, -60.6;48.6, -51.2;54.3, -40;59.1, -27.5;63.1, -14.6;67.1,1.29;71.2,20.7;74.4,39.3;77.6,61.1;80,80], style(color = 0)), Line(points = [ -90, -86.083;68, -86.083], style(color = 8)), Polygon(points = [90, -86.083;68, -78.083;68, -94.083;90, -86.083], style(color = 8, fillColor = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [11,98;38,78], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100, -86.083;84, -86.083], style(color = 8)), Polygon(points = [100, -86.083;84, -80.083;84, -92.083;100, -86.083], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -77.6,61.1; -74.4,39.3; -71.2,20.7; -67.1,1.29; -63.1, -14.6; -58.3, -29.8; -52.7, -43.5; -46.2, -55.1; -39, -64.3; -30.2, -71.7; -18.9, -77.1; -4.42, -79.9;10.9, -79.1;23.7, -75.2;34.2, -68.7;42.2, -60.6;48.6, -51.2;54.3, -40;59.1, -27.5;63.1, -14.6;67.1,1.29;71.2,20.7;74.4,39.3;77.6,61.1;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "27"), Text(extent = [62, -67;82, -87], string = "4"), Text(extent = [ -104, -63; -84, -83], string = "-4"), Text(extent = [78, -54;100, -74], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>hyperbolic cosine</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>cosh</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.cosh(u);
//       end Cosh;
//       block Tanh "Output the hyperbolic tangent of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Line(points = [0, -90;0,84], style(color = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Line(points = [ -80, -80; -47.8, -78.7; -35.8, -75.7; -27.7, -70.6; -22.1, -64.2; -17.3, -55.9; -12.5, -44.3; -7.64, -29.2; -1.21, -4.82;6.83,26.3;11.7,42;16.5,54.2;21.3,63.1;26.9,69.9;34.2,75;45.4,78.4;72,79.9;80,80], style(color = 0)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [ -88,72; -16,24], string = "tanh", style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [9,98;42,80], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -47.8, -78.7; -35.8, -75.7; -27.7, -70.6; -22.1, -64.2; -17.3, -55.9; -12.5, -44.3; -7.64, -29.2; -1.21, -4.82;6.83,26.3;11.7,42;16.5,54.2;21.3,63.1;26.9,69.9;34.2,75;45.4,78.4;72,79.9;80,80], style(color = 0)), Text(extent = [70,25;90,5], string = "4"), Text(extent = [ -106,21; -86,1], string = "-4"), Text(extent = [ -29,72; -9,88], string = "1"), Text(extent = [3, -72;23, -88], string = "-1"), Text(extent = [72, -8;98, -26], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>hyperbolic tangent</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>tanh</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.tanh(u);
//       end Tanh;
//       block Exp "Output the exponential (base e) of the input"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Line(points = [0, -80;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [ -86,50; -14,2], string = "exp", style(color = 8)), Line(points = [ -80, -80; -31, -77.9; -6.03, -74;10.9, -68.4;23.7, -61;34.2, -51.6;43, -40.3;50.3, -27.8;56.7, -13.5;62.3,2.23;67.1,18.6;72,38.2;76,57.6;80,80], style(color = 0)), Line(points = [ -90, -80.3976;68, -80.3976], style(color = 8)), Polygon(points = [90, -80.3976;68, -72.3976;68, -88.3976;90, -80.3976], style(color = 8, fillColor = 8))), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [9,100;40,80], string = "outPort", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8)), Line(points = [ -100, -80.3976;84, -80.3976], style(color = 8)), Polygon(points = [100, -80.3976;84, -74.3976;84, -86.3976;100, -80.3976], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -31, -77.9; -6.03, -74;10.9, -68.4;23.7, -61;34.2, -51.6;43, -40.3;50.3, -27.8;56.7, -13.5;62.3,2.23;67.1,18.6;72,38.2;76,57.6;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "20"), Text(extent = [ -92, -83; -72, -103], string = "-3"), Text(extent = [70, -83;90, -103], string = "3"), Text(extent = [ -18, -53;2, -73], string = "1"), Text(extent = [66, -52;96, -72], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>exponential</i> (of base e) of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>exp</b>( u[i] );
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.exp(u);
//       end Exp;
//       block Log "Output the natural (base e) logarithm of the input (input > 0 required)"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Line(points = [ -80, -80; -80,68], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Text(extent = [ -6, -24;66, -72], string = "log", style(color = 8))), Diagram(Line(points = [ -80,80; -88,80], style(color = 8)), Line(points = [ -80, -80; -88, -80], style(color = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -67,98; -40,80], string = "outPort", style(color = 9)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [ -105,72; -85,88], string = "3"), Text(extent = [ -109, -88; -89, -72], string = "-3"), Text(extent = [70, -3;90, -23], string = "20"), Text(extent = [ -78, -1; -58, -21], string = "1"), Text(extent = [68,28;94,8], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>natural (base e) logarithm</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>log</b>( u[i] );
// </pre>
// 
// <p>
// An error occurs if the elements of the input <b>u</b> are
// zero or negative.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.log(u);
//       end Log;
//       block Log10 "Output the base 10 logarithm of the input (input > 0 required)"
//         extends Interfaces.MIMOs;
//         annotation(Icon(Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Line(points = [ -79.8, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -80,68], style(color = 8)), Text(extent = [ -30, -22;60, -70], string = "log10", style(color = 8))), Diagram(Line(points = [ -80,80; -88,80], style(color = 8)), Line(points = [ -80, -80; -88, -80], style(color = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -65,96; -38,78], string = "outPort", style(color = 9)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -79.8, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [70, -3;90, -23], string = "20"), Text(extent = [ -78, -1; -58, -21], string = "1"), Text(extent = [ -109,72; -89,88], string = " 1.3"), Text(extent = [ -109, -88; -89, -72], string = "-1.3"), Text(extent = [62,30;90,10], string = "inPort", style(color = 9))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise as the
// <i>base 10 logarithm</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>log10</b>( u[i] );
// </pre>
// 
// <p>
// An error occurs if the elements of the input <b>u</b> are
// zero or negative.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>August 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         y = Modelica.Math.log10(u);
//       end Log10;
//       block RealToInteger "Convert real to integer signals"
//         extends Interfaces.IntegerBlockIcon;
//         parameter Integer n = 1 "Number of input and output signals";
//       protected 
//         Real u[n];
//         annotation(Icon(Text(extent = [ -100,60;0, -60], string = "R"), Text(extent = [20,60;120, -60], string = "I", style(color = 45)), Polygon(points = [50,0;30,20;30,10;0,10;0, -10;30, -10;30, -20;50,0], style(color = 45, fillColor = 45))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>nearest integer value</i> of the input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = <b>integer</b>( <b>floor</b>( u[i] + 0.5 ) )  for  u[i] &gt; 0;
//     y[i] = <b>integer</b>( <b>ceil </b>( u[i] - 0.5 ) )  for  u[i] &lt; 0;
// </pre>
// </html>
// "));
//       public 
//         Interfaces.InPort inPort(final n = n) annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.IntegerOutPort outPort(final n = n) annotation(extent = [100, -10;120,10]);
// 
//       equation 
//         u = inPort.signal;
//         for i in 1:n loop
//         outPort.signal[i] = if u[i] > 0 then integer(floor(u[i] + 0.5)) else integer(ceil(u[i] - 0.5));
// 
//         end for;
//       end RealToInteger;
//       block IntegerToReal "Convert integer to real signals"
//         extends Interfaces.BlockIcon;
//         parameter Integer n = 1 "Number of input signals (= number of output signals)";
//         annotation(Icon(Text(extent = [ -120,60; -20, -60], string = "I", style(color = 45)), Text(extent = [0,60;100, -60], string = "R"), Polygon(points = [10,0; -10,20; -10,10; -40,10; -40, -10; -10, -10; -10, -20;10,0], style(fillColor = 73))), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>Real equivalent</i> of the Integer input <b>u</b>=inPort.signal:
// </p>
// 
// <pre>    y[i] = u[i];
// </pre>
// 
// <p>where <b>u</b> is of Integer and <b>y</b> of Real type.</p>
// </html>
// "));
//         Interfaces.OutPort outPort(final n = n) annotation(extent = [100, -10;120,10]);
//         Interfaces.IntegerInPort inPort(final n = n) annotation(extent = [ -140, -20; -100,20]);
// 
//       equation 
//         outPort.signal = inPort.signal;
//       end IntegerToReal;
//       block Max "Pass through the largest signal"
//         extends Interfaces.MI2MO;
//         annotation(Icon(Text(extent = [ -90,36;90, -36], style(color = 9), string = "max()")), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>maximum</i> of the two inputs <b>u1</b>=inPort1.signal and <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    y[i] = <b>max</b> ( u1[i] , u2[i] );
// </pre>
// </html>
// "));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = max(u1[i], u2[i]);
// 
//         end for;
//       end Max;
//       block Min "Pass through the smallest signal"
//         extends Interfaces.MI2MO;
//         annotation(Icon(Text(extent = [ -90,36;90, -36], style(color = 9), string = "min()")), Documentation(info = "<html>
// <p>
// This block computes the output <b>y</b>=outPort.signal element-wise
// as <i>minimum</i> of the two inputs <b>u1</b>=inPort1.signal and <b>u2</b>=inPort2.signal:
// </p>
// 
// <pre>    y[i] = <b>min</b> ( u1[i] , u2[i] );
// </pre>
// </html>
// "));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = min(u1[i], u2[i]);
// 
//         end for;
//       end Min;
//       block Edge "Indicates rising edge of boolean signal"
//         extends Interfaces.BooleanMIMOs;
//         annotation(Icon(Text(extent = [ -90,36;90, -36], style(color = 9), string = "edge()")), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b>=outPort.signal element-wise
// to true, when the Boolean input <b>u</b>=inPort.signal shows a <i>rising edge</i>:
// </p>
// 
// <pre>    y[i] = <b>edge</b>( u[i] );
// </pre>
// </html>
// "));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = edge(u[i]);
// 
//         end for;
//         annotation(Icon);
//       end Edge;
//       block BooleanChange "Indicates boolean signal changing"
//         extends Interfaces.BooleanMIMOs;
//         annotation(Icon(Text(extent = [ -90,36;90, -36], style(color = 9), string = "change()")), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b>=outPort.signal element-wise
// to true, when the Boolean input <b>u</b>=inPort.signal shows a <i>rising
// or falling edge</i>, i.e., when the signal changes:
// </p>
// 
// <pre>    y[i] = <b>change</b>( u[i] );
// </pre>
// </html>
// "));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = change(u[i]);
// 
//         end for;
//       end BooleanChange;
//       block IntegerChange "Indicates integer signal changing"
//         extends Interfaces.IntegerMIBooleanMOs;
//         annotation(Icon(Text(extent = [ -90,36;90, -36], style(color = 9), string = "change()")), Documentation(info = "<html>
// <p>
// This block sets the Boolean output <b>y</b>=outPort.signal element-wise
// to true, when the Integer input <b>u</b>=inPort.signal changes:
// </p>
// 
// <pre>    y[i] = <b>change</b>( u[i] );
// </pre>
// </html>
// "));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = change(u[i]);
// 
//         end for;
//       end IntegerChange;
//     end Math;
//     package Nonlinear "Discontinuous or non-differentiable algebraic control blocks"
//       extends Modelica.Icons.Library;
//       annotation(Window(x = 0.05, y = 0.1, width = 0.21, height = 0.23, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains <b>discontinuous</b> and
// <b>non-differentiable, algebraic</b> input/output blocks.
// In particular the following blocks are provided:
// </p>
// 
// <pre>
//    <b>Limiter</b>           Limit the range of a signal to fixed limits.
//    <b>VariableLimiter</b>   Limit the range of a signal to variable limits.
//    <b>DeadZone</b>          Provide a region of zero output.
// </pre>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New block VariableLimiter added.
// <li><i>August 22, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.
// </li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       block Limiter "Limit the range of a signal"
//         parameter Real uMax[:] = {1} "Upper limits of input signals";
//         parameter Real uMin[size(uMax, 1)](max = uMax) =  -uMax "Lower limits of input signals";
//         extends Interfaces.MIMOs(final n = size(uMax, 1));
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.22, y = 0.06, width = 0.43, height = 0.51), Documentation(info = "<html>
// <p>
// The Limiter block passes its input signal as output signal
// as long as the input is within the specified upper and lower
// limits. If this is not the case, the corresponding limit is passed
// as output.
// </p>
// </HTML>
// "), Icon(Line(points = [0, -90;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68, -8;68,8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -70; -50, -70;50,70;80,70], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "uMax=%uMax", style(color = 0)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Line(points = [0, -60;0,50], style(color = 8)), Polygon(points = [0,60; -5,50;5,50;0,60], style(color = 8, fillColor = 8)), Line(points = [ -60,0;50,0], style(color = 8)), Polygon(points = [60,0;50, -5;50,5;60,0], style(color = 8, fillColor = 8)), Line(points = [ -50, -40; -30, -40;30,40;50,40], style(color = 0)), Text(extent = [46, -6;68, -18], string = "inPort", style(color = 10)), Text(extent = [ -30,70; -5,50], string = "outPort", style(color = 10)), Text(extent = [ -58, -54; -28, -42], string = "uMin", style(color = 10)), Text(extent = [26,40;66,56], string = "uMax", style(color = 10))));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = if u[i] > uMax[i] then uMax[i] else if u[i] < uMin[i] then uMin[i] else u[i];
// 
//         end for;
//       end Limiter;
//       block VariableLimiter "Limit the range of a signal with variable limits"
//         extends Interfaces.MIMOs;
//         Interfaces.InPort limit1(final n = n) annotation(extent = [ -140,60; -100,100]);
//         Interfaces.InPort limit2(final n = n) annotation(extent = [ -140, -100; -100, -60]);
//       protected 
//         Real uMax[n];
//         Real uMin[n];
//         annotation(Documentation(info = "<html>
// <p>
// The Limiter block passes its input signal as output signal
// as long as the input is within the upper and lower
// limits specified by the two additional inputs limit1 and
// limit2. If this is not the case, the corresponding limit
// is passed as output.
// </p>
// </HTML>
// "), Icon(Line(points = [0, -90;0,68], style(color = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68, -8;68,8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -70; -50, -70;50,70;80,70], style(color = 0)), Text(extent = [ -150,150;150,110], string = "%name"), Line(points = [ -100,80;66,80;66,70], style(fillPattern = 1)), Line(points = [ -100, -80; -64, -80; -64, -70], style(fillPattern = 1)), Polygon(points = [ -64, -70; -66, -74; -62, -74; -64, -70], style(fillPattern = 1)), Polygon(points = [66,70;64,74;68,74;66,70], style(fillPattern = 1)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8))), Diagram(Line(points = [0, -60;0,50], style(color = 8)), Polygon(points = [0,60; -5,50;5,50;0,60], style(color = 8, fillColor = 8)), Line(points = [ -60,0;50,0], style(color = 8)), Polygon(points = [60,0;50, -5;50,5;60,0], style(color = 8, fillColor = 8)), Line(points = [ -50, -40; -30, -40;30,40;50,40], style(color = 0)), Text(extent = [46, -6;68, -18], string = "inPort", style(color = 10)), Text(extent = [ -30,70; -5,50], string = "outPort", style(color = 10)), Text(extent = [ -66, -40; -26, -20], string = "uMin", style(color = 10)), Text(extent = [30,20;70,40], string = "uMax", style(color = 10)), Line(points = [ -100,80;40,80;40,40]), Line(points = [ -100, -80; -40, -80; -40, -40]), Polygon(points = [40,40;35,50;45,50;40,40], style(fillPattern = 1)), Polygon(points = [ -40, -40; -45, -50; -35, -50; -40, -40], style(fillPattern = 1))));
// 
//       equation 
//         for i in 1:n loop
//         uMax[i] = max(limit1.signal[i], limit2.signal[i]);
//         uMin[i] = min(limit1.signal[i], limit2.signal[i]);
//         y[i] = if u[i] > uMax[i] then uMax[i] else if u[i] < uMin[i] then uMin[i] else u[i];
// 
//         end for;
//       end VariableLimiter;
//       block DeadZone "Provide a region of zero output"
//         parameter Real uMax[:] = {1} "Upper limits of dead zones";
//         parameter Real uMin[size(uMax, 1)](max = uMax) =  -uMax "Lower limits of dead zones";
//         extends Interfaces.MIMOs(final n = size(uMax, 1));
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.39, y = 0.18, width = 0.56, height = 0.6), Documentation(info = "<html>
// <p>
// The DeadZone block defines a region of zero output.
// </p>
// 
// <p>
// If the input is within uMin ... uMax, the output
// is zero. Outside of this zone, the output is a linear
// function of the input with a slope of 1.
// </p>
// </HTML>
// "), Icon(Line(points = [0, -90;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68, -8;68,8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -60; -20,0;20,0;80,60], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "uMax=%uMax", style(color = 9)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Line(points = [0, -60;0,50], style(color = 8)), Polygon(points = [0,60; -5,50;5,50;0,60], style(color = 8, fillColor = 8)), Line(points = [ -76,0;74,0], style(color = 8)), Polygon(points = [84,0;74, -5;74,5;84,0], style(color = 8, fillColor = 8)), Line(points = [ -81, -40; -38,0;40,0;80,40], style(color = 0)), Text(extent = [62, -7;88, -25], string = "inPort", style(color = 10)), Text(extent = [ -36,72; -5,50], string = "outPort", style(color = 10)), Text(extent = [ -51,1; -28,19], string = "uMin", style(color = 10)), Text(extent = [27,21;52,5], string = "uMax", style(color = 10))));
// 
//       equation 
//         for i in 1:n loop
//         y[i] = if u[i] > uMax[i] then u[i] - uMax[i] else if u[i] < uMin[i] then u[i] - uMin[i] else 0;
// 
//         end for;
//       end DeadZone;
//     end Nonlinear;
//     package Sources "Signal source blocks generating Real, Integer and Boolean signals"
//       extends Modelica.Icons.Library;
//       annotation(Window(x = 0.06, y = 0.1, width = 0.43, height = 0.65, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains <b>source</b> components, i.e., blocks which
// have only output signals. These blocks are used as signal generators.
// </p>
// 
// <p>The following <b>sources</b> are provided to generate <b>Real</b> signals:</p>
// 
// <pre>
//   <b>Clock</b>             Generate actual time.
//   <b>Constant</b>          Generate constant signals.
//   <b>Step</b>              Generate step signals.
//   <b>Ramp</b>              Generate ramp signals.
//   <b>Sine</b>              Generate sine signals.
//   <b>ExpSine</b>           Generate exponentially damped sine signals.
//   <b>Exponentials</b>      Generate a rising and falling exponential signal.
//   <b>Pulse</b>             Generate pulse signals.
//   <b>SawTooth</b>          Generate sawtooth signals.
//   <b>Trapezoid</b>         Generate trapezoidal signals.
//   <b>KinematicPTP</b>      Generate an acceleration signal to move as fast as
//                     possible along a distance within given kinematic constraints.
//   <b>TimeTable</b>         Generate a (possibly discontinuous) signal by
//                     linear interpolation in a table.
// </pre>
// 
// <p>The following <b>sources</b> are provided to generate <b>Boolean</b> signals:</p>
// 
// <pre>
//   <b>BooleanConstant</b>   Generate constant signals.
//   <b>BooleanStep</b>       Generate step signals.
//   <b>BooleanPulse</b>      Generate pulse signals.
//   <b>SampleTrigger</b>     Generate sample triggers.
// </pre>
// 
// <p>The following <b>sources</b> are provided to generate <b>Integer</b> signals:</p>
// 
// <pre>
//   <b>IntegerConstant</b>   Generate constant signals.
//   <b>IntegerStep</b>       Generate step signals.
// </pre>
// 
// <p>
// All sources are <b>vectorized</b>. This means that the output
// is a vector of signals. The number of outputs is in correspondance
// to the lenght of the parameter vectors defining the signals. Examples:
// </p>
// 
// <pre>
//     // output.signal[1] = 2*sin(2*pi*2.1);
//     // output.signal[2] = 3*sin(2*pi*2.3);
//     Modelica.Blocks.Sources.Sine s1(amplitude={2,3}, freqHz={2.1,2.2});
// 
//     // output.signal[1] = 3*sin(2*pi*2.1);
//     // output.signal[2] = 3*sin(2*pi*2.3);
//     Modelica.Blocks.Sources.Sine s2(amplitude={3}, freqHz={2.1,2.3});
// </pre>
// 
// <p>
// The first instance s1 consists of two sinusoidal output signals
// with the given amplitudes and frequencies. The second instance s2
// consists also of two sinusoidal output signals. Since the
// amplitudes are the same for all output signals of s2, this value
// has to be provided only once. This approached is used for all
// parameters of signal sources: Whenever only a scalar value is
// provided for one parameter, then this value is used for all output
// signals.
// </p>
// 
// <p>
// All Real source signals (with the exception of the Constant source)
// have at least the following two parameters:
// </p>
// 
// <pre>
//    <b>offset</b>       Value which is added to all signal values.
//    <b>startTime</b>    Start time of signal. For time < startTime,
//                 the output is set to offset.
// </pre>
// 
// <p>
// The <b>offset</b> parameter is especially useful in order to shift
// the corresponding source, such that at initial time the system
// is stationary. To determine the corresponding value of offset,
// usually requires a trimming calculation.
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Integer sources added. Step, TimeTable and BooleanStep slightly changed
//        (see <a href=\"../Documentation/ChangeNotes1.5.html\">Change Notes</a>).</li>
// 
// <li><i>November 8, 1999</i>
//        by <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>,
//        <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a> and
//        <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
//        (nperiod=-1 is an infinite number of periods).</li>
// 
// <li><i>October 31, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>,
//        <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a> and
//        <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>:
//        All sources vectorized. New sources: ExpSine, Trapezoid,
//        BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
//        Improved documentation, especially detailed description of
//        signals in diagram layer.</li>
// 
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version, based on an existing Dymola library
//        of Dieter Moormann and Hilding Elmqvist.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association, DLR and Fraunhofer-Gesellschaft.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       block Clock "Generate actual time signals "
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.26, y = 0, width = 0.36, height = 0.52), Icon(Ellipse(extent = [ -80,80;80, -80], style(color = 9)), Line(points = [0,80;0,60], style(color = 9)), Line(points = [80,0;60,0], style(color = 9)), Line(points = [0, -80;0, -60], style(color = 9)), Line(points = [ -80,0; -60,0], style(color = 9)), Line(points = [37,70;26,50], style(color = 9)), Line(points = [70,38;49,26], style(color = 9)), Line(points = [71, -37;52, -27], style(color = 9)), Line(points = [39, -70;29, -51], style(color = 9)), Line(points = [ -39, -70; -29, -52], style(color = 9)), Line(points = [ -71, -37; -50, -26], style(color = 9)), Line(points = [ -71,37; -54,28], style(color = 9)), Line(points = [ -38,70; -28,51], style(color = 9)), Line(points = [0,0; -50,50], style(color = 0, thickness = 2)), Line(points = [0,0;40,0], style(color = 0, thickness = 2)), Text(extent = [ -150, -150;150, -110], string = "startTime=%startTime", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80,0; -10,0;60,70], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,0; -37, -13; -30, -13; -34,0], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -13; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -34, -69; -37, -56; -31, -56; -34, -69; -34, -69], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -81, -25; -35, -43], string = "offset", style(color = 9)), Text(extent = [ -33, -71;13, -89], string = "startTime", style(color = 9)), Text(extent = [ -66,92; -25,72], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10,0; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -10,0;50,0], style(color = 8, pattern = 2)), Line(points = [50,0;50,60], style(color = 8, pattern = 2)), Text(extent = [35,33;50,23], string = "1", style(color = 9)), Text(extent = [14,13;32,1], string = "1", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else time - p_startTime[i]);
// 
//         end for;
//       end Clock;
//       block Constant "Generate constant signals of type Real"
//         parameter Real k[:] = {1} "Constant output values";
//         extends Interfaces.MO(final nout = size(k, 1));
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.29, y = 0.19, width = 0.6, height = 0.6), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Line(points = [ -80,0;80,0], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80,0;80,0], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [ -75,94; -22,76], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -101,8; -81, -12], string = "k", style(color = 9))));
// 
//       equation 
//         outPort.signal = k;
//       end Constant;
//       block Step "Generate step signals of type Real"
//         parameter Real height[:] = {1} "Heights of steps";
//         extends Interfaces.SignalSource(final nout = max([size(height, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_height[nout] = if size(height, 1) == 1 then ones(nout) * height[1] else height;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Line(points = [ -80, -70;0, -70;0,50;80,50], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "startTime=%startTime", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -18;0, -18;0,50;80,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -21, -72;25, -90], string = "startTime", style(color = 9)), Line(points = [0, -17;0, -71], style(color = 8, pattern = 2)), Text(extent = [ -68, -36; -22, -54], string = "offset", style(color = 9)), Line(points = [ -13,50; -13, -17], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [2,50; -19,50;2,50], style(color = 8, pattern = 2)), Polygon(points = [ -13, -17; -16, -4; -10, -4; -13, -17; -13, -17], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -13,50; -16,37; -9,37; -13,50], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -68,26; -22,8], string = "height", style(color = 9)), Polygon(points = [ -13, -69; -16, -56; -10, -56; -13, -69; -13, -69], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -13, -18; -13, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -13, -18; -16, -31; -9, -31; -13, -18], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -72,100; -31,80], string = "outPort", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else p_height[i]);
// 
//         end for;
//       end Step;
//       block Ramp "Generate ramp signals"
//         parameter Real height[:] = {1} "Heights of ramps";
//         parameter Real duration[:](min = Modelica.Constants.small) = {2} "Durations of ramps";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(height, 1);size(duration, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_height[nout] = if size(height, 1) == 1 then ones(nout) * height[1] else height;
//         parameter Real p_duration[nout] = if size(duration, 1) == 1 then ones(nout) * duration[1] else duration;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.19, y = 0.02, width = 0.59, height = 0.77), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -70; -40, -70;31,38], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "duration=%duration", style(color = 0)), Line(points = [31,38;86,38], style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -20; -20, -20;50,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -40, -20; -42, -30; -37, -30; -40, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -20; -40, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -80, -33; -41, -49], string = "offset", style(color = 9)), Text(extent = [ -40, -70;6, -88], string = "startTime", style(color = 9)), Text(extent = [ -66,92; -25,72], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Line(points = [ -19, -20;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [50,50;101,50], style(color = 0, thickness = 2)), Line(points = [50,50;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [50, -20;42, -18;42, -22;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -20, -20; -11, -18; -11, -22; -20, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50,50;48,40;53,40;50,50], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50, -20;47, -10;52, -10;50, -20;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [53,25;82,7], string = "height", style(color = 9)), Text(extent = [0, -17;35, -37], string = "duration", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else if time < p_startTime[i] + p_duration[i] then ((time - p_startTime[i]) * p_height[i]) / p_duration[i] else p_height[i]);
// 
//         end for;
//       end Ramp;
//       block Sine "Generate sine signals"
//         parameter Real amplitude[:] = {1} "Amplitudes of sine waves";
//         parameter SI.Frequency freqHz[:] = {1} "Frequencies of sine waves";
//         parameter SI.Angle phase[:] = {0} "Phases of sine waves";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(amplitude, 1);size(freqHz, 1);size(phase, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         constant Real pi = Modelica.Constants.pi;
//         parameter Real p_amplitude[nout] = if size(amplitude, 1) == 1 then ones(nout) * amplitude[1] else amplitude;
//         parameter Real p_freqHz[nout] = if size(freqHz, 1) == 1 then ones(nout) * freqHz[1] else freqHz;
//         parameter Real p_phase[nout] = if size(phase, 1) == 1 then ones(nout) * phase[1] else phase;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.08, width = 0.66, height = 0.68), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80,0; -68.7,34.2; -61.5,53.1; -55.1,66.4; -49.4,74.6; -43.8,79.1; -38.2,79.8; -32.6,76.6; -26.9,69.7; -21.3,59.4; -14.9,44.1; -6.83,21.2;10.1, -30.8;17.3, -50.2;23.7, -64.2;29.3, -73.1;35, -78.4;40.6, -80;46.2, -77.6;51.9, -71.5;57.5, -61.9;63.9, -47.2;72, -24.8;80,0], style(color = 0)), Text(extent = [ -147, -152;153, -112], string = "freqHz=%freqHz", style(color = 0))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -40,0; -31.6,34.2; -26.1,53.1; -21.3,66.4; -17.1,74.6; -12.9,79.1; -8.64,79.8; -4.42,76.6; -0.201,69.7;4.02,59.4;8.84,44.1;14.9,21.2;27.5, -30.8;33, -50.2;37.8, -64.2;42, -73.1;46.2, -78.4;50.5, -80;54.7, -77.6;58.9, -71.5;63.1, -61.9;67.9, -47.2;74, -24.8;80,0], style(color = 0, thickness = 2)), Line(points = [ -41, -2; -80, -2], style(color = 0, thickness = 2)), Text(extent = [ -128,7; -82, -11], string = "offset", style(color = 9)), Line(points = [ -41, -2; -41, -40], style(color = 8, pattern = 2)), Text(extent = [ -60, -43; -14, -61], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Text(extent = [ -74,106; -33,86], string = "outPort", style(color = 9)), Line(points = [ -9,79;43,79], style(color = 8, pattern = 2)), Line(points = [ -42, -1;50,0], style(color = 8, pattern = 2)), Polygon(points = [33,80;30,67;37,67;33,80], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [37,57;83,39], string = "amplitude", style(color = 9)), Polygon(points = [33,1;30,14;36,14;33,1;33,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [33,79;33,0], style(color = 8, pattern = 1, thickness = 1, arrow = 0))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else p_amplitude[i] * Modelica.Math.sin(2 * pi * p_freqHz[i] * (time - p_startTime[i]) + p_phase[i]));
// 
//         end for;
//       end Sine;
//       block ExpSine "Generate exponentially damped sine signals"
//         parameter Real amplitude[:] = {1} "Amplitudes of sine waves";
//         parameter SI.Frequency freqHz[:] = {2} "Frequencies of sine waves";
//         parameter SI.Angle phase[:] = {0} "Phases of sine waves";
//         parameter SI.Damping damping[:] = {1} "Damping coefficients of sine waves";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(amplitude, 1);size(freqHz, 1);size(phase, 1);size(damping, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         constant Real pi = Modelica.Constants.pi;
//         parameter Real p_amplitude[nout] = if size(amplitude, 1) == 1 then ones(nout) * amplitude[1] else amplitude;
//         parameter Real p_freqHz[nout] = if size(freqHz, 1) == 1 then ones(nout) * freqHz[1] else freqHz;
//         parameter Real p_phase[nout] = if size(phase, 1) == 1 then ones(nout) * phase[1] else phase;
//         parameter Real p_damping[nout] = if size(damping, 1) == 1 then ones(nout) * damping[1] else damping;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.18, y = 0.05, width = 0.6, height = 0.63), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80,0; -75.2,32.3; -72,50.3; -68.7,64.5; -65.5,74.2; -62.3,79.3; -59.1,79.6; -55.9,75.3; -52.7,67.1; -48.6,52.2; -43,25.8; -35, -13.9; -30.2, -33.7; -26.1, -45.9; -22.1, -53.2; -18.1, -55.3; -14.1, -52.5; -10.1, -45.3; -5.23, -32.1;8.44,13.7;13.3,26.4;18.1,34.8;22.1,38;26.9,37.2;31.8,31.8;38.2,19.4;51.1, -10.5;57.5, -21.2;63.1, -25.9;68.7, -25.9;75.2, -20.5;80, -13.8], style(color = 0)), Text(extent = [ -147, -152;153, -112], string = "freqHz=%freqHz", style(color = 0))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -50,0; -46.1,28.2; -43.5,44; -40.9,56.4; -38.2,64.9; -35.6,69.4; -33,69.6; -30.4,65.9; -27.8,58.7; -24.5,45.7; -19.9,22.5; -13.4, -12.2; -9.5, -29.5; -6.23, -40.1; -2.96, -46.5;0.302, -48.4;3.57, -45.9;6.83, -39.6;10.8, -28.1;21.9,12;25.8,23.1;29.7,30.5;33,33.3;36.9,32.5;40.8,27.8;46,16.9;56.5, -9.2;61.7, -18.6;66.3, -22.7;70.9, -22.6;76.1, -18;80, -12.1], style(color = 0, thickness = 2)), Text(extent = [ -106,10; -83, -10], string = "offset", style(color = 9)), Text(extent = [ -72, -36; -26, -54], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Text(extent = [ -79,104; -39,87], string = "outPort", style(color = 9)), Line(points = [ -50,0;18,0], style(color = 8, pattern = 2)), Line(points = [ -50,0; -81,0], style(color = 0, thickness = 2)), Line(points = [ -50,77; -50,0], style(color = 8, pattern = 2)), Line(points = [18, -1;18,76], style(color = 8, pattern = 2)), Line(points = [18,73; -50,73], style(color = 8)), Text(extent = [ -42,88;9,74], string = "1/freqHz", style(color = 9)), Polygon(points = [ -49,73; -40,75; -40,71; -49,73], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [18,73;10,75;10,71;18,73], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -50, -61; -19, -61], style(color = 8)), Polygon(points = [ -18, -61; -26, -59; -26, -63; -18, -61], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -51, -63; -27, -75], string = "t", style(color = 9)), Text(extent = [ -82, -67;108, -96], string = "amplitude*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", style(color = 9)), Line(points = [ -50,0; -50, -40], style(color = 8, pattern = 2)), Line(points = [ -50, -54; -50, -72], style(color = 8, pattern = 2)), Line(points = [ -15, -77; -1, -48], style(color = 8, pattern = 2))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else p_amplitude[i] * Modelica.Math.exp( -(time - p_startTime[i]) * p_damping[i]) * Modelica.Math.sin(2 * pi * p_freqHz[i] * (time - p_startTime[i]) + p_phase[i]));
// 
//         end for;
//       end ExpSine;
//       block Exponentials "Generate a rising and falling exponential signal"
//         parameter Real outMax[:] = {1} "Height of output for infinite riseTime";
//         parameter SI.Time riseTime[:](min = 0) = {0.5} "Rise time";
//         parameter SI.Time riseTimeConst[:](min = Modelica.Constants.small) = {0.1} "Rise time constant";
//         parameter SI.Time fallTimeConst[:](min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(outMax, 1);size(riseTime, 1);size(riseTimeConst, 1);size(fallTimeConst, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_outMax[nout] = if size(outMax, 1) == 1 then ones(nout) * outMax[1] else outMax;
//         parameter SI.Time p_riseTime[nout] = if size(riseTime, 1) == 1 then ones(nout) * riseTime[1] else riseTime;
//         parameter SI.Time p_riseTimeConst[nout] = if size(riseTimeConst, 1) == 1 then ones(nout) * riseTimeConst[1] else riseTimeConst;
//         parameter SI.Time p_fallTimeConst[nout] = if size(fallTimeConst, 1) == 1 then ones(nout) * fallTimeConst[1] else fallTimeConst;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         Real y_riseTime[nout];
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.03, y = 0.05, width = 0.85, height = 0.74), Icon(Line(points = [ -90, -70;68, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Line(points = [ -80, -70; -77.2, -55.3; -74.3, -42.1; -70.8, -27.6; -67.3, -15; -63.7, -4.08; -59.5,7.18; -55.3,16.7; -50.3,26; -44.6,34.5; -38.3,42.1; -31.2,48.6; -22.7,54.3; -12.1,59.2; -10,60; -7.88,47.5; -5.05,32.7; -2.22,19.8;0.606,8.45;4.14, -3.7;7.68, -14;11.9, -24.2;16.2, -32.6;21.1, -40.5;26.8, -47.4;33.1, -53.3;40.9, -58.5;50.8, -62.8;60, -65.4], style(color = 0)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "riseTime=%riseTime", style(color = 0))), Diagram(Line(points = [ -100, -70;84, -70], style(color = 8)), Polygon(points = [100, -70;84, -64;84, -76;100, -70], style(color = 8, fillColor = 8)), Line(points = [ -40, -30; -37.2, -15.3; -34.3, -2.1; -30.8,12.4; -27.3,25; -23.7,35.92; -19.5,47.18; -15.3,56.7; -10.3,66; -4.6,74.5;1.7,82.1;8.8,88.6;17.3,94.3;27.9,99.2;30,100;32.12,87.5;34.95,72.7;37.78,59.8;40.606,48.45;44.14,36.3;47.68,26;51.9,15.8;56.2,7.4;61.1, -0.5;66.8, -7.4;73.1, -13.3;80.9, -18.5;90.8, -22.8;100, -25.4], style(color = 0, thickness = 2)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Text(extent = [ -70,91; -29,71], string = "outPort", style(color = 9)), Text(extent = [ -78, -43; -46, -56], string = "offset", style(color = 9)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -29; -40, -60], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -30; -42, -40; -37, -40; -40, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -39, -30; -80, -30], style(color = 0, thickness = 2)), Text(extent = [ -59, -71; -13, -89], string = "startTime", style(color = 9)), Polygon(points = [ -41, -30; -32, -28; -32, -32; -41, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -30;29, -30], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [29, -30;21, -28;21, -32;29, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -26, -12;19, -28], string = "riseTime", style(color = 9)), Text(extent = [78, -76;102, -96], string = "time", style(color = 9)), Line(points = [30,100;30, -34], style(color = 8, pattern = 2))));
// 
//       equation 
//         for i in 1:nout loop
//         y_riseTime[i] = p_outMax[i] * (1 - Modelica.Math.exp( -p_riseTime[i] / p_riseTimeConst[i]));
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else if time < p_startTime[i] + p_riseTime[i] then p_outMax[i] * (1 - Modelica.Math.exp( -(time - p_startTime[i]) / p_riseTimeConst[i])) else y_riseTime[i] * Modelica.Math.exp( -(time - p_startTime[i] - p_riseTime[i]) / p_fallTimeConst[i]));
// 
//         end for;
//       end Exponentials;
//       block Pulse "Generate pulse signals of type Real"
//         parameter Real amplitude[:] = {1} "Amplitudes of pulses";
//         parameter Real width[:](final min = Modelica.Constants.small, final max = 100) = {50} "Widths of pulses in % of periods";
//         parameter SI.Time period[:](final min = Modelica.Constants.small) = {1} "Times for one period";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(amplitude, 1);size(width, 1);size(period, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_amplitude[nout] = if size(amplitude, 1) == 1 then ones(nout) * amplitude[1] else amplitude;
//         parameter SI.Time p_period[nout] = if size(period, 1) == 1 then ones(nout) * period[1] else period;
//         parameter SI.Time p_width[nout] = (diagonal(p_period) * (if size(width, 1) == 1 then ones(nout) * width[1] else width)) / 100 "Width of one pulse";
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         SI.Time T0[nout](final start = p_startTime) "Start time of current period";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.29, y = 0.05, width = 0.59, height = 0.72), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -70; -40, -70; -40,44;0,44;0, -70;40, -70;40,44;79,44], style(color = 0)), Text(extent = [ -147, -152;153, -112], string = "period=%period", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37, -12; -30, -12; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -1; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -33, -70; -36, -57; -30, -57; -33, -70; -33, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [ -76,99; -35,79], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10,0; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -80,0; -10,0; -10,50;30,50;30,0;50,0;50,50;90,50], style(color = 0, thickness = 2)), Line(points = [ -10,88; -10,49], style(color = 8, pattern = 2)), Line(points = [30,74;30,50], style(color = 9, pattern = 2)), Line(points = [50,88;50,50], style(color = 8, pattern = 2)), Line(points = [ -10,83;51,83], style(color = 8)), Line(points = [ -10,69;30,69], style(color = 8)), Text(extent = [0,97;46,85], string = "period", style(color = 9)), Text(extent = [ -9,81;30,69], string = "width", style(color = 9)), Line(points = [ -43,50; -10,50], style(color = 8, pattern = 2)), Line(points = [ -34,50; -34,1], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "amplitude", style(color = 9)), Polygon(points = [ -34,49; -37,36; -30,36; -34,49], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37,14; -31,14; -34,1; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [90,50;90,0;100,0], style(color = 0, thickness = 2)), Polygon(points = [ -10,69; -1,71; -1,67; -10,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [30,69;22,71;22,67;30,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,83; -1,85; -1,81; -10,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50,83;42,85;42,81;50,83], style(color = 8, fillColor = 8, fillPattern = 1))));
// 
//       equation 
//         for i in 1:nout loop
//         when sample(p_startTime[i], p_period[i]) then
//                   T0[i] = time;
//         
//         end when;
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] or time >= T0[i] + p_width[i] then 0 else p_amplitude[i]);
// 
//         end for;
//       end Pulse;
//       block SawTooth "Generate saw tooth signals"
//         parameter Real amplitude[:] = {1} "Amplitudes of saw tooths";
//         parameter SI.Time period[:](final min = Modelica.Constants.small) = {1} "Times for one period";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(amplitude, 1);size(period, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_amplitude[nout] = if size(amplitude, 1) == 1 then ones(nout) * amplitude[1] else amplitude;
//         parameter SI.Time p_period[nout] = if size(period, 1) == 1 then ones(nout) * period[1] else period;
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         SI.Time T0[nout](final start = p_startTime) "Start time of current period";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.21, y = 0.11, width = 0.55, height = 0.71), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -70; -60, -70;0,40;0, -70;60,41;60, -70], style(color = 0)), Text(extent = [ -147, -152;153, -112], string = "period=%period", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -19; -37, -32; -30, -32; -34, -19], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -20; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -34, -70; -37, -57; -31, -57; -34, -70; -34, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [ -76,99; -35,79], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10, -20; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -10,88; -10, -20], style(color = 8, pattern = 2)), Line(points = [30,88;30,59], style(color = 8, pattern = 2)), Line(points = [ -10,83;30,83], style(color = 8)), Text(extent = [ -12,97;34,85], string = "period", style(color = 9)), Line(points = [ -44,60;30,60], style(color = 8, pattern = 2)), Line(points = [ -34,47; -34, -7], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "amplitude", style(color = 9)), Polygon(points = [ -34,60; -37,47; -30,47; -34,60], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -20; -37, -7; -31, -7; -34, -20; -34, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,83; -1,85; -1,81; -10,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [30,83;22,85;22,81;30,83], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -20; -10, -20;30,60;30, -20;72,60;72, -20], style(color = 0, thickness = 2))));
// 
//       equation 
//         for i in 1:nout loop
//         when sample(p_startTime[i], p_period[i]) then
//                   T0[i] = time;
//         
//         end when;
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else p_amplitude[i] / p_period[i] * (time - T0[i]));
// 
//         end for;
//       end SawTooth;
//       block Trapezoid "Generate trapezoidal signals of type Real"
//         parameter Real amplitude[:] = {1} "Amplitudes of trapezoids";
//         parameter SI.Time rising[:](final min = 0) = {0} "Rising durations of trapezoids";
//         parameter SI.Time width[:](final min = 0) = {0.5} "Width durations of trapezoids";
//         parameter SI.Time falling[:](final min = 0) = {0} "Falling durations of trapezoids";
//         parameter SI.Time period[:](final min = Modelica.Constants.small) = {1} "Time for one period";
//         parameter Integer nperiod[:] = { -1} "Number of periods (< 0 means infinite number of periods)";
//         parameter Real offset[:] = {0} "Offsets of output signals";
//         parameter SI.Time startTime[:] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = max([size(amplitude, 1);size(rising, 1);size(width, 1);size(falling, 1);size(period, 1);size(nperiod, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Real p_amplitude[nout] = if size(amplitude, 1) == 1 then ones(nout) * amplitude[1] else amplitude;
//         parameter SI.Time T_rising[nout] = if size(rising, 1) == 1 then ones(nout) * rising[1] else rising "End time of rising phase within one period";
//         parameter SI.Time T_width[nout] = T_rising + (if size(width, 1) == 1 then ones(nout) * width[1] else width) "End time of width phase within one period";
//         parameter SI.Time T_falling[nout] = T_width + (if size(falling, 1) == 1 then ones(nout) * falling[1] else falling) "End time of falling phase within one period";
//         parameter SI.Time p_period[nout] = if size(period, 1) == 1 then ones(nout) * period[1] else period "Duration of one period";
//         parameter Real p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         SI.Time T0[nout](final start = p_startTime) "Start time of current period";
//         Integer counter[nout](start = if size(nperiod, 1) == 1 then ones(nout) * nperiod[1] else nperiod) "Period counter";
//         Integer counter2[nout](start = if size(nperiod, 1) == 1 then ones(nout) * nperiod[1] else nperiod);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.35, y = 0, width = 0.49, height = 0.58), Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -147, -152;153, -112], string = "period=%period", style(color = 0)), Line(points = [ -81, -70; -60, -70; -30,40;9,40;39, -70;61, -70;90,40], style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -45, -30; -47, -41; -43, -41; -45, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -45, -31; -45, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -45, -70; -47, -60; -43, -60; -45, -70; -45, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -86, -43; -43, -55], string = "offset", style(color = 9)), Text(extent = [ -47, -69; -1, -87], string = "startTime", style(color = 9)), Text(extent = [ -76,99; -35,79], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -29,82; -30, -70], style(color = 8, pattern = 2)), Line(points = [ -10,59; -10,40], style(color = 8, pattern = 2)), Line(points = [20,59;20,39], style(color = 9, pattern = 2)), Line(points = [40,59;40, -30], style(color = 8, pattern = 2)), Line(points = [ -20,76;61,76], style(color = 8)), Line(points = [ -29,56;40,56], style(color = 8)), Text(extent = [ -2,86;25,77], string = "period", style(color = 9)), Text(extent = [ -8,70;21,60], string = "width", style(color = 9)), Line(points = [ -42,40; -10,40], style(color = 8, pattern = 2)), Line(points = [ -39,40; -39, -19], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -77,14; -40,0], string = "amplitude", style(color = 9)), Polygon(points = [ -29,56; -22,58; -22,54; -29,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,56; -17,58; -17,54; -10,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -29,76; -20,78; -20,74; -29,76], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [61,76;53,78;53,74;61,76], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -30; -30, -30; -10,40;20,40;40, -30;60, -30;80,40;100,40], style(color = 0, thickness = 2)), Polygon(points = [ -39,40; -41,29; -37,29; -39,40], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -39, -29; -41, -19; -37, -19; -39, -29; -39, -29], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [61,84;60, -30], style(color = 8, pattern = 2)), Polygon(points = [39,56;32,58;32,54;39,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;27,58;27,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;13,58;13,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -12,56; -5,58; -5,54; -12,56], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -34,70; -5,60], string = "rising", style(color = 9)), Text(extent = [16,70;45,60], string = "falling", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         when pre(counter2[i]) <> 0 and sample(p_startTime[i], p_period[i]) then
//                   T0[i] = time;
//           counter2[i] = pre(counter[i]);
//           counter[i] = pre(counter[i]) - (if pre(counter[i]) > 0 then 1 else 0);
//         
//         end when;
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] or counter2[i] == 0 or time >= T0[i] + T_falling[i] then 0 else if time < T0[i] + T_rising[i] then ((time - T0[i]) * p_amplitude[i]) / T_rising[i] else if time < T0[i] + T_width[i] then p_amplitude[i] else ((T0[i] + T_falling[i] - time) * p_amplitude[i]) / (T_falling[i] - T_width[i]));
// 
//         end for;
//       end Trapezoid;
//       block KinematicPTP "Move as fast as possible along a distance within given kinematic constraints"
//         parameter Real deltaq[:] = {1} "Distance to move";
//         parameter Real qd_max[:](final min = Modelica.Constants.small) = {1} "Maximum velocities der(q)";
//         parameter Real qdd_max[:](final min = Modelica.Constants.small) = {1} "Maximum accelerations der(qd)";
//         parameter SI.Time startTime = 0 "Time instant at which movement starts";
//         extends Interfaces.MO(final nout = max([size(deltaq, 1);size(qd_max, 1);size(qdd_max, 1)]));
//       protected 
//         parameter Real p_deltaq[nout] = if size(deltaq, 1) == 1 then ones(nout) * deltaq[1] else deltaq;
//         parameter Real p_qd_max[nout] = if size(qd_max, 1) == 1 then ones(nout) * qd_max[1] else qd_max;
//         parameter Real p_qdd_max[nout] = if size(qdd_max, 1) == 1 then ones(nout) * qdd_max[1] else qdd_max;
//         Real sd_max;
//         Real sdd_max;
//         Real sdd;
//         Real aux1[nout];
//         Real aux2[nout];
//         SI.Time Ta1;
//         SI.Time Ta2;
//         SI.Time Tv;
//         SI.Time Te;
//         Boolean noWphase;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.17, y = 0.05, width = 0.69, height = 0.72), Icon(Line(points = [ -80,78; -80, -82], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,88; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90,0;82,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80,0; -70,0; -70,70; -30,70; -30,0;20,0;20, -70;60, -70;60,0;68,0], style(color = 0, thickness = 1)), Text(extent = [2,80;80,20], string = "acc", style(color = 8)), Text(extent = [ -150, -150;150, -110], string = "deltaq=%deltaq", style(color = 0))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 3, gradient = 0, fillColor = 0, fillPattern = 0)), Line(points = [ -80,78; -80, -82], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,88; -80,90], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -90,0;82,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80,0; -70,0; -70,70; -30,70; -30,0;20,0;20, -70;60, -70;60,0;68,0], style(color = 0, thickness = 2)), Text(extent = [ -76,98; -19,83], string = "acceleration", style(color = 8)), Text(extent = [69,24;91,12], string = "time", style(color = 8))), Documentation(info = "<html>
// <p>
// The goal is to move as <b>fast</b> as possible along a distance
// <b>deltaq</b>
// under given <b>kinematical constraints</b>. The distance can be a positional or
// angular range. In robotics such a movement is called <b>PTP</b> (Point-To-Point).
// This source block generates the <b>acceleration</b> qdd of this signal
// as output. After integrating the output two times, the position q is
// obtained. The signal is constructed in such a way that it is not possible
// to move faster, given the <b>maximally</b> allowed <b>velocity</b> qd_max and
// the <b>maximally</b> allowed <b>acceleration</b> qdd_max.
// </p>
// 
// <p>
// If several distances are given (vector deltaq has more than 1 element),
// an acceleration output vector is constructed such that all signals
// are in the same periods in the acceleration, constant velocity
// and deceleration phase. This means that only one of the signals
// is at its limits whereas the others are sychnronized in such a way
// that the end point is reached at the same time instant.
// </p>
// 
// <p>
// This element is useful to generate a reference signal for a controller
// which controls a drive train or in combination with model
// Modelica.Mechanics.Rotational.<b>Accelerate</b> to drive
// a flange according to a given acceleration.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 27, 2001</i>
//        by Bernhard Bachmann.<br>
//        Bug fixed that element is also correct if startTime is not zero.</li>
// 
// <li><i>Nov. 3, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Vectorized and moved from Rotational to Blocks.Sources.</li>
// 
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// 
// </HTML>
// "));
// 
//       equation 
//         for i in 1:nout loop
//         aux1[i] = p_deltaq[i] / p_qd_max[i];
//         aux2[i] = p_deltaq[i] / p_qdd_max[i];
// 
//         end for;
//         sd_max = 1 / max(abs(aux1));
//         sdd_max = 1 / max(abs(aux2));
//         Ta1 = sqrt(1 / sdd_max);
//         Ta2 = sd_max / sdd_max;
//         noWphase = Ta2 >= Ta1;
//         Tv = if noWphase then Ta1 else 1 / sd_max;
//         Te = if noWphase then Ta1 + Ta1 else Tv + Ta2;
//         sdd = if time < startTime then 0 else if noWphase then if time < Ta1 + startTime then sdd_max else if time < Te + startTime then  -sdd_max else 0 else if time < Ta2 + startTime then sdd_max else if time < Tv + startTime then 0 else if time < Te + startTime then  -sdd_max else 0;
//         outPort.signal = p_deltaq * sdd;
//       end KinematicPTP;
//       block TimeTable "Generate a (possibly discontinuous) signal by linear interpolation in a table"
//         parameter Real table[:,2] = [0,0;1,1;2,4] "Table matrix (time = first column)";
//         parameter Real offset[1] = {0} "Offset of output signal";
//         parameter SI.Time startTime[1] = {0} "Output = offset for time < startTime";
//         extends Interfaces.MO(final nout = 1);
//       protected 
//         Real a "Interpolation coefficients a of actual interval (y=a*x+b)";
//         Real b "Interpolation coefficients b of actual interval (y=a*x+b)";
//         Integer last(start = 1) "Last used lower grid index";
//         SI.Time nextEvent(start = 0) "Next event instant";
//         annotation(Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -48,70;2, -50], style(color = 7, fillColor = 8, fillPattern = 1)), Line(points = [ -48, -50; -48,70;52,70;52, -50; -48, -50; -48, -20;52, -20;52,10; -48,10; -48,40;52,40;52,70;2,70;2, -51], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "offset=%offset", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;30, -30], style(color = 7, fillColor = 8, fillPattern = 1)), Line(points = [ -20, -30; -20,90;80,90;80, -30; -20, -30; -20,0;80,0;80,30; -20,30; -20,60;80,60;80,90;30,90;30, -31], style(color = 0)), Text(extent = [ -77, -42; -38, -58], string = "offset", style(color = 9)), Polygon(points = [ -31, -30; -33, -40; -28, -40; -31, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -30, -70; -33, -60; -28, -60; -30, -70; -30, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -31, -31; -31, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Text(extent = [ -38, -70;8, -88], string = "startTime", style(color = 9)), Line(points = [ -20, -30; -80, -30], style(color = 8, pattern = 2)), Text(extent = [ -73,93; -41,78], string = "outPort", style(color = 9)), Text(extent = [66, -81;91, -93], string = "time", style(color = 9)), Text(extent = [ -15,83;24,68], string = "time", style(color = 0)), Text(extent = [33,83;76,67], string = "outPort", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This block generates an output signal by <b>linear interpolation</b> in
// a table. The time points and function values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the data to be interpolated.
// The table interpolation has the following proporties:
// </p>
// 
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the function value is just returned independantly of the
//     actual time instant.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the ordinate value.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// 
// <p>
// Example:
// </p>
// 
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// 
// If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the output y =  2.5,
//     e.g., time = 2.0, the output y =  4.0,
//     e.g., time = 5.0, the output y = 23.0 (i.e. extrapolation).
// </pre>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Corrected interface from
// <pre>
//     parameter Real table[:, :]=[0, 0; 1, 1; 2, 4];
// </pre>
//        to
// <pre>
//     parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4];
// </pre>
//        </li>
// <li><i>Nov. 7, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "));
//         function getInterpolationCoefficients "Determine interpolation coefficients and next time event"
//           input Real table[:,2] "Table for interpolation";
//           input Real offset "y-offset";
//           input Real startTime "time-offset";
//           input Real t "Actual time instant";
//           input Integer last "Last used lower grid index";
//           input Real TimeEps "Relative epsilon to check for identical time instants";
//           output Real a "Interpolation coefficients a (y=a*x + b)";
//           output Real b "Interpolation coefficients b (y=a*x + b)";
//           output Real nextEvent "Next event instant";
//           output Integer next "New lower grid index";
//         protected 
//           Integer columns = 2 "Column to be interpolated";
//           Integer ncol = 2 "Number of columns to be interpolated";
//           Integer nrow = size(table, 1) "Number of table rows";
//           Integer next0;
//           Real tp;
//           Real dt;
//         algorithm 
//           next:=last;
//           nextEvent:=t - TimeEps * abs(t);
//           tp:=t + TimeEps * abs(t) - startTime;
//           if tp < 0.0 then 
//                     nextEvent:=startTime;
//           a:=0;
//           b:=offset;
//           elseif nrow < 2 then
//             a:=0;
//             b:=offset + table[1,columns];
// 
// 
//           else           while (next < nrow and tp >= table[next,1]) loop
//                       next:=next + 1;
// 
//           end while;
//           if next < nrow then 
//                     nextEvent:=startTime + table[next,1];
// 
//           else 
//           end if;
//           next0:=next - 1;
//           dt:=table[next,1] - table[next0,1];
//           if dt <= TimeEps * abs(table[next,1]) then 
//                     a:=0;
//           b:=offset + table[next,columns];
// 
//           else           a:=(table[next,columns] - table[next0,columns]) / dt;
//           b:=offset + table[next0,columns] - a * table[next0,1];
// 
//           end if;
// 
//           end if;
//           b:=b - a * startTime;
//         end getInterpolationCoefficients;
//       algorithm 
//         when {time >= pre(nextEvent),initial()} then
//                   (a,b,nextEvent,last):=getInterpolationCoefficients(table, scalar(offset), scalar(startTime), time, last, 100 * Modelica.Constants.eps);
//         
//         end when;
// 
//       equation 
//         outPort.signal[1] = a * time + b;
//       end TimeTable;
//       block BooleanConstant "Generate constant signals of type Boolean"
//         parameter Boolean k[:] = {true} "Constant output values";
//         extends Interfaces.BooleanSignalSource(final nout = size(k, 1));
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.29, y = 0.23, width = 0.6, height = 0.6), Icon(Line(points = [ -80,0;80,0], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80,0;80,0], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [ -75,94; -22,76], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -83,20; -63,0], string = "k", style(color = 9)), Text(extent = [ -100,6; -80, -6], string = "true", style(color = 9)), Text(extent = [ -104, -58; -78, -70], string = "false", style(color = 9))));
// 
//       equation 
//         outPort.signal = k;
//       end BooleanConstant;
//       block BooleanStep "Generate step signals of type Boolean"
//         parameter SI.Time startTime[:] = {0} "Time instants of steps";
//         parameter Boolean startValue[size(startTime, 1)] = fill(false, size(startTime, 1)) "Output before startTime";
//         extends Interfaces.BooleanSignalSource(final nout = size(startTime, 1));
//         annotation(Icon(Line(points = [ -80, -70;0, -70;0,50;80,50], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "startTime=%startTime", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -70;0, -70;0,50;80,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -23, -74;23, -92], string = "startTime", style(color = 9)), Polygon(points = [2,50; -80,50;2,50], style(color = 8, pattern = 2)), Text(extent = [ -72,100; -31,80], string = "outPort", style(color = 9)), Text(extent = [ -124,58; -80,44], string = "not startValue", style(color = 9)), Text(extent = [ -112, -62; -80, -76], string = "startValue", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = if time >= startTime[i] then not startValue[i] else startValue[i];
// 
//         end for;
//       end BooleanStep;
//       block BooleanPulse "Generate pulse signals of type Boolean"
//         parameter Real width[:](final min = Modelica.Constants.small, final max = 100) = {50} "Widths of pulses in % of period";
//         parameter SI.Time period[:](final min = Modelica.Constants.small) = {1} "Times for one period";
//         parameter SI.Time startTime[:] = {0} "Iime instants of first pulse";
//         extends Interfaces.BooleanSignalSource(final nout = max([size(width, 1);size(period, 1);size(startTime, 1)]));
//       protected 
//         parameter SI.Time p_period[nout] = if size(period, 1) == 1 then ones(nout) * period[1] else period;
//         parameter SI.Time Twidth[nout] = (diagonal(p_period) * (if size(width, 1) == 1 then ones(nout) * width[1] else width)) / 100 "width of one pulse";
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         SI.Time T0[nout](final start = p_startTime) "Start time of current period";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.32, y = 0.08, width = 0.6, height = 0.6), Icon(Text(extent = [ -150, -150;150, -110], string = "period=%period", style(color = 0)), Line(points = [ -80, -70; -40, -70; -40,44;0,44;0, -70;40, -70;40,44;79,44], style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -60, -72; -14, -90], string = "startTime", style(color = 9)), Text(extent = [ -76,99; -35,79], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -78, -70; -40, -70; -40,20;20,20;20, -70;50, -70;50,20;100,20], style(color = 0, thickness = 2)), Line(points = [ -40,61; -40,21], style(color = 8, pattern = 2)), Line(points = [20,44;20,20], style(color = 9, pattern = 2)), Line(points = [50,58;50,20], style(color = 8, pattern = 2)), Line(points = [ -40,53;50,53], style(color = 8)), Line(points = [ -40,35;20,35], style(color = 8)), Text(extent = [ -30,67;16,55], string = "period", style(color = 9)), Text(extent = [ -35,49;14,37], string = "width", style(color = 9)), Line(points = [ -80,20; -41,20], style(color = 8, pattern = 2)), Polygon(points = [ -40,35; -31,37; -31,33; -40,35], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,35;12,37;12,33;20,35], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -40,53; -31,55; -31,51; -40,53], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50,53;42,55;42,51;50,53], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -109,28; -77,14], string = "true", style(color = 9)), Text(extent = [ -101, -56; -80, -71], string = "false", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         when sample(p_startTime[i], p_period[i]) then
//                   T0[i] = time;
//         
//         end when;
//         outPort.signal[i] = time >= T0[i] and time < T0[i] + Twidth[i];
// 
//         end for;
//       end BooleanPulse;
//       block SampleTrigger "Generate sample trigger signals"
//         parameter SI.Time period[:](final min = Modelica.Constants.small) = {0.01} "Sample periods";
//         parameter SI.Time startTime[:] = {0} "Time instants of first sample triggers";
//         extends Interfaces.BooleanSignalSource(final nout = max([size(period, 1);size(startTime, 1)]));
//       protected 
//         parameter SI.Time p_period[nout] = if size(period, 1) == 1 then ones(nout) * period[1] else period;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.22, y = 0.02, width = 0.58, height = 0.8), Icon(Line(points = [ -60, -70; -60,70], style(color = 0)), Line(points = [ -20, -70; -20,70], style(color = 0)), Line(points = [20, -70;20,70], style(color = 0)), Line(points = [60, -70;60,70], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "period=%period", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -53, -71; -7, -89], string = "startTime", style(color = 9)), Text(extent = [ -76,99; -35,79], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -30,47; -30,19], style(color = 8, pattern = 2)), Line(points = [0,47;0,18], style(color = 8, pattern = 2)), Line(points = [ -30,41;0,41], style(color = 8)), Text(extent = [ -37,61;9,49], string = "period", style(color = 9)), Line(points = [ -80,19; -30,19], style(color = 8, pattern = 2)), Polygon(points = [ -30,41; -21,43; -21,39; -30,41], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [0,41; -8,43; -8,39;0,41], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -100,28; -80,13], string = "true", style(color = 9)), Text(extent = [ -100, -56; -80, -71], string = "false", style(color = 9)), Line(points = [0, -70;0,19], style(color = 0, thickness = 2)), Line(points = [ -30, -70; -30,19], style(color = 0, thickness = 2)), Line(points = [30, -70;30,19], style(color = 0, thickness = 2)), Line(points = [60, -70;60,19], style(color = 0, thickness = 2))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = sample(p_startTime[i], p_period[i]);
// 
//         end for;
//       end SampleTrigger;
//       block IntegerConstant "Generate constant signals of type Integer"
//         parameter Integer k[:] = {1} "Constant output values";
//         extends Interfaces.IntegerMO(final nout = size(k, 1));
//         annotation(Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Line(points = [ -80,0;80,0], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "k=%k", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80,0;80,0], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [ -75,94; -22,76], string = "outPort", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -101,8; -81, -12], string = "k", style(color = 9))));
// 
//       equation 
//         outPort.signal = k;
//       end IntegerConstant;
//       block IntegerStep "Generate step signals of type Integer"
//         parameter Integer height[:] = {1} "Heights of steps";
//         extends Interfaces.IntegerSignalSource(final nout = max([size(height, 1);size(offset, 1);size(startTime, 1)]));
//       protected 
//         parameter Integer p_height[nout] = if size(height, 1) == 1 then ones(nout) * height[1] else height;
//         parameter Integer p_offset[nout] = if size(offset, 1) == 1 then ones(nout) * offset[1] else offset;
//         parameter SI.Time p_startTime[nout] = if size(startTime, 1) == 1 then ones(nout) * startTime[1] else startTime;
//         annotation(Icon(Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Line(points = [ -80, -70;0, -70;0,50;80,50], style(color = 0)), Text(extent = [ -150, -150;150, -110], string = "startTime=%startTime", style(color = 0))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -18;0, -18;0,50;80,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -21, -72;25, -90], string = "startTime", style(color = 9)), Line(points = [0, -17;0, -71], style(color = 8, pattern = 2)), Text(extent = [ -68, -36; -22, -54], string = "offset", style(color = 9)), Line(points = [ -13,50; -13, -17], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [2,50; -19,50;2,50], style(color = 8, pattern = 2)), Polygon(points = [ -13, -17; -16, -4; -10, -4; -13, -17; -13, -17], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -13,50; -16,37; -9,37; -13,50], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -68,26; -22,8], string = "height", style(color = 9)), Polygon(points = [ -13, -69; -16, -56; -10, -56; -13, -69; -13, -69], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -13, -18; -13, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -13, -18; -16, -31; -9, -31; -13, -18], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -72,100; -31,80], string = "outPort", style(color = 9))));
// 
//       equation 
//         for i in 1:nout loop
//         outPort.signal[i] = p_offset[i] + (if time < p_startTime[i] then 0 else p_height[i]);
// 
//         end for;
//       end IntegerStep;
//     end Sources;
//   end Blocks;
//   package Electrical "Library for electrical models"
//     extends Modelica.Icons.Library2;
//     annotation(Documentation(info = "<html>
// <p>
// This library contains electrical components to build up analog and digital circuits.
// The library is currently structured in the following sublibraries:
// </p>
// <ul>
// <li>Analog</li>
// <li>MultiPhase</li>
// <li>Digital (not available yet)</li>
// </ul>
// 
// </HTML>
// "), Window(x = 0.03, y = 0.03, width = 0.13, height = 0.29, library = 1, autolayout = 1), Icon(Rectangle(extent = [ -29, -13;3, -27], style(color = 0)), Line(points = [37, -58;62, -58], style(color = 0)), Line(points = [36, -49;61, -49], style(color = 0)), Line(points = [ -78, -50; -43, -50], style(color = 0)), Line(points = [ -67, -55; -55, -55], style(color = 0)), Line(points = [ -61, -50; -61, -20; -29, -20], style(color = 0)), Line(points = [3, -20;48, -20;48, -49], style(color = 0)), Line(points = [48, -58;48, -78; -61, -78; -61, -55], style(color = 0))));
//     package Analog "Library for analog electrical models"
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(Window(x = 0.05, y = 0.06, width = 0.16, height = 0.58, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains packages for analog electrical components:
// <ul>
// <li>Basic: basic components (resistor, capacitor, conductor, inductor, transformer, gyrator)</li>
// <li>Semiconductors: semiconductor devices (diode, bipolar and MOS transistors)</li>
// <li>Lines: transmission lines (lossy and lossless)</li>
// <li>Ideal: ideal elements (switches, diode, transformer, idle, short, ...)</li>
// <li>Sources: time-dependend and controlled voltage and current sources</li>
// <li>Sensors: sensors to measure potential, voltage, and current</li>
// </ul>
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: package.mo,v 1.11 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//       package Examples "Examples for analog electrical packages"
//         extends Modelica.Icons.Library2;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.49, height = 0.5, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains examples for the analog electrical package.
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: package.mo,v 1.10 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         package Utilities "Utilities for examples"
//           extends Modelica.Icons.Library2;
//           annotation(Window(x = 0.09, y = 0.15, width = 0.26, height = 0.44, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains utilities ...
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: package.mo,v 1.9 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//           model Nand "CMOS NAND Gate (see Tietze/Schenk, page 157)"
//             annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -50,70;50, -70], style(color = 0, fillColor = 8)), Ellipse(extent = [50,5;60, -5], style(color = 0, pattern = 0)), Text(extent = [ -16,50;14,20], string = "&", style(color = 0)), Line(points = [60,0;100,0]), Line(points = [0,70;0,100]), Line(points = [ -50,50; -100,50]), Line(points = [ -50, -50; -100, -50]), Ellipse(extent = [50,5;60, -5], style(color = 0)), Text(extent = [ -100,34; -90,24], string = "x1"), Text(extent = [ -100, -65; -90, -75], string = "x2"), Text(extent = [90, -15;100, -25], string = "y")), Documentation(info = "<html>
// <p>
// The nand gate is a basic CMOS building block. It consists of four CMOS transistors.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 157
// <p>
// 
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Nand.mo,v 1.7 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "), Window(x = 0.28, y = 0.08, width = 0.6, height = 0.6), Diagram);
//             Semiconductors.PMOS TP1(W = 6.5e-06, L = 3.1e-06, Beta = 1.05e-05, Vt =  -1, K2 = 0.41, K5 = 0.8385, dW =  -2.5e-06, dL =  -2.1e-06) annotation(extent = [10,60;30,80]);
//             Semiconductors.PMOS TP2(W = 6.5e-06, L = 3.1e-06, Beta = 1.05e-05, Vt =  -1, K2 = 0.41, K5 = 0.8385, dW =  -2.5e-06, dL =  -2.1e-06) annotation(extent = [ -40,45; -20,65]);
//             Semiconductors.NMOS TN1(W = 6.5e-06, L = 3.1e-06, Beta = 4.1e-05, Vt = 0.8, K2 = 1.144, K5 = 0.7311, dW =  -2.5e-06, dL =  -1.5e-06) annotation(extent = [10,15;30,35]);
//             Semiconductors.NMOS TN2(W = 6.5e-06, L = 3.1e-06, Beta = 4.1e-05, Vt = 0.8, K2 = 1.144, K5 = 0.7311, dW =  -2.5e-06, dL =  -1.5e-06) annotation(extent = [10, -25;30, -5]);
//             Basic.Capacitor C4(C = 4e-14) annotation(extent = [50,20;70,40], rotation =  -90);
//             Basic.Capacitor C7(C = 4e-14) annotation(extent = [45, -60;65, -40], rotation =  -90);
//             Basic.Ground Gnd annotation(extent = [40, -25;50, -15]);
//             Basic.Ground Gnd2 annotation(extent = [55,0;65,10]);
//             Basic.Ground Gnd3 annotation(extent = [50, -80;60, -70]);
//             Basic.Ground Gnd6 annotation(extent = [ -15,30; -5,40]);
//             Basic.Ground Gnd7 annotation(extent = [40,15;50,25]);
//             Basic.Ground Gnd8 annotation(extent = [40,60;50,70]);
//             Interfaces.Pin x1 annotation(extent = [ -110,40; -90,60]);
//             Interfaces.Pin x2 annotation(extent = [ -110, -60; -90, -40]);
//             Interfaces.Pin Vdd annotation(extent = [ -10,90;10,110]);
//             Interfaces.Pin y annotation(extent = [90, -10;110,10]);
// 
//           equation 
//             connect(TN1.S,TN2.D) annotation(points = [30,20;30, -10]);
//             connect(TN2.B,Gnd.p) annotation(points = [30, -15;38, -15;38, -15;45, -15]);
//             connect(TN2.D,C7.p) annotation(points = [30, -10;55, -10;55, -40]);
//             connect(TN2.S,Gnd.p) annotation(points = [30, -20;38, -20;38, -15;45, -15]);
//             connect(TP1.S,TN1.D) annotation(points = [30,65;30,30]);
//             connect(TP1.G,TN1.G) annotation(points = [10,65;10,20]);
//             connect(C4.n,Gnd2.p) annotation(points = [60,20;60,10]);
//             connect(C7.n,Gnd3.p) annotation(points = [55, -60;55, -70]);
//             connect(TP2.B,Gnd6.p) annotation(points = [ -20,55; -10,55; -10,40]);
//             connect(TN1.B,Gnd7.p) annotation(points = [30,25;45,25]);
//             connect(TP1.B,Gnd8.p) annotation(points = [30,70;45,70]);
//             connect(TP2.G,x1) annotation(points = [ -40,50; -100,50]);
//             connect(TP2.G,TN2.G) annotation(points = [ -40,50; -40, -20;10, -20]);
//             connect(TN1.G,x2) annotation(points = [10,20; -70,20; -70, -50; -100, -50]);
//             connect(TP2.S,TN1.D) annotation(points = [ -20,50;30,50;30,30]);
//             connect(TN1.D,C4.p) annotation(points = [30,30;30,50;60,50;60,40]);
//             connect(Vdd,TP1.D) annotation(points = [0,100;0,80;30,80;30,75]);
//             connect(TP2.D,Vdd) annotation(points = [ -20,60; -20,80;0,80;0,100]);
//             connect(C4.p,y) annotation(points = [60,40;60,50;80,50;80,0;100,0]);
//           end Nand;
//           model NonlinearResistor "Chua's resistor"
//             extends Interfaces.OnePort;
//             annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.4, y = 0.4, width = 0.6, height = 0.6), Icon(Rectangle(extent = [ -70,30;70, -30]), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Line(points = [ -50, -60;50,60]), Polygon(points = [50,60;38,52;44,46;50,60], style(fillColor = 3, fillPattern = 1))), Diagram(Rectangle(extent = [ -70,30;70, -30]), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Line(points = [ -50, -60;50,60]), Polygon(points = [50,60;38,52;44,46;50,60], style(fillColor = 3, fillPattern = 1)), Text(extent = [ -100,100;100,70], string = "%name")));
//             parameter SI.Conductance Ga;
//             parameter SI.Conductance Gb;
//             parameter SI.Voltage Ve;
// 
//           equation 
//             i = if v <  -Ve then Gb * (v + Ve) - Ga * Ve else if v > Ve then Gb * (v - Ve) + Ga * Ve else Ga * v;
//           end NonlinearResistor;
//           model RealSwitch
//             Ideal.ControlledIdealCommutingSwitch S(level = 2.5) annotation(extent = [11.3333,18;58,64.6667]);
//             Basic.Resistor R(R = 0.01) annotation(extent = [ -66,16; -19.3333,62.6667]);
//             Interfaces.Pin p annotation(extent = [ -110,30; -90,50]);
//             Interfaces.Pin n1 annotation(extent = [90,50;110,70]);
//             Interfaces.Pin n2 annotation(extent = [90,4;110,24]);
//             Interfaces.Pin control annotation(extent = [24,90;44,110]);
// 
//           equation 
//             connect(p,R.p) annotation(points = [ -100,40; -66,39.3333]);
//             connect(R.n,S.p) annotation(points = [ -19.3333,39.3333;11.3333,41.3333]);
//             connect(n1,S.n1) annotation(points = [100,60;58,53]);
//             connect(n2,S.n2) annotation(points = [100,14;58,41.3333]);
//             connect(control,S.control) annotation(points = [34,100;34.6667,64.6667]);
//             annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.4, y = 0.4, width = 0.6, height = 0.6));
//           end RealSwitch;
//           model Transistor
//             annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Rectangle(extent = [ -80,80;80, -80]), Line(points = [80,60;100,60]), Line(points = [80, -60;100, -60]), Line(points = [ -100,0; -80,0]), Line(points = [ -60,0; -10,0]), Line(points = [ -10,40; -10, -40]), Line(points = [60,60;40,60; -10,10]), Line(points = [ -10, -10;40, -60;60, -60])), Window(x = 0.25, y = 0.24, width = 0.6, height = 0.6));
//             Basic.Resistor rtb(R = 0.05) annotation(extent = [ -80, -10; -60,10]);
//             Basic.Resistor rtc(R = 0.1) annotation(extent = [40,0;60,20]);
//             Basic.Capacitor ct(C = 1e-10) annotation(extent = [ -50, -40; -30, -20], rotation =  -90);
//             Semiconductors.NPN Tr(Bf = 50, Br = 0.1, Is = 1e-16, Vak = 0.02, Tauf = 1.2e-10, Taur = 5e-09, Ccs = 1e-12, Cje = 4e-13, Cjc = 5e-13, Phie = 0.8, Me = 0.4, Phic = 0.8, Mc = 0.333, Gbc = 1e-15, Gbe = 1e-15, Vt = 0.02585) annotation(extent = [ -20, -20;20,20]);
//             Basic.Ground Ground1 annotation(extent = [ -50, -80; -30, -60]);
//             Interfaces.Pin c annotation(extent = [90,50;110,70]);
//             Interfaces.Pin b annotation(extent = [ -110, -10; -90,10]);
//             Interfaces.Pin e annotation(extent = [90, -70;110, -50]);
// 
//           equation 
//             connect(rtb.n,Tr.B) annotation(points = [ -60,0; -20,0]);
//             connect(rtb.n,ct.p) annotation(points = [ -60,0; -40,0; -40, -20]);
//             connect(ct.n,Ground1.p) annotation(points = [ -40, -40; -40, -60]);
//             connect(Tr.C,rtc.p) annotation(points = [20,10;40,10]);
//             connect(rtc.n,c) annotation(points = [60,10;80,10;80,60;100,60]);
//             connect(b,rtb.p) annotation(points = [ -100,0; -80,0]);
//             connect(Tr.E,e) annotation(points = [20, -10;80, -10;80, -60;100, -60]);
//           end Transistor;
//         end Utilities;
//         encapsulated model CauerFilter "CAUER Switched Capacitor Filter"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Sources;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Icon, Documentation(info = "<html>
// <p>
// The example Cauer Filter is a low-pass-filter of the fifth order. It is realized
// using a switched-capacitor network. The voltage source V is the input voltage,
// and the Op5.p2.v is the filter output voltage. The pulse response is calculated.
// <p>
// The simulation end time should be 2e5. Please plot the output voltage Op5.p2.v.
// <p>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: CauerFilter.mo,v 1.8 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "), Window(x = 0.11, y = 0.1, width = 0.6, height = 0.6));
//           Sources.TrapezoidVoltage V(V = 1, startTime = 499, rising = 1, width = 1500, falling = 1, period = 50000, nperiod = 1) annotation(extent = [ -95.7143,75.7143; -75.7143,95.7143]);
//           Sources.TrapezoidVoltage Clk(V = 5, rising = 5, width = 500, falling = 5, period = 1000) annotation(extent = [ -67.1429,75.7143; -47.1429,95.7143]);
//           Basic.Capacitor C1(C = 1) annotation(extent = [ -38.5714,75.7143; -18.5714,95.7143]);
//           Basic.Capacitor C2(C = 1.55) annotation(extent = [ -10,75.7143;10,95.7143]);
//           Basic.Capacitor C3(C = 1.527) annotation(extent = [18.5714,75.7143;38.5714,95.7143]);
//           Basic.Capacitor C4(C = 1) annotation(extent = [47.1429,75.7143;67.1429,95.7143]);
//           Basic.Capacitor C5(C = 1) annotation(extent = [75.7143,75.7143;95.7143,95.7143]);
//           Basic.Capacitor C6(C = 1.018) annotation(extent = [ -95.7143,47.1429; -75.7143,67.1429]);
//           Basic.Capacitor C7(C = 1) annotation(extent = [ -67.1429,47.1429; -47.1429,67.1429]);
//           Basic.Capacitor C8(C = 1.644) annotation(extent = [ -38.5714,47.1429; -18.5714,67.1429]);
//           Basic.Capacitor C9(C = 2) annotation(extent = [ -10,47.1429;10,67.1429]);
//           Basic.Capacitor C10(C = 1) annotation(extent = [18.5714,47.1429;38.5714,67.1429]);
//           Basic.Capacitor C11(C = 2) annotation(extent = [47.1429,47.1429;67.1429,67.1429]);
//           Basic.Capacitor C12(C = 1) annotation(extent = [75.7143,47.1429;95.7143,67.1429]);
//           Basic.Capacitor C13(C = 9.862) annotation(extent = [ -95.7143,18.5714; -75.7143,38.5714]);
//           Basic.Capacitor C14(C = 7.23) annotation(extent = [ -67.1429,18.5714; -47.1429,38.5714]);
//           Basic.Capacitor C15(C = 10.06) annotation(extent = [ -38.5714,18.5714; -18.5714,38.5714]);
//           Basic.Capacitor C16(C = 10.23) annotation(extent = [ -10,18.5714;10,38.5714]);
//           Basic.Capacitor C17(C = 12.76) annotation(extent = [18.5714,18.5714;38.5714,38.5714]);
//           Basic.Capacitor C18(C = 8.676) annotation(extent = [47.1429,18.5714;67.1429,38.5714]);
//           Utilities.RealSwitch S1 annotation(extent = [75.7143,18.5714;95.7143,38.5714]);
//           Utilities.RealSwitch S2 annotation(extent = [ -95.7143, -10; -75.7143,10]);
//           Utilities.RealSwitch S3 annotation(extent = [ -67.1429, -10; -47.1429,10]);
//           Utilities.RealSwitch S4 annotation(extent = [ -38.5714, -10; -18.5714,10]);
//           Utilities.RealSwitch S5 annotation(extent = [ -10, -10;10,10]);
//           Utilities.RealSwitch S6 annotation(extent = [18.5714, -10;38.5714,10]);
//           Utilities.RealSwitch S7 annotation(extent = [47.1429, -10;67.1429,10]);
//           Utilities.RealSwitch S8 annotation(extent = [75.7143, -10;95.7143,10]);
//           Utilities.RealSwitch S9 annotation(extent = [ -95.7143, -38.5714; -75.7143, -18.5714]);
//           Utilities.RealSwitch S10 annotation(extent = [ -67.1429, -38.5714; -47.1429, -18.5714]);
//           Utilities.RealSwitch S11 annotation(extent = [ -38.5714, -38.5714; -18.5714, -18.5714]);
//           Utilities.RealSwitch S12 annotation(extent = [ -10, -38.5714;10, -18.5714]);
//           Utilities.RealSwitch S13 annotation(extent = [18.5714, -38.5714;38.5714, -18.5714]);
//           Utilities.RealSwitch S14 annotation(extent = [47.1429, -38.5714;67.1429, -18.5714]);
//           Utilities.RealSwitch S15 annotation(extent = [75.7143, -38.5714;95.7143, -18.5714]);
//           Utilities.RealSwitch S16 annotation(extent = [ -95.7143, -67.1429; -75.7143, -47.1429]);
//           Utilities.RealSwitch S17 annotation(extent = [ -67.1429, -67.1429; -47.1429, -47.1429]);
//           Utilities.RealSwitch S18 annotation(extent = [ -38.5714, -67.1429; -18.5714, -47.1429]);
//           Basic.VCV Op1(gain = 30000) annotation(extent = [ -10, -67.1429;10, -47.1429]);
//           Basic.VCV Op2(gain = 30000) annotation(extent = [18.5714, -67.1429;38.5714, -47.1429]);
//           Basic.VCV Op3(gain = 30000) annotation(extent = [47.1429, -67.1429;67.1429, -47.1429]);
//           Basic.VCV Op4(gain = 30000) annotation(extent = [75.7143, -67.1429;95.7143, -47.1429]);
//           Basic.VCV Op5(gain = 30000) annotation(extent = [ -95.7143, -95.7143; -75.7143, -75.7143]);
//           Basic.Ground G annotation(extent = [ -67.1429, -95.7143; -47.1429, -75.7143]);
//           Basic.Ground M annotation(extent = [ -38.5714, -95.7143; -18.5714, -75.7143]);
// 
//         equation 
//           connect(S1.n1,V.p) annotation(points = [95.7143,34.5714; -95.7143,85.7143]);
//           connect(C8.p,C18.n) annotation(points = [ -38.5714,57.1429;67.1429,28.5714]);
//           connect(C8.p,S11.n1) annotation(points = [ -38.5714,57.1429; -18.5714, -22.5714]);
//           connect(C8.p,S17.n1) annotation(points = [ -38.5714,57.1429; -47.1429, -51.1429]);
//           connect(C8.p,Op5.p2) annotation(points = [ -38.5714,57.1429; -75.7143, -80.7143]);
//           connect(C2.p,C13.p) annotation(points = [ -10,85.7143; -95.7143,28.5714]);
//           connect(C2.p,C16.n) annotation(points = [ -10,85.7143;10,28.5714]);
//           connect(C2.p,S7.n1) annotation(points = [ -10,85.7143;67.1429,6]);
//           connect(C2.p,S13.n1) annotation(points = [ -10,85.7143;38.5714, -22.5714]);
//           connect(C2.p,Op3.p2) annotation(points = [ -10,85.7143;67.1429, -52.1429]);
//           connect(C6.p,C14.n) annotation(points = [ -95.7143,57.1429; -47.1429,28.5714]);
//           connect(C6.p,S1.n2) annotation(points = [ -95.7143,57.1429;95.7143,29.9714]);
//           connect(C6.p,S5.n1) annotation(points = [ -95.7143,57.1429;10,6]);
//           connect(C6.p,Op1.p2) annotation(points = [ -95.7143,57.1429;10, -52.1429]);
//           connect(C15.n,S9.n2) annotation(points = [ -18.5714,28.5714; -75.7143, -27.1714]);
//           connect(C15.n,S3.n1) annotation(points = [ -18.5714,28.5714; -47.1429,6]);
//           connect(C15.n,Op2.p2) annotation(points = [ -18.5714,28.5714;38.5714, -52.1429]);
//           connect(C14.p,C2.n) annotation(points = [ -67.1429,28.5714;10,85.7143]);
//           connect(C14.p,S2.n2) annotation(points = [ -67.1429,28.5714; -75.7143,1.4]);
//           connect(C14.p,S4.n1) annotation(points = [ -67.1429,28.5714; -18.5714,6]);
//           connect(C14.p,Op1.n1) annotation(points = [ -67.1429,28.5714; -10, -62.1429]);
//           connect(C15.p,S6.n2) annotation(points = [ -38.5714,28.5714;38.5714,1.4]);
//           connect(C15.p,S8.n2) annotation(points = [ -38.5714,28.5714;95.7143,1.4]);
//           connect(C15.p,Op2.n1) annotation(points = [ -38.5714,28.5714;18.5714, -62.1429]);
//           connect(C16.p,C6.n) annotation(points = [ -10,28.5714; -75.7143,57.1429]);
//           connect(C16.p,C8.n) annotation(points = [ -10,28.5714; -18.5714,57.1429]);
//           connect(C16.p,S10.n2) annotation(points = [ -10,28.5714; -47.1429, -27.1714]);
//           connect(C16.p,Op3.n1) annotation(points = [ -10,28.5714;47.1429, -62.1429]);
//           connect(C17.p,S12.n1) annotation(points = [18.5714,28.5714;10, -22.5714]);
//           connect(C17.p,S14.n1) annotation(points = [18.5714,28.5714;67.1429, -22.5714]);
//           connect(C17.p,Op4.n1) annotation(points = [18.5714,28.5714;75.7143, -62.1429]);
//           connect(C18.p,C13.n) annotation(points = [47.1429,28.5714;16.4286,28.5714;16.4286,28.5714; -14.2857,28.5714; -14.2857,28.5714; -75.7143,28.5714]);
//           connect(C18.p,S16.n1) annotation(points = [47.1429,28.5714; -75.7143, -51.1429]);
//           connect(C18.p,S18.n1) annotation(points = [47.1429,28.5714; -18.5714, -51.1429]);
//           connect(C18.p,Op5.n1) annotation(points = [47.1429,28.5714; -95.7143, -90.7143]);
//           connect(C17.n,S15.n2) annotation(points = [38.5714,28.5714;95.7143, -27.1714]);
//           connect(C17.n,S17.n2) annotation(points = [38.5714,28.5714; -47.1429, -55.7429]);
//           connect(C17.n,S9.n1) annotation(points = [38.5714,28.5714; -75.7143, -22.5714]);
//           connect(C17.n,Op4.p2) annotation(points = [38.5714,28.5714;95.7143, -52.1429]);
//           connect(C1.n,S2.p) annotation(points = [ -18.5714,85.7143; -95.7143,4]);
//           connect(C3.p,S3.p) annotation(points = [18.5714,85.7143; -67.1429,4]);
//           connect(C3.n,S4.p) annotation(points = [38.5714,85.7143; -38.5714,4]);
//           connect(C4.p,S5.p) annotation(points = [47.1429,85.7143; -10,4]);
//           connect(C4.n,S6.p) annotation(points = [67.1429,85.7143;18.5714,4]);
//           connect(C5.p,S7.p) annotation(points = [75.7143,85.7143;47.1429,4]);
//           connect(C5.n,S8.p) annotation(points = [95.7143,85.7143;75.7143,4]);
//           connect(C7.p,S9.p) annotation(points = [ -67.1429,57.1429; -95.7143, -24.5714]);
//           connect(C7.n,S10.p) annotation(points = [ -47.1429,57.1429; -67.1429, -24.5714]);
//           connect(C9.p,S11.p) annotation(points = [ -10,57.1429; -38.5714, -24.5714]);
//           connect(C9.n,S12.p) annotation(points = [10,57.1429; -10, -24.5714]);
//           connect(C10.p,S13.p) annotation(points = [18.5714,57.1429;18.5714,36.7143;18.5714,36.7143;18.5714,16.2858;18.5714, -24.5714;18.5714, -24.5714]);
//           connect(C10.n,S14.p) annotation(points = [38.5714,57.1429;47.1429, -24.5714]);
//           connect(C11.p,S15.p) annotation(points = [47.1429,57.1429;75.7143, -24.5714]);
//           connect(C11.n,S16.p) annotation(points = [67.1429,57.1429; -95.7143, -53.1429]);
//           connect(C12.p,S17.p) annotation(points = [75.7143,57.1429; -67.1429, -53.1429]);
//           connect(C12.n,S18.p) annotation(points = [95.7143,57.1429; -38.5714, -53.1429]);
//           connect(C1.p,S1.p) annotation(points = [ -38.5714,85.7143;75.7143,32.5714]);
//           connect(S1.control,Clk.p) annotation(points = [89.1143,38.5714; -67.1429,85.7143]);
//           connect(S2.control,Clk.p) annotation(points = [ -82.3143,10; -67.1429,85.7143]);
//           connect(S3.control,Clk.p) annotation(points = [ -53.7429,10; -67.1429,85.7143]);
//           connect(S4.control,Clk.p) annotation(points = [ -25.1714,10; -67.1429,85.7143]);
//           connect(S5.control,Clk.p) annotation(points = [3.4,10; -67.1429,85.7143]);
//           connect(S6.control,Clk.p) annotation(points = [31.9714,10; -67.1429,85.7143]);
//           connect(S7.control,Clk.p) annotation(points = [60.5429,10; -67.1429,85.7143]);
//           connect(S8.control,Clk.p) annotation(points = [89.1143,10; -67.1429,85.7143]);
//           connect(S9.control,Clk.p) annotation(points = [ -82.3143, -18.5714; -67.1429,85.7143]);
//           connect(S10.control,Clk.p) annotation(points = [ -53.7429, -18.5714; -67.1429,85.7143]);
//           connect(S11.control,Clk.p) annotation(points = [ -25.1714, -18.5714; -67.1429,85.7143]);
//           connect(S12.control,Clk.p) annotation(points = [3.4, -18.5714; -67.1429,85.7143]);
//           connect(S13.control,Clk.p) annotation(points = [31.9714, -18.5714; -67.1429,85.7143]);
//           connect(S14.control,Clk.p) annotation(points = [60.5429, -18.5714; -67.1429,85.7143]);
//           connect(S15.control,Clk.p) annotation(points = [89.1143, -18.5714; -67.1429,85.7143]);
//           connect(S16.control,Clk.p) annotation(points = [ -82.3143, -47.1429; -67.1429,85.7143]);
//           connect(S17.control,Clk.p) annotation(points = [ -53.7429, -47.1429; -67.1429,85.7143]);
//           connect(S18.control,Clk.p) annotation(points = [ -25.1714, -47.1429; -67.1429,85.7143]);
//           connect(G.p,V.n) annotation(points = [ -57.1429, -75.7143; -75.7143,85.7143]);
//           connect(G.p,S3.n2) annotation(points = [ -57.1429, -75.7143; -47.1429,1.4]);
//           connect(G.p,S4.n2) annotation(points = [ -57.1429, -75.7143; -18.5714,1.4]);
//           connect(G.p,S5.n2) annotation(points = [ -57.1429, -75.7143;10,1.4]);
//           connect(G.p,S7.n2) annotation(points = [ -57.1429, -75.7143;67.1429,1.4]);
//           connect(G.p,S11.n2) annotation(points = [ -57.1429, -75.7143; -18.5714, -27.1714]);
//           connect(G.p,S12.n2) annotation(points = [ -57.1429, -75.7143;10, -27.1714]);
//           connect(G.p,S13.n2) annotation(points = [ -57.1429, -75.7143;38.5714, -27.1714]);
//           connect(G.p,S14.n2) annotation(points = [ -57.1429, -75.7143;67.1429, -27.1714]);
//           connect(G.p,S16.n2) annotation(points = [ -57.1429, -75.7143; -75.7143, -55.7429]);
//           connect(G.p,S18.n2) annotation(points = [ -57.1429, -75.7143; -18.5714, -55.7429]);
//           connect(G.p,S2.n1) annotation(points = [ -57.1429, -75.7143; -75.7143,6]);
//           connect(G.p,S6.n1) annotation(points = [ -57.1429, -75.7143;38.5714,6]);
//           connect(G.p,S8.n1) annotation(points = [ -57.1429, -75.7143;95.7143,6]);
//           connect(G.p,S10.n1) annotation(points = [ -57.1429, -75.7143; -47.1429, -22.5714]);
//           connect(G.p,S15.n1) annotation(points = [ -57.1429, -75.7143;95.7143, -22.5714]);
//           connect(M.p,Op1.p1) annotation(points = [ -28.5714, -75.7143; -10, -52.1429]);
//           connect(M.p,Op2.p1) annotation(points = [ -28.5714, -75.7143;18.5714, -52.1429]);
//           connect(M.p,Op3.p1) annotation(points = [ -28.5714, -75.7143;47.1429, -52.1429]);
//           connect(M.p,Op4.p1) annotation(points = [ -28.5714, -75.7143;75.7143, -52.1429]);
//           connect(M.p,Op5.p1) annotation(points = [ -28.5714, -75.7143; -95.7143, -80.7143]);
//           connect(M.p,Op1.n2) annotation(points = [ -28.5714, -75.7143;10, -62.1429]);
//           connect(M.p,Op2.n2) annotation(points = [ -28.5714, -75.7143;38.5714, -62.1429]);
//           connect(M.p,Op3.n2) annotation(points = [ -28.5714, -75.7143;67.1429, -62.1429]);
//           connect(M.p,Op4.n2) annotation(points = [ -28.5714, -75.7143;95.7143, -62.1429]);
//           connect(M.p,Op5.n2) annotation(points = [ -28.5714, -75.7143; -75.7143, -90.7143]);
//           connect(M.p,Clk.n) annotation(points = [ -28.5714, -75.7143; -47.1429,85.7143]);
//         end CauerFilter;
//         model CharacteristicIdealDiodes "Characteristic of ideal diodes"
//           extends Modelica.Icons.Example;
//           Modelica.Electrical.Analog.Ideal.IdealDiode Ideal(Roff = 0, Gon = 0) annotation(extent = [0,40;20,60]);
//           Modelica.Electrical.Analog.Ideal.IdealDiode With_Roff_Gon(Roff = 0.1, Gon = 0.1) annotation(extent = [0,0;20,20]);
//           Modelica.Electrical.Analog.Ideal.IdealDiode With_Roff_Gon1_Vknee(Vknee = 5, Roff = 0.2, Gon = 0.2) annotation(extent = [0, -40;20, -20]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = 10, offset =  -9) annotation(extent = [ -50, -10; -30,10], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(extent = [ -50, -80; -30, -60]);
//           annotation(Diagram(Text(extent = [ -88,102;92,48], string = "Characteristic Ideal Diodes")));
//           Modelica.Electrical.Analog.Basic.Resistor R1(R = 0.001) annotation(extent = [60,40;80,60]);
//           Modelica.Electrical.Analog.Basic.Resistor R2(R = 0.001) annotation(extent = [60,0;80,20]);
//           Modelica.Electrical.Analog.Basic.Resistor R3(R = 0.001) annotation(extent = [60, -40;80, -20]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage2(V = 10, offset = 0) annotation(extent = [ -70,30; -50,50], rotation = 270);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage3(V = 10, offset = 0) annotation(extent = [ -30, -50; -10, -30], rotation = 270);
//           annotation(Documentation(info = "<HTML>
// <P>
// Three examples of ideal diodes are shown:<br><br>
// the <b>totally ideal diode</b> (Ideal) with all parameters to be zero <br>
// the <b>nearly ideal diode</b> with <i>Roff=0.1</i> and <i>Gon=0.1</i> <br>
// the nearly ideal but <b>displaced diode</b> with <i>Vknee=5</i> and <i>Roff=0.1</i> and 
// <i>Gon=0.1</i> <br><br>
// The resistance and conductance are chosen untypically high since the slopes should
// be seen in the graphics.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Ideal.i versus Ideal.v <br>
// With_Roff_Gon.i versus With_Roff_Gon.v<br>
// With_Roff_Gon_Vknee.i versus With_Roff_Gon_Vknee.v<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 1));
// 
//         equation 
//           connect(Ground1.p,SineVoltage1.n) annotation(points = [ -40, -60; -40, -10], style(color = 3));
//           connect(Ideal.n,R1.p) annotation(points = [20,50;60,50], style(color = 3));
//           connect(With_Roff_Gon.n,R2.p) annotation(points = [20,10;60,10], style(color = 3));
//           connect(With_Roff_Gon1_Vknee.n,R3.p) annotation(points = [20, -30;60, -30], style(color = 3));
//           connect(R1.n,R2.n) annotation(points = [80,50;80,10], style(color = 3));
//           connect(R2.n,R3.n) annotation(points = [80,10;80, -30], style(color = 3));
//           connect(R3.n,Ground1.p) annotation(points = [80, -30;80, -60; -40, -60], style(color = 3));
//           connect(SineVoltage2.p,Ideal.p) annotation(points = [ -60,50;0,50], style(color = 3));
//           connect(SineVoltage2.n,Ground1.p) annotation(points = [ -60,30; -60, -60; -40, -60], style(color = 3));
//           connect(SineVoltage1.p,With_Roff_Gon.p) annotation(points = [ -40,10;0,10], style(color = 3));
//           connect(With_Roff_Gon1_Vknee.p,SineVoltage3.p) annotation(points = [0, -30; -20, -30], style(color = 3));
//           connect(SineVoltage3.n,Ground1.p) annotation(points = [ -20, -50; -20, -60; -40, -60], style(color = 3));
//         end CharacteristicIdealDiodes;
//         model CharacteristicThyristors "Characteristic of ideal thyristors"
//           extends Modelica.Icons.Example;
//           Modelica.Electrical.Analog.Ideal.IdealThyristor IdealThyristor1(Vknee = 5) annotation(extent = [ -20,0;0,20]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = 10, offset = 0) annotation(extent = [ -50, -20; -30,0], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(extent = [ -50, -60; -30, -40]);
//           Modelica.Electrical.Analog.Basic.Resistor R3(R = 0.001) annotation(extent = [40,0;60,20]);
//           annotation(Diagram(Text(extent = [ -96,100;98,60], string = "Characteristic Thyristors")));
//           Modelica.Blocks.Sources.BooleanStep BooleanStep1(startValue = {false}, startTime = {1.25}) annotation(extent = [ -60,40; -40,60]);
//           Modelica.Electrical.Analog.Ideal.IdealGTOThyristor IdealGTOThyristor1(Vknee = 0) annotation(extent = [ -20, -30;0, -10]);
//           Modelica.Electrical.Analog.Basic.Resistor R1(R = 0.001) annotation(extent = [40, -30;60, -10]);
//           annotation(Documentation(info = "<HTML>
// <P>
// Two examples of thyristors are shown:<br><br>
// the <b>ideal thyristor</b>  <br>
// and the <b>ideal GTO thyristor</b>  with <i>Vknee=5</i>  <br><br>
// </P>
// <P>
// Simulate until T=2 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// IdealThyristor1.i and IdealGTOThyristor1.i <br>
// IdealThyristor1.v and IdealGTOThyristor1.v <br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 2));
// 
//         equation 
//           connect(IdealThyristor1.n,R3.p) annotation(points = [0,10;40,10], style(color = 3));
//           connect(Ground1.p,SineVoltage1.n) annotation(points = [ -40, -40; -40, -20], style(color = 3));
//           connect(SineVoltage1.p,IdealThyristor1.p) annotation(points = [ -40,0; -40,10; -20,10], style(color = 3));
//           connect(BooleanStep1.outPort,IdealThyristor1.firePort) annotation(points = [ -39,50; -3,50; -3,20], style(color = 5));
//           connect(IdealGTOThyristor1.n,R1.p) annotation(points = [0, -20;40, -20], style(color = 3));
//           connect(R3.n,R1.n) annotation(points = [60,10;60, -20], style(color = 3));
//           connect(R1.n,Ground1.p) annotation(points = [60, -20;60, -40; -40, -40], style(color = 3));
//           connect(IdealGTOThyristor1.p,IdealThyristor1.p) annotation(points = [ -20, -20; -20,10], style(color = 3));
//           connect(IdealGTOThyristor1.firePort,IdealThyristor1.firePort) annotation(points = [ -3, -10; -3, -2.5; -2, -2.5; -2,5; -3,5; -3,20], style(color = 5));
//         end CharacteristicThyristors;
//         encapsulated model ChuaCircuit "Chua's circuit, ns, V, A"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon, Documentation(info = "<html>
// <p>
//  Chua's circuit is the most simple nonlinear circuit which shows chaotic behaviour. The circuit consists of linear basic elements (capacitors, resistor, conductor, inductor), and one nonlinear element, which is called Chua's diode. The chaotic behaviour is simulated.
// <p>
// The simulation end time should be set to 5e4. To get the chaotic behaviour please plot C1.v. Choose C2.v as the independent variable.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Kennedy, M.P.: Three Steps to Chaos - Part I: Evolution. IEEE Transactions on CAS I 40 (1993)10, 640-656
// <p>
// 
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: ChuaCircuit.mo,v 1.10 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "), Window(x = 0.22, y = 0.17, width = 0.6, height = 0.6));
//           Basic.Inductor L(L = 18) annotation(extent = [ -100,25; -50,75], rotation =  -90);
//           Basic.Resistor Ro(R = 0.0125) annotation(extent = [ -100, -30; -50,20], rotation =  -90);
//           Basic.Conductor G(G = 0.565) annotation(extent = [ -25,50;25,100]);
//           Basic.Capacitor C1(C = 10, v(start = 4)) annotation(extent = [0, -10;50,40], rotation =  -90);
//           Basic.Capacitor C2(C = 100) annotation(extent = [ -50, -10;0,40], rotation =  -90);
//           Utilities.NonlinearResistor Nr(Ga(min =  -1) =  -0.757576, Gb(min =  -1) =  -0.409091, Ve = 1) annotation(extent = [50, -10;100,40], rotation =  -90);
//           Basic.Ground Gnd annotation(extent = [ -25, -100;25, -50]);
// 
//         equation 
//           connect(L.p,G.p) annotation(points = [ -75,75; -25,75]);
//           connect(G.n,Nr.p) annotation(points = [25,75;75,75;75,40]);
//           connect(Nr.n,Gnd.p) annotation(points = [75, -10;75, -50;0, -50]);
//           connect(C1.p,G.n) annotation(points = [25,40;25,75]);
//           connect(L.n,Ro.p) annotation(points = [ -75,25; -75,20]);
//           connect(G.p,C2.p) annotation(points = [ -25,75; -25,40]);
//           connect(C1.n,Gnd.p) annotation(points = [25, -10;25, -50;0, -50]);
//           connect(C2.n,Gnd.p) annotation(points = [ -25, -10; -25, -50;0, -50]);
//           connect(Ro.n,Gnd.p) annotation(points = [ -75, -30; -75, -50;0, -50]);
//         end ChuaCircuit;
//         encapsulated model DifferenceAmplifier
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Sources;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon, Documentation(info = "<html>
// <p>
// It is a simple NPN transistor amplifier circuit. The voltage difference between R1.p and R3.n is amplified. The output signal is the voltage between R2.n and R4.n. In this example the voltage at V1 is amplified because R3.n is grounded.
// <p>
// The simulation end time should be set to 1e- 8. Please plot the input voltage V1.v, and the output voltages R2.n.v, and R4.n.v.
// <p>
// 
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 59
// <p>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: DifferenceAmplifier.mo,v 1.10 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "), Window(x = 0.35, y = 0.01, width = 0.45, height = 0.61));
//           Sources.ExpSineVoltage V1(V = 0.2, freqHz = 200000000.0, damping = 10000000.0) annotation(extent = [ -100, -60; -80, -40], rotation =  -90);
//           Sources.RampVoltage V2(V = 15, duration = 1e-09) annotation(extent = [70,40;90,60], rotation =  -90);
//           Sources.RampCurrent I1(I = 0.16, duration = 1e-09) annotation(extent = [ -20, -60;0, -40], rotation =  -90);
//           Basic.Resistor R1(R = 0.0001) annotation(extent = [ -90, -20; -70,0]);
//           Basic.Resistor R2(R = 100) annotation(extent = [ -50,20; -30,40], rotation =  -90);
//           Basic.Resistor R3(R = 0.0001) annotation(extent = [70, -20;90,0]);
//           Basic.Resistor R4(R = 100) annotation(extent = [30,20;50,40], rotation =  -90);
//           Basic.Capacitor C1(C = 1e-10) annotation(extent = [ -70, -60; -50, -40], rotation =  -90);
//           Basic.Capacitor C4(C = 1e-10) annotation(extent = [10, -14;30,6]);
//           Basic.Capacitor C5(C = 1e-10) annotation(extent = [0, -60;20, -40], rotation =  -90);
//           Basic.Capacitor C2(C = 1e-10) annotation(extent = [ -30, -14; -10,6]);
//           Basic.Capacitor C3(C = 1e-10) annotation(extent = [50, -60;70, -40], rotation =  -90);
//           Basic.Ground Gnd1 annotation(extent = [ -95, -80; -85, -70]);
//           Basic.Ground Gnd9 annotation(extent = [75,20;85,30]);
//           Basic.Ground Gnd3 annotation(extent = [ -15, -20; -5, -10]);
//           Basic.Ground Gnd2 annotation(extent = [ -65, -80; -55, -70]);
//           Basic.Ground Gnd6 annotation(extent = [5, -20;15, -10]);
//           Basic.Ground Gnd7 annotation(extent = [ -15, -80; -5, -70]);
//           Basic.Ground Gnd8 annotation(extent = [5, -80;15, -70]);
//           Basic.Ground Gnd5 annotation(extent = [55, -80;65, -70]);
//           Basic.Ground Gnd4 annotation(extent = [85, -50;95, -40]);
//           Utilities.Transistor Transistor1 annotation(extent = [ -60, -20; -40,0]);
//           Utilities.Transistor Transistor2 annotation(extent = [60, -20;40,0]);
// 
//         equation 
//           connect(V1.n,Gnd1.p) annotation(points = [ -90, -60; -90, -70]);
//           connect(C1.n,Gnd2.p) annotation(points = [ -60, -60; -60, -70]);
//           connect(I1.n,Gnd7.p) annotation(points = [ -10, -60; -10, -70]);
//           connect(C5.n,Gnd8.p) annotation(points = [10, -60;10, -70]);
//           connect(C3.n,Gnd5.p) annotation(points = [60, -60;60, -70]);
//           connect(R3.n,Gnd4.p) annotation(points = [90, -10;90, -40]);
//           connect(C2.n,Gnd3.p) annotation(points = [ -10, -4; -10, -10]);
//           connect(C4.p,Gnd6.p) annotation(points = [10, -4;10, -10]);
//           connect(I1.p,C5.p) annotation(points = [ -10, -40;10, -40]);
//           connect(R1.p,V1.p) annotation(points = [ -90, -10; -90, -40]);
//           connect(R2.p,V2.p) annotation(points = [ -40,40; -40,70;80,70;80,60]);
//           connect(R4.p,V2.p) annotation(points = [40,40;40,70;80,70;80,60]);
//           connect(V2.n,Gnd9.p) annotation(points = [80,40;80,30]);
//           connect(R1.n,Transistor1.b) annotation(points = [ -70, -10; -60, -10]);
//           connect(Transistor1.b,C1.p) annotation(points = [ -60, -10; -60, -40]);
//           connect(Transistor1.c,C2.p) annotation(points = [ -40, -4; -30, -4]);
//           connect(R2.n,Transistor1.c) annotation(points = [ -40,20; -40, -4]);
//           connect(Transistor1.e,I1.p) annotation(points = [ -40, -16; -30, -16; -30, -40; -10, -40]);
//           connect(Transistor2.b,R3.p) annotation(points = [60, -10;70, -10]);
//           connect(Transistor2.b,C3.p) annotation(points = [60, -10;60, -40]);
//           connect(C4.n,Transistor2.c) annotation(points = [30, -4;40, -4]);
//           connect(R4.n,Transistor2.c) annotation(points = [40,20;40, -4]);
//           connect(C5.p,Transistor2.e) annotation(points = [10, -40;30, -40;30, -16;40, -16]);
//         end DifferenceAmplifier;
//         model HeatingMOSInverter "Heating MOS Inverter"
//           extends Modelica.Icons.Example;
//           Modelica.Electrical.Analog.Basic.Ground G annotation(extent = [ -80, -40; -60, -20]);
//           Modelica.Electrical.Analog.Sources.SineVoltage Sin(V = 5) annotation(extent = [ -80, -10; -60,10], rotation = 270);
//           annotation(Diagram(Text(extent = [ -100,100; -6,72], string = "Heating MOS Inverter")));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 1e-05) annotation(extent = [20,0;40,20], rotation = 270);
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 0.01) annotation(extent = [60, -70;80, -50], rotation = 270);
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC1(G = 0.01) annotation(extent = [0, -50;20, -30], rotation = 0);
//           Semiconductors.HeatingPMOS H_PMOS annotation(extent = [ -40,40; -20,60]);
//           Semiconductors.HeatingNMOS H_NMOS annotation(extent = [ -40,0; -20,20]);
//           Modelica.Electrical.Analog.Sources.RampVoltage V(V = 5, duration = 0.01) annotation(extent = [40,40;60,60], rotation = 270);
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC2(G = 0.01) annotation(extent = [0, -90;20, -70], rotation = 0);
//           Modelica.Thermal.HeatTransfer.FixedTemperature FixedTemperature1(T = 300) annotation(extent = [78, -38;98, -18], rotation = 180);
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC3(G = 0.01) annotation(extent = [46, -40;66, -20], rotation = 0);
// 
//         equation 
//           connect(Sin.n,G.p) annotation(points = [ -70, -10; -70, -20], style(color = 3));
//           connect(Capacitor1.n,G.p) annotation(points = [30,0;30, -20; -70, -20], style(color = 3));
//           annotation(Documentation(info = "<HTML>
// <P>
// The heating MOS inverter shows a heat flow always if a transistor is leading.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Sin.p.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and H_PMOS.heatPort.T and H_NMOS.heatPort.T<br>
// H_PMOS.heatPort.Q_dot and H_NMOS.heatPort.Q_dot<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 5));
//           connect(H_NMOS.G,H_PMOS.G) annotation(points = [ -40,5; -40,45], style(color = 3));
//           connect(H_NMOS.G,Sin.p) annotation(points = [ -40,5; -40,10; -70,10], style(color = 3));
//           connect(H_PMOS.S,H_NMOS.D) annotation(points = [ -20,45; -20,15], style(color = 3));
//           connect(H_NMOS.D,Capacitor1.p) annotation(points = [ -20,15; -20,20;30,20], style(color = 3));
//           connect(H_NMOS.B,H_NMOS.S) annotation(points = [ -20,10; -20,5], style(color = 3));
//           connect(H_NMOS.S,G.p) annotation(points = [ -20,5; -20, -20; -70, -20], style(color = 3));
//           connect(H_PMOS.B,H_PMOS.D) annotation(points = [ -20,50; -20,55], style(color = 3));
//           connect(V.p,H_PMOS.D) annotation(points = [50,60; -20,60; -20,55], style(color = 3));
//           connect(V.n,G.p) annotation(points = [50,40;50, -20; -70, -20], style(color = 3));
//           connect(TC1.port_b,HeatCapacitor1.port) annotation(points = [21, -40;40, -40;40, -60;60, -60], style(color = 42));
//           connect(TC2.port_b,HeatCapacitor1.port) annotation(points = [21, -80;40, -80;40, -60;60, -60], style(color = 42));
//           connect(TC1.port_a,H_PMOS.heatPort) annotation(points = [ -1, -40; -10, -40; -10,40; -30,40], style(color = 42));
//           connect(TC2.port_a,H_NMOS.heatPort) annotation(points = [ -1, -80; -30, -80; -30,0], style(color = 42));
//           connect(TC3.port_b,FixedTemperature1.port) annotation(points = [67, -30;70, -30;70, -28;77, -28], style(color = 42, rgbcolor = {191,0,0}));
//           connect(TC3.port_a,HeatCapacitor1.port) annotation(points = [45, -30;52, -30;52, -60;60, -60], style(color = 42, rgbcolor = {191,0,0}));
//         end HeatingMOSInverter;
//         model HeatingNPN_OrGate "Heating NPN Or Gate"
//           extends Modelica.Icons.Example;
//           constant Real CapVal = 0;
//           annotation(Diagram(Text(extent = [ -100,100; -6,72], string = "Heating NPN Nand Gate")));
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 0.1) annotation(extent = [66, -94;86, -74], rotation = 180);
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC1(G = 0.01) annotation(extent = [80, -60;100, -40], rotation = 270);
//           Modelica.Thermal.HeatTransfer.ThermalConductor TC2(G = 0.01) annotation(extent = [50, -60;70, -40], rotation = 270);
//           annotation(Documentation(info = "<HTML>
// <P>
// The heating NPN nand gate shows a heat flow always if a transistor is leading.
// </P>
// <P>
// Simulate until T=200 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// V1.v and V2.v and C2.v <br>
// HeatCapacitor1.port.T and T1.heatPort.T and T2.heatPort.T<br>
// T1.heatPort.Q_dot and T2.heatPort.Q_dot<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 200));
//           Modelica.Electrical.Analog.Sources.RampVoltage V(V = 6, duration = 5) annotation(extent = [80,28;100,48], rotation = 270);
//           Modelica.Electrical.Analog.Sources.TrapezoidVoltage V1(V = 6, startTime = 55, rising = 5, width = 15, falling = 5, period = 50, nperiod = 10) annotation(extent = [ -100,8; -80,28], rotation = 270);
//           Modelica.Electrical.Analog.Sources.TrapezoidVoltage V2(V = 6, startTime = 65, rising = 5, width = 15, falling = 5, period = 50, nperiod = 10) annotation(extent = [ -60, -52; -40, -32], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Resistor R1(R = 1800) annotation(extent = [ -90,48; -70,68]);
//           Modelica.Electrical.Analog.Basic.Resistor R2(R = 1800) annotation(extent = [ -36, -22; -16, -2]);
//           Modelica.Electrical.Analog.Basic.Resistor RI(R = 40) annotation(extent = [60,58;80,78]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd annotation(extent = [80,0;100,20]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd1 annotation(extent = [ -100, -22; -80, -2]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd2 annotation(extent = [ -60, -82; -40, -62]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd3 annotation(extent = [ -10,16;10,36]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd4 annotation(extent = [30, -52;50, -32]);
//           Modelica.Electrical.Analog.Basic.Capacitor C1(C = CapVal) annotation(extent = [ -80,28; -60,48], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Capacitor C2(C = CapVal) annotation(extent = [50,32;70,52], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Capacitor C3(C = CapVal) annotation(extent = [ -26, -50; -6, -30], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Ground Gnd5 annotation(extent = [ -26, -76; -6, -56]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd6 annotation(extent = [50,6;70,26]);
//           Modelica.Electrical.Analog.Basic.Ground Gnd7 annotation(extent = [ -80,2; -60,22]);
//           Semiconductors.HeatingNPN T1(Bf = 100, Br = 1, Is = 1e-14, Vak = 0, Tauf = 0, Taur = 0, Ccs = CapVal, Cje = CapVal, Cjc = CapVal, Phie = 1, Me = 0.5, Phic = 1, Mc = 0.5, Gbc = 1e-12, Gbe = 1e-12, EMax = 40) annotation(extent = [ -20,48;0,68]);
//           Semiconductors.HeatingNPN T2(Bf = 100, Br = 1, Is = 1e-14, Vak = 0, Tauf = 0, Taur = 0, Ccs = CapVal, Cje = CapVal, Cjc = CapVal, Phie = 1, Me = 0.5, Phic = 1, Mc = 0.5, Gbc = 1e-12, Gbe = 1e-12, EMax = 40) annotation(extent = [20, -22;40, -2]);
// 
//         equation 
//           connect(Gnd1.p,V1.n) annotation(points = [ -90, -2; -90,8]);
//           connect(V1.p,R1.p) annotation(points = [ -90,28; -90,58]);
//           connect(RI.n,V.p) annotation(points = [80,68;90,68;90,48]);
//           connect(Gnd.p,V.n) annotation(points = [90,20;90,28]);
//           connect(V2.p,R2.p) annotation(points = [ -50, -32; -50, -12; -36, -12]);
//           connect(Gnd2.p,V2.n) annotation(points = [ -50, -62; -50, -52]);
//           connect(Gnd7.p,C1.n) annotation(points = [ -70,22; -70,28]);
//           connect(C2.p,RI.p) annotation(points = [60,52;60,68]);
//           connect(Gnd6.p,C2.n) annotation(points = [60,26;60,32]);
//           connect(C3.p,R2.n) annotation(points = [ -16, -30; -16, -21; -16, -21; -16, -12]);
//           connect(C1.p,R1.n) annotation(points = [ -70,48; -70,58]);
//           connect(Gnd5.p,C3.n) annotation(points = [ -16, -56; -16, -53; -16, -50; -16, -50]);
//           connect(T1.B,R1.n) annotation(points = [ -20,58; -70,58], style(color = 3));
//           connect(T1.E,Gnd3.p) annotation(points = [0,53;0,36], style(color = 3));
//           connect(RI.p,T1.C) annotation(points = [60,68;30,68;30,63;0,63], style(color = 3));
//           connect(T2.B,R2.n) annotation(points = [20, -12; -16, -12], style(color = 3));
//           connect(T2.E,Gnd4.p) annotation(points = [40, -17;40, -32], style(color = 3));
//           connect(T2.C,RI.p) annotation(points = [40, -7;40,68;60,68], style(color = 3));
//           connect(TC1.port_b,HeatCapacitor1.port) annotation(points = [90, -61;84, -61;84, -74;76, -74], style(color = 42));
//           connect(TC2.port_b,HeatCapacitor1.port) annotation(points = [60, -61;68, -61;68, -74;76, -74], style(color = 42));
//           connect(TC2.port_a,T2.heatPort) annotation(points = [60, -39;60, -22;30, -22], style(color = 42));
//           connect(TC1.port_a,T1.heatPort) annotation(points = [90, -39;90,2; -10,2; -10,48], style(color = 42));
//         end HeatingNPN_OrGate;
//         model HeatingRectifier "Heating rectifier"
//           extends Modelica.Icons.Example;
//           Modelica.Electrical.Analog.Semiconductors.HeatingDiode HeatingDiode1 annotation(extent = [ -20,40;0,60]);
//           Modelica.Electrical.Analog.Basic.Ground G annotation(extent = [ -80,0; -60,20]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1 annotation(extent = [ -80,30; -60,50], rotation = 270);
//           annotation(Diagram(Text(extent = [ -94,102;0,74], string = "HeatingRectifier")));
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1 annotation(extent = [20,40;40,60]);
//           Modelica.Thermal.HeatTransfer.HeatCapacitor HeatCapacitor1(C = 1) annotation(extent = [ -20, -60;0, -40], rotation = 180);
//           Modelica.Thermal.HeatTransfer.ThermalConductor ThermalConductor1(G = 10) annotation(extent = [ -20, -20;0,0], rotation = 270);
//           Modelica.Electrical.Analog.Basic.Resistor R(R = 1) annotation(extent = [20,70;40,90]);
// 
//         equation 
//           connect(SineVoltage1.p,HeatingDiode1.p) annotation(points = [ -70,50; -20,50], style(color = 3));
//           connect(SineVoltage1.n,G.p) annotation(points = [ -70,30; -70,20], style(color = 3));
//           connect(Capacitor1.n,G.p) annotation(points = [40,50;40,20; -70,20], style(color = 3));
//           connect(HeatingDiode1.n,Capacitor1.p) annotation(points = [0,50;20,50], style(color = 3));
//           connect(HeatingDiode1.heatPort,ThermalConductor1.port_a) annotation(points = [ -10,40; -10,20.5; -10,1; -10,1], style(color = 42));
//           connect(ThermalConductor1.port_b,HeatCapacitor1.port) annotation(points = [ -10, -21; -10, -25.75; -10, -25.75; -10, -30.5; -10, -40; -10, -40], style(color = 42));
//           connect(R.p,Capacitor1.p) annotation(points = [20,80;20,50], style(color = 3));
//           connect(R.n,Capacitor1.n) annotation(points = [40,80;40,50], style(color = 3));
//           annotation(Documentation(info = "<HTML>
// <P>
// The heating rectifier shows a heat flow always if the electrical capacitor is loaded.
// </P>
// <P>
// Simulate until T=5 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// SineVoltage1.v  and  Capacitor1.p.v <br>
// HeatCapacitor1.port.T and HeatingDiode1.heatPort.T<br>
// HeatingDiode1.heatPort.Q_dot<br>
// </P>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 5));
//         end HeatingRectifier;
//         encapsulated model NandGate "CMOS NAND Gate (see Tietze/Schenk, page 157)"
//           import Modelica.Electrical.Analog.Basic;
//           import Modelica.Electrical.Analog.Sources;
//           import Modelica.Electrical.Analog.Examples.Utilities;
//           import Modelica.Icons;
//           extends Icons.Example;
//           annotation(Icon, Documentation(info = "<html>
// <p>
// The nand gate is a basic CMOS building block. It consists of four CMOS transistors.
// The output voltage Nand.y.v is low if and only if the two input voltages at Nand.x1.v and Nand.x2.v
// are both high. In this way the nand functionality is realized.
// <p>
// The simulation end time should be set to 1e-7. Please plot the input voltages Nand.x1.v,
// d Nand.x2.v, and the output voltage Nand.y.v.
// <p>
// <dl>
// <dt>
// <b>Reference:</b>
// <dd>
// Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin Heidelberg NewYork 1980, p. 157
// <p>
// 
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: NandGate.mo,v 1.10 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "), Window(x = 0.36, y = 0.01, width = 0.44, height = 0.6));
//           Sources.TrapezoidVoltage VIN1(V = 3.5, startTime = 2e-08, rising = 1e-09, width = 1.9e-08, falling = 1e-09, period = 4e-08) annotation(extent = [ -80,10; -60,30], rotation =  -90);
//           Sources.TrapezoidVoltage VIN2(V = 3.5, startTime = 1e-08, rising = 1e-09, width = 1.9e-08, falling = 1e-09, period = 4e-08) annotation(extent = [ -80, -40; -60, -20], rotation =  -90);
//           Sources.RampVoltage VDD(V = 5, duration = 1e-09) annotation(extent = [40,60;60,80], rotation =  -90);
//           Basic.Ground Gnd1 annotation(extent = [45,43;55,53]);
//           Basic.Ground Gnd4 annotation(extent = [ -75, -5; -65,5]);
//           Basic.Ground Gnd5 annotation(extent = [ -75, -55; -65, -45]);
//           Utilities.Nand Nand annotation(extent = [ -40, -45;40,55]);
// 
//         equation 
//           connect(VDD.n,Gnd1.p) annotation(points = [50,60;50,53]);
//           connect(VIN1.n,Gnd4.p) annotation(points = [ -70,10; -70,5]);
//           connect(VIN2.n,Gnd5.p) annotation(points = [ -70, -40; -70, -45]);
//           connect(Nand.Vdd,VDD.p) annotation(points = [0,55;0,90;50,90;50,80]);
//           connect(VIN1.p,Nand.x1) annotation(points = [ -70,30; -40,30]);
//           connect(VIN2.p,Nand.x2) annotation(points = [ -70, -20; -40, -20]);
//         end NandGate;
//         model Rectifier "B6 diode bridge"
//           extends Modelica.Icons.Example;
//           import Modelica.Electrical.Analog.Ideal;
//           parameter Modelica.SIunits.Voltage VAC = 400 "RMS line-to-line";
//           parameter Modelica.SIunits.Frequency f = 50 "line frequency";
//           parameter Modelica.SIunits.Inductance LAC = 6e-05 "line inductor";
//           parameter Modelica.SIunits.Resistance Roff = 0.001 "diode forward resistance";
//           parameter Modelica.SIunits.Conductance Gon = 0.001 "diode backward conductance";
//           parameter Modelica.SIunits.Voltage Vknee = 2 "diode threshold voltage";
//           parameter Modelica.SIunits.Capacitance CDC = 0.015 "DC capacitance";
//           parameter Modelica.SIunits.Current IDC = 500 "load current";
//           output Modelica.SIunits.Voltage uDC;
//           output Modelica.SIunits.Current iAC[3];
//           output Modelica.SIunits.Voltage uAC[3];
//           output Modelica.SIunits.Power Losses;
//           annotation(Diagram(Text(extent = [ -80,90;80,70], string = "Rectifier", style(color = 0, rgbcolor = {0,0,0})), Line(points = [ -16,18; -16,2; -18,6; -14,6; -16,2], style(color = 0, rgbcolor = {0,0,0})), Line(points = [ -30,22; -26,20; -30,18; -30,22], style(color = 0, rgbcolor = {0,0,0})), Line(points = [32,30;32, -30;30, -26;34, -26;32, -30], style(color = 0, rgbcolor = {0,0,0})), Text(extent = [ -38,16; -22,8], string = "iAC", style(color = 0, rgbcolor = {0,0,0})), Text(extent = [ -14,8;2,0], string = "uAC", style(color = 0, rgbcolor = {0,0,0})), Text(extent = [22, -16;38, -24], string = "uDC", style(color = 0, rgbcolor = {0,0,0}))), experiment(StopTime = 0.1, Interval = 1e-05), experimentSetupOutput(doublePrecision = true, states = false, derivatives = false, inputs = false, auxiliaries = false), Documentation(info = "<HTML>
// <P>
// The rectifier example shows a B6 diode bridge fed by a three phase sinusoidal voltage, loaded by a DC current.<br>
// DC capacitors start at ideal no-load voltage, thus making easier initial transient.
// </P>
// <P>
// Simulate until T=0.1 s.<br><br>
// Plot in separate windows:<br><br>
// uDC ... DC-voltage<br>
// iAC ... AC-currents 1..3<br>
// uAC ... AC-voltages 1..3 (distorted)<br>
// Try different load currents iDC = 0..approximately 500 A.
// </P>
// <p>
// You may watch Losses (of the whole diode bridge) trying different diode parameters.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Anton Haumer<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(freqHz = f, V = VAC * sqrt(2 / 3)) annotation(extent = [ -70,10; -90,30]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage2(freqHz = f, phase =  -2 / 3 * Modelica.Constants.pi, V = VAC * sqrt(2 / 3)) annotation(extent = [ -70, -10; -90,10]);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage3(freqHz = f, phase =  -4 / 3 * Modelica.Constants.pi, V = VAC * sqrt(2 / 3)) annotation(extent = [ -70, -30; -90, -10]);
//           Modelica.Electrical.Analog.Basic.Inductor Inductor1(L = LAC) annotation(extent = [ -60,10; -40,30]);
//           Modelica.Electrical.Analog.Basic.Inductor Inductor2(L = LAC) annotation(extent = [ -60, -10; -40,10]);
//           Modelica.Electrical.Analog.Basic.Inductor Inductor3(L = LAC) annotation(extent = [ -60, -30; -40, -10]);
//           Ideal.IdealDiode IdealDiode1(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [ -30,30; -10,50], rotation = 90);
//           Ideal.IdealDiode IdealDiode2(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [ -10,30;10,50], rotation = 90);
//           Ideal.IdealDiode IdealDiode3(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [10,30;30,50], rotation = 90);
//           Ideal.IdealDiode IdealDiode4(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [ -30, -50; -10, -30], rotation = 90);
//           Ideal.IdealDiode IdealDiode5(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [ -10, -50;10, -30], rotation = 90);
//           Ideal.IdealDiode IdealDiode6(Roff = Roff, Gon = Gon, Vknee = Vknee) annotation(extent = [10, -50;30, -30], rotation = 90);
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 2 * CDC) annotation(extent = [30,30;50,50], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor2(C = 2 * CDC) annotation(extent = [30, -50;50, -30], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(extent = [40, -80;60, -60]);
//           Modelica.Electrical.Analog.Sources.SignalCurrent SignalCurrent1 annotation(extent = [50, -10;70,10], rotation =  -90);
//           Modelica.Blocks.Sources.Constant Constant1(k = {IDC}) annotation(extent = [100, -10;80,10], rotation = 0);
// 
//         initial equation 
//           Capacitor1.v = (VAC * sqrt(2)) / 2;
//           Capacitor2.v = (VAC * sqrt(2)) / 2;
// 
//         equation 
//           uDC = Capacitor1.v + Capacitor2.v;
//           iAC = {Inductor1.i,Inductor2.i,Inductor3.i};
//           uAC[1] = Inductor1.n.v - Inductor2.n.v;
//           uAC[2] = Inductor2.n.v - Inductor3.n.v;
//           uAC[3] = Inductor3.n.v - Inductor1.n.v;
//           Losses = IdealDiode1.v * IdealDiode1.i + IdealDiode2.v * IdealDiode2.i + IdealDiode3.v * IdealDiode3.i + IdealDiode4.v * IdealDiode4.i + IdealDiode5.v * IdealDiode5.i + IdealDiode6.v * IdealDiode6.i;
//           connect(SineVoltage1.n,SineVoltage2.n) annotation(points = [ -90,20; -90,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage2.n,SineVoltage3.n) annotation(points = [ -90,0; -90, -20], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage1.p,Inductor1.p) annotation(points = [ -70,20; -60,20], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage2.p,Inductor2.p) annotation(points = [ -70,0; -60,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage3.p,Inductor3.p) annotation(points = [ -70, -20; -60, -20], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode1.p,IdealDiode4.n) annotation(points = [ -20,30; -20, -30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode2.p,IdealDiode5.n) annotation(points = [ -6.12303e-16,30;0,16;1.76911e-22,0;6.12303e-16,0;6.12303e-16, -30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode3.p,IdealDiode6.n) annotation(points = [20,30;20, -30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode1.n,IdealDiode2.n) annotation(points = [ -20,50;6.12303e-16,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode2.n,IdealDiode3.n) annotation(points = [6.12303e-16,50;20,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode4.p,IdealDiode5.p) annotation(points = [ -20, -50; -6.12303e-16, -50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode5.p,IdealDiode6.p) annotation(points = [ -6.12303e-16, -50;20, -50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Capacitor2.n,IdealDiode6.p) annotation(points = [40, -50;20, -50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(IdealDiode3.n,Capacitor1.p) annotation(points = [20,50;40,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Capacitor1.n,Capacitor2.p) annotation(points = [40,30;40, -30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Capacitor2.p,Ground1.p) annotation(points = [40, -30;40,0;50,0;50, -60], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Capacitor1.p,SignalCurrent1.p) annotation(points = [40,50;60,50;60,10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SignalCurrent1.n,Capacitor2.n) annotation(points = [60, -10;60, -50;40, -50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Constant1.outPort,SignalCurrent1.inPort) annotation(points = [79,0;79,0.05;67.05,0.05], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Inductor1.n,IdealDiode1.p) annotation(points = [ -40,20; -20,20; -20,30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Inductor2.n,IdealDiode2.p) annotation(points = [ -40,0; -6.12303e-16,0; -6.12303e-16,30], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Inductor3.n,IdealDiode3.p) annotation(points = [ -40, -20;20, -20;20,30], style(color = 3, rgbcolor = {0,0,255}));
//         end Rectifier;
//         model ShowSaturatingInductor "Simple demo to show behaviour of SaturatingInductor component"
//           extends Modelica.Icons.Example;
//           parameter Modelica.SIunits.Inductance Lzer = 2;
//           parameter Modelica.SIunits.Inductance Lnom = 1;
//           parameter Modelica.SIunits.Current Inom = 1;
//           parameter Modelica.SIunits.Inductance Linf = 0.5;
//           parameter Modelica.SIunits.Voltage U = 1.25;
//           parameter Modelica.SIunits.Frequency f = 1 / (2 * Modelica.Constants.pi);
//           parameter Modelica.SIunits.Angle phase = Modelica.Constants.pi / 2;
//           output Modelica.SIunits.Voltage v;
//           output Modelica.SIunits.Current i;
//           annotation(Diagram, experiment(StopTime = 6.2832, Interval = 0.01), experimentSetupOutput(doublePrecision = true));
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V = U, phase = phase, freqHz = f) annotation(extent = [ -30, -10; -10,10], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(extent = [ -30, -30; -10, -10]);
//           Modelica.Electrical.Analog.Basic.SaturatingInductor SaturatingInductance1(Lzer = Lzer, Lnom = Lnom, Inom = Inom, Linf = Linf) annotation(extent = [12, -4;32,16], rotation =  -90);
// 
//         equation 
//           v = SaturatingInductance1.v;
//           i = SaturatingInductance1.i;
//           connect(SineVoltage1.n,Ground1.p) annotation(points = [ -20, -10; -20, -10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage1.n,SaturatingInductance1.n) annotation(points = [ -20, -10;22, -10;22, -4], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SaturatingInductance1.p,SineVoltage1.p) annotation(points = [22,16;22,26; -20,26; -20,10], style(color = 3, rgbcolor = {0,0,255}));
//         end ShowSaturatingInductor;
//         model ShowVariableResistor "Simple demo of a VariableResistor model"
//           extends Modelica.Icons.Example;
//           Modelica.Electrical.Analog.Basic.VariableResistor VariableResistor annotation(extent = [ -20, -20;0,0], rotation = 0);
//           Modelica.Electrical.Analog.Basic.Ground Ground1 annotation(extent = [ -100, -80; -80, -60]);
//           Modelica.Electrical.Analog.Basic.Ground Ground2 annotation(extent = [60, -40;80, -20]);
//           Modelica.Electrical.Analog.Basic.Resistor R1 annotation(extent = [ -60,40; -40,60]);
//           Modelica.Electrical.Analog.Basic.Resistor R2 annotation(extent = [ -20,40;0,60]);
//           Modelica.Electrical.Analog.Basic.Resistor R3 annotation(extent = [20,40;40,60]);
//           Modelica.Electrical.Analog.Basic.Resistor R4 annotation(extent = [ -60, -20; -40,0]);
//           Modelica.Electrical.Analog.Basic.Resistor R5 annotation(extent = [20, -20;40,0]);
//           annotation(Documentation(info = "<HTML>
// <P>
// It is a simple test circuit for the VariableResistor. The VariableResistor
// sould be compared with R2.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 6, 2004   </i>
//        by Teresa Schlegel<br> realized<br>
//        </li>
// </ul>
// </HTML>
// "), experiment(StopTime = 1), Diagram(Text(extent = [ -100,112;80,40], style(color = 3, rgbcolor = {0,0,255}), string = "Example VariableResistor")));
//           annotation(Diagram);
//           Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1 annotation(extent = [ -100, -40; -80, -20], rotation = 90);
//           Modelica.Blocks.Sources.Ramp Ramp1(height = {5}, offset = {2}) annotation(extent = [ -20,10;0,30], rotation = 270);
// 
//         equation 
//           connect(R1.n,R2.p) annotation(points = [ -40,50; -20,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(R2.n,R3.p) annotation(points = [0,50;20,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(R4.n,VariableResistor.p) annotation(points = [ -40, -10; -20, -10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(VariableResistor.n,R5.p) annotation(points = [0, -10;20, -10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(R3.n,Ground2.p) annotation(points = [40,50;70,50;70, -20], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Ground2.p,R5.n) annotation(points = [70, -20;70, -10;40, -10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage1.p,Ground1.p) annotation(points = [ -90, -40; -90, -60], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage1.n,R1.p) annotation(points = [ -90, -20; -90,50; -60,50], style(color = 3, rgbcolor = {0,0,255}));
//           connect(SineVoltage1.n,R4.p) annotation(points = [ -90, -20; -90, -10; -60, -10], style(color = 3, rgbcolor = {0,0,255}));
//           connect(Ramp1.outPort,VariableResistor.R_Port) annotation(points = [ -10,9; -10,4.5; -10,4.5; -10,0], style(color = 3, rgbcolor = {0,0,255}));
//         end ShowVariableResistor;
//       end Examples;
//       package Basic
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.54, height = 0.35, library = 1, autolayout = 1), Documentation(info = "<HTML>
// <p>
// This package contains basic analog electrical components:
// <ul>
// <li>Ground</li>
// <li>Resistor</li>
// <li>HeatingResistor</li>
// <li>Conductor</li>
// <li>Capacitor</li>
// <li>Inductor</li>
// <li>SaturatingInductor</li>
// <li>Transformer</li>
// <li>Gyrator</li>
// <li>EMF (Electroc-Motoric-Force)</li>
// <li>Linear controlled sources (VCV, VCC, CCV, CCC)</li>
// <li>OpAmp</li>
// <li>VariableResistor, VariableConductor, 
//     VariableCapacitor, VariableInductor</li>
// </ul>
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Basic.mo,v 1.16 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// </dl>
// </html>"));
//         model Ground "Ground node"
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<HTML>
// <P>
// Ground of an electrical circuit. The potential at the
// ground node is zero. Every electrical circuit has to contain
// at least one ground object.
// </P>
// </HTML>
// "), Icon(Line(points = [ -60,50;60,50]), Line(points = [ -40,30;40,30]), Line(points = [ -20,10;20,10]), Line(points = [0,90;0,50]), Text(extent = [ -100, -68;100, -10], string = "%name")), Diagram(Line(points = [ -60,50;60,50], style(thickness = 2)), Line(points = [ -40,30;40,30], style(thickness = 2)), Line(points = [ -20,10;20,10], style(thickness = 2)), Line(points = [0,90;0,50], style(thickness = 2)), Text(extent = [ -24, -38;22, -6], string = "p.v=0")), Window(x = 0.23, y = 0.23, width = 0.59, height = 0.63));
//           Interfaces.Pin p annotation(extent = [ -10,110;10,90], rotation =  -90);
// 
//         equation 
//           p.v = 0;
//         end Ground;
//         model Resistor "Ideal linear electrical resistor"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance R = 1 "Resistance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i*R = v</i>.
// The Resistance <i>R</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Text(extent = [ -98, -58;102, -120], string = "R=%R", style(color = 0)), Text(extent = [ -100,40;100,100], string = "%name")), Diagram(Rectangle(extent = [ -70,30;70, -30]), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0])), Window(x = 0.2, y = 0.06, width = 0.62, height = 0.69));
// 
//         equation 
//           R * i = v;
//         end Resistor;
//         model HeatingResistor "Temperature dependent electrical resistor"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance R_ref "Resistance at temperature T_ref";
//           parameter SI.Temperature T_ref = 300 "Reference temperature";
//           parameter Real alpha(unit = "1/K") = 0 "Temperature coefficient of resistance";
//           SI.Resistance R "Resistance = R_ref*(1 + alpha*(heatPort.T - T_ref));";
//           annotation(Diagram(Line(points = [ -110,20; -85,20], style(color = 9, fillColor = 9)), Polygon(points = [ -95,23; -85,20; -95,17; -95,23], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [90,20;115,20], style(color = 9, fillColor = 9)), Line(points = [ -125,0; -115,0], style(color = 9)), Line(points = [ -120, -5; -120,5], style(color = 9)), Text(extent = [ -110,25; -90,45], string = "i", style(color = 9)), Polygon(points = [105,23;115,20;105,17;105,23], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [115,0;125,0], style(color = 9)), Text(extent = [90,45;110,25], string = "i", style(color = 9)), Rectangle(extent = [ -70,30;70, -30]), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Line(points = [0, -30;0, -90], style(color = 42)), Line(points = [ -52, -50;48,50], style(color = 73, fillColor = 73)), Polygon(points = [40,52;50,42;54,56;40,52], style(color = 73, fillColor = 73))), Icon(Text(extent = [ -143,60;143,98], string = "%name"), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [0, -30;0, -91], style(color = 42)), Line(points = [ -52, -50;48,50], style(color = 73, fillColor = 73)), Polygon(points = [40,52;50,42;54,56;40,52], style(color = 73, fillColor = 73))), Documentation(info = "<HTML>
// <p>This is a model for an electrical resistor where the generated heat
// is dissipated to the environment via connector <b>heatPort</b> and where
// the resistance R is temperature dependent according to the following
// equation:</p>
// 
// <pre>    R = R_ref*(1 + alpha*(heatPort.T - T_ref))
// </pre>
// 
// <p><b>alpha</b> is the <b>temperature coefficient of resistance</b>, which
// is often abbreviated as <b>TCR</b>. In resistor catalogues, it is usually
// defined as <b>X [ppm/K]</b> (parts per million, similarly to per centage)
// meaning <b>X*1.e-6 [1/K]</b>. Resistors are available for 1 .. 7000 ppm/K,
// i.e., alpha = 1e-6 .. 7e-3 1/K;</p>
// 
// <p>When connector <b>heatPort</b> is <b>not</b> connected, the temperature
// dependent behaviour is switched off by setting heatPort.T = T_ref.
// Additionally, the equation <tt>heatPort.Q_dot = 0</tt> is implicitly present
// due to a special rule in Modelica that flow variables of not connected
// connectors are set to zero.</p>
// </HTML>
// "));
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort annotation(extent = [ -10, -90;10, -110], rotation =  -90);
// 
//         equation 
//           v = R * i;
//           if cardinality(heatPort) > 0 then
//             R = R_ref * (1 + alpha * (heatPort.T - T_ref));
//             heatPort.Q_dot =  -v * i;
// 
//           else
//             R = R_ref;
//             heatPort.T = T_ref;
// 
//           end if;
//         end HeatingResistor;
//         model Conductor "Ideal linear electrical conductor"
//           extends Interfaces.OnePort;
//           parameter SI.Conductance G = 1 "Conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear conductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i = v*G</i>.
// The Conductance <i>G</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Rectangle(extent = [ -70,30;70, -30], style(fillColor = 7, fillPattern = 1)), Rectangle(extent = [ -70,30;70, -30]), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Text(extent = [ -100, -60;100, -122], string = "G=%G", style(color = 0, pattern = 0)), Text(extent = [ -100,40;100,98], string = "%name")), Diagram(Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0])), Window(x = 0, y = 0.2, width = 0.63, height = 0.68));
// 
//         equation 
//           i = G * v;
//         end Conductor;
//         model Capacitor "Ideal linear electrical capacitor"
//           extends Interfaces.OnePort;
//           parameter SI.Capacitance C = 1 "Capacitance";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.32, y = 0.33, width = 0.48, height = 0.58), Documentation(info = "<HTML>
// <p>
// The linear capacitor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i = C * dv/dt</i>.
// The Capacitance <i>C</i> is allowed to be positive, zero, or negative.
// </p>
// </HTML>
// "), Icon(Line(points = [ -14,28; -14, -28], style(thickness = 2)), Line(points = [14,28;14, -28], style(thickness = 2)), Line(points = [ -90,0; -14,0]), Line(points = [14,0;90,0]), Text(extent = [ -100, -60;100, -120], string = "C=%C", style(color = 0)), Text(extent = [ -100,40;100,100], string = "%name")), Diagram(Line(points = [ -20,40; -20, -40], style(thickness = 2)), Line(points = [20,40;20, -40], style(thickness = 2)), Line(points = [ -90,0; -20,0]), Line(points = [20,0;90,0])));
// 
//         equation 
//           i = C * der(v);
//         end Capacitor;
//         model Inductor "Ideal linear electrical inductor"
//           extends Interfaces.OnePort;
//           parameter SI.Inductance L = 1 "Inductance";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<HTML>
// <P>
// The linear inductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by  <i>v = L * di/dt</i>.
// The Inductance <i>L</i> is allowed to be positive, zero, or negative.
// </p>
// </HTML>
// "), Icon(Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -30;60,0], style(color = 7, fillColor = 7)), Line(points = [60,0;90,0]), Line(points = [ -90,0; -60,0]), Text(extent = [ -100, -60;100, -120], string = "L=%L", style(color = 0)), Text(extent = [ -136,40;148,100], string = "%name")), Diagram(Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -30;60,0], style(color = 7, fillColor = 7)), Line(points = [60,0;90,0]), Line(points = [ -90,0; -60,0])), Window(x = 0.3, y = 0.12, width = 0.6, height = 0.6));
// 
//         equation 
//           L * der(i) = v;
//         end Inductor;
//         model SaturatingInductor "Simple model of an inductor with saturation"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Current Inom = 1 "Nominal current";
//           parameter Modelica.SIunits.Inductance Lnom = 1 "Nominal inductance at Nominal current";
//           parameter Modelica.SIunits.Inductance Lzer = 2 * Lnom "Inductance near current=0";
//           parameter Modelica.SIunits.Inductance Linf = Lnom / 2 "Inductance at large currents";
//         protected 
//           Modelica.SIunits.Inductance Lact(start = Lzer);
//           Modelica.SIunits.MagneticFlux Psi;
//           parameter Modelica.SIunits.Current Ipar(start = Inom / 10, fixed = false);
//           annotation(Icon(Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -20;60,0], style(color = 7, fillColor = 7)), Line(points = [60,0;90,0]), Line(points = [ -90,0; -60,0]), Rectangle(extent = [ -60, -10;60, -20], style(color = 3, rgbcolor = {0,0,255}, gradient = 3, fillColor = 3, rgbfillColor = {0,0,255})), Text(extent = [ -142,40;148,102], string = "%name"), Text(extent = [ -150, -48;150, -92], style(color = 0), string = "Lnom=%Lnom")), Documentation(info = "<HTML>
// <p>
// This model approximates the behaviour of an inductor with the influence of saturation,
// i.e. the value of the inductance depends on the current flowing through the inductor.
// The inductance decreases as current increases.<br>
// The parameters are:
// <ul>
// <li>Inom...nominal current</li>
// <li>Lnom...nominal inductance at nominal current</li>
// <li>Lzer...inductance near current = 0; Lzer has to be greater than Lnom</li>
// <li>Linf...inductance at large currents; Linf has to be less than Lnom</li>
// </ul>
// </p>
// </HTML>
// ", revisions = "<html>
// <dl>
// <p>
//   <dt><b>Main Author:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> May 27, 2004: Implemented by Anton Haumer</li>
//   </ul>
//   </dd>
// </dl>
// </html>"));
// 
//         initial equation 
//           Lnom - Linf = ((Lzer - Linf) * Ipar) / Inom * (Modelica.Constants.pi / 2 - arctan(Ipar / Inom));
// 
//         equation 
//           assert(Lzer > Lnom + Modelica.Constants.eps, "Lzer (= " + String(Lzer) + ") has to be > Lnom (= " + String(Lnom) + ")");
//           assert(Linf < Lnom - Modelica.Constants.eps, "Linf (= " + String(Linf) + ") has to be < Lnom (= " + String(Lnom) + ")");
//           ((Lact - Linf) * i) / Ipar = (Lzer - Linf) * noEvent(arctan(i / Ipar));
//           Psi = Lact * i;
//           v = der(Psi);
//         end SaturatingInductor;
//         model Transformer "Transformer with two ports"
//           extends Interfaces.TwoPort;
//           parameter SI.Inductance L1 = 1 "Primary inductance";
//           parameter SI.Inductance L2 = 1 "Secondary inductance";
//           parameter SI.Inductance M = 1 "Coupling inductance";
//           annotation(Documentation(info = "<HTML>
// <p>The transformer is a two port. The left port voltage <i>v1</i>, left port current <i>i1</i>,
// right port voltage <i>v2</i> and right port current <i>i2</i> are connected by the following
// relation:</p>
// <pre>         | v1 |         | L1   M  |  | i1' |
//          |    |    =    |         |  |     |
//          | v2 |         | M    L2 |  | i2' |</pre>
// <p><i>L1</i>, <i>L2</i>, and <i>M</i> are the primary, secondary, and coupling inductances respectively.</p>
// </html>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,128;100,70], string = "%name"), Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50]), Text(extent = [ -89,18; -60, -10], string = "L1"), Text(extent = [64,18;90, -10], string = "L2"), Text(extent = [ -18, -70;20, -98], string = "M")), Diagram(Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50])), Window(x = 0.26, y = 0.43, width = 0.6, height = 0.6));
// 
//         equation 
//           v1 = L1 * der(i1) + M * der(i2);
//           v2 = M * der(i1) + L2 * der(i2);
//         end Transformer;
//         model Gyrator "Gyrator"
//           extends Interfaces.TwoPort;
//           parameter SI.Conductance G1 = 1 "Gyration conductance";
//           parameter SI.Conductance G2 = 1 "Gyration conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// A gyrator is a two-port element defined by the following equations:
// </P>
// <PRE>
//     i1 =  G2 * v2
//     i2 = -G1 * v1
// </PRE>
// <P>
// where the constants <i>G1</i>, <i>G2</i> are called the gyration conductance.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,50;90,50]), Line(points = [60, -50;90, -50]), Line(points = [ -40,30;40,30]), Line(points = [ -20, -20;20, -20]), Polygon(points = [30,34;40,30;30,26;30,34], style(fillColor = 3, fillPattern = 1)), Polygon(points = [ -26, -19; -16, -15; -16, -23; -26, -19], style(fillColor = 3, fillPattern = 1)), Line(points = [ -5,10; -10, -10], style(thickness = 2)), Line(points = [9,10;4, -9], style(thickness = 2)), Line(points = [ -14,9;16,10], style(thickness = 2)), Text(extent = [ -100,130;100,69], string = "%name"), Text(extent = [ -29,59;30,30], string = "G1"), Text(extent = [ -29, -29;29, -58], string = "G2")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,50;90,50]), Line(points = [60, -50;90, -50]), Line(points = [ -40,30;40,30]), Line(points = [ -21, -22;19, -22]), Polygon(points = [30,34;40,30;30,26;30,34], style(fillColor = 3, fillPattern = 1)), Polygon(points = [ -20, -30; -10, -26; -10, -34; -20, -30], style(fillColor = 3, fillPattern = 1)), Line(points = [ -4,5; -6, -5], style(thickness = 4)), Line(points = [3,5;1, -5], style(thickness = 4)), Line(points = [ -8,5;7,5], style(thickness = 4)), Text(extent = [ -20,50;20,35], string = "G1"), Text(extent = [ -20, -35;20, -50], string = "G2")), Window(x = 0.4, y = 0.4, width = 0.6, height = 0.6));
// 
//         equation 
//           i1 = G2 * v2;
//           i2 =  -G1 * v1;
//         end Gyrator;
//         model EMF "Electromotoric force (electric/mechanic transformer)"
//           parameter Real k(final unit = "N.m/A") = 1 "Transformation coefficient";
//           SI.Voltage v "Voltage drop between the two pins";
//           SI.Current i "Current flowing from positive to negative pin";
//           SI.AngularVelocity w "Angular velocity of flange_b";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Line(points = [0,90;0,40]), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Ellipse(extent = [ -40,40;40, -40], style(fillColor = 7)), Line(points = [0, -90;0, -40]), Text(extent = [20, -40;100, -100], string = "%name"), Text(extent = [30,100;119,40], string = "k=%k", style(color = 9))), Diagram(Polygon(points = [ -17,95; -20,85; -23,95; -17,95], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [ -20,110; -20,85], style(color = 9, fillColor = 9)), Text(extent = [ -40,110; -30,90], string = "i", style(color = 9, fillColor = 9)), Line(points = [9,75;19,75], style(color = 8)), Line(points = [0,90;0,40]), Ellipse(extent = [ -40,40;40, -40]), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -20, -110; -20, -85], style(color = 9, fillColor = 9)), Polygon(points = [ -17, -100; -20, -110; -23, -100; -17, -100], style(color = 9, fillColor = 9, fillPattern = 1)), Text(extent = [ -40, -110; -30, -90], string = "i", style(color = 9)), Line(points = [8, -79;18, -79], style(color = 8)), Line(points = [0, -90;0, -40]), Line(points = [14,80;14,70], style(color = 8)), Line(points = [140,0;110,0], style(color = 0, fillColor = 0)), Text(extent = [114, -4;148, -14], string = "flange_b.phi"), Polygon(points = [140,3;150,0;140, -3;140,3;140,3], style(color = 0, fillColor = 0)), Text(extent = [112,16;148,6], string = "flange_b.tau"), Polygon(points = [120,35;100,40;100,30;120,35], style(color = 10, fillColor = 10)), Line(points = [30,35;101,35], style(color = 10, fillColor = 10)), Text(extent = [37,59;105,46], string = "rotation axis", style(color = 10))), Window(x = 0.21, y = 0, width = 0.65, height = 0.66), Documentation(info = "<HTML>
// <p>
// EMF transforms electrical energy into rotational mechanical energy.
// It is used as basic building block of an electrical motor. The mechanical
// connector flange_b can be connected to elements of the
// Modelica.Mechanics.Rotational library. flange_b.tau is the cut-torque,
// flange_b.phi is the angle at the rotational connection.
// </p>
// </HTML>
// "));
//           Interfaces.PositivePin p annotation(extent = [ -10,90;10,110], rotation = 90);
//           Interfaces.NegativePin n annotation(extent = [ -10, -110;10, -90], rotation = 90);
//           Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//           w = der(flange_b.phi);
//           k * w = v;
//           flange_b.tau =  -k * i;
//         end EMF;
//         model VCV "Linear voltage-controlled voltage source"
//           extends Interfaces.TwoPort;
//           parameter Real gain = 1 "Voltage gain";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear voltage-controlled voltage source is a TwoPort.
// The right port voltage v2 is controlled by the left port voltage v1
// via
// </p>
// 
// <pre>
//     v2 = v1 * gain.
// </pre>
// 
// <p>
// The left port current is zero. Any voltage gain can be chosen.
// </p>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0.02, width = 0.59, height = 0.92), Icon(Rectangle(extent = [ -70,70;70, -70], style(fillColor = 7)), Text(extent = [ -99, -79;100, -129], string = "%name"), Line(points = [ -90,50; -30,50]), Line(points = [ -30, -50; -90, -50]), Line(points = [100,50;30,50;30, -50;100, -50]), Ellipse(extent = [10,20;50, -20]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1))), Diagram(Line(points = [ -90,50; -30,50]), Line(points = [ -30, -50; -90, -50]), Line(points = [90,50;30,50;30, -50;90, -50]), Ellipse(extent = [10,20;50, -20]), Rectangle(extent = [ -70,70;70, -70]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1))));
// 
//         equation 
//           v2 = v1 * gain;
//           i1 = 0;
//         end VCV;
//         model VCC "Linear voltage-controlled current source"
//           extends Interfaces.TwoPort;
//           parameter SI.Conductance transConductance = 1 "Transconductance";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear voltage-controlled current source is a TwoPort.
// The right port current i2 is controlled by the left port voltage v1
// via
// </p>
// <pre>
//     i2 = v1 * transConductance.
// </pre>
// <p>
// The left port current is zero. Any transConductance can be chosen.
// </p>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -70,70;70, -70], style(fillColor = 7)), Text(extent = [ -99, -80;100, -129], string = "%name"), Line(points = [ -90,50; -30,50]), Line(points = [ -30, -50; -90, -50]), Ellipse(extent = [10,20;50, -20]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [90,50;30,50;30,20]), Line(points = [91, -50;30, -50;30, -20]), Line(points = [10,0;50,0])), Diagram(Line(points = [ -90,50; -30,50]), Line(points = [ -30, -50; -90, -50]), Ellipse(extent = [10,20;50, -20]), Rectangle(extent = [ -70,70;70, -70]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [90,50;30,50;30,20]), Line(points = [91, -50;30, -50;30, -20]), Line(points = [10,0;50,0])), Window(x = 0.34, y = 0.05, width = 0.6, height = 0.6));
// 
//         equation 
//           i2 = v1 * transConductance;
//           i1 = 0;
//         end VCC;
//         model CCV "Linear current-controlled voltage source"
//           extends Interfaces.TwoPort;
//           parameter SI.Resistance transResistance = 1 "Transresistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear current-controlled voltage source is a TwoPort.
// The right port voltage v2 is controlled by the left port current i1
// via
// </p>
// <pre>
//     v2 = i1 * transResistance.
// </pre>
// <p>
// The left port voltage is zero. Any transResistance can be chosen.
// </p>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -70,70;70, -70], style(fillColor = 7)), Text(extent = [ -99, -80;100, -130], string = "%name"), Line(points = [100,50;30,50;30, -50;100, -50]), Ellipse(extent = [10,20;50, -20]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [ -90,50; -20,50; -20, -50; -90, -50])), Diagram(Ellipse(extent = [10,20;50, -20]), Rectangle(extent = [ -70,70;70, -70]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [90,50;30,50;30, -50;90, -50]), Line(points = [ -90,50; -30,50; -30, -50; -90, -50])), Window(x = 0.3, y = 0.13, width = 0.6, height = 0.6));
// 
//         equation 
//           v2 = i1 * transResistance;
//           v1 = 0;
//         end CCV;
//         model CCC "Linear current-controlled current source"
//           extends Interfaces.TwoPort;
//           parameter Real gain = 1 "Current gain";
//           annotation(Documentation(info = "<HTML>
// <p>
// The linear current-controlled current source is a TwoPort.
// The right port current i2 is controlled by the left port current i1
// via
// </p>
// 
// <pre>
//     i2 = i1 * gain.
// </pre>
// 
// <p>
// The left port voltage is zero. Any current gain can be chosen.
// </p>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -70,70;70, -70], style(fillColor = 7)), Text(extent = [ -104, -76;97, -127], string = "%name"), Line(points = [ -100,50; -30,50; -30, -50; -100, -50]), Ellipse(extent = [10,20;50, -20]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [90,50;30,50;30,20]), Line(points = [91, -50;30, -50;30, -20]), Line(points = [10,0;50,0])), Diagram(Ellipse(extent = [10,20;50, -20]), Rectangle(extent = [ -70,70;70, -70]), Line(points = [ -20,60;20,60]), Polygon(points = [20,60;10,63;10,57;20,60], style(fillColor = 3, fillPattern = 1)), Line(points = [90,50;30,50;30,20]), Line(points = [91, -50;30, -50;30, -20]), Line(points = [10,0;50,0]), Line(points = [ -90,50; -30,50; -30, -50; -91, -50])), Window(x = 0.31, y = 0.09, width = 0.6, height = 0.6));
// 
//         equation 
//           i2 = i1 * gain;
//           v1 = 0;
//         end CCC;
//         model OpAmp "Simple nonideal model of an OpAmp with limitation"
//           annotation(Documentation(info = "<HTML>
// <P>
// The OpAmp is a simle nonideal model with a smooth out.v = f(vin) characteristic,
// where \"vin = in_p.v - in_n.v\".
// The characteristic is limited by VMax.v and VMin.v. Its slope at vin=0
// is the parameter Slope, which must be positive. (Therefore, the absolute 
// value of Slope is taken into calculation.)
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -95,88;115,146], string = "%name"), Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -45, -10; -20, -10; -14, -9; -11, -7; -9,7; -6,9;0,10;20,10]), Line(points = [0,35;0,80]), Line(points = [0, -35;0, -80]), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -48,32; -28,32]), Line(points = [ -39, -20; -39, -41]), Line(points = [ -50, -31; -28, -31])), Diagram(Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -45, -10; -20, -10; -14, -9; -11, -7; -9,7; -6,9;0,10;20,10]), Line(points = [0,35;0,80]), Line(points = [0, -35;0, -80]), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -55,50; -45,50]), Line(points = [ -50, -45; -50, -55]), Line(points = [ -55, -50; -45, -50]), Text(extent = [ -112, -93; -91, -73], style(color = 9, fillColor = 9), string = "in_p.i=0"), Polygon(points = [120,3;110,0;120, -3;120,3], style(color = 9, gradient = 2, fillColor = 9, fillPattern = 1)), Line(points = [111,0;136,0], style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [118,2;135,17], string = "i2", style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [ -111,60; -85,80], style(color = 9, fillColor = 9), string = "in_n.i=0"), Line(points = [ -100, -35; -100,23; -100,24], style(color = 9, arrow = 1)), Text(extent = [ -97, -16; -74,4], style(color = 9, fillColor = 9), string = "vin")), Window(x = 0.28, y = 0.19, width = 0.71, height = 0.59));
//           parameter Real Slope = 1 "Slope of the out.v/vin characteristic at vin=0";
//           Modelica.Electrical.Analog.Interfaces.PositivePin in_p "Positive pin of the input port" annotation(extent = [ -110, -60; -90, -40]);
//           Modelica.Electrical.Analog.Interfaces.NegativePin in_n "Negative pin of the input port" annotation(extent = [ -110,40; -90,60]);
//           Modelica.Electrical.Analog.Interfaces.PositivePin out "Output pin" annotation(extent = [90, -10;110,10]);
//           Modelica.Electrical.Analog.Interfaces.PositivePin VMax "Positive output voltage limitation" annotation(extent = [ -10,60;10,80]);
//           Modelica.Electrical.Analog.Interfaces.NegativePin VMin "Negative output voltage limitation" annotation(extent = [ -10, -80;10, -60]);
//           SI.Voltage vin "input voltagae";
//         protected 
//           Real f "auxiliary variable";
//           Real absSlope;
// 
//         equation 
//           in_p.i = 0;
//           in_n.i = 0;
//           VMax.i = 0;
//           VMin.i = 0;
//           vin = in_p.v - in_n.v;
//           f = 2 / (VMax.v - VMin.v);
//           absSlope = if Slope < 0 then  -Slope else Slope;
//           out.v = (VMax.v + VMin.v) / 2 + (absSlope * vin) / (1 + absSlope * noEvent(if f * vin < 0 then  -f * vin else f * vin));
//         end OpAmp;
//         model VariableResistor "Ideal linear electrical resistor with variable resistance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.Blocks.Interfaces.InPort R_Port(final n = 1) annotation(extent = [ -10,90;10,110], rotation =  -90);
//         protected 
//           Modelica.SIunits.Resistance R;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i*R = v</i></b>
// </P>
// <P>
// The Resistance <i>R</i> is defined by the R_Port signal.
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that the R_Port signal should not cross the zero value. Otherwise 
//   depending on the surrounding circuit the probability of singularities is high. <br>
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Text(extent = [ -100, -100;100, -40], string = "%name"), Line(points = [ -90,0; -70,0]), Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [70,0;90,0]), Line(points = [0,90;0,30], style(color = 73))), Diagram);
// 
//         equation 
//           R = R_Port.signal[1];
//           v = R * i;
//         end VariableResistor;
//         model VariableConductor "Ideal linear electrical conductor with variable conductance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.Blocks.Interfaces.InPort G_Port(final n = 1) annotation(extent = [ -10,90;10,110], rotation =  -90);
//         protected 
//           Modelica.SIunits.Conductance G "Conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear conductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i = G*v</i></b>
// </P>
// <P>
// The Conductance <i>G</i> is defined by the G_Port signal.
// 
// </P>
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that the G_Port signal should not cross the zero value. Otherwise 
//   depending on the surrounding circuit the probability of singularities is high. <br>
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Text(extent = [ -100, -100;100, -40], string = "%name"), Line(points = [ -90,0; -70,0]), Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [70,0;90,0]), Line(points = [0,90;0,30], style(color = 73))), Diagram);
// 
//         equation 
//           G = G_Port.signal[1];
//           i = G * v;
//         end VariableConductor;
//         model VariableCapacitor "Ideal linear electrical capacitor with variable capacitance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.Blocks.Interfaces.InPort C_Port(final n = 1) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           parameter Modelica.SIunits.Capacitance Cmin = Modelica.Constants.eps;
//           Modelica.SIunits.ElectricCharge Q;
//         protected 
//           Modelica.SIunits.Capacitance C;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear capacitor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>i = dQ/dt</i></b>  with <b><i>Q = C * v</i> </b>.
// </P>
// <P>
// The capacitance <i>C</i> is defined by the C_Port signal.
// </P>
// <P>
// It is required that C_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// C = Cmin, if 0 &le; C_Port.signal &lt; Cmin, where
// Cmin is a parameter with default value Modelica.Constants.eps.
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Icon(Text(extent = [ -100, -100;100, -40], string = "%name"), Line(points = [ -90,0; -14,0]), Line(points = [14,0;90,0]), Line(points = [0,90;0,30], style(color = 73)), Line(points = [ -14,28; -14, -28], style(thickness = 2)), Line(points = [14,28;14, -28], style(thickness = 2))), Diagram);
// 
//         equation 
//           assert(C_Port.signal[1] >= 0, "Capacitance C_Port.signal[1] (= " + String(C_Port.signal[1]) + ") has to be >= 0!");
//           C = noEvent(max(C_Port.signal[1], Cmin));
//           Q = C * v;
//           i = der(Q);
//         end VariableCapacitor;
//         model VariableInductor "Ideal linear electrical inductor with variable inductance"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.Blocks.Interfaces.InPort L_Port(final n = 1) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           Modelica.SIunits.MagneticFlux Psi;
//           parameter Modelica.SIunits.Inductance Lmin = Modelica.Constants.eps;
//         protected 
//           Modelica.SIunits.Inductance L;
//           annotation(Documentation(info = "<HTML>
// <P>
// The linear inductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <br><br>
//       <b> <i>v = d Psi/dt </i></b>   with  <b><i>Psi = L * i </i></b>.
// </P>
// <P>
// The inductance <i>L</i> is defined by the L_Port signal.
// </P>
// <P>
// It is required that L_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// L = Lmin, if 0 &le; L_Port.signal &lt; Lmin, where
// Lmin is a parameter with default value Modelica.Constants.eps.
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>June 7, 2004   </i>
//        by Christoph Clauss<br>changed, docu added<br>
//        </li>
// <li><i>April 30, 2004</i>
//        by Anton Haumer<br>implemented.
//        </li>
// </ul>
// </html>"), Icon(Text(extent = [ -100, -100;100, -40], string = "%name"), Line(points = [ -90,0; -60,0]), Line(points = [60,0;90,0]), Line(points = [0,90;0,8], style(color = 73)), Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -30;60,0], style(color = 7, fillColor = 7))), Diagram);
// 
//         equation 
//           assert(L_Port.signal[1] >= 0, "Inductance L_Port.signal[1] (= " + String(L_Port.signal[1]) + ") has to be >= 0!");
//           L = noEvent(max(L_Port.signal[1], Lmin));
//           Psi = L * i;
//           v = der(Psi);
//         end VariableInductor;
//       end Basic;
//       package Ideal
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.5, height = 0.36, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains electrical components with idealized behaviour:
// </p>
// <ul>
// <li>thyristor</li>
// <li>GTO thyristor</li>
// <li>switches (basic, commuting, intermediate, controlled, 
//     controlled commuting, controlled intermediate)</li>
// <li>operational amplifier</li>
// <li>operational amplifier (3 Pins)</li>
// <li>operational amplifier with limits</li>
// <li>diode</li>
// <li>transformer</li>
// <li>gyrator</li>
// <li>idle branch</li>
// <li>short cut</li>
// <li>opener</li>
// <li>closer</li>
// <li>controlled opener</li>
// <li>controlled closer</li>
// </ul>
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Ideal.mo,v 1.13 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         model IdealThyristor "Ideal thyristor"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Roff(final min = 0) = 1e-05 "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Gon(final min = 0) = 1e-05 "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           annotation(Documentation(info = "<html>
// This is an ideal thyristor model which is<br><br>
// <b>open </b>(off), if the voltage drop is less than 0 or the firePort is false<br>
// <b>closed</b> (on), if the voltage drop is greater or equal 0  and the firePort is true.<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// thyristor has a small conductance <i>Gon</i> and the closed thyristor has a low
// resistance <i>Roff</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Gon</i>-characteristic until <i>v = Vknee</i>.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100, -70;100, -100], string = "%name"), Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3)), Line(points = [30,20;70,60;70,90]), Line(points = [40,50;60,30])), Diagram(Line(points = [ -80,0;80,0], style(color = 10)), Polygon(points = [70,4;80,0;70, -4;70,4], style(color = 10, fillColor = 10)), Line(points = [0,80;0, -80], style(color = 10, fillColor = 10, fillPattern = 1)), Polygon(points = [ -4,70;0,80;4,70; -4,70], style(color = 10, fillColor = 10, fillPattern = 1)), Text(extent = [10,80;20,70], style(color = 10, fillColor = 10, fillPattern = 1), string = "i"), Text(extent = [70, -10;80, -20], style(color = 10, fillColor = 10, fillPattern = 1), string = "v"), Line(points = [ -80, -40; -20, -10;20,10;40,70], style(color = 0, thickness = 2, fillColor = 10, fillPattern = 1)), Line(points = [20,9;20,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1)), Text(extent = [20,0;40, -10], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Vknee"), Text(extent = [20,70;40,60], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Roff"), Text(extent = [ -20,10;0,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Gon"), Ellipse(extent = [18,12;22,8], style(pattern = 3, fillPattern = 1)), Line(points = [20,10;70,40], style(color = 0, thickness = 2, fillPattern = 1))), Window(x = 0.27, y = 0.18, width = 0.6, height = 0.6));
//         public 
//           Modelica.Blocks.Interfaces.BooleanInPort firePort(final n = 1) annotation(extent = [60,90;80,110], rotation =  -90);
// 
//         equation 
//           off = s < 0 or pre(off) and not firePort.signal[1];
//           v = s * (if off then 1 else Roff) + Vknee;
//           i = s * (if off then Gon else 1) + Gon * Vknee;
//         end IdealThyristor;
//         model IdealGTOThyristor "Ideal GTO thyristor"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Roff(final min = 0) = 1e-05 "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Gon(final min = 0) = 1e-05 "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           annotation(Documentation(info = "<html>
// This is an ideal GTO thyristor model which is<br><br>
// <b>open </b>(off), if the voltage drop is less than 0 or the firePort is false<br>
// <b>closed</b> (on), if the voltage drop is greater or equal 0  and the firePort is true.<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// thyristor has a small conductance <i>Gon</i> and the closed thyristor has a low
// resistance <i>Roff</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Gon</i>-characteristic until <i>v = Vknee</i>.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// 
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100, -70;100, -100], string = "%name"), Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3)), Line(points = [30,20;70,60;70,90]), Line(points = [40,50;60,30])), Diagram(Line(points = [ -80,0;80,0], style(color = 10)), Polygon(points = [70,4;80,0;70, -4;70,4], style(color = 10, fillColor = 10)), Line(points = [0,80;0, -80], style(color = 10, fillColor = 10, fillPattern = 1)), Polygon(points = [ -4,70;0,80;4,70; -4,70], style(color = 10, fillColor = 10, fillPattern = 1)), Text(extent = [10,80;20,70], style(color = 10, fillColor = 10, fillPattern = 1), string = "i"), Text(extent = [70, -10;80, -20], style(color = 10, fillColor = 10, fillPattern = 1), string = "v"), Line(points = [ -80, -40; -20, -10;20,10;40,70], style(color = 0, thickness = 2, fillColor = 10, fillPattern = 1)), Line(points = [20,9;20,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1)), Text(extent = [20,0;40, -10], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Vknee"), Text(extent = [20,70;40,60], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Roff"), Text(extent = [ -20,10;0,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Gon"), Ellipse(extent = [18,12;22,8], style(pattern = 3, fillPattern = 1)), Line(points = [20,10;70,40], style(color = 0, thickness = 2, fillPattern = 1))), Window(x = 0.27, y = 0.13, width = 0.6, height = 0.6));
//         public 
//           Modelica.Blocks.Interfaces.BooleanInPort firePort(final n = 1) annotation(extent = [60,90;80,110], rotation =  -90);
// 
//         equation 
//           off = s < 0 or not firePort.signal[1];
//           v = s * (if off then 1 else Roff) + Vknee;
//           i = s * (if off then Gon else 1) + Gon * Vknee;
//         end IdealGTOThyristor;
//         model IdealSwitch "Ideal electrical switch"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance Roff(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Gon(final min = 0) = 1e-05 "Opened switch conductance";
//         protected 
//           Real s "Auxiliary variable";
//           Boolean off;
//         public 
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = 1, signal(start = {false})) "true/false opened/closed switch" annotation(extent = [ -10,50;10,70], rotation =  -90);
//           annotation(Documentation(info = "<html>
// <P>
// Ideal electrical switch. In order to prevent singularities
// during switching, the opened switch has a high resistance
// and the closed switch has a low resistance.
// </P>
// <P>
// If the actual circuit has an appropriate structure, the
// limiting case is also allowed, i.e., the resistance of the
// closed switch could be exactly zero and the conductance of the
// open switch could be also exactly zero (i.e. the resistance is
// infinite). Note, there are circuits, where a description
// with zero/infinity resistances is not possible.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0.13, width = 0.56, height = 0.63), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name"), Line(points = [0,51;0,26])), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -40;100, -79], string = "%name"), Line(points = [0,51;0,26])));
// 
//         equation 
//           off = control.signal[1];
//           v = s * (if off then 1 else Roff);
//           i = s * (if off then Gon else 1);
//         end IdealSwitch;
//         model IdealCommutingSwitch "Ideal commuting switch"
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The commuting switch has a positive pin p and two negative pins n1 and n2. 
// The switching behaviour is controlled
// by the control signal. If the control signal is true, the pin p is connected 
// with the negative pin n2. Otherwise, the pin p is connected to the negative pin n1.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -44,4; -36, -4]), Text(extent = [ -80,0; -60,22], string = "p"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Text(extent = [ -80,0; -60,22], string = "p"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Window(x = 0.21, y = 0.05, width = 0.6, height = 0.6));
//         public 
//           Interfaces.PositivePin p annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n2 annotation(extent = [90, -10;110,10]);
//           Interfaces.NegativePin n1 annotation(extent = [90,40;110,60]);
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = 1) "true => p--n2 connected, false => p--n1 connected" annotation(extent = [ -10,70;10,90], rotation =  -90);
//         protected 
//           Real s1;
//           Real s2 "Auxiliary variables";
//           Boolean off;
// 
//         equation 
//           off = control.signal[1];
//           0 = p.i + n2.i + n1.i;
//           p.v - n1.v = s1 * (if off then 1 else Ron);
//           n1.i =  -s1 * (if off then Goff else 1);
//           p.v - n2.v = s2 * (if off then Ron else 1);
//           n2.i =  -s2 * (if off then 1 else Goff);
//         end IdealCommutingSwitch;
//         model IdealIntermediateSwitch "Ideal intermediate switch"
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The intermediate switch has four switching contact pins p1, p2, n1, and n2. 
// The switching behaviour is controlled by the control signal. If the control 
// signal is true, the pin p1 is connected to pin n2, and the pin p2 is 
// connected to the pin n2. Otherwise, the pin p1 is connected to n1, and
// p2 is connected to n2.
// </P>
// 
// <IMG SRC=\"../Images/IdealIntermediateSwitch1.png\" ALT=\"IdealIntermediateSwitch1\">
// 
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// </P>
// 
// <IMG SRC=\"../Images/IdealIntermediateSwitch2.png\" ALT=\"IdealIntermediateSwitch2\">
// 
// <P>
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -4,30;4,22]), Text(extent = [ -80,50; -60,72], string = "p1"), Text(extent = [ -80,0; -60,22], string = "p2"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -90,50; -44,50]), Line(points = [ -44,0;40,50]), Line(points = [ -44,50;40,0]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -4,30;4,22]), Text(extent = [ -80,50; -60,72], string = "p1"), Text(extent = [ -80,0; -60,22], string = "p2"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -90,50; -44,50]), Line(points = [ -44,0;40,50]), Line(points = [ -44,50;40,0]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Window(x = 0.21, y = 0.05, width = 0.6, height = 0.6));
//         public 
//           Interfaces.PositivePin p1 annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePin p2 annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n1 annotation(extent = [90,40;110,60]);
//           Interfaces.NegativePin n2 annotation(extent = [90, -10;110,10]);
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = 1) "true => p1--n2, p2--n1 connected,
//          otherwise p1--n1, p2--n2  connected" annotation(extent = [ -10,70;10,90], rotation =  -90);
//         protected 
//           Real s1;
//           Real s2;
//           Real s3;
//           Real s4 "Auxiliary variables";
//           Boolean off;
// 
//         equation 
//           off = control.signal[1];
//           p1.v - n1.v = s1 * (if off then 1 else Ron);
//           p2.v - n2.v = s2 * (if off then 1 else Ron);
//           p1.v - n2.v = s3 * (if off then Ron else 1);
//           p2.v - n1.v = s4 * (if off then Ron else 1);
//           p1.i = if off then s1 * Goff + s3 else s1 + s3 * Goff;
//           p2.i = if off then s2 * Goff + s4 else s2 + s4 * Goff;
//           n1.i = if off then  -s1 * Goff - s4 else  -s1 - s4 * Goff;
//           n2.i = if off then  -s2 * Goff - s3 else  -s2 - s3 * Goff;
//         end IdealIntermediateSwitch;
//         model ControlledIdealSwitch "Controlled ideal switch"
//           parameter SI.Voltage level = 0.5 "Switch level";
//           parameter SI.Resistance Roff(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Gon(final min = 0) = 1e-05 "Opened switch conductance";
//         protected 
//           Real s "Auxiliary variable";
//           annotation(Documentation(info = "<html>
// <P>
// The ideal switch is a three-pole. If the third pin voltage exceeds the given
// parameter Voltage, the pins <i>p</i> and <i>n</i> are open (no current flowing, any voltage
// possible). Otherwise, <i>p</i> and <i>n</i> are short cut.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.24, y = 0.27, width = 0.76, height = 0.57), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25])));
//         public 
//           Interfaces.Pin p "Positive pin" annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.Pin n "Negative pin" annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin control "Control pin: control.v > level open, otherwise closed" annotation(extent = [ -10,90;10,110], rotation = 90);
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n.i;
//           p.v - n.v = s * (if control.v < level then Roff else 1);
//           n.i = s * (if control.v < level then 1 else Gon);
//         end ControlledIdealSwitch;
//         model ControlledIdealCommutingSwitch "Controlled ideal commuting switch"
//           parameter SI.Voltage level = 0.5 "Switch level";
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The commuting switch has a positive pin p and two negative pins n1 and n2. 
// The switching behaviour is controlled
// by the control pin. If its voltage exceeds the value of the parameter level,
// the pin p is connected with the negative pin n2. Otherwise, the pin p is 
// connected the negative pin n1.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -44,4; -36, -4]), Text(extent = [ -80,0; -60,22], string = "p"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Text(extent = [ -80,0; -60,22], string = "p"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Window(x = 0.21, y = 0.05, width = 0.6, height = 0.6));
//         public 
//           Interfaces.PositivePin p annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n2 annotation(extent = [90, -10;110,10]);
//           Interfaces.NegativePin n1 annotation(extent = [90,40;110,60]);
//           Interfaces.Pin control "Control pin: if control.v > level p--n2 connected, otherwise p--n1 connected" annotation(extent = [ -10,90;10,110], rotation = 90);
//         protected 
//           Real s1;
//           Real s2 "Auxiliary variables";
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n2.i + n1.i;
//           p.v - n1.v = s1 * (if control.v > level then 1 else Ron);
//           n1.i =  -s1 * (if control.v > level then Goff else 1);
//           p.v - n2.v = s2 * (if control.v > level then Ron else 1);
//           n2.i =  -s2 * (if control.v > level then 1 else Goff);
//         end ControlledIdealCommutingSwitch;
//         model ControlledIdealIntermediateSwitch "Controlled ideal intermediate switch"
//           parameter SI.Voltage level = 0.5 "Switch level";
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance";
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance";
//           annotation(Documentation(info = "<HTML>
// <P>
// The intermediate switch has four switching contact pins p1, p2, n1, and n2. 
// The switching behaviour is controlled
// by the control pin. If its voltage exceeds the value of the 
// parameter level, the pin p1 is connected to pin n2, and the pin p2 is 
// connected to the pin n2. Otherwise, the pin p1 is connected to n1, and
// p2 is connected to n2.
// </P>
// 
// <IMG SRC=\"../Images/ControlledIdealIntermediateSwitch1.png\" ALT=\"ControlledIdealIntermediateSwitch1\">
// 
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// </P>
// 
// <IMG SRC=\"../Images/ControlledIdealIntermediateSwitch2.png\" ALT=\"ControlledIdealIntermediateSwitch2\">
// 
// <P>
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -4,30;4,22]), Text(extent = [ -80,50; -60,72], string = "p1"), Text(extent = [ -80,0; -60,22], string = "p2"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -90,50; -44,50]), Line(points = [ -44,0;40,50]), Line(points = [ -44,50;40,0]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -4,30;4,22]), Text(extent = [ -80,50; -60,72], string = "p1"), Text(extent = [ -80,0; -60,22], string = "p2"), Text(extent = [60,50;80,72], string = "n1"), Text(extent = [60,0;80,22], string = "n2"), Line(points = [ -90,0; -44,0]), Line(points = [ -90,50; -44,50]), Line(points = [ -44,0;40,50]), Line(points = [ -44,50;40,0]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Window(x = 0.21, y = 0.05, width = 0.6, height = 0.6));
//         public 
//           Interfaces.PositivePin p1 annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePin p2 annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n1 annotation(extent = [90,40;110,60]);
//           Interfaces.NegativePin n2 annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin control "Control pin: if control.v > level p1--n2, p2--n1 connected,
//          otherwise p1--n1, p2--n2  connected" annotation(extent = [ -10,90;10,110], rotation = 90);
//         protected 
//           Real s1;
//           Real s2;
//           Real s3;
//           Real s4 "Auxiliary variables";
// 
//         equation 
//           control.i = 0;
//           p1.v - n1.v = s1 * (if control.v > level then 1 else Ron);
//           p2.v - n2.v = s2 * (if control.v > level then 1 else Ron);
//           p1.v - n2.v = s3 * (if control.v > level then Ron else 1);
//           p2.v - n1.v = s4 * (if control.v > level then Ron else 1);
//           p1.i = if control.v > level then s1 * Goff + s3 else s1 + s3 * Goff;
//           p2.i = if control.v > level then s2 * Goff + s4 else s2 + s4 * Goff;
//           n1.i = if control.v > level then  -s1 * Goff - s4 else  -s1 - s4 * Goff;
//           n2.i = if control.v > level then  -s2 * Goff - s3 else  -s2 - s3 * Goff;
//         end ControlledIdealIntermediateSwitch;
//         model IdealOpAmp "Ideal operational amplifier (norator-nullator pair)"
//           SI.Voltage v1 "Voltage drop over the left port";
//           SI.Voltage v2 "Voltage drop over the right port";
//           SI.Current i1 "Current flowing from pos. to neg. pin of the left port";
//           SI.Current i2 "Current flowing from pos. to neg. pin of the right port";
//           annotation(Documentation(info = "<html>
// <P>
// The ideal OpAmp is a two-port. The left port is fixed to <i>v1=0</i> and <i>i1=0</i>
// (nullator). At the right port both any voltage <i>v2</i> and any current <i>i2</i>
// are possible (norator).
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [0, -35;0, -91]), Line(points = [ -48,32; -28,32]), Line(points = [ -39, -20; -39, -41]), Line(points = [ -50, -31; -28, -31])), Diagram(Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [0, -35;0, -91]), Line(points = [ -55,50; -45,50]), Line(points = [ -50, -45; -50, -55]), Line(points = [ -55, -50; -45, -50]), Text(extent = [ -111, -39; -90, -19], string = "p1.i=0", style(color = 9, fillColor = 9)), Polygon(points = [120,3;110,0;120, -3;120,3], style(color = 9, gradient = 2, fillColor = 9, fillPattern = 1)), Line(points = [111,0;136,0], style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [118,2;135,17], string = "i2", style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [ -111,60; -90,80], string = "n1.i=0", style(color = 9, fillColor = 9)), Line(points = [18, -111;18, -86], style(color = 9, fillColor = 9)), Polygon(points = [21, -101;18, -111;15, -101;21, -101], style(color = 9, fillColor = 9, fillPattern = 1)), Text(extent = [22, -100;39, -85], string = "i2", style(color = 9, gradient = 2, fillColor = 9))), Window(x = 0.28, y = 0.19, width = 0.71, height = 0.59));
//           Interfaces.PositivePin p1 "Positive pin of the left port" annotation(extent = [ -110, -60; -90, -40]);
//           Interfaces.NegativePin n1 "Negative pin of the left port" annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePin p2 "Positive pin of the right port" annotation(extent = [90, -10;110,10]);
//           Interfaces.NegativePin n2 "Negative pin of the right port" annotation(extent = [ -10, -90;10, -110], rotation =  -90);
// 
//         equation 
//           v1 = p1.v - n1.v;
//           v2 = p2.v - n2.v;
//           0 = p1.i + n1.i;
//           0 = p2.i + n2.i;
//           i1 = p1.i;
//           i2 = p2.i;
//           v1 = 0;
//           i1 = 0;
//         end IdealOpAmp;
//         model IdealOpAmp3Pin "Ideal operational amplifier (norator-nullator pair), but 3 pins"
//           annotation(Documentation(info = "<html>
// <P>
// The ideal OpAmp with three pins is of exactly the same behaviour as the ideal
// OpAmp with four pins. Only the negative output pin is left out.
// Both the input voltage and current are fixed to zero (nullator).
// At the output pin both any voltage <i>v2</i> and any current <i>i2</i>
// are possible.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -48,32; -28,32]), Line(points = [ -39, -20; -39, -41]), Line(points = [ -50, -31; -28, -31])), Diagram(Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -55,50; -45,50]), Line(points = [ -50, -45; -50, -55]), Line(points = [ -55, -50; -45, -50]), Text(extent = [ -111, -39; -90, -19], string = "p1.i=0", style(color = 9, fillColor = 9)), Polygon(points = [120,3;110,0;120, -3;120,3], style(color = 9, gradient = 2, fillColor = 9, fillPattern = 1)), Line(points = [111,0;136,0], style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [118,2;135,17], string = "i2", style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [ -111,60; -90,80], string = "n1.i=0", style(color = 9, fillColor = 9))), Window(x = 0.28, y = 0.19, width = 0.71, height = 0.59));
//           Interfaces.PositivePin in_p "Positive pin of the input port" annotation(extent = [ -110, -60; -90, -40]);
//           Interfaces.NegativePin in_n "Negative pin of the input port" annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePin out "Output pin" annotation(extent = [90, -10;110,10]);
// 
//         equation 
//           in_p.v = in_n.v;
//           in_p.i = 0;
//           in_n.i = 0;
//         end IdealOpAmp3Pin;
//         model IdealOpAmpLimited "Ideal operational amplifier with limitation"
//           annotation(Documentation(info = "<HTML>
// <P>
// The ideal OpAmp with limitation behaves like an ideal OpAmp without limitation,
// if the output voltage is within the limits (VMin < out.v < VMax). In this case
// the input voltage vin=in_p.v - in_n.v is zero.
// If the input voltage is vin < 0, the output voltage is out.v = VMin.
// If the input voltage is vin > 0, the output voltage is out.v = VMax.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -110,80;100,90], string = "%name"), Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -45, -10; -10, -10; -10,10;20,10]), Line(points = [0,35;0,80]), Line(points = [0, -35;0, -80]), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -48,32; -28,32]), Line(points = [ -39, -20; -39, -41]), Line(points = [ -50, -31; -28, -31])), Diagram(Polygon(points = [60,0; -60,70; -60, -70;60,0], style(fillColor = 7)), Line(points = [ -45, -10; -10, -10; -10,10;20,10]), Line(points = [0,35;0,80]), Line(points = [0, -35;0, -80]), Line(points = [ -90,50; -60,50]), Line(points = [ -90, -50; -60, -50]), Line(points = [60,0;90,0]), Line(points = [ -55,50; -45,50]), Line(points = [ -50, -45; -50, -55]), Line(points = [ -55, -50; -45, -50]), Text(extent = [ -111, -39; -90, -19], string = "p1.i=0", style(color = 9, fillColor = 9)), Polygon(points = [120,3;110,0;120, -3;120,3], style(color = 9, gradient = 2, fillColor = 9, fillPattern = 1)), Line(points = [111,0;136,0], style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [118,2;135,17], string = "i2", style(color = 9, gradient = 2, fillColor = 9)), Text(extent = [ -111,60; -90,80], string = "n1.i=0", style(color = 9, fillColor = 9))), Window(x = 0.28, y = 0.19, width = 0.71, height = 0.59));
//           Interfaces.PositivePin in_p "Positive pin of the input port" annotation(extent = [ -110, -60; -90, -40]);
//           Interfaces.NegativePin in_n "Negative pin of the input port" annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePin out "Output pin" annotation(extent = [90, -10;110,10]);
//           Interfaces.PositivePin VMax "Positive output voltage limitation" annotation(extent = [ -10,60;10,80]);
//           Interfaces.NegativePin VMin "Negative output voltage limitation" annotation(extent = [ -10, -80;10, -60]);
//           SI.Voltage vin "input voltage";
//         protected 
//           Real s "Auxiliary variable";
// 
//         equation 
//           in_p.i = 0;
//           in_n.i = 0;
//           VMax.i = 0;
//           VMin.i = 0;
//           vin = in_p.v - in_n.v;
//           in_p.v - in_n.v = if s <  -1 then s + 1 else if s > 1 then s - 1 else 0;
//           out.v = if s <  -1 then VMin.v else if s > 1 then VMax.v else ((VMax.v - VMin.v) * s) / 2 + (VMax.v + VMin.v) / 2;
//         end IdealOpAmpLimited;
//         model IdealDiode "Ideal diode"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter Modelica.SIunits.Resistance Roff(final min = 0) = 1e-05 "Forward state-on differential resistance (closed diode resistance)";
//           parameter Modelica.SIunits.Conductance Gon(final min = 0) = 1e-05 "Backward state-off conductance (opened diode conductance)";
//           parameter Modelica.SIunits.Voltage Vknee(final min = 0) = 0 "Forward threshold voltage";
//           Boolean off(start = true) "Switching state";
//         protected 
//           Real s "Auxiliary variable: if on then current, if opened then voltage";
//           annotation(Documentation(info = "<html>
// <P>
// This is an ideal switch which is<br><br>
// <b>open </b>(off), if it is reversed biased (voltage drop less than 0)<br>
// <b>closed</b> (on), if it is conducting (current > 0).<br>
// </P>
// <p>
// This is the behaviour if all parameters are exactly zero.<br><br>
// Note, there are circuits, where this ideal description
// with zero resistance and zero cinductance is not possible.
// In order to prevent singularities during switching, the opened
// diode has a small conductance <i>Gon</i> and the closed diode has a low
// resistance <i>Roff</i> which is default.
// </P>
// <P>
// The parameter <i>Vknee</i> which is the forward threshold voltage, allows to displace
// the knee point <br> 
// along  the <i>Gon</i>-characteristic until <i>v = Vknee</i>.
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss and Anton Haumer<br> Vknee added<br>
//        </li>
// <li><i>some years ago   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3)), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Line(points = [ -80,0;80,0], style(color = 10)), Polygon(points = [70,4;80,0;70, -4;70,4], style(color = 10, fillColor = 10)), Line(points = [0,80;0, -80], style(color = 10, fillColor = 10, fillPattern = 1)), Polygon(points = [ -4,70;0,80;4,70; -4,70], style(color = 10, fillColor = 10, fillPattern = 1)), Text(extent = [10,80;20,70], style(color = 10, fillColor = 10, fillPattern = 1), string = "i"), Text(extent = [70, -10;80, -20], style(color = 10, fillColor = 10, fillPattern = 1), string = "v"), Line(points = [ -80, -40; -20, -10;20,10;40,70], style(color = 0, thickness = 2, fillColor = 10, fillPattern = 1)), Line(points = [20,9;20,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1)), Text(extent = [20,0;40, -10], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Vknee"), Text(extent = [20,70;40,60], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Roff"), Text(extent = [ -20,10;0,0], style(color = 10, pattern = 3, fillColor = 10, fillPattern = 1), string = "Gon"), Ellipse(extent = [18,12;22,8], style(pattern = 3, fillPattern = 1))), Window(x = 0.26, y = 0.11, width = 0.6, height = 0.6));
// 
//         equation 
//           off = s < 0;
//           v = s * (if off then 1 else Roff) + Vknee;
//           i = s * (if off then Gon else 1) + Gon * Vknee;
//         end IdealDiode;
//         model IdealTransformer "Ideal electrical transformer"
//           extends Interfaces.TwoPort;
//           parameter Real n = 1 "Turns ratio";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<html>
// <P>
// The ideal transformer is an ideal two-port resistive circuit element
// which is characterized by the following two equations:
// </P>
// <PRE>
//     v1 =  n * v2
//     i2 = -n * i1
// </PRE>
// <P>
// where <i>n</i> is a real number called the turns ratio.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1]), Icon(Text(extent = [ -100,100;100,80], string = "%name"), Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50]), Text(extent = [ -100, -80;100, -100], string = "n=%n")), Diagram(Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50])), Window(x = 0.29, y = 0.07, width = 0.6, height = 0.6));
// 
//         equation 
//           v1 = n * v2;
//           i2 =  -n * i1;
//         end IdealTransformer;
//         model IdealGyrator "Ideal gyrator"
//           extends Interfaces.TwoPort;
//           annotation(Documentation(info = "<html>
// <P>
// A gyrator is an ideal two-port element defined by the following equations:
// </P>
// <PRE>
//     i1 =  G * v2
//     i2 = -G * v1
// </PRE>
// <P>
// where the constant <i>G</i> is called the gyration conductance.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1]), Icon(Ellipse(extent = [ -70, -30; -10,30]), Rectangle(extent = [ -80, -40; -41,40], style(color = 7, pattern = 1, thickness = 1, arrow = 0, fillColor = 7)), Line(points = [ -90,50; -40,50; -40, -50; -90, -50]), Text(extent = [ -100,100;100,70], string = "%name"), Line(points = [ -30,60;20,60]), Polygon(points = [20,63;30,60;20,57;20,63], style(pattern = 1, thickness = 1, arrow = 0, fillColor = 3, fillPattern = 1)), Ellipse(extent = [10, -30;70,30]), Rectangle(extent = [80, -40;40,40], style(color = 7, pattern = 1, thickness = 1, arrow = 0, fillColor = 7)), Line(points = [90,50;40,50;40, -50;90, -50])), Diagram(Ellipse(extent = [ -70, -30; -10,30]), Rectangle(extent = [ -80, -40; -41,40], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -40,50; -40, -50; -90, -50]), Line(points = [ -30,60;20,60]), Polygon(points = [20,63;30,60;20,57;20,63], style(fillColor = 3, fillPattern = 1)), Ellipse(extent = [10, -30;70,30]), Rectangle(extent = [80, -40;40,40], style(color = 7, fillColor = 7)), Line(points = [90,50;40,50;40, -50;90, -50])));
//           parameter SI.Conductance G = 1 "Gyration conductance";
// 
//         equation 
//           i1 = G * v2;
//           i2 =  -G * v1;
//         end IdealGyrator;
//         model Idle "Idle branch"
//           extends Interfaces.OnePort;
//           annotation(Documentation(info = "<html>
// <P>
// The model Idle is a simple idle running branch.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [ -90,0; -41,0]), Line(points = [91,0;40,0]), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [ -90,0; -41,0]), Line(points = [91,0;40,0])), Window(x = 0.36, y = 0.16, width = 0.6, height = 0.6));
// 
//         equation 
//           i = 0;
//         end Idle;
//         model Short "Short cut branch"
//           extends Interfaces.OnePort;
//           annotation(Documentation(info = "<html>
// <P>
// The model Short is a simple short cut branch.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [91,0; -90,0]), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [91,0; -90,0]), Text(extent = [ -100,100;100,70], string = "Short")), Window(x = 0.31, y = 0.14, width = 0.6, height = 0.6));
// 
//         equation 
//           v = 0;
//         end Short;
//         model IdealOpener "Ideal electrical opener"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [10,10;56.6667,56.6667]);
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = 1) "true => switch open, false => p--n connected" annotation(extent = [ -10,50;10,70], rotation =  -90);
//         protected 
//           Real s "Auxiliary variable";
//           Boolean off;
//           annotation(Documentation(info = "<HTML>
// <P> 
// The ideal opener has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control signal. 
// If the control signal is true, pin p is not connected 
// with negative pin n. Otherwise, pin p is connected 
// with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.44, height = 0.65), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name"), Line(points = [0,51;0,26]), Line(points = [40,20;40,0])), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -40;100, -79], string = "%name"), Line(points = [0,51;0,26]), Line(points = [40,20;40,0])));
// 
//         equation 
//           off = control.signal[1];
//           v = s * (if off then 1 else Ron);
//           i = s * (if off then Goff else 1);
//         end IdealOpener;
//         model IdealCloser "Ideal electrical closer"
//           extends Interfaces.OnePort;
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [10,10;56.6667,56.6667]);
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = 1) "true => switch open, false => p--n connected" annotation(extent = [ -10,50;10,70], rotation =  -90);
//         protected 
//           Real s "Auxiliary variable";
//           Boolean on;
//           annotation(Documentation(info = "<HTML>
// <P> 
// The ideal opener has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control signal. 
// If the control signal is true, pin p is not connected 
// with negative pin n. Otherwise, pin p is connected 
// with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.24, y = 0.01, width = 0.65, height = 0.77), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -70;100, -100], string = "%name"), Line(points = [0,51;0,26])), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Text(extent = [ -100, -40;100, -79], string = "%name"), Line(points = [0,51;0,26])));
// 
//         equation 
//           on = control.signal[1];
//           v = s * (if not on then 1 else Ron);
//           i = s * (if not on then Goff else 1);
//         end IdealCloser;
//         model ControlledIdealOpener "Controlled ideal electrical opener"
//           parameter SI.Voltage level = 0.5 "Switch level" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [10,10;56.6667,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [ -56.6667, -56.6667; -10, -10]);
//         protected 
//           Real s "Auxiliary variable";
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The ideal switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control pin. 
// If its voltage exceeds the voltage of the parameter level,
// pin p is not connected with negative pin n. 
// Otherwise, pin p is connected with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.44, height = 0.65), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25]), Text(extent = [ -100, -70;100, -100], string = "%name"), Line(points = [40,20;40,0])), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25]), Line(points = [40,20;40,0])));
//         public 
//           Interfaces.PositivePin p annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin control "Control pin: control.v > level switch open, otherwise p--n connected" annotation(extent = [ -10,90;10,110], rotation = 90);
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n.i;
//           p.v - n.v = s * (if control.v > level then 1 else Ron);
//           p.i = s * (if control.v > level then Goff else 1);
//         end ControlledIdealOpener;
//         model ControlledIdealCloser "Controlled ideal electrical closer"
//           parameter SI.Voltage level = 0.5 "Switch level" annotation(extent = [ -56.6667,10; -10,56.6667]);
//           parameter SI.Resistance Ron(final min = 0) = 1e-05 "Closed switch resistance" annotation(extent = [10,10;56.6667,56.6667]);
//           parameter SI.Conductance Goff(final min = 0) = 1e-05 "Opened switch conductance" annotation(extent = [ -56.6667, -56.6667; -10, -10]);
//         protected 
//           Real s "Auxiliary variable";
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The ideal switch has a positive pin p and a negative pin n. 
// The switching behaviour is controlled by the control pin. 
// If its voltage exceeds the voltage of the parameter level,
// pin p is not connected with negative pin n. 
// Otherwise, pin p is connected with negative pin n.
// </P>
// <P>
// In order to prevent singularities during switching, the opened 
// switch has a (very low) conductance Goff
// and the closed switch has a (very low) resistance Ron. 
// The limiting case is also allowed, i.e., the resistance Ron of the
// closed switch could be exactly zero and the conductance Goff of the
// open switch could be also exactly zero. Note, there are circuits, 
// where a description with zero Ron or zero Goff is not possible. 
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.44, height = 0.65), Icon(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25]), Text(extent = [ -100, -70;100, -100], string = "%name")), Diagram(Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,0;90,0]), Line(points = [0,90;0,25])));
//         public 
//           Interfaces.PositivePin p annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePin n annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin control "Control pin: control.v > level switch open, otherwise p--n connected" annotation(extent = [ -10,90;10,110], rotation = 90);
// 
//         equation 
//           control.i = 0;
//           0 = p.i + n.i;
//           p.v - n.v = s * (if control.v > level then Ron else 1);
//           p.i = s * (if control.v > level then 1 else Goff);
//         end ControlledIdealCloser;
//       end Ideal;
//       package Interfaces
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.21, height = 0.49, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains connectors and interfaces (partial models) for
// analog electrical components.
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Interfaces.mo,v 1.12 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         connector Pin "Pin of an electrical component"
//           SI.Voltage v "Potential at the pin";
//           flow SI.Current i "Current flowing into the pin";
//           annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 3))), Terminal(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3))));
//         end Pin;
//         connector PositivePin "Positive pin of an electric component"
//           SI.Voltage v "Potential at the pin";
//           flow SI.Current i "Current flowing into the pin";
//           annotation(Documentation(info = "<html><p>Connectors PositivePin
// and NegativePin are nearly identical.
// The only difference is that the icons are different in order
// to identify more easily the pins of a component. Usually,
// connector PositivePin is used for the positive and
// connector NegativePin for the negative pin of an electrical
// component.</p></html>"), Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 3))), Terminal(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3))));
//         end PositivePin;
//         connector NegativePin "Negative pin of an electric component"
//           SI.Voltage v "Potential at the pin";
//           flow SI.Current i "Current flowing into the pin";
//           annotation(Documentation(info = "<html><p>Connectors PositivePin
// and NegativePin are nearly identical.
// The only difference is that the icons are different in order
// to identify more easily the pins of a component. Usually,
// connector PositivePin is used for the positive and
// connector NegativePin for the negative pin of an electrical
// component.</p></html>"), Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 3, gradient = 0, fillColor = 7, fillPattern = 1))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 3, fillColor = 7, fillPattern = 1)), Text(extent = [ -100, -120;100, -220], string = "%name")), Terminal(Rectangle(extent = [ -100,100;100, -100], style(color = 3))));
//         end NegativePin;
//         partial model TwoPin "Component with one electrical port"
//           SI.Voltage v "Voltage drop between the two pins (= p.v - n.v)";
//           PositivePin p "Positive pin" annotation(extent = [ -110, -10; -90,10]);
//           NegativePin n "Negative pin" annotation(extent = [90, -10;110,10]);
//           annotation(Diagram(Polygon(points = [ -120,3; -110,0; -120, -3; -120,3], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [ -136,0; -111,0], style(color = 9, fillColor = 9)), Text(extent = [ -134,5; -117,20], string = "p.i", style(color = 9, fillColor = 9)), Line(points = [110,0;135,0], style(color = 9, fillColor = 9)), Polygon(points = [120,3;110,0;120, -3;120,3], style(color = 9, fillColor = 9, fillPattern = 1)), Text(extent = [117,3;134,18], string = "n.i", style(color = 9, fillColor = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.11, y = 0.14, width = 0.55, height = 0.64));
// 
//         equation 
//           v = p.v - n.v;
//         end TwoPin;
//         partial model OnePort "Component with two electrical pins p and n and current i from p to n"
//           SI.Voltage v "Voltage drop between the two pins (= p.v - n.v)";
//           SI.Current i "Current flowing from pin p to pin n";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<HTML>
// <P>
// Superclass of elements which have <b>two</b> electrical pins:
// the positive pin connector <i>p</i>, and the negative pin
// connector <i>n</i>. It is assumed that the current flowing
// into pin p is identical to the current flowing out of pin n.
// This current is provided explicitly as current i.
// </P>
// </HTML>
// "), Diagram(Line(points = [ -110,20; -85,20], style(color = 9, fillColor = 9)), Polygon(points = [ -95,23; -85,20; -95,17; -95,23], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [90,20;115,20], style(color = 9, fillColor = 9)), Line(points = [ -125,0; -115,0], style(color = 9)), Line(points = [ -120, -5; -120,5], style(color = 9)), Text(extent = [ -110,25; -90,45], string = "i", style(color = 9)), Polygon(points = [105,23;115,20;105,17;105,23], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [115,0;125,0], style(color = 9)), Text(extent = [90,45;110,25], string = "i", style(color = 9))), Window(x = 0.33, y = 0.04, width = 0.63, height = 0.67));
//           PositivePin p annotation(extent = [ -110, -10; -90,10]);
//           NegativePin n annotation(extent = [110, -10;90,10]);
// 
//         equation 
//           v = p.v - n.v;
//           0 = p.i + n.i;
//           i = p.i;
//         end OnePort;
//         partial model TwoPort "Component with two electrical ports, including current"
//           SI.Voltage v1 "Voltage drop over the left port";
//           SI.Voltage v2 "Voltage drop over the right port";
//           SI.Current i1 "Current flowing from pos. to neg. pin of the left port";
//           SI.Current i2 "Current flowing from pos. to neg. pin of the right port";
//           PositivePin p1 "Positive pin of the left port" annotation(extent = [ -110,40; -90,60]);
//           NegativePin n1 "Negative pin of the left port" annotation(extent = [ -110, -60; -90, -40]);
//           PositivePin p2 "Positive pin of the right port" annotation(extent = [90,40;110,60]);
//           NegativePin n2 "Negative pin of the right port" annotation(extent = [90, -60;110, -40]);
//           annotation(Diagram(Polygon(points = [ -120,53; -110,50; -120,47; -120,53], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [ -136,50; -111,50], style(color = 9, fillColor = 9)), Polygon(points = [127, -47;137, -50;127, -53;127, -47], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [111, -50;136, -50], style(color = 9, fillColor = 9)), Text(extent = [112, -44;128, -29], string = "i2", style(color = 9, fillColor = 9)), Text(extent = [118,52;135,67], string = "i2", style(color = 9, gradient = 2, fillColor = 9)), Polygon(points = [120,53;110,50;120,47;120,53], style(color = 9, gradient = 2, fillColor = 9, fillPattern = 1)), Line(points = [111,50;136,50], style(color = 9, gradient = 2, fillColor = 9)), Line(points = [ -136, -49; -111, -49], style(color = 9, fillColor = 9)), Polygon(points = [ -126, -46; -136, -49; -126, -52; -126, -46], style(color = 9, fillColor = 9, fillPattern = 1)), Text(extent = [ -127, -46; -110, -31], string = "i1", style(color = 9, fillColor = 9)), Text(extent = [ -136,53; -119,68], string = "i1", style(color = 9, fillColor = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.16, y = 0.12, width = 0.6, height = 0.6));
// 
//         equation 
//           v1 = p1.v - n1.v;
//           v2 = p2.v - n2.v;
//           0 = p1.i + n1.i;
//           0 = p2.i + n2.i;
//           i1 = p1.i;
//           i2 = p2.i;
//         end TwoPort;
//         partial model AbsoluteSensor "Base class to measure the absolute value of a pin variable"
//           extends Modelica.Icons.RotationalSensor;
//           PositivePin p "pin to be measured" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.31, y = 0.04, width = 0.6, height = 0.6), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0]), Text(extent = [ -110,80;110,120], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0])));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Base class to measure a relative variable between two pins"
//           extends Modelica.Icons.RotationalSensor;
//           PositivePin p "positive pin" annotation(extent = [ -110, -10; -90,10]);
//           NegativePin n "negative pin" annotation(extent = [90, -10;110,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [ -10, -90;10, -110], rotation = 90);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [0, -90;0, -70]), Text(extent = [ -110,80;110,120], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [0, -90;0, -70]), Line(points = [70,0;90,0], style(color = 0))));
//         end RelativeSensor;
//         partial model VoltageSource "Interface for voltage sources"
//           extends OnePort;
//           parameter SI.Voltage offset = 0 "Voltage offset";
//           parameter SI.Time startTime = 0 "Time offset";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Text(extent = [ -100, -120;100, -80], string = "%name=%V"), Line(points = [ -50,0;50,0])), Window(x = 0.31, y = 0.09, width = 0.6, height = 0.6));
//           replaceable Modelica.Blocks.Interfaces.SignalSource signalSource(final offset = {offset}, final startTime = {startTime}) annotation(extent = [70,70;90,90]);
// 
//         equation 
//           v = signalSource.outPort.signal[1];
//         end VoltageSource;
//         partial model CurrentSource "Interface for current sources"
//           extends OnePort;
//           parameter SI.Current offset = 0 "Current offset";
//           parameter SI.Time startTime = 0 "Time offset";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Line(points = [0, -50;0,50]), Text(extent = [ -100, -120;100, -80], string = "%name=%I")), Window(x = 0.33, y = 0.24, width = 0.6, height = 0.6));
//           replaceable Modelica.Blocks.Interfaces.SignalSource signalSource(final offset = {offset}, final startTime = {startTime}) annotation(extent = [69,70;90,90]);
// 
//         equation 
//           i = signalSource.outPort.signal[1];
//         end CurrentSource;
//       end Interfaces;
//       package Lines
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.5, height = 0.24, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains lossy and lossless segmented transmission lines,
// and LC distributed line models.
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Joachim.Haase/\">Joachim Haase;</a> 
//     &lt;<a href=\"mailto:haase@eas.iis.fhg.de\">haase@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a> 
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Lines.mo,v 1.12 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         model OLine "Lossy Transmission Line"
//           Interfaces.Pin p1 annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.Pin p2 annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin p3 annotation(extent = [ -10, -110;10, -90]);
//           SI.Voltage v13;
//           SI.Voltage v23;
//           SI.Current i1;
//           SI.Current i2;
//           parameter Real r(final min = Modelica.Constants.small, unit = "Ohm/m") = 1 "Resistance per meter";
//           parameter Real l(final min = Modelica.Constants.small, unit = "H/m") = 1 "Inductance per meter";
//           parameter Real g(final min = Modelica.Constants.small, unit = "Siemens/m") = 1 "Conductance per meter";
//           parameter Real c(final min = Modelica.Constants.small, unit = "F/m") = 1 "Capacitance per meter";
//           parameter SI.Length length(final min = Modelica.Constants.small) = 1 "Length of line";
//           parameter Integer N(final min = 1) = 1 "Number of lumped segments";
//         protected 
//           Basic.Resistor R[N + 1](R = fill((r * length) / (N + 1), N + 1));
//           Basic.Inductor L[N + 1](L = fill((l * length) / (N + 1), N + 1));
//           Basic.Capacitor C[N](C = fill((c * length) / N, N));
//           Basic.Conductor G[N](G = fill((g * length) / N, N));
//           annotation(Documentation(info = "<html>
// <P>
// Lossy Transmission Line.
// 
//   The lossy transmission line OLine consists of segments of
//   lumped resistances and inductances in series
//   and conductances and capacitances that are
//   connected with the reference pin p3. The precision
//   of the model depends on the number N of
//   lumped segments.
// </P>
// <DL>
// <DT>
// <b>References:</b>
// <DD>
//   Johnson, B.; Quarles, T.; Newton, A. R.; Pederson, D. O.;
//   Sangiovanni-Vincentelli, A.: SPICE3 Version 3e User's Manual
//   (April 1, 1991). Department of Electrical Engineering and
//   Computer Sciences, University of California, Berkley
//   p. 12, p. 106 - 107
// </DL>
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [0, -60;0, -90]), Line(points = [60,0;90,0]), Line(points = [ -60,0; -90,0]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [0, -60;0, -90]), Line(points = [60,0;90,0]), Line(points = [ -60,0; -90,0]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20])), Window(x = 0.24, y = 0.07, width = 0.6, height = 0.6));
// 
//         equation 
//           v13 = p1.v - p3.v;
//           v23 = p2.v - p3.v;
//           i1 = p1.i;
//           i2 = p2.i;
//           connect(p1,R[1].p);
//           for i in 1:N loop
//           connect(R[i].n,L[i].p);
//           connect(L[i].n,C[i].p);
//           connect(L[i].n,G[i].p);
//           connect(C[i].n,p3);
//           connect(G[i].n,p3);
//           connect(L[i].n,R[i + 1].p);
// 
//           end for;
//           connect(R[N + 1].n,L[N + 1].p);
//           connect(L[N + 1].n,p2);
//         end OLine;
//         model ULine "Lossy RC Line"
//           Interfaces.Pin p1 annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.Pin p2 annotation(extent = [90, -10;110,10]);
//           Interfaces.Pin p3 annotation(extent = [ -10, -110;10, -90]);
//           SI.Voltage v13;
//           SI.Voltage v23;
//           SI.Current i1;
//           SI.Current i2;
//           parameter Real r(final min = Modelica.Constants.small, unit = "Ohm/m") = 1 "Resistance per meter";
//           parameter Real c(final min = Modelica.Constants.small, unit = "F/m") = 1 "Capacitance per meter";
//           parameter SI.Length length(final min = Modelica.Constants.small) = 1 "Length of line";
//           parameter Integer N(final min = 1) = 1 "Number of lumped segments";
//         protected 
//           Basic.Resistor R[N + 1](R = fill((r * length) / (N + 1), N + 1));
//           Basic.Capacitor C[N](C = fill((c * length) / N, N));
//           annotation(Documentation(info = "<html>
// <P>
// The lossy RC line ULine consists of segments of
// lumped series resistances and capacitances that are
// connected with the reference pin p3. The precision
// of the model depends on the number N of
// lumped segments.
// </P>
// <DL>
// <DT>
// <b>References:</b>
// <DD>
//   Johnson, B.; Quarles, T.; Newton, A. R.; Pederson, D. O.;
//   Sangiovanni-Vincentelli, A.: SPICE3 Version 3e User's Manual
//   (April 1, 1991). Department of Electrical Engineering and
//   Computer Sciences, University of California, Berkley
//   p. 22, p. 124
// </DL>
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.2, y = 0.21, width = 0.6, height = 0.6), Icon(Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [0, -60;0, -90]), Line(points = [60,0;90,0]), Line(points = [ -60,0; -90,0]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [0, -60;0, -90]), Line(points = [60,0;90,0]), Line(points = [ -60,0; -90,0]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20])));
// 
//         equation 
//           v13 = p1.v - p3.v;
//           v23 = p2.v - p3.v;
//           i1 = p1.i;
//           i2 = p2.i;
//           connect(p1,R[1].p);
//           for i in 1:N loop
//           connect(R[i].n,R[i + 1].p);
// 
//           end for;
//           for i in 1:N loop
//           connect(R[i].n,C[i].p);
// 
//           end for;
//           for i in 1:N loop
//           connect(C[i].n,p3);
// 
//           end for;
//           connect(R[N + 1].n,p2);
//         end ULine;
//         model TLine1 "Lossless transmission line with characteristic impedance Z0 and transmission delay TD"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Characteristic impedance";
//           parameter Modelica.SIunits.Time TD = 1 "Transmission delay";
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           annotation(Documentation(info = "
// 
// Lossless transmission line with characteristic impedance Z0 and transmission delay TD
// 
//   The lossless transmission line TLine1 is a two Port. Both port branches
//   consist of a resistor with characteristic impedance Z0 and a controled voltage
//   source that takes into consideration the transmission delay TD.
//   For further details see Branin's article.
//   The model parameters can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e.
//   Z0 = sqrt(L'/C') and TD = sqrt(L'*C')*length_of_line. Resistance R'
//   and conductance C' per meter are assumed to be zero.
// 
// References:
//   Branin Jr., F. H.: Transient Analysis of Lossless Transmission Lines.
//   Proceedings of the IEEE 55(1967), 2012 - 2013
// 
//   Hoefer, E. E. E.; Nielinger, H.: SPICE : Analyseprogramm fuer elektronische
//   Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// 
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine1"), Text(extent = [ -30,10;30, -20], string = "TLine1")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine1"), Text(extent = [ -30,0;31, -31], string = "TLine1")), Window(x = 0.45, y = 0.01, width = 0.51, height = 0.83));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(TD > 0, "TD has to be positive");
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine1;
//         model TLine2 "Lossless transmission line with characteristic impedance Z0, frequency F and normalized length NL"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Characteristic impedance";
//           parameter Modelica.SIunits.Frequency F = 1 "Frequency";
//           parameter Modelica.SIunits.Length NL = 1 "Normalized length";
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           Modelica.SIunits.Time TD;
//           annotation(Documentation(info = "
// 
// Lossless transmission line with characteristic impedance Z0, frequency F and normalized length NL
// 
//   The lossless transmission line TLine2 is a two Port. Both port branches
//   consist of a resistor with the value of the characteristic impedance Z0 
//   and a controled voltage source that takes into consideration 
//   the transmission delay.
//   For further details see Branin's article.
//   Resistance R' and conductance C' per meter are assumed to be zero.
//   The characteristic impedance Z0 can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e. Z0 = sqrt(L'/C').   
//   The normalized length NL is equal to the length of the line divided
//   by the wavelength corresponding to the frequency F, i. e. the
//   transmission delay TD is the quotient of NL and F.
// 
// References:
//   Branin Jr., F. H.: Transient Analysis of Lossless Transmission Lines.
//   Proceedings of the IEEE 55(1967), 2012 - 2013
// 
//   Hoefer, E. E. E.; Nielinger, H.: SPICE : Analyseprogramm fuer elektronische
//   Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// 
//  
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine2"), Text(extent = [ -30,10;30, -20], string = "TLine2")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine2")), Window(x = 0.01, y = 0.03, width = 0.78, height = 0.89));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(NL > 0, "NL has to be positive");
//           assert(F > 0, "F  has to be positive");
//           TD = NL / F;
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine2;
//         model TLine3 "Lossless transmission line with characteristic impedance Z0 and frequency F"
//           extends Modelica.Electrical.Analog.Interfaces.TwoPort;
//           parameter Modelica.SIunits.Resistance Z0 = 1 "Natural impedance";
//           parameter Modelica.SIunits.Frequency F = 1 "Frequency";
//         protected 
//           Modelica.SIunits.Voltage er;
//           Modelica.SIunits.Voltage es;
//           Modelica.SIunits.Time TD;
//           annotation(Documentation(info = "
// 
// Lossless transmission line with characteristic impedance Z0 and frequency F
// 
//   The lossless transmission line TLine3 is a two Port. Both port branches
//   consist of a resistor with value of the characteristic impedance Z0 
//   and a controled voltage source that takes into consideration 
//   the transmission delay.
//   For further details see Branin's article.
//   Resistance R' and conductance C' per meter are assumed to be zero.
//   The characteristic impedance Z0 can be derived from inductance and 
//   capacitance per length (L' resp. C'), i. e. Z0 = sqrt(L'/C').   
//   The length of the line is equal to a quarter of the wavelength
//   corresponding to the frequency F, i. e. the
//   transmission delay is the quotient of 4 and F.
//   In this case, the caracteristic impedance is called natural impedance.
// 
//   References:
//     Branin Jr., F. H.: Transient Analysis of Lossless Transmission Lines.
//     Proceedings of the IEEE 55(1967), 2012 - 2013
// 
//     Hoefer, E. E. E.; Nielinger, H.: SPICE : Analyseprogramm fuer elektronische
//     Schaltungen. Springer-Verlag, Berlin, Heidelberg, New York, Tokyo, 1985.
// 
// 
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine3"), Text(extent = [ -29, -1;30, -31], string = "TLine3")), Diagram(Rectangle(extent = [ -60,60;60, -60]), Line(points = [60, -50;90, -50]), Line(points = [60,50;90,50]), Line(points = [ -60,50; -90,50]), Line(points = [ -60, -50; -90, -50]), Line(points = [30,30; -30,30]), Line(points = [ -30,40; -30,20]), Line(points = [30,40;30,20]), Text(extent = [ -100,100;100,70], string = "TLine3")), Window(x = 0, y = 0, width = 0.7, height = 0.92));
// 
//         equation 
//           assert(Z0 > 0, "Z0 has to be positive");
//           assert(F > 0, "F  has to be positive");
//           TD = 1 / F / 4;
//           i1 = (v1 - es) / Z0;
//           i2 = (v2 - er) / Z0;
//           es = 2 * delay(v2, TD) - delay(er, TD);
//           er = 2 * delay(v1, TD) - delay(es, TD);
//         end TLine3;
//       end Lines;
//       package Semiconductors
//         extends Modelica.Icons.Library;
//         import Modelica.SIunits;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.5, height = 0.36, library = 1, autolayout = 1), Documentation(info = "
// <HTML>
// <p>
// This package contains semiconductor devices:
// <ul>
// <li>diode</li>
// <li>MOS transistors</li>
// <li>bipolar transistors</li>
// <li>diode, MOS and bipolar transistors with temperature 
//     dependent characteristic and a heatPort for connection
//     to the thermal domain</li>
// </ul>
// </p>
// 
// </HTML>
// ", revisions = "<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a> 
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a> 
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Semiconductors.mo,v 1.15 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// </dl>
// </html>"));
//         model Diode "Simple diode"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           parameter SIunits.Current Ids = 1e-06 "Saturation current";
//           parameter SIunits.Voltage Vt = 0.04 "Voltage equivalent of temperature (kT/qn)";
//           parameter Real Maxexp(final min = Modelica.Constants.SMALL) = 15 "Max. exponent for linear continuation";
//           parameter SIunits.Resistance R = 100000000.0 "Parallel ohmic resistance";
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The simple diode is a one port. It consists of the diode itself and an parallel ohmic
// resistance <i>R</i>. The diode formula is:
// </P>
// <PRE> 
//                 v/vt
//   i  =  ids ( e      - 1).
// </PRE>
// <P>
// If the exponent <i>v/vt</i> reaches the limit <i>maxex</i>, the diode characterisic is linearly
// continued to avoid overflow.
// </P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3)), Text(extent = [ -98, -58;102, -100], string = "Vt=%Vt", style(color = 0)), Text(extent = [ -100,100;100,70], string = "%name")), Diagram(Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 1, fillPattern = 0)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3))), Window(x = 0.13, y = 0.09, width = 0.75, height = 0.63));
// 
//         equation 
//           i = if v / Vt > Maxexp then Ids * (exp(Maxexp) * (1 + v / Vt - Maxexp) - 1) + v / R else Ids * (exp(v / Vt) - 1) + v / R;
//         end Diode;
//         model PMOS "Simple MOS Transistor"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The PMOS model is a simple model of a p-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag 
//   Muenchen Wien 1990.   
// </DL>
// <P>
// Some typical parameter sets are:
// </P>
// <PRE>
//   W       L      Beta        Vt       K2       K5       DW         DL    
//   m       m      A/V^2       V        -        -        m          m    
// 
//   50.e-6  8.e-6  .0085e-3   -.15     .41      .839    -3.8e-6    -4.0e-6           
//   20.e-6  6.e-6  .0105e-3  -1.0      .41      .839    -2.5e-6    -2.1e-6 
//   30.e-6  5.e-6  .0059e-3   -.3      .98     1.01      0         -3.9e-6   
//   30.e-6  5.e-6  .0152e-3   -.69     .104    1.1       -.8e-6     -.4e-6         
//   30.e-6  5.e-6  .0163e-3   -.69     .104    1.1       -.8e-6     -.4e-6         
//   30.e-6  5.e-6  .0182e-3   -.69     .086    1.06      -.1e-6     -.6e-6         
//   20.e-6  6.e-6  .0074e-3  -1.       .4       .59      0          0           
// </PRE>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.34, y = 0.24, width = 0.6, height = 0.6), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [60,0;40,5;40, -5;60,0], style(fillColor = 3, fillPattern = 1))), Diagram(Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [60,0;40,5;40, -5;60,0], style(fillColor = 3, fillPattern = 1))));
//           Interfaces.Pin D "Drain" annotation(extent = [90,40;110,60]);
//           Interfaces.Pin G "Gate" annotation(extent = [ -90, -40; -110, -60]);
//           Interfaces.Pin S "Source" annotation(extent = [90, -40;110, -60]);
//           Interfaces.Pin B "Bulk" annotation(extent = [90, -10;110,10]);
//           parameter SIunits.Length W = 2e-05 "Width";
//           parameter SIunits.Length L = 6e-06 "Length";
//           parameter SIunits.Transconductance Beta = 1.05e-05 "Transconductance parameter";
//           parameter SIunits.Voltage Vt =  -1.0 "Zero bias threshold voltage";
//           parameter Real K2 = 0.41 "Bulk threshold parameter";
//           parameter Real K5 = 0.839 "Reduction of pinch-off region";
//           parameter SIunits.Length dW =  -2.5e-06 "Narrowing of channel";
//           parameter SIunits.Length dL =  -2.1e-06 "Shortening of channel";
//           parameter SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
// 
//         equation 
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (Beta * (W + dW)) / (L + dL);
//           ud = if D.v > S.v then S.v else D.v;
//           us = if D.v > S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v < us then 0 else B.v - us;
//           ugst = (G.v - us - Vt + K2 * ubs) * K5;
//           id = if ugst >= 0 then v * uds * gds else if ugst < uds then  -v * uds * (ugst - uds / 2 - gds) else  -v * ((ugst * ugst) / 2 - uds * gds);
//           G.i = 0;
//           D.i = if D.v > S.v then  -id else id;
//           S.i = if D.v > S.v then id else  -id;
//           B.i = 0;
//         end PMOS;
//         model NMOS "Simple MOS Transistor"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The NMos model is a simple model of a n-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <P>
// <PRE>
//   W       L      Beta        Vt       K2      K5       DW         DL    
//   m       m      A/V^2       V        -       -        m          m    
// 
//   12.e-6  4.e-6  .062e-3   -4.5      .24     .61     -1.2e-6     -.9e-6      depletion
//   60.e-6  3.e-6  .048e-3     .1      .08     .68     -1.2e-6     -.9e-6      enhancement
//   12.e-6  4.e-6  .0625e-3   -.8      .21     .78     -1.2e-6     -.9e-6      zero
//   50.e-6  8.e-6  .0299e-3    .24    1.144    .7311   -5.4e-6    -4.e-6          
//   20.e-6  6.e-6  .041e-3     .8     1.144    .7311   -2.5e-6    -1.5e-6         
//   30.e-6  9.e-6  .025e-3   -4.       .861    .878    -3.4e-6    -1.74e-6        
//   30.e-6  5.e-6  .031e-3     .6     1.5      .72      0         -3.9e-6         
//   50.e-6  6.e-6  .0414e-3  -3.8      .34     .8      -1.6e-6    -2.e-6       depletion
//   50.e-6  5.e-6  .03e-3      .37     .23     .86     -1.6e-6    -2.e-6       enhancement
//   50.e-6  6.e-6  .038e-3    -.9      .23     .707    -1.6e-6    -2.e-6       zero
//   20.e-6  4.e-6  .06776e-3   .5409   .065    .71      -.8e-6     -.2e-6      
//   20.e-6  4.e-6  .06505e-3   .6209   .065    .71      -.8e-6     -.2e-6         
//   20.e-6  4.e-6  .05365e-3   .6909   .03     .8       -.3e-6     -.2e-6        
//   20.e-6  4.e-6  .05365e-3   .4909   .03     .8       -.3e-6     -.2e-6        
//   12.e-6  4.e-6  .023e-3   -4.5      .29     .6       0          0           depletion
//   60.e-6  3.e-6  .022e-3     .1      .11     .65      0          0           enhancement
//   12.e-6  4.e-6  .038e-3    -.8      .33     .6       0          0           zero
//   20.e-6  6.e-6  .022e-3     .8     1        .66      0          0            
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag 
// Muenchen Wien 1990.  
// </DL>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [40,0;60,5;60, -5;40,0], style(fillColor = 3, fillPattern = 1))), Diagram(Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [40,0;60,5;60, -5;40,0], style(fillColor = 3, fillPattern = 1))));
//           Interfaces.Pin D "Drain" annotation(extent = [90,40;110,60]);
//           Interfaces.Pin G "Gate" annotation(extent = [ -90, -40; -110, -60]);
//           Interfaces.Pin S "Source" annotation(extent = [90, -40;110, -60]);
//           Interfaces.Pin B "Bulk" annotation(extent = [90, -10;110,10]);
//           parameter SIunits.Length W = 2e-05 "Width";
//           parameter SIunits.Length L = 6e-06 "Length";
//           parameter SIunits.Transconductance Beta = 4.1e-05 "Transconductance parameter";
//           parameter SIunits.Voltage Vt = 0.8 "Zero bias threshold voltage";
//           parameter Real K2 = 1.144 "Bulk threshold parameter";
//           parameter Real K5 = 0.7311 "Reduction of pinch-off region";
//           parameter SIunits.Length dW =  -2.5e-06 "narrowing of channel";
//           parameter SIunits.Length dL =  -1.5e-06 "shortening of channel";
//           parameter SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
// 
//         equation 
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (Beta * (W + dW)) / (L + dL);
//           ud = if D.v < S.v then S.v else D.v;
//           us = if D.v < S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v > us then 0 else B.v - us;
//           ugst = (G.v - us - Vt + K2 * ubs) * K5;
//           id = if ugst <= 0 then v * uds * gds else if ugst > uds then v * uds * (ugst - uds / 2 + gds) else v * ((ugst * ugst) / 2 + uds * gds);
//           G.i = 0;
//           D.i = if D.v < S.v then  -id else id;
//           S.i = if D.v < S.v then id else  -id;
//           B.i = 0;
//         end NMOS;
//         model NPN "Simple BJT according to Ebers-Moll"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter SIunits.Voltage Vt = 0.02585 "Voltage equivalent of temperature";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//         protected 
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           function pow "Just a helper function for x^y"
//             input Real x;
//             input Real y;
//             output Real z;
//           algorithm 
//             z:=x ^ y;
//           end pow;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar npn junction transistor according
// to Ebers-Moll.
// </P>
// <P>
// A typical parameter set is:
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe    Vt   
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     V
// 
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15  0.02585
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// <P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.22, y = 0.28, width = 0.6, height = 0.6), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [30, -50;24, -36;16, -44;30, -50], style(fillColor = 3, fillPattern = 1))), Diagram(Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Line(points = [100,50;30,50]), Polygon(points = [30, -50;24, -36;16, -44;30, -50], style(fillColor = 3, fillPattern = 1))));
//         public 
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(extent = [ -90, -10; -110,10]);
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(extent = [90, -40;110, -60]);
// 
//         equation 
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = B.v - C.v;
//           vbe = B.v - E.v;
//           qbk = 1 - vbc * Vak;
//           ibc = if vbc / Vt < EMin then Is * (ExMin * (vbc / Vt - EMin + 1) - 1) + vbc * Gbc else if vbc / Vt > EMax then Is * (ExMax * (vbc / Vt - EMax + 1) - 1) + vbc * Gbc else Is * (exp(vbc / Vt) - 1) + vbc * Gbc;
//           ibe = if vbe / Vt < EMin then Is * (ExMin * (vbe / Vt - EMin + 1) - 1) + vbe * Gbe else if vbe / Vt > EMax then Is * (ExMax * (vbe / Vt - EMax + 1) - 1) + vbe * Gbe else Is * (exp(vbe / Vt) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / Vt < EMin then (Taur * Is) / Vt * ExMin * (vbc / Vt - EMin + 1) + Capcjc else if vbc / Vt > EMax then (Taur * Is) / Vt * ExMax * (vbc / Vt - EMax + 1) + Capcjc else (Taur * Is) / Vt * exp(vbc / Vt) + Capcjc;
//           cbe = if vbe / Vt < EMin then (Tauf * Is) / Vt * ExMin * (vbe / Vt - EMin + 1) + Capcje else if vbe / Vt > EMax then (Tauf * Is) / Vt * ExMax * (vbe / Vt - EMax + 1) + Capcje else (Tauf * Is) / Vt * exp(vbe / Vt) + Capcje;
//           C.i = (ibe - ibc) * qbk - ibc / Br - cbc * der(vbc) + Ccs * der(C.v);
//           B.i = ibe / Bf + ibc / Br + cbc * der(vbc) + cbe * der(vbe);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//         end NPN;
//         model PNP "Simple BJT according to Ebers-Moll"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter SIunits.Voltage Vt = 0.02585 "Voltage equivalent of temperature";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//         protected 
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           function pow "Just a helper function for x^y"
//             input Real x;
//             input Real y;
//             output Real z;
//           algorithm 
//             z:=x ^ y;
//           end pow;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar pnp junction transistor according
// to Ebers-Moll.
// <P>
// A typical parameter set is:
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe    Vt   
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     V
// 
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15  0.02585
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// <P>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [ -10, -10;5, -17; -3, -25; -10, -10], style(fillColor = 3, fillPattern = 1))), Diagram(Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [ -10, -10;5, -17; -3, -25; -10, -10], style(fillColor = 3, fillPattern = 1))));
//         public 
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(extent = [ -90, -10; -110,10]);
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(extent = [90, -40;110, -60]);
// 
//         equation 
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = C.v - B.v;
//           vbe = E.v - B.v;
//           qbk = 1 - vbc * Vak;
//           ibc = if vbc / Vt < EMin then Is * (ExMin * (vbc / Vt - EMin + 1) - 1) + vbc * Gbc else if vbc / Vt > EMax then Is * (ExMax * (vbc / Vt - EMax + 1) - 1) + vbc * Gbc else Is * (exp(vbc / Vt) - 1) + vbc * Gbc;
//           ibe = if vbe / Vt < EMin then Is * (ExMin * (vbe / Vt - EMin + 1) - 1) + vbe * Gbe else if vbe / Vt > EMax then Is * (ExMax * (vbe / Vt - EMax + 1) - 1) + vbe * Gbe else Is * (exp(vbe / Vt) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / Vt < EMin then (Taur * Is) / Vt * ExMin * (vbc / Vt - EMin + 1) + Capcjc else if vbc / Vt > EMax then (Taur * Is) / Vt * ExMax * (vbc / Vt - EMax + 1) + Capcjc else (Taur * Is) / Vt * exp(vbc / Vt) + Capcjc;
//           cbe = if vbe / Vt < EMin then (Tauf * Is) / Vt * ExMin * (vbe / Vt - EMin + 1) + Capcje else if vbe / Vt > EMax then (Tauf * Is) / Vt * ExMax * (vbe / Vt - EMax + 1) + Capcje else (Tauf * Is) / Vt * exp(vbe / Vt) + Capcje;
//           C.i =  -((ibe - ibc) * qbk - ibc / Br - cbc * der(vbc) - Ccs * der(C.v));
//           B.i =  -(ibe / Bf + ibc / Br + cbe * der(vbe) + cbc * der(vbc));
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//         end PNP;
//         model HeatingDiode "Simple diode with heating port"
//           extends Modelica.Electrical.Analog.Interfaces.OnePort;
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(extent = [ -10, -90;10, -110], rotation =  -90);
//           parameter Modelica.SIunits.Current Ids = 1e-06 "Saturation current";
//           parameter Real Maxexp(final min = Modelica.Constants.SMALL) = 15 "Max. exponent for linear continuation";
//           parameter Modelica.SIunits.Resistance R = 100000000.0 "Parallel ohmic resistance";
//           parameter Real EG = 1.11 "activation energy";
//           parameter Real N = 1 "Emission coefficient";
//           parameter Modelica.SIunits.Temperature TNOM = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent of saturation current";
//           Modelica.SIunits.Temperature vt_t "Temperature voltage";
//           Modelica.SIunits.Current id "diode current";
//         protected 
//           Real k = 1.380662e-23 "Boltzmann's constant, J/K";
//           Real q = 1.6021892e-19 "Electron charge, As";
//           Modelica.SIunits.Temperature htemp "auxiliary temperature";
//           Real aux;
//           Real auxp;
//           Real maxexp = exp(Maxexp);
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The simple diode is an electrical one port, where a heat port is added, which is 
// defined in the Modelica.Thermal library. It consists of the diode itself and an parallel ohmic
// resistance <i>R</i>. The diode formula is:
// </P>
// <PRE> 
//                 v/vt_t
//   i  =  ids ( e        - 1).
// </PRE>
// where vt_t depends on the temperature of the heat port: 
// <PRE> 
//   vt_t = k*temp/q
// </PRE>
// <P>
// If the exponent <i>v/vt_t</i> reaches the limit <i>maxex</i>, the diode characterisic is linearly
// continued to avoid overflow.<br>
// The thermal power is calculated by <i>i*v</i>.
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>April 5, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3)), Text(extent = [ -142,101;143,51], string = "%name"), Line(points = [0, -20;0, -91], style(color = 42))), Diagram(Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 1, fillPattern = 0)), Line(points = [ -90,0;40,0]), Line(points = [40,0;90,0]), Line(points = [30,40;30, -40], style(color = 3))), Window(x = 0.13, y = 0.09, width = 0.75, height = 0.63));
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           htemp = heatPort.T;
//           vt_t = (k * htemp) / q;
//           id = exlin(v / (N * vt_t), Maxexp) - 1;
//           aux = ((htemp / TNOM - 1) * EG) / (N * vt_t);
//           auxp = exp(aux);
//           i = Ids * id * pow(htemp / TNOM, XTI / N) * auxp + v / R;
//           heatPort.Q_dot =  -i * v;
//         end HeatingDiode;
//         model HeatingNMOS "Simple MOS Transistor with heating port"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The NMos model is a simple model of a n-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <P>
// <PRE>
//   W       L      Beta        Vt       K2      K5       DW         DL    
//   m       m      A/V^2       V        -       -        m          m    
//   12.e-6  4.e-6  .062e-3   -4.5      .24     .61     -1.2e-6     -.9e-6      depletion
//   60.e-6  3.e-6  .048e-3     .1      .08     .68     -1.2e-6     -.9e-6      enhancement
//   12.e-6  4.e-6  .0625e-3   -.8      .21     .78     -1.2e-6     -.9e-6      zero
//   50.e-6  8.e-6  .0299e-3    .24    1.144    .7311   -5.4e-6    -4.e-6          
//   20.e-6  6.e-6  .041e-3     .8     1.144    .7311   -2.5e-6    -1.5e-6         
//   30.e-6  9.e-6  .025e-3   -4.       .861    .878    -3.4e-6    -1.74e-6        
//   30.e-6  5.e-6  .031e-3     .6     1.5      .72      0         -3.9e-6         
//   50.e-6  6.e-6  .0414e-3  -3.8      .34     .8      -1.6e-6    -2.e-6       depletion
//   50.e-6  5.e-6  .03e-3      .37     .23     .86     -1.6e-6    -2.e-6       enhancement
//   50.e-6  6.e-6  .038e-3    -.9      .23     .707    -1.6e-6    -2.e-6       zero
//   20.e-6  4.e-6  .06776e-3   .5409   .065    .71      -.8e-6     -.2e-6      
//   20.e-6  4.e-6  .06505e-3   .6209   .065    .71      -.8e-6     -.2e-6         
//   20.e-6  4.e-6  .05365e-3   .6909   .03     .8       -.3e-6     -.2e-6        
//   20.e-6  4.e-6  .05365e-3   .4909   .03     .8       -.3e-6     -.2e-6        
//   12.e-6  4.e-6  .023e-3   -4.5      .29     .6       0          0           depletion
//   60.e-6  3.e-6  .022e-3     .1      .11     .65      0          0           enhancement
//   12.e-6  4.e-6  .038e-3    -.8      .33     .6       0          0           zero
//   20.e-6  6.e-6  .022e-3     .8     1        .66      0          0            
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag 
// Muenchen Wien 1990.  
// </DL>
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 31, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [40,0;60,5;60, -5;40,0], style(fillColor = 3, fillPattern = 1)), Line(points = [0, -91;0, -50], style(color = 42))), Diagram(Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [40,0;60,5;60, -5;40,0], style(fillColor = 3, fillPattern = 1))));
//           Modelica.Electrical.Analog.Interfaces.Pin D "Drain" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin G "Gate" annotation(extent = [ -90, -40; -110, -60]);
//           Modelica.Electrical.Analog.Interfaces.Pin S "Source" annotation(extent = [90, -40;110, -60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Bulk" annotation(extent = [90, -10;110,10]);
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(extent = [ -10, -90;10, -110], rotation =  -90);
//           parameter Modelica.SIunits.Length W = 2e-05 "Width";
//           parameter Modelica.SIunits.Length L = 6e-06 "Length";
//           parameter Modelica.SIunits.Transconductance Beta = 4.1e-05 "Transconductance parameter";
//           parameter Modelica.SIunits.Voltage Vt = 0.8 "Zero bias threshold voltage";
//           parameter Real K2 = 1.144 "Bulk threshold parameter";
//           parameter Real K5 = 0.7311 "Reduction of pinch-off region";
//           parameter Modelica.SIunits.Length dW =  -2.5e-06 "narrowing of channel";
//           parameter Modelica.SIunits.Length dL =  -1.5e-06 "shortening of channel";
//           parameter Modelica.SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real kvt =  -0.00696 "fitting parameter for Vt";
//           parameter Real kk2 = 0.0006 "fitting parameter for K22";
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
//           Real beta_t;
//           Real vt_t;
//           Real k2_t;
// 
//         equation 
//           assert(L + dL > 0, "Effective length must be positive");
//           assert(W + dW > 0, "Effective width  must be positive");
//           assert(heatPort.T > 0, "temperature must be positive");
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (beta_t * (W + dW)) / (L + dL);
//           ud = if D.v < S.v then S.v else D.v;
//           us = if D.v < S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v > us then 0 else B.v - us;
//           ugst = (G.v - us - vt_t + k2_t * ubs) * K5;
//           id = if ugst <= 0 then v * uds * gds else if ugst > uds then v * uds * (ugst - uds / 2 + gds) else v * ((ugst * ugst) / 2 + uds * gds);
//           beta_t = Beta * pow(heatPort.T / Tnom,  -1.5);
//           vt_t = Vt * (1 + (heatPort.T - Tnom) * kvt);
//           k2_t = K2 * (1 + (heatPort.T - Tnom) * kk2);
//           G.i = 0;
//           D.i = if D.v < S.v then  -id else id;
//           S.i = if D.v < S.v then id else  -id;
//           B.i = 0;
//           heatPort.Q_dot =  -D.i * (D.v - S.v);
//         end HeatingNMOS;
//         model HeatingPMOS "Simple PMOS Transistor with heating port"
//           annotation(Documentation(info = "
// <HTML>
// <P>
// The PMOS model is a simple model of a p-channel metal-oxide semiconductor
// FET. It differs slightly from the device used in the SPICE simulator.
// For more details please care for H. Spiro.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// The model does not consider capacitances. A high drain-source resistance RDS
// is included to avoid numerical difficulties.
// </P>
// <DL>
// <DT><b>References:</b>
// <DD>Spiro, H.: Simulation integrierter Schaltungen. R. Oldenbourg Verlag 
//   Muenchen Wien 1990.   
// </DL>
// <P>
// Some typical parameter sets are:
// </P>
// <PRE>
//   W       L      Beta        Vt       K2       K5       DW         DL    
//   m       m      A/V^2       V        -        -        m          m    
//   50.e-6  8.e-6  .0085e-3   -.15     .41      .839    -3.8e-6    -4.0e-6           
//   20.e-6  6.e-6  .0105e-3  -1.0      .41      .839    -2.5e-6    -2.1e-6 
//   30.e-6  5.e-6  .0059e-3   -.3      .98     1.01      0         -3.9e-6   
//   30.e-6  5.e-6  .0152e-3   -.69     .104    1.1       -.8e-6     -.4e-6         
//   30.e-6  5.e-6  .0163e-3   -.69     .104    1.1       -.8e-6     -.4e-6         
//   30.e-6  5.e-6  .0182e-3   -.69     .086    1.06      -.1e-6     -.6e-6         
//   20.e-6  6.e-6  .0074e-3  -1.       .4       .59      0          0           
// </PRE>
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 31, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.34, y = 0.24, width = 0.6, height = 0.6), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [60,0;40,5;40, -5;60,0], style(fillColor = 3, fillPattern = 1)), Line(points = [0, -91;0, -50], style(color = 42))), Diagram(Line(points = [ -90, -50; -10, -50]), Line(points = [ -10, -50; -10,50]), Line(points = [10,70;10,29]), Line(points = [10,20;10, -21]), Line(points = [10, -30;10, -71]), Line(points = [10,50;91,50]), Line(points = [10,0;90,0]), Line(points = [10, -50;90, -50]), Polygon(points = [60,0;40,5;40, -5;60,0], style(fillColor = 3, fillPattern = 1))));
//           Modelica.Electrical.Analog.Interfaces.Pin D "Drain" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin G "Gate" annotation(extent = [ -90, -40; -110, -60]);
//           Modelica.Electrical.Analog.Interfaces.Pin S "Source" annotation(extent = [90, -40;110, -60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Bulk" annotation(extent = [90, -10;110,10]);
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(extent = [ -10, -90;10, -110], rotation =  -90);
//           parameter Modelica.SIunits.Length W = 2e-05 "Width";
//           parameter Modelica.SIunits.Length L = 6e-06 "Length";
//           parameter Modelica.SIunits.Transconductance Beta = 1.05e-05 "Transconductance parameter";
//           parameter Modelica.SIunits.Voltage Vt =  -1.0 "Zero bias threshold voltage";
//           parameter Real K2 = 0.41 "Bulk threshold parameter";
//           parameter Real K5 = 0.839 "Reduction of pinch-off region";
//           parameter Modelica.SIunits.Length dW =  -2.5e-06 "Narrowing of channel";
//           parameter Modelica.SIunits.Length dL =  -2.1e-06 "Shortening of channel";
//           parameter Modelica.SIunits.Resistance RDS = 10000000.0 "Drain-Source-Resistance";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real kvt =  -0.0029 "fitting parameter for Vt";
//           parameter Real kk2 = 0.00062 "fitting parameter for Kk2";
//         protected 
//           Real v;
//           Real uds;
//           Real ubs;
//           Real ugst;
//           Real ud;
//           Real us;
//           Real id;
//           Real gds;
//           Real beta_t;
//           Real vt_t;
//           Real k2_t;
// 
//         equation 
//           assert(L + dL > 0, "Effective length must be positive");
//           assert(W + dW > 0, "Effective width  must be positive");
//           assert(heatPort.T > 0, "temperature must be positive");
//           gds = if RDS < 1e-20 and RDS >  -1e-20 then 1e+20 else 1 / RDS;
//           v = (beta_t * (W + dW)) / (L + dL);
//           ud = if D.v > S.v then S.v else D.v;
//           us = if D.v > S.v then D.v else S.v;
//           uds = ud - us;
//           ubs = if B.v < us then 0 else B.v - us;
//           ugst = (G.v - us - vt_t + k2_t * ubs) * K5;
//           id = if ugst >= 0 then v * uds * gds else if ugst < uds then  -v * uds * (ugst - uds / 2 - gds) else  -v * ((ugst * ugst) / 2 - uds * gds);
//           beta_t = Beta * pow(heatPort.T / Tnom,  -1.5);
//           vt_t = Vt * (1 + (heatPort.T - Tnom) * kvt);
//           k2_t = K2 * (1 + (heatPort.T - Tnom) * kk2);
//           G.i = 0;
//           D.i = if D.v > S.v then  -id else id;
//           S.i = if D.v > S.v then id else  -id;
//           B.i = 0;
//           heatPort.Q_dot =  -D.i * (D.v - S.v);
//         end HeatingPMOS;
//         model HeatingNPN "Simple NPN BJT according to Ebers-Moll with heating port"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter Modelica.SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter Modelica.SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter Modelica.SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter Modelica.SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter Modelica.SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter Modelica.SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter Modelica.SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter Modelica.SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter Modelica.SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter Modelica.SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter Modelica.SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent for effect on Is";
//           parameter Real XTB = 0 "Forward and reverse beta temperature exponent";
//           parameter Real EG = 1.11 "Energy gap for temperature effect on Is";
//           parameter Real NF = 1.0 "Forward current emission coefficient";
//           parameter Real NR = 1.0 "Reverse current emission coefficient";
//           parameter Real K = 1.3806226e-23 "Boltzmann's constant";
//           parameter Real q = 1.6021918e-19 "Elementary electronic charge";
//           Real vbc;
//           Real vbe;
//           Real qbk;
//           Real ibc;
//           Real ibe;
//           Real cbc;
//           Real cbe;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           Real is_t;
//           Real br_t;
//           Real bf_t;
//           Real vt_t;
//           Real hexp;
//           Real htempexp;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar npn junction transistor according
// to Ebers-Moll.
// </P>
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// A typical parameter set is (the parameter Vt is no longer used):
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe      
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15 
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// </P>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 20, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.22, y = 0.28, width = 0.6, height = 0.6), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [30, -50;24, -36;16, -44;30, -50], style(fillColor = 3, fillPattern = 1)), Line(points = [0, -91;0, -30], style(color = 42))), Diagram(Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Line(points = [100,50;30,50]), Polygon(points = [30, -50;24, -36;16, -44;30, -50], style(fillColor = 3, fillPattern = 1))));
//         public 
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(extent = [ -90, -10; -110,10]);
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(extent = [90, -40;110, -60]);
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(extent = [ -10, -90;10, -110], rotation =  -90);
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vbc = B.v - C.v;
//           vbe = B.v - E.v;
//           qbk = 1 - vbc * Vak;
//           hexp = ((heatPort.T / Tnom - 1) * EG) / vt_t;
//           htempexp = if hexp < EMin then ExMin * (hexp - EMin + 1) else if hexp > EMax then ExMax * (hexp - EMax + 1) else exp(hexp);
//           is_t = Is * pow(heatPort.T / Tnom, XTI) * htempexp;
//           br_t = Br * pow(heatPort.T / Tnom, XTB);
//           bf_t = Bf * pow(heatPort.T / Tnom, XTB);
//           vt_t = K / q * heatPort.T;
//           ibc = if vbc / (NR * vt_t) < EMin then is_t * (ExMin * (vbc / (NR * vt_t) - EMin + 1) - 1) + vbc * Gbc else if vbc / (NR * vt_t) > EMax then is_t * (ExMax * (vbc / (NR * vt_t) - EMax + 1) - 1) + vbc * Gbc else is_t * (exp(vbc / (NR * vt_t)) - 1) + vbc * Gbc;
//           ibe = if vbe / (NF * vt_t) < EMin then is_t * (ExMin * (vbe / (NF * vt_t) - EMin + 1) - 1) + vbe * Gbe else if vbe / (NF * vt_t) > EMax then is_t * (ExMax * (vbe / (NF * vt_t) - EMax + 1) - 1) + vbe * Gbe else is_t * (exp(vbe / (NF * vt_t)) - 1) + vbe * Gbe;
//           Capcjc = if vbc / Phic > 0 then Cjc * (1 + (Mc * vbc) / Phic) else Cjc * pow(1 - vbc / Phic,  -Mc);
//           Capcje = if vbe / Phie > 0 then Cje * (1 + (Me * vbe) / Phie) else Cje * pow(1 - vbe / Phie,  -Me);
//           cbc = if vbc / (NR * vt_t) < EMin then (Taur * is_t) / (NR * vt_t) * ExMin * (vbc / (NR * vt_t) - EMin + 1) + Capcjc else if vbc / (NR * vt_t) > EMax then (Taur * is_t) / (NR * vt_t) * ExMax * (vbc / (NR * vt_t) - EMax + 1) + Capcjc else (Taur * is_t) / (NR * vt_t) * exp(vbc / (NR * vt_t)) + Capcjc;
//           cbe = if vbe / (NF * vt_t) < EMin then (Tauf * is_t) / (NF * vt_t) * ExMin * (vbe / (NF * vt_t) - EMin + 1) + Capcje else if vbe / (NF * vt_t) > EMax then (Tauf * is_t) / (NF * vt_t) * ExMax * (vbe / (NF * vt_t) - EMax + 1) + Capcje else (Tauf * is_t) / (NF * vt_t) * exp(vbe / (NF * vt_t)) + Capcje;
//           C.i = (ibe - ibc) * qbk - ibc / br_t - cbc * der(vbc) + Ccs * der(C.v);
//           B.i = ibe / bf_t + ibc / br_t + cbc * der(vbc) + cbe * der(vbe);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//           heatPort.Q_dot =  -((vbc * ibc) / br_t + (vbe * ibe) / bf_t + (ibe - ibc) * qbk * (C.v - E.v));
//         end HeatingNPN;
//         model HeatingPNP "Simple PNP BJT according to Ebers-Moll with heating port"
//           parameter Real Bf = 50 "Forward beta";
//           parameter Real Br = 0.1 "Reverse beta";
//           parameter Modelica.SIunits.Current Is = 1e-16 "Transport saturation current";
//           parameter Modelica.SIunits.InversePotential Vak = 0.02 "Early voltage (inverse), 1/Volt";
//           parameter Modelica.SIunits.Time Tauf = 1.2e-10 "Ideal forward transit time";
//           parameter Modelica.SIunits.Time Taur = 5e-09 "Ideal reverse transit time";
//           parameter Modelica.SIunits.Capacitance Ccs = 1e-12 "Collector-substrat(ground) cap.";
//           parameter Modelica.SIunits.Capacitance Cje = 4e-13 "Base-emitter zero bias depletion cap.";
//           parameter Modelica.SIunits.Capacitance Cjc = 5e-13 "Base-coll. zero bias depletion cap.";
//           parameter Modelica.SIunits.Voltage Phie = 0.8 "Base-emitter diffusion voltage";
//           parameter Real Me = 0.4 "Base-emitter gradation exponent";
//           parameter Modelica.SIunits.Voltage Phic = 0.8 "Base-collector diffusion voltage";
//           parameter Real Mc = 0.333 "Base-collector gradation exponent";
//           parameter Modelica.SIunits.Conductance Gbc = 1e-15 "Base-collector conductance";
//           parameter Modelica.SIunits.Conductance Gbe = 1e-15 "Base-emitter conductance";
//           parameter Real EMin =  -100 "if x < EMin, the exp(x) function is linearized";
//           parameter Real EMax = 40 "if x > EMax, the exp(x) function is linearized";
//           parameter Modelica.SIunits.Temperature Tnom = 300.15 "Parameter measurement temperature";
//           parameter Real XTI = 3 "Temperature exponent for effect on Is";
//           parameter Real XTB = 0 "Forward and reverse beta temperature exponent";
//           parameter Real EG = 1.11 "Energy gap for temperature effect on Is";
//           parameter Real NF = 1.0 "Forward current emission coefficient";
//           parameter Real NR = 1.0 "Reverse current emission coefficient";
//           parameter Real K = 1.3806226e-23 "Boltzmann's constant";
//           parameter Real q = 1.6021918e-19 "Elementary electronic charge";
//         protected 
//           Real vcb;
//           Real veb;
//           Real qbk;
//           Real icb;
//           Real ieb;
//           Real ccb;
//           Real ceb;
//           Real ExMin;
//           Real ExMax;
//           Real Capcje;
//           Real Capcjc;
//           Real is_t;
//           Real br_t;
//           Real bf_t;
//           Real vt_t;
//           Real hexp;
//           Real htempexp;
//           annotation(Documentation(info = "
// <HTML>
// <P>
// This model is a simple model of a bipolar pnp junction transistor according
// to Ebers-Moll.
// <P>
// A heating port is added for thermal electric simulation. The heating port
// is defined in the Modelica.Thermal library.
// </P>
// <P>
// A typical parameter set is  (the parameter Vt is no longer used):
// </P>
// <PRE>
//   Bf  Br  Is     Vak  Tauf    Taur  Ccs   Cje     Cjc     Phie  Me   PHic   Mc     Gbc    Gbe  
//   -   -   A      V    s       s     F     F       F       V     -    V      -      mS     mS     
//   50  0.1 1e-16  0.02 0.12e-9 5e-9  1e-12 0.4e-12 0.5e-12 0.8   0.4  0.8    0.333  1e-15  1e-15 
// </PRE>
// <P>
// <DL>
// <DT><b>References:</b>
// <DD>Vlach, J.; Singal, K.: Computer methods for circuit analysis and design.
// Van Nostrand Reinhold, New York 1983
// on page 317 ff.
// </DL>
// 
// </HTML>
// ", revisions = "<html>
// <ul>
// <li><i>March 20, 2004   </i>
//        by Christoph Clauss<br> implemented<br>
//        </li>
// </ul>
// </html>"), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -100,80;100,100], string = "%name"), Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [ -10, -10;5, -17; -3, -25; -10, -10], style(fillColor = 3, fillPattern = 1)), Line(points = [0, -91;0, -30], style(color = 42))), Diagram(Line(points = [ -10,40; -10, -40]), Line(points = [ -10,0; -90,0]), Line(points = [91,50;30,50]), Line(points = [30,50; -10,10]), Line(points = [ -10, -10;30, -50]), Line(points = [30, -50;91, -50]), Polygon(points = [ -10, -10;5, -17; -3, -25; -10, -10], style(fillColor = 3, fillPattern = 1))));
//         public 
//           Modelica.Electrical.Analog.Interfaces.Pin C "Collector" annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Interfaces.Pin B "Base" annotation(extent = [ -90, -10; -110,10]);
//           Modelica.Electrical.Analog.Interfaces.Pin E "Emitter" annotation(extent = [90, -40;110, -60]);
//           Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(T(start = 300.15)) annotation(extent = [ -10, -90;10, -110], rotation =  -90);
// 
//         equation 
//           assert(heatPort.T > 0, "temperature must be positive");
//           ExMin = exp(EMin);
//           ExMax = exp(EMax);
//           vcb = C.v - B.v;
//           veb = E.v - B.v;
//           qbk = 1 - vcb * Vak;
//           hexp = ((heatPort.T / Tnom - 1) * EG) / vt_t;
//           htempexp = if hexp < EMin then ExMin * (hexp - EMin + 1) else if hexp > EMax then ExMax * (hexp - EMax + 1) else exp(hexp);
//           is_t = Is * pow(heatPort.T / Tnom, XTI) * htempexp;
//           br_t = Br * pow(heatPort.T / Tnom, XTB);
//           bf_t = Bf * pow(heatPort.T / Tnom, XTB);
//           vt_t = K / q * heatPort.T;
//           icb = if vcb / (NR * vt_t) < EMin then is_t * (ExMin * (vcb / (NR * vt_t) - EMin + 1) - 1) + vcb * Gbc else if vcb / (NR * vt_t) > EMax then is_t * (ExMax * (vcb / (NR * vt_t) - EMax + 1) - 1) + vcb * Gbc else is_t * (exp(vcb / (NR * vt_t)) - 1) + vcb * Gbc;
//           ieb = if veb / (NF * vt_t) < EMin then is_t * (ExMin * (veb / (NF * vt_t) - EMin + 1) - 1) + veb * Gbe else if veb / (NF * vt_t) > EMax then is_t * (ExMax * (veb / (NF * vt_t) - EMax + 1) - 1) + veb * Gbe else is_t * (exp(veb / (NF * vt_t)) - 1) + veb * Gbe;
//           Capcjc = if vcb / Phic > 0 then Cjc * (1 + (Mc * vcb) / Phic) else Cjc * pow(1 - vcb / Phic,  -Mc);
//           Capcje = if veb / Phie > 0 then Cje * (1 + (Me * veb) / Phie) else Cje * pow(1 - veb / Phie,  -Me);
//           ccb = if vcb / (NR * vt_t) < EMin then (Taur * is_t) / (NR * vt_t) * ExMin * (vcb / (NR * vt_t) - EMin + 1) + Capcjc else if vcb / (NR * vt_t) > EMax then (Taur * is_t) / (NR * vt_t) * ExMax * (vcb / (NR * vt_t) - EMax + 1) + Capcjc else (Taur * is_t) / (NR * vt_t) * exp(vcb / (NR * vt_t)) + Capcjc;
//           ceb = if veb / (NF * vt_t) < EMin then (Tauf * is_t) / (NF * vt_t) * ExMin * (veb / (NF * vt_t) - EMin + 1) + Capcje else if veb / (NF * vt_t) > EMax then (Tauf * is_t) / (NF * vt_t) * ExMax * (veb / (NF * vt_t) - EMax + 1) + Capcje else (Tauf * is_t) / (NF * vt_t) * exp(veb / (NF * vt_t)) + Capcje;
//           C.i = icb / br_t + ccb * der(vcb) + Ccs * der(C.v) + (icb - ieb) * qbk;
//           B.i =  -ieb / bf_t - icb / br_t - ceb * der(veb) - ccb * der(vcb);
//           E.i =  -B.i - C.i + Ccs * der(C.v);
//           heatPort.Q_dot =  -((vcb * icb) / br_t + (veb * ieb) / bf_t + (icb - ieb) * qbk * (E.v - C.v));
//         end HeatingPNP;
//       protected 
//         function pow "Just a helper function for x^y in order that a symbolic engine can apply some transformations more easily"
//           input Real x;
//           input Real y;
//           output Real z;
//         algorithm 
//           z:=x ^ y;
//         end pow;
//         function exlin "Exponential function linearly continued for x > Maxexp"
//           input Real x;
//           input Real Maxexp;
//           output Real z;
//         algorithm 
//           z:=if x > Maxexp then exp(Maxexp) * (1 + x - Maxexp) else exp(x);
//         end exlin;
//       end Semiconductors;
//       package Sensors
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.5, height = 0.24, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains potential, voltage, and current sensors.
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Sensors.mo,v 1.12 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         model PotentialSensor "Sensor to measure the potential"
//           extends Interfaces.AbsoluteSensor;
//           SI.ElectricPotential phi "Absolute voltage potential";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Text(extent = [ -29, -11;30, -70], string = "V", style(color = 0))), Window(x = 0.4, y = 0.32, width = 0.6, height = 0.6));
// 
//         equation 
//           p.i = 0;
//           phi = p.v;
//           phi = outPort.signal[1];
//         end PotentialSensor;
//         model VoltageSensor "Sensor to measure the voltage between two pins"
//           extends Interfaces.RelativeSensor;
//           SI.Voltage v "Voltage between pin p and n (= p.v - n.v)";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0.29, width = 0.6, height = 0.6), Icon(Text(extent = [ -29, -11;30, -70], string = "V", style(color = 0))));
// 
//         equation 
//           p.i = 0;
//           n.i = 0;
//           v = p.v - n.v;
//           v = outPort.signal[1];
//         end VoltageSensor;
//         model CurrentSensor "Sensor to measure the current in a branch"
//           extends Interfaces.RelativeSensor;
//           SI.Current i "current in the branch from p to n";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.07, width = 0.6, height = 0.6), Icon(Text(extent = [ -29, -11;30, -70], string = "A", style(color = 0))));
// 
//         equation 
//           p.v = n.v;
//           p.i = i;
//           n.i =  -i;
//           i = outPort.signal[1];
//         end CurrentSensor;
//       end Sensors;
//       package Sources
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.03, y = 0.04, width = 0.5, height = 0.6, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains time-dependend and controlled voltage and current sources.
// </p>
// 
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// <a href=\"http://people.eas.iis.fhg.de/Christoph.Clauss/\">Christoph Clau&szlig;</a>
//     &lt;<a href=\"mailto:clauss@eas.iis.fhg.de\">clauss@eas.iis.fhg.de</a>&gt;<br>
//     <a href=\"http://people.eas.iis.fhg.de/Andre.Schneider/\">Andr&eacute; Schneider</a>
//     &lt;<a href=\"mailto:schneider@eas.iis.fhg.de\">schneider@eas.iis.fhg.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// 
// <p>
// <dt>
// <b>Version:</b>
// <dd>
// $Id: Sources.mo,v 1.14 2004/06/30 14:50:11 Dag Exp $<br>
// <p>
// <dt>
// <b>Copyright:</b>
// <dd>
// Copyright &copy; 1998-2002, Modelica Association and Fraunhofer-Gesellschaft.<br>
// <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i><br>
// <p>
// </dl>
// </HTML>
// "));
//         model SignalVoltage "Generic voltage source using the input signal as source voltage"
//           extends Interfaces.OnePort;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -50,50;50, -50], style(fillColor = 7)), Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Line(points = [ -50,0;50,0]), Text(extent = [ -100, -120;100, -80], string = "%name")), Window(x = 0.36, y = 0.03, width = 0.62, height = 0.76));
//           Modelica.Blocks.Interfaces.InPort inPort(final n = 1) annotation(extent = [ -20,50;20,90], rotation =  -90);
// 
//         equation 
//           inPort.signal[1] = v;
//         end SignalVoltage;
//         model ConstantVoltage "Source for constant voltage"
//           parameter SI.Voltage V = 1 "Value of constant voltage";
//           extends Interfaces.OnePort;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.33, y = 0.18, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0; -10,0]), Line(points = [ -10,60; -10, -60]), Line(points = [0,30;0, -30]), Line(points = [0,0;90,0]), Text(extent = [ -100, -120;100, -80], string = "%name=%V")), Diagram(Line(points = [ -90,0; -10,0]), Line(points = [ -10,60; -10, -60]), Line(points = [0,30;0, -30]), Line(points = [0,0;90,0])));
// 
//         equation 
//           v = V;
//         end ConstantVoltage;
//         model StepVoltage "Step voltage source"
//           parameter SI.Voltage V = 1 "Height of step";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Step signalSource(height = {V}));
//           annotation(Icon(Line(points = [ -70, -70;0, -70;0,70;69,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -18;0, -18;0,50;80,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -21, -72;25, -90], string = "startTime", style(color = 9)), Line(points = [0, -17;0, -71], style(color = 8, pattern = 2)), Text(extent = [ -68, -36; -22, -54], string = "offset", style(color = 9)), Line(points = [ -13,50; -13, -17], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [2,50; -19,50;2,50], style(color = 8, pattern = 2)), Polygon(points = [ -13, -17; -16, -4; -10, -4; -13, -17; -13, -17], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -13,50; -16,37; -9,37; -13,50], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -68,26; -22,8], string = "V", style(color = 9)), Polygon(points = [ -13, -69; -16, -56; -10, -56; -13, -69; -13, -69], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -13, -18; -13, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -13, -18; -16, -31; -9, -31; -13, -18], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -67,93; -2,67], string = "v = p.v - n.v", style(color = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0, width = 0.72, height = 0.73));
//         end StepVoltage;
//         model RampVoltage "Ramp voltage source"
//           parameter SI.Voltage V = 1 "Height of ramp";
//           parameter SI.Time duration(min = Modelica.Constants.small) = 2 "Duration of ramp";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Ramp signalSource(final height = {V}, final duration = {duration}));
//           annotation(Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -20; -20, -20;50,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -40, -20; -42, -30; -37, -30; -40, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -20; -40, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -80, -33; -41, -49], string = "offset", style(color = 9)), Text(extent = [ -40, -70;6, -88], string = "startTime", style(color = 9)), Text(extent = [ -67,93; -2,67], string = "v = p.v - n.v", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Line(points = [ -19, -20;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [50,50;101,50], style(color = 0, thickness = 2)), Line(points = [50,50;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [50, -20;42, -18;42, -22;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -20, -20; -11, -18; -11, -22; -20, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50,50;48,40;53,40;50,50], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50, -20;47, -10;52, -10;50, -20;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [53,25;82,7], string = "V", style(color = 9)), Text(extent = [0, -17;35, -37], string = "duration", style(color = 9))), Icon(Line(points = [ -80, -60; -50, -60;50,60;80,60], style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.29, y = 0.11, width = 0.6, height = 0.6));
//         end RampVoltage;
//         model SineVoltage "Sine voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Frequency freqHz = 1 "Frequency of sine wave";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Sine signalSource(amplitude = {V}, freqHz = {freqHz}, phase = {phase}));
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.37, y = 0.06, width = 0.6, height = 0.6), Icon(Line(points = [ -70,0; -60.2,29.9; -53.8,46.5; -48.2,58.1; -43.3,65.2; -38.3,69.2; -33.4,69.8; -28.5,67; -23.6,61; -18.6,52; -13,38.6; -5.98,18.6;8.79, -26.9;15.1, -44;20.8, -56.2;25.7, -64;30.6, -68.6;35.5, -70;40.5, -67.9;45.4, -62.5;50.3, -54.1;55.9, -41.3;63, -21.7;70,0], style(color = 8))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -40,0; -31.6,34.2; -26.1,53.1; -21.3,66.4; -17.1,74.6; -12.9,79.1; -8.64,79.8; -4.42,76.6; -0.201,69.7;4.02,59.4;8.84,44.1;14.9,21.2;27.5, -30.8;33, -50.2;37.8, -64.2;42, -73.1;46.2, -78.4;50.5, -80;54.7, -77.6;58.9, -71.5;63.1, -61.9;67.9, -47.2;74, -24.8;80,0], style(color = 0, thickness = 2)), Line(points = [ -41, -2; -80, -2], style(color = 0, thickness = 2)), Text(extent = [ -106, -11; -60, -29], string = "offset", style(color = 9)), Line(points = [ -41, -2; -41, -40], style(color = 8, pattern = 2)), Text(extent = [ -60, -43; -14, -61], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Line(points = [ -9,79;43,79], style(color = 8, pattern = 2)), Line(points = [ -42, -1;50,0], style(color = 8, pattern = 2)), Polygon(points = [33,80;30,67;37,67;33,80], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [37,57;83,39], string = "V", style(color = 9)), Polygon(points = [33,1;30,14;36,14;33,1;33,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [33,79;33,0], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -69,109; -4,83], string = "v = p.v - n.v", style(color = 9))));
//         end SineVoltage;
//         model ExpSineVoltage "Exponentially damped sine voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of sine wave";
//           parameter SI.Frequency freqHz = 2 "Frequency of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Damping damping = 1 "Damping coefficient of sine wave";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.ExpSine signalSource(amplitude = {V}, freqHz = {freqHz}, phase = {phase}, damping = {damping}));
//           annotation(Icon(Line(points = [ -80, -14; -75.2,18.3; -72,36.3; -68.7,50.5; -65.5,60.2; -62.3,65.3; -59.1,65.6; -55.9,61.3; -52.7,53.1; -48.6,38.2; -43,11.8; -35, -27.9; -30.2, -47.7; -26.1, -59.9; -22.1, -67.2; -18.1, -69.3; -14.1, -66.5; -10.1, -59.3; -5.23, -46.1;8.44, -0.3;13.3,12.4;18.1,20.8;22.1,24;26.9,23.2;31.8,17.8;38.2,5.4;51.1, -24.5;57.5, -35.2;63.1, -39.9;68.7, -39.9;75.2, -34.5;80, -27.8], style(color = 8))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -50,0; -46.1,28.2; -43.5,44; -40.9,56.4; -38.2,64.9; -35.6,69.4; -33,69.6; -30.4,65.9; -27.8,58.7; -24.5,45.7; -19.9,22.5; -13.4, -12.2; -9.5, -29.5; -6.23, -40.1; -2.96, -46.5;0.302, -48.4;3.57, -45.9;6.83, -39.6;10.8, -28.1;21.9,12;25.8,23.1;29.7,30.5;33,33.3;36.9,32.5;40.8,27.8;46,16.9;56.5, -9.2;61.7, -18.6;66.3, -22.7;70.9, -22.6;76.1, -18;80, -12.1], style(color = 0, thickness = 2)), Text(extent = [ -78,1; -55, -19], string = "offset", style(color = 9)), Text(extent = [ -72, -36; -26, -54], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Line(points = [ -50,0;18,0], style(color = 8, pattern = 2)), Line(points = [ -50,0; -81,0], style(color = 0, thickness = 2)), Line(points = [ -50,77; -50,0], style(color = 8, pattern = 2)), Line(points = [18, -1;18,76], style(color = 8, pattern = 2)), Line(points = [18,73; -50,73], style(color = 8)), Text(extent = [ -42,88;9,74], string = "1/freqHz", style(color = 9)), Polygon(points = [ -49,73; -40,75; -40,71; -49,73], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [18,73;10,75;10,71;18,73], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -50, -61; -19, -61], style(color = 8)), Polygon(points = [ -18, -61; -26, -59; -26, -63; -18, -61], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -51, -63; -27, -75], string = "t", style(color = 9)), Text(extent = [ -82, -67;108, -96], string = "V*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", style(color = 9)), Line(points = [ -50,0; -50, -40], style(color = 8, pattern = 2)), Line(points = [ -50, -54; -50, -72], style(color = 8, pattern = 2)), Line(points = [18, -76; -1, -48], style(color = 8, pattern = 2)), Text(extent = [ -77,105; -38,92], string = "v = p.v - n.v", style(color = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.33, y = 0.06, width = 0.6, height = 0.75));
//         end ExpSineVoltage;
//         model ExponentialsVoltage " Rising and falling exponential voltage source"
//           parameter Real vMax = 1 "Upper bound for rising edge";
//           parameter SI.Time riseTime(min = 0) = 0.5 "Rise time";
//           parameter SI.Time riseTimeConst(min = Modelica.Constants.small) = 0.1 "Rise time constant";
//           parameter SI.Time fallTimeConst(min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Exponentials signalSource(outMax = {vMax}, riseTime = {riseTime}, riseTimeConst = {riseTimeConst}, fallTimeConst = {fallTimeConst}));
//           annotation(Icon(Line(points = [ -76, -59; -73.2, -44.3; -70.3, -31.1; -66.8, -16.6; -63.3, -4; -59.7,6.92; -55.5,18.18; -51.3,27.7; -46.3,37; -40.6,45.5; -34.3,53.1; -27.2,59.6; -18.7,65.3; -8.1,70.2; -6,71; -3.88,58.5; -1.05,43.7;1.78,30.8;4.606,19.45;8.14,7.3;11.68, -3;15.9, -13.2;20.2, -21.6;25.1, -29.5;30.8, -36.4;37.1, -42.3;44.9, -47.5;54.8, -51.8;64, -54.4], style(color = 8))), Diagram(Line(points = [ -100, -70;84, -70], style(color = 8)), Polygon(points = [100, -70;84, -64;84, -76;100, -70], style(color = 8, fillColor = 8)), Line(points = [ -40, -30; -37.2, -15.3; -34.3, -2.1; -30.8,12.4; -27.3,25; -23.7,35.92; -19.5,47.18; -15.3,56.7; -10.3,66; -4.6,74.5;1.7,82.1;8.8,88.6;17.3,94.3;27.9,99.2;30,100;32.12,87.5;34.95,72.7;37.78,59.8;40.606,48.45;44.14,36.3;47.68,26;51.9,15.8;56.2,7.4;61.1, -0.5;66.8, -7.4;73.1, -13.3;80.9, -18.5;90.8, -22.8;100, -25.4], style(color = 0, thickness = 2)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Text(extent = [ -70,91; -29,71], string = "outPort", style(color = 9)), Text(extent = [ -78, -43; -46, -56], string = "offset", style(color = 9)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -29; -40, -60], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -30; -42, -40; -37, -40; -40, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -39, -30; -80, -30], style(color = 0, thickness = 2)), Text(extent = [ -59, -71; -13, -89], string = "startTime", style(color = 9)), Polygon(points = [ -41, -30; -32, -28; -32, -32; -41, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -30;29, -30], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [29, -30;21, -28;21, -32;29, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -26, -12;19, -28], string = "riseTime", style(color = 9)), Text(extent = [78, -76;102, -96], string = "time", style(color = 9)), Line(points = [ -100, -70;84, -70], style(color = 8)), Polygon(points = [100, -70;84, -64;84, -76;100, -70], style(color = 8, fillColor = 8)), Line(points = [ -40, -30; -37.2, -15.3; -34.3, -2.1; -30.8,12.4; -27.3,25; -23.7,35.92; -19.5,47.18; -15.3,56.7; -10.3,66; -4.6,74.5;1.7,82.1;8.8,88.6;17.3,94.3;27.9,99.2;30,100;32.12,87.5;34.95,72.7;37.78,59.8;40.606,48.45;44.14,36.3;47.68,26;51.9,15.8;56.2,7.4;61.1, -0.5;66.8, -7.4;73.1, -13.3;80.9, -18.5;90.8, -22.8;100, -25.4], style(color = 0, thickness = 2)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Text(extent = [ -70,91; -29,71], string = "outPort", style(color = 9)), Text(extent = [ -78, -43; -46, -56], string = "offset", style(color = 9)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -29; -40, -60], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -30; -42, -40; -37, -40; -40, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -39, -30; -80, -30], style(color = 0, thickness = 2)), Text(extent = [ -59, -71; -13, -89], string = "startTime", style(color = 9)), Polygon(points = [ -41, -30; -32, -28; -32, -32; -41, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -30;29, -30], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [29, -30;21, -28;21, -32;29, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -26, -12;19, -28], string = "riseTime", style(color = 9)), Text(extent = [78, -76;102, -96], string = "time", style(color = 9)), Line(points = [30,100;30, -34], style(color = 8, pattern = 2))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.11, y = 0.12, width = 0.78, height = 0.83));
//         end ExponentialsVoltage;
//         model PulseVoltage "Pulse voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of pulse";
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of period";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Pulse signalSource(amplitude = {V}, width = {width}, period = {period}));
//           annotation(Icon(Line(points = [ -70, -70; -40, -70; -40,70;0,70;0, -70;40, -70;41,70;80,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37, -12; -30, -12; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -1; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -33, -70; -36, -57; -30, -57; -33, -70; -33, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10,0; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -80,0; -20,0; -21,50;21,50;20, -1;41,0;40,50;80,51], style(color = 0, thickness = 2)), Line(points = [ -19,88; -19,49], style(color = 8, pattern = 2)), Line(points = [21,74;21,50], style(color = 9, pattern = 2)), Line(points = [41,88;41,50], style(color = 8, pattern = 2)), Line(points = [ -19,83;42,83], style(color = 8)), Line(points = [ -19,69;21,69], style(color = 8)), Text(extent = [ -9,97;37,85], string = "period", style(color = 9)), Text(extent = [ -18,81;21,69], string = "width", style(color = 9)), Line(points = [ -52,50; -19,50], style(color = 8, pattern = 2)), Line(points = [ -34,50; -34,1], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "V", style(color = 9)), Polygon(points = [ -34,49; -37,36; -30,36; -34,49], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37,14; -31,14; -34,1; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [80,51;80,0;90, -1], style(color = 0, thickness = 2)), Polygon(points = [ -19,69; -10,71; -10,67; -19,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [21,69;13,71;13,67;21,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -19,83; -10,85; -10,81; -19,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [41,83;33,85;33,81;41,83], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78,103; -24,89], string = "v = p.v - n.v", style(color = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.4, y = 0.23, width = 0.6, height = 0.6));
//         end PulseVoltage;
//         model SawToothVoltage "Saw tooth voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of saw tooth";
//           parameter SI.Time period = 1 "Time for one period";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.SawTooth signalSource(amplitude = {V}, period = {period}));
//           annotation(Icon(Line(points = [ -70, -71; -50, -71;10,70;10, -71;70,70;70, -71], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -19; -37, -32; -30, -32; -34, -19], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -20; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -34, -70; -37, -57; -31, -57; -34, -70; -34, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10, -20; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -10,88; -10, -20], style(color = 8, pattern = 2)), Line(points = [30,88;30,59], style(color = 8, pattern = 2)), Line(points = [ -10,83;30,83], style(color = 8)), Text(extent = [ -12,97;34,85], string = "period", style(color = 9)), Line(points = [ -44,60;30,60], style(color = 8, pattern = 2)), Line(points = [ -34,47; -34, -7], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "V", style(color = 9)), Polygon(points = [ -34,60; -37,47; -30,47; -34,60], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -20; -37, -7; -31, -7; -34, -20; -34, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,83; -1,85; -1,81; -10,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [30,83;22,85;22,81;30,83], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -20; -10, -20;30,60;30, -20;72,60;72, -20], style(color = 0, thickness = 2)), Text(extent = [ -77,100; -27,88], string = "v = p.v - n.v", style(color = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.37, y = 0.04, width = 0.6, height = 0.6));
//         end SawToothVoltage;
//         model TrapezoidVoltage "Trapezoidal voltage source"
//           parameter SI.Voltage V = 1 "Amplitude of trapezoid";
//           parameter SI.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//           parameter SI.Time width(final min = 0) = 0.5 "Width duration of trapezoid";
//           parameter SI.Time falling(final min = 0) = 0 "Falling duration of trapezoid";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.Trapezoid signalSource(amplitude = {V}, rising = {rising}, width = {width}, falling = {falling}, period = {period}, nperiod = {nperiod}));
//           annotation(Icon(Line(points = [ -81, -70; -60, -70; -30,70;1,70;30, -70;51, -70;80,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -45, -30; -47, -41; -43, -41; -45, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -45, -31; -45, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -45, -70; -47, -60; -43, -60; -45, -70; -45, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -86, -43; -43, -55], string = "offset", style(color = 9)), Text(extent = [ -47, -69; -1, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -30,81; -30, -70], style(color = 8, pattern = 2)), Line(points = [ -10,59; -10,40], style(color = 8, pattern = 2)), Line(points = [20,59;20,39], style(color = 9, pattern = 2)), Line(points = [40,59;40, -30], style(color = 8, pattern = 2)), Line(points = [ -29,56;40,56], style(color = 8)), Text(extent = [ -8,70;21,60], string = "width", style(color = 9)), Line(points = [ -42,40; -10,40], style(color = 8, pattern = 2)), Line(points = [ -39,40; -39, -19], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -77,14; -40,0], string = "V", style(color = 9)), Polygon(points = [ -29,56; -22,58; -22,54; -29,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,56; -17,58; -17,54; -10,56], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -30; -30, -30; -9,46;21,46;40, -30;60, -30;80,46;100,46], style(color = 0, thickness = 2)), Polygon(points = [ -39,40; -41,29; -37,29; -39,40], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -39, -29; -41, -19; -37, -19; -39, -29; -39, -29], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [60,81;60, -30], style(color = 8, pattern = 2)), Polygon(points = [39,56;32,58;32,54;39,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;27,58;27,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;13,58;13,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -12,56; -5,58; -5,54; -12,56], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -34,70; -5,60], string = "rising", style(color = 9)), Text(extent = [16,70;45,60], string = "falling", style(color = 9)), Text(extent = [ -77,103; -23,91], string = "v = p.v - n.v", style(color = 9)), Line(points = [ -20,76;61,76], style(color = 8)), Polygon(points = [ -29,76; -20,78; -20,74; -29,76], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [61,76;53,78;53,74;61,76], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -2,86;25,77], string = "period", style(color = 9))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.21, y = 0.22, width = 0.6, height = 0.63));
//         end TrapezoidVoltage;
//         model TableVoltage "Voltage source by linear interpolation in a table"
//           parameter Real table[:,:] = [0,0;1,1;2,4] "Table matrix (time = first column, voltage = second column)";
//           extends Interfaces.VoltageSource(redeclare Modelica.Blocks.Sources.TimeTable signalSource(table = table));
//           annotation(Icon(Line(points = [ -66, -36; -66,84;34,84;34, -36; -66, -36; -66, -6;34, -6;34,24; -66,24; -66,54;34,54;34,84; -16,84; -16, -37], style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.25, y = 0.01, width = 0.72, height = 0.86), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;30, -30], style(color = 7, fillColor = 8, fillPattern = 1)), Line(points = [ -20, -30; -20,90;80,90;80, -30; -20, -30; -20,0;80,0;80,30; -20,30; -20,60;80,60;80,90;30,90;30, -31], style(color = 0)), Text(extent = [ -77, -42; -38, -58], string = "offset", style(color = 9)), Polygon(points = [ -31, -30; -33, -40; -28, -40; -31, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -30, -70; -33, -60; -28, -60; -30, -70; -30, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -31, -31; -31, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Text(extent = [ -38, -70;8, -88], string = "startTime", style(color = 9)), Line(points = [ -20, -30; -80, -30], style(color = 8, pattern = 2)), Text(extent = [66, -81;91, -93], string = "time", style(color = 9)), Text(extent = [ -15,83;24,68], string = "time", style(color = 0)), Text(extent = [33,83;76,67], string = "v", style(color = 0)), Text(extent = [ -81,98; -31,85], string = "v = p.v - n.v", style(color = 9))), Documentation(info = "<HTML>
// <p>
// This block generates a voltage source by <b>linear interpolation</b> in
// a table. The time points and voltage values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the voltage to be interpolated.
// The table interpolation has the following proporties:
// </p>
// 
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the voltage value is just returned independantly of the
//     actual time instant, i.e., this is a constant voltage source.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the voltage.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// 
// <p>
// Example:
// </p>
// 
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// 
// If, e.g., time = 1.0, the voltage v =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the voltage v =  2.5,
//     e.g., time = 2.0, the voltage v =  4.0,
//     e.g., time = 5.0, the voltage v = 23.0 (i.e. extrapolation).
// </pre>
// 
// </HTML>
// "));
//         end TableVoltage;
//         model SignalCurrent "Generic current source using the input signal as source current"
//           extends Interfaces.OnePort;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -50,50;50, -50], style(fillColor = 7)), Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Line(points = [0, -50;0,50]), Text(extent = [ -100, -120;100, -80], string = "%name")), Window(x = 0.39, y = 0.19, width = 0.6, height = 0.6));
//           Modelica.Blocks.Interfaces.InPort inPort(final n = 1) annotation(extent = [ -20,51;19,90], rotation =  -90);
// 
//         equation 
//           i = inPort.signal[1];
//         end SignalCurrent;
//         model ConstantCurrent "Source for constant current"
//           parameter SI.Current I = 1 "Value of constant current";
//           extends Interfaces.OnePort;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Line(points = [0, -50;0,50]), Text(extent = [ -100, -120;100, -80], string = "%name=%I")), Window(x = 0.33, y = 0.24, width = 0.6, height = 0.6));
// 
//         equation 
//           i = I;
//         end ConstantCurrent;
//         model StepCurrent "Step current source"
//           parameter SI.Current I = 1 "Height of step";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Step signalSource(height = {I}));
//           annotation(Icon(Line(points = [ -80, -70; -10, -70; -10,70;59,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -18;0, -18;0,50;80,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Text(extent = [ -21, -72;25, -90], string = "startTime", style(color = 9)), Line(points = [0, -17;0, -71], style(color = 8, pattern = 2)), Text(extent = [ -68, -36; -22, -54], string = "offset", style(color = 9)), Line(points = [ -13,50; -13, -17], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [2,50; -19,50;2,50], style(color = 8, pattern = 2)), Polygon(points = [ -13, -17; -16, -4; -10, -4; -13, -17; -13, -17], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -13,50; -16,37; -9,37; -13,50], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -68,26; -22,8], string = "I", style(color = 9)), Polygon(points = [ -13, -69; -16, -56; -10, -56; -13, -69; -13, -69], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -13, -18; -13, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -13, -18; -16, -31; -9, -31; -13, -18], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0, width = 0.72, height = 0.73));
//         end StepCurrent;
//         model RampCurrent "Ramp current source"
//           parameter SI.Current I = 1 "Height of ramp";
//           parameter SI.Time duration(min = Modelica.Constants.small) = 2 "Duration of ramp";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Ramp signalSource(final height = {I}, final duration = {duration}));
//           annotation(Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -80, -20; -20, -20;50,50], style(color = 0, thickness = 2)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -40, -20; -42, -30; -37, -30; -40, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -20; -40, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -80, -33; -41, -49], string = "offset", style(color = 9)), Text(extent = [ -40, -70;6, -88], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Line(points = [ -19, -20;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [50,50;101,50], style(color = 0, thickness = 2)), Line(points = [50,50;50, -20], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [50, -20;42, -18;42, -22;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -20, -20; -11, -18; -11, -22; -20, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50,50;48,40;53,40;50,50], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [50, -20;47, -10;52, -10;50, -20;50, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [53,25;82,7], string = "I", style(color = 9)), Text(extent = [0, -17;35, -37], string = "duration", style(color = 9)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Icon(Line(points = [ -80, -60; -50, -60;50,60;80,60], style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.29, y = 0.11, width = 0.6, height = 0.6));
//         end RampCurrent;
//         model SineCurrent "Sine current source"
//           parameter SI.Current I = 1 "Amplitude of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Frequency freqHz = 1 "Frequency of sine wave";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Sine signalSource(amplitude = {I}, freqHz = {freqHz}, phase = {phase}));
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.37, y = 0.06, width = 0.6, height = 0.6), Icon(Line(points = [ -70,0; -60.2,29.9; -53.8,46.5; -48.2,58.1; -43.3,65.2; -38.3,69.2; -33.4,69.8; -28.5,67; -23.6,61; -18.6,52; -13,38.6; -5.98,18.6;8.79, -26.9;15.1, -44;20.8, -56.2;25.7, -64;30.6, -68.6;35.5, -70;40.5, -67.9;45.4, -62.5;50.3, -54.1;55.9, -41.3;63, -21.7;70,0], style(color = 8))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -40,0; -31.6,34.2; -26.1,53.1; -21.3,66.4; -17.1,74.6; -12.9,79.1; -8.64,79.8; -4.42,76.6; -0.201,69.7;4.02,59.4;8.84,44.1;14.9,21.2;27.5, -30.8;33, -50.2;37.8, -64.2;42, -73.1;46.2, -78.4;50.5, -80;54.7, -77.6;58.9, -71.5;63.1, -61.9;67.9, -47.2;74, -24.8;80,0], style(color = 0, thickness = 2)), Line(points = [ -41, -2; -80, -2], style(color = 0, thickness = 2)), Text(extent = [ -106, -11; -60, -29], string = "offset", style(color = 9)), Line(points = [ -41, -2; -41, -40], style(color = 8, pattern = 2)), Text(extent = [ -60, -43; -14, -61], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Line(points = [ -9,79;43,79], style(color = 8, pattern = 2)), Line(points = [ -42, -1;50,0], style(color = 8, pattern = 2)), Polygon(points = [33,80;30,67;37,67;33,80], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [37,57;83,39], string = "I", style(color = 9)), Polygon(points = [33,1;30,14;36,14;33,1;33,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [33,79;33,0], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -73,82; -53,102], string = "i", style(color = 8))));
//         end SineCurrent;
//         model ExpSineCurrent "Exponentially damped sine current source"
//           parameter Real I = 1 "Amplitude of sine wave";
//           parameter SI.Frequency freqHz = 2 "Frequency of sine wave";
//           parameter SI.Angle phase = 0 "Phase of sine wave";
//           parameter SI.Damping damping = 1 "Damping coefficient of sine wave";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.ExpSine signalSource(amplitude = {I}, freqHz = {freqHz}, phase = {phase}, damping = {damping}));
//           annotation(Icon(Line(points = [ -80, -14; -75.2,18.3; -72,36.3; -68.7,50.5; -65.5,60.2; -62.3,65.3; -59.1,65.6; -55.9,61.3; -52.7,53.1; -48.6,38.2; -43,11.8; -35, -27.9; -30.2, -47.7; -26.1, -59.9; -22.1, -67.2; -18.1, -69.3; -14.1, -66.5; -10.1, -59.3; -5.23, -46.1;8.44, -0.3;13.3,12.4;18.1,20.8;22.1,24;26.9,23.2;31.8,17.8;38.2,5.4;51.1, -24.5;57.5, -35.2;63.1, -39.9;68.7, -39.9;75.2, -34.5;80, -27.8], style(color = 8))), Diagram(Line(points = [ -80, -90; -80,84], style(color = 8)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8)), Line(points = [ -99, -40;85, -40], style(color = 8)), Polygon(points = [101, -40;85, -34;85, -46;101, -40], style(color = 8, fillColor = 8)), Line(points = [ -50,0; -46.1,28.2; -43.5,44; -40.9,56.4; -38.2,64.9; -35.6,69.4; -33,69.6; -30.4,65.9; -27.8,58.7; -24.5,45.7; -19.9,22.5; -13.4, -12.2; -9.5, -29.5; -6.23, -40.1; -2.96, -46.5;0.302, -48.4;3.57, -45.9;6.83, -39.6;10.8, -28.1;21.9,12;25.8,23.1;29.7,30.5;33,33.3;36.9,32.5;40.8,27.8;46,16.9;56.5, -9.2;61.7, -18.6;66.3, -22.7;70.9, -22.6;76.1, -18;80, -12.1], style(color = 0, thickness = 2)), Text(extent = [ -78,1; -55, -19], string = "offset", style(color = 9)), Text(extent = [ -72, -36; -26, -54], string = "startTime", style(color = 9)), Text(extent = [84, -52;108, -72], string = "time", style(color = 9)), Line(points = [ -50,0;18,0], style(color = 8, pattern = 2)), Line(points = [ -50,0; -81,0], style(color = 0, thickness = 2)), Line(points = [ -50,77; -50,0], style(color = 8, pattern = 2)), Line(points = [18, -1;18,76], style(color = 8, pattern = 2)), Line(points = [18,73; -50,73], style(color = 8)), Text(extent = [ -42,88;9,74], string = "1/freqHz", style(color = 9)), Polygon(points = [ -49,73; -40,75; -40,71; -49,73], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [18,73;10,75;10,71;18,73], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -50, -61; -19, -61], style(color = 8)), Polygon(points = [ -18, -61; -26, -59; -26, -63; -18, -61], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -51, -63; -27, -75], string = "t", style(color = 9)), Text(extent = [ -82, -67;108, -96], string = "I*exp(-damping*t)*sin(2*pi*freqHz*t+phase)", style(color = 9)), Line(points = [ -50,0; -50, -40], style(color = 8, pattern = 2)), Line(points = [ -50, -54; -50, -72], style(color = 8, pattern = 2)), Line(points = [18, -76; -1, -48], style(color = 8, pattern = 2)), Text(extent = [ -74,83; -54,103], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.33, y = 0.06, width = 0.6, height = 0.75));
//         end ExpSineCurrent;
//         model ExponentialsCurrent " Rising and falling exponential current source"
//           parameter Real iMax = 1 "Upper bound for rising edge";
//           parameter SI.Time riseTime(min = 0) = 0.5 "Rise time";
//           parameter SI.Time riseTimeConst(min = Modelica.Constants.small) = 0.1 "Rise time constant";
//           parameter SI.Time fallTimeConst(min = Modelica.Constants.small) = riseTimeConst "Fall time constant";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Exponentials signalSource(outMax = {iMax}, riseTime = {riseTime}, riseTimeConst = {riseTimeConst}, fallTimeConst = {fallTimeConst}));
//           annotation(Icon(Line(points = [ -76, -59; -73.2, -44.3; -70.3, -31.1; -66.8, -16.6; -63.3, -4; -59.7,6.92; -55.5,18.18; -51.3,27.7; -46.3,37; -40.6,45.5; -34.3,53.1; -27.2,59.6; -18.7,65.3; -8.1,70.2; -6,71; -3.88,58.5; -1.05,43.7;1.78,30.8;4.606,19.45;8.14,7.3;11.68, -3;15.9, -13.2;20.2, -21.6;25.1, -29.5;30.8, -36.4;37.1, -42.3;44.9, -47.5;54.8, -51.8;64, -54.4], style(color = 8))), Diagram(Line(points = [ -100, -70;84, -70], style(color = 8)), Polygon(points = [100, -70;84, -64;84, -76;100, -70], style(color = 8, fillColor = 8)), Line(points = [ -40, -30; -37.2, -15.3; -34.3, -2.1; -30.8,12.4; -27.3,25; -23.7,35.92; -19.5,47.18; -15.3,56.7; -10.3,66; -4.6,74.5;1.7,82.1;8.8,88.6;17.3,94.3;27.9,99.2;30,100;32.12,87.5;34.95,72.7;37.78,59.8;40.606,48.45;44.14,36.3;47.68,26;51.9,15.8;56.2,7.4;61.1, -0.5;66.8, -7.4;73.1, -13.3;80.9, -18.5;90.8, -22.8;100, -25.4], style(color = 0, thickness = 2)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Polygon(points = [ -40, -70; -43, -60; -38, -60; -40, -70; -40, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -29; -40, -60], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -40, -30; -42, -40; -37, -40; -40, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -39, -30; -80, -30], style(color = 0, thickness = 2)), Text(extent = [ -59, -71; -13, -89], string = "startTime", style(color = 9)), Polygon(points = [ -41, -30; -32, -28; -32, -32; -41, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -40, -30;29, -30], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [29, -30;21, -28;21, -32;29, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -26, -12;19, -28], string = "riseTime", style(color = 9)), Line(points = [ -39, -30; -80, -30], style(color = 0, thickness = 2)), Line(points = [30,100;30, -34], style(color = 8, pattern = 2)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.11, y = 0.12, width = 0.78, height = 0.83));
//         end ExponentialsCurrent;
//         model PulseCurrent "Pulse current source"
//           parameter SI.Current I = 1 "Amplitude of pulse";
//           parameter Real width(final min = Modelica.Constants.small, final max = 100) = 50 "Width of pulse in % of period";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Pulse signalSource(amplitude = {I}, width = {width}, period = {period}));
//           annotation(Icon(Line(points = [ -70, -70; -40, -70; -40,70;0,70;0, -70;40, -70;41,70;80,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37, -12; -30, -12; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -1; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -33, -70; -36, -57; -30, -57; -33, -70; -33, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10,0; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -80,0; -20,0; -21,50;21,50;20, -1;41,0;40,50;80,51], style(color = 0, thickness = 2)), Line(points = [ -19,88; -19,49], style(color = 8, pattern = 2)), Line(points = [21,74;21,50], style(color = 9, pattern = 2)), Line(points = [41,88;41,50], style(color = 8, pattern = 2)), Line(points = [ -19,83;42,83], style(color = 8)), Line(points = [ -19,69;21,69], style(color = 8)), Text(extent = [ -9,97;37,85], string = "period", style(color = 9)), Text(extent = [ -18,81;21,69], string = "width", style(color = 9)), Line(points = [ -52,50; -19,50], style(color = 8, pattern = 2)), Line(points = [ -34,50; -34,1], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "I", style(color = 9)), Polygon(points = [ -34,49; -37,36; -30,36; -34,49], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34,1; -37,14; -31,14; -34,1; -34,1], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [80,51;80,0;90, -1], style(color = 0, thickness = 2)), Polygon(points = [ -19,69; -10,71; -10,67; -19,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [21,69;13,71;13,67;21,69], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -19,83; -10,85; -10,81; -19,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [41,83;33,85;33,81;41,83], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.4, y = 0.23, width = 0.6, height = 0.6));
//         end PulseCurrent;
//         model SawToothCurrent "Saw tooth current source"
//           parameter SI.Current I = 1 "Amplitude of saw tooth";
//           parameter SI.Time period = 1 "Time for one period";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.SawTooth signalSource(amplitude = {I}, period = {period}));
//           annotation(Icon(Line(points = [ -70, -71; -50, -71;10,70;10, -71;70,70;70, -71], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -19; -37, -32; -30, -32; -34, -19], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -34, -20; -34, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -34, -70; -37, -57; -31, -57; -34, -70; -34, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -78, -24; -35, -36], string = "offset", style(color = 9)), Text(extent = [ -31, -69;15, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -10, -20; -10, -70], style(color = 8, pattern = 2)), Line(points = [ -10,88; -10, -20], style(color = 8, pattern = 2)), Line(points = [30,88;30,59], style(color = 8, pattern = 2)), Line(points = [ -10,83;30,83], style(color = 8)), Text(extent = [ -12,97;34,85], string = "period", style(color = 9)), Line(points = [ -44,60;30,60], style(color = 8, pattern = 2)), Line(points = [ -34,47; -34, -7], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -78,34; -37,20], string = "I", style(color = 9)), Polygon(points = [ -34,60; -37,47; -30,47; -34,60], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -34, -20; -37, -7; -31, -7; -34, -20; -34, -20], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,83; -1,85; -1,81; -10,83], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [30,83;22,85;22,81;30,83], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -20; -10, -20;30,60;30, -20;72,60;72, -20], style(color = 0, thickness = 2)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.37, y = 0.04, width = 0.6, height = 0.6));
//         end SawToothCurrent;
//         model TrapezoidCurrent "Trapezoidal current source"
//           parameter SI.Current I = 1 "Amplitude of trapezoid";
//           parameter SI.Time rising(final min = 0) = 0 "Rising duration of trapezoid";
//           parameter SI.Time width(final min = 0) = 0.5 "Width duration of trapezoid";
//           parameter SI.Time falling(final min = 0) = 0 "Falling duration of trapezoid";
//           parameter SI.Time period(final min = Modelica.Constants.small) = 1 "Time for one period";
//           parameter Integer nperiod =  -1 "Number of periods (< 0 means infinite number of periods)";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.Trapezoid signalSource(amplitude = {I}, rising = {rising}, width = {width}, falling = {falling}, period = {period}, nperiod = {nperiod}));
//           annotation(Icon(Line(points = [ -81, -70; -60, -70; -30,70;1,70;30, -70;51, -70;80,70], style(color = 8))), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -45, -30; -47, -41; -43, -41; -45, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -45, -31; -45, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Polygon(points = [ -45, -70; -47, -60; -43, -60; -45, -70; -45, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -86, -43; -43, -55], string = "offset", style(color = 9)), Text(extent = [ -47, -69; -1, -87], string = "startTime", style(color = 9)), Text(extent = [70, -80;94, -100], string = "time", style(color = 9)), Line(points = [ -29,79; -30, -70], style(color = 8, pattern = 2)), Line(points = [ -10,59; -10,40], style(color = 8, pattern = 2)), Line(points = [20,59;20,39], style(color = 9, pattern = 2)), Line(points = [40,59;40, -30], style(color = 8, pattern = 2)), Line(points = [ -20,75;60,75], style(color = 8)), Line(points = [ -29,56;40,56], style(color = 8)), Text(extent = [ -9,88;37,76], string = "period", style(color = 9)), Text(extent = [ -8,70;21,60], string = "width", style(color = 9)), Line(points = [ -42,40; -10,40], style(color = 8, pattern = 2)), Line(points = [ -39,40; -39, -19], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -77,14; -40,0], string = "I", style(color = 9)), Polygon(points = [ -29,56; -22,58; -22,54; -29,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -10,56; -17,58; -17,54; -10,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -29,75; -20,77; -20,73; -29,75], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [60,75;52,77;52,73;60,75], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -80, -30; -30, -30; -9,46;21,46;40, -30;60, -30;80,46;100,46], style(color = 0, thickness = 2)), Polygon(points = [ -39,40; -41,29; -37,29; -39,40], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -39, -29; -41, -19; -37, -19; -39, -29; -39, -29], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [60,80;60, -30], style(color = 8, pattern = 2)), Polygon(points = [39,56;32,58;32,54;39,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;27,58;27,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [20,56;13,58;13,54;20,56], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -12,56; -5,58; -5,54; -12,56], style(color = 8, fillColor = 8, fillPattern = 1)), Text(extent = [ -34,70; -5,60], string = "rising", style(color = 9)), Text(extent = [16,70;45,60], string = "falling", style(color = 9)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.19, y = 0.28, width = 0.6, height = 0.63));
//         end TrapezoidCurrent;
//         model TableCurrent "Current source by linear interpolation in a table"
//           parameter Real table[:,:] = [0,0;1,1;2,4] "Table matrix (time = first column, current = second column)";
//           extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.TimeTable signalSource(table = table));
//           annotation(Icon(Line(points = [ -66, -36; -66,84;34,84;34, -36; -66, -36; -66, -6;34, -6;34,24; -66,24; -66,54;34,54;34,84; -16,84; -16, -37], style(color = 8))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.25, y = 0.01, width = 0.72, height = 0.86), Diagram(Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Line(points = [ -80,68; -80, -80], style(color = 8)), Line(points = [ -90, -70;82, -70], style(color = 8)), Polygon(points = [90, -70;68, -62;68, -78;90, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;30, -30], style(color = 7, fillColor = 8, fillPattern = 1)), Line(points = [ -20, -30; -20,90;80,90;80, -30; -20, -30; -20,0;80,0;80,30; -20,30; -20,60;80,60;80,90;30,90;30, -31], style(color = 0)), Text(extent = [ -77, -42; -38, -58], string = "offset", style(color = 9)), Polygon(points = [ -31, -30; -33, -40; -28, -40; -31, -30], style(color = 8, fillColor = 8, fillPattern = 1)), Polygon(points = [ -30, -70; -33, -60; -28, -60; -30, -70; -30, -70], style(color = 8, fillColor = 8, fillPattern = 1)), Line(points = [ -31, -31; -31, -70], style(color = 8, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -20, -20; -20, -70], style(color = 8, pattern = 2)), Text(extent = [ -38, -70;8, -88], string = "startTime", style(color = 9)), Line(points = [ -20, -30; -80, -30], style(color = 8, pattern = 2)), Text(extent = [66, -81;91, -93], string = "time", style(color = 9)), Text(extent = [ -15,83;24,68], string = "time", style(color = 0)), Text(extent = [33,83;76,67], string = "v", style(color = 0)), Text(extent = [ -73,75; -53,95], string = "i", style(color = 8))), Documentation(info = "<HTML>
// <p>
// This block generates a current source by <b>linear interpolation</b> in
// a table. The time points and current values are stored in a matrix
// <b>table[i,j]</b>, where the first column table[:,1] contains the
// time points and the second column contains the current to be interpolated.
// The table interpolation has the following proporties:
// </p>
// 
// <ul>
// <li>The time points need to be <b>monotonically increasing</b>. </li>
// <li><b>Discontinuities</b> are allowed, by providing the same
//     time point twice in the table. </li>
// <li>Values <b>outside</b> of the table range, are computed by
//     <b>extrapolation</b> through the last or first two points of the
//     table.</li>
// <li>If the table has only <b>one row</b>, no interpolation is performed and
//     the current value is just returned independantly of the
//     actual time instant, i.e., this is a constant current source.</li>
// <li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
//     by the table can be shifted both in time and in the current.
// <li>The table is implemented in a numerically sound way by
//     generating <b>time events</b> at interval boundaries,
//     in order to not integrate over a discontinuous or not differentiable
//     points.
// </li>
// </ul>
// 
// <p>
// Example:
// </p>
// 
// <pre>
//    table = [0  0
//             1  0
//             1  1
//             2  4
//             3  9
//             4 16]
// 
// If, e.g., time = 1.0, the current i =  0.0 (before event), 1.0 (after event)
//     e.g., time = 1.5, the current i =  2.5,
//     e.g., time = 2.0, the current i =  4.0,
//     e.g., time = 5.0, the current i = 23.0 (i.e. extrapolation).
// </pre>
// 
// </HTML>
// "));
//         end TableCurrent;
//       end Sources;
//     end Analog;
//     package MultiPhase "Library for electrical multiphase models"
//       extends Modelica.Icons.Library;
//       annotation(Documentation(info = "<HTML>
// <p>
// This package contains packages for electrical multiphase components, based on Modelica.Electrical.Analog:
// <ul>
// <li>Basic: basic components (resistor, capacitor, inductor, ...)</li>
// <li>Ideal: ideal elements (switches, diode, transformer, ...)</li>
// <li>Sensors: sensors to measure potentials, voltages, and currents</li>
// <li>Sources: time-dependend and controlled voltage and current sources</li>
// </ul>
// This package is intended to be used the same way as Modelica.Electrical.Analog 
// but to make design of multiphase models easier.<br>
// The package is based on the plug: a composite connector containing m pins.<br>
// It is possible to connect plugs to plugs or single pins of a plug to single pins.<br>
// Potentials may be accessed as <tt>plug.pin[].v</tt>, currents may be accessed as <tt>plug.pin[].i</tt>.
// </p>
// <p>
// Further development:
// <ul>
// <li>temperature-dependent resistor</li>
// <li>lines (m-phase models)</li>
// </ul>
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"), uses(Modelica(version = "1.6")));
//       package Basic "Basic components for electrical multiphase models"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains basic analog electrical multiphase components.
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         model Star "Star-connection"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           Interfaces.PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Electrical.Analog.Interfaces.NegativePin pin_n annotation(extent = [90, -10;110,10]);
//           annotation(Icon(Text(extent = [ -100,50;100,99], string = "%name"), Line(points = [80,0;0,0], style(thickness = 2, fillPattern = 1)), Line(points = [0,0; -39,68], style(thickness = 2, fillPattern = 1)), Line(points = [0,0; -38, -69], style(thickness = 2, fillPattern = 1)), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Connects all pins of plug_p to pin_n, thus establishing a so-called star-connection.
// </p>
// </HTML>"));
// 
//         equation 
//           for j in 1:m loop
//           connect(plug_p.pin[j],pin_n);
// 
//           end for;
//         end Star;
//         model Delta "Delta (polygon) connection"
//           parameter Integer m(final min = 2) = 3 "number of phases";
//           Interfaces.PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePlug plug_n(final m = m) annotation(extent = [90, -10;110,10]);
//           annotation(Icon(Text(extent = [ -100,50;100,99], string = "%name"), Line(points = [ -40,68; -40, -70;79,0; -40,68; -40,67], style(thickness = 2, fillPattern = 1)), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Connects in a cyclic way plug_n.pin[j] to plug_p.pin[j+1], 
// thus establishing a so-called delta (or polygon) connection 
// when used in parallel to another component.
// </p>
// </HTML>"));
// 
//         equation 
//           for j in 1:m loop
//           if j < m then
//             connect(plug_n.pin[j],plug_p.pin[j + 1]);
// 
//           else
//             connect(plug_n.pin[j],plug_p.pin[1]);
// 
//           end if;
// 
//           end for;
//         end Delta;
//         model PlugToPin_p "Connect one (positive) Pin to a Plug Connector"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Integer k(final min = 1, final max = m) = 1 "phase index";
//           Interfaces.PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Electrical.Analog.Interfaces.PositivePin pin_p annotation(extent = [90, -10;110,10]);
//           annotation(Icon(Line(points = [ -90,0;90,0]), Text(extent = [ -80,80;80,20], string = "%name"), Text(extent = [ -80, -20;80, -80], string = "k = %k"), Polygon(points = [ -100,10;90,0; -100, -10; -100,10], style(color = 3, fillColor = 3, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// Connects pin <i>k</i> of plug_p to pin_p, leaving the other pins of plug_p unconnected.
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           pin_p.v = plug_p.pin[k].v;
//           for j in 1:m loop
//           plug_p.pin[j].i = if j == k then  -pin_p.i else 0;
// 
//           end for;
//         end PlugToPin_p;
//         model PlugToPin_n "Connect one (negative) Pin to a Plug connector"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Integer k(final min = 1, final max = m) = 1 "phase index";
//           Interfaces.NegativePlug plug_n(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Electrical.Analog.Interfaces.NegativePin pin_n annotation(extent = [92, -10;112,10]);
//           annotation(Icon(Line(points = [ -90,0;92,0]), Text(extent = [ -80,80;80,20], string = "%name"), Text(extent = [ -80, -20;80, -80], string = "k = %k"), Polygon(points = [ -100,10;92,0; -100, -10; -100,10], style(color = 3))), Documentation(info = "<HTML>
// <p>
// Connects pin <i>k</i> of plug_n to pin_n, leaving the other pins of plug_n unconnected.
// </p>
// </HTML>"));
// 
//         equation 
//           pin_n.v = plug_n.pin[k].v;
//           for j in 1:m loop
//           plug_n.pin[j].i = if j == k then  -pin_n.i else 0;
// 
//           end for;
//         end PlugToPin_n;
//         model Resistor "Ideal linear electrical resistors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance R[m] = fill(1, m) "Resistance";
//           Modelica.Electrical.Analog.Basic.Resistor resistor[m](final R = R) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Text(extent = [ -100,40;100,100], string = "%name"), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m resistors (Modelica.Electrical.Analog.Basic.Resistor)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(resistor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(resistor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end Resistor;
//         model Conductor "Ideal linear electrical conductors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance G[m] = fill(1, m) "Conductance";
//           Modelica.Electrical.Analog.Basic.Conductor conductor[m](final G = G) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [ -90,0; -70,0]), Line(points = [70,0;90,0]), Text(extent = [ -100,40;100,100], string = "%name"), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m conductors (Modelica.Electrical.Analog.Basic.Conductor)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p.pin,conductor.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(plug_n.pin,conductor.n) annotation(points = [100,0;10,0], style(color = 3));
//         end Conductor;
//         model Capacitor "Ideal linear electrical capacitors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Capacitance C[m] = fill(1, m) "Capacitance";
//           Modelica.Electrical.Analog.Basic.Capacitor capacitor[m](final C = C) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -100,39;100,99], string = "%name"), Line(points = [ -14,28; -14, -28], style(thickness = 2)), Line(points = [14,28;14, -28], style(thickness = 2)), Line(points = [ -90,0; -14,0]), Line(points = [14,0;90,0]), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m capacitors (Modelica.Electrical.Analog.Basic.Capacitor)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(capacitor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(capacitor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end Capacitor;
//         model Inductor "Ideal linear electrical inductors"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Inductance L[m] = fill(1, m) "Inductance";
//           Modelica.Electrical.Analog.Basic.Inductor inductor[m](final L = L) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -30;60,0], style(color = 7, fillColor = 7)), Line(points = [60,0;90,0]), Line(points = [ -90,0; -60,0]), Text(extent = [ -100,40;100,100], string = "%name"), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m inductors (Modelica.Electrical.Analog.Basic.Inductor)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(inductor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(inductor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end Inductor;
//         model SaturatingInductor "Simple model of inductors with saturation"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Current Inom[m] = fill(1, m) "Nominal current";
//           parameter Modelica.SIunits.Inductance Lnom[m] = fill(1, m) "Nominal inductance at Nominal current";
//           parameter Modelica.SIunits.Inductance Lzer[m] = array(2 * Lnom[j] for j in 1:m) "Inductance near current=0";
//           parameter Modelica.SIunits.Inductance Linf[m] = array(Lnom[j] / 2 for j in 1:m) "Inductance at large currents";
//           Modelica.Electrical.Analog.Basic.SaturatingInductor saturatingInductor[m](final Inom = Inom, final Lnom = Lnom, final Lzer = Lzer, final Linf = Linf) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -20;60,0], style(color = 7, fillColor = 7)), Line(points = [60,0;90,0]), Line(points = [ -90,0; -60,0]), Rectangle(extent = [ -60, -10;60, -20], style(color = 3, rgbcolor = {0,0,255}, gradient = 3, fillColor = 3, rgbfillColor = {0,0,255})), Text(extent = [ -100,40;100,100], string = "%name"), Text(extent = [ -100, -100;100, -40], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m saturating inductors (Modelica.Electrical.Analog.Basic.SaturatingInductor)
// </p>
// <p>
// <b>Attention!!!</b><br>
// Each element of the array of saturatingInductors is only dependent on the current flowing through this element.
// </p>
// </HTML>"));
// 
//         equation 
//           connect(saturatingInductor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(saturatingInductor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, rgbcolor = {0,0,255}));
//         end SaturatingInductor;
//         model Transformer "Multiphase Transformer"
//           extends Interfaces.FourPlug;
//           parameter Modelica.SIunits.Inductance L1[m] = fill(1, m) "Primary inductance";
//           parameter Modelica.SIunits.Inductance L2[m] = fill(1, m) "Secondary inductance";
//           parameter Modelica.SIunits.Inductance M[m] = fill(1, m) "Coupling inductance";
//           Modelica.Electrical.Analog.Basic.Transformer transformer[m](final L1 = L1, final L2 = L2, final M = M) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50]), Text(extent = [ -100,20; -58, -20], string = "L1"), Text(extent = [60,20;100, -20], string = "L2"), Text(extent = [ -20,20;20, -20], string = "M"), Text(extent = [ -80,60;80,100], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m transformers (Modelica.Electrical.Analog.Basic.Transformer)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p1.pin,transformer.p1) annotation(points = [ -100,100; -10,100; -10,5], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(plug_p2.pin,transformer.p2) annotation(points = [100,100;10,100;10,5], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(plug_n1.pin,transformer.n1) annotation(points = [ -100, -100; -10, -100; -10, -5], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(plug_n2.pin,transformer.n2) annotation(points = [100, -100;10, -100;10, -5], style(color = 3, fillColor = 7, fillPattern = 1));
//         end Transformer;
//         model VariableResistor "Ideal linear electrical resistors with variable resistance"
//           extends Interfaces.TwoPlug;
//           Modelica.Blocks.Interfaces.InPort R_Port(final n = m) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.VariableResistor variableResistor[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -70,0]), Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [70,0;90,0]), Line(points = [0,90;0,30], style(color = 73)), Text(extent = [ -100, -100;100, -40], string = "%name"), Text(extent = [ -100,40;100,100], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m variable resistors (Modelica.Electrical.Analog.Basic.VariableResistor)
// </p>
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that none of the R_Port signals should not cross the zero value. 
//   Otherwise depending on the surrounding circuit the probability of singularities is high.
// </P>
// </HTML>"), Diagram);
// 
//         equation 
//           variableResistor.R_Port.signal[1] = R_Port.signal;
//           connect(variableResistor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(variableResistor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, rgbcolor = {0,0,255}));
//         end VariableResistor;
//         model VariableConductor "Ideal linear electrical conductors with variable conductance"
//           extends Interfaces.TwoPlug;
//           Modelica.Blocks.Interfaces.InPort G_Port(final n = m) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.VariableConductor variableConductor[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -70,0]), Rectangle(extent = [ -70,30;70, -30], style(color = 3, fillColor = 7, fillPattern = 1)), Line(points = [70,0;90,0]), Line(points = [0,90;0,30], style(color = 73)), Text(extent = [ -100, -100;100, -40], string = "%name"), Text(extent = [ -100,40;100,100], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m variable conductors (Modelica.Electrical.Analog.Basic.VariableConductor)
// </p>
// <P>
// <b>Attention!!!</b><br>
//   It is recomended that none of the G_Port signals should not cross the zero value. 
//   Otherwise depending on the surrounding circuit the probability of singularities is high.
// </P>
// </HTML>"), Diagram);
// 
//         equation 
//           variableConductor.G_Port.signal[1] = G_Port.signal;
//           connect(variableConductor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(variableConductor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, rgbcolor = {0,0,255}));
//         end VariableConductor;
//         model VariableCapacitor "Ideal linear electrical capacitors with variable capacitance"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Capacitance Cmin[m] = fill(Modelica.Constants.eps, m);
//           Modelica.Blocks.Interfaces.InPort C_Port(final n = m) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.VariableCapacitor variableCapacitor[m](final Cmin = Cmin) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [0,90;0,30], style(color = 73)), Text(extent = [ -100, -100;100, -40], string = "%name"), Text(extent = [ -100,40;100,100], string = "m=%m"), Line(points = [ -90,0; -14,0]), Line(points = [14,0;90,0]), Line(points = [ -14,28; -14, -28], style(thickness = 2)), Line(points = [14,28;14, -28], style(thickness = 2))), Documentation(info = "<HTML>
// <p>
// Contains m variable capacitors (Modelica.Electrical.Analog.Basic.VariableCapacitor)
// </p>
// <P>
// It is required that each C_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// C = Cmin, if 0 &le; C_Port.signal &lt; Cmin, where
// Cmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>"), Diagram);
// 
//         equation 
//           variableCapacitor.C_Port.signal[1] = C_Port.signal;
//           connect(variableCapacitor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(variableCapacitor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, rgbcolor = {0,0,255}));
//         end VariableCapacitor;
//         model VariableInductor "Ideal linear electrical inductors with variable inductance"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Inductance Lmin[m] = fill(Modelica.Constants.eps, m);
//           Modelica.Blocks.Interfaces.InPort L_Port(final n = m) annotation(extent = [ -10,90;10,110], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.VariableInductor variableInductor[m](final Lmin = Lmin) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -100, -100;100, -40], string = "%name"), Text(extent = [ -100,40;100,100], string = "m=%m"), Line(points = [ -90,0; -60,0]), Line(points = [60,0;90,0]), Line(points = [0,90;0,8], style(color = 73)), Ellipse(extent = [ -60, -15; -30,15]), Ellipse(extent = [ -30, -15;0,15]), Ellipse(extent = [0, -15;30,15]), Ellipse(extent = [30, -15;60,15]), Rectangle(extent = [ -60, -30;60,0], style(color = 7, fillColor = 7))), Documentation(info = "<HTML>
// <p>
// Contains m variable inductors (Modelica.Electrical.Analog.Basic.VariableInductor)
// </p>
// <P>
// It is required that each L_Port.signal &ge; 0, otherwise an 
// assertion is raised. To avoid a variable index system,<br>
// L = Lmin, if 0 &le; L_Port.signal &lt; Lmin, where
// Lmin is a parameter with default value Modelica.Constants.eps.
// </P>
// </HTML>"), Diagram);
// 
//         equation 
//           variableInductor.L_Port.signal[1] = L_Port.signal;
//           connect(variableInductor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3, rgbcolor = {0,0,255}));
//           connect(variableInductor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, rgbcolor = {0,0,255}));
//         end VariableInductor;
//       end Basic;
//       package Examples "Multiphase test examples"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains test examples of analog electrical multiphase circuits.
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         model TransformerYY "Test example with multiphase components"
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance LT = 0.003 "Transformer stray inductance";
//           parameter Modelica.SIunits.Resistance RT = 0.05 "Transformer resistance";
//           parameter Modelica.SIunits.Resistance RL = 1 "Load Resistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a Y-Y-transformer with internal impedance (RT, LT) a load resistor RT.<br>
// Using f=5 Hz LT=3mH defines nominal voltage drop of approximately 10 %.<br>
// Simulate for 1 second (2 periods) and compare voltages and currents of source, transformer and load.
// </p>
// </HTML>"), Diagram);
//           Sources.SineVoltage SineVoltage1(V = fill(V, m), freqHz = fill(f, m), m = m) annotation(extent = [ -90,10; -70,30], rotation =  -180);
//           Basic.Star StarS1(m = m) annotation(extent = [ -100, -72; -80, -52], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundS1 annotation(extent = [ -100, -100; -80, -80]);
//           Ideal.IdealTransformer IdealTransformer1(m = m) annotation(extent = [ -40,0; -20,20]);
//           Basic.Star StarT1(m = m) annotation(extent = [ -50, -72; -30, -52], rotation =  -90);
//           Basic.Star StarT2(m = m) annotation(extent = [ -30, -72; -10, -52], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundT2 annotation(extent = [ -30, -100; -10, -80]);
//           Basic.Resistor RT1(m = m, R = fill(RT, m)) annotation(extent = [0,10;20,30]);
//           Basic.Inductor LT1(m = m, L = fill(LT, m)) annotation(extent = [30,10;50,30]);
//           Basic.Resistor RL1(m = m, R = fill(RL, m)) annotation(extent = [70,10;90,30], rotation = 0);
//           Basic.Star StarL1(m = m) annotation(extent = [80, -72;100, -52], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundT1 annotation(extent = [ -50, -100; -30, -80]);
// 
//         equation 
//           connect(StarS1.pin_n,GroundS1.p) annotation(points = [ -90, -72; -90, -80], style(color = 3));
//           connect(StarT1.pin_n,GroundT1.p) annotation(points = [ -40, -72; -40, -72; -40, -80], style(color = 3));
//           connect(StarT2.pin_n,GroundT2.p) annotation(points = [ -20, -72; -20, -80], style(color = 3));
//           connect(StarS1.plug_p,SineVoltage1.plug_n) annotation(points = [ -90, -52; -90,20; -90,20], style(color = 3));
//           connect(SineVoltage1.plug_p,IdealTransformer1.plug_p1) annotation(points = [ -70,20; -40,20], style(color = 3));
//           connect(IdealTransformer1.plug_n1,StarT1.plug_p) annotation(points = [ -40,0; -40, -52], style(color = 3));
//           connect(StarT2.plug_p,IdealTransformer1.plug_n2) annotation(points = [ -20, -52; -20,0], style(color = 3));
//           connect(IdealTransformer1.plug_p2,RT1.plug_p) annotation(points = [ -20,20;0,20], style(color = 3));
//           connect(RT1.plug_n,LT1.plug_p) annotation(points = [20,20;30,20], style(color = 3));
//           connect(LT1.plug_n,RL1.plug_p) annotation(points = [50,20;70,20], style(color = 3));
//           connect(RL1.plug_n,StarL1.plug_p) annotation(points = [90,20;90, -52], style(color = 3));
//         end TransformerYY;
//         model TransformerYD "Test example with multiphase components"
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance LT = 0.003 "Transformer stray inductance";
//           parameter Modelica.SIunits.Resistance RT = 0.05 "Transformer resistance";
//           parameter Modelica.SIunits.Resistance RL = 1 "Load Resistance";
//           parameter Real nT = 1 / sqrt((1 - Modelica.Math.cos((2 * Modelica.Constants.pi) / m)) ^ 2 + Modelica.Math.sin((2 * Modelica.Constants.pi) / m) ^ 2) "Transformer ratio";
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a Y-D-transformer with internal impedance (RT, LT) a load resistor RT.<br>
// Using f=5 Hz LT=3mH defines nominal voltage drop of approximately 10 %.<br>
// Simulate for 1 second (2 periods) and compare voltages and currents of source, transformer and load.
// </p>
// </HTML>"), Diagram);
//           Sources.SineVoltage SineVoltage1(V = fill(V, m), freqHz = fill(f, m), m = m) annotation(extent = [ -90,10; -70,30], rotation =  -180);
//           Basic.Star StarS1(m = m) annotation(extent = [ -100, -72; -80, -52], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundS1 annotation(extent = [ -100, -100; -80, -80]);
//           Ideal.IdealTransformer IdealTransformer1(m = m, n = fill(nT, m)) annotation(extent = [ -40,0; -20,20]);
//           Basic.Star StarT1(m = m) annotation(extent = [ -50, -72; -30, -52], rotation =  -90);
//           Basic.Delta Delta1(m = m) annotation(extent = [60,0;40,20], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundT1 annotation(extent = [ -50, -100; -30, -80]);
//           Basic.Resistor RT1(m = m, R = fill(RT / nT ^ 2, m)) annotation(extent = [ -10,10;10,30]);
//           Basic.Inductor LT1(m = m, L = fill(LT / nT ^ 2, m)) annotation(extent = [20,10;40,30]);
//           Basic.Resistor RL1(m = m, R = fill(RL, m)) annotation(extent = [70,10;90,30], rotation = 0);
//           Basic.Star StarL1(m = m) annotation(extent = [80, -72;100, -52], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundL1 annotation(extent = [80, -100;100, -80]);
// 
//         equation 
//           connect(GroundS1.p,StarS1.pin_n) annotation(points = [ -90, -80; -90, -72], style(color = 3));
//           connect(GroundT1.p,StarT1.pin_n) annotation(points = [ -40, -80; -40, -72], style(color = 3));
//           connect(StarS1.plug_p,SineVoltage1.plug_n) annotation(points = [ -90, -52; -90,20; -90,20], style(color = 3));
//           connect(SineVoltage1.plug_p,IdealTransformer1.plug_p1) annotation(points = [ -70,20; -40,20], style(color = 3));
//           connect(IdealTransformer1.plug_n1,StarT1.plug_p) annotation(points = [ -40,0; -40, -52], style(color = 3));
//           connect(IdealTransformer1.plug_p2,RT1.plug_p) annotation(points = [ -20,20; -10,20], style(color = 3));
//           connect(RT1.plug_n,LT1.plug_p) annotation(points = [10,20;20,20], style(color = 3));
//           connect(LT1.plug_n,Delta1.plug_p) annotation(points = [40,20;50,20], style(color = 3));
//           connect(Delta1.plug_n,IdealTransformer1.plug_n2) annotation(points = [50,0; -20,0], style(color = 3));
//           connect(Delta1.plug_p,RL1.plug_p) annotation(points = [50,20;70,20], style(color = 3));
//           connect(RL1.plug_n,StarL1.plug_p) annotation(points = [90,20;90, -52;90, -52], style(color = 3));
//           connect(StarL1.pin_n,GroundL1.p) annotation(points = [90, -72;90, -80], style(color = 3));
//         end TransformerYD;
//         model Rectifier "Test example with multiphase components"
//           extends Modelica.Icons.Example;
//           parameter Integer m = 3 "Number of phases";
//           parameter Modelica.SIunits.Voltage V = 1 "Amplitude of Star-Voltage";
//           parameter Modelica.SIunits.Frequency f = 5 "Frequency";
//           parameter Modelica.SIunits.Inductance L = 0.001 "Line Inductance";
//           parameter Modelica.SIunits.Resistance RL = 2 "Load Resistance";
//           parameter Modelica.SIunits.Capacitance C = 0.05 "Total DC-Capacitance";
//           parameter Modelica.SIunits.Resistance RE = 1000000.0 "Earthing Resistance";
//           annotation(Documentation(info = "<HTML>
// <p>
// Test example with multiphase components:<br>
// Star-connected voltage source feeds via a line reactor a diode bridge rectifier with a DC burden.<br>
// Using f=5 Hz, simulate for 1 second (2 periods) and compare voltages and currents of source and DC burden, 
// neglecting initial transient.
// </p>
// </HTML>"), Diagram);
//           Sources.SineVoltage SineVoltage1(m = m, V = fill(V, m), freqHz = fill(f, m)) annotation(extent = [ -70, -10; -90,10]);
//           Basic.Star StarS(m = m) annotation(extent = [ -100, -60; -80, -40], rotation =  -90);
//           Basic.Inductor L1(m = m, L = fill(L, m)) annotation(extent = [ -52, -10; -32,10]);
//           Ideal.IdealDiode IdealDiode1(m = m) annotation(extent = [0,10;20,30], rotation = 90);
//           Basic.Star Star1(m = m) annotation(extent = [0,40;20,60], rotation = 90);
//           Ideal.IdealDiode IdealDiode2(m = m) annotation(extent = [0, -30;20, -10], rotation = 90);
//           Basic.Star Star2(m = m) annotation(extent = [0, -60;20, -40], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Resistor RLoad(R = RL) annotation(extent = [40, -10;60,10], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor1(C = 2 * C) annotation(extent = [60,20;80,40], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Capacitor Capacitor2(C = 2 * C) annotation(extent = [60, -40;80, -20], rotation =  -90);
//           Modelica.Electrical.Analog.Basic.Ground GroundDC annotation(extent = [80, -80;100, -60]);
// 
//         equation 
//           connect(Capacitor1.n,Capacitor2.p) annotation(points = [70,20;70, -20], style(color = 3));
//           connect(Capacitor1.n,GroundDC.p) annotation(points = [70,20;70,0;90,0;90, -60], style(color = 3));
//           connect(StarS.plug_p,SineVoltage1.plug_n) annotation(points = [ -90, -40; -90,0], style(color = 3));
//           connect(SineVoltage1.plug_p,L1.plug_p) annotation(points = [ -70,0; -52,0], style(color = 3));
//           connect(IdealDiode1.plug_p,L1.plug_n) annotation(points = [10,10;10,0; -32,0], style(color = 3));
//           connect(IdealDiode2.plug_n,L1.plug_n) annotation(points = [10, -10;10,0; -32,0], style(color = 3));
//           connect(IdealDiode1.plug_n,Star1.plug_p) annotation(points = [10,30;10,40], style(color = 3));
//           connect(IdealDiode2.plug_p,Star2.plug_p) annotation(points = [10, -30;10, -40], style(color = 3));
//           connect(Star2.pin_n,RLoad.n) annotation(points = [10, -60;50, -60;50, -10], style(color = 3));
//           connect(Star2.pin_n,Capacitor2.n) annotation(points = [10, -60;70, -60;70, -40], style(color = 3));
//           connect(Star1.pin_n,RLoad.p) annotation(points = [10,60;50,60;50,10], style(color = 3));
//           connect(Star1.pin_n,Capacitor1.p) annotation(points = [10,60;70,60;70,40], style(color = 3));
//         end Rectifier;
//       end Examples;
//       package Ideal "Multiphase components with idealized behaviour"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains analog electrical multiphase components with idealized behaviour, 
// like thyristor, diode, switch, transformer.
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         model IdealThyristor "Multiphase ideal thyristor"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Roff[m](final min = zeros(m)) = fill(1e-05, m) "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Gon[m](final min = zeros(m)) = fill(1e-05, m) "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           Modelica.Blocks.Interfaces.BooleanInPort firePort(final n = m) annotation(extent = [60,90;80,110], rotation =  -90);
//           Modelica.Electrical.Analog.Ideal.IdealThyristor idealThyristor[m](final Roff = Roff, final Gon = Gon, final Vknee = Vknee) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Line(points = [ -90,0;40,0]), Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [30,40;30, -40], style(color = 3)), Line(points = [40,0;90,0]), Line(points = [40,50;60,30]), Line(points = [30,20;70,60;70,90]), Text(extent = [ -100,100;60,60], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m ideal thyristors (Modelica.Electrical.Analog.Ideal.IdealThyristor).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           idealThyristor.firePort.signal[1] = firePort.signal;
//           connect(plug_p.pin,idealThyristor.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(idealThyristor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end IdealThyristor;
//         model IdealGTOThyristor "Multiphase ideal GTO thyristor"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Roff[m](final min = zeros(m)) = fill(1e-05, m) "Closed thyristor resistance";
//           parameter Modelica.SIunits.Conductance Gon[m](final min = zeros(m)) = fill(1e-05, m) "Opened thyristor conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           Modelica.Blocks.Interfaces.BooleanInPort firePort(final n = m) annotation(extent = [60,90;80,110], rotation =  -90);
//           Modelica.Electrical.Analog.Ideal.IdealGTOThyristor idealGTOThyristor[m](final Roff = Roff, final Gon = Gon, final Vknee = Vknee) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Line(points = [ -90,0;40,0]), Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [30,40;30, -40], style(color = 3)), Line(points = [40,0;90,0]), Line(points = [40,50;60,30]), Line(points = [30,20;70,60;70,90]), Text(extent = [ -100,100;60,60], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m ideal GTO thyristors (Modelica.Electrical.Analog.Ideal.IdealGTOThyristor).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           idealGTOThyristor.firePort.signal[1] = firePort.signal;
//           connect(idealGTOThyristor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(idealGTOThyristor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end IdealGTOThyristor;
//         model IdealCommutingSwitch "Multiphase ideal commuting switch"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = m) annotation(extent = [ -10,88;10,108], rotation =  -90);
//           Interfaces.PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePlug plug_n2(final m = m) annotation(extent = [90, -10;110,10]);
//           Interfaces.NegativePlug plug_n1(final m = m) annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch idealCommutingSwitch[m](final Ron = Ron, final Goff = Goff) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Text(extent = [ -100,100; -20,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m="), Text(extent = [20,100;100,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "%m"), Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -90,0; -44,0]), Line(points = [ -37,2;40,50]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Documentation(info = "<HTML>
// <p>
// Contains m ideal commuting switches (Modelica.Electrical.Analog.Ideal.IdealCommutingSwitch).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           idealCommutingSwitch.control.signal[1] = control.signal;
//           connect(plug_p.pin,idealCommutingSwitch.p) annotation(points = [ -100,0; -10,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idealCommutingSwitch.n2,plug_n2.pin) annotation(points = [10,0;100,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idealCommutingSwitch.n1,plug_n1.pin) annotation(points = [10,5;10,50;100,50], style(color = 3, fillColor = 7, fillPattern = 1));
//         end IdealCommutingSwitch;
//         model IdealIntermediateSwitch "Multiphase ideal intermediate switch"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = m) annotation(extent = [ -10,88;10,108], rotation =  -90);
//           Interfaces.PositivePlug plug_p1(final m = m) annotation(extent = [ -110,40; -90,60]);
//           Interfaces.PositivePlug plug_p2(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.NegativePlug plug_n2(final m = m) annotation(extent = [90, -10;110,10]);
//           Interfaces.NegativePlug plug_n1(final m = m) annotation(extent = [90,40;110,60]);
//           Modelica.Electrical.Analog.Ideal.IdealIntermediateSwitch idealIntermediateSwitch[m](final Ron = Ron, final Goff = Goff) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Text(extent = [ -100,100; -20,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m="), Text(extent = [20,100;100,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "%m"), Ellipse(extent = [ -4,30;4,22]), Line(points = [ -90,0; -44,0]), Line(points = [ -90,50; -44,50]), Line(points = [ -44,0;40,50]), Line(points = [ -44,50;40,0]), Line(points = [40,50;90,50]), Line(points = [0,90;0,25]), Line(points = [40,0;90,0])), Documentation(info = "<HTML>
// <p>
// Contains m ideal intermediate switches (Modelica.Electrical.Analog.Ideal.IdealIntermediateSwitch).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           idealIntermediateSwitch.control.signal[1] = control.signal;
//           connect(plug_p2.pin,idealIntermediateSwitch.p2) annotation(points = [ -100,0; -10,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idealIntermediateSwitch.n2,plug_n2.pin) annotation(points = [10,0;100,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idealIntermediateSwitch.p1,plug_p1.pin) annotation(points = [ -10,5; -10,50; -100,50], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idealIntermediateSwitch.n1,plug_n1.pin) annotation(points = [10,5;10,50;100,50], style(color = 3, fillColor = 7, fillPattern = 1));
//         end IdealIntermediateSwitch;
//         model IdealDiode "Multiphase ideal diode"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Roff[m](final min = zeros(m)) = fill(1e-05, m) "Closed diode resistance";
//           parameter Modelica.SIunits.Conductance Gon[m](final min = zeros(m)) = fill(1e-05, m) "Opened diode conductance";
//           parameter Modelica.SIunits.Voltage Vknee[m](final min = zeros(m)) = zeros(m) "Treshold voltage";
//           Modelica.Electrical.Analog.Ideal.IdealDiode idealDiode[m](final Roff = Roff, final Gon = Gon, final Vknee = Vknee) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Line(points = [ -90,0;40,0]), Polygon(points = [30,0; -30,40; -30, -40;30,0], style(color = 3, gradient = 0, fillColor = 7)), Line(points = [30,40;30, -40], style(color = 3)), Line(points = [40,0;90,0]), Text(extent = [ -100,100;60,60], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m ideal diodes (Modelica.Electrical.Analog.Ideal.IdealDiode).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p.pin,idealDiode.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(idealDiode.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end IdealDiode;
//         model IdealTransformer "Multiphase ideal transformer"
//           extends Interfaces.FourPlug;
//           parameter Real n[m] = fill(1, m) "Turns ratio";
//           Modelica.Electrical.Analog.Ideal.IdealTransformer idealTransformer[m](final n = n) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Ellipse(extent = [ -45, -50; -20, -25]), Ellipse(extent = [ -45, -25; -20,0]), Ellipse(extent = [ -45,0; -20,25]), Ellipse(extent = [ -45,25; -20,50]), Rectangle(extent = [ -72, -60; -33,60], style(color = 7, fillColor = 7)), Line(points = [ -90,50; -32,50]), Line(points = [ -90, -50; -32, -50]), Ellipse(extent = [20, -50;45, -25]), Ellipse(extent = [20, -25;45,0]), Ellipse(extent = [20,0;45,25]), Ellipse(extent = [20,25;45,50]), Rectangle(extent = [33, -60;72,60], style(color = 7, fillColor = 7)), Line(points = [32,50;90,50]), Line(points = [32, -50;90, -50]), Text(extent = [ -80,100;80,60], string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m ideal transformers (Modelica.Electrical.Analog.Ideal.IdealTransformer).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p1.pin,idealTransformer.p1) annotation(points = [ -100,100; -10,100; -10,5], style(color = 3));
//           connect(plug_p2.pin,idealTransformer.p2) annotation(points = [100,100;10,100;10,5], style(color = 3));
//           connect(plug_n1.pin,idealTransformer.n1) annotation(points = [ -100, -100; -10, -100; -10, -5], style(color = 3));
//           connect(plug_n2.pin,idealTransformer.n2) annotation(points = [100, -100;10, -100;10, -5], style(color = 3));
//         end IdealTransformer;
//         model Idle "Multiphase idle branch"
//           extends Interfaces.TwoPlug;
//           Modelica.Electrical.Analog.Ideal.Idle idle[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -100,50;100,110], string = "%name"), Text(extent = [ -100, -110;100, -50], string = "m=%m"), Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [ -90,0; -41,0]), Line(points = [91,0;40,0])), Documentation(info = "<HTML>
// <p>
// Contains m idles (Modelica.Electrical.Analog.Ideal.Idle)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p.pin,idle.p) annotation(points = [ -100,0; -10,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(idle.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, fillColor = 7, fillPattern = 1));
//         end Idle;
//         model Short "Multiphase short cut branch"
//           extends Interfaces.TwoPlug;
//           Modelica.Electrical.Analog.Ideal.Short short[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -100,50;100,110], string = "%name"), Text(extent = [ -100, -110;100, -50], string = "m=%m"), Rectangle(extent = [ -60,60;60, -60], style(fillColor = 7)), Line(points = [ -90,0;90,0])), Documentation(info = "<HTML>
// <p>
// Contains m short cuts (Modelica.Electrical.Analog.Ideal.Short)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(plug_p.pin,short.p) annotation(points = [ -100,0; -10,0], style(color = 3, fillColor = 7, fillPattern = 1));
//           connect(short.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3, fillColor = 7, fillPattern = 1));
//         end Short;
//         model IdealOpener "Multiphase ideal opener"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = m) annotation(extent = [ -10,88;10,108], rotation =  -90);
//           Modelica.Electrical.Analog.Ideal.IdealOpener idealOpener[m](final Ron = Ron, final Goff = Goff) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Line(points = [ -90,0; -44,0]), Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -37,2;40,50]), Line(points = [0,88;0,26]), Line(points = [40,0;90,0]), Text(extent = [ -100,100; -20,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m="), Text(extent = [20,100;100,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "%m"), Line(points = [40,20;40,0])), Documentation(info = "<HTML>
// <p>
// Contains m ideal opening switches (Modelica.Electrical.Analog.Ideal.IdealOpener).
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           idealOpener.control.signal[1] = control.signal;
//           connect(plug_p.pin,idealOpener.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(idealOpener.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end IdealOpener;
//         model IdealCloser "Multiphase ideal closer"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Resistance Ron[m](final min = zeros(m)) = fill(1e-05, m) "Closed switch resistance";
//           parameter Modelica.SIunits.Conductance Goff[m](final min = zeros(m)) = fill(1e-05, m) "Opened switch conductance";
//           Modelica.Blocks.Interfaces.BooleanInPort control(final n = m) annotation(extent = [ -10,88;10,108], rotation =  -90);
//           Modelica.Electrical.Analog.Ideal.IdealCloser idealCloser[m](final Ron = Ron, final Goff = Goff) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -80, -60;80, -100], string = "%name"), Line(points = [ -90,0; -44,0]), Ellipse(extent = [ -44,4; -36, -4]), Line(points = [ -37,2;40,50]), Line(points = [0,88;0,26]), Line(points = [40,0;90,0]), Text(extent = [ -100,100; -20,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m="), Text(extent = [20,100;100,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "%m")), Documentation(info = "<HTML>
// <p>
// Contains m ideal closing switches (Modelica.Electrical.Analog.Ideal.IdealCloser).
// </p><
// /HTML>"), Diagram);
// 
//         equation 
//           idealCloser.control.signal[1] = control.signal;
//           connect(plug_p.pin,idealCloser.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(idealCloser.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end IdealCloser;
//       end Ideal;
//       package Interfaces "Interfaces for electrical multiphase models"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains connectors and interfaces (partial models) for
// electrical multiphase components, based on Modelica.Electrical.Analog.
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         connector Plug "Plug with m pins for an electric component"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           Modelica.Electrical.Analog.Interfaces.Pin pin[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"));
//         end Plug;
//         connector PositivePlug "Positive plug with m pins"
//           extends Plug;
//           annotation(Icon(Ellipse(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3))), Diagram(Ellipse(extent = [ -100,100;100, -100], style(color = 3, fillColor = 3, fillPattern = 1)), Text(extent = [ -100, -99;100, -179], style(color = 3), string = "%name")), Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"));
//         end PositivePlug;
//         connector NegativePlug "Negative plug with m pins"
//           extends Plug;
//           annotation(Icon(Ellipse(extent = [ -100,100;100, -100], style(color = 3, fillColor = 7, fillPattern = 1))), Diagram(Ellipse(extent = [ -100,100;100, -100], style(color = 3, fillColor = 7, fillPattern = 1)), Text(extent = [ -100, -100;100, -180], style(color = 3), string = "%name")), Documentation(info = "<HTML>
// <p>
// Connectors PositivePlug and NegativePlug are nearly identical. 
// The only difference is that the icons are different in order 
// to identify more easily the plugs of a component. 
// Usually, connector PositivePlug is used for the positive and 
// connector NegativePlug for the negative plug of an electrical component.<br>
// Connector Plug is a composite connector containing m Pins (Modelica.Electrical.Analog.Interfaces.Pin).
// </p>
// </HTML>"));
//         end NegativePlug;
//         partial model TwoPlug "Component with one m-phase electric port"
//           parameter Integer m(min = 1) = 3 "number of phases";
//           Modelica.SIunits.Voltage v[m] "Voltage drops between the two plugs";
//           Modelica.SIunits.Current i[m] "Currents flowing into positive plugs";
//           PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           NegativePlug plug_n(final m = m) annotation(extent = [90, -10;110,10]);
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>two</b> electrical plugs: 
// the positive plug connector <i>plug_p</i>, and the negative plug connector <i>plug_n</i>. 
// The currents flowing into plug_p are provided explicitly as currents i[m].
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           v = plug_p.pin.v - plug_n.pin.v;
//           i = plug_p.pin.i;
//         end TwoPlug;
//         partial model OnePort "Component with two electrical plugs and currents from plug_p to plug_n"
//           extends TwoPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>two</b> electrical plugs: 
// the positive plug connector <i>plug_p</i>, and the negative plug connector <i>plug_n</i>. 
// The currents flowing into plug_p are provided explicitly as currents i[m]. 
// It is assumed that the currents flowing into plug_p are identical to the currents flowing out of plug_n.
// </p>
// </HTML>"));
// 
//         equation 
//           plug_p.pin.i + plug_n.pin.i = zeros(m);
//         end OnePort;
//         partial model FourPlug "Component with two m-phase electric ports"
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           Modelica.SIunits.Voltage v1[m] "Voltage drops over the left port";
//           Modelica.SIunits.Voltage v2[m] "Voltage drops over the right port";
//           Modelica.SIunits.Current i1[m] "Current flowing into positive plug of the left port";
//           Modelica.SIunits.Current i2[m] "Current flowing into positive plug of the right port";
//           PositivePlug plug_p1(final m = m) annotation(extent = [ -110,90; -90,110]);
//           PositivePlug plug_p2(final m = m) annotation(extent = [90,90;110,110]);
//           NegativePlug plug_n1(final m = m) annotation(extent = [ -110, -110; -90, -90]);
//           NegativePlug plug_n2(final m = m) annotation(extent = [90, -110;110, -90]);
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>four</b> electrical plugs.
// </p>
// </HTML>"));
// 
//         equation 
//           v1 = plug_p1.pin.v - plug_n1.pin.v;
//           v2 = plug_p2.pin.v - plug_n2.pin.v;
//           i1 = plug_p1.pin.i;
//           i2 = plug_p2.pin.i;
//         end FourPlug;
//         partial model TwoPort "Component with two m-phase electric ports, including currents"
//           extends FourPlug;
//           annotation(Documentation(info = "<HTML>
// <p>
// Superclass of elements which have <b>four</b> electrical plugs. 
// It is assumed that the currents flowing into plug_p1 are identical to the currents flowing out of plug_n1, 
// and that the currents flowing into plug_p2 are identical to the currents flowing out of plug_n2.
// </p>
// </HTML>"));
// 
//         equation 
//           plug_p1.pin.i + plug_n1.pin.i = zeros(m);
//           plug_p2.pin.i + plug_n2.pin.i = zeros(m);
//         end TwoPort;
//         partial model AbsoluteSensor "Base partial model for measuring potentials"
//           extends Modelica.Icons.RotationalSensor;
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           PositivePlug plug_p(m) annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = m) annotation(extent = [100, -10;120,10]);
//           annotation(Icon(Line(points = [70,0;100,0]), Line(points = [ -70,0; -90,0], style(color = 0)), Text(extent = [ -60, -60;60, -100], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m"), Text(extent = [ -100,60;100,100], string = "%name")), Documentation(info = "<HTML>
// <p>
// Superclass for models measuring potentials.
// </p>
// </HTML>"), Diagram);
//         end AbsoluteSensor;
//         partial model RelativeSensor "Base partial model for measuring relative variables between two plugs"
//           extends Modelica.Icons.RotationalSensor;
//           parameter Integer m(final min = 1) = 3 "number of phases";
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = m) annotation(extent = [ -10, -110;10, -90], rotation =  -90);
//           PositivePlug plug_p(final m = m) annotation(extent = [ -110, -10; -90,10]);
//           NegativePlug plug_n(final m = m) annotation(extent = [90, -10;110,10]);
//           annotation(Icon(Line(points = [0, -90;0, -70]), Line(points = [70,0;90,0], style(color = 0)), Line(points = [ -70,0; -90,0], style(color = 0)), Text(extent = [ -60, -60;60, -100], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m"), Text(extent = [ -100,60;100,100], string = "%name")), Documentation(info = "<HTML>
// <p>
// Superclass for models measuring relative variables between plugs.
// </p>
// </HTML>"));
//         end RelativeSensor;
//       end Interfaces;
//       package Sensors "Multiphase potential, voltage and current Sensors"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains multiphase potential, voltage, and current sensors.
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         model PotentialSensor "Multiphase potential sensor"
//           extends Interfaces.AbsoluteSensor;
//           Modelica.SIunits.ElectricPotential phi[m] "Absolute voltage potentials";
//           Modelica.Electrical.Analog.Sensors.PotentialSensor potentialSensor[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Documentation(info = "<HTML>
// <p>
// Contains m potential sensors (Modelica.Electrical.Analog.Sensors.PotentialSensor), 
// thus measuring the m potentials <i>phi[m]</i> of the m pins of plug_p.
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           phi = potentialSensor.outPort.signal[1];
//           outPort.signal = phi;
//           connect(potentialSensor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//         end PotentialSensor;
//         model VoltageSensor "Multiphase voltage sensor"
//           extends Interfaces.RelativeSensor;
//           Modelica.SIunits.Voltage v[m] "Voltages between plug_p and plug_n";
//           Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -29, -11;30, -70], style(color = 0), string = "V")), Documentation(info = "<HTML>
// <p>
// Contains m voltage sensors (Modelica.Electrical.Analog.Sensors.VoltageSensor), 
// thus measuring the m potential differences <i>v[m]</i> between the m pins of plug_p and plug_n. 
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           v = voltageSensor.outPort.signal[1];
//           outPort.signal = v;
//           connect(voltageSensor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//           connect(voltageSensor.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//         end VoltageSensor;
//         model CurrentSensor "Multiphase current sensor"
//           extends Interfaces.RelativeSensor;
//           Modelica.SIunits.Current i[m] "Currents flowing from plug_p to plug_n";
//           Modelica.Electrical.Analog.Sensors.CurrentSensor currentSensor[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Text(extent = [ -31, -11;28, -70], string = "A", style(color = 0))), Documentation(info = "<HTML>
// <p>
// Contains m current sensors (Modelica.Electrical.Analog.Sensors.CurrentSensor), 
// thus measuring the m currents <i>i[m]</i> flowing from the m pins of plug_p to the m pins of plug_n. 
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           i = currentSensor.outPort.signal[1];
//           outPort.signal = i;
//           connect(plug_p.pin,currentSensor.p) annotation(points = [ -100,0; -10,0], style(color = 3));
//           connect(currentSensor.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end CurrentSensor;
//       end Sensors;
//       package Sources "Multiphase voltage and current sources"
//         extends Modelica.Icons.Library;
//         annotation(Documentation(info = "<HTML>
// <p>
// This package contains time-dependend and controlled multiphase voltage and current sources:
// <ul>
// <li>SignalVoltage: fed by Modelica.Blocks.Sources arbitrary waveforms of voltages are possible</li>
// <li>SineVoltage : phase shift between consecutive voltages by default <tt>= pi/m</tt></li>
// <li>SignalCurrent: fed by Modelica.Blocks.Sources arbitrary waveforms of currents are possible</li>
// <li>SineCurrent : phase shift between consecutive currents by default <tt>= pi/m</tt></li>
// </ul>
// </p>
// <dl>
// <p>
//   <dt><b>Main Authors:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> v1.00 2004/06/25 Anton Haumer</li>
//   </ul>
//   </dd>
// <p>
//   <dt><b>Copyright:</b></dt>
//   <dd>Copyright &copy; 1998-2004, Modelica Association and Anton Haumer.<br>
//   <i>The Modelica package is <b>free</b> software; it can be redistributed and/or modified
//   under the terms of the <b>Modelica license</b>, see the license conditions
//   and the accompanying <b>disclaimer</b> in the documentation of package
//   Modelica in file \"Modelica/package.mo\".</i></dd>
// </p>
// </dl>
// </HTML>"));
//         model SignalVoltage "Multiphase signal voltage source"
//           extends Interfaces.TwoPlug;
//           Modelica.Blocks.Interfaces.InPort inPort(final n = m) annotation(extent = [ -20,50;20,90], rotation =  -90);
//           Modelica.Electrical.Analog.Sources.SignalVoltage signalVoltage[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [ -50,0;50,0]), Text(extent = [ -100, -100;100, -60], string = "%name"), Text(extent = [ -60,20;60, -20], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m signal controlled voltage sources (Modelica.Electrical.Analog.Sources.SignalVoltage)
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           signalVoltage.inPort.signal[1] = inPort.signal;
//           connect(signalVoltage.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(signalVoltage.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end SignalVoltage;
//         model SineVoltage "Multiphase sine voltage source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Voltage V[m] = fill(1, m) "Amplitudes of sine waves";
//           parameter Modelica.SIunits.Angle phase[m] =  -array((j - 1) / m * 2 * Modelica.Constants.pi for j in 1:m) "Phases of sine waves";
//           parameter Modelica.SIunits.Frequency freqHz[m] = fill(1, m) "Frequencies of sine waves";
//           parameter Modelica.SIunits.Voltage offset[m] = zeros(m) "Voltage offsets";
//           parameter Modelica.SIunits.Time startTime[m] = zeros(m) "Time offsets";
//           Modelica.Electrical.Analog.Sources.SineVoltage sineVoltage[m](final V = V, final phase = phase, final freqHz = freqHz, final offset = offset, final startTime = startTime) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [ -50,0;50,0]), Line(points = [ -70,0; -60.2,29.9; -53.8,46.5; -48.2,58.1; -43.3,65.2; -38.3,69.2; -33.4,69.8; -28.5,67; -23.6,61; -18.6,52; -13,38.6; -5.98,18.6;8.79, -26.9;15.1, -44;20.8, -56.2;25.7, -64;30.6, -68.6;35.5, -70;40.5, -67.9;45.4, -62.5;50.3, -54.1;55.9, -41.3;63, -21.7;70,0], style(color = 8)), Text(extent = [ -100, -100;100, -60], string = "%name"), Text(extent = [ -60,100;60,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m sine voltage sources (Modelica.Electrical.Analog.Sources.SineVoltage) 
// with a default phase shift of -(j-1)/m * 2*pi for j in 1:m.
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(sineVoltage.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(sineVoltage.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end SineVoltage;
//         model SignalCurrent "Multiphase sine current source"
//           extends Interfaces.TwoPlug;
//           Modelica.Blocks.Interfaces.InPort inPort(final n = m) annotation(extent = [ -20,50;20,90], rotation =  -90);
//           Modelica.Electrical.Analog.Sources.SignalCurrent signalCurrent[m] annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [0,50;0, -50]), Text(extent = [ -100, -100;100, -60], string = "%name"), Text(extent = [ -60,20;60, -20], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m signal controlled current sources (Modelica.Electrical.Analog.Sources.SignalCurrent) 
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           signalCurrent.inPort.signal[1] = inPort.signal;
//           connect(signalCurrent.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(signalCurrent.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end SignalCurrent;
//         model SineCurrent "Multiphase sine current source"
//           extends Interfaces.TwoPlug;
//           parameter Modelica.SIunits.Current I[m] = fill(1, m) "Amplitudes of sine waves";
//           parameter Modelica.SIunits.Angle phase[m] =  -array((j - 1) / m * 2 * Modelica.Constants.pi for j in 1:m) "Phases of sine waves";
//           parameter Modelica.SIunits.Frequency freqHz[m] = fill(1, m) "Frequencies of sine waves";
//           parameter Modelica.SIunits.Voltage offset[m] = zeros(m) "Voltage offsets";
//           parameter Modelica.SIunits.Time startTime[m] = zeros(m) "Time offsets";
//           Modelica.Electrical.Analog.Sources.SineCurrent sineCurrent[m](final I = I, final phase = phase, final freqHz = freqHz, final offset = offset, final startTime = startTime) annotation(extent = [ -10, -10;10,10]);
//           annotation(Icon(Line(points = [ -90,0; -50,0]), Line(points = [50,0;90,0]), Ellipse(extent = [ -50,50;50, -50], style(color = 3, fillColor = 7)), Line(points = [0,50;0, -50]), Line(points = [ -70,0; -60.2,29.9; -53.8,46.5; -48.2,58.1; -43.3,65.2; -38.3,69.2; -33.4,69.8; -28.5,67; -23.6,61; -18.6,52; -13,38.6; -5.98,18.6;8.79, -26.9;15.1, -44;20.8, -56.2;25.7, -64;30.6, -68.6;35.5, -70;40.5, -67.9;45.4, -62.5;50.3, -54.1;55.9, -41.3;63, -21.7;70,0], style(color = 8)), Text(extent = [ -100, -100;100, -60], string = "%name"), Text(extent = [ -60,100;60,60], style(color = 3, fillColor = 3, fillPattern = 1), string = "m=%m")), Documentation(info = "<HTML>
// <p>
// Contains m sine current sources (Modelica.Electrical.Analog.Sources.SineCurrent) 
// with a default phase shift of -(j-1)/m * 2*pi for j in 1:m.
// </p>
// </HTML>"), Diagram);
// 
//         equation 
//           connect(sineCurrent.p,plug_p.pin) annotation(points = [ -10,0; -100,0], style(color = 3));
//           connect(sineCurrent.n,plug_n.pin) annotation(points = [10,0;100,0], style(color = 3));
//         end SineCurrent;
//       end Sources;
//     end MultiPhase;
//   end Electrical;
//   package Math "Mathematical functions"
//     import SI = Modelica.SIunits;
//     extends Modelica.Icons.Library2;
//     annotation(Window(x = 0.04, y = 0.05, width = 0.44, height = 0.68, library = 1, autolayout = 1), Invisible = true, Icon(Text(extent = [ -59, -9;42, -56], string = "f(x)", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This package contains the following basic mathematical functions:
// </p>
// 
// <pre>
//    <b>sin</b>(u)        sine
//    <b>cos</b>(u)        cosine
//    <b>tan</b>(u)        tangent     (u shall not be -pi/2, pi/2, 3*pi/2, ...)
//    <b>asin</b>(u)       inverse sine    (-1 <= u <= 1)
//    <b>acos</b>(u)       inverse cosine  (-1 <= u <= 1)
//    <b>atan</b>(u)       inverse tangent
//    <b>atan2</b>(u1,u2)  four quadrant inverse tangent
//    <b>sinh</b>(u)       hyperbolic sine
//    <b>cosh</b>(u)       hyperbolic cosine
//    <b>tanh</b>(u)       hyperbolic tangent
//    <b>exp</b>(u)        exponential, base e
//    <b>log</b>(u)        natural (base e) logarithm (u > 0)
//    <b>log10</b>(u)      base 10 logarithm (u > 0)
// </pre>
// 
// <p>
// These functions are used by calling them directly
// with a full name (e.g. y = Modelica.Math.asin(0.5)).
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Function tempInterpol2 added.</li>
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Icons for icon and diagram level introduced.</li>
// 
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// 
// </HTML>
// "));
//     partial function baseIcon1 "Basic icon for mathematical function with y-axis on left side"
//       annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, fillColor = 7)), Line(points = [ -80, -80; -80,68], style(color = 8)), Polygon(points = [ -80,90; -88,68; -72,68; -80,90], style(color = 8, fillColor = 8)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Line(points = [ -80,80; -88,80], style(color = 8)), Line(points = [ -80, -80; -88, -80], style(color = 8)), Line(points = [ -80, -90; -80,84], style(color = 8)), Text(extent = [ -75,110; -55,90], string = "y", style(color = 9)), Polygon(points = [ -80,100; -86,84; -74,84; -80,100], style(color = 8, fillColor = 8))));
//     end baseIcon1;
//     partial function baseIcon2 "Basic icon for mathematical function with y-axis in middle"
//       annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, fillColor = 7)), Line(points = [0, -80;0,68], style(color = 8)), Polygon(points = [0,90; -8,68;8,68;0,90], style(color = 8, fillColor = 8)), Text(extent = [ -150,150;150,110], string = "%name")), Diagram(Line(points = [0,80; -8,80], style(color = 8)), Line(points = [0, -80; -8, -80], style(color = 8)), Line(points = [0, -90;0,84], style(color = 8)), Text(extent = [5,110;25,90], string = "y", style(color = 9)), Polygon(points = [0,100; -6,84;6,84;0,100], style(color = 8, fillColor = 8))));
//     end baseIcon2;
//     function sin "sine"
//       extends baseIcon1;
//       input SI.Angle u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.02, y = 0.21, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80,0; -68.7,34.2; -61.5,53.1; -55.1,66.4; -49.4,74.6; -43.8,79.1; -38.2,79.8; -32.6,76.6; -26.9,69.7; -21.3,59.4; -14.9,44.1; -6.83,21.2;10.1, -30.8;17.3, -50.2;23.7, -64.2;29.3, -73.1;35, -78.4;40.6, -80;46.2, -77.6;51.9, -71.5;57.5, -61.9;63.9, -47.2;72, -24.8;80,0], style(color = 0)), Text(extent = [12,84;84,36], string = "sin", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80,0; -68.7,34.2; -61.5,53.1; -55.1,66.4; -49.4,74.6; -43.8,79.1; -38.2,79.8; -32.6,76.6; -26.9,69.7; -21.3,59.4; -14.9,44.1; -6.83,21.2;10.1, -30.8;17.3, -50.2;23.7, -64.2;29.3, -73.1;35, -78.4;40.6, -80;46.2, -77.6;51.9, -71.5;57.5, -61.9;63.9, -47.2;72, -24.8;80,0], style(color = 0)), Text(extent = [ -105,72; -85,88], string = "1"), Text(extent = [70,25;90,5], string = "2*pi"), Text(extent = [ -105, -72; -85, -88], string = "-1"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = sin(u) ;
//     end sin;
//     function cos "cosine"
//       extends baseIcon1;
//       input SI.Angle u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.28, y = 0.06, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -74.4,78.1; -68.7,72.3; -63.1,63; -56.7,48.7; -48.6,26.6; -29.3, -32.5; -22.1, -51.7; -15.7, -65.3; -10.1, -73.8; -4.42, -78.8;1.21, -79.9;6.83, -77.1;12.5, -70.6;18.1, -60.6;24.5, -45.7;32.6, -23;50.3,31.3;57.5,50.7;63.9,64.6;69.5,73.4;75.2,78.6;80,80], style(color = 0)), Text(extent = [ -36,82;36,34], string = "cos", style(color = 8))), Diagram(Text(extent = [ -105,72; -85,88], string = "1"), Text(extent = [ -105, -72; -85, -88], string = "-1"), Text(extent = [70,25;90,5], string = "2*pi"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -74.4,78.1; -68.7,72.3; -63.1,63; -56.7,48.7; -48.6,26.6; -29.3, -32.5; -22.1, -51.7; -15.7, -65.3; -10.1, -73.8; -4.42, -78.8;1.21, -79.9;6.83, -77.1;12.5, -70.6;18.1, -60.6;24.5, -45.7;32.6, -23;50.3,31.3;57.5,50.7;63.9,64.6;69.5,73.4;75.2,78.6;80,80], style(color = 0)), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = cos(u) ;
//     end cos;
//     function tan "tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
//       extends baseIcon2;
//       input SI.Angle u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.31, y = 0.01, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -78.4, -68.4; -76.8, -59.7; -74.4, -50; -71.2, -40.9; -67.1, -33; -60.7, -24.8; -51.1, -17.2; -35.8, -9.98; -4.42, -1.07;33.4,9.12;49.4,16.2;59.1,23.2;65.5,30.6;70.4,39.1;73.6,47.4;76,56.1;77.6,63.8;80,80], style(color = 0)), Text(extent = [ -90,72; -18,24], string = "tan", style(color = 8))), Diagram(Text(extent = [ -37, -72; -17, -88], string = "-5.8"), Text(extent = [ -33,86; -13,70], string = " 5.8"), Text(extent = [70,25;90,5], string = "1.4"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -78.4, -68.4; -76.8, -59.7; -74.4, -50; -71.2, -40.9; -67.1, -33; -60.7, -24.8; -51.1, -17.2; -35.8, -9.98; -4.42, -1.07;33.4,9.12;49.4,16.2;59.1,23.2;65.5,30.6;70.4,39.1;73.6,47.4;76,56.1;77.6,63.8;80,80], style(color = 0)), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = tan(u) ;
//     end tan;
//     function asin "inverse sine (-1 <= u <= 1)"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.29, y = 0.02, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -72.8; -77.6, -67.5; -73.6, -59.4; -66.3, -49.8; -53.5, -37.3; -30.2, -19.7;37.4,24.8;57.5,40.8;68.7,52.7;75.2,62.2;77.6,67.5;80,80], style(color = 0)), Text(extent = [ -88,78; -16,30], string = "asin", style(color = 8))), Diagram(Text(extent = [ -40, -72; -15, -88], string = "-pi/2"), Text(extent = [ -38,88; -13,72], string = " pi/2"), Text(extent = [70,25;90,5], string = "+1"), Text(extent = [ -90,21; -70,1], string = "-1"), Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -72.8; -77.6, -67.5; -73.6, -59.4; -66.3, -49.8; -53.5, -37.3; -30.2, -19.7;37.4,24.8;57.5,40.8;68.7,52.7;75.2,62.2;77.6,67.5;80,80], style(color = 0)), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = asin(u) ;
//     end asin;
//     function acos "inverse cosine (-1 <= u <= 1)"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.37, y = 0.09, width = 0.6, height = 0.6), Icon(Line(points = [ -90, -80;68, -80], style(color = 8)), Polygon(points = [90, -80;68, -72;68, -88;90, -80], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -79.2,72.8; -77.6,67.5; -73.6,59.4; -66.3,49.8; -53.5,37.3; -30.2,19.7;37.4, -24.8;57.5, -40.8;68.7, -52.7;75.2, -62.2;77.6, -67.5;80, -80], style(color = 0)), Text(extent = [ -86, -14; -14, -62], string = "acos", style(color = 8))), Diagram(Line(points = [ -100, -80;84, -80], style(color = 8)), Polygon(points = [100, -80;84, -74;84, -86;100, -80], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -79.2,72.8; -77.6,67.5; -73.6,59.4; -66.3,49.8; -53.5,37.3; -30.2,19.7;37.4, -24.8;57.5, -40.8;68.7, -52.7;75.2, -62.2;77.6, -67.5;80, -80], style(color = 0)), Text(extent = [ -30,88; -5,72], string = " pi"), Text(extent = [ -94, -57; -74, -77], string = "-1"), Text(extent = [80, -45;100, -65], string = "+1"), Text(extent = [90, -82;110, -102], string = "u", style(color = 9))));
// 
//       external "C" y = acos(u) ;
//     end acos;
//     function atan "inverse tangent"
//       extends baseIcon2;
//       input Real u;
//       output SI.Angle y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -52.7, -75.2; -37.4, -69.7; -26.9, -63; -19.7, -55.2; -14.1, -45.8; -10.1, -36.4; -6.03, -23.9; -1.21, -5.06;5.23,21;9.25,34.1;13.3,44.2;18.1,52.9;24.5,60.8;33.4,67.6;47,73.6;69.5,78.6;80,80], style(color = 0)), Text(extent = [ -86,68; -14,20], string = "atan", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -52.7, -75.2; -37.4, -69.7; -26.9, -63; -19.7, -55.2; -14.1, -45.8; -10.1, -36.4; -6.03, -23.9; -1.21, -5.06;5.23,21;9.25,34.1;13.3,44.2;18.1,52.9;24.5,60.8;33.4,67.6;47,73.6;69.5,78.6;80,80], style(color = 0)), Text(extent = [ -32,91; -12,71], string = "1.4"), Text(extent = [ -32, -71; -12, -91], string = "-1.4"), Text(extent = [73,26;93,10], string = " 5.8"), Text(extent = [ -103,20; -83,4], string = "-5.8"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = atan(u) ;
//     end atan;
//     function atan2 "four quadrant inverse tangent"
//       extends baseIcon2;
//       input Real u1;
//       input Real u2;
//       output SI.Angle y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [0, -80;8.93, -67.2;17.1, -59.3;27.3, -53.6;42.1, -49.4;69.9, -45.8;80, -45.1], style(color = 0)), Line(points = [ -80, -34.9; -46.1, -31.4; -29.4, -27.1; -18.3, -21.5; -10.3, -14.5; -2.03, -3.17;7.97,11.6;15.5,19.4;24.3,25;39,30;62.1,33.5;80,34.9], style(color = 0)), Line(points = [ -80,45.1; -45.9,48.7; -29.1,52.9; -18.1,58.6; -10.2,65.8; -1.82,77.2;0,80], style(color = 0)), Text(extent = [ -90, -46; -18, -94], string = "atan2", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [0, -80;8.93, -67.2;17.1, -59.3;27.3, -53.6;42.1, -49.4;69.9, -45.8;80, -45.1], style(color = 0)), Line(points = [ -80, -34.9; -46.1, -31.4; -29.4, -27.1; -18.3, -21.5; -10.3, -14.5; -2.03, -3.17;7.97,11.6;15.5,19.4;24.3,25;39,30;62.1,33.5;80,34.9], style(color = 0)), Line(points = [ -80,45.1; -45.9,48.7; -29.1,52.9; -18.1,58.6; -10.2,65.8; -1.82,77.2;0,80], style(color = 0)), Text(extent = [ -30,89; -10,70], string = "pi"), Text(extent = [ -30, -69; -10, -88], string = "-pi"), Text(extent = [ -30,49; -10,30], string = "pi/2"), Line(points = [0,40; -8,40], style(color = 8)), Line(points = [0, -40; -8, -40], style(color = 8)), Text(extent = [ -30, -31; -10, -50], string = "-pi/2"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))), Documentation(info = "<HTML>
// y = atan2(u1,u2) computes y such that tan(y) = u1/u2 and
// y is in the range -pi < y < pi. u2 may be zero, provided
// u1 is not zero.
// </HTML>
// "));
// 
//       external "C" y = atan2(u1,u2) ;
//     end atan2;
//     function sinh "hyperbolic sine"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -76, -65.4; -71.2, -51.4; -65.5, -38.8; -59.1, -28.1; -51.1, -18.7; -41.4, -11.4; -27.7, -5.5; -4.42, -0.653;24.5,4.57;39,10.1;49.4,17.2;57.5,25.9;63.9,35.8;69.5,47.4;74.4,60.4;78.4,73.8;80,80], style(color = 0)), Text(extent = [ -88,80; -16,32], string = "sinh", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -76, -65.4; -71.2, -51.4; -65.5, -38.8; -59.1, -28.1; -51.1, -18.7; -41.4, -11.4; -27.7, -5.5; -4.42, -0.653;24.5,4.57;39,10.1;49.4,17.2;57.5,25.9;63.9,35.8;69.5,47.4;74.4,60.4;78.4,73.8;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "27"), Text(extent = [ -35, -88; -15, -72], string = "-27"), Text(extent = [70,25;90,5], string = "4"), Text(extent = [ -98,21; -78,1], string = "-4"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = sinh(u) ;
//     end sinh;
//     function cosh "hyperbolic cosine"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.4, y = 0.05, width = 0.6, height = 0.6), Icon(Line(points = [ -90, -86.083;68, -86.083], style(color = 8)), Polygon(points = [90, -86.083;68, -78.083;68, -94.083;90, -86.083], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -77.6,61.1; -74.4,39.3; -71.2,20.7; -67.1,1.29; -63.1, -14.6; -58.3, -29.8; -52.7, -43.5; -46.2, -55.1; -39, -64.3; -30.2, -71.7; -18.9, -77.1; -4.42, -79.9;10.9, -79.1;23.7, -75.2;34.2, -68.7;42.2, -60.6;48.6, -51.2;54.3, -40;59.1, -27.5;63.1, -14.6;67.1,1.29;71.2,20.7;74.4,39.3;77.6,61.1;80,80], style(color = 0)), Text(extent = [4,66;66,20], string = "cosh", style(color = 8))), Diagram(Line(points = [ -100, -86.083;84, -86.083], style(color = 8)), Polygon(points = [100, -86.083;84, -80.083;84, -92.083;100, -86.083], style(color = 8, fillColor = 8)), Line(points = [ -80,80; -77.6,61.1; -74.4,39.3; -71.2,20.7; -67.1,1.29; -63.1, -14.6; -58.3, -29.8; -52.7, -43.5; -46.2, -55.1; -39, -64.3; -30.2, -71.7; -18.9, -77.1; -4.42, -79.9;10.9, -79.1;23.7, -75.2;34.2, -68.7;42.2, -60.6;48.6, -51.2;54.3, -40;59.1, -27.5;63.1, -14.6;67.1,1.29;71.2,20.7;74.4,39.3;77.6,61.1;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "27"), Text(extent = [76, -61;96, -81], string = "4"), Text(extent = [ -104, -63; -84, -83], string = "-4"), Text(extent = [90, -88;110, -108], string = "u", style(color = 9))));
// 
//       external "C" y = cosh(u) ;
//     end cosh;
//     function tanh "hyperbolic tangent"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -47.8, -78.7; -35.8, -75.7; -27.7, -70.6; -22.1, -64.2; -17.3, -55.9; -12.5, -44.3; -7.64, -29.2; -1.21, -4.82;6.83,26.3;11.7,42;16.5,54.2;21.3,63.1;26.9,69.9;34.2,75;45.4,78.4;72,79.9;80,80], style(color = 0)), Text(extent = [ -88,72; -16,24], string = "tanh", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -47.8, -78.7; -35.8, -75.7; -27.7, -70.6; -22.1, -64.2; -17.3, -55.9; -12.5, -44.3; -7.64, -29.2; -1.21, -4.82;6.83,26.3;11.7,42;16.5,54.2;21.3,63.1;26.9,69.9;34.2,75;45.4,78.4;72,79.9;80,80], style(color = 0)), Text(extent = [70,25;90,5], string = "4"), Text(extent = [ -106,21; -86,1], string = "-4"), Text(extent = [ -29,72; -9,88], string = "1"), Text(extent = [3, -72;23, -88], string = "-1"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = tanh(u) ;
//     end tanh;
//     function exp "exponential, base e"
//       extends baseIcon2;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90, -80.3976;68, -80.3976], style(color = 8)), Polygon(points = [90, -80.3976;68, -72.3976;68, -88.3976;90, -80.3976], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -31, -77.9; -6.03, -74;10.9, -68.4;23.7, -61;34.2, -51.6;43, -40.3;50.3, -27.8;56.7, -13.5;62.3,2.23;67.1,18.6;72,38.2;76,57.6;80,80], style(color = 0)), Text(extent = [ -86,50; -14,2], string = "exp", style(color = 8))), Diagram(Line(points = [ -100, -80.3976;84, -80.3976], style(color = 8)), Polygon(points = [100, -80.3976;84, -74.3976;84, -86.3976;100, -80.3976], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -31, -77.9; -6.03, -74;10.9, -68.4;23.7, -61;34.2, -51.6;43, -40.3;50.3, -27.8;56.7, -13.5;62.3,2.23;67.1,18.6;72,38.2;76,57.6;80,80], style(color = 0)), Text(extent = [ -31,72; -11,88], string = "20"), Text(extent = [ -92, -83; -72, -103], string = "-3"), Text(extent = [70, -83;90, -103], string = "3"), Text(extent = [ -18, -53;2, -73], string = "1"), Text(extent = [96, -82;116, -102], string = "u", style(color = 9))));
// 
//       external "C" y = exp(u) ;
//     end exp;
//     function log "natural (base e) logarithm (u shall be > 0)"
//       extends baseIcon1;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [ -6, -24;66, -72], string = "log", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -80, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [ -105,72; -85,88], string = "3"), Text(extent = [ -109, -88; -89, -72], string = "-3"), Text(extent = [70, -3;90, -23], string = "20"), Text(extent = [ -78, -1; -58, -21], string = "1"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = log(u) ;
//     end log;
//     function log10 "base 10 logarithm (u shall be > 0)"
//       extends baseIcon1;
//       input Real u;
//       output Real y;
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.36, y = 0.07, width = 0.6, height = 0.6), Icon(Line(points = [ -90,0;68,0], style(color = 8)), Polygon(points = [90,0;68,8;68, -8;90,0], style(color = 8, fillColor = 8)), Line(points = [ -79.8, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [ -30, -22;60, -70], string = "log10", style(color = 8))), Diagram(Line(points = [ -100,0;84,0], style(color = 8)), Polygon(points = [100,0;84,6;84, -6;100,0], style(color = 8, fillColor = 8)), Line(points = [ -79.8, -80; -79.2, -50.6; -78.4, -37; -77.6, -28; -76.8, -21.3; -75.2, -11.4; -72.8, -1.31; -69.5,8.08; -64.7,17.9; -57.5,28; -47,38.1; -31.8,48.1; -10.1,58;22.1,68;68.7,78.1;80,80], style(color = 0)), Text(extent = [70, -3;90, -23], string = "20"), Text(extent = [ -78, -1; -58, -21], string = "1"), Text(extent = [ -109,72; -89,88], string = " 1.3"), Text(extent = [ -109, -88; -89, -72], string = "-1.3"), Text(extent = [92, -2;112, -22], string = "u", style(color = 9))));
// 
//       external "C" y = log10(u) ;
//     end log10;
//     function tempInterpol1 "temporary routine for linear interpolation (will be removed)"
//       input Real u "input value (first column of table)";
//       input Real table[:,:] "table to be interpolated";
//       input Integer icol "column of table to be interpolated";
//       output Real y "interpolated input value (icol column of table)";
//     protected 
//       Integer i;
//       Integer n "number of rows of table";
//       Real u1;
//       Real u2;
//       Real y1;
//       Real y2;
//     algorithm 
//       n:=size(table, 1);
//       if n <= 1 then 
//             y:=table[1,icol];
// 
//       else       if u <= table[1,1] then 
//             i:=1;
// 
//       else       i:=2;
//       while (i < n and u >= table[i,1]) loop
//               i:=i + 1;
// 
//       end while;
//       i:=i - 1;
// 
//       end if;
//       u1:=table[i,1];
//       u2:=table[i + 1,1];
//       y1:=table[i,icol];
//       y2:=table[i + 1,icol];
//       assert(u2 > u1, "Table index must be increasing");
//       y:=y1 + ((y2 - y1) * (u - u1)) / (u2 - u1);
// 
//       end if;
//     end tempInterpol1;
//     function tempInterpol2 "temporary routine for vectorized linear interpolation (will be removed)"
//       input Real u "input value (first column of table)";
//       input Real table[:,:] "table to be interpolated";
//       input Integer icol[:] "column(s) of table to be interpolated";
//       output Real y[1,size(icol, 1)] "interpolated input value(s) (column(s) icol of table)";
//     protected 
//       Integer i;
//       Integer n "number of rows of table";
//       Real u1;
//       Real u2;
//       Real y1[1,size(icol, 1)];
//       Real y2[1,size(icol, 1)];
//     algorithm 
//       n:=size(table, 1);
//       if n <= 1 then 
//             y:=transpose([table[1,icol]]);
// 
//       else       if u <= table[1,1] then 
//             i:=1;
// 
//       else       i:=2;
//       while (i < n and u >= table[i,1]) loop
//               i:=i + 1;
// 
//       end while;
//       i:=i - 1;
// 
//       end if;
//       u1:=table[i,1];
//       u2:=table[i + 1,1];
//       y1:=transpose([table[i,icol]]);
//       y2:=transpose([table[i + 1,icol]]);
//       assert(u2 > u1, "Table index must be increasing");
//       y:=y1 + ((y2 - y1) * (u - u1)) / (u2 - u1);
// 
//       end if;
//     end tempInterpol2;
//   end Math;
//   package Mechanics "Library for mechanical systems"
//     extends Modelica.Icons.Library2;
//     annotation(Window(x = 0.03, y = 0.05, width = 0.36, height = 0.26, library = 1, autolayout = 1), Icon(Rectangle(extent = [ -5, -40;45, -70], style(gradient = 2, fillColor = 8, fillPattern = 1)), Ellipse(extent = [ -90, -50; -80, -60], style(color = 0)), Line(points = [ -85, -55; -60, -21], style(color = 0, thickness = 2)), Ellipse(extent = [ -65, -16; -55, -26], style(color = 0)), Line(points = [ -60, -21;9, -55], style(color = 0, thickness = 2)), Ellipse(extent = [4, -50;14, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [ -10, -34;72, -34;72, -76; -10, -76], style(color = 0))), Documentation(info = "<HTML>
// <p>
// This package contains components to model <b>mechanical systems</b>.
// Currently, the following subpackages are available:</p>
// 
// <pre>
//    <b>Rotational</b>     1-dimensional rotational mechanical components.
//    <b>Translational</b>  1-dimensional translational mechanical components.
// </pre>
// 
// <p>
// It is planned to add a subpackage for multibody systems to
// model 3-dimensional mechanical systems.
// </p>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Oct. 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Bearing torque computation added to package <b>Rotational</b>.</li>
// <li><i>Oct. 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New components and examples in package <b>Rotational</b>.</li>
// <li><i>Oct. 24, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Changes according to the Twente meeting introduced. Especially,
//        package Rotational1D renamed to Rotational and package
//        Translational1D renamed to Translational. For the particular
//        changes in these packages, see the corresponding package
//        release notes.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version for 1-dimensional rotational mechanical
//        systems based on an existing Dymola library of Martin Otter and
//        Hilding Elmqvist.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2003, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//     package Rotational "1-dimensional rotational mechanical components"
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(Window(x = 0.05, y = 0.09, width = 0.43, height = 0.63, library = 1, autolayout = 1), Documentation(info = "<html>
// 
// <h4>Content</h4>
// 
// <ol>
//   <li>Overview of library Modelica.Mechanics.Rotational</li>
//   <li>Components of the library</li>
//   <li>Flange connectors</li>
//   <li>Sign conventions</li>
//   <li>User-defined components</li>
//   <li>Requirements for simulation tools</li>
//   <li>Support torque</li>
// </ol>
// 
// <h4>1. Overview of library Modelica.Mechanics.Rotational</h4>
// 
// <p>
// This package contains components to model <b>1-dimensional rotational
// mechanical</b> systems, including different types of gearboxes,
// shafts with inertia, external torques, spring/damper elements,
// frictional elements, backlash, elements to measure angle, angular velocity,
// angular acceleration and the cut-torque of a flange. In sublibrary
// <b>Examples</b> several examples are present to demonstrate the usage of
// the elements. Just open the corresponding example model and simulate
// the model according to the provided description.
// </p>
// 
// <p>
// A unique feature of this library is the <b>component-oriented</b>
// modeling of <b>Coulomb friction</b> elements, such as friction in bearings,
// clutches, brakes, and gear efficiency. Even (dynamically) coupled
// friction elements, e.g., as in automatic gearboxes, can be handeled
// <b>without</b> introducing stiffness which leads to fast simulations.
// The underlying theory is new and is based on the solution of mixed
// continuous/discrete systems of equations, i.e., equations where the
// <b>unknowns</b> are of type <b>Real</b>, <b>Integer</b> or <b>Boolean</b>.
// Provided appropriate numerical algorithms for the solution of such types of
// systems are available in the simulation tool, the simulation of
// (dynamically) coupled friction elements of this library is
// <b>efficient</b> and <b>reliable</b>.
// </p>
// 
// <p><IMG SRC=\"../Images/drive1.png\" ALT=\"drive1\"></p>
// 
// <p>
// A simple example of the usage of this library is given in the
// figure above. This drive consists of a shaft with inertia J1=0.2 which
// is connected via an ideal gearbox with gear ratio=5 to a second shaft
// with inertia J2=5. The left shaft is driven via an external,
// sinusoidal torque.
// The <b>filled</b> and <b>non-filled grey squares</b> at the left and
// right side of a component represent <b>mechanical flanges</b>.
// Drawing a line between such squares means that the corresponding
// flanges are <b>rigidly attached</b> to each other.
// By convention in this library, the connector characterized as a
// <b>filled</b> grey square is called <b>flange_a</b> and placed at the
// left side of the component in the \"design view\" and the connector
// characterized as a <b>non-filled</b> grey square is called <b>flange_b</b>
// and placed at the right side of the component in the \"design view\".
// The two connectors are completely <b>identical</b>, with the only
// exception that the graphical layout is a little bit different in order
// to distinguish them for easier access of the connector variables.
// For example, <tt>J1.flange_a.tau</tt> is the cut-torque in the connector
// <tt>flange_a</tt> of component <tt>J1</tt>.
// </p>
// 
// <p>
// The components of this
// library can be <b>connected</b> together in an <b>arbitrary</b> way. E.g., it is
// possible to connect two springs or two shafts with inertia directly
// together, see figure below.
// </p>
// 
// <p><IMG SRC=\"../Images/driveConnections.png\" ALT=\"driveConnections\"></p>
// 
// <h4>2. Components of the library</h4>
// 
// <p>
// This package contains the following model components:
// </p>
// 
// <table BORDER=1 CELLSPACING=0 CELLPADDING=2>
// <tr><th>Name</th><th>Description</th></tr>
// <tr><td><tt><b>Examples</b></tt></td><td>Sublibrary containing example models.</td></tr>
// <tr><td><tt><b>Interfaces</b></tt></td><td>Sublibrary containing interface definitions.</td></tr>
// <tr><td><tt><b>Inertia</b></tt></td><td>Rotational component with inertia.</td></tr>
// <tr><td><tt><b>IdealGear</b></tt></td><td>Ideal gear transforming rotational in rotational motion.</td></tr>
// <tr><td><tt><b>IdealPlanetary</b></tt></td><td>Ideal standard planetary gear.</td></tr>
// <tr><td><tt><b>IdealGearR2T</b></tt></td><td>Ideal gear transforming rotational in translational motion.</td></tr>
// <tr><td><tt><b>Spring</b></tt></td><td>Linear spring.</td></tr>
// <tr><td><tt><b>Damper</b></tt></td><td>Linear damper.</td></tr>
// <tr><td><tt><b>SpringDamper</b></tt></td><td>Linear spring and linear damper in parallel connection.</td></tr>
// <tr><td><tt><b>ElastoBacklash</b></tt></td><td>Linear spring, linear damper and backlash in series connection (backlash is modeled with elasticity).</td></tr>
// <tr><td><tt><b>BearingFriction</b></tt></td><td>Coulomb friction in the bearings.</td></tr>
// <tr><td><tt><b>Clutch</b></tt></td><td>Frictional clutch where the clutch pressure force is an input signal (= Coulomb friction between two flanges).</td></tr>
// <tr><td><tt><b>OneWayClutch</b></tt></td><td>Parallel connection of free wheel and clutch</td></tr>
// <tr><td><tt><b>Brake</b></tt></td><td>Frictional brake where the brake pressure force is an input signal (= Coulomb friction between flange and housing).</td></tr>
// <tr><td><tt><b>LossyGear</b></tt></td><td>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</td></tr>
// <tr><td><tt><b>GearEfficiency</b></tt></td><td>Efficiency of a gearbox.</td></tr>
// <tr><td><tt><b>Gear</b></tt></td><td>Realistic model of a gearbox (taking into account efficiency, bearing friction, elasticity, damping, backlash)</td></tr>
// <tr><td><tt><b>GearNew</b></tt></td><td>Realistic model of a gearbox (taking into account efficiency, bearing friction, elasticity, damping, backlash), based on new component LossyGear</td></tr>
// <tr><td><tt><b>Position</b></tt></td><td>Forced movement of a flange with a reference angle given as input signal (positive angle for positive input signal).</td></tr>
// <tr><td><tt><b>Accelerate</b></tt></td><td>Forced movement of a flange with an angular acceleration given as input signal (positive acceleration for positive input signal).</td></tr>
// <tr><td><tt><b>Move</b></tt></td><td>Forced movement of a flange according to an angle, speed and angular acceleration given as input signals.</td></tr>
// <tr><td><tt><b>Fixed</b></tt></td><td>Fixing flange in housing at a predefined angle.</td></tr>
// <tr><td><tt><b>Torque</b></tt></td><td>External torque defined as input signal which accelerates the connected flange for positive input signal.</td></tr>
// <tr><td><tt><b>RelativeStates</b></tt></td><td>Definition of relative state variables</td></tr>
// <tr><td><tt><b>Sensors</b></tt></td><td>Sublibrary containing ideal sensors to measure flange variables.</td></tr>
// </table>
// 
// <h4>3. Flange connectors</h4>
// 
// <p>
// A flange is described by the connector class
// Interfaces.<b>Flange_a</b>
// or Interfaces.<b>Flange_b</b>. As already noted, the two connector
// classes are completely identical. There is only a difference in the icons,
// in order to easier identify a flange variable in a diagram.
// Both connector classes contain the following variables:
// </p>
// 
// <pre>
//    SIunits.Angle       phi  \"absolute rotation angle of flange\";
//    <b>flow</b> SIunits.Torque tau  \"cut-torque in the flange\";
// </pre>
// 
// <p>
// If needed, the angular velocity <tt>w</tt> and the
// angular acceleration <tt>a</tt> of a flange connector can be
// determined by differentiation of the flange angle <tt>phi</tt>:
// </p>
// 
// <pre>
//      w = <b>der</b>(phi);    a = <b>der</b>(w);
// 
// </pre>
// 
// <h4>4. Sign conventions</h4>
// 
// <p>
// The variables of a component of this library can be accessed in the
// usual way. However, since most of these variables are basically elements
// of <b>vectors</b>, i.e., have a direction, the question arises how the
// signs of variables shall be interpreted. The basic idea is explained
// at hand of the following figure:
// </p>
// 
// <p><IMG SRC=\"../Images/drive2.png\" ALT=\"drive2\"></p>
// 
// <p>
// In the figure, three identical drive trains are shown. The only
// difference is that the gear of the middle drive train and the
// gear as well as the right inertia of the lower drive train
// are horizontally flipped with regards to the upper drive train.
// The signs of variables are now interpreted in the following way:
// Due to the 1-dimensional nature of the model, all components are
// basically connected together along one line (more complicated
// cases are discussed below). First, one has to define
// a <b>positive</b> direction of this line, called <b>axis of rotation</b>.
// In the top part of the figure this is characterized by an arrow
// defined as <tt>axis of rotation</tt>. The simple rule is now:
// If a variable of a component is positive and can be interpreted as
// the element of a vector (e.g. torque or angular velocity vector), the
// corresponding vector is directed into the positive direction
// of the axis of rotation. In the following figure, the right-most
// inertias of the figure above are displayed with the positive
// vector direction displayed according to this rule:
// </p>
// 
// <p><IMG SRC=\"../Images/drive3.png\" ALT=\"drive3\"></p>
// 
// <p>
// The cut-torques <tt>J2.flange_a.tau, J4.flange_a.tau, J6.flange_b.tau</tt>
// of the right inertias are all identical and are directed into the
// direction of rotation if the values are positive. Similiarily,
// the angular velocities <tt>J2.w, J4.w, J6.w</tt> of the right inertias
// are all identical and are also directed into the
// direction of rotation if the values are positive. Some special
// cases are shown in the next figure:
// </p>
// 
// <p><IMG SRC=\"../Images/drive4.png\" ALT=\"drive4\"></p>
// 
// <p>
// In the upper part of the figure, two variants of the connection of an
// external torque and an inertia are shown. In both cases, a positive
// signal input into the torque component accelerates the inertias
// <tt>inertia1, inertia2</tt> into the positive axis of rotation,
// i.e., the angular accelerations <tt>inertia1.a, inertia2.a</tt>
// are positive and are directed along the \"axis of rotation\" arrow.
// In the lower part of the figure the connection of inertias with
// a planetary gear is shown. Note, that the three flanges of the
// planetary gearbox are located along the axis of rotation and that
// the axis direction determines the positive rotation along these
// flanges. As a result, the positive rotation for <tt>inertia4, inertia6</tt>
// is as indicated with the additional grey arrows.
// </p>
// 
// <h4>5. User-defined components</h4>
// 
// <p>
// In this section some hints are given to define your own
// 1-dimensional rotational components which are compatible with the
// elements of this package.
// It is convenient to define a new
// component by inheritance from one of the following base classes,
// which are defined in sublibrary Interfaces:
// </p>
// 
// <table BORDER=1 CELLSPACING=0 CELLPADDING=2>
// <tr><th>Name</th><th>Description</th></tr>
// <tr><td><tt><b>Rigid</b></tt></td><td>Rigid connection of two rotational 1D flanges (used for elements with inertia).</td></tr>
// <tr><td><tt><b>Compliant</b></tt></td><td>Compliant connection of two rotational 1D flanges (used for force laws such as a spring or a damper).</td></tr>
// <tr><td><tt><b>TwoFlanges</b></tt></td><td>General connection of two rotational 1D flanges (used for gearboxes).</td></tr>
// <tr><td><tt><b>AbsoluteSensor</b></tt></td><td>Measure absolute flange variables.</td></tr>
// <tr><td><tt><b>RelativeSensor</b></tt></td><td>Measure relative flange variables.</td></tr>
// </table>
// 
// <p>
// The difference between these base classes are the auxiliary
// variables defined in the model and the relations between
// the flange variables already defined in the base class.
// For example, in model <b>Rigid</b> the flanges flange_a and
// flange_b are rigidly connected, i.e., flange_a.phi = flange_b.phi,
// whereas in model <b>Compliant</b> the cut-torques are the
// same, i.e., flange_a.tau + flange_b.tau = 0.
// </p>
// 
// <p>
// The equations of a mechanical component are vector equations, i.e.,
// they need to be expressed in a common coordinate system.
// Therefore, for a component a <b>local axis of rotation</b> has to be
// defined. All vector quantities, such as cut-torques or angular
// velocities have to be expressed according to this definition.
// Examples for such a definition are given in the following figure
// for an inertia component and a planetary gearbox:
// </p>
// 
// <p><IMG SRC=\"../Images/driveAxis.png\" ALT=\"driveAxis\"></p>
// 
// <p>
// As can be seen, all vectors are directed into the direction
// of the rotation axis. The angles in the flanges are defined
// correspondingly. For example, the angle <tt>sun.phi</tt> in the
// flange of the sun wheel of the planetary gearbox is positive,
// if rotated in mathematical positive direction (= counter clock
// wise) along the axis of rotation.
// </p>
// 
// <p>
// On first view, one may assume that the selected local
// coordinate system has an influence on the usage of the
// component. But this is not the case, as shown in the next figure:
// </p>
// 
// <p><IMG SRC=\"../Images/inertias.png\" ALT=\"inertias\"></p>
// 
// <p>
// In the figure the <b>local</b> axes of rotation of the components
// are shown. The connection of two inertias in the left and in the
// right part of the figure are completely equivalent, i.e., the right
// part is just a different drawing of the left part. This is due to the
// fact, that by a connection, the two local coordinate systems are
// made identical and the (automatically) generated connection equations
// (= angles are identical, cut-torques sum-up to zero) are also
// expressed in this common coordinate system. Therefore, even if in
// the left figure it seems to be that the angular velocity vector of
// <tt>J2</tt> goes from right to left, in reality it goes from
// left to right as shown in the right part of the figure, where the
// local coordinate systems are drawn such that they are aligned.
// Note, that the simple rule stated in section 4 (Sign conventions)
// also determines that
// the angular velocity of <tt>J2</tt> in the left part of the
// figure is directed from left to right.
// </p>
// 
// <p>
// To summarize, the local coordinate system selected for a component
// is just necessary, in order that the equations of this component
// are expressed correctly. The selection of the coordinate system
// is arbitrary and has no influence on the usage of the component.
// Especially, the actual direction of, e.g., a cut-torque is most
// easily determined by the rule of section 4. A more strict determination
// by aligning coordinate systems and then using the vector direction
// of the local coordinate systems, often requires a re-drawing of the
// diagram and is therefore less convenient to use.
// </p>
// 
// <h4>6. Requirements for simulation tools</h4>
// 
// <p>
// This library is designed in a fully object oriented way in order that
// components can be connected together in every meaningful combination
// (e.g. direct connection of two springs or two inertias).
// As a consequence, most models lead to a system of
// differential-algebraic equations of <b>index 3</b> (= constraint
// equations have to be differentiated twice in order to arrive at
// a state space representation) and the Modelica translator or
// the simulator has to cope with this system representation.
// According to our present knowledge, this requires that the
// Modelica translator is able to symbolically differentiate equations
// (otherwise it is e.g. not possible to provide consistent initial
// conditions; even if consistent initial conditions are present, most
// numerical DAE integrators can cope at most with index 2 DAEs).
// </p>
// 
// 
// </p>
// The elements of this library can be connected together in an
// arbitrary way. However, difficulties may occur, if the elements which can <b>lock</b> the
// <b>relative motion</b> between two flanges are connected <b>rigidly</b>
// together such that essentially the <b>same relative motion</b> can be locked.
// The reason is
// that the cut-torque in the locked phase is not uniquely defined if the
// elements are locked at the same time instant (i.e., there does not exist a
// unique solution) and some simulation systems may not be
// able to handle this situation, since this leads to a singularity during
// simulation. Currently, this type of problem can occur with the
// Coulomb friction elements <b>BearingFriction, Clutch, Brake, LossyGear</b> when
// the elements become stuck:
// </p>
// 
// <p><IMG SRC=\"../Images/driveConnections2.png\" ALT=\"driveConnections2\"></p>
// 
// <p>
// In the figure above two typical situations are shown: In the upper part of
// the figure, the series connection of rigidly attached BearingFriction and
// Clutch components are shown. This does not hurt, because the BearingFriction
// element can lock the relative motion between the element and the housing,
// whereas the clutch element can lock the relative motion between the two
// connected flanges. Contrary, the drive train in the lower part of the figure
// may rise to simulation problems, because the BearingFriction element
// and the Brake element can lock the relative motion between a flange and
// the housing and these flanges are rigidly connected together, i.e.,
// essentially the same relative motion can be locked. These difficulties
// may be solved by either introducing a compliance between these flanges
// or by combining the BearingFriction and Brake element into
// one component and resolving the ambiguity of the frictional torque in the
// stuck mode. A tool may handle this situation also <b>automatically</b>,
// by picking one solution of the infinitely many, e.g., the one where
// the difference to the value of the previous time instant is as small
// as possible.
// </p>
// 
// <h4>7. Support torques</h4>
// 
// <p>The following figure shows examples of components equipped with
// a bearing flange (framed flange in the lower center), which can be used
// to fix components on the ground or on other rotating elements or to combine
// them with force elements. If the bearing flange is not connected, the
// components are assumed to be mounted on the ground. Otherwise, the bearing
// connector offers the possibility to consider, e.g., gearboxes mounted on
// the ground via spring-damper-systems (cf. example <tt>ElasticBearing</tt>). Independently, these components
// provide a variable <tt>tau_support</tt> stating the support torque exerted
// on the bearing.</p>
// 
// <p><IMG SRC=\"../Images/bearing.png\" ALT=\"bearing\"></p>
// 
// <p>In general, it is not necessary to connect the bearing flange
// with a fixation, i.e., the two implementations in the following figure give
// identical results.</p>
// 
// <p><IMG SRC=\"../Images/bearing2.png\" ALT=\"bearing2\"></p>
// 
// <dl>
// <dt><b>Main Author:</b></dt>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 11 16<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br></dd>
// </dl>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Bearing flanges added for mounted components and support torque computation implemented.<br>
//        New component <tt>Torque2</tt> and new example <tt>ElasticBearing</tt>.
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New components <b>LossyGear</b> (with corresponding examples) and <b>Gear2</b>.<br>
//        Interface <b>FrictionBase</b> adapted to new initialization.</li>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New elements:<br><!-- silly construction follows as Dymola not able to handle nested lists -->
//        <tt>IdealGearR2T&nbsp;&nbsp;&nbsp;</tt> Ideal gear transforming rotational in translational motion<br>
//        <tt>Position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> Forced movement of a flange with a reference angle given as input signal<br>
//        <tt>RelativeStates&nbsp;</tt> Definition of relative state variables<br>
//        Icon of Rotational.Torque changed.
//        Elements Acceleration, Torque, Fixed, Sensors ordered according
//        to the Translational library.</li>
// <li><i>Nov. 4, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Improved documentation and improved graphical layout of the diagram level.
//        Changes according to the Twente meeting introduced. Especially:
//        Alias names, instead of extends. Model Shaft renamed to Inertia.
//        Torque1D renamed to Torque.
//        AccMotion renamed to Accelerate. LockedL, LockedR replaced by Fixed.
//        SpeedSensor splitted into AngleSensor and
//        SpeedSensor. RelSpeedSensor splitted into RelAngleSensor and
//        RelSpeedSensor. Initialization of friction elements improved.
//        Flanges renamed to flange_a, flange_b. MoveAngle renamed to
//        KinematicPTP, vectorized and moved to Blocks.Sources.<br>
//        Advice given from P. Beater, H. Elmqvist, S.E. Mattsson, H. Olsson
//        is appreciated.</li>
// 
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Documentation and icons improved. Appropriate initial conditions
//        introduced as start values in the demo models. Bearing model
//        replaced by FixedRight and FixedLeft models; sensor elements replaced by
//        TorqueSensor, SpeedSensor, AccSensor; new sensor elements
//        RelSpeedSensor, RelAccSensor to measure relative kinematic quantitites.
//        New elements GearEfficiency and Gear.</li>
// 
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version based on an existing Dymola library
//        of Martin Otter and Hilding Elmqvist.</li>
// </ul>
// 
// <p><b>Copyright &copy; 1999-2003, 2000-2003, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// 
// </HTML>
// "), Icon(Line(points = [ -83, -66; -63, -66], style(color = 0)), Line(points = [36, -68;56, -68], style(color = 0)), Line(points = [ -73, -66; -73, -91], style(color = 0)), Line(points = [46, -68;46, -91], style(color = 0)), Line(points = [ -83, -29; -63, -29], style(color = 0)), Line(points = [36, -32;56, -32], style(color = 0)), Line(points = [ -73, -9; -73, -29], style(color = 0)), Line(points = [46, -12;46, -32], style(color = 0)), Line(points = [ -73, -91;46, -91], style(color = 0)), Rectangle(extent = [ -47, -17;27, -80], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [ -87, -41; -47, -54], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [27, -42;66, -56], style(color = 0, gradient = 2, fillColor = 8))));
//       package Examples "Demonstration examples of the components of this package"
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.07, y = 0.13, width = 0.59, height = 0.36, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains example models to demonstrate the usage of the
// Modelica.Mechanics.Rotational package. Open the models and
// simulate them according to the provided description in the models.
// The following demo models are present:
// </p>
// 
// <pre>
//    <b>First</b>            First example using simple, basic elements
//    <b>Friction</b>         Example to demonstrate usage of a clutch and a brake
//    <b>CoupledClutches</b>  Example to demonstrate usage of 3 dynamically
//                     coupled clutches.
//    <b>LossyGearDemo1</b>   Example to demonstrate that gear efficiency may lead to stuck motion
//    <b>LossyGearDemo2</b>   Example to show combination of LossyGear and BearingFriction
//    <b>ElasticBearing</b>   Demonstration of bearing flange usage
// </pre>
// 
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New example <tt>ElasticBearing</tt>.</li>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New examples concerning LossyGear added.</li>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Appropriate initial conditions provided as start values in the models.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version based on an existing Dymola library
//        of Martin Otter and Hilding Elmqvist.</li>
// </ul>
// 
// <br>
// 
// <p><b>Copyright &copy; 1999-2003, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//         encapsulated model First "First example: simple drive train"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter Real amplitude = 10;
//           parameter SI.Frequency freqHz = 5;
//           parameter SI.Inertia Jmotor = 0.1;
//           parameter SI.Inertia Jload = 2;
//           parameter Real ratio = 10;
//           parameter Real damping = 10;
//           annotation(Documentation(info = "<html>
// <p>The drive train consists of a motor inertia which is driven by
// a sine-wave motor torque. Via a gearbox the rotational energy is
// transmitted to a load inertia. Elasticity in the gearbox is modeled
// by a spring element. A linear damper is used to model the
// damping in the gearbox bearing.</p>
// 
// <p>Note, that a force component (like the damper of this example)
// which is acting between a shaft and the housing has to be fixed
// in the housing on one side via component Fixed.</p>
// 
// <p>Simulate for 1 second and plot the following variables:<br>
//    angular velocities of inertias inertia2 and 3: inertia2.w, inertia3.w</p>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul><li><i>June 30, 1999</i>
//     by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//     Realized.</li>
// </ul>
// </HTML>"));
//           Rotational.Fixed fixed annotation(extent = [38, -60;54, -44]);
//           Rotational.Torque torque annotation(extent = [ -70, -8; -54,8]);
//           Rotational.Inertia inertia1(J = Jmotor) annotation(extent = [ -40, -8; -24,8]);
//           Rotational.IdealGear idealGear(ratio = ratio) annotation(extent = [ -10, -8;6,8]);
//           Rotational.Inertia inertia2(J = 2, phi(start = 0), w(start = 0)) annotation(extent = [20, -8;36,8]);
//           Rotational.Spring spring(c = 10000.0) annotation(extent = [54, -8;70,8]);
//           Rotational.Inertia inertia3(J = Jload, phi(start = 0), w(start = 0)) annotation(extent = [84, -8;100,8]);
//           Rotational.Damper damper(d = damping) annotation(extent = [38, -36;54, -20], rotation =  -90);
//           Sources.Sine sine(amplitude = {amplitude}, freqHz = {freqHz}) annotation(extent = [ -100, -8; -84,8]);
// 
//         equation 
//           connect(sine.outPort,torque.inPort) annotation(points = [ -83.2,0; -71.6,0], style(color = 3));
//           connect(torque.flange_b,inertia1.flange_a) annotation(points = [ -54,0; -40,0], style(color = 0));
//           connect(inertia1.flange_b,idealGear.flange_a) annotation(points = [ -24,0; -10,0], style(color = 0));
//           connect(idealGear.flange_b,inertia2.flange_a) annotation(points = [6,0;20,0], style(color = 0));
//           connect(inertia2.flange_b,spring.flange_a) annotation(points = [36,0;54,0], style(color = 0));
//           connect(spring.flange_b,inertia3.flange_a) annotation(points = [70,0;84,0], style(color = 0));
//           connect(damper.flange_a,inertia2.flange_b) annotation(points = [46, -20;46,0;36,0], style(color = 0));
//           connect(damper.flange_b,fixed.flange_b) annotation(points = [46, -36;46, -52], style(color = 0));
//         end First;
//         encapsulated model Friction "Drive train with clutch and brake"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Blocks.Math;
//           import Modelica.Mechanics.Rotational;
//           import Modelica.Constants.pi;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter SI.Time startTime = 0.5 "Start time of step";
//           output SI.Torque tMotor "driving torque of inertia3";
//           output SI.Torque tClutch "friction torque of clutch";
//           output SI.Torque tBrake "friction torque of brake";
//           output SI.Torque tSpring "spring torque";
//           annotation(Documentation(info = "<html>
// <p>This drive train contains a frictional <b>clutch</b> and a <b>brake</b>.
// Simulate the system for 1 second using the following initial
// values (defined already in the model):</p>
// 
// <pre>   inertia1.w =  90 (or brake.w)
//    inertia2.w =  90
//    inertia3.w = 100
// </pre>
// 
// <p>Plot the output signals</p>
// 
// <pre>   tMotor      Torque of motor
//    tClutch     Torque in clutch
//    tBrake      Torque in brake
//    tSpring     Torque in spring
// </pre>
// 
// <p>as well as the absolute angular velocities of the three inertia components
// (inertia1.w, inertia2.w, inertia3.w).</p>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul><li><i>June 30, 1999</i>
//     by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//     Realized.</li>
// </ul>
// </HTML>"));
//           Rotational.Torque torque annotation(extent = [ -45, -5; -35,5]);
//           Rotational.Inertia inertia3(J = 1, phi(start = 0), w(start = 100)) annotation(extent = [ -25, -5; -15,5]);
//           Rotational.Clutch clutch(fn_max = 160) annotation(extent = [ -5, -5;5,5]);
//           Rotational.Inertia inertia2(J = 0.05, phi(start = 0), w(start = 90)) annotation(extent = [15, -5;25,5]);
//           Rotational.SpringDamper spring(c = 160, d = 1) annotation(extent = [35, -5;45,5]);
//           Rotational.Inertia inertia1(J = 1, phi(start = 0), w(start = 90)) annotation(extent = [75, -5;85,5]);
//           Rotational.Brake brake(fn_max = 1600) annotation(extent = [55, -5;65,5]);
//           Sources.Constant const(k = {1}) annotation(extent = [ -5,20;5,30], rotation =  -90);
//           Sources.Step step(startTime = {startTime}) annotation(extent = [55,20;65,30], rotation =  -90);
//           Sources.Step step2(height = { -1}, offset = {1}, startTime = {startTime}) annotation(extent = [ -85, -15; -75, -5]);
//           Sources.Sine sine(amplitude = {200}, freqHz = {50 / pi}) annotation(extent = [ -85,5; -75,15]);
//           Math.Product product annotation(extent = [ -65, -5; -55,5]);
// 
//         equation 
//           tMotor = torque.tau;
//           tClutch = clutch.tau;
//           tBrake = brake.tau;
//           tSpring = spring.tau;
//           connect(sine.outPort,product.inPort1) annotation(points = [ -74.5,10; -70,10; -70,3; -66,3], style(color = 3));
//           connect(step2.outPort,product.inPort2) annotation(points = [ -74.5, -10; -70, -10; -70, -3; -66, -3], style(color = 3));
//           connect(product.outPort,torque.inPort) annotation(points = [ -54.5,0; -46,0], style(color = 3));
//           connect(torque.flange_b,inertia3.flange_a) annotation(points = [ -35,0; -25,0], style(color = 0));
//           connect(inertia3.flange_b,clutch.flange_a) annotation(points = [ -15,0; -5,0], style(color = 0));
//           connect(clutch.flange_b,inertia2.flange_a) annotation(points = [5,0;15,0], style(color = 0));
//           connect(const.outPort,clutch.inPort) annotation(points = [3.36767e-16,19.5;3.36767e-16,12.25;0,12.25;0,5.5], style(color = 3));
//           connect(inertia2.flange_b,spring.flange_a) annotation(points = [25,0;35,0], style(color = 0));
//           connect(spring.flange_b,brake.flange_a) annotation(points = [45,0;55,0], style(color = 0));
//           connect(brake.flange_b,inertia1.flange_a) annotation(points = [65,0;75,0], style(color = 0));
//           connect(step.outPort,brake.inPort) annotation(points = [60,19.5;60,5.5], style(color = 3));
//         end Friction;
//         encapsulated model CoupledClutches "Drive train with 3 dynamically coupled clutches"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           parameter SI.Frequency freqHz = 0.2 "frequency of sine function to invoke clutch1";
//           parameter SI.Time T2 = 0.4 "time when clutch2 is invoked";
//           parameter SI.Time T3 = 0.9 "time when clutch3 is invoked";
//           annotation(Documentation(info = "<html>
// <p>This example demonstrates how variable structure
// drive trains are handeled. The drive train consists
// of 4 inertias and 3 clutches, where the clutches
// are controlled by input signals. The system has
// 2^3=8 different configurations and 3^3 = 27
// different states (every clutch may be in forward
// sliding, backward sliding or locked mode when the
// relative angular velocity is zero). By invoking the
// clutches at different time instances, the switching
// of the configurations can be studied.</p>
// 
// <p>Simulate the system for 1.2 seconds with the
// following initial values:<br>
// J1.w = 10.</p>
// 
// <p>Plot the following variables:<br>
// angular velocities of inertias (J1.w, J2.w, J3.w,
// J4.w), frictional torques of clutches (clutchX.tau),
// frictional mode of clutches (clutchX.mode) where
// mode = -1/0/+1 means backward sliding,
// locked, forward sliding.</p>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul><li><i>June 30, 1999</i>
//         by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//         Realized.</li>
// </ul></HTML>"), Commands(file = "CoupledClutches.mos" "Plot inertias"));
//           Rotational.Inertia J1(J = 1, phi(start = 0), w(start = 10)) annotation(extent = [ -45, -5; -35,5]);
//           Rotational.Torque torque annotation(extent = [ -65, -5; -55,5]);
//           Rotational.Clutch clutch1(peak = 1.1, fn_max = 20) annotation(extent = [ -25, -5; -15,5]);
//           Sources.Sine sin1(amplitude = {10}, freqHz = {5}) annotation(extent = [ -85, -5; -75,5]);
//           Sources.Step step1(startTime = {T2}) annotation(extent = [15,15;25,25], rotation =  -90);
//           Rotational.Inertia J2(J = 1) annotation(extent = [ -5, -5;5,5]);
//           Rotational.Clutch clutch2(peak = 1.1, fn_max = 20) annotation(extent = [15, -5;25,5]);
//           Rotational.Inertia J3(J = 1) annotation(extent = [35, -5;45,5]);
//           Rotational.Clutch clutch3(peak = 1.1, fn_max = 20) annotation(extent = [55, -5;65,5]);
//           Rotational.Inertia J4(J = 1) annotation(extent = [75, -5;85,5]);
//           Sources.Sine sin2(amplitude = {1}, freqHz = {freqHz}, phase = {1.57}) annotation(extent = [ -25,15; -15,25], rotation =  -90);
//           Sources.Step step2(startTime = {T3}) annotation(extent = [55,15;65,25], rotation =  -90);
// 
//         equation 
//           connect(sin1.outPort,torque.inPort) annotation(points = [ -74.5,0; -66,0], style(color = 3));
//           connect(torque.flange_b,J1.flange_a) annotation(points = [ -55,0; -45,0], style(color = 0));
//           connect(J1.flange_b,clutch1.flange_a) annotation(points = [ -35,0; -25,0], style(color = 0));
//           connect(clutch1.flange_b,J2.flange_a) annotation(points = [ -15,0; -5,0], style(color = 0));
//           connect(J2.flange_b,clutch2.flange_a) annotation(points = [5,0;15,0], style(color = 0));
//           connect(clutch2.flange_b,J3.flange_a) annotation(points = [25,0;35,0], style(color = 0));
//           connect(J3.flange_b,clutch3.flange_a) annotation(points = [45,0;55,0], style(color = 0));
//           connect(clutch3.flange_b,J4.flange_a) annotation(points = [65,0;75,0], style(color = 0));
//           connect(step2.outPort,clutch3.inPort) annotation(points = [60,14.5;60,5.5], style(color = 3));
//           connect(step1.outPort,clutch2.inPort) annotation(points = [20,14.5;20,5.5], style(color = 3));
//           connect(sin2.outPort,clutch1.inPort) annotation(points = [ -20,14.5; -20,5.5], style(color = 3));
//         end CoupledClutches;
//         encapsulated model LossyGearDemo1 "Example to show that gear efficiency may lead to stuck motion"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           SI.Power PowerLoss "power lost in the gear";
//           annotation(Documentation(info = "<html>
// <p>
// This model contains two inertias which are connected by an ideal
// gear where the friction between the teeth of the gear is modeled in
// a physical meaningful way (friction may lead to stuck mode which
// locks the motion of the gear). The friction is defined by an
// efficiency factor (= 0.5) for forward and backward driving condition leading
// to a torque dependent friction loss. Simulate for about 0.5 seconds.
// The friction in the gear will take all modes
// (forward and backward rolling, as well as stuck).
// </p>
// 
// <p>
// You may plot:
// </p>
// 
// <pre>
// Inertia1.w,
// Inertia2.w : angular velocities of inertias
// powerLoss  : power lost in the gear
// gear.mode  :  1 = forward rolling
//               0 = stuck (w=0)
//              -1 = backward rolling
// </pre>
// </HTML>
// "));
//           Rotational.LossyGear gear(i = 2, lossTable = [0,0.5,0.5,0,0]) annotation(extent = [ -10,0;10,20]);
//           Rotational.Inertia Inertia1 annotation(extent = [ -40,0; -20,20]);
//           Rotational.Inertia Inertia2(J = 1.5) annotation(extent = [20,0;40,20]);
//           Rotational.Torque torque1 annotation(extent = [ -70,0; -50,20]);
//           Rotational.Torque torque2 annotation(extent = [70,0;50,20]);
//           Sources.Sine DriveSine(amplitude = {10}, freqHz = {1}) annotation(extent = [ -100,0; -80,20]);
//           Sources.Ramp load(height = {5}, duration = {2}, offset = { -10}) annotation(extent = [100,0;80,20]);
// 
//         equation 
//           connect(Inertia1.flange_b,gear.flange_a) annotation(points = [ -20,10; -10,10], style(color = 0));
//           connect(gear.flange_b,Inertia2.flange_a) annotation(points = [10,10;20,10], style(color = 0));
//           connect(torque1.flange_b,Inertia1.flange_a) annotation(points = [ -50,10; -40,10], style(color = 0));
//           connect(torque2.flange_b,Inertia2.flange_b) annotation(points = [50,10;40,10], style(color = 0));
//           connect(DriveSine.outPort,torque1.inPort) annotation(points = [ -79,10; -72,10], style(color = 3));
//           connect(load.outPort,torque2.inPort) annotation(points = [79,10;72,10], style(color = 3));
//           PowerLoss = gear.flange_a.tau * der(gear.flange_a.phi) + gear.flange_b.tau * der(gear.flange_b.phi);
//         end LossyGearDemo1;
//         encapsulated model LossyGearDemo2 "Example to show combination of LossyGear and BearingFriction"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Rotational;
//           import SI = Modelica.SIunits;
//           extends Icons.Example;
//           SI.Power PowerLoss "power lost in the gear";
//           annotation(Documentation(info = "<html>
// <p>
// This model contains bearing friction and gear friction (= efficiency).
// If both friction models are stuck, there is no unique solution.
// Still a reliable Modelica simulator, such as Dymola, should
// be able to handle this situation.
// </p>
// 
// <p>
// Simulate for about 0.5 seconds. The friction elements are
// in all modes (forward and backward rolling, as well as stuck).
// </p>
// 
// <p>
// You may plot:
// </p>
// 
// <pre>
// Inertia1.w,
// Inertia2.w          : angular velocities of inertias
// powerLoss           : power lost in the gear
// bearingFriction.mode:  1 = forward rolling
//                        0 = stuck (w=0)
//                       -1 = backward rolling
// gear.mode           :  1 = forward rolling
//                        0 = stuck (w=0)
//                       -1 = backward rolling
// </pre>
// 
// <p>Note: This combination of LossyGear and BearingFriction is not recommended to use,
// as component LossyGear includes the functionality of component BearingFriction
// (only <i>peak</i> not supported).</p>
// 
// </HTML>
// "));
//           Rotational.LossyGear gear(i = 2, lossTable = [0,0.5,0.5,0,0]) annotation(extent = [ -10,0;10,20]);
//           Rotational.Inertia Inertia1 annotation(extent = [ -40,0; -20,20]);
//           Rotational.Inertia Inertia2(J = 1.5) annotation(extent = [20,0;40,20]);
//           Rotational.Torque torque1 annotation(extent = [ -50,60; -70,80]);
//           Rotational.Torque torque2 annotation(extent = [70,0;50,20]);
//           Sources.Sine DriveSine(amplitude = {10}, freqHz = {1}) annotation(extent = [ -20,60; -40,80]);
//           Sources.Ramp load(height = {5}, duration = {2}, offset = { -10}) annotation(extent = [100,0;80,20]);
//           Rotational.BearingFriction bearingFriction(tau_pos = [0,0.5;1,1]) annotation(extent = [ -70,0; -50,20]);
// 
//         equation 
//           PowerLoss = gear.flange_a.tau * der(gear.flange_a.phi) + gear.flange_b.tau * der(gear.flange_b.phi);
//           connect(load.outPort,torque2.inPort) annotation(points = [79,10;72,10], style(color = 3));
//           connect(torque2.flange_b,Inertia2.flange_b) annotation(points = [50,10;40,10], style(color = 0));
//           connect(Inertia2.flange_a,gear.flange_b) annotation(points = [20,10;10,10], style(color = 0));
//           connect(gear.flange_a,Inertia1.flange_b) annotation(points = [ -10,10; -20,10], style(color = 0));
//           connect(Inertia1.flange_a,bearingFriction.flange_b) annotation(points = [ -40,10; -50,10], style(color = 0));
//           connect(bearingFriction.flange_a,torque1.flange_b) annotation(points = [ -70,10; -80,10; -80,70; -70,70], style(color = 0));
//           connect(DriveSine.outPort,torque1.inPort) annotation(points = [ -41,70; -48,70], style(color = 3));
//         end LossyGearDemo2;
//         model ElasticBearing "Example to show possible usage of bearing flange"
//           extends Icons.Example;
//           Modelica.Mechanics.Rotational.Inertia shaft annotation(extent = [ -20,40;0,60]);
//           Modelica.Mechanics.Rotational.Inertia load(J = 50) annotation(extent = [70,40;90,60]);
//           Modelica.Mechanics.Rotational.Spring spring(c = 1000.0) annotation(extent = [40,40;60,60]);
//           Modelica.Mechanics.Rotational.Fixed fixed annotation(extent = [10, -80;30, -60]);
//           Modelica.Mechanics.Rotational.SpringDamper springDamper(c = 100000.0, d = 5) annotation(extent = [10, -40;30, -20], rotation = 90);
//           Modelica.Mechanics.Rotational.Torque torque annotation(extent = [ -50,40; -30,60]);
//           Modelica.Blocks.Sources.Ramp ramp(height = {100}, duration = {5}) annotation(extent = [ -90,40; -70,60]);
//           annotation(Diagram, Documentation(info = "<html>
// <p>
// This model demonstrates the usage of the bearing flange.
// The gearbox is not connected rigidly to the ground, but by
// a spring-damper-system. This allows examination of the gearbox
// housing dynamics.</p>
// 
// <p>
// Simulate for about 10 seconds and plot the angular velocities of the inertias <tt>housing.w</tt>,
// <tt>shaft.w</tt> and <tt>load.w</tt>.</p>
// 
// </html>
// "));
//           Modelica.Mechanics.Rotational.IdealGear idealGear(ratio = 3) annotation(extent = [10,40;30,60]);
//           Inertia housing(J = 5) annotation(extent = [10,0;30,20], rotation = 90);
// 
//         equation 
//           connect(ramp.outPort,torque.inPort) annotation(points = [ -69,50; -52,50], style(color = 3));
//           connect(torque.flange_b,shaft.flange_a) annotation(points = [ -30,50; -20,50], style(color = 0));
//           connect(spring.flange_b,load.flange_a) annotation(points = [60,50;70,50], style(color = 0));
//           connect(springDamper.flange_a,fixed.flange_b) annotation(points = [20, -40;20, -70], style(color = 0));
//           connect(shaft.flange_b,idealGear.flange_a) annotation(points = [0,50;10,50], style(color = 0));
//           connect(idealGear.flange_b,spring.flange_a) annotation(points = [30,50;40,50], style(color = 0));
//           connect(idealGear.bearing,housing.flange_b) annotation(points = [20,40;20,20], style(color = 0));
//           connect(housing.flange_a,springDamper.flange_b) annotation(points = [20,0;20, -20], style(color = 0));
//         end ElasticBearing;
//       end Examples;
//       package Interfaces "Connectors and partial models for 1D rotational mechanical components"
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.07, y = 0.13, width = 0.43, height = 0.52, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains connectors and partial models for 1D rotational mechanical
// components. In particular
// </p>
// 
// <pre>
//   <b>Flange_a</b>                 Left flange of a component.
//   <b>Flange_b</b>                 Right flange of a component.
//   <b>Rigid</b>                    Rigid connection of two rotational 1D flanges
//                            (used for elements with inertia).
//   <b>Compliant</b>                Compliant connection of two rotational 1D flanges
//                            (used for force laws such as a spring or a damper).
//   <b>TwoFlanges</b>               Component with two rotational 1D flanges
//   <b>Bearing</b>                  Component with two rotational 1D flanges, one bearing flange
//                            and cardinality dependent equations
//   <b>TwoFlangesAndBearing</b>     Component inherited from Bearing for equation-based classes
//   <b>TwoFlangesAndBearingH</b>    Component inherited from Bearing for hierarchical components
//   <b>AbsoluteSensor</b>           Base class to measure absolute flange variables.
//   <b>RelativeSensor</b>           Base class to measure relative flange variables.
// </pre>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// 
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
//        <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        New components: Bearing, TwoFlangesAndBearing and TwoFlangesAndBearingH.</li>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Component FrictionBase adapted to new initialization.</li>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New components: TwoFlanges, AbsoluteSensor, RelativeSensor.</li>
// <li><i>June 28, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// <br>
// 
// <p><b>Copyright &copy; 1999-2003, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//         connector Flange_a "1D rotational flange (filled square icon)"
//           SI.Angle phi "Absolute rotation angle of flange";
//           flow SI.Torque tau "Cut torque in the flange";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.02, width = 0.56, height = 0.68), Documentation(info = "<HTML>
// <p>
// This is a connector for 1D rotational mechanical systems and models
// a mechanical flange. The following variables are defined in this connector:
// </p>
// 
// <pre>
//    <b>phi</b>: Absolute rotation angle of the flange in [rad].
//    <b>tau</b>: Cut-torque in the flange in [Nm].
// </pre>
// 
// <p>
// There is a second connector for flanges: Flange_b. The connectors
// Flange_a and Flange_b are completely identical. There is only a difference
// in the icons, in order to easier identify a flange variable in a diagram.
// For a discussion on the actual direction of the cut-torque tau and
// of the rotation angle, see the information text of package Rotational
// (section 4. Sign conventions).
// </p>
// 
// <p>
// If needed, the absolute angular velocity w and the
// absolute angular acceleration a of the flange can be determined by
// differentiation of the flange angle phi:
// </p>
// 
// <pre>
//      w = der(phi);    a = der(w)
// </pre>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 2, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Improved documentation.</li>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// </HTML>
// "), Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 10))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 10)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 0))), Terminal(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 10))));
//         end Flange_a;
//         connector Flange_b "1D rotational flange (non-filled square icon)"
//           SI.Angle phi "Absolute rotation angle of flange";
//           flow SI.Torque tau "Cut torque in the flange";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.21, y = 0.05, width = 0.48, height = 0.65), Documentation(info = "<HTML>
// <p>
// This is a connector for 1D rotational mechanical systems and models
// a mechanical flange. The following variables are defined in this connector:
// </p>
// 
// <pre>
//    <b>phi</b>: Absolute rotation angle of the flange in [rad].
//    <b>tau</b>: Cut-torque in the flange in [Nm].
// </pre>
// 
// <p>
// There is a second connector for flanges: Flange_a. The connectors
// Flange_a and Flange_b are completely identical. There is only a difference
// in the icons, in order to easier identify a flange variable in a diagram.
// For a discussion on the actual direction of the cut-torque tau and
// of the rotation angle, see the information text of package Rotational
// (section 4. Sign conventions).
// </p>
// 
// <p>
// If needed, the absolute angular velocity w and the
// absolute angular acceleration a of the flange can be determined by
// differentiation of the flange angle phi:
// </p>
// 
// <pre>
//      w = der(phi);    a = der(w)
// </pre>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Nov. 2, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Improved documentation.</li>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 7))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 7)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 0))), Terminal(Rectangle(extent = [ -100, -100;100,100], style(color = 0, fillColor = 7))));
//         end Flange_b;
//         partial model Rigid "Base class for the rigid connection of two rotational 1D flanges"
//           SI.Angle phi "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two rigidly connected flanges,
// i.e., flange_a.phi = flange_b.phi. It is used e.g. to built up components
// with inertia.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram, Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.18, y = 0.3, width = 0.61, height = 0.66));
// 
//         equation 
//           flange_a.phi = phi;
//           flange_b.phi = phi;
//         end Rigid;
//         partial model Compliant "Base class for the compliant connection of two rotational 1D flanges"
//           SI.Angle phi_rel(start = 0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
//           SI.Torque tau "Torque between flanges (= flange_b.tau)";
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.32, y = 0.01, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// This is a 1D rotational component with a compliant connection of two
// rotational 1D flanges where inertial effects between the two
// flanges are neglected. The basic assumption is that the cut-torques
// of the two flanges sum-up to zero, i.e., they have the same absolute value
// but opposite sign: flange_a.tau + flange_b.tau = 0. This base class
// is used to built up force elements such as springs, dampers, friction.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram);
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           flange_b.tau = tau;
//           flange_a.tau =  -tau;
//         end Compliant;
//         partial model TwoFlanges "Base class for a component with two rotational 1D flanges"
//           Flange_a flange_a annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b annotation(extent = [90, -10;110,10]);
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges.
// It is used e.g. to build up parts of a drive train consisting
// of several base components. There are specialized versions of this
// base class for rigidly connected flanges (Interfaces.Rigid) and
// for a compliant connection of flanges (Interfaces.Compliant).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram, Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.37, y = 0.05, width = 0.6, height = 0.6));
//         end TwoFlanges;
//         partial model Bearing "Base class for interface classes with bearing connector"
//           extends TwoFlanges;
//           SI.Torque tau_support;
//           Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
//           annotation(Diagram(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8))), Icon(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8))), Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is a superclass for the two components TwoFlangesAndBearing and TwoFlangesAndBearingH.</p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
//         end Bearing;
//         partial model TwoFlangesAndBearing "Base class for a equation-based component with two rotational 1D flanges and one rotational 1D bearing flange"
//           extends Bearing;
//           SI.Angle phi_a;
//           SI.Angle phi_b;
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is used e.g. to build up equation-based parts of a drive train.</p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
// 
//         equation 
//           if cardinality(bearing) == 0 then
//             bearing.phi = 0;
// 
//           else
//             bearing.tau = tau_support;
// 
//           end if;
//           0 = flange_a.tau + flange_b.tau + tau_support;
//           phi_a = flange_a.phi - bearing.phi;
//           phi_b = flange_b.phi - bearing.phi;
//         end TwoFlangesAndBearing;
//         partial model TwoFlangesAndBearingH "Base class for a hierarchically composed component with two rotational 1D flanges and one rotational bearing flange"
//           extends Bearing;
//           Adapter adapter(bearingConnected = cardinality(bearing) > 1) annotation(extent = [ -10, -70;10, -50], rotation = 90);
//         protected 
//           encapsulated model Adapter
//             import Modelica.Mechanics.Rotational.Interfaces.TwoFlanges;
//             extends TwoFlanges;
//             parameter Boolean bearingConnected;
//             annotation(Icon(Rectangle(extent = [ -90,10;90, -10], style(color = 8, fillColor = 8)), Text(extent = [0,60;0,20], string = "%name")));
// 
//           equation 
//             flange_a.phi = flange_b.phi;
//             if bearingConnected then
//               0 = flange_a.tau + flange_b.tau;
// 
//             else
//               0 = flange_a.phi;
// 
//             end if;
//           end Adapter;
// 
//         equation 
//           tau_support =  -adapter.flange_b.tau;
//           connect(adapter.flange_a,bearing) annotation(points = [ -6.12303e-16, -70;0, -70;0, -100], style(color = 0));
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D rotational component with two flanges and an additional bearing flange.
// It is used e.g. to build up parts of a drive train consisting
// of several base components.</p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "));
//         end TwoFlangesAndBearingH;
//         partial model FrictionBase "Base class of Coulomb friction elements"
//           parameter SI.AngularVelocity w_small = 1 "Relative angular velocity near to zero (see model info text)";
//           SI.AngularVelocity w_relfric "Relative angular velocity between frictional surfaces";
//           SI.AngularAcceleration a_relfric "Relative angular acceleration between frictional surfaces";
//           SI.Torque tau "Friction torque (positive, if directed in opposite direction of w_rel)";
//           SI.Torque tau0 "Friction torque for w=0 and forward sliding";
//           SI.Torque tau0_max "Maximum friction torque for w=0 and locked";
//           Boolean free "true, if frictional element is not active";
//           Real sa "Path parameter of friction characteristic tau = f(a_relfric)";
//           Boolean startForward(start = false, fixed = true) "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
//           Boolean startBackward(start = false, fixed = true) "true, if w_rel=0 and start of backward sliding or w_rel < -w_small";
//           Boolean locked "true, if w_rel=0 and not sliding";
//           constant Integer Unknown = 3 "Value of mode is not known";
//           constant Integer Free = 2 "Element is not active";
//           constant Integer Forward = 1 "w_rel > 0 (forward sliding)";
//           constant Integer Stuck = 0 "w_rel = 0 (forward sliding, locked or backward sliding)";
//           constant Integer Backward =  -1 "w_rel < 0 (backward sliding)";
//           Integer mode(final min = Backward, final max = Unknown, start = Unknown, fixed = true);
// 
//         equation 
//           startForward = pre(mode) == Stuck and (sa > tau0_max or pre(startForward) and sa > tau0) or pre(mode) == Backward and w_relfric > w_small or initial() and w_relfric > 0;
//           startBackward = pre(mode) == Stuck and (sa <  -tau0_max or pre(startBackward) and sa <  -tau0) or pre(mode) == Forward and w_relfric <  -w_small or initial() and w_relfric < 0;
//           locked = not free and not (pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//           a_relfric = if locked then 0 else if free then sa else if startForward then sa - tau0 else if startBackward then sa + tau0 else if pre(mode) == Forward then sa - tau0 else sa + tau0;
//           mode = if free then Free else if (pre(mode) == Forward or pre(mode) == Free or startForward) and w_relfric > 0 then Forward else if (pre(mode) == Backward or pre(mode) == Free or startBackward) and w_relfric < 0 then Backward else Stuck;
//         end FrictionBase;
//         partial model AbsoluteSensor "Base class to measure a single absolute flange variable"
//           extends Modelica.Icons.RotationalSensor;
//           Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane)" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.39, y = 0.05, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// This is the base class of a 1D rotational component with one flange and one
// output signal in order to measure an absolute kinematic quantity in the flange
// and to provide the measured signal as output signal for further processing
// with the blocks of package Modelica.Blocks.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0]), Text(extent = [0,70;0,110], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0])));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Base class to measure a single relative variable between two flanges"
//           extends Modelica.Icons.RotationalSensor;
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [ -10, -100;10, -120], rotation = 90);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.37, y = 0.02, width = 0.6, height = 0.65), Documentation(info = "<html>
// <p>
// This is a base class for 1D rotational components with two rigidly connected
// flanges and one output signal in order to measure relative kinematic quantities
// between the two flanges or the cut-torque in the flange and
// to provide the measured signal as output signal for further processing
// with the blocks of package Modelica.Blocks.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [0, -100;0, -70]), Text(extent = [0,70;0,110], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [0, -100;0, -70])));
//         end RelativeSensor;
//       end Interfaces;
//       model Inertia "1D-rotational component with inertia"
//         extends Interfaces.Rigid;
//         parameter SI.Inertia J = 1 "Moment of inertia";
//         SI.AngularVelocity w "Absolute angular velocity of component";
//         SI.AngularAcceleration a "Absolute angular acceleration of component";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.28, y = 0.04, width = 0.7, height = 0.63), Documentation(info = "<html>
// <p>
// Rotational component with <b>inertia</b> and two rigidly connected flanges.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80, -25; -60, -25], style(color = 0)), Line(points = [60, -25;80, -25], style(color = 0)), Line(points = [ -70, -25; -70, -70], style(color = 0)), Line(points = [70, -25;70, -70], style(color = 0)), Line(points = [ -80,25; -60,25], style(color = 0)), Line(points = [60,25;80,25], style(color = 0)), Line(points = [ -70,45; -70,25], style(color = 0)), Line(points = [70,45;70,25], style(color = 0)), Line(points = [ -70, -70;70, -70], style(color = 0)), Rectangle(extent = [ -50,50;50, -50], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [ -90,10; -50, -10], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [50,10;90, -10], style(color = 0, gradient = 2, fillColor = 8)), Text(extent = [0,120;0,60], string = "%name"), Text(extent = [0, -80;0, -130], string = "J=%J", style(color = 0))), Diagram(Line(points = [ -80, -25; -60, -25], style(color = 0)), Line(points = [60, -25;80, -25], style(color = 0)), Line(points = [ -70, -25; -70, -70], style(color = 0)), Line(points = [70, -25;70, -70], style(color = 0)), Line(points = [ -80,25; -60,25], style(color = 0)), Line(points = [60,25;80,25], style(color = 0)), Line(points = [ -70,45; -70,25], style(color = 0)), Line(points = [70,45;70,25], style(color = 0)), Line(points = [ -70, -70;70, -70], style(color = 0)), Rectangle(extent = [ -50,50;50, -50], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [ -90,10; -50, -10], style(color = 0, gradient = 2, fillColor = 8)), Rectangle(extent = [50,10;90, -10], style(color = 0, gradient = 2, fillColor = 8)), Polygon(points = [0, -90; -20, -85; -20, -95;0, -90], style(color = 10, fillColor = 10)), Line(points = [ -90, -90; -19, -90], style(color = 10, fillColor = 10)), Text(extent = [4, -83;72, -96], string = "rotation axis", style(color = 10)), Polygon(points = [9,73;19,70;9,67;9,73], style(color = 0, fillColor = 0)), Line(points = [9,70; -21,70], style(color = 0, fillColor = 0)), Text(extent = [25,77;77,65], string = "w = der(phi) ")));
// 
//       equation 
//         w = der(phi);
//         a = der(w);
//         J * a = flange_a.tau + flange_b.tau;
//       end Inertia;
//       model IdealGear "Ideal gear without inertia"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real ratio = 1 "Transmission ratio (flange_a.phi/flange_b.phi)";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.01, width = 0.6, height = 0.57), Documentation(info = "<html>
// <p>
// This element characterices any type of gear box which is fixed in the
// ground and which has one driving shaft and one driven shaft.
// The gear is <b>ideal</b>, i.e., it does not have inertia, elasticity, damping
// or backlash. If these effects have to be considered, the gear has to be
// connected to other elements in an appropriate way.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -40,20; -20, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -40,140; -20,20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,100;40,60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,60;40, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;20,70], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -40, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Text(extent = [0,190;0,130], string = "%name=%ratio"), Line(points = [ -80,20; -60,20], style(color = 0)), Line(points = [ -80, -20; -60, -20], style(color = 0)), Line(points = [ -70, -20; -70, -70], style(color = 0)), Line(points = [0,60;0, -90], style(color = 0)), Line(points = [ -10,60;10,60], style(color = 0)), Line(points = [ -10,100;10,100], style(color = 0)), Line(points = [60, -20;80, -20], style(color = 0)), Line(points = [60,20;80,20], style(color = 0)), Line(points = [70, -20;70, -70], style(color = 0)), Line(points = [70, -70; -70, -70], style(color = 0))), Diagram(Rectangle(extent = [ -40,20; -20, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -40,140; -20,20], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,100;40,60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,60;40, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -40, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;20,70], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -80; -20, -80], style(color = 10, fillColor = 10)), Polygon(points = [0, -80; -20, -75; -20, -85;0, -80], style(color = 10, fillColor = 10)), Text(extent = [34, -72;34, -86], string = "rotation axis", style(color = 10)), Line(points = [ -80,20; -60,20], style(color = 0)), Line(points = [ -80, -20; -60, -20], style(color = 0)), Line(points = [ -70, -20; -70, -70], style(color = 0)), Line(points = [70, -70; -70, -70], style(color = 0)), Line(points = [0,60;0, -90], style(color = 0)), Line(points = [ -10,60;10,60], style(color = 0)), Line(points = [ -10,100;10,100], style(color = 0)), Line(points = [60,20;80,20], style(color = 0)), Line(points = [60, -20;80, -20], style(color = 0)), Line(points = [70, -20;70, -70], style(color = 0))));
// 
//       equation 
//         phi_a = ratio * phi_b;
//         0 = ratio * flange_a.tau + flange_b.tau;
//       end IdealGear;
//       model IdealPlanetary "Ideal planetary gear box"
//         parameter Real ratio = 100 / 50 "number of ring_teeth/sun_teeth (e.g. ratio=100/50)";
//         Interfaces.Flange_a sun "sun flange (flange axis directed INTO cut plane)" annotation(extent = [ -110, -10; -90,10]);
//         Interfaces.Flange_a carrier "carrier flange (flange axis directed INTO cut plane)" annotation(extent = [ -90,30; -110,50]);
//         Interfaces.Flange_b ring "ring flange (flange axis directed OUT OF cut plane)" annotation(extent = [110, -10;90,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.25, y = 0.01, width = 0.3, height = 0.73), Documentation(info = "<HTML>
// <p>
// The IdealPlanetary gear box is an ideal gear without inertia,
// elasticity, damping or backlash consisting
// of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
// <b>planet</b> wheel located between sun and ring wheel. The bearing
// of the planet wheel shaft is fixed in the planet <b>carrier</b>.
// The component can be connected to other elements at the
// sun, ring and/or carrier flanges. It is not possible to connect
// to the planet wheel. If inertia shall not be neglected,
// the sun, ring and carrier inertias can be easily added by attaching
// inertias (= model Inertia) to the corresponding connectors.
// The inertias of the planet wheels are always neglected.
// </p>
// 
// <p>
// The icon of the planetary gear signals that the sun and carrier
// flanges are on the left side and the ring flange is on the right side
// of the gear box. However, this component is generic and is valid
// independantly how the flanges are actually placed (e.g. sun wheel
// may be placed on the right side instead on the left side in reality).
// </p>
// 
// <p>
// The ideal planetary gearbox is uniquely defined by the ratio
// of the number of ring teeth zr with respect to the number of
// sun teeth zs. For example, if there are 100 ring teeth and
// 50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
// zp has to fulfill the following relationship:
// </p>
// 
// <pre>
//    <b>zp := (zr - zs) / 2</b>
// </pre>
// 
// <p>
// Therefore, in the above example zp = 25 is required.
// </p>
// 
// <p>
// According to the overall convention, the positive direction of all
// vectors, especially the absolute angular velocities and cut-torques
// in the flanges, are along the axis vector displayed in the icon.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 5, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [50,100;10, -100], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -10,45; -50,85], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -10,30; -50, -30], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50,10; -90, -10], style(color = 8, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [90,10;50, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [50,100; -50,105], style(color = 9, fillColor = 9, fillPattern = 1)), Rectangle(extent = [50, -100; -50, -105], style(color = 9, fillColor = 9, fillPattern = 1)), Rectangle(extent = [ -80,70; -50,60], style(color = 0, gradient = 2, arrow = 1, fillColor = 8, fillPattern = 1)), Line(points = [ -90,40; -70,40], style(color = 0)), Line(points = [ -80,50; -60,50], style(color = 0)), Line(points = [ -70,50; -70,40], style(color = 0)), Line(points = [ -80,80; -59,80], style(color = 0)), Line(points = [ -70,100; -70,80], style(color = 0)), Text(extent = [0,168;0,108], string = "%name"), Text(extent = [0, -112;0, -163], string = "ratio=%ratio", style(color = 0))), Diagram(Rectangle(extent = [50,100;10, -100], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -10,45; -50,85], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -10,30; -50, -30], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50,10; -90, -10], style(color = 8, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [90,10;50, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [50,100; -50,105], style(color = 9, fillColor = 9, fillPattern = 1)), Rectangle(extent = [50, -100; -50, -105], style(color = 9, fillColor = 9, fillPattern = 1)), Rectangle(extent = [ -80,70; -50,60], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -90,40; -70,40], style(color = 0)), Line(points = [ -80,50; -60,50], style(color = 0)), Line(points = [ -70,50; -70,40], style(color = 0)), Line(points = [ -80,80; -59,80], style(color = 0)), Line(points = [ -70,90; -70,80], style(color = 0)), Line(points = [ -26, -42; -32, -2], style(pattern = 3)), Line(points = [36, -26;64, -60], style(pattern = 3)), Text(extent = [58, -66;98, -78], string = "ring gear"), Text(extent = [ -112,111; -56,87], string = "planet carrier "), Text(extent = [ -47, -42; -3, -56], string = "sun gear"), Polygon(points = [58,130;28,140;28,120;58,130], style(color = 10, fillColor = 10, fillPattern = 1)), Line(points = [ -52,130;28,130], style(color = 0, fillColor = 10, fillPattern = 1)), Line(points = [ -92,93; -70,80], style(pattern = 3)), Polygon(points = [ -7, -86; -27, -81; -27, -91; -7, -86], style(color = 10, fillColor = 10)), Line(points = [ -97, -86; -26, -86], style(color = 10, fillColor = 10)), Text(extent = [ -96, -71; -28, -84], string = "rotation axis", style(color = 10))));
// 
//       equation 
//         (1 + ratio) * carrier.phi = sun.phi + ratio * ring.phi;
//         ring.tau = ratio * sun.tau;
//         carrier.tau =  -(1 + ratio) * sun.tau;
//       end IdealPlanetary;
//       model IdealGearR2T "Gearbox transforming rotational into translational motion"
//         parameter Real ratio(final unit = "rad/m") = 1 "transmission ratio (flange_a.phi/flange_b.s)";
//         SI.Torque tau_support;
//         SI.Force f_support;
//         Interfaces.Flange_a flange_a annotation(extent = [ -110, -10; -90,10]);
//         Modelica.Mechanics.Translational.Interfaces.Flange_b flange_b annotation(extent = [90,10;110, -10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.35, y = 0.1, width = 0.6, height = 0.65), Documentation(info = "<html>
// This is an ideal mass- and inertialess gearbox which transforms a
// 1D-rotational into a 1D-translational motion. If elasticity, damping
// or backlash has to be considered, this ideal gearbox has to be
// connected with corresponding elements.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>May 16, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "), Icon(Rectangle(extent = [40, -80;80, -120], style(color = 8, fillColor = 8)), Ellipse(extent = [ -70,40;10, -40], style(color = 0, fillColor = 7, fillPattern = 1)), Ellipse(extent = [ -40,10; -20, -10], style(color = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [ -90,10; -70, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Text(extent = [0,110;0,50], string = "%name=%ratio"), Polygon(points = [ -74, -60; -54, -40; -34, -60; -14, -40;6, -60;26, -40;46, -60;66, -40;86, -60; -74, -60], style(color = 0, gradient = 0, fillColor = 9, fillPattern = 1)), Rectangle(extent = [95, -10;106, -60], style(color = 0, fillColor = 9)), Rectangle(extent = [ -80, -80; -40, -120], style(color = 8, fillColor = 8)), Rectangle(extent = [ -74, -60;106, -80], style(color = 0, gradient = 0, fillColor = 9, fillPattern = 1))), Diagram(Rectangle(extent = [ -80, -80; -40, -120], style(color = 8, fillColor = 8)), Rectangle(extent = [40, -80;80, -120], style(color = 8, fillColor = 8)), Ellipse(extent = [ -70,40;10, -40], style(color = 0, fillColor = 7, fillPattern = 1)), Ellipse(extent = [ -40,10; -20, -10], style(color = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [ -90,10; -70, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -74, -60;106, -80], style(color = 0, gradient = 0, fillColor = 9, fillPattern = 1)), Rectangle(extent = [95, -10;106, -60], style(color = 0, fillColor = 9)), Text(extent = [ -100,70;100,40], string = "transform rotation into translation"), Polygon(points = [ -74, -60; -54, -40; -34, -60; -14, -40;6, -60;26, -40;46, -60;66, -40;86, -60; -74, -60], style(color = 0, gradient = 0, fillColor = 9, fillPattern = 1)), Polygon(points = [16,80; -4,85; -4,75;16,80], style(color = 10, fillColor = 10)), Line(points = [ -74,80; -3,80], style(color = 10, fillColor = 10)), Text(extent = [21,88;89,75], string = "rotation axis", style(color = 10))));
//         Interfaces.Flange_a bearingR annotation(extent = [ -70, -110; -50, -90]);
//         Translational.Interfaces.Flange_a bearingT annotation(extent = [50, -110;70, -90]);
// 
//       equation 
//         flange_a.phi - bearingR.phi = ratio * (flange_b.s - bearingT.s);
//         0 = ratio * flange_a.tau + flange_b.f;
//         0 = flange_a.tau + tau_support;
//         0 = flange_b.f + f_support;
//         if cardinality(bearingR) == 0 then
//           bearingR.phi = 0;
// 
//         else
//           bearingR.tau = tau_support;
// 
//         end if;
//         if cardinality(bearingT) == 0 then
//           bearingT.s = 0;
// 
//         else
//           bearingT.f = f_support;
// 
//         end if;
//       end IdealGearR2T;
//       model Spring "Linear 1D rotational spring"
//         extends Interfaces.Compliant;
//         parameter Real c(final unit = "N.m/rad", final min = 0) "Spring constant";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.21, y = 0.02, width = 0.8, height = 0.69), Documentation(info = "<html>
// <p>
// A <b>linear 1D rotational spring</b>. The component can be connected either
// between two inertias/gears to describe the shaft elasticity, or between
// a inertia/gear and the housing (component Fixed), to describe
// a coupling of the element with the housing via a spring.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [0,100;0,40], string = "%name"), Text(extent = [10, -40;10, -90], string = "c=%c", style(color = 0)), Line(points = [ -100,0; -58,0; -43, -30; -13,30;17, -30;47,30;62,0;100,0], style(color = 0, pattern = 1, thickness = 1, arrow = 0))), Diagram(Line(points = [ -68,0; -68,65], style(color = 10)), Line(points = [72,0;72,65], style(color = 10)), Line(points = [ -68,60;72,60], style(color = 10)), Polygon(points = [62,63;72,60;62,57;62,63], style(color = 10, fillColor = 10)), Text(extent = [ -22,62;18,87], string = "phi_rel", style(color = 3)), Text(extent = [12, -61;80, -74], string = "rotation axis", style(color = 10)), Polygon(points = [8, -68; -12, -63; -12, -73;8, -68], style(color = 10, fillColor = 10)), Line(points = [ -82, -68; -11, -68], style(color = 10, fillColor = 10)), Line(points = [ -80,0; -60,0; -42, -32; -12,30;18, -30;48,28;62,0;80,0])));
// 
//       equation 
//         tau = c * (phi_rel - phi_rel0);
//       end Spring;
//       model Damper "Linear 1D rotational damper"
//         extends Interfaces.Compliant;
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         SI.AngularVelocity w_rel "Relative angular velocity between flange_b and flange_a";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.05, width = 0.62, height = 0.65), Documentation(info = "<html>
// <p>
// <b>Linear, velocity dependent damper</b> element. It can be either connected
// between an inertia or gear and the housing (component Fixed), or
// between two inertia/gear elements.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -90,0; -60,0], style(color = 0)), Line(points = [ -60, -30; -60,30], style(color = 0)), Line(points = [ -60, -30;60, -30], style(color = 0)), Line(points = [ -60,30;60,30], style(color = 0)), Rectangle(extent = [ -60,30;30, -30], style(color = 0, fillColor = 8)), Line(points = [30,0;90,0], style(color = 0)), Text(extent = [0,100;0,40], string = "%name"), Text(extent = [0, -50;0, -100], string = "d=%d", style(color = 0))), Diagram(Line(points = [ -90,0; -60,0], style(color = 0)), Line(points = [ -60, -30; -60,30], style(color = 0)), Line(points = [ -60, -30;60, -30], style(color = 0)), Line(points = [ -60,30;60,30], style(color = 0)), Rectangle(extent = [ -60,30;30, -30], style(color = 0, fillColor = 8)), Line(points = [30,0;90,0], style(color = 0)), Line(points = [ -68,0; -68,65], style(color = 10)), Text(extent = [ -22,62;18,87], string = "phi_rel", style(color = 3)), Line(points = [ -68,60;72,60], style(color = 10)), Line(points = [72,0;72,65], style(color = 10)), Polygon(points = [62,63;72,60;62,57;62,63], style(color = 10, fillColor = 10)), Polygon(points = [10, -60; -10, -55; -10, -65;10, -60], style(color = 10, fillColor = 10)), Line(points = [ -80, -60; -9, -60], style(color = 10, fillColor = 10)), Text(extent = [14, -53;82, -66], string = "rotation axis", style(color = 10))));
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = d * w_rel;
//       end Damper;
//       model SpringDamper "Linear 1D rotational spring and damper in parallel"
//         extends Interfaces.Compliant;
//         parameter Real c(final unit = "N.m/rad", final min = 0) "Spring constant";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         SI.AngularVelocity w_rel "Relative angular velocity between flange_b and flange_a";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.04, width = 0.44, height = 0.65), Documentation(info = "<html>
// <p>
// A <b>spring</b> and <b>damper</b> element <b>connected in parallel</b>.
// The component can be
// connected either between two inertias/gears to describe the shaft elasticity
// and damping, or between an inertia/gear and the housing (component Fixed),
// to describe a coupling of the element with the housing via a spring/damper.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,40; -60,40; -45,10; -15,70;15,10;45,70;60,40;80,40], style(color = 0)), Line(points = [ -80,40; -80, -70], style(color = 0)), Line(points = [ -80, -70; -52, -70], style(color = 0)), Rectangle(extent = [ -52, -40;38, -100], style(color = 0, fillColor = 8)), Line(points = [ -52, -40;68, -40], style(color = 0)), Line(points = [ -52, -100;68, -100], style(color = 0)), Line(points = [38, -70;80, -70], style(color = 0)), Line(points = [80,40;80, -70], style(color = 0)), Line(points = [ -90,0; -80,0], style(color = 0)), Line(points = [80,0;90,0], style(color = 0)), Text(extent = [ -101, -147;98, -107], string = "d=%d", style(color = 0)), Text(extent = [0,130;0,70], string = "%name=%c")), Diagram(Line(points = [ -80,32; -58,32; -43,2; -13,62;17,2;47,62;62,32;80,32], style(color = 0, thickness = 2)), Line(points = [ -68,32; -68,97], style(color = 10)), Line(points = [72,32;72,97], style(color = 10)), Line(points = [ -68,92;72,92], style(color = 10)), Polygon(points = [62,95;72,92;62,89;62,95], style(color = 10, fillColor = 10)), Text(extent = [ -20,72;20,97], string = "phi_rel", style(color = 3)), Rectangle(extent = [ -52, -20;38, -80], style(color = 0, fillColor = 8)), Line(points = [ -52, -80;68, -80], style(color = 0)), Line(points = [ -52, -20;68, -20], style(color = 0)), Line(points = [38, -50;80, -50], style(color = 0)), Line(points = [ -80, -50; -52, -50], style(color = 0)), Line(points = [ -80,32; -80, -50], style(color = 0)), Line(points = [80,32;80, -50], style(color = 0)), Line(points = [ -90,0; -80,0], style(color = 0)), Line(points = [90,0;80,0], style(color = 0)), Text(extent = [15, -87;83, -100], string = "rotation axis", style(color = 10)), Polygon(points = [11, -94; -9, -89; -9, -99;11, -94], style(color = 10, fillColor = 10)), Line(points = [ -79, -94; -8, -94], style(color = 10, fillColor = 10))));
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = c * (phi_rel - phi_rel0) + d * w_rel;
//       end SpringDamper;
//       model ElastoBacklash "Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)"
//         extends Interfaces.Compliant;
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Spring constant (c > 0 required)";
//         parameter SI.Angle phi_rel0 = 0 "Unstretched spring angle";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "Damping constant";
//         SI.AngularVelocity w_rel "Relative angular velocity between flange_b and flange_a";
//       protected 
//         SI.Angle b2 = b / 2;
//         constant SI.Angle b_min = 1e-10 "minimum backlash";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.44, height = 0.65), Documentation(info = "<html>
// <p>
// This element consists of a <b>backlash</b> element <b>connected in series</b>
// to a <b>spring</b> and <b>damper</b> element which are <b>connected in parallel</b>.
// The spring constant shall be non-zero, otherwise the component cannot be used.
// </p>
// 
// <p>
// In combination with components IdealGear, the ElastoBacklash model
// can be used to model a gear box with backlash, elasticity and damping.
// </p>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Line(points = [ -80,32; -58,32; -48,0; -34,61; -20,0; -8,60;0,30;20,30], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Rectangle(extent = [ -60, -20; -10, -80], style(color = 0, pattern = 1, thickness = 1, arrow = 0, fillColor = 8)), Line(points = [ -52, -80;0, -80], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -52, -20;0, -20], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -10, -50;20, -50], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -80, -50; -60, -50], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -80,32; -80, -50], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [20,30;20, -50], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -90,0; -80,0], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [90,0;80,0], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [20,0;60,0;60, -30], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [40, -12;40, -40;80, -40;80,0], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Text(extent = [ -99, -130;100, -90], string = "b=%b", style(color = 0)), Text(extent = [0,120;0,60], string = "%name=%c")), Diagram(Line(points = [ -80,32; -58,32; -48,0; -34,60; -20,0; -8,60;0,30;20,30], style(color = 0, thickness = 2)), Line(points = [ -68,32; -68,97], style(color = 10)), Line(points = [80,0;80,96], style(color = 10)), Line(points = [ -68,92;72,92], style(color = 10)), Polygon(points = [70,95;80,92;70,89;70,95], style(color = 10, fillColor = 10)), Text(extent = [ -10,70;30,95], string = "phi_rel", style(color = 10)), Rectangle(extent = [ -60, -20; -10, -80], style(color = 0, thickness = 2, fillColor = 8)), Line(points = [ -52, -80;0, -80], style(color = 0, thickness = 2)), Line(points = [ -52, -20;0, -20], style(color = 0, thickness = 2)), Line(points = [ -10, -50;20, -50], style(color = 0, thickness = 2)), Line(points = [ -80, -50; -60, -50], style(color = 0, thickness = 2)), Line(points = [ -80,32; -80, -50], style(color = 0, thickness = 2)), Line(points = [20,30;20, -50], style(color = 0, thickness = 2)), Line(points = [ -90,0; -80,0], style(color = 0)), Line(points = [90,0;80,0], style(color = 0, thickness = 2)), Line(points = [20,0;60,0;60, -30], style(color = 0, thickness = 2)), Line(points = [40, -12;40, -40;80, -40;80,0], style(color = 0, thickness = 2)), Line(points = [30,0;30,64], style(color = 10)), Line(points = [30,60;80,60], style(color = 10)), Polygon(points = [70,63;80,60;70,57;70,63], style(color = 10, fillColor = 10)), Text(extent = [39,60;68,46], string = "b", style(color = 9, fillColor = 8, fillPattern = 1)), Text(extent = [15, -89;83, -102], string = "rotation axis", style(color = 10)), Polygon(points = [11, -96; -9, -91; -9, -101;11, -96], style(color = 10, fillColor = 10)), Line(points = [ -79, -96; -8, -96], style(color = 10, fillColor = 10))));
// 
//       equation 
//         w_rel = der(phi_rel);
//         tau = if b2 > b_min then if phi_rel > b2 then c * (phi_rel - phi_rel0 - b2) + d * w_rel else if phi_rel <  -b2 then c * (phi_rel - phi_rel0 + b2) + d * w_rel else 0 else c * (phi_rel - phi_rel0) + d * w_rel;
//       end ElastoBacklash;
//       model BearingFriction "Coulomb friction in bearings "
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real tau_pos[:,:] = [0,1] "[w,tau] Positive sliding friction characteristic (w>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*tau_pos[1,2] = Maximum friction torque for w==0";
//         extends Interfaces.FrictionBase;
//         SI.Angle phi;
//         SI.AngularVelocity w "Absolute angular velocity of flange_a and flange_b";
//         SI.AngularAcceleration a "Absolute angular acceleration of flange_a and flange_b";
//         annotation(Documentation(info = "<html>
// <p>
// This element describes <b>Coulomb friction</b> in <b>bearings</b>,
// i.e., a frictional torque acting between a flange and the housing.
// The positive sliding friction torque \"tau\" has to be defined
// by table \"tau_pos\" as function of the absolute angular velocity \"w\".
// E.g.
// <p>
// 
// <pre>
//        w | tau
//       ---+-----
//        0 |   0
//        1 |   2
//        2 |   5
//        3 |   8
// </pre>
// 
// <p>
// gives the following table:
// </p>
// 
// <pre>
//    tau_pos = [0, 0; 1, 2; 2, 5; 3, 8];
// </pre>
// 
// <p>
// Currently, only linear interpolation in the table is supported.
// Outside of the table, extrapolation through the last
// two table entries is used. It is assumed that the negative
// sliding friction force has the same characteristic with negative
// values. Friction is modelled in the following way:
// </p>
// 
// <p>
// When the absolute angular velocity \"w\" is not zero, the friction torque
// is a function of w and of a constant normal force. This dependency
// is defined via table tau_pos and can be determined by measurements,
// e.g. by driving the gear with constant velocity and measuring the
// needed motor torque (= friction torque).
// </p>
// 
// <p>
// When the absolute angular velocity becomes zero, the elements
// connected by the friction element become stuck, i.e., the absolute
// angle remains constant. In this phase the friction torque is
// calculated from a torque balance due to the requirement, that
// the absolute acceleration shall be zero.  The elements begin
// to slide when the friction torque exceeds a threshold value,
// called the maximum static friction torque, computed via:
// </p>
// 
// <pre>
//    maximum_static_friction = <b>peak</b> * sliding_friction(w=0)  (<b>peak</b> >= 1)
// </pre>
// 
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled which have to be solved by appropriate
// numerical methods. The method is described in:
// </p>
// 
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// 
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// 
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// 
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// 
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.25, y = 0.01, width = 0.53, height = 0.61), Icon(Rectangle(extent = [ -90,10;90, -10], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60, -10;60, -60], style(color = 0)), Rectangle(extent = [ -60, -10;60, -25], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60, -45;60, -61], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50, -18;50, -50], style(color = 0, fillColor = 7, fillPattern = 1)), Polygon(points = [60, -60;60, -70;75, -70;75, -80; -75, -80; -75, -70; -60, -70; -60, -60;60, -60], style(color = 0, fillColor = 9, fillPattern = 1)), Line(points = [ -75, -10; -75, -70], style(color = 0)), Line(points = [75, -10;75, -70], style(color = 0)), Rectangle(extent = [ -60,60;60,10], style(color = 0)), Rectangle(extent = [ -60,60;60,45], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60,25;60,10], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50,51;50,19], style(color = 0, fillColor = 7, fillPattern = 1)), Line(points = [ -75,70; -75,10], style(color = 0)), Polygon(points = [60,60;60,70;75,70;75,80; -75,80; -75,70; -60,70; -60,60;60,60], style(color = 0, fillColor = 9, fillPattern = 1)), Line(points = [75,70;75,10], style(color = 0)), Text(extent = [0,150;0,90], string = "%name"), Line(points = [ -10, -90;0, -80], style(color = 0)), Line(points = [ -5, -90;5, -80], style(color = 0)), Line(points = [0, -90;10, -80], style(color = 0)), Line(points = [5, -90;10, -85], style(color = 0)), Line(points = [ -10, -85; -5, -80], style(color = 0))), Diagram(Rectangle(extent = [ -90,10;90, -10], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60, -10;60, -60], style(color = 0)), Rectangle(extent = [ -60, -10;60, -25], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60, -45;60, -61], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50, -18;50, -50], style(color = 0, fillColor = 7, fillPattern = 1)), Polygon(points = [60, -60;60, -70;75, -70;75, -80; -75, -80; -75, -70; -60, -70; -60, -60;60, -60], style(color = 0, fillColor = 9, fillPattern = 1)), Line(points = [ -75, -10; -75, -70], style(color = 0)), Line(points = [75, -10;75, -70], style(color = 0)), Rectangle(extent = [ -60,60;60,10], style(color = 0)), Rectangle(extent = [ -60,60;60,45], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -60,25;60,10], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -50,51;50,19], style(color = 0, fillColor = 7, fillPattern = 1)), Line(points = [ -75,70; -75,10], style(color = 0)), Polygon(points = [60,60;60,70;75,70;75,80; -75,80; -75,70; -60,70; -60,60;60,60], style(color = 0, fillColor = 9, fillPattern = 1)), Line(points = [75,70;75,10], style(color = 0)), Line(points = [ -20, -24;38, -24], style(color = 1, thickness = 4)), Polygon(points = [ -20, -19; -20, -29; -36, -24; -20, -19], style(color = 1, fillColor = 1, fillPattern = 1)), Text(extent = [ -45, -23;49, -51], string = "tau (friction torque)", style(color = 1)), Text(extent = [14,97;82,84], string = "rotation axis", style(color = 10)), Polygon(points = [10,90; -10,95; -10,85;10,90], style(color = 10, fillColor = 10)), Line(points = [ -80,90; -9,90], style(color = 10, fillColor = 10)), Line(points = [ -10, -90;0, -80], style(color = 0)), Line(points = [ -5, -90;5, -80], style(color = 0)), Line(points = [0, -90;10, -80], style(color = 0)), Line(points = [5, -90;10, -85], style(color = 0)), Line(points = [ -10, -85; -5, -80], style(color = 0))));
// 
//       equation 
//         tau0 = Modelica.Math.tempInterpol1(0, tau_pos, 2);
//         tau0_max = peak * tau0;
//         free = false;
//         phi = phi_a;
//         phi = phi_b;
//         w = der(phi);
//         a = der(w);
//         w_relfric = w;
//         a_relfric = a;
//         0 = flange_a.tau + flange_b.tau - tau;
//         tau = if locked then sa else if startForward then Modelica.Math.tempInterpol1(w, tau_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w, tau_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w, tau_pos, 2) else  -Modelica.Math.tempInterpol1( -w, tau_pos, 2);
//       end BearingFriction;
//       model Clutch "Clutch based on Coulomb friction "
//         extends Interfaces.Compliant;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         extends Interfaces.FrictionBase;
//         SI.AngularVelocity w_rel "Relative angular velocity (flange_b.w - flange_a.w)";
//         SI.AngularAcceleration a_rel "Relative angular acceleration (flange_b.a - flange_a.a)";
//         Real mue0 "Friction coefficient for w=0 and forward sliding";
//         SI.Force fn "Normal force (fn=fn_max*inPort.signal)";
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Normalized force signal (= normal_force/fn_max; clutch is engaged if > 0)" annotation(extent = [ -20,130;20,90], rotation = 90);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.2, y = 0.01, width = 0.63, height = 0.64), Icon(Polygon(points = [ -30,40; -60,50; -60,30; -30,40], style(fillColor = 3, fillPattern = 1)), Line(points = [0,90; -90,70; -90,40; -30,40], style(pattern = 1, thickness = 1, arrow = 0)), Line(points = [0,90;90,70;90,40;30,40]), Polygon(points = [30,40;60,50;60,30;30,40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [10,60;30, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -30,60; -10, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [30,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -30, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Text(extent = [0, -130;0, -70], string = "%name")), Documentation(info = "<html>
// <p>
// This component models a <b>clutch</b>, i.e., a component with
// two flanges where friction is present between the two flanges
// and these flanges are pressed together via a normal force.
// The normal force fn has to be provided as input signal u in a normalized form,
// fn = fn_max*u, where fn_max has to be provided as parameter. Friction in the
// clutch is modelled in the following way:
// </p>
// 
// <p>
// When the relative angular velocity is not zero, the friction torque is a
// function of the velocity dependent friction coefficient  mue(w_rel) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// 
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
// </pre>
// 
// <p>
//    Typical values of coefficients of friction:
// </p>
// 
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// 
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// 
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// 
// </pre>
// 
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w_rel),
//     w_rel >= 0, is defined via table mue_pos (first column = w_rel,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// 
// <p>
//    When the relative angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the relative
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the relative acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// 
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// 
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// 
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// 
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// 
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// 
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// 
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized first version.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram(Polygon(points = [ -30,40; -60,50; -60,30; -30,40], style(fillColor = 3, fillPattern = 1)), Line(points = [0,90; -90,70; -90,40; -30,40], style(pattern = 1, thickness = 1, arrow = 0)), Line(points = [0,90;90,70;90,40;30,40]), Polygon(points = [30,40;60,50;60,30;30,40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [10,60;30, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -30,60; -10, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [30,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -30, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Text(extent = [19, -90;87, -103], string = "rotation axis", style(color = 10)), Polygon(points = [15, -97; -5, -92; -5, -102;15, -97], style(color = 10, fillColor = 10)), Line(points = [ -75, -97; -4, -97], style(color = 10, fillColor = 10))));
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         w_relfric = w_rel;
//         a_relfric = a_rel;
//         fn = fn_max * inPort.signal[1];
//         free = fn <= 0;
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = peak * tau0;
//         tau = if locked then sa else if free then 0 else cgeo * fn * (if startForward then Modelica.Math.tempInterpol1(w_rel, mue_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w_rel, mue_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w_rel, mue_pos, 2) else  -Modelica.Math.tempInterpol1( -w_rel, mue_pos, 2));
//       end Clutch;
//       model OneWayClutch "Series connection of freewheel and clutch"
//         extends Interfaces.Compliant;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         parameter SI.AngularVelocity w_small(min = Modelica.Constants.eps) = 1 "Relative angular velocity near to zero (see model info text)";
//         SI.AngularVelocity w_rel "Relative angular velocity (flange_b.w - flange_a.w)";
//         SI.AngularAcceleration a_rel "Relative angular acceleration (flange_b.a - flange_a.a)";
//         Real u "normalized force input signal (0..1)";
//         SI.Force fn "Normal force (fn=fn_max*inPort.signal)";
//         Boolean startForward "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
//         Boolean locked "true, if w_rel=0 and not sliding";
//         Boolean stuck(final start = false) "w_rel=0 (forward sliding or locked)";
//       protected 
//         SI.Torque tau0 "Friction torque for w=0 and sliding";
//         SI.Torque tau0_max "Maximum friction torque for w=0 and locked";
//         Real mue0 "Friction coefficient for w=0 and sliding";
//         Boolean free "true, if frictional element is not active";
//         Real sa "path parameter of tau = f(a_rel) Friction characteristic";
//         constant Real eps0 = 0.0001 "Relative hysteresis epsilon";
//         SI.Torque tau0_max_low "lowest value for tau0_max";
//         parameter Real peak2 = max([peak,1 + eps0]);
//       public 
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) annotation(extent = [ -20,130;20,90], rotation = 90);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.19, y = 0.01, width = 0.55, height = 0.72), Icon(Polygon(points = [ -30,40; -60,50; -60,30; -30,40], style(fillColor = 3, fillPattern = 1)), Line(points = [0,90; -90,70; -90,40; -30,40], style(pattern = 1, thickness = 1, arrow = 0)), Line(points = [0,90;90,70;90,40;30,40]), Polygon(points = [30,40;60,50;60,30;30,40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [10,60;30, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -30,60; -10, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [30,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -30, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Text(extent = [0, -130;0, -70], string = "%name"), Polygon(points = [ -10,30;50,0; -10, -30; -10,30], style(color = 0, fillColor = 0, fillPattern = 1))), Documentation(info = "<html>
// <p>
// This component models a <b>one-way clutch</b>, i.e., a component with
// two flanges where friction is present between the two flanges
// and these flanges are pressed together via a normal force. These
// flanges maybe sliding with respect to each other
// 
// Parallel connection of ClutchCombi and of FreeWheel.
//                      The element is introduced to resolve the ambiguity
//                      of the constraint torques of the elements.
// 
// <p>
// A one-way-clutch is an element where a clutch is connected in parallel
// to a free wheel. This special element is provided, because such
// a parallel connection introduces an ambiguity into the model
// (the constraint torques are not uniquely defined when both
// elements are stuck) and this element resolves it by introducing
// <b>one</b> constraint torque and not two.
// </p>
// 
// <p>
// Note, initial values have to be chosen for the model, such that the
// relative speed of the one-way-clutch >= 0. Otherwise, the configuration
// is physically not possible and an error occurs.
// </p>
// 
// <p>
// The normal force fn has to be provided as input signal u in a normalized form,
// fn = fn_max*u, where fn_max has to be provided as parameter. Friction in the
// clutch is modelled in the following way:
// </p>
// 
// <p>
// When the relative angular velocity is positive, the friction torque is a
// function of the velocity dependent friction coefficient  mue(w_rel) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// 
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
// </pre>
// 
// <p>
//    Typical values of coefficients of friction:
// </p>
// 
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// 
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// 
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// 
// </pre>
// 
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w_rel),
//     w_rel >= 0, is defined via table mue_pos (first column = w_rel,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// 
// <p>
//    When the relative angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the relative
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the relative acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// 
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// 
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// 
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version 0.9 (Nov. 26, 1999)</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// <p><b>Copyright &copy; 1999-2002, DLR.</b></p>
// </HTML>
// "));
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         tau0_max_low = eps0 * mue0 * cgeo * fn_max;
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         u = inPort.signal[1];
//         free = u <= 0;
//         fn = if free then 0 else fn_max * u;
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = if free then tau0_max_low else peak2 * tau0;
//         startForward = pre(stuck) and (sa > tau0_max or pre(startForward) and sa > tau0 or w_rel > w_small) or initial() and w_rel > 0;
//         locked = pre(stuck) and not startForward;
//         a_rel = if locked then 0 else sa - tau0;
//         tau = if locked then sa else if free then 0 else cgeo * fn * Modelica.Math.tempInterpol1(w_rel, mue_pos, 2);
//         stuck = locked or w_rel <= 0;
//       end OneWayClutch;
//       model Brake "Brake based on Coulomb friction "
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real mue_pos[:,:] = [0,0.5] "[w,mue] positive sliding friction coefficient (w_rel>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
//         parameter Real cgeo(final min = 0) = 1 "Geometry constant containing friction distribution assumption";
//         parameter SI.Force fn_max(final min = 0) = 1 "Maximum normal force";
//         extends Interfaces.FrictionBase;
//         SI.Angle phi;
//         SI.AngularVelocity w "Absolute angular velocity of flange_a and flange_b";
//         SI.AngularAcceleration a "Absolute angular acceleration of flange_a and flange_b";
//         Real mue0 "Friction coefficient for w=0 and forward sliding";
//         SI.Force fn "Normal force (=fn_max*inPort.signal)";
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Normalized force signal (= normal_force/fn_max; brake is active if > 0)" annotation(extent = [ -20,130;20,90], rotation = 90);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.05, y = 0.01, width = 0.74, height = 0.71), Icon(Polygon(points = [ -37, -55; -37, -90;37, -90;37, -55;33, -55;33, -86; -33, -86; -33, -55; -37, -55], style(color = 8, fillColor = 8)), Rectangle(extent = [ -90,10; -20, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,60;20, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Polygon(points = [40, -40;70, -30;70, -50;40, -40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [30, -25;40, -55], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [ -40, -40; -70, -30; -70, -50; -40, -40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [ -40, -25; -30, -55], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [0,90;80,70;80, -40;70, -40]), Line(points = [0,90; -80,70; -80, -40; -70, -40], style(pattern = 1, thickness = 1, arrow = 0)), Text(extent = [0, -200;0, -140], string = "%name")), Documentation(info = "<html>
// <p>
// This component models a <b>brake</b>, i.e., a component where a frictional
// torque is acting between the housing and a flange and a controlled normal
// force presses the flange to the housing in order to increase friction.
// The normal force fn has to be provided as input signal u in a normalized
// form, fn = fn_max*u, where fn_max has to be provided as parameter.
// Friction in the brake is modelled in the following way:
// </p>
// 
// <p>
// When the absolute angular velocity \"w\" is not zero, the friction torque
// is a function of the velocity dependent friction coefficient  mue(w) , of
// the normal force \"fn\", and of a geometry constant \"cgeo\" which takes into
// account the geometry of the device and the assumptions on the friction
// distributions:
// </p>
// 
// <pre>
//         frictional_torque = <b>cgeo</b> * <b>mue</b>(w) * <b>fn</b>
// </pre>
// 
// <p>
//    Typical values of coefficients of friction:
// </p>
// 
// <pre>
//       dry operation   :  <b>mue</b> = 0.2 .. 0.4
//       operating in oil:  <b>mue</b> = 0.05 .. 0.1
// </pre>
// 
// <p>
//    When plates are pressed together, where  <b>ri</b>  is the inner radius,
//    <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
//    the geometry constant is calculated in the following way under the
//    assumption of a uniform rate of wear at the interfaces:
// </p>
// 
// <pre>
//          <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
// 
// </pre>
// 
// <p>
//     The positive part of the friction characteristic <b>mue</b>(w),
//     w >= 0, is defined via table mue_pos (first column = w,
//     second column = mue). Currently, only linear interpolation in
//     the table is supported.
// </p>
// 
// <p>
//    When the absolute angular velocity becomes zero, the elements
//    connected by the friction element become stuck, i.e., the absolute
//    angle remains constant. In this phase the friction torque is
//    calculated from a torque balance due to the requirement, that
//    the absolute acceleration shall be zero.  The elements begin
//    to slide when the friction torque exceeds a threshold value,
//    called the  maximum static friction torque, computed via:
// </p>
// 
// <pre>
//        frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w=0) * <b>fn</b>   (<b>peak</b> >= 1)
// </pre>
// 
// <p>
// This procedure is implemented in a \"clean\" way by state events and
// leads to continuous/discrete systems of equations if friction elements
// are dynamically coupled. The method is described in:
// </p>
// 
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <dd><b>Hybrid Modeling in Modelica based on the Synchronous
//     Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
// </dl>
// 
// <p>
// More precise friction models take into account the elasticity of the
// material when the two elements are \"stuck\", as well as other effects,
// like hysteresis. This has the advantage that the friction element can
// be completely described by a differential equation without events. The
// drawback is that the system becomes stiff (about 10-20 times slower
// simulation) and that more material constants have to be supplied which
// requires more sophisticated identification. For more details, see the
// following references, especially (Armstrong and Canudas de Witt 1996):
// </p>
// 
// <dl>
// <dt>Armstrong B. (1991):
// <dd><b>Control of Machines with Friction</b>. Kluwer Academic
//     Press, Boston MA.<br><br>
// 
// <dt>Armstrong B., and Canudas de Wit C. (1996):
// <dd><b>Friction Modeling and Compensation.</b>
//     The Control Handbook, edited by W.S.Levine, CRC Press,
//     pp. 1369-1382.<br><br>
// 
// <dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
// <dd><b>A new model for control of systems with friction.</b>
//     IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
// </dl>
// <br>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized first version.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram(Polygon(points = [ -37, -55; -37, -90;37, -90;37, -55;33, -55;33, -86; -33, -86; -33, -55; -37, -55], style(color = 8, fillColor = 8)), Text(extent = [14, -73;82, -86], string = "rotation axis", style(color = 10)), Polygon(points = [10, -80; -10, -75; -10, -85;10, -80], style(color = 10, fillColor = 10)), Line(points = [ -80, -80; -9, -80], style(color = 10, fillColor = 10)), Rectangle(extent = [ -90,10; -20, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [0,90; -80,70; -80, -40; -70, -40], style(pattern = 1, thickness = 1, arrow = 0)), Rectangle(extent = [ -20,60;20, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [0,90;80,70;80, -40;70, -40]), Polygon(points = [40, -40;70, -30;70, -50;40, -40], style(fillColor = 3, fillPattern = 1)), Polygon(points = [ -40, -40; -70, -30; -70, -50; -40, -40], style(fillColor = 3, fillPattern = 1)), Rectangle(extent = [ -40, -25; -30, -55], style(color = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [30, -25;40, -55], style(color = 0, fillColor = 0, fillPattern = 1))));
// 
//       equation 
//         mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
//         phi = phi_a;
//         phi = phi_b;
//         w = der(phi);
//         a = der(w);
//         w_relfric = w;
//         a_relfric = a;
//         0 = flange_a.tau + flange_b.tau - tau;
//         fn = fn_max * inPort.signal[1];
//         tau0 = mue0 * cgeo * fn;
//         tau0_max = peak * tau0;
//         free = fn <= 0;
//         tau = if locked then sa else if free then 0 else cgeo * fn * (if startForward then Modelica.Math.tempInterpol1(w, mue_pos, 2) else if startBackward then  -Modelica.Math.tempInterpol1( -w, mue_pos, 2) else if pre(mode) == Forward then Modelica.Math.tempInterpol1(w, mue_pos, 2) else  -Modelica.Math.tempInterpol1( -w, mue_pos, 2));
//       end Brake;
//       model LossyGear "Gear with mesh efficiency and bearing friction (stuck/rolling possible)"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real i = 1 "Transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real lossTable[:,5] = [0,1,1,0,0] "Array for mesh efficiencies and bearing friction depending on speed";
//         Real sa "path parameter for acceleration and torque loss";
//         SI.AngularVelocity w_a "angular velocity of flange_a";
//         SI.AngularAcceleration a_a "angular acceleration of flange_a";
//         Real interpolation_result[1,size(lossTable, 2) - 1];
//         Real eta_mf1;
//         Real eta_mf2;
//         Real tau_bf1;
//         Real tau_bf2;
//         Real quadrant1;
//         Real quadrant2;
//         Real quadrant3;
//         Real quadrant4;
//         SI.Torque tauLoss "Torque loss due to friction in the gear teeth and in the bearings";
//         SI.Torque tauLossMax "Torque loss for positive speed";
//         SI.Torque tauLossMin "Torque loss for negative speed";
//         Boolean tau_aPos "true, if torque of flange_a is not negative";
//         Boolean startForward "true, if starting to roll forward";
//         Boolean startBackward "true, if starting to roll backward";
//         Boolean locked "true, if gear is locked";
//         Boolean ideal "true, if losses are neglected";
//         constant Integer Unknown = 3 "Value of mode is not known";
//         constant Integer Free = 2 "Element is not active";
//         constant Integer Forward = 1 "w_a > 0 (forward rolling)";
//         constant Integer Stuck = 0 "w_a = 0 (forward rolling, locked or backward rolling)";
//         constant Integer Backward =  -1 "w_a < 0 (backward rolling)";
//         Integer mode(final min = Backward, final max = Unknown, start = Free, fixed = true);
//         annotation(Documentation(info = "<HTML>
// <p>
// This component models the gear ratio and the <b>losses</b> of
// a standard gear box in a <b>reliable</b> way including the stuck phases
// that may occur at zero speed. The gear boxes that can
// be handeled are fixed in the ground, have one input and one
// output shaft, and are essentially described by the equations:
// </p>
// 
// <pre>     flange_a.phi  = i*flange_b.phi
//    (-flange_b.tau) = i*(eta_mf*flange_a.tau - tau_bf)
// </pre>
// 
// <p>
// where
// </p>
// 
// <ul>
// <li><b>i</b> is the constant <b>gear ratio</b>,</li>
// <li><b>eta_mf</b> = eta_mf(w) is the <b>mesh efficiency</b> due to the
//    friction between the teeth of the gear wheels, </li>
// <li><b>tau_bf</b> = tau_bf(w) is the <b>bearing friction torque</b>, and</li>
// <li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
// </ul>
// 
// <p>The loss terms \"eta_mf\" and \"tau_bf\" are functions of the
// <i>absolute value</i> of the input shaft speed w_a and of the energy
// flow direction. They are defined by parameter <b>lossTable[:,5]
// </b> where the columns of this table have the following
// meaning:</p>
// 
// <p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
//   <tbody>
//     <tr>
//       <td>|w_a|</td>
//       <td>eta_mf1</td>
//       <td>eta_mf2</td>
//       <td>|tau_bf1|</td>
//       <td>|tau_bf2|</td>
//     </tr>
//     <tr>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//     </tr>
//     <tr>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//       <td align=\"center\">...</td>
//     </tr>
//   </tbody>
// </table></p>
// 
// <p>with</p>
// 
// <p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
//   <tbody>
//     <tr>
//       <td>|w_a|</td>
//       <td>Absolute value of angular velocity of input shaft flange_a</td>
//     </tr>
//     <tr>
//       <td>eta_mf1</td>
//       <td>Mesh efficiency in case of input shaft driving</td>
//     </tr>
//     <tr>
//       <td>eta_mf2</td>
//       <td>Mesh efficiency in case of output shaft driving</td>
//     </tr>
//     <tr>
//       <td>|tau_bf1|</td>
//       <td>Absolute bearing friction torque in case of input shaft driving</td>
//     </tr>
//     <tr>
//       <td>|tau_bf2|</td>
//       <td>Absolute bearing friction torque in case of output shaft driving</td>
//     </tr>
//   </tbody>
// </table></p>
// 
// <p>
// With these variables, the mesh efficiency and the bearing friction
// are formally defined as:
// </p>
// 
// <pre>  <b>if</b> flange_a.tau*w_a > 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a > 0 <b>then</b>
//      eta_mf := eta_mf1
//      tau_bf := tau_bf1
//   <b>elseif</b> flange_a.tau*w_a &lt; 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a &lt; 0 <b>then</b>
//      eta_mf := 1/eta_mf2
//      tau_bf := tau_bf2
//   <b>else</b> // w_a == 0
//      eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
//   <b>end if</b>;
// </pre>
// 
// <p>Note, that the losses are modeled in a physically meaningful way taking
// into account that at zero speed the movement may be locked due
// to the friction in the gear teeth and/or in the bearings.
// Due to this important property, this component can be used in
// situations where the combination of the components
// Modelica.Mechanics.Rotational.IdealGear and
// Modelica.Mechanics.Rotational.GearEfficiency will fail because,
// e.g., chattering occurs when using the
// Modelica.Mechanics.Rotational.GearEfficiency model.
// </p>
// 
// <p>
// <b>Acknowledgement:</b> The essential idea to model efficiency
// in this way is from Christoph Pelchen, ZF Friedrichshafen.
// </p>
// 
// <p><b>For detailed information:</b></p>
// 
// <p>Pelchen C.,
// <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Schweiger C.</a>,
// and <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Otter M.</a>:
// &quot;<a href=\"http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf\">Modeling
// and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
// <I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
// pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
// Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</p>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -40,20; -20, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -40,140; -20,20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,100;40,60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,60;40, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;20,70], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -40, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Polygon(points = [ -111,30; -70,30; -70,100; -40,100; -60,121; -80,100; -49,100; -49,20; -111,20; -111,30], style(color = 1, gradient = 0, fillColor = 1, fillPattern = 1)), Line(points = [ -80,20; -60,20], style(color = 0)), Line(points = [ -80, -20; -60, -20], style(color = 0)), Line(points = [ -70, -20; -70, -70], style(color = 0)), Line(points = [70, -70; -70, -70], style(color = 0)), Line(points = [0,60;0, -90], style(color = 0)), Line(points = [ -10,60;10,60], style(color = 0)), Line(points = [ -10,100;10,100], style(color = 0)), Line(points = [60,20;80,20], style(color = 0)), Line(points = [60, -20;80, -20], style(color = 0)), Line(points = [70, -20;70, -70], style(color = 0)), Text(extent = [0,190;0,130], string = "%name=%i")), Diagram(Rectangle(extent = [ -40,20; -20, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -40,140; -20,20], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,100;40,60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [20,60;40, -60], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -90,10; -40, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [40,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -20,90;20,70], style(color = 0, gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -90, -90; -19, -90], style(color = 10, fillColor = 10)), Polygon(points = [0, -90; -20, -85; -20, -95;0, -90], style(color = 10, fillColor = 10)), Text(extent = [5, -82;73, -95], string = "rotation axis", style(color = 10)), Line(points = [ -80,20; -60,20], style(color = 0)), Line(points = [ -80, -20; -60, -20], style(color = 0)), Line(points = [ -70, -20; -70, -70], style(color = 0)), Line(points = [70, -70; -70, -70], style(color = 0)), Line(points = [0,60;0, -90], style(color = 0)), Line(points = [ -10,60;10,60], style(color = 0)), Line(points = [ -10,100;10,100], style(color = 0)), Line(points = [60,20;80,20], style(color = 0)), Line(points = [60, -20;80, -20], style(color = 0)), Line(points = [70, -20;70, -70], style(color = 0))));
//       protected 
//         function equal "Compare whether two Real matrices are identical"
//           extends Modelica.Icons.Function;
//           input Real A[:,:];
//           input Real B[:,:];
//           input Real eps = Modelica.Constants.eps "two numbers r1, r2 are identical if abs(r1-r2) <= eps";
//           output Boolean result;
//         algorithm 
//           result:=false;
//           if size(A, 1) == size(B, 1) and size(A, 2) == size(B, 2) then 
//                     result:=true;
//           for i in 1:size(A, 1) loop
//                       for j in 1:size(A, 2) loop
//                           if abs(A[i,j] - B[i,j]) >= eps then 
//                             result:=false;
// 
//               else 
//               end if;
// 
//             end for;
// 
//           end for;
// 
//           else 
//           end if;
//           annotation(Documentation(info = "<HTML>
// <p>
// The function call
// </p>
// 
// <pre>     equal(A1, A2);
// </pre>
// 
// <p>
// returns <b>true</b>, if the two Real matrices A1 and A2 have the
// same dimensions and the same elements. Otherwise the function
// returns <b>false</b>. Two elements r1 and r2 of A1 and A2 respectively
// are checked on equality by the test 'eps >= abs(r1-r2)', where 'eps'
// can be provided as third argument of the function (the default is
// Modelica.Constants.eps).
// </p>
// </HTML>"));
//         end equal;
// 
//       equation 
//         assert(abs(i) > 0, "Error in initialization of LossyGear: i may not be zero");
//         ideal = equal(lossTable, [0,1,1,0,0]);
//         interpolation_result = if ideal then [1,1,0,0] else Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
//         eta_mf1 = interpolation_result[1,1];
//         eta_mf2 = interpolation_result[1,2];
//         tau_bf1 = noEvent(abs(interpolation_result[1,3]));
//         tau_bf2 = noEvent(abs(interpolation_result[1,4]));
//         phi_a = i * phi_b;
//         0 = flange_b.tau + i * (flange_a.tau - tauLoss);
//         w_a = der(phi_a);
//         a_a = der(w_a);
//         quadrant1 = (1 - eta_mf1) * flange_a.tau + tau_bf1;
//         quadrant2 = (1 - 1 / eta_mf2) * flange_a.tau + tau_bf2;
//         quadrant4 = (1 - 1 / eta_mf2) * flange_a.tau - tau_bf2;
//         quadrant3 = (1 - eta_mf1) * flange_a.tau - tau_bf1;
//         tau_aPos = ideal or flange_a.tau >= 0;
//         tauLossMax = if tau_aPos then quadrant1 else quadrant2;
//         tauLossMin = if tau_aPos then quadrant4 else quadrant3;
//         startForward = pre(mode) == Stuck and sa > tauLossMax or initial() and w_a > 0;
//         startBackward = pre(mode) == Stuck and sa < tauLossMin or initial() and w_a < 0;
//         locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//         tauLoss = if ideal then 0 else if locked then sa else if startForward or pre(mode) == Forward then tauLossMax else tauLossMin;
//         a_a = if locked then 0 else sa - tauLoss;
//         mode = if ideal then Free else if (pre(mode) == Forward or startForward) and w_a > 0 then Forward else if (pre(mode) == Backward or startBackward) and w_a < 0 then Backward else Stuck;
//       end LossyGear;
//       model GearEfficiency "Obsolete component (use model LossyGear instead)"
//         extends Interfaces.TwoFlangesAndBearing;
//         parameter Real eta(min = Modelica.Constants.small, max = 1) = 1 "Efficiency";
//         SI.Angle phi;
//         SI.Power power_a "Energy flowing into flange_a (= power)";
//         Boolean driving_a "True, if energy is flowing INTO and not out of flange flange_a";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.06, width = 0.69, height = 0.62), Icon(Text(extent = [0,130;0,70], string = "%name"), Rectangle(extent = [ -90,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -40;30, -40], style(color = 0)), Line(points = [0, -40;0, -90], style(color = 0)), Polygon(points = [ -30, -20;60, -20;60, -80;70, -80;50, -100;30, -80;40, -80;40, -30; -30, -30; -30, -20; -30, -20], style(color = 1, gradient = 0, fillColor = 1, fillPattern = 1)), Text(extent = [0,70;0,20], string = "eta=%eta", style(color = 0)), Line(points = [30, -50;20, -60], style(color = 0)), Line(points = [30, -40;10, -60], style(color = 0)), Line(points = [20, -40;0, -60], style(color = 0)), Line(points = [10, -40; -10, -60], style(color = 0)), Line(points = [0, -40; -20, -60], style(color = 0)), Line(points = [ -10, -40; -30, -60], style(color = 0)), Line(points = [ -20, -40; -30, -50], style(color = 0))), obsolete = "This model can get stuck due when the torque direction varies, use LossyGear instead.", Documentation(info = "<html>
// <p>
// THIS COMPONENT IS <b>OBSOLETE</b> and should <b>no longer be used</b>. It is only
// kept for <b>backward compatibility</b> purposes. Use model
// Modelica.Mechanics.Rotational.LossyGear instead which implements
// gear efficiency in a much more reliable way.
// </p>
// 
// <p>
// This component consists of two rigidly connected flanges flange_a and flange_b without
// inertia where an <b>efficency</b> coefficient <b>eta</b> reduces the driven
// torque as function of the driving torque depending on the direction
// of the energy flow, i.e., energy is always lost. This can be seen as a
// simple model of the Coulomb friction acting between the teeth of a
// gearbox.
// </p>
// 
// <p>
// Note, that most gearbox manufacturers provide tables of the
// efficiency of a gearbox as function of the angular velocity
// (efficiency becomes zero, if the angular velocity is zero).
// However, such a table is practically useless for simulation purposes,
// because in gearboxes always two types of friction is present:
// (1) Friction in the <b>bearings</b> and (2) friction between
// the teeth of the gear. (1) leads to a velocity dependent, additive
// loss-torque, whereas (2) leads to a torque-dependent reduction of the
// driving torque. The gearbox manufacturers measure both effects
// together and determine the gear efficiency from it, although for
// simulation purposes the two effects need to be separated.
// Assume for example that only constant bearing friction, i.e.,
// bearingTorque=const., is present, i.e.,
// </p>
// 
// <pre>
//    (1)  loadTorque = motorTorque - sign(w)*bearingTorque
// </pre>
// 
// <p>
// Gearbox manufacturers use the loss-formula
// </p>
// 
// <pre>
//    (2)  loadTorque = eta*motorTorque
// </pre>
// 
// <p>
// Comparing (1) and (2) gives a formulat for the efficiency eta:
// </p>
// 
// <pre>
//    eta = (1 - sign(w)*bearingTorque/motorTorque)
// </pre>
// 
// <p>
// When the motorTorque becomes smaller as the bearingTorque,
// (2) is useless, because the efficiency is zero. To summarize,
// be careful to determine the gear <b>efficiency</b> of this element
// from tables of the gear manufacturers.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram(Rectangle(extent = [ -90,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -40;30, -40], style(color = 0)), Line(points = [0,60;0,40], style(color = 0)), Line(points = [ -30,40;29,40], style(color = 0)), Line(points = [0, -40;0, -90], style(color = 0)), Polygon(points = [ -30, -20;60, -20;60, -80;70, -80;50, -100;30, -80;40, -80;40, -30; -30, -30; -30, -20; -30, -20], style(color = 1, gradient = 0, fillColor = 1, fillPattern = 1)), Text(extent = [16,83;84,70], string = "rotation axis", style(color = 10)), Polygon(points = [12,76; -8,81; -8,71;12,76], style(color = 10, fillColor = 10)), Line(points = [ -78,76; -7,76], style(color = 10, fillColor = 10)), Line(points = [30, -50;20, -60], style(color = 0)), Line(points = [30, -40;10, -60], style(color = 0)), Line(points = [20, -40;0, -60], style(color = 0)), Line(points = [10, -40; -10, -60], style(color = 0)), Line(points = [0, -40; -20, -60], style(color = 0)), Line(points = [ -10, -40; -30, -60], style(color = 0)), Line(points = [ -20, -40; -30, -50], style(color = 0))));
// 
//       equation 
//         phi = phi_a;
//         phi = phi_b;
//         power_a = flange_a.tau * der(phi);
//         driving_a = power_a >= 0;
//         flange_b.tau =  -(if driving_a then eta * flange_a.tau else flange_a.tau / eta);
//       end GearEfficiency;
//       model Gear "Realistic model of a gearbox"
//         extends Interfaces.TwoFlangesAndBearingH;
//         parameter Real ratio = 1 "transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real eta(min = Modelica.Constants.small, max = 1) = 1 "Gear efficiency";
//         parameter Real friction_pos[:,:] = [0,1] "[w,tau] positive sliding friction characteristic (w>=0)";
//         parameter Real peak(final min = 1) = 1 "peak*friction_pos[1,2] = maximum friction torque at zero velocity";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Gear elasticity (spring constant)";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "(relative) gear damping";
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         annotation(Documentation(info = "<html>
// <p>
// This component models the essential effects of a gearbox, in particular
// gear <b>efficiency</b> due to friction between the teeth, <b>bearing friction</b>,
// gear <b>elasticity</b> and <b>damping</b>, <b>backlash</b>.
// The inertia of the gear wheels is not modeled. If necessary, inertia
// has to be taken into account by connecting components of model Inertia
// to the left and/or the right flange.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -40,60;40, -60], style(color = 3, pattern = 1, thickness = 1, gradient = 2, arrow = 0, fillColor = 8, fillPattern = 1)), Polygon(points = [ -60, -80; -46, -80; -20, -20;20, -20;46, -80;60, -80;60, -90; -60, -90; -60, -80], style(color = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [ -90,10; -60, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [60,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Polygon(points = [ -60,10; -60,20; -40,40; -40, -40; -60, -20; -60,10], style(color = 10, gradient = 2, fillColor = 10, fillPattern = 1)), Polygon(points = [60,20;40,40;40, -40;60, -20;60,20], style(color = 10, fillColor = 10, fillPattern = 1)), Text(extent = [0,129;0,70], string = "%name=%ratio"), Text(extent = [ -100, -152;99, -112], string = "c=%c", style(color = 0))), Diagram(Text(extent = [2,29;46,22], string = "rotation axis", style(color = 10)), Polygon(points = [4,25; -4,27; -4,23;4,25], style(color = 10, fillColor = 10)), Line(points = [ -36,25; -3,25], style(color = 10, fillColor = 10))));
//         IdealGear gearRatio(final ratio = ratio) annotation(extent = [ -70, -10; -50,10]);
//         GearEfficiency gearEfficiency(final eta = eta) annotation(extent = [ -30, -10; -10,10]);
//         ElastoBacklash elastoBacklash(final b = b, final c = c, final phi_rel0 = 0, final d = d) annotation(extent = [50, -10;70,10]);
//         BearingFriction bearingFriction(final tau_pos = friction_pos, final peak = peak) annotation(extent = [10, -10;30,10]);
// 
//       equation 
//         connect(flange_a,gearRatio.flange_a) annotation(points = [ -100,0; -70,0], style(color = 0));
//         connect(gearRatio.flange_b,gearEfficiency.flange_a) annotation(points = [ -50,0; -30,0], style(color = 0));
//         connect(gearEfficiency.flange_b,bearingFriction.flange_a) annotation(points = [ -10,0;10,0], style(color = 0));
//         connect(bearingFriction.flange_b,elastoBacklash.flange_a) annotation(points = [30,0;50,0], style(color = 0));
//         connect(elastoBacklash.flange_b,flange_b) annotation(points = [70,0;100,0], style(color = 0));
//         connect(gearRatio.bearing,adapter.flange_b) annotation(points = [ -60, -10; -60, -40;6.12303e-16, -40;6.12303e-16, -50], style(color = 0));
//         connect(gearEfficiency.bearing,adapter.flange_b) annotation(points = [ -20, -10; -20, -40;6.12303e-16, -40;6.12303e-16, -50], style(color = 0));
//         connect(bearingFriction.bearing,adapter.flange_b) annotation(points = [20, -10;20, -40;6.12303e-16, -40;6.12303e-16, -50], style(color = 0));
//       end Gear;
//       model Gear2 "Realistic model of a gearbox (based on LossyGear)"
//         extends Interfaces.TwoFlangesAndBearingH;
//         parameter Real i = 1 "transmission ratio (flange_a.phi/flange_b.phi)";
//         parameter Real lossTable[:,5] = [0,1,1,0,0] "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)";
//         parameter Real c(final unit = "N.m/rad", final min = Modelica.Constants.small) = 100000.0 "Gear elasticity (spring constant)";
//         parameter Real d(final unit = "N.m.s/rad", final min = 0) = 0 "(relative) gear damping";
//         parameter SI.Angle b(final min = 0) = 0 "Total backlash";
//         annotation(Documentation(info = "<html>
// <p>This component models the essential effects of a gearbox, in
// particular</p>
// 
// <ul>
//   <li>in component <b>lossyGear</b></li>
//     <ul>
//       <li>gear <b>efficiency</b> due to friction between the teeth</li>
//       <li><b>bearing friction</b></li>
//     </ul>
//   <li>in component <b>elastoBacklash</b></li>
//     <ul>
//       <li>gear <b>elasticity</b></li>
//       <li><b>damping</b></li>
//       <li><b>backlash</b></li>
//     </ul>
// </ul>
// 
// <p>The inertia of the gear wheels is not modeled. If necessary,
// inertia has to be taken into account by connecting components of
// model Inertia to the left and/or the right flange of component
// GearNew.</p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>September 12, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized based on Rotational.Gear by inventing Rotational.LossyGear.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -90,10; -60, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [60,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -40,60;40, -60], style(color = 3, pattern = 1, thickness = 1, gradient = 2, arrow = 0, fillColor = 8, fillPattern = 1)), Polygon(points = [ -60,10; -60,20; -40,40; -40, -40; -60, -20; -60,10], style(color = 10, gradient = 2, fillColor = 10, fillPattern = 1)), Polygon(points = [60,20;40,40;40, -40;60, -20;60,20], style(color = 10, fillColor = 10, fillPattern = 1)), Text(extent = [0,129;0,70], string = "%name=%i"), Text(extent = [ -100, -152;99, -112], string = "c=%c", style(color = 0)), Polygon(points = [ -60, -80; -46, -80; -20, -20;20, -20;46, -80;60, -80;60, -90; -60, -90; -60, -80], style(color = 0, fillColor = 0, fillPattern = 1))), Diagram(Text(extent = [2,64;46,57], string = "rotation axis", style(color = 10)), Polygon(points = [4,60; -4,62; -4,58;4,60], style(color = 10, fillColor = 10)), Line(points = [ -36,60; -3,60], style(color = 10, fillColor = 10))));
//         LossyGear lossyGear(final i = i, final lossTable = lossTable) annotation(extent = [ -60, -20; -20,20]);
//         ElastoBacklash elastoBacklash(final b = b, final c = c, final phi_rel0 = 0, final d = d) annotation(extent = [20, -20;60,20]);
// 
//       equation 
//         connect(flange_a,lossyGear.flange_a) annotation(points = [ -100,0; -60,0], style(color = 0));
//         connect(lossyGear.flange_b,elastoBacklash.flange_a) annotation(points = [ -20,0;20,0], style(color = 0));
//         connect(elastoBacklash.flange_b,flange_b) annotation(points = [60,0;100,0], style(color = 0));
//         connect(lossyGear.bearing,adapter.flange_b) annotation(points = [ -40, -20; -40, -40;6.12303e-16, -40;6.12303e-16, -50], style(color = 0));
//       end Gear2;
//       model Position "Forced movement of a flange according to a reference angle signal"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal";
//         output SI.Angle phi_ref "reference angle defined with the input signal";
//         output SI.Angle phi "absolute rotation angle of flange flange_b";
//         output SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         output SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//       protected 
//         parameter Real w_crit = 2 * Modelica.Constants.pi * f_crit "critical frequency in [1/s]";
//         constant Real af = 1.3617 "s coefficient of Bessel filter";
//         constant Real bf = 0.618 "s*s coefficient of Bessel filter";
//       public 
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Flange angle as input signal" annotation(extent = [ -140, -20; -100,20]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.33, y = 0.01, width = 0.57, height = 0.72), Documentation(info = "<HTML>
// <p>
// The input signal inPort.signal[1] defines the <b>reference
// angle</b> <b>phi_ref(t)</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference angle is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference angle is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// 
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>.<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8)), Text(extent = [0,120;0,60], string = "%name"), Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [ -80, -60; -80, -100], style(color = 0), string = "phi")), Diagram(Text(extent = [ -100,80; -100,40], string = "phi"), Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Line(points = [ -80,80; -10,80], style(color = 10, fillColor = 10)), Polygon(points = [10,80; -10,85; -10,75;10,80], style(color = 10, fillColor = 10)), Text(extent = [50,87;50,73], string = "rotation axis", style(color = 10))));
//         Interfaces.Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi_ref = inPort.signal[1];
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         if exact then
//           phi = phi_ref;
// 
//         else
//           a = ((phi_ref - phi) * w_crit - af * w) * w_crit / bf;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   phi = phi_ref;
//         end if;
//       end Position;
//       model Speed "Forced movement of a flange according to a reference angular velocity signal"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal";
//         SI.Angle w_ref "reference angular velocity defined with the input signal";
//         SI.Angle phi_ref "reference angle defined by time integration of input signal";
//         SI.Angle phi "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//       protected 
//         parameter Real w_crit = 2 * Constants.pi * f_crit "critical frequency in [1/s]";
//         constant Real af = 1.3617 "s coefficient of Bessel filter";
//         constant Real bf = 0.618 "s*s coefficient of Bessel filter";
//       public 
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Blocks.Interfaces.InPort inPort(final n = 1) "Flange angle as input signal" annotation(extent = [ -140, -20; -100,20]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.33, y = 0.01, width = 0.57, height = 0.72), Documentation(info = "<HTML>
// <p>
// The input signal inPort.signal[1] defines the <b>reference
// angle</b> <b>phi_ref(t)</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference angle is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference angle is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// 
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>.<br>
//        Realized based on component <tt>Position</tt> (implemented by
//        <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>).</li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8)), Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Text(extent = [ -80, -60; -80, -100], style(color = 0), string = "w"), Text(extent = [0,120;0,60], string = "%name")), Diagram(Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [ -100,80; -100,40], string = "w"), Line(points = [ -80,80; -10,80], style(color = 10, fillColor = 10)), Polygon(points = [10,80; -10,85; -10,75;10,80], style(color = 10, fillColor = 10)), Text(extent = [50,87;50,73], string = "rotation axis", style(color = 10))));
//         Interfaces.Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         der(phi_ref) = w_ref;
//         w_ref = inPort.signal[1];
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         if exact then
//           w = w_ref;
// 
//         else
//           a = ((phi_ref - phi) * w_crit - af * w) * w_crit / bf;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   w = w_ref;
//         end if;
//       end Speed;
//       model Accelerate "Forced movement of a flange according to an acceleration signal"
//         parameter SI.Angle phi_start = 0 "Start angle";
//         parameter SI.AngularVelocity w_start = 0 "Start angular velocity";
//         SI.Angle phi(final start = phi_start, final fixed = true) "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w(final start = w_start, final fixed = true) "absolute angular velocity of flange flange_b";
//         SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Angular acceleration as input signal" annotation(extent = [ -140, -20; -100,20]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.22, y = 0.01, width = 0.47, height = 0.55), Documentation(info = "<html>
// <p>
// The input signal inPort.signal[1] defines an <b>angular acceleration</b>
// <b>a</b> in [rad/s2]. Flange <b>flange_b</b> is <b>forced</b> to move with
// this acceleration. The angular velocity <b>w</b> and the rotation angle
// <b>phi</b> of the flange are automatically determined by integration of
// the acceleration.
// </p>
// 
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        renamed (previous name: Move).</li>
// 
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8)), Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [ -80, -60; -80, -100], style(color = 0), string = "a"), Text(extent = [0,120;0,60], string = "%name")), Diagram(Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [ -100,80; -100,40], string = "a"), Line(points = [ -80,80; -10,80], style(color = 10, fillColor = 10)), Polygon(points = [10,80; -10,85; -10,75;10,80], style(color = 10, fillColor = 10)), Text(extent = [50,87;50,73], string = "rotation axis", style(color = 10))));
//         Interfaces.Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         a = inPort.signal[1];
//       end Accelerate;
//       model Move "Forced movement of a flange according to an angle, speed and angular acceleration signal"
//         SI.Angle phi "absolute rotation angle of flange flange_b";
//         SI.AngularVelocity w "absolute angular velocity of flange flange_b";
//         SI.AngularAcceleration a "absolute angular acceleration of flange flange_b";
//         SI.Torque tau_support "Support torque";
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 3) annotation(extent = [ -140, -20; -100,20]);
//       protected 
//         Real constraintResidue;
//         Real constraintResidue_d;
//         Real constraintResidue_dd;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<html>
// <p>
// Flange <b>flange_b</b> is <b>forced</b> to move with a predefined motion
// according to the input signals:
// </p>
// 
// <pre>
//     inPort.signal[1]: angle of flange
//     inPort.signal[2]: angular velocity of flange
//     inPort.signal[3]: angular acceleration of flange
// </pre>
// 
// <p>
// The user has to guarantee that the input signals are consistent to each other,
// i.e., that inPort.signal[2] is the derivative of inPort.signal[1] and that
// inPort.signal[3] is the derivative of inPort.signal[2]. There are, however,
// also applications where by purpose these conditions do not hold. For example,
// if only the position dependent terms of a mechanical system shall be
// calculated, one may provide angle = angle(t) and set the angular velocity
// and the angular acceleration to zero.
// </p>
// 
// <p>
// The input signals can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p>
// Note, this model utilizes the non-standard function <b>constrain(..)</b>
// and assumes that this function is supported by the Modelica translator:
// </p>
// <pre>
//    Real r[:], rd[:], rdd[:];
//       ...
//    r   = ..
//    rd  = ...
//    rdd = ...
//    constrain(r,rd,rdd);
// </pre>
// <p>
// where r, rd and rdd are variables which need to be computed
// somewhere else. A simple implementation of constrain() is:
// </p>
// 
// <pre>
//    r = 0;
// </pre>
// 
// <p>
// However, this implementation requires that r(t) is given as analytical,
// smooth function in order that it can be differentiated and it does
// not allow applications such as the one sketched above.
// Function constrain()
// is used to explicitly inform the Modelica translator that
// rd is the derivative of r and rdd is the derivative of rd
// and that all derivatives need to be identical to zero.
// The Modelica translator can utilize this information to use
// rd and rdd whenever the Pantelides algorithm requires to compute
// the derivatives of r (and takes rd and rdd instead of actually
// differentiating r).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 25, 2001</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// 
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Text(extent = [50,87;50,73], string = "rotation axis", style(color = 10)), Polygon(points = [10,80; -10,85; -10,75;10,80], style(color = 10, fillColor = 10)), Line(points = [ -80,80; -10,80], style(color = 10, fillColor = 10)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [ -100,80; -100,40], string = "phi,w,a")), Icon(Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8)), Text(extent = [ -80, -60; -80, -100], string = "phi,w,a", style(color = 0)), Rectangle(extent = [ -100,20;90, -20], style(gradient = 2, fillColor = 8, fillPattern = 1)), Line(points = [ -30, -32;30, -32], style(color = 0)), Line(points = [0,52;0,32], style(color = 0)), Line(points = [ -29,32;30,32], style(color = 0)), Line(points = [0, -32;0, -90], style(color = 0)), Line(points = [30, -42;20, -52], style(color = 0)), Line(points = [30, -32;10, -52], style(color = 0)), Line(points = [20, -32;0, -52], style(color = 0)), Line(points = [10, -32; -10, -52], style(color = 0)), Line(points = [0, -32; -20, -52], style(color = 0)), Line(points = [ -10, -32; -30, -52], style(color = 0)), Line(points = [ -20, -32; -30, -42], style(color = 0)), Text(extent = [0,120;0,60], string = "%name")), Window(x = 0.27, y = 0.05, width = 0.6, height = 0.6));
//       public 
//         Interfaces.Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
// 
//       equation 
//         0 = flange_b.tau + tau_support;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau_support;
// 
//         end if;
//         phi = flange_b.phi;
//         w = der(phi);
//         a = der(w);
//         constraintResidue = inPort.signal[1] - phi;
//         constraintResidue_d = inPort.signal[2] - w;
//         constraintResidue_dd = inPort.signal[3] - a;
//         constrain(constraintResidue, constraintResidue_d, constraintResidue_dd);
//       end Move;
//       model Fixed "Flange fixed in housing at a given angle"
//         parameter SI.Angle phi0 = 0 "Fixed offset angle of housing";
//         Interfaces.Flange_b flange_b "(right) flange fixed in housing" annotation(extent = [10,10; -10, -10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.27, y = 0.02, width = 0.63, height = 0.73), Icon(Text(extent = [0, -92;0, -152], string = "%name=%phi0"), Line(points = [ -80, -40;80, -40], style(color = 0)), Line(points = [80, -40;40, -80], style(color = 0)), Line(points = [40, -40;0, -80], style(color = 0)), Line(points = [0, -40; -40, -80], style(color = 0)), Line(points = [ -40, -40; -80, -80], style(color = 0)), Line(points = [0, -40;0, -10], style(color = 0))), Documentation(info = "<html>
// <p>
// The <b>flange</b> of a 1D rotational mechanical system is <b>fixed</b>
// at an angle phi0 in the <b>housing</b>. May be used:
// </p>
// 
// <ul>
// <li> to connect a compliant element, such as a spring or a damper,
//      between an inertia or gearbox component and the housing.
// 
// <li> to fix a rigid element, such as an inertia, with a specific
//      angle to the housing.
// </ul>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Diagram(Line(points = [ -80, -40;80, -40], style(color = 0)), Line(points = [80, -40;40, -80], style(color = 0)), Line(points = [40, -40;0, -80], style(color = 0)), Line(points = [0, -40; -40, -80], style(color = 0)), Line(points = [ -40, -40; -80, -80], style(color = 0)), Line(points = [0, -40;0, -10], style(color = 0)), Polygon(points = [8,46; -12,51; -12,41;8,46], style(color = 10, fillColor = 10)), Line(points = [ -82,46; -11,46], style(color = 10, fillColor = 10)), Text(extent = [12,53;80,40], string = "rotation axis", style(color = 10))));
// 
//       equation 
//         flange_b.phi = phi0;
//       end Fixed;
//       model Torque "Input signal acting as external torque on a flange"
//         SI.Torque tau "Torque (a positive value accelerates the flange)";
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Connector of input signal used as torque" annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.Flange_b flange_b "(Right) flange" annotation(extent = [90, -10;110,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.32, y = 0.03, width = 0.67, height = 0.72), Documentation(info = "<HTML>
// <p>
// The input signal <b>inPort.signal[1]</b> defines an external
// torque <b>tau</b> in [Nm] which acts (with negative sign) at
// a flange connector, i.e., the component connected to this
// flange is driven by torque <b>tau</b>.</p>
// <p>
// The input signal can be provided from one of the signal generator
// blocks of Modelica.Blocks.Sources.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [0,130;0,70], string = "%name"), Text(extent = [ -90, -10; -90, -50], string = "tau", style(color = 0)), Line(points = [ -88,0; -64,30; -36,52; -2,62;28,56;48,44;64,28;76,14;86,0], style(color = 0, thickness = 2, fillColor = 0)), Polygon(points = [86,0;66,58;37,27;86,0], style(color = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [ -20, -80;20, -120], style(color = 8, fillColor = 8)), Line(points = [ -30, -30;30, -30], style(color = 0)), Line(points = [0, -30;0, -90], style(color = 0)), Line(points = [ -30, -50; -10, -30], style(color = 0)), Line(points = [ -10, -50;10, -30], style(color = 0)), Line(points = [10, -50;30, -30], style(color = 0))), Diagram(Text(extent = [ -124,37; -95,13], string = "tau"), Text(extent = [14,86;82,73], string = "rotation axis", style(color = 10)), Polygon(points = [10,80; -10,85; -10,75;10,80], style(color = 10, fillColor = 10)), Line(points = [ -80,80; -9,80], style(color = 10, fillColor = 10)), Line(points = [ -88,0; -64,30; -36,52; -2,62;28,56;48,44;64,28;76,14;80,10], style(color = 0, thickness = 2, fillColor = 0)), Polygon(points = [86,0;66,58;38,28;86,0], style(color = 0, fillColor = 0, fillPattern = 1))));
//         Interfaces.Flange_a bearing annotation(extent = [ -10, -110;10, -90]);
// 
//       equation 
//         tau = inPort.signal[1];
//         flange_b.tau =  -tau;
//         if cardinality(bearing) == 0 then
//           bearing.phi = 0;
// 
//         else
//           bearing.tau = tau;
// 
//         end if;
//       end Torque;
//       model Torque2 "Input signal acting as torque on two flanges"
//         extends Interfaces.TwoFlanges;
//         SI.Torque tau "Torque (a positive value accelerates the flange)";
//         Blocks.Interfaces.InPort inPort(final n = 1) "Connector of input signal used as torque" annotation(extent = [ -20,20;20,60], rotation = 270);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.32, y = 0.03, width = 0.67, height = 0.72), Documentation(info = "<HTML>
// <p>
// The input signal <b>inPort.signal[1]</b> defines an external
// torque <b>tau</b> in [Nm] which acts at both flange connectors,
// i.e., the components connected to these flanges are driven by torque <b>tau</b>.</p>
// 
// <p>The input signal can be provided from one of the signal generator
// blocks of Modelica.Blocks.Sources.</p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 27, 2003</i>
//        by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "), Icon(Text(extent = [0, -40;0, -100], string = "%name"), Polygon(points = [ -78,24; -69,17; -89,0; -78,24], style(color = 0, thickness = 2, fillColor = 0, fillPattern = 1)), Line(points = [ -74,20; -70,23; -65,26; -60,28; -56,29; -50,30; -41,30; -35,29; -31,28; -26,26; -21,23; -17,20; -13,15; -10,9], style(color = 0, thickness = 2, fillPattern = 1)), Line(points = [74,20;70,23;65,26;60,28;56,29;50,30;41,30;35,29;31,28;26,26;21,23;17,20;13,15;10,9], style(color = 0, thickness = 2, fillPattern = 1)), Polygon(points = [89,0;78,24;69,17;89,0], style(color = 0, fillColor = 0))), Diagram(Text(extent = [20,80;50,60], string = "tau"), Text(extent = [15, -71;83, -84], string = "rotation axis", style(color = 10)), Polygon(points = [11, -77; -9, -72; -9, -82;11, -77], style(color = 10, fillColor = 10)), Line(points = [ -79, -77; -8, -77], style(color = 10, fillColor = 10))));
// 
//       equation 
//         tau = inPort.signal[1];
//         flange_a.tau = tau;
//         flange_b.tau =  -tau;
//       end Torque2;
//       model RelativeStates "Definition of relative state variables"
//         extends Interfaces.TwoFlanges;
//         SI.Angle phi_rel(stateSelect = StateSelect.prefer) "relative rotation angle used as state variable";
//         SI.AngularVelocity w_rel(stateSelect = StateSelect.prefer) "relative angular velocity used as state variable";
//         SI.AngularAcceleration a_rel "relative angular acceleration";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.02, width = 0.72, height = 0.83), Documentation(info = "<html>
// <p>
// Usually, the absolute angle and the absolute angular velocity of
// Modelica.Mechanics.Rotational.Inertia models are used as state variables.
// In some circumstances, relative quantities are better suited, e.g.,
// because it may be easier to supply initial values.
// In such cases, model <b>RelativeStates</b> allows the definition of state variables
// in the following way:
// </p>
// 
// <ul>
// <li> Connect an instance of this model between two flange connectors.</li>
// <li> The <b>relative rotation angle</b> and the <b>relative angular velocity</b>
//      between the two connectors are used as <b>state variables</b>.
// </ul>
// 
// <p>
// An example is given in the next figure
// </p>
// 
// <IMG SRC=\"../Images/relativeStates.png\" ALT=\"relativeStates\">
// 
// <p>
// Here, the relative angle and the relative angular velocity between
// the two inertias are used as state variables. Additionally, the
// simulator selects either the absolute angle and absolute angular
// velocity of model inertia1 or of model inertia2 as state variables.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "), Icon(Ellipse(extent = [ -40,40;40, -40], style(color = 4, fillColor = 4)), Text(extent = [ -40,40;40, -40], string = "S"), Line(points = [ -92,0; -42,0], style(color = 0, pattern = 3)), Line(points = [40,0;90,0], style(color = 0, pattern = 3, fillColor = 4)), Text(extent = [0, -40;0, -100], string = "%name")), Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 4, fillColor = 4)), Text(extent = [ -40,40;40, -40], string = "S"), Line(points = [40,0;90,0], style(color = 0, pattern = 2, fillColor = 4)), Line(points = [ -100, -10; -100, -80], style(color = 9)), Line(points = [100, -10;100, -80], style(color = 9)), Polygon(points = [80, -65;80, -55;100, -60;80, -65], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [ -100, -60;80, -60], style(color = 9)), Text(extent = [ -30, -70;30, -90], string = "w_rel"), Line(points = [ -76,80; -5,80], style(color = 10, fillColor = 10)), Polygon(points = [14,80; -6,85; -6,75;14,80], style(color = 10, fillColor = 10)), Text(extent = [18,87;86,74], string = "rotation axis", style(color = 10)), Line(points = [ -90,0; -40,0], style(color = 0, pattern = 2, fillColor = 4))));
// 
//       equation 
//         phi_rel = flange_b.phi - flange_a.phi;
//         w_rel = der(phi_rel);
//         a_rel = der(w_rel);
//         flange_a.tau = 0;
//         flange_b.tau = 0;
//       end RelativeStates;
//       package Sensors "Sensors to measure variables in 1D rotational mechanical components"
//         extends Modelica.Icons.Library2;
//         model TorqueSensor "Ideal sensor to measure the torque between two flanges (= flange_a.tau)"
//           extends Modelica.Icons.RotationalSensor;
//           SI.Torque tau "Torque in flange flange_a and flange_b (= flange_a.tau = -flange_b.tau)";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>cut-torque between two flanges</b> in an ideal way
// and provides the result as output signal outPort.signal[1] = flange_a.tau
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [ -39, -71;41, -121], string = "tau", style(color = 0)), Line(points = [ -80, -100; -80,0]), Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Text(extent = [0,70;0,110], string = "%name")), Diagram(Text(extent = [ -60, -80; -29, -101], string = "tau"), Polygon(points = [14,85; -6,90; -6,80;14,85], style(color = 10, fillColor = 10)), Line(points = [ -76,85; -5,85], style(color = 10, fillColor = 10)), Text(extent = [18,92;86,79], string = "rotation axis", style(color = 10)), Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [ -80, -100; -80,0])), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.43, y = 0.11, width = 0.55, height = 0.59));
//           Interfaces.Flange_a flange_a annotation(extent = [ -110, -10; -90,10]);
//           Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [ -89, -100; -69, -120], rotation = 90);
// 
//         equation 
//           flange_a.phi = flange_b.phi;
//           flange_a.tau = tau;
//           flange_b.tau =  -tau;
//           tau = outPort.signal[1];
//         end TorqueSensor;
//         model AngleSensor "Ideal sensor to measure the absolute flange angle"
//           extends Interfaces.AbsoluteSensor;
//           SI.Angle phi "Absolute angle of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angle phi</b> of a flange in an ideal
// way and provides the result as output signal outPort.signal[1]
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [70, -30;120, -80], string = "phi", style(color = 0))), Diagram(Text(extent = [70, -11;100, -31], string = "phi"), Text(extent = [14,101;82,88], string = "rotation axis", style(color = 10)), Polygon(points = [10,94; -10,99; -10,89;10,94], style(color = 10, fillColor = 10)), Line(points = [ -80,94; -9,94], style(color = 10, fillColor = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.08, y = 0.09, width = 0.6, height = 0.6));
// 
//         equation 
//           phi = flange_a.phi;
//           phi = outPort.signal[1];
//           0 = flange_a.tau;
//         end AngleSensor;
//         model SpeedSensor "Ideal sensor to measure the absolute flange angular velocity"
//           extends Interfaces.AbsoluteSensor;
//           SI.AngularVelocity w "Absolute angular velocity of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angular velocity w</b> of a flange in an ideal
// way and provides the result as output signal outPort.signal[1]
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [70, -30;120, -80], string = "w", style(color = 0))), Diagram(Text(extent = [69, -10;100, -30], string = "w"), Polygon(points = [13,93; -7,98; -7,88;13,93], style(color = 10, fillColor = 10)), Line(points = [ -77,93; -6,93], style(color = 10, fillColor = 10)), Text(extent = [14,100;82,87], string = "rotation axis", style(color = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.12, y = 0.08, width = 0.6, height = 0.6));
// 
//         equation 
//           w = der(flange_a.phi);
//           w = outPort.signal[1];
//           0 = flange_a.tau;
//         end SpeedSensor;
//         model AccSensor "Ideal sensor to measure the absolute flange angular acceleration"
//           extends Interfaces.AbsoluteSensor;
//           SI.AngularAcceleration a "Absolute angular acceleration of flange";
//           SI.AngularVelocity w "Absolute angular velocity of flange";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>absolute angular acceleration a</b> of a flange in an ideal
// way and provides the result as output signal (to be further processed with
// blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [70, -30;120, -80], string = "a", style(color = 0))), Diagram(Text(extent = [69, -11;100, -31], string = "a"), Polygon(points = [13,93; -7,98; -7,88;13,93], style(color = 10, fillColor = 10)), Line(points = [ -77,93; -6,93], style(color = 10, fillColor = 10)), Text(extent = [17,100;85,87], string = "rotation axis", style(color = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.17, y = 0.12, width = 0.6, height = 0.6));
// 
//         equation 
//           w = der(flange_a.phi);
//           a = der(w);
//           a = outPort.signal[1];
//           0 = flange_a.tau;
//         end AccSensor;
//         model RelAngleSensor "Ideal sensor to measure the relative angle between two flanges"
//           extends Interfaces.RelativeSensor;
//           SI.Angle phi_rel "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angle phi_rel</b> between two flanges
// in an ideal way and provides the result as output signal outPort.signal[1]
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [20, -70;160, -100], string = "phi_rel", style(color = 0))), Diagram(Text(extent = [24, -76;65, -96], string = "phi_rel"), Polygon(points = [13,93; -7,98; -7,88;13,93], style(color = 10, fillColor = 10)), Line(points = [ -77,93; -6,93], style(color = 10, fillColor = 10)), Text(extent = [17,100;85,87], string = "rotation axis", style(color = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.12, y = 0.17, width = 0.6, height = 0.6));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           phi_rel = outPort.signal[1];
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelAngleSensor;
//         model RelSpeedSensor "Ideal sensor to measure the relative angular velocity between two flanges"
//           extends Interfaces.RelativeSensor;
//           SI.Angle phi_rel "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//           SI.AngularVelocity w_rel "Relative angular velocity between two flanges";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angular velocity w_rel</b> between two flanges
// in an ideal way and provides the result as output signal outPort.signal[1]
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [20, -70;160, -100], string = "w_rel", style(color = 0))), Diagram(Text(extent = [25, -79;65, -98], string = "w_rel"), Polygon(points = [13,93; -7,98; -7,88;13,93], style(color = 10, fillColor = 10)), Line(points = [ -77,93; -6,93], style(color = 10, fillColor = 10)), Text(extent = [17,100;85,87], string = "rotation axis", style(color = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.12, y = 0.05, width = 0.6, height = 0.6));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           w_rel = der(phi_rel);
//           w_rel = outPort.signal[1];
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelSpeedSensor;
//         model RelAccSensor "Ideal sensor to measure the relative angular acceleration between two flanges"
//           extends Interfaces.RelativeSensor;
//           SI.Angle phi_rel "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
//           SI.AngularVelocity w_rel "Relative angular velocity between two flanges";
//           SI.AngularAcceleration a_rel "Relative angular aceleration between two flanges";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <b>relative angular acceleration a_rel</b> between two flanges
// in an ideal way and provides the result as output signal outPort.signal[1]
// (to be further processed with blocks of the Modelica.Blocks library).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.
// </li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [20, -70;160, -100], string = "a_rel", style(color = 0))), Diagram(Text(extent = [18, -81;58, -100], string = "a_rel"), Polygon(points = [13,93; -7,98; -7,88;13,93], style(color = 10, fillColor = 10)), Line(points = [ -77,93; -6,93], style(color = 10, fillColor = 10)), Text(extent = [17,100;85,87], string = "rotation axis", style(color = 10))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.14, y = 0.08, width = 0.6, height = 0.6));
// 
//         equation 
//           phi_rel = flange_b.phi - flange_a.phi;
//           w_rel = der(phi_rel);
//           a_rel = der(w_rel);
//           a_rel = outPort.signal[1];
//           0 = flange_a.tau;
//           0 = flange_b.tau;
//         end RelAccSensor;
//         annotation(Icon(Line(points = [ -56, -61; -56, -81], style(color = 0)), Line(points = [ -36, -61; -36, -81], style(color = 0)), Line(points = [ -16, -61; -16, -81], style(color = 0)), Rectangle(extent = [ -76, -81;64, -1], style(color = 0, fillColor = 7)), Line(points = [4, -61;4, -81], style(color = 0)), Line(points = [24, -61;24, -81], style(color = 0)), Line(points = [44, -61;44, -81], style(color = 0)), Polygon(points = [ -6, -61; -16, -37;4, -37; -6, -61], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [ -6, -21; -6, -37], style(color = 0)), Line(points = [ -76, -21; -6, -21], style(color = 0)), Line(points = [ -56, -61; -56, -81], style(color = 0)), Line(points = [ -36, -61; -36, -81], style(color = 0)), Line(points = [ -16, -61; -16, -81], style(color = 0))));
//       end Sensors;
//     end Rotational;
//     package Translational "1-dimensional translational mechanical components"
//       import SI = Modelica.SIunits;
//       extends Modelica.Icons.Library2;
//       annotation(Window(x = 0.05, y = 0.09, width = 0.39, height = 0.47, library = 1, autolayout = 1), Icon(Line(points = [ -84, -73;66, -73], style(color = 0)), Rectangle(extent = [ -81, -22; -8, -65], style(color = 0, gradient = 3, fillColor = 8, fillPattern = 1)), Line(points = [ -8, -43; -1, -43;6, -64;17, -23;29, -65;40, -23;50, -44;61, -44], style(color = 0)), Line(points = [ -59, -73; -84, -93], style(color = 0)), Line(points = [ -11, -73; -36, -93], style(color = 0)), Line(points = [ -34, -73; -59, -93], style(color = 0)), Line(points = [14, -73; -11, -93], style(color = 0)), Line(points = [39, -73;14, -93], style(color = 0)), Line(points = [63, -73;38, -93], style(color = 0))), Documentation(info = "<html>
// <p>
// This package contains components to model <i>1-dimensional translational
// mechanical</i> systems.
// </p>
// 
// <p>
// The <i>filled</i> and <i>non-filled green squares</i> at the left and
// right side of a component represent <i>mechanical flanges</i>.
// Drawing a line between such squares means that the corresponding
// flanges are <i>rigidly attached</i> to each other. The components of this
// library can be usually connected together in an arbitrary way. E.g. it is
// possible to connect two springs or two sliding masses with inertia directly
// together.
// 
// <p> The only <i>connection restriction</i> is that the Coulomb friction
// elements (Stop) should be only connected
// together provided a compliant element, such as a spring, is in between.
// The reason is that otherwise the frictional force is not uniquely
// defined if the elements are stuck at the same time instant (i.e., there
// does not exist a unique solution) and some simulation systems may not be
// able to handle this situation, since this leads to a singularity during
// simulation. It can only be resolved in a \"clean way\" by combining the
// two connected friction elements into
// one component and resolving the ambiguity of the frictional force in the
// stuck mode.
// </p>
// 
// <p> Another restriction arises if the hard stops in model Stop are used, i. e.
// the movement of the mass is limited by a stop at smax or smin.
// <font color=\"#ff0000\"> <b>This requires the states Stop.s and Stop.v</b> </font>. If these states are eliminated during the index reduction
// the model will not work. To avoid this any inertias should be connected via springs
// to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided. </p>
// 
// 
// <p>
// In the <i>icon</i> of every component an <i>arrow</i> is displayed in grey
// color. This arrow characterizes the coordinate system in which the vectors
// of the component are resolved. It is directed into the positive
// translational direction (in the mathematical sense).
// In the flanges of a component, a coordinate system is rigidly attached
// to the flange. It is called <i>flange frame</i> and is directed in parallel
// to the component coordinate system. As a result, e.g., the positive
// cut-force of a \"left\" flange (flange_a) is directed into the flange, whereas
// the positive cut-force of a \"right\" flange (flange_b) is directed out of the
// flange. A flange is described by a Modelica connector containing
// the following variables:
// </p>
// 
// <pre>
//    SIunits.Position s  \"absolute position of flange\";
//    <i>flow</i> Force f        \"cut-force in the flange\";
// </pre>
// 
// <p>
// This package contains the following model components:
// </p>
// 
// <pre>
//    <i>Interfaces</i>       Sublibrary containing interface definitions.
//    <i>Examples</i>         Examples of library usage.
// 
//    <i>SlidingMass</i>      Translational component with inertia.
//    <i>Stop</i>             Sliding mass with Coulomb friction and hard stops.
//    <i>Rod</i>              Massless rod.
//    <i>Spring</i>           Linear spring.
//    <i>Damper</i>           Linear damper.
//    <i>SpringDamper</i>     Linear spring and linear damper in parallel connection.
//    <i>ElastoGap</i>        Linear spring and linear damper that can lift off.
// 
//    <i>Position</i>         Drive a flange with a reference position given as input signal.
//    <i>Accelerate</i>       Drive a flange with an acceleration given as input signal.
//    <i>Move</i>             Drive a flange with a reference position, velocity and
//                     acceleration given as input signal.
//    <i>Fixed</i>            Fixed flange at a predefined position.
//    <i>Force</i>            External force defined as input signal.
// 
//    <i>ForceSensor</i>      Ideal sensor to measure the force in a flange.
//    <i>PositionSensor</i>   Ideal sensor to measure absolute position of a flange.
//    <i>SpeedSensor</i>      Ideal sensor to measure absolute velocity of a flange.
//    <i>AccSensor</i>        Ideal sensor to measure absolute acceleration of a flange.
// 
// </pre>
// 
// <p>
// This library is designed in a fully object oriented way in order that
// components can be connected together in every meaningful combination
// (e.g. direct connection of two springs or two shafts with inertia).
// As a consequence, most models lead to a system of
// differential-algebraic equations of <i>index 3</i> (= constraint
// equations have to be differentiated twice in order to arrive at
// a state space representation) and the Modelica translator or
// the simulator has to cope with this system representation.
// According to our present knowledge, this requires that the
// Modelica translator is able to symbolically differentiate equations
// (otherwise it is e.g. not possible to provide consistent initial
// conditions; even if consistent initial conditions are present, most
// numerical DAE integrators can cope at most with index 2 DAEs).
// </p>
// 
// <b>Main Author:</b><i><ul> Peter Beater</i> <br>
//     Universit&auml;t Paderborn, Abteilung Soest<br>
//     Fachbereich Maschinenbau/Automatisierungstechnik<br>
//     L&uuml;becker Ring 2 <br>
//     D 59494 Soest <br>
//     Germany <br>
// email: <A HREF=\"mailto:Beater@mailso.uni-paderborn.de\">Beater@mailso.uni-paderborn.de</A><br>
// </ul>
// <br>
// 
// <p><b>Release
//  Notes:</b></p>
// <ul>
// <li><i>Version 1.0 (January 5, 2000)</i>
//        by Peter Beater <br>
//        Realized a first version based on Modelica library Mechanics.Rotational
//        by Martin Otter and an existing Dymola library onedof.lib by Peter Beater.
//        <br>
// <li><i>Version 1.01 (July 18, 2001)</i>
//        by Peter Beater <br>
//        Assert statement added to \"Stop\", small bug fixes in examples.
// 
//        <br><br>
// 
// 
// </li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 2000-2002, Modelica Association and Universit&auml;t Paderborn, FB 12.</b></p>
// 
// <p><i>
// The Modelica package is free software; it can be redistributed and/or modified
// under the terms of the Modelica license , see the license conditions
// and the accompanying disclaimer in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       package Examples "Demonstration examples of the components of this package"
//         extends Modelica.Icons.Library;
//         annotation(Window(x = 0.07, y = 0.14, width = 0.51, height = 0.4, library = 1, autolayout = 1), Documentation(info = "<html>
// <p>
// This package contains example models to demonstrate the usage of the
// Translational package. Open the models and
// simulate them according to the provided description in the models.
// The following examples are present:
// </p>
// 
// <pre>
//    <i>SignConvention</i>    Examples for the used sign conventions using simple, basic elements
//    <i>InitialConditions</i> Setting of initial conditions
//    <i>Accelerate </i>       Use of model accelerate
//    <i>Damper</i>            Use of damper elements
//    <i>Oscillator</i>        Oscillator demonstrates the use of initial conditions
//    <i>Sensors</i>           Sensors for translational systems
//    <i>Friction</i>          Stribeck friction characteristics
//    <i>PreLoad</i>           Positioning of a spool using ElastoGap models
// </pre>
// 
// <ul>
// <li><i>First Version from December 7, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "));
//         encapsulated model SignConvention "Examples for the used sign conventions."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "<html>
// <p>
// If all arrows point in the same direction a positive force
// results in a positive acceleration a, velocity v and position s.
// </p>
// For a force of 1 N and a mass of 1 Kg this leads to
// <pre>
//         a = 1 m/s2
//         v = 1 m/s after 1 s (SlidingMass1.v)
//         s = 0.5 m after 1 s (SlidingMass1.s)
// </pre>
// The acceleration is not available for plotting.
// <p>
// </p>
// System 1) and 2) are equivalent. It doesn't matter whether the
// force pushes at flange_a in system 1 or pulls at flange_b in system 2.
// </p><p>
// It is of course possible to ignore the arrows and connect the models
// in an arbitrary way. But then it is hard see in what direction the
// force acts.
// </p><p>
// In the third system the two arrows are opposed which means that the
// force acts in the opposite direction (in the same direction as in
// the two other examples).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// </HTML>
// "), Diagram(Text(extent = [ -100,80; -82,60], string = "1)"), Text(extent = [ -100,40; -82,20], string = "2)"), Text(extent = [ -100, -20; -82, -40], string = "3)")));
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(extent = [36,60;56,80]);
//           Translational.Force Force1 annotation(extent = [ -4,60;16,80]);
//           Sources.Constant Constant1 annotation(extent = [ -44,60; -24,80]);
//           Translational.SlidingMass SlidingMass2(L = 1) annotation(extent = [36,0;56,20]);
//           Translational.Force Force2 annotation(extent = [ -4,20;16,40]);
//           Sources.Constant Constant2 annotation(extent = [ -44,20; -24,40]);
//           Translational.SlidingMass SlidingMass3(L = 1) annotation(extent = [ -40, -40; -20, -20]);
//           Translational.Force Force3 annotation(extent = [20, -40;0, -20]);
//           Sources.Constant Constant3 annotation(extent = [60, -40;40, -20]);
// 
//         equation 
//           connect(Constant1.outPort,Force1.inPort) annotation(points = [ -23,70; -6,70]);
//           connect(Constant2.outPort,Force2.inPort) annotation(points = [ -23,30; -6,30]);
//           connect(Force3.inPort,Constant3.outPort) annotation(points = [22, -30;39, -30]);
//           connect(Force1.flange_b,SlidingMass1.flange_a) annotation(points = [16,70;36,70], style(color = 58));
//           connect(Force2.flange_b,SlidingMass2.flange_b) annotation(points = [16,30;82,30;82,10;56,10], style(color = 58));
//           connect(SlidingMass3.flange_b,Force3.flange_b) annotation(points = [ -20, -30;0, -30], style(color = 58));
//         end SignConvention;
//         encapsulated model InitialConditions "Setting of initial conditions"
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Documentation(info = "There are several ways to set initial conditions.
// 
// In the first system the position of the sliding mass m3 was defined
// by using the modifier s(start=4.5), the position of m5 by s(start=12.5).
// These positions were chosen such that the system is a rest. To calculate
// these values start at the left (Fixed1) with a value of 1 m. The spring
// has an unstreched length of 2 m and m3 an length of 3 m, which leads to
// 
//         1   m (Fixed1)
//       + 2   m (Spring S2)
//       + 3/2 m (half of the length of SlidingMass m3)
//       -------
//         4,5 m = s(start = 4.5) for m3
//       + 3/2 m (half of the length of SlidingMass m3)
//       + 4   m (SpringDamper 4
//       + 5/2 m (half of length of SlidingMass m5)
//       -------
//        12,5 m = s(start = 12.5) for m5
// 
// This selection of initial conditions has the effect that Dymola selects
// those variables (m3.s and m5.s) as state variables.
// 
// In the second example the length of the springs are given as start values
// but they cannot be used as state for pure springs (only for the spring/damper
// combination). In this case the system is not at rest.
// 
// <html> <IMG SRC=../Images/Fig.translational.examples.InitialConditions.png>  </HTML>
// <html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// <li><i>Parameters and documentation modified, July 17, 2001 by P. Beater </i> </li>
// </ul>
// </HTML>
// 
// 
// "));
//           Translational.SlidingMass M3(L = 3, s(start = 4.5)) annotation(extent = [ -20,60;0,80]);
//           Translational.Spring S2(s_rel0 = 2, c = 1000.0) annotation(extent = [ -60,60; -40,80]);
//           Translational.Fixed Fixed1(s0 = 1) annotation(extent = [ -100,60; -80,80]);
//           Translational.SpringDamper SD4(s_rel0 = 4, c = 111) annotation(extent = [20,60;40,80]);
//           Translational.SlidingMass M5(L = 5, s(start = 12.5)) annotation(extent = [60,60;80,80]);
//           Translational.SlidingMass M1(L = 1) annotation(extent = [ -20, -20;0,0]);
//           Translational.Spring S1(s_rel0 = 1, c = 1000.0, s_rel(start = 1)) annotation(extent = [ -58, -20; -38,0]);
//           Translational.Fixed Fixed2(s0 =  -1) annotation(extent = [ -100, -20; -80,0]);
//           Translational.SpringDamper SD1(s_rel0 = 1, c = 111, s_rel(start = 1)) annotation(extent = [20, -20;40,0]);
//           Translational.SlidingMass M2(L = 2) annotation(extent = [60, -20;80,0]);
// 
//         equation 
//           connect(Fixed1.flange_b,S2.flange_a) annotation(points = [ -90,70; -60,70], style(color = 53));
//           connect(S2.flange_b,M3.flange_a) annotation(points = [ -40,70; -20,70], style(color = 53));
//           connect(M3.flange_b,SD4.flange_a) annotation(points = [0,70;20,70], style(color = 53));
//           connect(SD4.flange_b,M5.flange_a) annotation(points = [40,70;60,70], style(color = 53));
//           connect(Fixed2.flange_b,S1.flange_a) annotation(points = [ -90, -10; -58, -10], style(color = 53));
//           connect(S1.flange_b,M1.flange_a) annotation(points = [ -38, -10; -20, -10], style(color = 53));
//           connect(M1.flange_b,SD1.flange_a) annotation(points = [0, -10;20, -10], style(color = 53));
//           connect(SD1.flange_b,M2.flange_a) annotation(points = [40, -10;60, -10], style(color = 53));
//         end InitialConditions;
//         encapsulated model WhyArrows "Use of arrows in Mechanics.Translational"
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Documentation(info = "When using the models of the translational sublibrary
// it is recommended to make sure that all arrows point in
// the same direction because then all component have the
// same reference system.
// 
// In the example the distance from flange_a of Rod1 to flange_b
// of Rod2 is 2 m. The distance from flange_a of Rad1 to flange_b
// of Rod3 is also 2 m though it is difficult to see that. Without
// the arrows it would be almost impossible to notice.
// 
// That all arrows point in the same direction is a sufficient
// condition for an easy use of the library. There are cases
// where horizontally flipped models can be used without
// problems.
// 
// <html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from July 17, 2001 by P. Beater </i> </li>
// </ul>
// </HTML>
// 
// 
// "), Diagram(Text(extent = [ -80,14;90,0], string = "PositionSensor2.s = PositionSensor3.s"), Text(extent = [ -84,4;88, -16], string = "PositionSensor3.s <> PositionSensor1.s"), Text(extent = [ -82, -80;94, -92], string = "Both systems are equivalent"), Line(points = [ -90, -28;90, -28], style(thickness = 2))));
//           Translational.Fixed Fixed1 annotation(extent = [ -20,20;0,40]);
//           Translational.Rod Rod1(L = 1) annotation(extent = [ -48,20; -28,40]);
//           Translational.Rod Rod2(L = 1) annotation(extent = [20,20;40,40]);
//           Translational.Rod Rod3(L = 1) annotation(extent = [ -30,58; -50,78]);
//           Translational.Sensors.PositionSensor PositionSensor2 annotation(extent = [60,20;80,40]);
//           Translational.Sensors.PositionSensor PositionSensor1 annotation(extent = [ -60,20; -80,40]);
//           Translational.Sensors.PositionSensor PositionSensor3 annotation(extent = [ -60,58; -80,78]);
//           Translational.Fixed Fixed3(s0 =  -1.9) annotation(extent = [ -100, -60; -80, -40]);
//           Translational.Spring Spring1(s_rel0 = 2, c = 11) annotation(extent = [ -74, -60; -54, -40]);
//           Translational.SlidingMass SlidingMass1(L = 2) annotation(extent = [ -46, -60; -26, -40]);
//           Translational.Fixed Fixed2(s0 =  -1.9) annotation(extent = [4, -60;24, -40]);
//           Translational.Spring Spring2(s_rel0 = 2, c = 11) annotation(extent = [30, -60;50, -40]);
//           Translational.SlidingMass SlidingMass2(L = 2) annotation(extent = [78, -60;58, -40]);
// 
//         equation 
//           connect(Rod1.flange_b,Fixed1.flange_b) annotation(points = [ -28,30; -10,30], style(color = 58));
//           connect(Fixed1.flange_b,Rod2.flange_a) annotation(points = [ -10,30;20,30], style(color = 58));
//           connect(Rod3.flange_a,Fixed1.flange_b) annotation(points = [ -30,68; -10,68; -10,30], style(color = 58));
//           connect(Rod2.flange_b,PositionSensor2.flange_a) annotation(points = [40,30;60,30], style(color = 58));
//           connect(PositionSensor1.flange_a,Rod1.flange_a) annotation(points = [ -60,30; -48,30], style(color = 58));
//           connect(PositionSensor3.flange_a,Rod3.flange_b) annotation(points = [ -60,68; -50,68], style(color = 58));
//           connect(Fixed3.flange_b,Spring1.flange_a) annotation(points = [ -90, -50; -74, -50], style(color = 58));
//           connect(Spring1.flange_b,SlidingMass1.flange_b) annotation(points = [ -54, -50; -54, -72; -26, -72; -26, -50], style(color = 58));
//           connect(Fixed2.flange_b,Spring2.flange_a) annotation(points = [14, -50;30, -50], style(color = 58));
//           connect(Spring2.flange_b,SlidingMass2.flange_b) annotation(points = [50, -50;58, -50], style(color = 58));
//         end WhyArrows;
//         encapsulated model Accelerate "Use of model accelerate."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           Translational.Accelerate Accelerate1 annotation(extent = [ -40,20; -20,40]);
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(extent = [40,20;60,40]);
//           Sources.Constant Constant1 annotation(extent = [ -100,20; -80,40]);
// 
//         equation 
//           connect(Constant1.outPort,Accelerate1.inPort) annotation(points = [ -79,30; -42,30]);
//           connect(Accelerate1.flange_b,SlidingMass1.flange_a) annotation(points = [ -20,30;40,30], style(color = 58));
//         end Accelerate;
//         encapsulated model Damper "Use of damper models."
//           import Modelica.Icons;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Documentation(info = "Release notes:
// --------------
// 
// 2001 - 7  - 14: Damping parameters increased (from 1 to 25)
// "));
//           Translational.SlidingMass SlidingMass1(L = 1, v(start = 10), s(start = 3)) annotation(extent = [ -80,60; -60,80]);
//           Translational.Damper Damper1(d = 25) annotation(extent = [ -20,60;0,80]);
//           Translational.Fixed Fixed1(s0 = 4.5) annotation(extent = [22,60;42,80]);
//           Translational.SlidingMass SlidingMass2(L = 1, v(start = 10), s(start = 3)) annotation(extent = [ -80,0; -60,20]);
//           Translational.Damper Damper2(d = 25) annotation(extent = [ -20,0;0,20]);
//           Translational.Fixed Fixed2(s0 = 4.5) annotation(extent = [20,0;40,20]);
//           Translational.SlidingMass SlidingMass3(L = 1, v(start = 10), s(start = 3)) annotation(extent = [ -80, -60; -60, -40]);
//           Translational.Fixed Fixed3(s0 = 4.5) annotation(extent = [20, -60;40, -40]);
//           Translational.Spring Spring1(s_rel0 = 1) annotation(extent = [ -20, -20;0,0]);
//           Translational.SpringDamper SpringDamper1(s_rel0 = 1, d = 25) annotation(extent = [ -20, -60;0, -40]);
// 
//         equation 
//           connect(SlidingMass1.flange_b,Damper1.flange_a) annotation(points = [ -60,70; -20,70], style(color = 58));
//           connect(Damper1.flange_b,Fixed1.flange_b) annotation(points = [0,70;32,70], style(color = 58));
//           connect(SlidingMass2.flange_b,Damper2.flange_a) annotation(points = [ -60,10; -20,10], style(color = 58));
//           connect(Damper2.flange_b,Fixed2.flange_b) annotation(points = [0,10;30,10], style(color = 58));
//           connect(Damper2.flange_b,Spring1.flange_b) annotation(points = [0,10;0, -10], style(color = 58));
//           connect(Damper2.flange_a,Spring1.flange_a) annotation(points = [ -20,10; -20, -10], style(color = 58));
//           connect(SlidingMass3.flange_b,SpringDamper1.flange_a) annotation(points = [ -60, -50; -20, -50], style(color = 58));
//           connect(SpringDamper1.flange_b,Fixed3.flange_b) annotation(points = [0, -50;30, -50], style(color = 58));
//         end Damper;
//         encapsulated model Oscillator "Oscillator demonstrates the use of initial conditions."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Documentation(info = "A spring - mass system is a mechanical oscillator. If no
// damping is included and the system is excited at resonance
// frequency infinite amplitudes will result.
// 
// The resonant frequency is given by
// 
// omega_res = sqrt(c / m)
// 
// with: c spring stiffness
//       m mass
// 
// To make sure that the system is initially at rest the initial
// conditions s(start=0) and v(start=0) for the SlindingMass
// are set.
// 
// If damping is added the amplitudes are bounded.
// <html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// </HTML>
// "));
//           Translational.SlidingMass SlidingMass1(L = 1, s(start =  -0.5), v(start = 0.0)) annotation(extent = [ -20,40;0,60]);
//           Translational.Spring Spring1(s_rel0 = 1, c = 10000) annotation(extent = [20,40;40,60]);
//           Translational.Fixed Fixed1(s0 = 1.0) annotation(extent = [60,40;80,60]);
//           Translational.Force Force1 annotation(extent = [ -60,40; -40,60]);
//           Sources.Sine Sine1(freqHz = {15.9155}) annotation(extent = [ -100,40; -80,60]);
//           Translational.SlidingMass SlidingMass2(L = 1, s(start =  -0.5), v(start = 0.0)) annotation(extent = [ -20, -60;0, -40]);
//           Translational.Spring Spring2(s_rel0 = 1, c = 10000) annotation(extent = [20, -60;40, -40]);
//           Translational.Fixed Fixed2(s0 = 1.0) annotation(extent = [60, -60;80, -40]);
//           Translational.Force Force2 annotation(extent = [ -60, -60; -40, -40]);
//           Sources.Sine Sine2(freqHz = {15.9155}) annotation(extent = [ -100, -60; -80, -40]);
//           Translational.Damper Damper1(d = 10) annotation(extent = [20, -36;40, -16]);
// 
//         equation 
//           connect(Sine1.outPort,Force1.inPort) annotation(points = [ -79,50; -62,50]);
//           connect(Sine2.outPort,Force2.inPort) annotation(points = [ -79, -50; -62, -50]);
//           connect(Force1.flange_b,SlidingMass1.flange_a) annotation(points = [ -40,50; -20,50], style(color = 58));
//           connect(Spring1.flange_b,Fixed1.flange_b) annotation(points = [40,50;70,50], style(color = 58));
//           connect(SlidingMass1.flange_b,Spring1.flange_a) annotation(points = [0,50;20,50], style(color = 58));
//           connect(Force2.flange_b,SlidingMass2.flange_a) annotation(points = [ -40, -50; -20, -50], style(color = 58));
//           connect(Spring2.flange_a,Damper1.flange_a) annotation(points = [20, -50;20, -26], style(color = 58));
//           connect(SlidingMass2.flange_b,Spring2.flange_a) annotation(points = [0, -50;20, -50], style(color = 58));
//           connect(Damper1.flange_b,Spring2.flange_b) annotation(points = [40, -26;40, -50], style(color = 58));
//           connect(Spring2.flange_b,Fixed2.flange_b) annotation(points = [40, -50;70, -50], style(color = 58));
//         end Oscillator;
//         encapsulated model Sensors "Sensors for translational systems."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Documentation(info = "These sensors measure
// 
//    force f in N
//    position s in m
//    velocity v in m/s
//    acceleration a in m/s2
// 
// Dhe measured velocity and acceleration is independent on
// the flange the sensor is connected to. The position
// depends on the flange (flange_a or flange_b) and the
// length L of the component.
// 
// Plot PositionSensor1.s, PositionSensor2.s and SlidingMass1.s
// to see the difference.
// <html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// </HTML>
// "));
//           Translational.Sensors.ForceSensor ForceSensor1 annotation(extent = [ -20,40;0,60]);
//           Translational.Sensors.SpeedSensor SpeedSensor1 annotation(extent = [20, -40;40, -20]);
//           Translational.Sensors.PositionSensor PositionSensor1 annotation(extent = [20,0;40,20]);
//           Translational.Sensors.AccSensor AccSensor1 annotation(extent = [20, -80;40, -60]);
//           Translational.SlidingMass SlidingMass1(L = 1) annotation(extent = [20,40;40,60]);
//           Translational.Force Force1 annotation(extent = [ -60,40; -40,60]);
//           Sources.Sine Sine1(amplitude = {10}, freqHz = {4}) annotation(extent = [ -100,40; -80,60]);
//           Translational.Sensors.PositionSensor PositionSensor2 annotation(extent = [60,40;80,60]);
// 
//         equation 
//           connect(Sine1.outPort,Force1.inPort) annotation(points = [ -79,50; -62,50]);
//           connect(ForceSensor1.flange_b,SlidingMass1.flange_a) annotation(points = [0,50;20,50], style(color = 58));
//           connect(SlidingMass1.flange_b,PositionSensor2.flange_a) annotation(points = [40,50;60,50], style(color = 58));
//           connect(Force1.flange_b,ForceSensor1.flange_a) annotation(points = [ -40,50; -20,50], style(color = 58));
//           connect(SlidingMass1.flange_a,PositionSensor1.flange_a) annotation(points = [20,50;20,10], style(color = 58));
//           connect(PositionSensor1.flange_a,SpeedSensor1.flange_a) annotation(points = [20,10;20, -30], style(color = 58));
//           connect(SpeedSensor1.flange_a,AccSensor1.flange_a) annotation(points = [20, -30;20, -70], style(color = 58));
//         end Sensors;
//         encapsulated model Friction "Use of model Stop"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Diagram(Text(extent = [ -56, -88;62, -100], string = "simulate 5 s"), Text(extent = [ -100,80; -80,60], string = "1)"), Text(extent = [ -100,20; -80,0], string = "2)")), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Documentation(info = "1) Simulate and then plot Stop1.f as a function of Stop1.v
//    This gives the Stribeck curve.
// 
// 2) This model gives an example for a hard stop. However there
//    can arise some problems with the used modeling approach (use of
//    Reinit, convergence problems). In this case use the ElastoGap
//    to model a stop (see example Preload).
// <html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// </ul>
// </HTML>
// "));
//           Translational.Stop Stop1(L = 1) annotation(extent = [60,60;80,80]);
//           Translational.Force Force1 annotation(extent = [18,60;38,80]);
//           Sources.Sine Sine1(amplitude = {25}, freqHz = {0.25}) annotation(extent = [ -20,60;0,80]);
//           Translational.Stop Stop2(L = 1, smax = 0.9, smin =  -0.9, F_Coulomb = 3, F_Stribeck = 5, s(start = 0), v(start =  -5)) annotation(extent = [60,0;80,20]);
//           Translational.Spring Spring1(s_rel0 = 1, c = 500) annotation(extent = [20,0;40,20]);
//           Translational.Fixed Fixed1(s0 =  -1.75) annotation(extent = [ -22,0; -2,20]);
// 
//         equation 
//           connect(Sine1.outPort,Force1.inPort) annotation(points = [1,70;16,70]);
//           connect(Force1.flange_b,Stop1.flange_a) annotation(points = [38,70;60,70], style(color = 58));
//           connect(Fixed1.flange_b,Spring1.flange_a) annotation(points = [ -12,10;20,10], style(color = 58));
//           connect(Spring1.flange_b,Stop2.flange_a) annotation(points = [40,10;60,10], style(color = 58));
//         end Friction;
//         encapsulated model PreLoad "Preload of a spool using ElastoGap models."
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Mechanics.Translational;
//           extends Icons.Example;
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Diagram(Text(extent = [ -98, -68;102, -94], string = "positive force => spool moves in positive direction "), Text(extent = [ -32, -46;38, -62], string = "Simulate for 100 s"), Text(extent = [ -100, -54;100, -80], string = "plot Spool.s as a function of Force1.f")), Documentation(info = "When designing hydraulic valves it is often necessary to hold the spool in
// a certain position as long as an external force is below a threshold value.
// If this force exceeds the treshold value a linear relation between force
// and position is desired.
// There are designs that need only one spring to accomplish this task. Using
// the ElastoGap elements this design can be modelled easily.
// Drawing of spool.
// <HTML> <IMG SRC=../Images/PreLoad.png> </HTML>
// <HTML> <IMG SRC=../Images/PreLoad3.png> </HTML>
// <HTML> <IMG SRC=../Images/PreLoad4.png> </HTML>
// Spool position s as a function of working force f.
// <HTML> <IMG SRC=../Images/PreLoad2.png> </HTML>
// <HTML>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 10, 1999 by P. Beater </i> </li>
// <li><i>July 17, 2001, parameters changed, by P. Beater </i> </li>
// <li><i>Ocotber 5, 2002, object diagram and parameters changed, by P. Beater </i> </li>
// </ul>
// </HTML>
// "));
//           Translational.ElastoGap InnerContactA(s_rel0 = 0.001, c = 1000000.0, d = 250) annotation(extent = [ -68,20; -48,40]);
//           Translational.ElastoGap InnerContactB(s_rel0 = 0.001, c = 1000000.0, d = 250) annotation(extent = [54,20;74,40], style(color = 58));
//           Translational.SlidingMass Spool(L = 0.19, m = 0.15, s(start = 0.01475)) annotation(extent = [6, -42;46, -2]);
//           Translational.Fixed FixedLe(s0 =  -0.0955) annotation(extent = [ -98,58; -78,78]);
//           Translational.SlidingMass SpringPlateA(L = 0.002, m = 0.01, s(start =  -0.093)) annotation(extent = [ -40,58; -20,78]);
//           Translational.SlidingMass SpringPlateB(L = 0.002, m = 0.01, s(start =  -0.06925)) annotation(extent = [26,58;46,78], style(color = 58));
//           Translational.Spring Spring(c = 20000.0, s_rel0 = 0.025) annotation(extent = [ -8,58;12,78]);
//           Translational.ElastoGap OuterContactA(s_rel0 = 0.0015, c = 1000000.0, d = 250) annotation(extent = [ -74,58; -54,78]);
//           Translational.ElastoGap OuterContactB(c = 1000000.0, d = 250, s_rel0 = 0.0015) annotation(extent = [60,58;80,78]);
//           Translational.Rod Rod1(L = 0.007) annotation(extent = [ -40,32; -20,52]);
//           Translational.Damper Friction(d = 2500) annotation(extent = [ -98,14; -78,34], rotation =  -90);
//           Translational.Force Force1 annotation(extent = [ -32, -32; -12, -12]);
//           Translational.Rod Housing(L = 0.0305) annotation(extent = [ -8,78;12,98]);
//           Translational.Rod Rod3(L = 0.00575) annotation(extent = [ -40, -2; -20,18]);
//           Translational.Rod Rod4(L = 0.00575) annotation(extent = [26, -2;46,18]);
//           Translational.Rod Rod2(L = 0.007) annotation(extent = [26,32;46,52]);
//           Sources.Sine Sine1(amplitude = {150}, freqHz = {0.01}) annotation(extent = [ -76, -32; -56, -12]);
// 
//         equation 
//           connect(OuterContactA.flange_b,SpringPlateA.flange_a) annotation(points = [ -54,68; -40,68], style(color = 58));
//           connect(SpringPlateA.flange_b,Spring.flange_a) annotation(points = [ -20,68; -8,68], style(color = 58));
//           connect(Spring.flange_b,SpringPlateB.flange_a) annotation(points = [12,68;26,68], style(color = 58));
//           connect(SpringPlateB.flange_b,OuterContactB.flange_a) annotation(points = [46,68;60,68], style(color = 58));
//           connect(FixedLe.flange_b,OuterContactA.flange_a) annotation(points = [ -88,68; -74,68], style(color = 58));
//           connect(Friction.flange_a,FixedLe.flange_b) annotation(points = [ -88,34; -88,68], style(color = 58));
//           connect(FixedLe.flange_b,Housing.flange_a) annotation(points = [ -88,68; -88,88; -8,88], style(color = 58));
//           connect(OuterContactB.flange_b,Housing.flange_b) annotation(points = [80,68;80,88;12,88], style(color = 58));
//           connect(SpringPlateA.flange_b,Rod1.flange_a) annotation(points = [ -20,68; -20,52; -40,52; -40,42], style(color = 58));
//           connect(InnerContactA.flange_a,Rod3.flange_a) annotation(points = [ -68,30; -80,30; -80,8; -40,8], style(color = 58));
//           connect(InnerContactA.flange_b,Rod1.flange_b) annotation(points = [ -48,30; -12,30; -12,42; -20,42], style(color = 58));
//           connect(Rod2.flange_a,InnerContactB.flange_a) annotation(points = [26,42;26,30;54,30], style(color = 58));
//           connect(Rod4.flange_b,InnerContactB.flange_b) annotation(points = [46,8;80,8;80,30;74,30], style(color = 58));
//           connect(Friction.flange_b,Rod3.flange_a) annotation(points = [ -88,14; -88,8; -40,8], style(color = 58));
//           connect(Sine1.outPort,Force1.inPort) annotation(points = [ -55, -22; -34, -22], style(color = 3));
//           connect(Force1.flange_b,Spool.flange_a) annotation(points = [ -12, -22;6, -22], style(color = 58));
//           connect(Rod3.flange_b,Rod4.flange_a) annotation(points = [ -20,8;26,8], style(color = 58));
//           connect(Rod2.flange_b,SpringPlateB.flange_a) annotation(points = [46,42;46,54;26,54;26,68], style(color = 58));
//           connect(Spool.flange_a,Rod4.flange_a) annotation(points = [6, -20;6,8;26,8], style(color = 58));
//         end PreLoad;
//       end Examples;
//       package Interfaces "Interfaces for 1D translational mechanical components"
//         extends Modelica.Icons.Library;
//         connector Flange_a "(left) 1D translational flange (flange axis directed INTO cut plane, e. g. from left to right)"
//           annotation(Coordsys(extent = [ -100, -100;100,100]), Window(x = 0.27, y = 0.05, width = 0.39, height = 0.83), Documentation(info = "<html>
// 
// This is a flange for 1D translational mechanical systems. In the cut plane of
// the flange a unit vector n, called flange axis, is defined which is directed
// INTO the cut plane, i. e. from left to right. All vectors in the cut plane are
// resolved with respect to
// this unit vector. E.g. force f characterizes a vector which is directed in
// the direction of n with value equal to f. When this flange is connected to
// other 1D translational flanges, this means that the axes vectors of the connected
// flanges are identical.
// </p>
// <p>
// The following variables are transported through this connector:
// <pre>
// 
//   s: Absolute position of the flange in [m]. A positive translation
//      means that the flange is translated along the flange axis.
//   f: Cut-force in direction of the flange axis in [N].
// </pre>
// </HTML>
// "), Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 58, fillColor = 58))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 58, fillColor = 58)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 58))), Terminal(Rectangle(extent = [ -100, -100;100,100], style(color = 58, fillColor = 58))));
//           SI.Position s "absolute position of flange";
//           flow SI.Force f "cut force directed into flange";
//         end Flange_a;
//         connector Flange_b "right 1D translational flange (flange axis directed OUT OF cut plane)"
//           SI.Position s "absolute position of flange";
//           flow SI.Force f "cut force directed into flange";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.27, y = 0.05, width = 0.39, height = 0.83), Documentation(info = "<html>
// This is a flange for 1D translational mechanical systems. In the cut plane of
// the flange a unit vector n, called flange axis, is defined which is directed
// OUT OF the cut plane. All vectors in the cut plane are resolved with respect to
// this unit vector. E.g. force f characterizes a vector which is directed in
// the direction of n with value equal to f. When this flange is connected to
// other 1D translational flanges, this means that the axes vectors of the connected
// flanges are identical.
// </p>
// <p>
// The following variables are transported through this connector:
// <pre>
// 
//   s: Absolute position of the flange in [m]. A positive translation
//      means that the flange is translated along the flange axis.
//   f: Cut-force in direction of the flange axis in [N].
// </pre>
// </HTML>
// "), Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 58, fillColor = 7))), Diagram(Rectangle(extent = [ -100, -100;100,100], style(color = 58, fillColor = 7)), Text(extent = [ -100, -120;100, -220], string = "%name", style(color = 58))), Terminal(Rectangle(extent = [ -100, -100;100,100], style(color = 58))));
//         end Flange_b;
//         partial model Rigid "Rigid connection of two translational 1D flanges "
//           SI.Position s "absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)";
//           parameter SI.Length L = 0 "length of component from left flange to right flange (= flange_b.s - flange_a.s)";
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, i. e. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane, i. e. from right to left)" annotation(extent = [90, -10;110,10]);
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D translational component with two <i>rigidly</i> connected flanges.
// The distance between the left and the right flange is always constant, i. e. L.
// The forces at the right and left flange can be different.
// It is used e.g. to built up sliding masses.
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater  (based on Rotational.Rigid)</i> </li>
// </ul>
// </HTML>
// "), Diagram, Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.14, y = 0.05, width = 0.71, height = 0.58));
// 
//         equation 
//           flange_a.s = s - L / 2;
//           flange_b.s = s + L / 2;
//         end Rigid;
//         partial model Compliant "Compliant connection of two translational 1D flanges"
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           SI.Distance s_rel "relative distance (= flange_b.s - flange_a.s)";
//           SI.Force f "forcee between flanges (positive in direction of flange axis R)";
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.17, y = 0.09, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// This is a 1D translational component with a <i>compliant </i>connection of two
// translational 1D flanges where inertial effects between the two
// flanges are not included. The absolute value of the force at the left and the right
// flange is the same. It is used to built up springs, dampers etc.
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Compliant)</i> </li>
// </ul>
// </HTML>
// "), Diagram(Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10))));
// 
//         equation 
//           s_rel = flange_b.s - flange_a.s;
//           flange_b.f = f;
//           flange_a.f =  -f;
//         end Compliant;
//         partial model TwoFlanges "Component with two translational 1D flanges "
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           annotation(Documentation(info = "<html>
// <p>
// This is a 1D translational component with two flanges.
// It is used e.g. to built up parts of a drive train consisting
// of several base components.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.TwoFlanges)</i> </li>
// </ul>
// </HTML>
// "), Diagram, Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.08, y = 0.18, width = 0.6, height = 0.6));
//         end TwoFlanges;
//         partial model AbsoluteSensor "Device to measure a single absolute flange variable"
//           extends Modelica.Icons.TranslationalSensor;
//           Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.36, y = 0.04, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// This is the superclass of a 1D translational component with one flange and one
// output signal in order to measure an absolute kinematic quantity in the flange
// and to provide the measured signal as output signal for further processing
// with the Modelica.Blocks blocks.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version 1.0 (July 18, 1999)</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// </HTML>
// "), Icon(Line(points = [ -100, -90; -20, -90], style(color = 0, fillColor = 10, fillPattern = 1)), Polygon(points = [10, -90; -20, -80; -20, -100;10, -90], style(color = 10, fillColor = 10, fillPattern = 1)), Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0]), Text(extent = [ -118,99;118,40], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;100,0])));
//         end AbsoluteSensor;
//         partial model RelativeSensor "Device to measure a single relative variable between two flanges"
//           extends Modelica.Icons.TranslationalSensor;
//           Flange_a flange_a "(left) driving flange (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Flange_b flange_b "(right) driven flange (flange axis directed OUT OF cut plane)" annotation(extent = [90, -10;110,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [ -10, -100;10, -120], rotation = 90);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.04, y = 0.05, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// This is a superclass for 1D translational components with two rigidly connected
// flanges and one output signal in order to measure relative kinematic quantities
// between the two flanges or the cut-force in the flange and
// to provide the measured signal as output signal for further processing
// with the Modelica.Blocks blocks.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version 1.0 (July 18, 1999)</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// </HTML>
// "), Icon(Line(points = [ -51,34;29,34], style(color = 0, fillColor = 10, fillPattern = 1)), Polygon(points = [59,34;29,44;29,24;59,34], style(color = 0, fillColor = 10, fillPattern = 1)), Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [0, -100;0, -60]), Text(extent = [ -117,116;115,52], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70,0;90,0], style(color = 0)), Line(points = [0, -100;0, -60])));
//         end RelativeSensor;
//         partial model FrictionBase "Base class of Coulomb friction elements"
//           extends Rigid;
//           parameter SI.Position smax = 25 "right stop for (right end of) sliding mass";
//           parameter SI.Position smin =  -25 "left stop for (left end of) sliding mass";
//           parameter SI.Velocity v_small = 0.001 "Relative velocity near to zero (see model info text)";
//           SI.Velocity v_relfric "Relative velocity between frictional surfaces";
//           SI.Acceleration a_relfric "Relative acceleration between frictional surfaces";
//           SI.Force f "Friction force (positive, if directed in opposite direction of v_rel)";
//           SI.Force f0 "Friction force for v=0 and forward sliding";
//           SI.Force f0_max "Maximum friction force for v=0 and locked";
//           Boolean free "true, if frictional element is not active";
//           Real sa "Path parameter of friction characteristic f = f(a_relfric)";
//           Boolean startForward "true, if v_rel=0 and start of forward sliding or v_rel > v_small";
//           Boolean startBackward "true, if v_rel=0 and start of backward sliding or v_rel < -v_small";
//           Boolean locked "true, if v_rel=0 and not sliding";
//           constant Integer Unknown = 3 "Value of mode is not known";
//           constant Integer Free = 2 "Element is not active";
//           constant Integer Forward = 1 "v_rel > 0 (forward sliding)";
//           constant Integer Stuck = 0 "v_rel = 0 (forward sliding, locked or backward sliding)";
//           constant Integer Backward =  -1 "v_rel < 0 (backward sliding)";
//           Integer mode(final min = Backward, final max = Unknown, start = Unknown);
//           annotation(Documentation(info = "<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Version from January 5, 2000 by P. Beater
// (based on Translational.FrictionBase from Martin Otter)</i> </li>
// </ul>
// </HTML>
// "));
// 
//         equation 
//           startForward = pre(mode) == Stuck and (sa > f0_max and s < smax - L / 2 or pre(startForward) and sa > f0 and s < smax - L / 2) or pre(mode) == Backward and v_relfric > v_small or initial() and v_relfric > 0;
//           startBackward = pre(mode) == Stuck and (sa <  -f0_max and s > smin + L / 2 or pre(startBackward) and sa <  -f0 and s > smin + L / 2) or pre(mode) == Forward and v_relfric <  -v_small or initial() and v_relfric < 0;
//           locked = not free and not (pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);
//           a_relfric = if locked then 0 else if free then sa else if startForward then sa - f0 else if startBackward then sa + f0 else if pre(mode) == Forward then sa - f0 else sa + f0;
//           mode = if free then Free else if (pre(mode) == Forward or pre(mode) == Free or startForward) and v_relfric > 0 and s < smax - L / 2 then Forward else if (pre(mode) == Backward or pre(mode) == Free or startBackward) and v_relfric < 0 and s > smin + L / 2 then Backward else Stuck;
//         end FrictionBase;
//       end Interfaces;
//       model SlidingMass "Sliding mass with inertia"
//         extends Interfaces.Rigid;
//         parameter SI.Mass m = 1 "mass of the sliding mass";
//         SI.Velocity v "absolute velocity of component";
//         SI.Acceleration a "absolute acceleration of component";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.06, width = 0.7, height = 0.63), Documentation(info = "<html>
// <p>
// Sliding mass with <i>inertia, without friction</i> and two rigidly connected flanges.
// </p>
// <p>
// The sliding mass has the length L, the position coordinate s is in the middle.
// Sign convention: A positive force at flange flange_a moves the sliding mass in the positive direction.
// A negative force at flange flange_a moves the sliding mass to the negative direction.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Shaft)</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -100,0; -55,0], style(color = 58)), Line(points = [55,0;100,0], style(color = 58)), Rectangle(extent = [ -55, -30;56,30], style(color = 0, gradient = 3, fillColor = 7, fillPattern = 1)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Line(points = [ -100,0; -55,0], style(color = 58)), Line(points = [55,0;100,0], style(color = 58)), Rectangle(extent = [ -55, -30;55,30], style(color = 0, gradient = 3, fillColor = 7, fillPattern = 1)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Line(points = [ -100, -29; -100, -61], style(color = 0)), Line(points = [100, -61;100, -28], style(color = 0)), Line(points = [ -98, -60;98, -60], style(color = 0)), Polygon(points = [ -101, -60; -96, -59; -96, -61; -101, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [100, -60;95, -61;95, -59;100, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -44, -41;51, -57], string = "Length L"), Line(points = [0,30;0,53], style(color = 0)), Line(points = [ -72,40;1,40], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [ -7,42; -7,38; -1,40; -7,42], style(color = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -61,53; -9,42], string = "Position s")));
// 
//       equation 
//         v = der(s);
//         a = der(v);
//         m * a = flange_a.f + flange_b.f;
//       end SlidingMass;
//       model Stop "Sliding mass with hard stop and Stribeck friction"
//         extends Modelica.Mechanics.Translational.Interfaces.FrictionBase(s(stateSelect = StateSelect.always));
//         Modelica.SIunits.Velocity v(stateSelect = StateSelect.always) "Absolute velocity of flange_a and flange_b";
//         Modelica.SIunits.Acceleration a "Absolute acceleration of flange_a and flange_b";
//         parameter Modelica.SIunits.Mass m = 1 "mass";
//         parameter Real F_prop(final unit = "N/ (m/s)", final min = 0) = 1 "velocity dependent friction";
//         parameter Modelica.SIunits.Force F_Coulomb = 5 "constant friction: Coulomb force";
//         parameter Modelica.SIunits.Force F_Stribeck = 10 "Stribeck effect";
//         parameter Real fexp(final unit = "1/ (m/s)", final min = 0) = 2 "exponential decay";
//         annotation(Documentation(info = "
// <HTML>
// <P>This element describes the <i>Stribeck friction characteristics</i> of a sliding mass,
// i. e. the frictional force acting between the sliding mass and the support. Included is a
// <i>hard stop</i> for the position. <BR>
// The surface is fixed and there is friction between sliding mass and surface.
// The frictional force f is given for positive velocity v by:</P>
// <i><uL>
// f = F_Coulomb + F_prop * v + F_Stribeck * exp (-fexp * v)</i> </ul><br>
// 
// 
// <IMG SRC=../Images/Stribeck.png>
// <br><br>
// The distance between the left and the right connector is given by parameter L.
// The position of the center of gravity, coordinate s, is in the middle between
// the two flanges. </p>
// <p>
// There are hard stops at smax and smin, i. e. if <i><uL>
// flange_a.s &gt;= smin
// <ul>    and </ul>
// flange_b.s &lt;= xmax </ul></i>
// the sliding mass can move freely.</p>
// 
// <p>When the absolute velocity becomes zero, the sliding mass becomes stuck, i.e., the absolute position remains constant. In this phase the
// friction force is calculated from a force balance due to the requirement that the
// absolute acceleration shall be zero. The elements begin to slide when the friction
// force exceeds a threshold value, called the maximum static friction force, computed via: </P>
// 
// <i><uL>
// 
//    maximum_static_friction =  F_Coulomb + F_Stribeck
// </i> </ul>
// 
// 
// <font color=\"#ff0000\"> <b>This requires the states Stop.s and Stop.v</b> </font>. If these states are eliminated during the index reduction
// the model will not work. To avoid this any inertias should be connected via springs
// to the Stop element, other sliding masses, dampers or hydraulic chambers must be avoided. </p>
// 
// <p>For more details of the used friction model see the following reference: <br> <br>
// Beater P. (1999): <DD><a href=\"http://www.springer.de/cgi-bin/search_book.pl?isbn=3-540-65444-5\">
// Entwurf hydraulischer Maschinen</a>. Springer Verlag Berlin Heidelberg New York.</DL></P>
// 
// <P>The friction model is implemented in a \"clean\" way by state events and leads to
// continuous/discrete systems of equations which have to be solved by appropriate
// numerical methods. The method is described in: </P>
// <DL>
// Otter M., Elmqvist H., and Mattsson S.E. (1999):
// <i><DD>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</i>. CACSD'99, Aug. 22.-26, Hawaii. </DD>
// </DL>
// 
// <P>More precise friction models take into account the elasticity of the material when
// the two elements are \"stuck\", as well as other effects, like hysteresis. This has
// the advantage that the friction element can be completely described by a differential
// equation without events. The drawback is that the system becomes stiff (about 10-20 times
// slower simulation) and that more material constants have to be supplied which requires more
// sophisticated identification. For more details, see the following references, especially
// (Armstrong and Canudas de Witt 1996): </P>
// <DL>
// Armstrong B. (1991):
// <i><DD>Control of Machines with Friction</i>. Kluwer Academic Press, Boston MA.<BR>
// </DD>
// <DT>Armstrong B., and Canudas de Wit C. (1996): </DT>
// <i><DD>Friction Modeling and Compensation.</i> The Control Handbook, edited by W.S.Levine, CRC Press, pp. 1369-1382.<BR>
// </DD>
// <DT>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995): </DT>
// <i><DD>A new model for control of systems with friction.</i> IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<BR>
// </DD>
// </DL>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from December 7, 1999 by P. Beater (based on Rotational.BearingFriction)</i> </li>
// <li><i>July 14, 2001 by P. Beater, assert on initialization added, diagram modified </i> </li>
// <li><i>October 11, 2001, by Hans Olsson, Dynasim, modified assert to handle start at stops,
// modified event logic such if you have friction parameters equal to zero you do not get events
// between the stops.</i> </li>
// <li><i>June 10, 2002 by P. Beater, StateSelect.always for variables s and v (instead of fixed=true). </i> </li>
// </ul>
// </HTML>
// "), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.45, y = 0.01, width = 0.56, height = 0.83), Icon(Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Rectangle(extent = [ -30,30;35, -35], style(color = 0, gradient = 3, fillColor = 7, fillPattern = 1)), Line(points = [ -90,0; -30,0], style(color = 58)), Rectangle(extent = [ -70, -45;74, -60], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -63, -15; -55, -45], style(color = 0, arrow = 1, fillColor = 0, fillPattern = 1)), Rectangle(extent = [60, -16;69, -45], style(color = 0, arrow = 1, fillColor = 0, fillPattern = 1)), Line(points = [29,0;90,0], style(color = 58)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Rectangle(extent = [ -30,26;35, -9], style(color = 0, gradient = 3, fillColor = 7, fillPattern = 1)), Line(points = [ -90,0; -30,0], style(color = 58)), Line(points = [35,0;90,0], style(color = 58)), Rectangle(extent = [ -68, -14;76, -29], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -119,43; -111,17], style(color = 0, arrow = 1, fillColor = 0, fillPattern = 1)), Line(points = [ -111,43; -111,50], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -151,49; -113,49], style(color = 0, pattern = 1, thickness = 1, arrow = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -149,51; -126,60], string = "s min"), Polygon(points = [ -121,52; -111,49; -121,46; -121,52], style(color = 0, fillColor = 0)), Rectangle(extent = [124,42;132,17], style(color = 0, arrow = 1, fillColor = 0, fillPattern = 1)), Line(points = [124,39;124,87], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -19,78;121,78], style(color = 0, pattern = 1, thickness = 1, arrow = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -17,83;6,92], string = "s max"), Polygon(points = [114,81;124,78;114,75;114,81], style(color = 0, fillColor = 0)), Line(points = [5,26;5,63], style(color = 0, pattern = 1, thickness = 1, arrow = 0)), Line(points = [ -77,58; -1,58], style(color = 0, pattern = 1, thickness = 1, arrow = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -75,60; -38,71], string = "Position s"), Polygon(points = [ -5,61;5,58; -5,55; -5,61], style(color = 0, fillColor = 0)), Line(points = [ -100, -10; -100, -60], style(color = 0)), Line(points = [100, -10;100, -60], style(color = 0)), Polygon(points = [90, -47;100, -50;90, -53;90, -47], style(color = 0, fillColor = 0)), Polygon(points = [ -90, -47; -90, -53; -100, -50; -90, -47], style(color = 0, fillColor = 0)), Line(points = [ -90, -50;92, -50], style(color = 0)), Text(extent = [ -11, -46;26, -36], string = "Length L")));
// 
//       equation 
//         f0 = F_Coulomb + F_Stribeck;
//         f0_max = f0 * 1.001;
//         free = f0 <= 0 and F_prop <= 0 and s > smin + L / 2 and s < smax - L / 2;
//         v = der(s);
//         a = der(v);
//         v_relfric = v;
//         a_relfric = a;
//         0 = flange_a.f + flange_b.f - f - m * der(v);
//         f = if locked then sa else if free then 0 else if startForward then F_prop * v + F_Coulomb + F_Stribeck else if startBackward then F_prop * v - F_Coulomb - F_Stribeck else if pre(mode) == Forward then F_prop * v + F_Coulomb + F_Stribeck * exp( -fexp * abs(v)) else F_prop * v - F_Coulomb - F_Stribeck * exp( -fexp * abs(v));
//       algorithm 
//         when initial() then
//                   assert(s > smin + L / 2 or s >= smin + L / 2 and v >= 0, "Error in initialization of hard stop. (s - L/2) must be >= smin ");
//           assert(s < smax - L / 2 or s <= smax - L / 2 and v <= 0, "Error in initialization of hard stop. (s + L/2) must be <= smax ");
//         
//         end when;
//         when not s < smax - L / 2 then
//                   reinit(s, smax - L / 2);
//           if not initial() or v > 0 then 
//                     reinit(v, 0);
// 
//           else 
//           end if;
//         
//         end when;
//         when not s > smin + L / 2 then
//                   reinit(s, smin + L / 2);
//           if not initial() or v < 0 then 
//                     reinit(v, 0);
// 
//           else 
//           end if;
//         
//         end when;
//       end Stop;
//       model Rod "Rod without inertia"
//         extends Interfaces.Rigid;
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.06, width = 0.7, height = 0.63), Documentation(info = "<html>
// <p>
// Rod <i>without inertia</i> and two rigidly connected flanges.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -100,0; -55,0], style(color = 58)), Line(points = [55,0;100,0], style(color = 58)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Rectangle(extent = [ -55,10;53, -10], style(color = 9, fillColor = 8, fillPattern = 1)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Line(points = [ -100,0; -55,0], style(color = 58)), Line(points = [55,0;100,0], style(color = 58)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Rectangle(extent = [ -55,3;53, -4], style(color = 9, fillColor = 8, fillPattern = 1)), Line(points = [ -100, -29; -100, -61], style(color = 0)), Line(points = [100, -61;100, -28], style(color = 0)), Line(points = [ -98, -60;98, -60], style(color = 0)), Polygon(points = [ -101, -60; -96, -59; -96, -61; -101, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [100, -60;95, -61;95, -59;100, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Text(extent = [ -44, -41;51, -57], string = "Length L")));
// 
//       equation 
//         0 = flange_a.f + flange_b.f;
//       end Rod;
//       model Spring "Linear 1D translational spring"
//         extends Interfaces.Compliant;
//         parameter SI.Distance s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant ";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.21, y = 0.12, width = 0.56, height = 0.64), Documentation(info = "<html>
// <p>
// A <i>linear 1D translational spring</i>. The component can be connected either
// between two sliding masses, or between
// a sliding mass and the housing (model Fixed), to describe
// a coupling of the slidin mass with the housing via a spring.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Spring)</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Text(extent = [0,110;0,50], string = "%name"), Line(points = [ -86,0; -60,0; -44, -30; -16,30;14, -30;44,30;60,0;84,0], style(color = 0))), Diagram(Line(points = [ -100,0; -100,65], style(color = 10)), Line(points = [100,0;100,65], style(color = 10)), Line(points = [ -100,60;100,60], style(color = 10)), Polygon(points = [90,63;100,60;90,57;90,63], style(color = 10, fillColor = 10)), Text(extent = [ -22,62;18,87], string = "s_rel", style(color = 3)), Line(points = [ -86,0; -60,0; -44, -30; -16,30;14, -30;44,30;60,0;84,0], style(color = 0))));
// 
//       equation 
//         f = c * (s_rel - s_rel0);
//       end Spring;
//       model Damper "Linear 1D translational damper"
//         extends Interfaces.Compliant;
//         parameter Real d(final unit = "N/ (m/s)", final min = 0) = 0 "damping constant [N/ (m/s)]";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.05, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// <i>Linear, velocity dependent damper</i> element. It can be either connected
// between a sliding mass and the housing (model Fixed), or
// between two sliding masses.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Damper)</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -90,0; -60,0], style(color = 0)), Line(points = [ -60, -30; -60,30], style(color = 0)), Line(points = [ -60, -30;60, -30], style(color = 0)), Line(points = [ -60,30;60,30], style(color = 0)), Rectangle(extent = [ -60,30;30, -30], style(color = 0, fillColor = 8)), Line(points = [30,0;90,0], style(color = 0)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Text(extent = [0,106;0,46], string = "%name")), Diagram(Line(points = [ -90,0; -60,0], style(color = 0)), Line(points = [ -60, -30; -60,30], style(color = 0)), Line(points = [ -60, -30;60, -30], style(color = 0)), Line(points = [ -60,30;60,30], style(color = 0)), Rectangle(extent = [ -60,30;30, -30], style(color = 0, fillColor = 8)), Line(points = [30,0;90,0], style(color = 0)), Line(points = [ -50,60;50,60], style(color = 10)), Polygon(points = [50,63;60,60;50,57;50,63], style(color = 10, fillColor = 10)), Text(extent = [ -40,68;38,90], string = "der(s_rel)", style(color = 10))));
// 
//       equation 
//         v_rel = der(s_rel);
//         f = d * v_rel;
//       end Damper;
//       model SpringDamper "Linear 1D translational spring and damper in parallel"
//         extends Interfaces.Compliant;
//         parameter SI.Position s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant";
//         parameter Real d(final unit = "N/(m/s)", final min = 0) = 1 "damping constant";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.2, y = 0.03, width = 0.64, height = 0.68), Documentation(info = "<html>
// <p>
// A <i>spring and damper element connected in parallel</i>.
// The component can be
// connected either between two sliding masses to describe the elasticity
// and damping, or between a sliding mass and the housing (model Fixed),
// to describe a coupling of the sliding mass with the housing via a spring/damper.
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.SpringDamper)</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -80,40; -60,40; -45,10; -15,70;15,10;45,70;60,40;80,40], style(color = 0)), Line(points = [ -80,40; -80, -70], style(color = 0)), Line(points = [ -80, -70; -52, -70], style(color = 0)), Rectangle(extent = [ -52, -49;38, -91], style(color = 0, fillColor = 8)), Line(points = [ -52, -49;68, -49], style(color = 0)), Line(points = [ -51, -91;69, -91], style(color = 0)), Line(points = [38, -70;80, -70], style(color = 0)), Line(points = [80,40;80, -70], style(color = 0)), Line(points = [ -90,0; -80,0], style(color = 0)), Line(points = [80,0;90,0], style(color = 0)), Polygon(points = [53, -18;23, -8;23, -28;53, -18], style(color = 10, fillColor = 10)), Line(points = [ -57, -18;23, -18], style(color = 0, fillColor = 10)), Text(extent = [1,140;1,80], string = "%name")), Diagram(Line(points = [ -80,32; -58,32; -43,2; -13,62;17,2;47,62;62,32;80,32], style(color = 0, thickness = 2)), Line(points = [ -100,31; -100,96], style(color = 10)), Line(points = [100,29;100,94], style(color = 10)), Line(points = [ -98,82;100,82], style(color = 10)), Polygon(points = [90,85;100,82;90,79;90,85], style(color = 10, fillColor = 10)), Text(extent = [ -21,61;19,86], string = "s_rel", style(color = 3)), Rectangle(extent = [ -52, -28;38, -72], style(color = 0, fillColor = 8)), Line(points = [ -51, -72;69, -72], style(color = 0)), Line(points = [ -52, -28;68, -28], style(color = 0)), Line(points = [38, -50;80, -50], style(color = 0)), Line(points = [ -80, -50; -52, -50], style(color = 0)), Line(points = [ -80,32; -80, -50], style(color = 0)), Line(points = [80,32;80, -50], style(color = 0)), Line(points = [ -90,0; -80,0], style(color = 0)), Line(points = [90,0;80,0], style(color = 0))));
// 
//       equation 
//         v_rel = der(s_rel);
//         f = c * (s_rel - s_rel0) + d * v_rel;
//       end SpringDamper;
//       model ElastoGap "1D translational spring damper combination with gap"
//         extends Interfaces.Compliant;
//         parameter SI.Position s_rel0 = 0 "unstretched spring length";
//         parameter Real c(final unit = "N/m", final min = 0) = 1 "spring constant";
//         parameter Real d(final unit = "N/ (m/s)", final min = 0) = 1 "damping constant";
//         SI.Velocity v_rel "relative velocity between flange_a and flange_b";
//         Boolean Contact "false, if s_rel > l ";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.04, width = 0.62, height = 0.69), Documentation(info = "<html>
// <p>
// A <i>linear translational spring damper combination that can lift off</i>.
// The component can be connected
// between
// a sliding mass and the housing (model Fixed), to describe
// the contact of a sliding mass with the housing.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Diagram(Line(points = [ -100,0; -50,0], style(color = 58)), Line(points = [ -48,34; -48, -46], style(color = 0, thickness = 4)), Line(points = [8,40;8,2], style(color = 0)), Line(points = [ -2,0;38,0;38,44; -2,44], style(color = 0)), Line(points = [38,22;72,22], style(color = 0)), Line(points = [ -12, -38; -12,20], style(color = 0, thickness = 4)), Line(points = [ -12,22;8,22], style(color = 0)), Line(points = [ -12, -38; -2, -38], style(color = 0)), Line(points = [72,0;90,0], style(color = 58)), Line(points = [72,22;72, -42], style(color = 0)), Line(points = [ -2, -38;10, -28;22, -48;38, -28;50, -48;64, -28;72, -40], style(color = 0)), Rectangle(extent = [8,44;38,0], style(color = 0, fillColor = 8, fillPattern = 1)), Text(extent = [ -28, -80;12, -55], string = "s_rel", style(color = 3)), Line(points = [ -100, -29; -100, -61], style(color = 0)), Line(points = [100, -61;100, -28], style(color = 0)), Line(points = [ -98, -60;98, -60], style(color = 0)), Polygon(points = [ -101, -60; -96, -59; -96, -61; -101, -60], style(color = 0, fillColor = 0, fillPattern = 1)), Polygon(points = [100, -60;95, -61;95, -59;100, -60], style(color = 0, fillColor = 0, fillPattern = 1))), Icon(Line(points = [ -100,0; -50,0], style(color = 58)), Line(points = [ -48,34; -48, -46], style(color = 0, thickness = 4)), Line(points = [8,40;8,2], style(color = 0)), Line(points = [ -2,0;38,0;38,44; -2,44], style(color = 0)), Line(points = [38,22;72,22], style(color = 0)), Line(points = [ -12, -38; -12,20], style(color = 0, thickness = 4)), Line(points = [ -12,22;8,22], style(color = 0)), Line(points = [ -12, -38; -2, -38], style(color = 0)), Line(points = [74,0;100,0], style(color = 58)), Line(points = [72,22;72, -42], style(color = 0)), Line(points = [ -2, -38;10, -28;22, -48;38, -28;50, -48;64, -28;72, -40], style(color = 0)), Rectangle(extent = [8,44;38,0], style(color = 0, fillColor = 8, fillPattern = 1)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Text(extent = [0,120;0,60], string = "%name")));
// 
//       equation 
//         v_rel = der(s_rel);
//         Contact = s_rel < s_rel0;
//         f = if Contact then c * (s_rel - s_rel0) + d * v_rel else 0;
//       end ElastoGap;
//       model Position "Forced movement of a flange according to a reference position"
//         parameter Boolean exact = false "true/false exact treatment/filtering the input signal";
//         parameter SI.Frequency f_crit = 50 "if exact=false, critical frequency of filter to filter input signal";
//         output SI.Position s_ref "reference position defined with the input signal";
//         output SI.Position s "absolute position of flange_b";
//         output SI.Velocity v "absolute velocity of flange_b";
//         output SI.Acceleration a "absolute acceleration of flange_b";
//       protected 
//         parameter Real w_crit = 2 * Modelica.Constants.pi * f_crit "critical frequency in [1/s]";
//         constant Real af = 1.3617 "s coefficient of Bessel filter";
//         constant Real bf = 0.618 "s*s coefficient of Bessel filter";
//       public 
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Flange position as input signal" annotation(extent = [ -140, -20; -100,20]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.33, y = 0.01, width = 0.66, height = 0.62), Documentation(info = "<HTML>
// <p>
// The input signal inPort.signal[1] defines the <b>reference
// position</b> <b>s_ref</b> in [m]. Flange <b>flange_b</b> is <b>forced</b>
// to move according to this reference motion. According to parameter
// <b>exact</b> (default = <b>false</b>), this is done in the following way:
// <ol>
// <li><b>exact=true</b><br>
//     The reference position is treated <b>exactly</b>. This is only possible, if
//     the input signal is defined by an analytical function which can be
//     differentiated at least twice. If this prerequisite is fulfilled,
//     the Modelica translator will differentiate the input signal twice
//     in order to compute the reference acceleration of the flange.</li>
// <li><b>exact=false</b><br>
//     The reference position is <b>filtered</b> and the second derivative
//     of the filtered curve is used to compute the reference acceleration
//     of the flange. This second derivative is <b>not</b> computed by
//     numerical differentiation but by an appropriate realization of the
//     filter. For filtering, a second order Bessel filter is used.
//     The critical frequency (also called cut-off frequency) of the
//     filter is defined via parameter <b>f_crit</b> in [Hz]. This value
//     should be selected in such a way that it is higher as the essential
//     low frequencies in the signal.</li>
// </ol>
// 
// <p>
// The input signal can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>.<br>
//        Realized.</li>
// </ul>
// 
// </HTML>
// "), Icon(Text(extent = [ -80, -20; -80, -80], string = "s", style(color = 0)), Line(points = [ -95,0;90,0], style(color = 58)), Text(extent = [0,86;0,26], string = "%name")), Diagram(Polygon(points = [46, -90;26, -85;26, -95;46, -90], style(color = 10, fillColor = 10)), Line(points = [ -44, -90;27, -90], style(color = 10, fillColor = 10))));
// 
//       equation 
//         s_ref = inPort.signal[1];
//         s = flange_b.s;
//         v = der(s);
//         a = der(v);
//         if exact then
//           s = s_ref;
// 
//         else
//           a = ((s_ref - s) * w_crit - af * v) * w_crit / bf;
// 
//         end if;
// 
//       initial equation 
// if not exact then
//                   s = s_ref;
//         end if;
//       end Position;
//       model Accelerate "Forced movement of a flange according to an acceleration signal"
//         parameter SI.Position s_start = 0 "Start position";
//         parameter SI.Velocity v_start = 0 "Start velocity";
//         SI.Acceleration a "absolute acceleration of flange_b";
//         SI.Velocity v(final start = v_start, final fixed = true) "absolute velocity of flange_b";
//         SI.Position s(final start = s_start, final fixed = true) "absolute position of flange_b";
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Connector of input signal used as force" annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.23, y = 0.07, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// The input signal \"a\"  in [m/s2] of connector \"i\" moves the 1D translational flange
// connector flange_b with a predefined <i>acceleration</i>, i.e., the flange
// is <i>forced</i> to move with this acceleration. The velocity and the
// position of the flange are also predefined and are determined by
// integration of the acceleration.
// </p>
// 
// <p>
// The acceleration \"a(t)\" can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Source.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.AccMotion)</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -95,0;90,0], style(color = 58)), Text(extent = [ -80, -20; -80, -80], string = "a", style(color = 0)), Text(extent = [0,80;0,20], string = "%name")), Diagram(Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10))));
// 
//       equation 
//         s = flange_b.s;
//         v = der(s);
//         a = der(v);
//         a = inPort.signal[1];
//       end Accelerate;
//       model Move "Forced movement of a flange according to a position, velocity and acceleration signal"
//         SI.Position s "absolute position of flange_b";
//         SI.Velocity v "absolute velocity of flange_b";
//         SI.Acceleration a "absolute acceleration of flange_b";
//       protected 
//         Real constraintResidue;
//         Real constraintResidue_d;
//         Real constraintResidue_dd;
//       public 
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 3) annotation(extent = [ -140, -20; -100,20]);
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Documentation(info = "<html>
// <p>
// Flange <b>flange_b</b> is <b>forced</b> to move with a predefined motion
// according to the input signals:
// </p>
// 
// <pre>
//     inPort.signal[1]: position of flange
//     inPort.signal[2]: velocity of flange
//     inPort.signal[3]: acceleration of flange
// </pre>
// 
// <p>
// The user has to guarantee that the input signals are consistent to each other,
// i.e., that inPort.signal[2] is the derivative of inPort.signal[1] and that
// inPort.signal[3] is the derivative of inPort.signal[2]. There are, however,
// also applications where by purpose these conditions do not hold. For example,
// if only the position dependent terms of a mechanical system shall be
// calculated, one may provide position = position(t) and set the velocity
// and the acceleration to zero.
// </p>
// 
// <p>
// The input signals can be provided from one of the signal generator
// blocks of the block library Modelica.Blocks.Sources.
// </p>
// 
// <p>
// Note, this model utilizes the non-standard function <b>constrain(..)</b>
// and assumes that this function is supported by the Modelica translator:
// </p>
// <pre>
//    Real r[:], rd[:], rdd[:];
//       ...
//    r   = ..
//    rd  = ...
//    rdd = ...
//    constrain(r,rd,rdd);
// </pre>
// <p>
// where r, rd and rdd are variables which need to be computed
// somewhere else. A simple implementation of constrain() is:
// </p>
// 
// <pre>
//    r = 0;
// </pre>
// 
// <p>
// However, this implementation requires that r(t) is given as analytical,
// smooth function in order that it can be differentiated and it does
// not allow applications such as the one sketched above.
// Function constrain()
// is used to explicitly inform the Modelica translator that
// rd is the derivative of r and rdd is the derivative of rd
// and that all derivatives need to be identical to zero.
// The Modelica translator can utilize this information to use
// rd and rdd whenever the Pantelides algorithm requires to compute
// the derivatives of r (and takes rd and rdd instead of actually
// differentiating r).
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 25, 2001</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        realized.</li>
// </ul>
// 
// </HTML>
// "), Diagram(Polygon(points = [0, -90; -20, -85; -20, -95;0, -90], style(color = 10, fillColor = 10)), Line(points = [ -90, -90; -19, -90], style(color = 10, fillColor = 10))), Icon(Text(extent = [ -140, -62;20, -100], string = "phi,w,a", style(color = 0)), Line(points = [ -95,0;90,0], style(color = 58)), Text(extent = [0,80;0,20], string = "%name")), Window(x = 0.27, y = 0.05, width = 0.6, height = 0.6));
// 
//       equation 
//         s = flange_b.s;
//         v = der(s);
//         a = der(v);
//         constraintResidue = inPort.signal[1] - s;
//         constraintResidue_d = inPort.signal[2] - v;
//         constraintResidue_dd = inPort.signal[3] - a;
//         constrain(constraintResidue, constraintResidue_d, constraintResidue_dd);
//       end Move;
//       model Fixed "Fixed flange"
//         parameter SI.Position s0 = 0 "fixed offset position of housing";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.41, y = 0.02, width = 0.42, height = 0.58), Icon(Line(points = [ -80, -40;80, -40], style(color = 0)), Line(points = [80, -40;40, -80], style(color = 0)), Line(points = [40, -40;0, -80], style(color = 0)), Line(points = [0, -40; -40, -80], style(color = 0)), Line(points = [ -40, -40; -80, -80], style(color = 0)), Line(points = [0, -40;0, -10], style(color = 0)), Text(extent = [0, -90;0, -150], string = "%name")), Diagram(Line(points = [ -80, -40;80, -40], style(color = 0)), Line(points = [80, -40;40, -80], style(color = 0)), Line(points = [40, -40;0, -80], style(color = 0)), Line(points = [0, -40; -40, -80], style(color = 0)), Line(points = [ -40, -40; -80, -80], style(color = 0)), Line(points = [0, -40;0, -10], style(color = 0)), Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10))), Documentation(info = "<html>
// <p>
// The <i>flange</i> of a 1D translational mechanical system <i>fixed</i>
// at an position s0 in the <i>housing</i>. May be used:
// </p>
// 
// <ul>
// <li> to connect a compliant element, such as a spring or a damper,
//      between a sliding mass and the housing.
// 
// <li> to fix a rigid element, such as a sliding mass, at a specific
//      position.
// </ul>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.LockedR)</i> </li>
// </ul>
// </HTML>
// "));
//         Interfaces.Flange_b flange_b annotation(extent = [ -10, -10;10,10], rotation = 180);
// 
//       equation 
//         flange_b.s = s0;
//       end Fixed;
//       model Force "External force acting on a drive train element as input signal"
//         SI.Force f "driving force";
//         Interfaces.Flange_b flange_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.InPort inPort(final n = 1) "Connector of input signal used as force" annotation(extent = [ -140, -20; -100,20]);
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.05, y = 0.01, width = 0.69, height = 0.83), Documentation(info = "<html>
// <p>
// The input signal \"s\" in [N] characterizes an <i>external
// force</i> which acts (with positive sign) at a flange,
// i.e., the component connected to the flange is driven by force f.
// </p>
// 
// 
// <p>
// Input signal s can be provided from one of the signal generator
// blocks of Modelica.Blocks.Source.
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater (based on Rotational.Torque1D)</i> </li>
// </ul>
// </HTML>
// "), Icon(Polygon(points = [ -100,10;20,10;20,41;90,0;20, -41;20, -10; -100, -10; -100,10], style(color = 10, fillColor = 58)), Text(extent = [ -100, -40; -47, -88], string = "f", style(color = 0)), Text(extent = [0,109;0,49], string = "%name")), Diagram(Polygon(points = [50, -90;20, -80;20, -100;50, -90], style(color = 10, fillColor = 10)), Line(points = [ -60, -90;20, -90], style(color = 0, fillColor = 10)), Polygon(points = [ -100,10;20,10;20,41;90,0;20, -41;20, -10; -100, -10; -100,10], style(color = 10, fillColor = 58))));
// 
//       equation 
//         f = inPort.signal[1];
//         flange_b.f =  -f;
//       end Force;
//       model RelativeStates "Definition of relative state variables"
//         extends Interfaces.TwoFlanges;
//         SI.Position s_rel(stateSelect = StateSelect.prefer) "relative position used as state variable";
//         SI.Velocity v_rel(stateSelect = StateSelect.prefer) "relative velocity used as state variable";
//         SI.Acceleration a_rel "relative angular acceleration";
//         annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Window(x = 0.23, y = 0.02, width = 0.72, height = 0.83), Documentation(info = "<html>
// <p>
// Usually, the absolute position and the absolute velocity of
// Modelica.Mechanics.Translational.Inertia models are used as state variables.
// In some circumstances, relative quantities are better suited, e.g.,
// because it may be easier to supply initial values.
// In such cases, model <b>RelativeStates</b> allows the definition of state variables
// in the following way:
// </p>
// 
// <ul>
// <li> Connect an instance of this model between two flange connectors.</li>
// <li> The <b>relative position</b> and the <b>relative velocity</b>
//      between the two connectors are used as <b>state variables</b>.
// </ul>
// 
// <p>
// An example is given in the next figure
// </p>
// 
// <IMG SRC=\"../Images/relativeStates2.png\" ALT=\"relativeStates2\">
// 
// <p>
// Here, the relative position and the relative velocity between
// the two masses are used as state variables. Additionally, the
// simulator selects either the absolute position and absolute
// velocity of model mass1 or of model mass2 as state variables.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>June 19, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.
// </li>
// </ul>
// </HTML>
// "), Icon(Ellipse(extent = [ -40,40;40, -40], style(color = 4, fillColor = 4)), Text(extent = [ -40,40;40, -40], string = "S"), Line(points = [ -92,0; -42,0], style(color = 0, pattern = 3)), Line(points = [40,0;90,0], style(color = 0, pattern = 3, fillColor = 4)), Text(extent = [0,110;0,50], string = "%name")), Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 4, fillColor = 4)), Text(extent = [ -40,40;40, -40], string = "S"), Line(points = [40,0;90,0], style(color = 0, pattern = 2, fillColor = 4)), Line(points = [ -100, -10; -100, -80], style(color = 9)), Line(points = [100, -10;100, -80], style(color = 9)), Polygon(points = [80, -65;80, -55;100, -60;80, -65], style(color = 9, fillColor = 9, fillPattern = 1)), Line(points = [ -100, -60;80, -60], style(color = 9)), Text(extent = [ -30, -70;30, -90], string = "w_rel"), Line(points = [ -76,80; -5,80], style(color = 10, fillColor = 10)), Polygon(points = [14,80; -6,85; -6,75;14,80], style(color = 10, fillColor = 10)), Text(extent = [18,87;86,74], string = "rotation axis", style(color = 10)), Line(points = [ -90,0; -40,0], style(color = 0, pattern = 2, fillColor = 4))));
// 
//       equation 
//         s_rel = flange_b.s - flange_a.s;
//         v_rel = der(s_rel);
//         a_rel = der(v_rel);
//         flange_a.f = 0;
//         flange_b.f = 0;
//       end RelativeStates;
//       package Sensors "Sensor for 1D translational mechanical quantities"
//         extends Modelica.Icons.Library2;
//         annotation(Window(x = 0.08, y = 0.16, width = 0.23, height = 0.39, library = 1, autolayout = 1), Icon(Rectangle(extent = [ -76, -81;64, -1], style(color = 0, fillColor = 7)), Polygon(points = [ -6, -61; -16, -37;4, -37; -6, -61], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [ -6, -21; -6, -37], style(color = 0)), Line(points = [ -76, -21; -6, -21], style(color = 0)), Line(points = [ -56, -61; -56, -81], style(color = 0)), Line(points = [ -36, -61; -36, -81], style(color = 0)), Line(points = [ -16, -61; -16, -81], style(color = 0)), Line(points = [4, -61;4, -81], style(color = 0)), Line(points = [24, -61;24, -81], style(color = 0)), Line(points = [44, -61;44, -81], style(color = 0))));
//         model ForceSensor "Ideal sensor to measure the force between two flanges"
//           extends Interfaces.RelativeSensor;
//           SI.Force f "force in flange_a and flange_b (f = flange_a.f = -flange_b.f)";
//           annotation(Documentation(info = "<html>
// <p>
// Measures the <i>cut-force between two flanges</i> in an ideal way
// and provides the result as output signal (to be further processed
// with blocks of the Modelica.Blocks library).
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Icon(Text(extent = [40, -70;120, -120], string = "f", style(color = 0))), Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.27, y = 0.08, width = 0.6, height = 0.6));
// 
//         equation 
//           flange_a.s = flange_b.s;
//           flange_a.f = f;
//           flange_b.f =  -f;
//           f = outPort.signal[1];
//         end ForceSensor;
//         model PositionSensor "Ideal sensor to measure the absolute position"
//           extends Modelica.Icons.TranslationalSensor;
//           SI.Position s "Absolute position of flange";
//           Interfaces.Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.04, y = 0.05, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// Measures the <i>absolute position s</i> of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70.4,0;100,0]), Text(extent = [80, -28;114, -62], string = "s", style(color = 0)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Line(points = [100,0;70,0]), Line(points = [ -70,0; -92,0], style(color = 53))));
// 
//         equation 
//           s = flange_a.s;
//           s = outPort.signal[1];
//           0 = flange_a.f;
//         end PositionSensor;
//         model SpeedSensor "Ideal sensor to measure the absolute velocity"
//           extends Modelica.Icons.TranslationalSensor;
//           SI.Position s "Absolute position of flange";
//           SI.Velocity v "Absolute velocity of flange";
//           Interfaces.Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.04, y = 0.05, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// Measures the <i>absolute velocity v</i> of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70.4,0;100,0]), Text(extent = [80, -28;111, -61], string = "v", style(color = 0)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 53)), Line(points = [100,0;70,0], style(color = 0))));
// 
//         equation 
//           s = flange_a.s;
//           v = der(s);
//           v = outPort.signal[1];
//           0 = flange_a.f;
//         end SpeedSensor;
//         model AccSensor "Ideal sensor to measure the absolute acceleration"
//           extends Modelica.Icons.TranslationalSensor;
//           SI.Velocity v "Absolute velocity of flange";
//           SI.Acceleration a "Absolute acceleration of a flange";
//           Interfaces.Flange_a flange_a "(left) flange to be measured (flange axis directed INTO cut plane, e. g. from left to right)" annotation(extent = [ -110, -10; -90,10]);
//           Modelica.Blocks.Interfaces.OutPort outPort(final n = 1) annotation(extent = [100, -10;120,10]);
//           annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Window(x = 0.14, y = 0.08, width = 0.6, height = 0.6), Documentation(info = "<html>
// <p>
// Measures the <i>absolute acceleration a</i>
// of a flange in an ideal way and provides the result as
// output signals (to be further processed with blocks of the
// Modelica.Blocks library).
// </p>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>First Version from August 26, 1999 by P. Beater</i> </li>
// </ul>
// </HTML>
// "), Icon(Line(points = [ -70,0; -90,0], style(color = 0)), Line(points = [70.4,0;100,0]), Text(extent = [80, -28;115, -60], string = "a", style(color = 0)), Text(extent = [0,100;0,40], string = "%name")), Diagram(Line(points = [ -70,0; -90,0], style(color = 53)), Line(points = [100,0;70,0])));
// 
//         equation 
//           v = der(flange_a.s);
//           a = der(v);
//           a = outPort.signal[1];
//           0 = flange_a.f;
//         end AccSensor;
//       end Sensors;
//     end Translational;
//   end Mechanics;
//   package Thermal "Components for thermal systems"
//     import SI = Modelica.SIunits;
//     extends Modelica.Icons.Library;
//     package HeatTransfer "1-dimensional heat transfer with lumped elements"
//       import Modelica.SIunits.Conversions.*;
//       import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//       extends Modelica.Icons.Library2;
//       annotation(Icon(Polygon(points = [ -54, -6; -61, -7; -75, -15; -79, -24; -80, -34; -78, -42; -73, -49; -64, -51; -57, -51; -47, -50; -41, -43; -38, -35; -40, -27; -40, -20; -42, -13; -47, -7; -54, -5; -54, -6], style(color = 10, fillColor = 8)), Polygon(points = [ -75, -15; -79, -25; -80, -34; -78, -42; -72, -49; -64, -51; -57, -51; -47, -50; -57, -47; -65, -45; -71, -40; -74, -33; -76, -23; -75, -15; -75, -15], style(color = 0, fillColor = 9)), Polygon(points = [39, -6;32, -7;18, -15;14, -24;13, -34;15, -42;20, -49;29, -51;36, -51;46, -50;52, -43;55, -35;53, -27;53, -20;51, -13;46, -7;39, -5;39, -6], style(color = 9, fillColor = 8)), Polygon(points = [18, -15;14, -25;13, -34;15, -42;21, -49;29, -51;36, -51;46, -50;36, -47;28, -45;22, -40;19, -33;17, -23;18, -15;18, -15], style(color = 0, fillColor = 9)), Polygon(points = [ -9, -23; -9, -10;18, -17; -9, -23], style(color = 42, fillColor = 42, fillPattern = 1)), Line(points = [ -41, -17; -9, -17], style(color = 42, thickness = 2)), Line(points = [ -17, -40;15, -40], style(color = 42, thickness = 2)), Polygon(points = [ -17, -46; -17, -34; -40, -40; -17, -46], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This package contains components to model <b>1-dimensional heat transfer</b>
// with lumped elements. This allows especially to model heat transfer in
// machines provided the parameters of the lumped elements, such as
// the heat capacity of a part, can be determined by measurements
// (due to the complex geometries and many materials used in machines,
// calculating the lumped element parameters from some basic analytic
// formulas is usually not possible).
// </p>
// 
// <p>
// Example models how to use this library are given in subpackage <b>Examples</b>.
// For a first simple example, see Examples.TwoMasses where two masses
// with different initial temperatures are getting in contact to each
// other and arriving after some time at a common temperature.
// A more realistic example is provided in <b>Examples.Drive</b> where the
// heating of an electrical motor is modelled, see the following screen shot
// of this example:
// </p>
// 
// <img src=\"../Images/driveWithHeatTransfer.png\" ALT=\"driveWithHeatTransfer\">
// 
// <p>
// The <b>filled</b> and <b>non-filled red squares</b> at the left and
// right side of a component represent <b>thermal ports</b> (connector HeatPort).
// Drawing a line between such squares means that they are thermally connected.
// The variables of a HeatPort connector are the temperature <b>T</b> at the port
// and the heat flow rate <b>Q_dot</b> flowing into the component (if Q_dot is positive,
// the heat flows into the element, otherwise it flows out of the element):
// </p>
// 
// <pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
//    Modelica.SIunits.HeatFlowRate Q_dot  \"flow rate at the port in Watt\";
// </pre>
// 
// <p>
// Note, that all temperatures of this package, including initial conditions,
// are given in Kelvin. For convenience, in subpackages <b>HeatTransfer.Celsius</b>,
//  <b>HeatTransfer.Fahrenheit</b> and <b>HeatTransfer.Rankine</b> components are provided such that source and
// sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
// respectively. Additionally, in package <b>SIunits.Conversions</b> conversion
// functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
// provided. These functions may be used in the following way:
// </p>
// 
// <pre>  <b>import</b> SI=Modelica.SIunits;
//   <b>import</b> Modelica.SIunits.Conversions.*;
//      ...
//   <b>parameter</b> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
// </pre>
// 
// <p>
// This package contains the following model components:
// </p>
// 
// <pre>   <b>Examples</b>               (subpackage) Examples of library usage.
//    <b>Interfaces</b>             (subpackage) Interface definitions.
// 
//    <b>HeatCapacitor</b>          Lumped thermal element storing heat.
//    <b>ThermalConductor</b>       Lumped thermal element transporting heat without
//                           storing it.
//    <b>Convection</b>             Lumped thermal element for heat convection.
//    <b>BodyRadiation</b>          Lumped thermal element for radiation heat transfer
//                           between two bodies
// 
//    <b>FixedTemperature</b>       Fixed temperature boundary condition.
//    <b>PrescribedTemperature</b>  Variable temperature boundary condition
//    <b>FixedHeatFlow</b>          Fixed heat flow boundary condition.
//    <b>PrescribedHeatFlow</b>     Variable heat flow boundary condition.
// 
//    <b>TemperatureSensor</b>      Absolute temperature sensor.
//    <b>RelTemperatureSensor</b>   Relative temperature sensor.
//    <b>HeatFlowSensor</b>         Sensor to determine the heat flow rate
//                           between two ports.
// 
//    <b>Celsius</b>                (subpackage) Elements with Celsius interface.
//    <b>Fahrenheit</b>             (subpackage) Elements with Fahrenheit interface.
//    <b>Rankine</b>                (subpackage) Elements with Rankine interface.
// </pre>
// 
// <p>
// There are several other components available, such as AxialConduction (discretized PDE in
// axial direction), which have been temporarily removed from this library. The reason is that
// these components reference material properties, such as thermal conductivity, and currently
// the Modelica design group is discussing a general scheme to describe material properties.
// </p>
// 
// <p>
// For technical details in the design of this library, see the following reference:<br>
// <b>Michael Tiller (2001)</b>: <a href=\"http://www.amazon.de\">
// Introduction to Physical Modeling with Modelica</a>.
// Kluwer Academic Publishers Boston.
// </p>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>July 15, 2002</i>
//        by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Nikolaus.Schuermann/\">Nikolaus Sch&uuml;rmann</a>:<br>
//        Implemented.
// </li>
// </ul>
// 
// <p>
// <b>Acknowledgements:</b><br>
// Several helpful remarks from the following persons are acknowledged:
// John Batteh, Ford Motors, Dearborn, U.S.A;
// <a href=\"http://www.haumer.at/\">Anton Haumer</a>, Technical Consulting & Electrical Engineering, Austria;
// Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
// Hans Olsson, Dynasim AB, Sweden;
// Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
// </p>
// 
// <p><b>Copyright &copy; 2001-2002, Modelica Association, Michael Tiller and DLR.</b></p>
// 
// <p><i>
// The Modelica package is free software; it can be redistributed and/or modified
// under the terms of the Modelica license, see the license conditions
// and the accompanying disclaimer in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//       package Examples "Example models to demonstrate the usage of package Modelica.Thermal.HeatTransfer"
//         extends Modelica.Icons.Library;
//         encapsulated model TwoMasses "Simple conduction demo"
//           import Modelica.Icons;
//           import Modelica.Thermal.HeatTransfer;
//           import SI = Modelica.SIunits;
//           import Modelica.SIunits.Conversions.*;
//           import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//           extends Icons.Example;
//           parameter SI.Temperature T_final_K(fixed = false) "Projected final temperature";
//           parameter NonSI.Temperature_degC T_final_degC(fixed = false) "Projected final temperature";
//           HeatTransfer.HeatCapacitor mass1(C = 15, T(start = from_degC(100))) annotation(extent = [ -100,20; -40,80]);
//           HeatTransfer.HeatCapacitor mass2(C = 15, T(start = from_degC(0))) annotation(extent = [40,20;100,80]);
//           HeatTransfer.ThermalConductor conduction(G = 10) annotation(extent = [ -30, -20;30,40]);
//           annotation(Documentation(info = "<HTML>
// <p>
// This example demonstrates the thermal response of two masses connected by
// a conducting element. The two masses have the same heat capacity but different
// initial temperatures (T1=100 [degC], T2= 0 [degC]). The mass with the higher
// temperature will cool off while the mass with the lower temperature heats up.
// They will each asymptotically approach the calculated temperature <b>T_final_K</b>
// (<b>T_final_degC</b>) that results from dividing the total initial energy in the system by the sum
// of the heat capacities of each element.
// </p>
// 
// <p>
// Simulate for 5 s and plot the variables<br>
// mass1.T, mass2.T, T_final_K or <br>
// Tsensor1.T.signal, Tsensor2.T.signal, T_final_degC
// </p>
// 
// </HTML>
// "));
//           HeatTransfer.Celsius.TemperatureSensor Tsensor1 annotation(extent = [ -60, -80; -20, -40]);
//           HeatTransfer.Celsius.TemperatureSensor Tsensor2 annotation(extent = [60, -80;20, -40]);
// 
//         equation 
//           connect(mass1.port,conduction.port_a) annotation(points = [ -70,20; -70,10; -30,10], style(color = 42));
//           connect(conduction.port_b,mass2.port) annotation(points = [33,10;70,10;70,20], style(color = 42));
//           connect(mass1.port,Tsensor1.port) annotation(points = [ -70,20; -70, -60; -62, -60], style(color = 42));
//           connect(mass2.port,Tsensor2.port) annotation(points = [70,20;70, -60;60, -60], style(color = 42));
// 
//         initial equation 
//           T_final_K = (mass1.port.T * mass1.C + mass2.port.T * mass2.C) / (mass1.C + mass2.C);
//           T_final_degC = to_degC(T_final_K);
//         end TwoMasses;
//         encapsulated model FrequencyInverter "First order thermal model of a frequency inverter"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Thermal.HeatTransfer;
//           import SI = Modelica.SIunits;
//           import Modelica.SIunits.Conversions.*;
//           extends Icons.Example;
//           annotation(Documentation(info = "<HTML>
// <p>
// This example contains a simple first order thermal model of
// a frequency inverter. The periodic power losses in the
// frequency inverter are described by two tables.
// \"conductionTable\" describes the convection conduction G
// and \"lossTable\" the generated power loss P_loss dependent
// on the time.</p>
// 
// <p>
// The power dissipation to the environment is approximated by
// heat flow through a thermal conductance, partially storage
// of the heat in a heat capacitor and finally by forced
// convection to the environment, defined in the two tables.
// </p>
// 
// <p>
// Simulate for 5 s and plot the heat flow rate and the
// temperature in the frequency inverter.
// </p>
// </HTML>
// "));
//           Sources.TimeTable conductionTable(table = [0,0.007;1,0.014;2,0.007;3,0.014;4,0.007;5,0.014]) annotation(extent = [20,60;40,80]);
//           Sources.TimeTable lossTable(table = [0,10000;1,7000;2,10000;3,7000;4,10000;5,7000]) annotation(extent = [ -100, -20; -80,0]);
//           HeatTransfer.HeatCapacitor C(C = 30000) annotation(extent = [10,20;30,40]);
//           HeatTransfer.Celsius.TemperatureSensor Tsensor annotation(extent = [ -10, -60;10, -40]);
//           HeatTransfer.ThermalConductor G(G = 50) annotation(extent = [ -10, -20;10,0]);
//           HeatTransfer.Convection convection annotation(extent = [40, -20;60,0]);
//           HeatTransfer.PrescribedHeatFlow Q_dot annotation(extent = [ -60, -20; -40,0]);
//           HeatTransfer.Celsius.FixedTemperature environment(T = 20) annotation(extent = [80, -20;100,0], rotation = 180);
// 
//         equation 
//           connect(Q_dot.port,G.port_a) annotation(points = [ -40, -10; -11, -10], style(color = 42));
//           connect(Q_dot.port,Tsensor.port) annotation(points = [ -40, -10; -20, -10; -20, -50; -10, -50], style(color = 42));
//           connect(G.port_b,convection.solid) annotation(points = [11, -10;39, -10], style(color = 42));
//           connect(C.port,G.port_b) annotation(points = [20,20;20, -10;11, -10], style(color = 42));
//           connect(environment.port,convection.fluid) annotation(points = [80, -10;61, -10], style(color = 42));
//           connect(lossTable.outPort,Q_dot.Q_dot) annotation(points = [ -78, -10; -62, -10], style(color = 3));
//           connect(conductionTable.outPort,convection.G) annotation(points = [42,70;50,70;50,2], style(color = 3));
//         end FrequencyInverter;
//         encapsulated model ControlledTemperature "Control temperature of a resistor"
//           import Modelica.Icons;
//           import Modelica.Blocks.Sources;
//           import Modelica.Electrical.Analog;
//           import Modelica.Thermal.HeatTransfer;
//           import SI = Modelica.SIunits;
//           import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//           import Modelica.SIunits.Conversions.*;
//           extends Icons.Example;
//           parameter NonSI.Temperature_degC TAmb = 20 "Ambient Temperature";
//           parameter NonSI.Temperature_degC TDif = 2 "Error in Temperature";
//           output NonSI.Temperature_degC TRes "Resulting Temperature";
//           annotation(Documentation(info = "<HTML>
// <P>
// A constant voltage of 10 V is applied to a
// temperature dependent resistor of 10*(1+(T-20C)/(235+20C)) Ohms,
// whose losses v**2/r are dissipated via a
// thermal conductance of 0.1 W/K to ambient temperature 20 degree C.
// The resistor is assumed to have a thermal capacity of 1 J/K,
// having ambient temparature at the beginning of the experiment.
// The temperature of this heating resistor is held by an OnOff-controller
// at reference temperature within a given bandwith +/- 1 K
// by switching on and off the voltage source.
// The reference temperature starts at 25 degree C
// and rises between t = 2 and 8 seconds linear to 50 degree C.
// An approppriate simulating time would be 10 seconds.
// </P>
// </HTML>
// "));
//           Analog.Basic.Ground Ground1 annotation(extent = [ -100, -100; -80, -80]);
//           Analog.Sources.ConstantVoltage ConstantVoltage1(V = 10) annotation(extent = [ -100, -60; -80, -40], rotation =  -90);
//           HeatTransfer.HeatCapacitor HeatCapacitor1(C = 1, T(start = from_degC(TAmb))) annotation(extent = [0, -60;20, -80]);
//           Analog.Basic.HeatingResistor HeatingResistor1(R_ref = 10, T_ref = from_degC(20), alpha = 1 / (235 + 20)) annotation(extent = [ -20, -60; -40, -40], rotation =  -90);
//           HeatTransfer.Celsius.FixedTemperature FixedTemperature1(T = TAmb) annotation(extent = [100, -60;80, -40]);
//           HeatTransfer.Celsius.TemperatureSensor TemperatureSensor1 annotation(extent = [0, -40;20, -20], rotation = 90);
//           HeatTransfer.ThermalConductor ThermalConductor1(G = 0.1) annotation(extent = [40, -60;60, -40]);
//           SwitchController SwitchController1(bandwidth = TDif) annotation(extent = [ -20, -20; -40,0]);
//           Analog.Ideal.IdealSwitch IdealSwitch1 annotation(extent = [ -70, -50; -50, -30]);
//           Sources.Ramp Ramp1(height = {25}, duration = {6}, offset = {25}, startTime = {2}) annotation(extent = [20,0;0,20]);
//           encapsulated block SwitchController "On-off controller for use with Modelica.Electrical.Analog.Ideal.IdealSwitch"
//             import Modelica.Blocks;
//             extends Blocks.Interfaces.MI2BooleanMOs(final n = 1);
//             parameter Real bandwidth = 0.1 "Bandwidth around reference signal";
//             annotation(Icon(Rectangle(extent = [ -100, -100;100,100], style(color = 5, fillColor = 7)), Text(extent = [ -90,80; -30,60], string = "Reference", style(thickness = 2)), Text(extent = [ -88, -60; -28, -80], string = "Input        "), Line(points = [ -80,0; -70,20; -52,42; -28,60; -8,66;16,58;32,50;48,38;66,20;78,0], style(thickness = 2)), Line(points = [ -80,30; -8,50;80,20], style(color = 41, thickness = 2)), Line(points = [ -80,38; -8,56;80,26], style(color = 41, pattern = 2)), Line(points = [ -80,24; -8,42;80,12], style(color = 41, pattern = 2)), Line(points = [ -80, -20; -46, -20; -46, -60;68, -60;68, -20;80, -20], style(color = 81, thickness = 2))), Documentation(info = "<html>
// <p>The block SwitchController sets the output signal to false when
// the input signal falls below the reference signal minus half of
// the bandwidth and sets the output signal to true when the input
// signal exceeds the reference signal plus half of the bandwidth.</p>
// 
// <p>The reference signal is represented by inPort1 and the input
// signal by inPort2.</p>
// 
// <p>Note: This component <b>will be removed</b> when package
// ModelicaAdditions.Blocks.Logical is incorporated into the Modelica
// Standard library.</p>
// </html>
// "));
//           protected 
//             Real u = inPort2.signal[1] "Input signal";
//             Real uRef = inPort1.signal[1] "Reference input signal";
//             Boolean y = outPort.signal[1] "Output signal";
// 
//           equation 
//             y = u > uRef + bandwidth / 2 or pre(y) and not u < uRef - bandwidth / 2;
//           end SwitchController;
// 
//         equation 
//           connect(ConstantVoltage1.n,HeatingResistor1.n) annotation(points = [ -90, -60; -30, -60], style(color = 3));
//           connect(ConstantVoltage1.n,Ground1.p) annotation(points = [ -90, -60; -90, -80], style(color = 3));
//           connect(HeatingResistor1.heatPort,ThermalConductor1.port_a) annotation(points = [ -20, -50;38, -50], style(color = 42));
//           connect(ThermalConductor1.port_b,FixedTemperature1.port) annotation(points = [61, -50;80, -50], style(color = 42));
//           connect(HeatingResistor1.heatPort,TemperatureSensor1.port) annotation(points = [ -20, -50;10, -50;10, -40], style(color = 42));
//           connect(HeatingResistor1.heatPort,HeatCapacitor1.port) annotation(points = [ -20, -50;10, -50;10, -60], style(color = 42));
//           connect(TemperatureSensor1.T,SwitchController1.inPort2) annotation(points = [10, -20;10, -16; -16, -16], style(color = 3));
//           connect(ConstantVoltage1.p,IdealSwitch1.p) annotation(points = [ -90, -40; -70, -40], style(color = 3));
//           connect(IdealSwitch1.n,HeatingResistor1.p) annotation(points = [ -50, -40; -30, -40], style(color = 3));
//           connect(SwitchController1.inPort1,Ramp1.outPort) annotation(points = [ -16, -4; -9, -4; -9,10; -2,10], style(color = 3));
//           connect(SwitchController1.outPort,IdealSwitch1.control) annotation(points = [ -42, -10; -60, -10; -60, -34], style(color = 5));
//           TRes = to_degC(HeatingResistor1.heatPort.T);
//         end ControlledTemperature;
//       end Examples;
//       package Interfaces
//         extends Modelica.Icons.Library;
//         partial connector HeatPort "Thermal port for 1-dim. heat transfer"
//           SI.Temperature T "Port temperature";
//           flow SI.HeatFlowRate Q_dot "Heat flow rate (positive if flowing from outside into the component)";
//         end HeatPort;
//         connector HeatPort_a "Thermal port for 1-dim. heat transfer (filled rectangular icon)"
//           extends HeatPort;
//           annotation(Documentation(info = "<HTML>
// <p>This connector is used for 1-dimensional heat flow between components.
// The variables in the connector are:</p>
// 
// <pre>   T       Temperature in [Kelvin].
//    Q_dot   Heat flow rate in [Watt].
// </pre>
// 
// <p>According to the Modelica sign convention, a <b>positive</b> heat flow
// rate <b>Q_dot</b> is considered to flow <b>into</b> a component. This
// convention has to be used whenever this connector is used in a model
// class.</p>
// 
// <p>Note, that the two connector classes <b>HeatPort_a</b> and
// <b>HeatPort_b</b> are identical with the only exception of the different
// <b>icon layout</b>.</p></HTML>
// "), Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 42, fillColor = 42)), Text(extent = [ -98,196;102,102], string = "%name", style(color = 42))), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 42, fillColor = 42)), Text(extent = [ -98,196;102,102], string = "%name", style(color = 42))));
//         end HeatPort_a;
//         connector HeatPort_b "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"
//           extends HeatPort;
//           annotation(Documentation(info = "<HTML>
// <p>This connector is used for 1-dimensional heat flow between components.
// The variables in the connector are:</p>
// 
// <pre>   T       Temperature in [Kelvin].
//    Q_dot   Heat flow rate in [Watt].
// </pre>
// 
// <p>According to the Modelica sign convention, a <b>positive</b> heat flow
// rate <b>Q_dot</b> is considered to flow <b>into</b> a component. This
// convention has to be used whenever this connector is used in a model
// class.</p>
// 
// <p>Note, that the two connector classes <b>HeatPort_a</b> and
// <b>HeatPort_b</b> are identical with the only exception of the different
// <b>icon layout</b>.</p></HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 42, fillColor = 7)), Text(extent = [ -98,196;102,102], string = "%name", style(color = 42))), Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 42, fillColor = 7)), Text(extent = [ -98,196;102,102], string = "%name", style(color = 42))));
//         end HeatPort_b;
//         partial model Element1D "Partial heat transfer element with two HeatPort connectors that does not store energy"
//           SI.HeatFlowRate Q_dot "Heat flow rate from port_a -> port_b";
//           SI.Temperature dT "port_a.T - port_b.T";
//         public 
//           HeatPort_a port_a annotation(extent = [ -120, -10; -100,10]);
//           HeatPort_b port_b annotation(extent = [100, -10;120,10]);
//           annotation(Documentation(info = "<HTML>
// <p>
// This partial model contains the basic connectors and variables to
// allow heat transfer models to be created that <b>do not store energy</b>,
// This model defines and includes equations for the temperature
// drop across the element, <b>dT</b>, and the heat flow rate
// through the element from port_a to port_b, <b>Q_dot</b>.
// </p>
// 
// <p>
// By extending this model, it is possible to write simple
// constitutive equations for many types of heat transfer components.
// </p>
// 
// </HTML>
// "), Icon);
// 
//         equation 
//           dT = port_a.T - port_b.T;
//           port_a.Q_dot = Q_dot;
//           port_b.Q_dot =  -Q_dot;
//         end Element1D;
//       end Interfaces;
//       model HeatCapacitor "Lumped thermal element storing heat"
//         parameter SI.HeatCapacity C "Heat capacity of part (= cp*m)";
//         parameter Boolean steadyStateStart = false "true, if component shall start in steady state";
//         SI.Temperature T(start = from_degC(25)) "Temperature of part";
//         annotation(Icon(Text(extent = [ -129,121;131,70], string = "%name"), Polygon(points = [0,65; -20,61; -40,55; -52,41; -58,33; -68,23; -72,11; -76, -3; -78, -17; -76, -33; -76, -45; -76, -55; -70, -67; -64, -75; -48, -79; -30, -85; -18, -85; -2, -87;8, -91;22, -91;32, -89;42, -83;54, -77;56, -75;66, -63;68, -55;70, -53;72, -37;76, -23;78, -15;78,1;74,13;66,23;54,31;44,39;36,55;26,63;0,65], style(color = 9, fillColor = 8)), Polygon(points = [ -58,33; -68,23; -72,11; -76, -3; -78, -17; -76, -33; -76, -45; -76, -55; -70, -67; -64, -75; -48, -79; -30, -85; -18, -85; -2, -87;8, -91;22, -91;32, -89;42, -83;54, -77;42, -79;40, -79;30, -81;20, -83;18, -83;10, -83;2, -79; -12, -75; -22, -75; -30, -73; -40, -67; -50, -57; -56, -45; -58, -37; -58, -27; -60, -15; -60, -7; -60,5; -58,15; -56,17; -52,25; -48,33; -44,43; -40,55; -58,33], style(color = 0, fillColor = 9)), Text(extent = [ -69,5;71, -26], string = "%C", style(color = 0))), Diagram(Polygon(points = [0,65; -20,61; -40,55; -52,41; -58,33; -68,23; -72,11; -76, -3; -78, -17; -76, -33; -76, -45; -76, -55; -70, -67; -64, -75; -48, -79; -30, -85; -18, -85; -2, -87;8, -91;22, -91;32, -89;42, -83;54, -77;56, -75;66, -63;68, -55;70, -53;72, -37;76, -23;78, -15;78,1;74,13;66,23;54,31;44,39;36,55;26,63;0,65], style(color = 9, fillColor = 8)), Polygon(points = [ -58,33; -68,23; -72,11; -76, -3; -78, -17; -76, -33; -76, -45; -76, -55; -70, -67; -64, -75; -48, -79; -30, -85; -18, -85; -2, -87;8, -91;22, -91;32, -89;42, -83;54, -77;42, -79;40, -79;30, -81;20, -83;18, -83;10, -83;2, -79; -12, -75; -22, -75; -30, -73; -40, -67; -50, -57; -56, -45; -58, -37; -58, -27; -60, -15; -60, -7; -60,5; -58,15; -56,17; -52,25; -48,33; -44,43; -40,55; -58,33], style(color = 0, fillColor = 9)), Line(points = [ -1, -90; -1, -8], style(color = 41)), Ellipse(extent = [ -6, -3;4, -13], style(color = 41, fillColor = 42)), Text(extent = [11,11;50, -27], string = "T", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This is a generic model for the heat capacity of a material.
// No specific geometry is assumed beyond a total volume with
// uniform temperature for the entire volume.
// Furthermore, it is assumed that the heat capacity
// is constant (indepedent of temperature).
// </p>
// 
// <p>
// The temperature T [Kelvin] of this component is a <b>state</b>.
// A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
// is used as start value for initialization.
// This usually means that at start of integration the temperature of this
// component is 25 degrees Celsius. You may, of course, define a different
// temperature as start value for initialization. Alternatively, it is possible
// to set parameter <b>steadyStateStart</b> to <b>true</b>. In this case
// the additional equation '<b>der</b>(T) = 0' is used during
// initialization, i.e., the temperature T is computed in such a way that
// the component starts in <b>steady state</b>. This is useful in cases,
// where one would like to start simulation in a suitable operating
// point without being forced to integrate for a long time to arrive
// at this point.
// </p>
// 
// <p>
// Note, that parameter <b>steadyStateStart</b> is not available in
// the parameter menue of the simulation window, because its value
// is utilized during translation to generate quite different
// equations depending on its setting. Therefore, the value of this
// parameter can only be changed before translating the model.
// </p>
// 
// <p>
// This component may be used for complicated geometries where
// the heat capacity C is determined my measurements. If the component
// consists mainly of one type of material, the <b>mass m</b> of the
// component may be measured or calculated and multiplied with the
// <b>specific heat capacity cp</b> of the component material to
// compute C:
// </p>
// 
// <pre>
//    C = cp*m.
// 
//    Typical values for cp at 20 degC in J/(kg.K):
// 
//       aluminium   896
//       concrete    840
//       copper      383
//       iron        452
//       silver      235
//       steel       420 ... 500 (V2A)
//       wood       2500
// </pre>
// 
// </HTML>
// "));
//         Interfaces.HeatPort_a port annotation(extent = [ -10, -110;10, -90], rotation = 90);
// 
//       equation 
//         T = port.T;
//         C * der(T) = port.Q_dot;
// 
//       initial equation 
// if steadyStateStart then
//                   der(T) = 0;
//         end if;
//       end HeatCapacitor;
//       model ThermalConductor "Lumped thermal element transporting heat without storing it"
//         extends Interfaces.Element1D;
//         parameter SI.ThermalConductance G "Constant thermal conductance of material";
//         annotation(Icon(Rectangle(extent = [ -100,70;100, -70], style(color = 0, pattern = 0, fillColor = 8, fillPattern = 8)), Line(points = [ -100,70; -100, -70], style(color = 0, thickness = 2)), Line(points = [100,70;100, -70], style(color = 0, thickness = 2)), Text(extent = [ -139,134;141,74], string = "%name"), Text(extent = [ -115, -76;113, -116], string = "G=%G", style(color = 0))), Diagram(Line(points = [ -80,0;80,0], style(color = 41, thickness = 2, arrow = 1)), Text(extent = [ -26, -10;27, -39], string = "Q_dot", style(color = 41)), Text(extent = [ -80,50;80,20], string = "dT = port_a.T - port_b.T", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This is a model for transport of heat without storing it.
// It may be used for complicated geometries where
// the thermal conductance G (= inverse of thermal resistance)
// is determined by measurements and is assumed to be constant
// over the range of operations. If the component consists mainly of
// one type of material and a regular geometry, it may be calculated,
// e.g., with one of the following equations:
// </p>
// 
// <ul>
// <li><p>
//     Conductance for a <b>box</b> geometry under the assumption
//     that heat flows along the box length:</p>
//     <pre>
//     G = k*A/L
// 
//     k: Thermal conductivity (material constant)
//     A: Area of box
//     L: Length of box
//     </pre>
//     </li>
// 
// <li><p>
//     Conductance for a <b>cylindrical</b> geometry under the assumption
//     that heat flows from the inside to the outside radius
//     of the cylinder:</p>
//     <pre>
//     G = 2*pi*k*L/log(r_out/r_in)
// 
//     pi   : Modelica.Constants.pi
//     k    : Thermal conductivity (material constant)
//     L    : Length of cylinder
//     log  : Modelica.Math.log;
//     r_out: Outer radius of cylinder
//     r_in : Inner radius of cylinder
//     </pre>
//     </li>
// 
// </li>
// </ul>
// 
// <pre>
//     Typical values for k at 20 degC in W/(m.K):
// 
//       aluminium   220
//       concrete      1
//       copper      384
//       iron         74
//       silver      407
//       steel        45 .. 15 (V2A)
//       wood         0.1 ... 0.2
// </pre>
// 
// </HTML>
// "));
// 
//       equation 
//         Q_dot = G * dT;
//       end ThermalConductor;
//       model Convection "Lumped thermal element for heat convection"
//         SI.ThermalConductance Gc "Convective thermal conductance of element";
//         SI.HeatFlowRate Q_dot "Heat flow rate from solid -> fluid";
//         SI.Temperature dT "= solid.T - fluid.T";
//         annotation(Icon(Rectangle(extent = [ -70,80;99, -80], style(color = 7, fillColor = 7)), Rectangle(extent = [ -100,80; -70, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Text(extent = [ -117, -88;124, -128], string = "%name"), Line(points = [ -40,80; -40, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [34,80;34, -80], style(color = 69, fillColor = 47)), Line(points = [34, -80;44, -60], style(color = 69, fillColor = 47)), Line(points = [34, -80;24, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80;10, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80; -10, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -30, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -50, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;60, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;80, -60], style(color = 69, fillColor = 47)), Line(points = [70,80;70, -80], style(color = 69, fillColor = 47)), Line(points = [100,0;100,0], style(color = 69, fillColor = 47)), Line(points = [100,80;100, -80], style(color = 69, fillColor = 47)), Line(points = [100, -80;90, -60], style(color = 69, fillColor = 47)), Line(points = [100, -80;110, -60], style(color = 69, fillColor = 47)), Line(points = [80,30;100,20], style(color = 42, fillColor = 45)), Line(points = [80,10;100,20], style(color = 42, fillColor = 45)), Line(points = [ -59,20;100,20], style(color = 42, fillColor = 45)), Line(points = [ -60, -20;100, -20], style(color = 42, fillColor = 45)), Line(points = [80, -10;100, -20], style(color = 42, fillColor = 45)), Line(points = [80, -30;100, -20], style(color = 42, fillColor = 45))), Documentation(info = "<HTML>
// <p>
// This is a model of linear heat convection, e.g., the heat transfer
// between a plate and the surrounding air. It may be used for complicated
// solid geometries and fluid flow over the solid by determining the
// convective thermal conductance Gc by measurements. The basic constitutive
// equation for convection is
// </p>
// 
// <pre>
//    Q_dot = Gc*(solid.T - fluid.T);
// 
//    Q_dot: Heat flow rate from connector 'solid' (e.g. a plate)
//       to connector 'fluid' (e.g. the surrounding air)
// </pre>
// 
// <p>
// Gc = G.signal[1] is an input signal to the component, since Gc is
// nearly never constant in practice. For example, Gc may be a function
// of the speed of a cooling fan. For simple situations,
// Gc may be <i>calculated</i> according to
// </p>
// 
// <pre>
//    Gc = A*h
// 
//    A: Convection area (e.g. perimeter*length of a box)
//    h: Heat transfer coefficient
// </pre>
// 
// <p>
// where the heat transfer coefficient h is calculated
// from properties of the fluid flowing over the solid. Examples:
// </p>
// 
// <p>
// <b>Machines cooled by air</b> (empirical, very rough approximation according
// to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
// p. 378):
// </p>
// 
// <pre>
//     h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
//       = 12         [W/(m2.K)] (free convection)
// 
//     where
//       v: Air velocity in [m/s]
// </pre>
// 
// 
// <p><b>Laminar</b> flow with constant velocity of a fluid along a
// <b>flat plate</b> where the heat flow rate from the plate
// to the fluid (= solid.Q_dot) is kept constant
// (according to J.P.Holman: Heat Transfer, 8th edition,
// McGraw-Hill, 1997, p.270):
// </p>
// 
// <pre>
//    h  = Nu*k/x;
//    Nu = 0.453*Re^(1/2)*Pr^(1/3);
// 
//    where
//       h  : Heat transfer coefficient
//       Nu : = h*x/k       (Nusselt number)
//       Re : = v*x*rho/mue (Reynolds number)
//       Pr : = cp*mue/k    (Prandtl number)
//       v  : Absolute velocity of fluid
//       x  : distance from leading edge of flat plate
//       rho: density of fluid (material constant
//       mue: dynamic viscosity of fluid (material constant)
//       cp : specific heat capacity of fluid (material constant)
//       k  : thermal conductivity of fluid (material constant)
// 
//    and the equation for h holds, provided
//       Re < 5e5 and 0.6 < Pr < 50
// </pre>
// 
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,80; -70, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Line(points = [ -40,80; -40, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [34,80;34, -80], style(color = 69, fillColor = 47)), Line(points = [34, -80;44, -60], style(color = 69, fillColor = 47)), Line(points = [34, -80;24, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80;10, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80; -10, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -30, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -50, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;60, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;80, -60], style(color = 69, fillColor = 47)), Line(points = [70,80;70, -80], style(color = 69, fillColor = 47)), Line(points = [100,0;100,0], style(color = 69, fillColor = 47)), Line(points = [100,80;100, -80], style(color = 69, fillColor = 47)), Line(points = [100, -80;90, -60], style(color = 69, fillColor = 47)), Line(points = [100, -80;110, -60], style(color = 69, fillColor = 47)), Line(points = [ -40,80; -40, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [34,80;34, -80], style(color = 69, fillColor = 47)), Line(points = [34, -80;44, -60], style(color = 69, fillColor = 47)), Line(points = [34, -80;24, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80;10, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80; -10, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -30, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -50, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;60, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;80, -60], style(color = 69, fillColor = 47)), Line(points = [70,80;70, -80], style(color = 69, fillColor = 47)), Line(points = [100,0;100,0], style(color = 69, fillColor = 47)), Line(points = [100,80;100, -80], style(color = 69, fillColor = 47)), Line(points = [100, -80;90, -60], style(color = 69, fillColor = 47)), Line(points = [100, -80;110, -60], style(color = 69, fillColor = 47)), Line(points = [ -40,80; -40, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [0,80;0, -80], style(color = 69, fillColor = 47)), Line(points = [34,80;34, -80], style(color = 69, fillColor = 47)), Line(points = [34, -80;44, -60], style(color = 69, fillColor = 47)), Line(points = [34, -80;24, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80;10, -60], style(color = 69, fillColor = 47)), Line(points = [0, -80; -10, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -30, -60], style(color = 69, fillColor = 47)), Line(points = [ -40, -80; -50, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;60, -60], style(color = 69, fillColor = 47)), Line(points = [70, -80;80, -60], style(color = 69, fillColor = 47)), Line(points = [70,80;70, -80], style(color = 69, fillColor = 47)), Line(points = [100,0;100,0], style(color = 69, fillColor = 47)), Line(points = [100,80;100, -80], style(color = 69, fillColor = 47)), Line(points = [100, -80;90, -60], style(color = 69, fillColor = 47)), Line(points = [100, -80;110, -60], style(color = 69, fillColor = 47)), Line(points = [ -59,20;100,20], style(color = 42, fillColor = 45)), Line(points = [80,30;100,20], style(color = 42, fillColor = 45)), Line(points = [80,10;100,20], style(color = 42, fillColor = 45)), Line(points = [ -60, -20;100, -20], style(color = 42, fillColor = 45)), Line(points = [80, -10;100, -20], style(color = 42, fillColor = 45)), Line(points = [80, -30;100, -20], style(color = 42, fillColor = 45)), Text(extent = [ -35,42; -5,20], string = "Q_dot", style(color = 41))));
//         Modelica.Blocks.Interfaces.InPort G(final n = 1, redeclare type SignalType = SI.ThermalConductance) "Signal representing the convective thermal conductance in [W/K]" annotation(extent = [ -20,80;20,120], rotation = 270);
//         Interfaces.HeatPort_a solid annotation(extent = [ -120, -10; -100,10]);
//         Interfaces.HeatPort_b fluid annotation(extent = [100, -10;120,10]);
// 
//       equation 
//         Gc = G.signal[1];
//         dT = solid.T - fluid.T;
//         solid.Q_dot = Q_dot;
//         fluid.Q_dot =  -Q_dot;
//         Q_dot = Gc * dT;
//       end Convection;
//       model BodyRadiation "Lumped thermal element for radiation heat transfer"
//         extends Interfaces.Element1D;
//         parameter Real Gr(unit = "m2") "Net radiation conductance between two surfaces (see docu)";
//         annotation(Icon(Rectangle(extent = [60,80;100, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Rectangle(extent = [ -100,80; -60, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Line(points = [ -40,10;40,10], style(color = 42, fillColor = 45)), Line(points = [ -40,10; -30,16], style(color = 42, fillColor = 45)), Line(points = [ -40,10; -30,4], style(color = 42, fillColor = 45)), Line(points = [ -40, -10;40, -10], style(color = 42, fillColor = 45)), Line(points = [30, -16;40, -10], style(color = 42, fillColor = 45)), Line(points = [30, -4;40, -10], style(color = 42, fillColor = 45)), Line(points = [ -40, -30;40, -30], style(color = 42, fillColor = 45)), Line(points = [ -40, -30; -30, -24], style(color = 42, fillColor = 45)), Line(points = [ -40, -30; -30, -36], style(color = 42, fillColor = 45)), Line(points = [ -40,30;40,30], style(color = 42, fillColor = 45)), Line(points = [30,24;40,30], style(color = 42, fillColor = 45)), Line(points = [30,36;40,30], style(color = 42, fillColor = 45)), Text(extent = [ -132,144;108,84], string = "%name"), Text(extent = [ -119, -86;117, -125], string = "G=%G", style(color = 0)), Rectangle(extent = [ -60,80; -54, -80], style(color = 42, fillColor = 42)), Rectangle(extent = [55,80;60, -80], style(color = 42, fillColor = 42))), Documentation(info = "<HTML>
// <p>
// This is a model describing the thermal radiation, i.e., electromagnetic
// radiation emitted between two bodies as a result of their temperatures.
// The following constitutive equation is used:
// </p>
// 
// <pre>
//     Q_dot = Gr*sigma*(port_a.T^4 - port_b.T^4);
// </pre>
// 
// <p>
// where Gr is the radiation conductance and sigma is the Stefan-Boltzmann
// constant (= Modelica.Constants.sigma). Gr may be determined by
// measurements and is assumed to be constant over the range of operations.
// </p>
// 
// <p>
// For simple cases, Gr may be analytically computed. The analytical
// equations use epsilon, the emission value of a body which is in the
// range 0..1. Epsilon=1, if the body absorbs all radiation (= black body).
// Epsilon=0, if the body reflects all radiation and does not absorb any.
// </p>
// 
// <pre>
//    Typical values for epsilon:
// 
//    aluminium, polished    0.04
//    copper, polished       0.04
//    gold, polished         0.02
//    paper                  0.09
//    rubber                 0.95
//    silver, polished       0.02
//    wood                   0.85..0.9
// </pre>
// 
// <p><b>Analytical Equations for Gr</b></p>
// 
// <p>
// <b>Small convex object in large enclosure</b>
// (e.g., a hot machine in a room):
// </p>
// 
// <pre>
//     Gr = e*A
// 
//     where
//        e: Emission value of object (0..1)
//        A: Surface area of object where radiation
//           heat transfer takes place
// </pre>
// 
// 
// <p><b>Two parallel plates</b>:</p>
// 
// <pre>
//     Gr = A/(1/e1 + 1/e2 - 1)
// 
//     where
//        e1: Emission value of plate1 (0..1)
//        e2: Emission value of plate2 (0..1)
//        A : Area of plate1 (= area of plate2)
// </pre>
// 
// 
// 
// <p><b>Two long cylinders in each other</b>, where radiation takes
// place from the inner to the outer cylinder):
// </p>
// 
// <pre>
//     Gr = 2*pi*r1*L/(1/e1 + (1/e2 - 1)*(r1/r2))
// 
//     where
//        pi: = Modelica.Constants.pi
//        r1: Radius of inner cylinder
//        r2: Radius of outer cylinder
//        L : Length of the two cylinders
//        e1: Emission value of inner cylinder (0..1)
//        e2: Emission value of outer cylinder (0..1)
// </pre>
// 
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,80; -66, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Line(points = [ -66,80; -66, -80], style(color = 0, thickness = 4)), Line(points = [60,80;60, -80], style(color = 0, thickness = 4)), Rectangle(extent = [60,80;100, -80], style(color = 0, fillColor = 8, fillPattern = 8)), Line(points = [ -40,10;40,10], style(color = 42, fillColor = 45)), Line(points = [ -40,10; -30,16], style(color = 42, fillColor = 45)), Line(points = [ -40,10; -30,4], style(color = 42, fillColor = 45)), Line(points = [ -40, -10;40, -10], style(color = 42, fillColor = 45)), Line(points = [30, -16;40, -10], style(color = 42, fillColor = 45)), Line(points = [30, -4;40, -10], style(color = 42, fillColor = 45)), Line(points = [ -40, -30;40, -30], style(color = 42, fillColor = 45)), Line(points = [ -40, -30; -30, -24], style(color = 42, fillColor = 45)), Line(points = [ -40, -30; -30, -36], style(color = 42, fillColor = 45)), Line(points = [ -40,30;40,30], style(color = 42, fillColor = 45)), Line(points = [30,24;40,30], style(color = 42, fillColor = 45)), Line(points = [30,36;40,30], style(color = 42, fillColor = 45))));
// 
//       equation 
//         Q_dot = Gr * Modelica.Constants.sigma * (port_a.T ^ 4 - port_b.T ^ 4);
//       end BodyRadiation;
//       model FixedTemperature "Fixed temperature boundary condition in Kelvin"
//         parameter SI.Temperature T "Fixed temperature at port";
//         annotation(Icon(Text(extent = [ -121,162;119,102], string = "%name"), Text(extent = [ -121, -105;119, -151], string = "T=%T", style(color = 0)), Rectangle(extent = [ -100,100;101, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Text(extent = [0,4; -100, -96], string = "K", style(color = 0)), Line(points = [ -42,0;66,0], style(color = 42, thickness = 2)), Polygon(points = [60, -20;60,20;100,0;60, -20], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in Kelvin,
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -101], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -42,0;66,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "K", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//         Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
// 
//       equation 
//         port.T = T;
//       end FixedTemperature;
//       model PrescribedTemperature "Variable temperature boundary condition in Kelvin"
//         annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "K", style(color = 0)), Polygon(points = [62, -20;62,20;99,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [ -125,162;115,102], string = "%name")), Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition.
// The temperature in [K] is given as input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Text(extent = [0,0; -100, -100], string = "K", style(color = 0)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//         Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
//         Modelica.Blocks.Interfaces.InPort T(final n = 1, redeclare type SignalType = SI.Temperature) annotation(extent = [ -140, -20; -100,20]);
// 
//       equation 
//         port.T = T.signal[1];
//       end PrescribedTemperature;
//       model FixedHeatFlow "Fixed heat flow boundary condition"
//         parameter SI.HeatFlowRate Q_dot "Fixed heat flow rate at port";
//         annotation(Icon(Text(extent = [ -134,120;132,60], string = "%name"), Text(extent = [ -137, -52;133, -100], string = "Q_dot=%Q_dot", style(color = 0)), Line(points = [ -100, -20;48, -20], style(color = 42, thickness = 2)), Line(points = [ -100,20;46,20], style(color = 42, thickness = 2)), Polygon(points = [40,0;40,40;70,20;40,0], style(color = 42, fillColor = 42, fillPattern = 1)), Polygon(points = [40, -40;40,0;70, -20;40, -40], style(color = 42, fillColor = 42, fillPattern = 1)), Rectangle(extent = [70,40;90, -40], style(color = 42, fillColor = 42))), Diagram(Text(extent = [ -100,40;0, -36], string = "Q_dot=const.", style(color = 0)), Line(points = [ -48, -20;60, -20], style(color = 42, thickness = 2)), Line(points = [ -48,20;60,20], style(color = 42, thickness = 2)), Polygon(points = [60,0;60,40;90,20;60,0], style(color = 42, fillColor = 42, fillPattern = 1)), Polygon(points = [60, -40;60,0;90, -20;60, -40], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This model allows a specified amount of heat flow rate to be \"injected\"
// into a thermal system at a given port.  The constant amount of heat
// flow rate Q_dot is given as a parameter. The heat flows into the
// component to which the component FixedHeatFlow is connected,
// if parameter Q_dot is positive.
// </p>
// </HTML>
// "));
//         Interfaces.HeatPort_b port annotation(extent = [90, -10;110,10]);
// 
//       equation 
//         port.Q_dot =  -Q_dot;
//       end FixedHeatFlow;
//       model PrescribedHeatFlow "Prescribed heat flow boundary condition"
//         annotation(Icon(Line(points = [ -60, -20;40, -20], style(color = 42, thickness = 2)), Line(points = [ -60,20;40,20], style(color = 42, thickness = 2)), Line(points = [ -80,0; -60, -20], style(color = 42, thickness = 2)), Line(points = [ -80,0; -60,20], style(color = 42, thickness = 2)), Polygon(points = [40,0;40,40;70,20;40,0], style(color = 42, fillColor = 42, fillPattern = 1)), Polygon(points = [40, -40;40,0;70, -20;40, -40], style(color = 42, fillColor = 42, fillPattern = 1)), Rectangle(extent = [70,40;90, -40], style(color = 42, fillColor = 42)), Text(extent = [ -134,120;132,60], string = "%name")), Documentation(info = "<HTML>
// <p>
// This model allows a specified amount of heat flow rate to be \"injected\"
// into a thermal system at a given port.  The amount of heat
// is given by the input signal into the model. The heat flows into the
// component to which the component PrescribedHeatFlow is connected,
// if the input signal is positive.
// </p>
// </HTML>
// "), Diagram(Line(points = [ -60, -20;68, -20], style(color = 42, thickness = 2)), Line(points = [ -60,20;68,20], style(color = 42, thickness = 2)), Line(points = [ -80,0; -60, -20], style(color = 42, thickness = 2)), Line(points = [ -80,0; -60,20], style(color = 42, thickness = 2)), Polygon(points = [60,0;60,40;90,20;60,0], style(color = 42, fillColor = 42, fillPattern = 1)), Polygon(points = [60, -40;60,0;90, -20;60, -40], style(color = 42, fillColor = 42, fillPattern = 1))));
//         Modelica.Blocks.Interfaces.InPort Q_dot(final n = 1) annotation(extent = [ -80, -20; -120,20], rotation = 180);
//         Interfaces.HeatPort_b port annotation(extent = [90, -10;110,10]);
// 
//       equation 
//         port.Q_dot =  -Q_dot.signal[1];
//       end PrescribedHeatFlow;
//       model TemperatureSensor "Absolute temperature sensor in Kelvin"
//         annotation(Diagram(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -94,0; -14,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [102, -28;60, -78], string = "K", style(color = 0))), Icon(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -90,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [126, -20;26, -120], string = "K", style(color = 0)), Text(extent = [ -132,144;108,84], string = "%name")), Documentation(info = "<HTML>
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Kelvin as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "));
//         Modelica.Blocks.Interfaces.OutPort T(redeclare type SignalType = SI.Temperature) annotation(extent = [90, -10;110,10]);
//         Interfaces.HeatPort_a port annotation(extent = [ -110, -10; -90,10]);
// 
//       equation 
//         T.signal[1] = port.T;
//         port.Q_dot = 0;
//       end TemperatureSensor;
//       model RelTemperatureSensor "Relative Temperature sensor"
//         extends Modelica.Icons.TranslationalSensor;
//         annotation(Icon(Line(points = [ -90,0; -70,0; -70,0], style(color = 42)), Line(points = [ -90,0; -70,0; -70,0], style(color = 42)), Line(points = [70,0;90,0;90,0], style(color = 42)), Line(points = [0, -30;0, -80]), Text(extent = [ -140,94;144,34], string = "%name"), Text(extent = [92, -62;34, -122], string = "K", style(color = 0))), Diagram(Line(points = [ -90,0; -70,0; -70,0], style(color = 42)), Line(points = [ -98,0; -70,0; -70,0], style(color = 42)), Line(points = [70,0;90,0;90,0], style(color = 42)), Line(points = [0, -30;0, -80]), Text(extent = [64, -74;32, -102], string = "K", style(color = 0))), Documentation(info = "<HTML>
// <p>
// The relative temperature \"port_a.T - port_b.T\" is determined between
// the two ports of this component and is provided as output signal in Kelvin.
// </p>
// </HTML>
// "));
//         Interfaces.HeatPort_a port_a annotation(extent = [ -110, -10; -90,10]);
//         Interfaces.HeatPort_b port_b annotation(extent = [90, -10;110,10]);
//         Modelica.Blocks.Interfaces.OutPort T_rel(redeclare type SignalType = SI.Temperature) annotation(extent = [ -10, -80;10, -100], rotation = 90);
// 
//       equation 
//         T_rel.signal[1] = port_a.T - port_b.T;
//         0 = port_a.Q_dot;
//         0 = port_b.Q_dot;
//       end RelTemperatureSensor;
//       model HeatFlowSensor "Heat flow rate sensor"
//         extends Modelica.Icons.RotationalSensor;
//         output SI.HeatFlowRate Q_dot "Heat flow rate from port_a to port_b";
//         Modelica.Blocks.Interfaces.OutPort heat(redeclare type SignalType = SI.HeatFlowRate) "Heat flow from port_a -> port_b" annotation(extent = [ -10, -110;10, -90], rotation = 270);
//         annotation(Diagram(Line(points = [ -70,0; -95,0], style(color = 42)), Line(points = [0, -70;0, -90]), Line(points = [69,0;90,0], style(color = 42))), Icon(Text(extent = [33, -58;88, -116], string = "Q_dot", style(color = 0)), Line(points = [ -70,0; -90,0], style(color = 42)), Line(points = [69,0;90,0], style(color = 42)), Line(points = [0, -70;0, -90]), Text(extent = [ -132,144;108,84], string = "%name")), Documentation(info = "<HTML>
// <p>
// This model is capable of monitoring the heat flow rate flowing through
// this component. The sensed value of heat flow rate is the amount that
// passes through this sensor while keeping the temperature drop across the
// sensor zero.  This is an ideal model so it does not absorb any energy
// and it has no direct effect on the thermal response of a system it is included in.
// The output signal is positive, if the heat flows from port_a
// to port_b.
// </p>
// </HTML>
// "));
//         Interfaces.HeatPort_a port_a annotation(extent = [ -110, -10; -90,10]);
//         Interfaces.HeatPort_b port_b annotation(extent = [90, -10;110,10]);
// 
//       equation 
//         port_a.T = port_b.T;
//         port_a.Q_dot + port_b.Q_dot = 0;
//         Q_dot = port_a.Q_dot;
//         heat.signal[1] = Q_dot;
//       end HeatFlowSensor;
//       package Celsius "Components with Celsius input and/or output"
//         extends Modelica.Icons.Library;
//         model ToKelvin "Conversion block from Celsius to Kelvin"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -40, -50; -99, -99], string = "C", style(color = 0, thickness = 4)), Text(extent = [100, -47;44, -100], string = "K", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [41,0;100,0])), Icon(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [112, -40;32, -120], string = "K", style(color = 0)), Text(extent = [ -31, -39; -111, -119], string = "C", style(color = 0, thickness = 4)), Line(points = [ -41,0; -100,0]), Line(points = [100,0;40,0]), Text(extent = [ -137,99;132,49], string = "%name")), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Celsius to Kelvin
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Celsius(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Kelvin(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Kelvin.signal = from_degC(Celsius.signal);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Celsius"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Icon(Text(extent = [ -137,99;132,49], string = "%name"), Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -34, -42; -114, -122], string = "K", style(color = 0, thickness = 4)), Text(extent = [110, -39;30, -119], string = "C", style(color = 0)), Line(points = [ -40,0; -100,0]), Line(points = [40,0;100,0])), Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -42, -41; -101, -98], string = "K", style(color = 0, thickness = 4)), Text(extent = [100, -40;30, -100], string = "C", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [40,0;100,0])), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Kelvin to Celsius
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Kelvin(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Celsius(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Celsius.signal = to_degC(Kelvin.signal);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in degree Celsius"
//           parameter NonSI.Temperature_degC T "Fixed Temperature at the port";
//           annotation(Icon(Text(extent = [ -118,165;122,105], string = "%name"), Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Text(extent = [0,0; -100, -100], string = "C", style(color = 0)), Line(points = [ -91,0;66,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [ -145, -102;135, -151], string = "T=%T", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in [degC],
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;101, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -42,0;66,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "C", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           port.T = from_degC(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Celsius"
//           annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;92,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [0,0; -100, -100], string = "C", style(color = 0)), Text(extent = [ -122,163;118,103], string = "%name"), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in [degC] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "C", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
//           Modelica.Blocks.Interfaces.InPort T(final n = 1) annotation(extent = [ -140, -20; -100,20]);
// 
//         equation 
//           port.T = from_degC(T.signal[1]);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Celsius units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// 
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit,
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// 
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degC(20));
// </pre>
// 
// </HTML>
// "));
//         model TemperatureSensor "Absolute temperature sensor in Celsius"
//           annotation(Diagram(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -94,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [102, -22;60, -74], string = "C", style(color = 0))), Icon(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -90,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [126, -20;26, -120], string = "C", style(color = 0)), Text(extent = [ -132,144;108,84], string = "%name")), Documentation(info = "<HTML>
// 
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Celsius as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.OutPort T(redeclare type SignalType = NonSI.Temperature_degC) annotation(extent = [90, -10;110,10]);
//           Interfaces.HeatPort_a port annotation(extent = [ -110, -10; -90,10]);
// 
//         equation 
//           T.signal[1] = to_degC(port.T);
//           port.Q_dot = 0;
//         end TemperatureSensor;
//       end Celsius;
//       package Fahrenheit "Components with Fahrenheit input and/or output"
//         extends Modelica.Icons.Library;
//         model ToKelvin "Conversion block from Fahrenheit to Kelvin"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -40, -50; -99, -99], string = "F", style(color = 0, thickness = 4)), Text(extent = [100, -47;44, -100], string = "K", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [41,0;100,0])), Icon(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [112, -40;32, -120], string = "K", style(color = 0)), Text(extent = [ -31, -39; -111, -119], string = "F", style(color = 0, thickness = 4)), Line(points = [ -41,0; -100,0]), Line(points = [100,0;40,0]), Text(extent = [ -137,99;132,49], string = "%name")), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from degree Fahrenheit to Kelvin
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Fahrenheit(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Kelvin(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Kelvin.signal = from_degF(Fahrenheit.signal);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Fahrenheit"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Icon(Text(extent = [ -137,99;132,49], string = "%name"), Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -34, -42; -114, -122], string = "K", style(color = 0, thickness = 4)), Text(extent = [110, -39;30, -119], string = "F", style(color = 0)), Line(points = [ -40,0; -100,0]), Line(points = [40,0;100,0])), Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -42, -41; -101, -98], string = "K", style(color = 0, thickness = 4)), Text(extent = [100, -40;30, -100], string = "F", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [40,0;100,0])), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Kelvin to Fahrenheit
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Kelvin(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Fahrenheit(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Fahrenheit.signal = to_degF(Kelvin.signal);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in Fahrenheit"
//           parameter NonSI.Temperature_degF T "Fixed Temperature at the port";
//           annotation(Icon(Text(extent = [ -118,165;122,105], string = "%name"), Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Text(extent = [0,0; -100, -100], string = "F", style(color = 0)), Line(points = [ -91,0;66,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [ -145, -102;135, -151], string = "T=%T", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in [degF],
// i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;101, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -42,0;66,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "F", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           port.T = from_degF(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Fahrenheit"
//           annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;92,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [0,0; -100, -100], string = "F", style(color = 0)), Text(extent = [ -122,163;118,103], string = "%name"), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in [degF] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "F", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
//           Modelica.Blocks.Interfaces.InPort T(final n = 1) annotation(extent = [ -140, -20; -100,20]);
// 
//         equation 
//           port.T = from_degF(T.signal[1]);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Fahrenheit units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// 
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// 
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degF(70));
// </pre>
// 
// </HTML>
// "));
//         model TemperatureSensor "Absolute temperature sensor in Fahrenheit"
//           annotation(Diagram(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -94,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [102, -22;60, -74], string = "F", style(color = 0))), Icon(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -90,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [126, -20;26, -120], string = "F", style(color = 0)), Text(extent = [ -132,144;108,84], string = "%name")), Documentation(info = "<HTML>
// 
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Fahrenheit as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.OutPort T(redeclare type SignalType = NonSI.Temperature_degF) annotation(extent = [90, -10;110,10]);
//           Interfaces.HeatPort_a port annotation(extent = [ -110, -10; -90,10]);
// 
//         equation 
//           T.signal[1] = to_degF(port.T);
//           port.Q_dot = 0;
//         end TemperatureSensor;
//       end Fahrenheit;
//       package Rankine "Components with Rankine input and/or output"
//         extends Modelica.Icons.Library;
//         model ToKelvin "Conversion block from Rankine to Kelvin"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -40, -50; -99, -99], string = "Rk", style(color = 0, thickness = 4)), Text(extent = [100, -47;44, -100], string = "K", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [41,0;100,0])), Icon(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [112, -40;32, -120], string = "K", style(color = 0)), Text(extent = [ -31, -39; -111, -119], string = "Rk", style(color = 0, thickness = 4)), Line(points = [ -41,0; -100,0]), Line(points = [100,0;40,0]), Text(extent = [ -137,99;132,49], string = "%name")), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from degree Rankine to Kelvin
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Rankine(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Kelvin(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Kelvin.signal = from_degRk(Rankine.signal);
//         end ToKelvin;
//         model FromKelvin "Conversion from Kelvin to Rankine"
//           parameter Integer n = 1 "Number of inputs (= number of outputs)";
//           annotation(Icon(Text(extent = [ -137,99;132,49], string = "%name"), Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -34, -42; -114, -122], string = "K", style(color = 0, thickness = 4)), Text(extent = [110, -39;30, -119], string = "Rk", style(color = 0)), Line(points = [ -40,0; -100,0]), Line(points = [40,0;100,0])), Diagram(Ellipse(extent = [ -40,40;40, -40], style(color = 0, thickness = 2, fillColor = 7)), Text(extent = [ -42, -41; -101, -98], string = "K", style(color = 0, thickness = 4)), Text(extent = [100, -40;30, -100], string = "Rk", style(color = 0)), Line(points = [ -100,0; -40,0]), Line(points = [40,0;100,0])), Documentation(info = "<HTML>
// <p>
// This component converts all input signals from Kelvin to Rankine
// and provides them as output signals.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.InPort Kelvin(final n = n) annotation(extent = [ -140, -20; -100,20]);
//           Modelica.Blocks.Interfaces.OutPort Rankine(final n = n) annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           Rankine.signal = to_degRk(Kelvin.signal);
//         end FromKelvin;
//         model FixedTemperature "Fixed temperature boundary condition in Rankine"
//           parameter NonSI.Temperature_degRk T "Fixed Temperature at the port";
//           annotation(Icon(Text(extent = [ -118,165;122,105], string = "%name"), Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Text(extent = [0,0; -100, -100], string = "Rk", style(color = 0)), Line(points = [ -91,0;66,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [ -145, -102;135, -151], string = "T=%T", style(color = 0))), Documentation(info = "<HTML>
// <p>
// This model defines a fixed temperature T at its port in degree Rankine,
// [degRk], i.e., it defines a fixed temperature as a boundary condition.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;101, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -42,0;66,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "Rk", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
// 
//         equation 
//           port.T = from_degRk(T);
//         end FixedTemperature;
//         model PrescribedTemperature "Variable temperature boundary condition in Rankine"
//           annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;92,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1)), Text(extent = [0,0; -100, -100], string = "Rk", style(color = 0)), Text(extent = [ -122,163;118,103], string = "%name"), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))), Documentation(info = "<HTML>
// <p>
// This model represents a variable temperature boundary condition
// The temperature value in degree Rankine, [degRk] is given by the input signal
// to the model. The effect is that an instance of this model acts as
// an infinite reservoir able to absorb or generate as much energy
// as required to keep the temperature at the specified value.
// </p>
// </HTML>
// "), Diagram(Rectangle(extent = [ -100,100;100, -100], style(color = 0, pattern = 0, fillColor = 76, fillPattern = 8)), Line(points = [ -102,0;64,0], style(color = 42, thickness = 2)), Text(extent = [0,0; -100, -100], string = "Rk", style(color = 0)), Polygon(points = [62, -20;62,20;100,0;62, -20], style(color = 42, fillColor = 42, fillPattern = 1))));
//           Interfaces.HeatPort_b port annotation(extent = [100, -10;120,10]);
//           Modelica.Blocks.Interfaces.InPort T(final n = 1) annotation(extent = [ -140, -20; -100,20]);
// 
//         equation 
//           port.T = from_degRk(T.signal[1]);
//         end PrescribedTemperature;
//         annotation(Documentation(info = "<HTML>
// <p>
// The components of this package are provided for the convenience of
// people working mostly with Rankine units, since all models
// in package HeatTransfer are based on Kelvin units.
// </p>
// 
// <p>
// Note, that in package SIunits.Conversions, functions are provided
// to convert between the units Kelvin, degree Celsius, degree Fahrenheit
// and degree Rankine. These functions allow, e.g., a direct conversion
// of units at all places where Kelvin is required as parameter.
// Example:
// </p>
// 
// <pre>
//     <b>import</b> SIunits.Conversions.*;
//     Modelica.Thermal.HeatTransfer.HeatCapacitor C(T0 = from_degRk(500));
// </pre>
// 
// </HTML>
// "));
//         model TemperatureSensor "Absolute temperature sensor in Rankine"
//           annotation(Diagram(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -94,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [102, -22;60, -74], string = "Rk", style(color = 0))), Icon(Ellipse(extent = [ -20, -98;20, -60], style(color = 0, thickness = 2, fillColor = 42)), Rectangle(extent = [ -12,40;12, -68], style(color = 42, fillColor = 42)), Line(points = [12,0;90,0]), Line(points = [ -90,0; -12,0], style(color = 42)), Polygon(points = [ -12,40; -12,80; -10,86; -6,88;0,90;6,88;10,86;12,80;12,40; -12,40], style(color = 0, thickness = 2)), Line(points = [ -12,40; -12, -64], style(color = 0, thickness = 2)), Line(points = [12,40;12, -64], style(color = 0, thickness = 2)), Line(points = [ -40, -20; -12, -20], style(color = 0)), Line(points = [ -40,20; -12,20], style(color = 0)), Line(points = [ -40,60; -12,60], style(color = 0)), Text(extent = [126, -20;26, -120], string = "Rk", style(color = 0)), Text(extent = [ -132,144;108,84], string = "%name")), Documentation(info = "<HTML>
// 
// <p>
// This is an ideal absolute temperature sensor which returns
// the temperature of the connected port in Rankine as an output
// signal.  The sensor itself has no thermal interaction with
// whatever it is connected to.  Furthermore, no
// thermocouple-like lags are associated with this
// sensor model.
// </p>
// </HTML>
// "));
//           Modelica.Blocks.Interfaces.OutPort T(redeclare type SignalType = NonSI.Temperature_degRk) annotation(extent = [90, -10;110,10]);
//           Interfaces.HeatPort_a port annotation(extent = [ -110, -10; -90,10]);
// 
//         equation 
//           T.signal[1] = to_degRk(port.T);
//           port.Q_dot = 0;
//         end TemperatureSensor;
//       end Rankine;
//     end HeatTransfer;
//   end Thermal;
//   package Constants "Mathematical constants and constants of nature"
//     import SI = Modelica.SIunits;
//     import NonSI = Modelica.SIunits.Conversions.NonSIunits;
//     extends Modelica.Icons.Library2;
//     constant Real e = Modelica.Math.exp(1.0);
//     constant Real pi = 2 * Modelica.Math.asin(1.0);
//     constant Real D2R = pi / 180 "Degree to Radian";
//     constant Real R2D = 180 / pi "Radian to Degree";
//     constant Real eps = 1e-15 "Biggest number such that 1.0 + eps = 1.0";
//     constant Real small = 1e-60 "Smallest number such that small and -small are representable on the machine";
//     constant Real inf = 1e+60 "Biggest Real number such that inf and -inf are representable on the machine";
//     constant Integer Integer_inf = 1073741823 "Biggest Integer number such that Integer_inf and -Integer_inf are representable on the machine";
//     constant SI.Velocity c = 299792458 "Speed of light in vacuum";
//     constant SI.Acceleration g_n = 9.80665 "Standard acceleration of gravity on earth";
//     constant Real G(final unit = "m3/(kg.s2)") = 6.673e-11 "Newtonian constant of gravitation";
//     constant Real h(final unit = "J.s") = 6.62606876e-34 "Planck constant";
//     constant Real k(final unit = "J/K") = 1.3806503e-23 "Boltzmann constant";
//     constant Real R(final unit = "J/(mol.K)") = 8.314472 "Molar gas constant";
//     constant Real sigma(final unit = "W/(m2.K4)") = 5.6704e-08 "Stefan-Boltzmann constant";
//     constant Real N_A(final unit = "1/mol") = 6.02214199e+23 "Avogadro constant";
//     constant Real mue_0(final unit = "N/A2") = 4 * pi * 1e-07 "Magnetic constant";
//     constant Real epsilon_0(final unit = "F/m") = 1 / (mue_0 * c * c) "Electric constant";
//     constant NonSI.Temperature_degC T_zero =  -273.15 "Absolute zero temperature";
//     constant Real E = e;
//     constant Real PI = pi;
//     constant Real EPS = eps;
//     constant Real SMALL = small;
//     constant Real INF = inf;
//     constant Real INTEGER_INF = Integer_inf;
//     constant Real C = c;
//     constant Real H = h;
//     constant Real K = k;
//     constant Real R0 = R;
//     constant Real SIGMA = sigma;
//     constant Real G_EARTH = g_n;
//     constant Real T_ZERO = T_zero;
//     annotation(Documentation(info = "<html>
// <p>
// This package provides often needed constants from mathematics, machine
// dependent constants and constants from nature. The latter constants
// (name, value, description) are from the following source:
// </p>
// 
// <dl>
// <dt>Peter J. Mohr and Barry N. Taylor (1999):
// <dd><b>CODATA Recommended Values of the Fundamental Physical Constants: 1998</b>.
//        Journal of Physical and Chemical Reference Data, Vol. 28, No. 6, 1999 and
//        Reviews of Modern Physics, Vol. 72, No. 2, 2000. See also
//        <a href=\"http://physics.nist.gov/cuu/Constants/\">
//                  http://physics.nist.gov/cuu/Constants/</a>
// </dl>
// <br>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Dec. 9, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Constants updated according to 1998 CODATA values. Using names, values
//        and description text from this source. Included magnetic and
//        electric constant.</li>
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Constants EPS, INF, SMALL introduced.</li>
// <li><i>Nov 15, 1997</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is free software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "), Window(x = 0.16, y = 0.01, width = 0.65, height = 0.81, library = 1, autolayout = 1), Invisible = true, Icon(Line(points = [ -34, -38;12, -38], style(color = 0, thickness = 2)), Line(points = [ -20, -38; -24, -48; -28, -56; -34, -64], style(color = 0, thickness = 2)), Line(points = [ -2, -38;2, -46;8, -56;14, -64], style(color = 0, thickness = 2))), Diagram(Rectangle(extent = [200,162;380,312], style(fillColor = 30, fillPattern = 1)), Polygon(points = [200,312;220,332;400,332;380,312;200,312], style(fillColor = 30, fillPattern = 1)), Polygon(points = [400,332;400,182;380,162;380,312;400,332], style(fillColor = 30, fillPattern = 1)), Text(extent = [210,302;370,272], string = "Library", style(color = 9, fillColor = 0, fillPattern = 1)), Line(points = [266,224;312,224], style(color = 0, thickness = 4)), Line(points = [280,224;276,214;272,206;266,198], style(color = 0, thickness = 4)), Line(points = [298,224;302,216;308,206;314,198], style(color = 0, thickness = 4)), Text(extent = [152,412;458,334], string = "Modelica.Constants", style(color = 1))));
//   end Constants;
//   package Icons "Icon definitions"
//     annotation(Window(x = 0.08, y = 0.08, width = 0.28, height = 0.51, library = 1, autolayout = 1), Icon(Rectangle(extent = [ -100, -100;80,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [ -100,50; -80,70;100,70;80,50; -100,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [100,70;100, -80;80, -100;80,50;100,70], style(fillColor = 30, fillPattern = 1)), Text(extent = [ -120,135;120,70], string = "%name", style(color = 1)), Text(extent = [ -90,40;70,10], string = "Library", style(color = 9, fillColor = 0, fillPattern = 1)), Rectangle(extent = [ -100, -100;80,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [ -100,50; -80,70;100,70;80,50; -100,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [100,70;100, -80;80, -100;80,50;100,70], style(fillColor = 30, fillPattern = 1)), Text(extent = [ -90,40;70,10], string = "Library", style(color = 9, fillColor = 0, fillPattern = 1)), Polygon(points = [ -64, -20; -50, -4;50, -4;36, -20; -64, -20; -64, -20], style(color = 0, fillColor = 8, fillPattern = 1)), Rectangle(extent = [ -64, -20;36, -84], style(color = 0, fillColor = 8, fillPattern = 1)), Text(extent = [ -60, -24;32, -38], string = "Library", style(color = 10, fillColor = 10, fillPattern = 1)), Polygon(points = [50, -4;50, -70;36, -84;36, -20;50, -4], style(color = 0, fillColor = 8, fillPattern = 1))), Documentation(info = "<html>
// <p>
// This package contains definitions for the graphical layout of
// components which may be used in different libraries.
// The icons can be utilized by inheriting them in the desired class
// using \"extends\".
// </p>
// 
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added new icons <b>Function</b>, <b>Enumerations</b> and <b>Record</b>.</li>
// <li><i>June 6, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Replaced <b>model</b> keyword by <b>package</b> if the main
//        usage is for inheriting from a package.<br>
//        New icons <b>GearIcon</b> and <b>MotorIcon</b>.</li>
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renaming package Icon to Icons.
//        Model Advanced removed (icon not accepted on the Modelica meeting).
//        New model Library2, which is the Library icon with enough place
//        to add library specific elements in the icon. Icon also used in diagram
//        level for models Info, TranslationalSensor, RotationalSensor.</li>
// <li><i>July 15, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Model Caution renamed to Advanced, model Sensor renamed to
//        TranslationalSensor, new model RotationalSensor.</li>
// <li><i>June 30, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Realized a first version.</li>
// </ul>
// <br>
// 
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>
// The Modelica package is <b>free</b> software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".
// </i></p>
// </HTML>
// "));
//     partial model Info "Icon for an information class"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -100,80;80, -90], style(color = 3)), Polygon(points = [ -100,80; -90,90;90,90;80,80; -100,80], style(fillColor = 3)), Polygon(points = [80, -90;90, -80;90,90;80,80;80, -90], style(fillColor = 3)), Text(extent = [ -80,70;60, -70], string = "Info")), Diagram(Rectangle(extent = [ -100,80;80, -90], style(color = 3)), Polygon(points = [ -100,80; -90,90;90,90;80,80; -100,80], style(fillColor = 3)), Polygon(points = [80, -90;90, -80;90,90;80,80;80, -90], style(fillColor = 3)), Text(extent = [ -80,70;60, -70], string = "Info")));
//     end Info;
//     partial package Library "Icon for library"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -100, -100;80,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [ -100,50; -80,70;100,70;80,50; -100,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [100,70;100, -80;80, -100;80,50;100,70], style(fillColor = 30, fillPattern = 1)), Text(extent = [ -85,35;65, -85], string = "Library", style(color = 3)), Text(extent = [ -120,122;120,73], string = "%name", style(color = 1))));
//     end Library;
//     partial package Library2 "Icon for library where additional icon elements shall be added"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -100, -100;80,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [ -100,50; -80,70;100,70;80,50; -100,50], style(fillColor = 30, fillPattern = 1)), Polygon(points = [100,70;100, -80;80, -100;80,50;100,70], style(fillColor = 30, fillPattern = 1)), Text(extent = [ -120,125;120,70], string = "%name", style(color = 1)), Text(extent = [ -90,40;70,10], string = "Library", style(color = 9, fillColor = 0, fillPattern = 1))));
//     end Library2;
//     partial model Example "Icon for an example model"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -100, -100;80,50], style(fillColor = 7)), Polygon(points = [ -100,50; -80,70;100,70;80,50; -100,50], style(fillColor = 7)), Polygon(points = [100,70;100, -80;80, -100;80,50;100,70], style(fillColor = 7)), Text(extent = [ -96,3;77, -49], string = "Example", style(color = 3)), Text(extent = [ -120,132;120,73], string = "%name", style(color = 1))));
//     end Example;
//     partial function Function "Icon for a function"
//       annotation(Icon(Text(extent = [ -134,104;142,44], string = "%name"), Ellipse(extent = [ -100,40;100, -100], style(color = 45, fillColor = 7)), Text(extent = [ -84, -4;84, -52], string = "function", style(color = 45))));
//     end Function;
//     partial record Record "Icon for a record"
//       annotation(Icon(Rectangle(extent = [ -100,50;100, -100], style(fillColor = 51, fillPattern = 1)), Text(extent = [ -127,115;127,55], string = "%name"), Line(points = [ -100, -50;100, -50], style(color = 0)), Line(points = [ -100,0;100,0], style(color = 0)), Line(points = [0,50;0, -100], style(color = 0))));
//     end Record;
//     partial function Enumeration "Icon for an enumeration"
//       annotation(Icon(Text(extent = [ -134,104;142,44], string = "%name"), Ellipse(extent = [ -100,40;100, -100], style(color = 85, fillColor = 7)), Text(extent = [ -84, -4;84, -52], string = "enumeration", style(color = 85, fillColor = 88))));
//     end Enumeration;
//     partial model TranslationalSensor "Icon representing translational measurement device"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -70, -60;70,20], style(color = 0, fillColor = 7)), Polygon(points = [0, -40; -10, -16;10, -16;0, -40], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [0,0;0, -16], style(color = 0)), Line(points = [ -70,0;0,0], style(color = 0)), Line(points = [ -50, -40; -50, -60], style(color = 0)), Line(points = [ -30, -40; -30, -60], style(color = 0)), Line(points = [ -10, -40; -10, -60], style(color = 0)), Line(points = [10, -40;10, -60], style(color = 0)), Line(points = [30, -40;30, -60], style(color = 0)), Line(points = [50, -40;50, -60], style(color = 0))), Diagram(Rectangle(extent = [ -70, -60;70,20], style(color = 0, fillColor = 7)), Polygon(points = [0, -40; -10, -16;10, -16;0, -40], style(color = 0, fillColor = 0, fillPattern = 1)), Line(points = [0,0;0, -16], style(color = 0)), Line(points = [ -70,0;0,0], style(color = 0)), Line(points = [ -50, -40; -50, -60], style(color = 0)), Line(points = [ -30, -40; -30, -60], style(color = 0)), Line(points = [ -10, -40; -10, -60], style(color = 0)), Line(points = [10, -40;10, -60], style(color = 0)), Line(points = [30, -40;30, -60], style(color = 0)), Line(points = [50, -40;50, -60], style(color = 0))));
//     end TranslationalSensor;
//     partial model RotationalSensor "Icon representing rotational measurement device"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Ellipse(extent = [ -70,70;70, -70], style(color = 0, fillColor = 7)), Line(points = [0,70;0,40], style(color = 0)), Line(points = [22.9,32.8;40.2,57.3], style(color = 0)), Line(points = [ -22.9,32.8; -40.2,57.3], style(color = 0)), Line(points = [37.6,13.7;65.8,23.9], style(color = 0)), Line(points = [ -37.6,13.7; -65.8,23.9], style(color = 0)), Line(points = [0,0;9.02,28.6], style(color = 0)), Polygon(points = [ -0.48,31.6;18,26;18,57.2; -0.48,31.6], style(color = 0, fillColor = 0, fillPattern = 1)), Ellipse(extent = [ -5,5;5, -5], style(color = 0, gradient = 0, fillColor = 0, fillPattern = 1))), Diagram(Ellipse(extent = [ -70,70;70, -70], style(color = 0, fillColor = 7)), Line(points = [0,70;0,40], style(color = 0)), Line(points = [22.9,32.8;40.2,57.3], style(color = 0)), Line(points = [ -22.9,32.8; -40.2,57.3], style(color = 0)), Line(points = [37.6,13.7;65.8,23.9], style(color = 0)), Line(points = [ -37.6,13.7; -65.8,23.9], style(color = 0)), Line(points = [0,0;9.02,28.6], style(color = 0)), Polygon(points = [ -0.48,31.6;18,26;18,57.2; -0.48,31.6], style(color = 0, fillColor = 0, fillPattern = 1)), Ellipse(extent = [ -5,5;5, -5], style(color = 0, gradient = 0, fillColor = 0, fillPattern = 1))));
//     end RotationalSensor;
//     partial model GearIcon "Icon for gearbox"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [2,2], component = [20,20]), Icon(Rectangle(extent = [ -90,10; -60, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Polygon(points = [ -60,10; -60,20; -40,40; -40, -40; -60, -20; -60,10], style(color = 10, gradient = 2, fillColor = 10, fillPattern = 1)), Rectangle(extent = [ -40,60;40, -60], style(color = 3, pattern = 1, thickness = 1, gradient = 2, arrow = 0, fillColor = 8, fillPattern = 1)), Polygon(points = [60,20;40,40;40, -40;60, -20;60,20], style(color = 10, fillColor = 10, fillPattern = 1)), Rectangle(extent = [60,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1)), Polygon(points = [ -60, -90; -50, -90; -20, -30;20, -30;48, -90;60, -90;60, -100; -60, -100; -60, -90], style(color = 0, fillColor = 0, fillPattern = 1))));
//     end GearIcon;
//     partial model MotorIcon "Icon for electrical motor"
//       annotation(Coordsys(extent = [ -100, -100;100,100], grid = [1,1], component = [20,20]), Icon(Rectangle(extent = [ -100,50;30, -50], style(color = 1, gradient = 2, fillColor = 1, fillPattern = 1)), Polygon(points = [ -100, -90; -90, -90; -60, -20; -10, -20;20, -90;30, -90;30, -100; -100, -100; -100, -90], style(color = 0, gradient = 0, fillColor = 0, fillPattern = 1)), Rectangle(extent = [30,10;90, -10], style(gradient = 2, fillColor = 8, fillPattern = 1))));
//     end MotorIcon;
//   end Icons;
//   package SIunits "Type definitions based on SI units according to ISO 31-1992"
//     extends Modelica.Icons.Library2;
//     package Conversions "Conversion functions to/from non SI units and type definitions of non SI units"
//       extends Modelica.Icons.Library2;
//       package NonSIunits "Type definitions of non SI units"
//         extends Modelica.Icons.Library2;
//         type Temperature_degC = Real(final quantity = "ThermodynamicTemperature", final unit = "degC");
//         type Temperature_degF = Real(final quantity = "ThermodynamicTemperature", final unit = "degF");
//         type Temperature_degRk = Real(final quantity = "ThermodynamicTemperature", final unit = "degRk");
//         type Angle_deg = Real(final quantity = "Angle", final unit = "deg");
//         type AngularVelocity_rpm = Real(final quantity = "AngularVelocity", final unit = "rev/min");
//         type Velocity_kmh = Real(final quantity = "Velocity", final unit = "km/h");
//         type Time_day = Real(final quantity = "Time", final unit = "d");
//         type Time_hour = Real(final quantity = "Time", final unit = "h");
//         type Time_minute = Real(final quantity = "Time", final unit = "min");
//         type Volume_litre = Real(final quantity = "Volume", final unit = "l");
//         type Energy_kWh = Real(final quantity = "Energy", final unit = "kWh");
//         type Pressure_bar = Real(final quantity = "Pressure", final unit = "bar");
//         type MassFlowRate_gps = Real(final quantity = "MassFlowRate", final unit = "g/s");
//         annotation(Documentation(info = "<HTML>
// <p>
// This package provides predefined types, such as <b>Angle_deg</b> (angle in
// degree), <b>AngularVelocity_rpm</b> (angular velocity in revolutions per
// minute) or <b>Temperature_degF</b> (temperature in degree Fahrenheit),
// which are in common use but are not part of the international standard on
// units according to ISO 31-1992 \"General principles concerning quantities,
// units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
// the use of their multiples and of certain other units\".</p>
// 
// <p>If possible, the types in this package should not be used. Use instead
// types of package Modelica.SIunits. For more information on units, see also
// the book of Francois Cardarelli <b>Scientific Unit Conversion - A
// Practical Guide to Metrication</b> (Springer 1997).</p>
// 
// <p>Some units, such as <b>Temperature_degC/Temp_C</b> are both defined in
// Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
// definitions have been placed erroneously in Modelica.SIunits although they
// are not SIunits. For backward compatibility, these type definitions are
// still kept in Modelica.SIunits.</p>
// 
// </HTML>
// "), Icon(Text(extent = [ -66, -13;52, -67], string = "[rev/min]", style(color = 0))));
//       end NonSIunits;
//       function to_degC "Convert from Kelvin to Celsius"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degC Celsius "Celsius value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "K"), Text(extent = [100, -20;20, -100], style(color = 0), string = "C")));
//       algorithm 
//         Celsius:=Kelvin + Modelica.Constants.T_zero;
//       end to_degC;
//       function from_degC "Convert from Celsius to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degC Celsius "Celsius value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "C"), Text(extent = [100, -20;20, -100], style(color = 0), string = "K")));
//       algorithm 
//         Kelvin:=Celsius - Modelica.Constants.T_zero;
//       end from_degC;
//       function to_degF "Convert from Kelvin to Fahrenheit"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degF Fahrenheit "Fahrenheit value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "K"), Text(extent = [100, -20;20, -100], style(color = 0), string = "F")));
//       algorithm 
//         Fahrenheit:=(Kelvin + Modelica.Constants.T_zero) * 9 / 5 + 32;
//       end to_degF;
//       function from_degF "Convert from Fahrenheit to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degF Fahrenheit "Fahrenheit value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "F"), Text(extent = [100, -20;20, -100], style(color = 0), string = "K")));
//       algorithm 
//         Kelvin:=(Fahrenheit - 32) * 5 / 9 - Modelica.Constants.T_zero;
//       end from_degF;
//       function to_degRk "Convert from Kelvin to Rankine"
//         extends ConversionIcon;
//         input Temperature Kelvin "Kelvin value";
//         output NonSIunits.Temperature_degRk Rankine "Rankine value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "K"), Text(extent = [100, -20;20, -100], style(color = 0), string = "Rk")));
//       algorithm 
//         Rankine:=9 / 5 * Kelvin;
//       end to_degRk;
//       function from_degRk "Convert from Rankine to Kelvin"
//         extends ConversionIcon;
//         input NonSIunits.Temperature_degRk Rankine "Rankine value";
//         output Temperature Kelvin "Kelvin value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "Rk"), Text(extent = [100, -20;20, -100], style(color = 0), string = "K")));
//       algorithm 
//         Kelvin:=5 / 9 * Rankine;
//       end from_degRk;
//       function to_deg "Convert from radian to degree"
//         extends ConversionIcon;
//         input Angle radian "radian value";
//         output NonSIunits.Angle_deg degree "degree value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "rad"), Text(extent = [100, -20;20, -100], style(color = 0), string = "deg")));
//       algorithm 
//         degree:=180.0 / Modelica.Constants.pi * radian;
//       end to_deg;
//       function from_deg "Convert from degree to radian"
//         extends ConversionIcon;
//         input NonSIunits.Angle_deg degree "degree value";
//         output Angle radian "radian value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "deg"), Text(extent = [100, -20;20, -100], style(color = 0), string = "rad")));
//       algorithm 
//         radian:=Modelica.Constants.pi / 180.0 * degree;
//       end from_deg;
//       function to_rpm "Convert from radian per second to revolutions per minute"
//         extends ConversionIcon;
//         input AngularVelocity rs "radian per second value";
//         output NonSIunits.AngularVelocity_rpm rpm "revolutions per minute value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "rad/s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "rev/min")));
//       algorithm 
//         rpm:=30 / Modelica.Constants.pi * rs;
//       end to_rpm;
//       function from_rpm "Convert from revolutions per minute to radian per second"
//         extends ConversionIcon;
//         input NonSIunits.AngularVelocity_rpm rpm "revolutions per minute value";
//         output AngularVelocity rs "radian per second value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "rev/min"), Text(extent = [100, -20;20, -100], style(color = 0), string = "rad/s")));
//       algorithm 
//         rs:=Modelica.Constants.pi / 30 * rpm;
//       end from_rpm;
//       function to_kmh "Convert from metre per second to kilometre per hour"
//         extends ConversionIcon;
//         input Velocity ms "metre per second value";
//         output NonSIunits.Velocity_kmh kmh "kilometre per hour value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "m/s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "km/h")));
//       algorithm 
//         kmh:=3.6 * ms;
//       end to_kmh;
//       function from_kmh "Convert from kilometre per hour to metre per second"
//         extends ConversionIcon;
//         input NonSIunits.Velocity_kmh kmh "kilometre per hour value";
//         output Velocity ms "metre per second value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "km/h"), Text(extent = [100, -20;20, -100], style(color = 0), string = "m/s")));
//       algorithm 
//         ms:=kmh / 3.6;
//       end from_kmh;
//       function to_day "Convert from second to day"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_day day "day value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "day")));
//       algorithm 
//         day:=s / 86400;
//       end to_day;
//       function from_day "Convert from day to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_day day "day value";
//         output Time s "second value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "day"), Text(extent = [100, -20;20, -100], style(color = 0), string = "s")));
//       algorithm 
//         s:=86400 * day;
//       end from_day;
//       function to_hour "Convert from second to hour"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_hour hour "hour value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "hour")));
//       algorithm 
//         hour:=s / 3600;
//       end to_hour;
//       function from_hour "Convert from hour to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_hour hour "hour value";
//         output Time s "second value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "hour"), Text(extent = [100, -20;20, -100], style(color = 0), string = "s")));
//       algorithm 
//         s:=3600 * hour;
//       end from_hour;
//       function to_minute "Convert from second to minute"
//         extends ConversionIcon;
//         input Time s "second value";
//         output NonSIunits.Time_minute minute "minute value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "minute")));
//       algorithm 
//         minute:=s / 60;
//       end to_minute;
//       function from_minute "Convert from minute to second"
//         extends ConversionIcon;
//         input NonSIunits.Time_minute minute "minute value";
//         output Time s "second value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "minute"), Text(extent = [100, -20;20, -100], style(color = 0), string = "s")));
//       algorithm 
//         s:=60 * minute;
//       end from_minute;
//       function to_litre "Convert from cubic metre to litre"
//         extends ConversionIcon;
//         input Volume m3 "cubic metre value";
//         output NonSIunits.Volume_litre litre "litre value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "m3"), Text(extent = [100, -20;20, -100], style(color = 0), string = "litre")));
//       algorithm 
//         litre:=1000 * m3;
//       end to_litre;
//       function from_litre "Convert from litre to cubic metre"
//         extends ConversionIcon;
//         input NonSIunits.Volume_litre litre "litre value";
//         output Volume m3 "cubic metre value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "litre"), Text(extent = [100, -20;20, -100], style(color = 0), string = "m3")));
//       algorithm 
//         m3:=litre / 1000;
//       end from_litre;
//       function to_kWh "Convert from Joule to kilo Watt hour"
//         extends ConversionIcon;
//         input Energy J "Joule value";
//         output NonSIunits.Energy_kWh kWh "kWh value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "J"), Text(extent = [100, -20;20, -100], style(color = 0), string = "kWh")));
//       algorithm 
//         kWh:=J / 3600000.0;
//       end to_kWh;
//       function from_kWh "Convert from kilo Watt hour to Joule"
//         extends ConversionIcon;
//         input NonSIunits.Energy_kWh kWh "kWh value";
//         output Energy J "Joule value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "kWh"), Text(extent = [100, -20;20, -100], style(color = 0), string = "J")));
//       algorithm 
//         J:=3600000.0 * kWh;
//       end from_kWh;
//       function to_bar "Convert from Pascal to bar"
//         extends ConversionIcon;
//         input Pressure Pa "Pascal value";
//         output NonSIunits.Pressure_bar bar "bar value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "Pa"), Text(extent = [100, -20;20, -100], style(color = 0), string = "bar")));
//       algorithm 
//         bar:=Pa / 100000.0;
//       end to_bar;
//       function from_bar "Convert from bar to Pascal"
//         extends ConversionIcon;
//         input NonSIunits.Pressure_bar bar "bar value";
//         output Pressure Pa "Pascal value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "bar"), Text(extent = [100, -20;20, -100], style(color = 0), string = "Pa")));
//       algorithm 
//         Pa:=100000.0 * bar;
//       end from_bar;
//       function to_gps "Convert from kilogram per second to gram per second"
//         extends ConversionIcon;
//         input MassFlowRate kgps "kg/s value";
//         output NonSIunits.MassFlowRate_gps gps "g/s value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "kg/s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "g/s")));
//       algorithm 
//         gps:=1000 * kgps;
//       end to_gps;
//       function from_gps "Convert from gram per second to kilogram per second"
//         extends ConversionIcon;
//         input NonSIunits.MassFlowRate_gps gps "g/s value";
//         output MassFlowRate kgps "kg/s value";
//         annotation(Icon(Text(extent = [ -20,100; -100,20], style(color = 0), string = "g/s"), Text(extent = [100, -20;20, -100], style(color = 0), string = "kg/s")));
//       algorithm 
//         kgps:=gps / 1000;
//       end from_gps;
//       partial function ConversionIcon "Base icon for conversion functions"
//         annotation(Icon(Rectangle(extent = [ -100,100;100, -100], style(color = 42, fillColor = 7)), Line(points = [ -90,0;30,0], style(color = 42)), Polygon(points = [90,0;30,20;30, -20;90,0], style(color = 42, fillColor = 42)), Text(extent = [ -115,155;115,105], string = "%name")));
//       end ConversionIcon;
//       annotation(Icon(Text(extent = [ -33, -7; -92, -67], string = "C", style(color = 0, thickness = 4)), Text(extent = [82, -7;22, -67], string = "K", style(color = 0)), Line(points = [ -26, -36;6, -36], style(color = 0)), Polygon(points = [6, -28;6, -45;26, -37;6, -28], style(pattern = 0, fillColor = 0))), Documentation(info = "<HTML>
// <p>This package provides conversion functions from the non SI Units
// defined in package Modelica.SIunits.Conversions.NonSIunits to the
// corresponding SI Units defined in package Modelica.SIunits and vice
// versa. It is recommended to use these functions in the following
// way:</p>
// 
// <pre>
//   <b>import</b> SI = Modelica.SIunits;
//   <b>import</b> Modelica.SIunits.Conversions.*;
//      ...
//   <b>parameter</b> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
//   <b>parameter</b> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
//   <b>parameter</b> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
//                                                       // to radian per seconds
// </pre>
// 
// <p>The following conversion functions are provided. Note, that all
// of them have one Real input and one Real output argument:</p>
// 
// <table border=1 cellspacing=0 cellpadding=2>
// <tr>
// <th>Function</th>
// <th>Description</th>
// </tr>
// 
// <tr>
// <td><b>to_degC</b><br>
// <b>from_degC</b></td>
// <td>Convert from Kelvin to degree Celsius<br>
// Convert from degree Celsius to Kelvin</td>
// </tr>
// 
// <tr>
// <td><b>to_degF</b><br>
// <b>from_degF</b></td>
// <td>Convert from Kelvin to degree Fahrenheit<br>
// Convert from degree Fahrenheit to Kelvin</td>
// </tr>
// 
// <tr>
// <td><b>to_degRk</b><br>
// <b>from_degRk</b></td>
// <td>Convert from Kelvin to degree Rankine<br>
// Convert from degree Rankine to Kelvin</td>
// </tr>
// 
// <tr>
// <td><b>to_deg</b><br>
// <b>from_deg</b></td>
// <td>Convert from radian to degree<br>
// Convert from degree to radian</td>
// </tr>
// 
// <tr>
// <td><b>to_rpm</b><br>
// <b>from_rpm</b></td>
// <td>Convert from radian per second to revolutions per minute<br>
// Convert from revolutions per minute to radian per second</td>
// </tr>
// 
// <tr>
// <td><b>to_kmh</b><br>
// <b>from_kmh</b></td>
// <td>Convert from metre per second to kilometre per hour<br>
// Convert from kilometre per hour to metre per second</td>
// </tr>
// 
// <tr>
// <td><b>to_day</b><br>
// <b>from_day</b></td>
// <td>Convert from second to day<br>
// Convert from day to second</td>
// </tr>
// 
// <tr>
// <td><b>to_hour</b><br>
// <b>from_hour</b></td>
// <td>Convert from second to hour<br>
// Convert from hour to second</td>
// </tr>
// 
// <tr>
// <td><b>to_minute</b><br>
// <b>from_minute</b></td>
// <td>Convert from second to minute<br>
// Convert from minute to second</td>
// </tr>
// 
// <tr>
// <td><b>to_litre</b><br>
// <b>from_litre</b></td>
// <td>Convert from cubic metre to litre<br>
// Convert from litre to cubic metre</td>
// </tr>
// 
// <tr>
// <td><b>to_kWh</b><br>
// <b>from_kWh</b></td>
// <td>Convert from Joule to kilo Watt hour<br>
// Convert from kilo Watt hour to Joule</td>
// </tr>
// 
// <tr>
// <td><b>to_bar</b><br>
// <b>from_bar</b></td>
// <td>Convert from Pascal to bar<br>
// Convert from bar to Pascal</td>
// </tr>
// 
// <tr>
// <td><b>to_gps</b><br>
// <b>from_gps</b></td>
// <td>Convert from kilogram per second to gram per second<br>
// Convert from gram per second to kilogram per second</td>
// </tr>
// </table>
// 
// <p>There is the additional <b>partial</b> function <b>ConversionIcon</b>
// in this package. It contains just the base icon for all the conversion
// functions.</p>
// 
// </HTML>
// "));
//     end Conversions;
//     type Angle = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg");
//     type SolidAngle = Real(final quantity = "SolidAngle", final unit = "sr");
//     type Length = Real(final quantity = "Length", final unit = "m");
//     type PathLength = Length;
//     type Position = Length;
//     type Distance = Length(min = 0);
//     type Breadth = Distance;
//     type Height = Distance;
//     type Thickness = Distance;
//     type Radius = Distance;
//     type Diameter = Distance;
//     type Area = Real(final quantity = "Area", final unit = "m2");
//     type Volume = Real(final quantity = "Volume", final unit = "m3");
//     type Time = Real(final quantity = "Time", final unit = "s");
//     type Duration = Time;
//     type AngularVelocity = Real(final quantity = "AngularVelocity", final unit = "rad/s", displayUnit = "rev/min");
//     type AngularAcceleration = Real(final quantity = "AngularAcceleration", final unit = "rad/s2");
//     type Velocity = Real(final quantity = "Velocity", final unit = "m/s");
//     type Acceleration = Real(final quantity = "Acceleration", final unit = "m/s2");
//     type Period = Real(final quantity = "Time", final unit = "s");
//     type Frequency = Real(final quantity = "Frequency", final unit = "Hz");
//     type AngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1");
//     type Wavelength = Real(final quantity = "Wavelength", final unit = "m");
//     type Wavelenght = Wavelength;
//     type WaveNumber = Real(final quantity = "WaveNumber", final unit = "m-1");
//     type CircularWaveNumber = Real(final quantity = "CircularWaveNumber", final unit = "rad/m");
//     type AmplitudeLevelDifference = Real(final quantity = "AmplitudeLevelDifference", final unit = "dB");
//     type PowerLevelDifference = Real(final quantity = "PowerLevelDifference", final unit = "dB");
//     type DampingCoefficient = Real(final quantity = "DampingCoefficient", final unit = "s-1");
//     type LogarithmicDecrement = Real(final quantity = "LogarithmicDecrement", final unit = "Np/S");
//     type AttenuationCoefficient = Real(final quantity = "AttenuationCoefficient", final unit = "m-1");
//     type PhaseCoefficient = Real(final quantity = "PhaseCoefficient", final unit = "m-1");
//     type PropagationCoefficient = Real(final quantity = "PropagationCoefficient", final unit = "m-1");
//     type Damping = DampingCoefficient;
//     type Mass = Real(quantity = "Mass", final unit = "kg", min = 0);
//     type Density = Real(final quantity = "Density", final unit = "kg/m3", displayUnit = "g/cm3", min = 0);
//     type RelativeDensity = Real(final quantity = "RelativeDensity", final unit = "1", min = 0);
//     type SpecificVolume = Real(final quantity = "SpecificVolume", final unit = "m3/kg", min = 0);
//     type LinearDensity = Real(final quantity = "LinearDensity", final unit = "kg/m", min = 0);
//     type SurfaceDensity = Real(final quantity = "SurfaceDensity", final unit = "kg/m2", min = 0);
//     type Momentum = Real(final quantity = "Momentum", final unit = "kg.m/s");
//     type Impulse = Real(final quantity = "Impulse", final unit = "N.s");
//     type AngularMomentum = Real(final quantity = "AngularMomentum", final unit = "kg.m2/s");
//     type AngularImpulse = Real(final quantity = "AngularImpulse", final unit = "N.m.s");
//     type MomentOfInertia = Real(final quantity = "MomentOfInertia", final unit = "kg.m2");
//     type Inertia = MomentOfInertia;
//     type Force = Real(final quantity = "Force", final unit = "N");
//     type Weight = Force;
//     type Torque = Real(final quantity = "Torque", final unit = "N.m");
//     type MomentOfForce = Torque;
//     type Pressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar");
//     type AbsolutePressure = Pressure(min = 0);
//     type BulkModulus = AbsolutePressure;
//     type Stress = Real(final unit = "Pa");
//     type NormalStress = Stress;
//     type ShearStress = Stress;
//     type Strain = Real(final quantity = "Strain", final unit = "1");
//     type LinearStrain = Strain;
//     type ShearStrain = Strain;
//     type VolumeStrain = Real(final quantity = "VolumeStrain", final unit = "1");
//     type PoissonNumber = Real(final quantity = "PoissonNumber", final unit = "1");
//     type ModulusOfElasticity = Stress;
//     type ShearModulus = Stress;
//     type SecondMomentOfArea = Real(final quantity = "SecondMomentOfArea", final unit = "m4");
//     type SecondPolarMomentOfArea = SecondMomentOfArea;
//     type SectionModulus = Real(final quantity = "SectionModulus", final unit = "m3");
//     type CoefficientOfFriction = Real(final quantity = "CoefficientOfFriction", final unit = "1");
//     type DynamicViscosity = Real(final quantity = "DynamicViscosity", final unit = "Pa.s", min = 0);
//     type KinematicViscosity = Real(final quantity = "KinematicViscosity", final unit = "m2/s", min = 0);
//     type SurfaceTension = Real(final quantity = "SurfaceTension", final unit = "N/m");
//     type Work = Real(final quantity = "Work", final unit = "J");
//     type Energy = Real(final quantity = "Energy", final unit = "J");
//     type EnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3");
//     type PotentialEnergy = Energy;
//     type KineticEnergy = Energy;
//     type Power = Real(final quantity = "Power", final unit = "W");
//     type EnergyFlowRate = Power;
//     type EnthalpyFlowRate = Real(final quantity = "EnthalpyFlowRate", final unit = "W");
//     type Efficiency = Real(final quantity = "Efficiency", final unit = "1", min = 0);
//     type MassFlowRate = Real(quantity = "MassFlowRate", final unit = "kg/s");
//     type VolumeFlowRate = Real(final quantity = "VolumeFlowRate", final unit = "m3/s");
//     type MomentumFlux = Real(final quantity = "MomentumFlux", final unit = "N");
//     type AngularMomentumFlux = Real(final quantity = "AngularMomentumFlux", final unit = "N.m");
//     type ThermodynamicTemperature = Real(final quantity = "ThermodynamicTemperature", final unit = "K", min = 0, displayUnit = "degC");
//     type Temp_K = ThermodynamicTemperature;
//     type Temperature = ThermodynamicTemperature;
//     type CelsiusTemperature = Real(final quantity = "CelsiusTemperature", final unit = "degC");
//     type Temp_C = CelsiusTemperature;
//     type LinearExpansionCoefficient = Real(final quantity = "LinearExpansionCoefficient", final unit = "1/K");
//     type CubicExpansionCoefficient = Real(final quantity = "CubicExpansionCoefficient", final unit = "1/K");
//     type RelativePressureCoefficient = Real(final quantity = "RelativePressureCoefficient", final unit = "1/K");
//     type PressureCoefficient = Real(final quantity = "PressureCoefficient", final unit = "Pa/K");
//     type Compressibility = Real(final quantity = "Compressibility", final unit = "1/Pa");
//     type IsothermalCompressibility = Compressibility;
//     type IsentropicCompressibility = Compressibility;
//     type Heat = Real(final quantity = "Energy", final unit = "J");
//     type HeatFlowRate = Real(final quantity = "Power", final unit = "W");
//     type HeatFlux = Real(final quantity = "HeatFlux", final unit = "W/m^2");
//     type DensityOfHeatFlowRate = Real(final quantity = "DensityOfHeatFlowRate", final unit = "W/m2");
//     type ThermalConductivity = Real(final quantity = "ThermalConductivity", final unit = "W/(m.K)");
//     type CoefficientOfHeatTransfer = Real(final quantity = "CoefficientOfHeatTransfer", final unit = "W/(m2.K)");
//     type SurfaceCoefficientOfHeatTransfer = CoefficientOfHeatTransfer;
//     type ThermalInsulance = Real(final quantity = "ThermalInsulance", final unit = "m2.K/W");
//     type ThermalResistance = Real(final quantity = "ThermalResistance", final unit = "K/W");
//     type ThermalConductance = Real(final quantity = "ThermalConductance", final unit = "W/K");
//     type ThermalDiffusivity = Real(final quantity = "ThermalDiffusivity", final unit = "m2/s");
//     type HeatCapacity = Real(final quantity = "HeatCapacity", final unit = "J/K");
//     type SpecificHeatCapacity = Real(final quantity = "SpecificHeatCapacity", final unit = "J/(kg.K)");
//     type SpecificHeatCapacityAtConstantPressure = SpecificHeatCapacity;
//     type SpecificHeatCapacityAtConstantVolume = SpecificHeatCapacity;
//     type SpecificHeatCapacityAtSaturation = SpecificHeatCapacity;
//     type RatioOfSpecificHeatCapacities = Real(final quantity = "RatioOfSpecificHeatCapacities", final unit = "1");
//     type IsentropicExponent = Real(final quantity = "IsentropicExponent", final unit = "1");
//     type Entropy = Real(final quantity = "Entropy", final unit = "J/K");
//     type SpecificEntropy = Real(final quantity = "SpecificEntropy", final unit = "J/(kg.K)");
//     type InternalEnergy = Heat;
//     type Enthalpy = Heat;
//     type HelmholtzFreeEnergy = Heat;
//     type GibbsFreeEnergy = Heat;
//     type SpecificEnergy = Real(final quantity = "SpecificEnergy", final unit = "J/kg");
//     type SpecificInternalEnergy = SpecificEnergy;
//     type SpecificEnthalpy = SpecificEnergy;
//     type SpecificHelmholtzFreeEnergy = SpecificEnergy;
//     type SpecificGibbsFreeEnergy = SpecificEnergy;
//     type MassieuFunction = Real(final quantity = "MassieuFunction", final unit = "J/K");
//     type PlanckFunction = Real(final quantity = "PlanckFunction", final unit = "J/K");
//     type DerDensityByEnthalpy = Real(final unit = "kg.s^2/m^5");
//     type DerDensityByPressure = Real(final unit = "s^2/m^2");
//     type DerDensityByTemperature = Real(final unit = "kg/(m^3.K)");
//     type DerEnthalpyByPressure = Real(final unit = "J.m.s^2/kg^2");
//     type DerEnergyByDensity = Real(final unit = "J.m^3/kg");
//     type DerEnergyByPressure = Real(final unit = "J.m.s^2/kg");
//     type ElectricCurrent = Real(final quantity = "ElectricCurrent", final unit = "A");
//     type Current = ElectricCurrent;
//     type ElectricCharge = Real(final quantity = "ElectricCharge", final unit = "C");
//     type Charge = ElectricCharge;
//     type VolumeDensityOfCharge = Real(final quantity = "VolumeDensityOfCharge", final unit = "C/m3", min = 0);
//     type SurfaceDensityOfCharge = Real(final quantity = "SurfaceDensityOfCharge", final unit = "C/m2", min = 0);
//     type ElectricFieldStrength = Real(final quantity = "ElectricFieldStrength", final unit = "V/m");
//     type ElectricPotential = Real(final quantity = "ElectricPotential", final unit = "V");
//     type Voltage = ElectricPotential;
//     type PotentialDifference = ElectricPotential;
//     type ElectromotiveForce = ElectricPotential;
//     type ElectricFluxDensity = Real(final quantity = "ElectricFluxDensity", final unit = "C/m2");
//     type ElectricFlux = Real(final quantity = "ElectricFlux", final unit = "C");
//     type Capacitance = Real(final quantity = "Capacitance", final unit = "F", min = 0);
//     type Permittivity = Real(final quantity = "Permittivity", final unit = "F/m", min = 0);
//     type PermittivityOfVacuum = Permittivity;
//     type RelativePermittivity = Real(final quantity = "RelativePermittivity", final unit = "1");
//     type ElectricSusceptibility = Real(final quantity = "ElectricSusceptibility", final unit = "1");
//     type ElectricPolarization = Real(final quantity = "ElectricPolarization", final unit = "C/m2");
//     type Electrization = Real(final quantity = "Electrization", final unit = "V/m");
//     type ElectricDipoleMoment = Real(final quantity = "ElectricDipoleMoment", final unit = "C.m");
//     type CurrentDensity = Real(final quantity = "CurrentDensity", final unit = "A/m2");
//     type LinearCurrentDensity = Real(final quantity = "LinearCurrentDensity", final unit = "A/m");
//     type MagneticFieldStrength = Real(final quantity = "MagneticFieldStrength", final unit = "A/m");
//     type MagneticPotentialDifference = Real(final quantity = "MagneticPotentialDifference", final unit = "A");
//     type MagnetomotiveForce = Real(final quantity = "MagnetomotiveForce", final unit = "A");
//     type CurrentLinkage = Real(final quantity = "CurrentLinkage", final unit = "A");
//     type MagneticFluxDensity = Real(final quantity = "MagneticFluxDensity", final unit = "T");
//     type MagneticFlux = Real(final quantity = "MagneticFlux", final unit = "Wb");
//     type MagneticVectorPotential = Real(final quantity = "MagneticVectorPotential", final unit = "Wb/m");
//     type Inductance = Real(final quantity = "Inductance", final unit = "H");
//     type SelfInductance = Inductance(min = 0);
//     type MutualInductance = Inductance;
//     type CouplingCoefficient = Real(final quantity = "CouplingCoefficient", final unit = "1");
//     type LeakageCoefficient = Real(final quantity = "LeakageCoefficient", final unit = "1");
//     type Permeability = Real(final quantity = "Permeability", final unit = "H/m");
//     type PermeabilityOfVacuum = Permeability;
//     type RelativePermeability = Real(final quantity = "RelativePermeability", final unit = "1");
//     type MagneticSusceptibility = Real(final quantity = "MagneticSusceptibility", final unit = "1");
//     type ElectromagneticMoment = Real(final quantity = "ElectromagneticMoment", final unit = "A.m2");
//     type MagneticDipoleMoment = Real(final quantity = "MagneticDipoleMoment", final unit = "Wb.m");
//     type Magnetization = Real(final quantity = "Magnetization", final unit = "A/m");
//     type MagneticPolarization = Real(final quantity = "MagneticPolarization", final unit = "T");
//     type ElectromagneticEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3");
//     type PoyntingVector = Real(final quantity = "PoyntingVector", final unit = "W/m2");
//     type Resistance = Real(final quantity = "Resistance", final unit = "Ohm", min = 0);
//     type Resistivity = Real(final quantity = "Resistivity", final unit = "Ohm.m");
//     type Conductivity = Real(final quantity = "Conductivity", final unit = "S/m");
//     type Reluctance = Real(final quantity = "Reluctance", final unit = "H-1");
//     type Permeance = Real(final quantity = "Permeance", final unit = "H");
//     type PhaseDifference = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg");
//     type Impedance = Resistance;
//     type ModulusOfImpedance = Resistance;
//     type Reactance = Resistance;
//     type QualityFactor = Real(final quantity = "QualityFactor", final unit = "1");
//     type LossAngle = Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg");
//     type Conductance = Real(final quantity = "Conductance", final unit = "S", min = 0);
//     type Admittance = Conductance;
//     type ModulusOfAdmittance = Conductance;
//     type Susceptance = Conductance;
//     type InstantaneousPower = Real(final quantity = "Power", final unit = "W");
//     type ActivePower = Real(final quantity = "Power", final unit = "W");
//     type ApparentPower = Real(final quantity = "Power", final unit = "VA");
//     type ReactivePower = Real(final quantity = "Power", final unit = "var");
//     type PowerFactor = Real(final quantity = "PowerFactor", final unit = "1");
//     type Transconductance = Real(final quantity = "Transconductance", final unit = "A/(V*V)");
//     type InversePotential = Real(final quantity = "InversePotential", final unit = "1/V");
//     type RadiantEnergy = Real(final quantity = "Energy", final unit = "J");
//     type RadiantEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3");
//     type SpectralRadiantEnergyDensity = Real(final quantity = "SpectralRadiantEnergyDensity", final unit = "J/m4");
//     type RadiantPower = Real(final quantity = "Power", final unit = "W");
//     type RadiantEnergyFluenceRate = Real(final quantity = "RadiantEnergyFluenceRate", final unit = "W/m2");
//     type RadiantIntensity = Real(final quantity = "RadiantIntensity", final unit = "W/sr");
//     type Radiance = Real(final quantity = "Radiance", final unit = "W/sr.m2");
//     type RadiantExtiance = Real(final quantity = "RadiantExtiance", final unit = "W/m2");
//     type Irradiance = Real(final quantity = "Irradiance", final unit = "W/m2");
//     type Emissivity = Real(final quantity = "Emissivity", final unit = "1");
//     type SpectralEmissivity = Real(final quantity = "SpectralEmissivity", final unit = "1");
//     type DirectionalSpectralEmissivity = Real(final quantity = "DirectionalSpectralEmissivity", final unit = "1");
//     type LuminousIntensity = Real(final quantity = "LuminousIntensity", final unit = "cd");
//     type LuminousFlux = Real(final quantity = "LuminousFlux", final unit = "lm");
//     type QuantityOfLight = Real(final quantity = "QuantityOfLight", final unit = "lm.s");
//     type Luminance = Real(final quantity = "Luminance", final unit = "cd/m2");
//     type LuminousExitance = Real(final quantity = "LuminousExitance", final unit = "lm/m2");
//     type Illuminance = Real(final quantity = "Illuminance", final unit = "lx");
//     type LightExposure = Real(final quantity = "LightExposure", final unit = "lx.s");
//     type LuminousEfficacy = Real(final quantity = "LuminousEfficacy", final unit = "lm/W");
//     type SpectralLuminousEfficacy = Real(final quantity = "SpectralLuminousEfficacy", final unit = "lm/W");
//     type LuminousEfficiency = Real(final quantity = "LuminousEfficiency", final unit = "1");
//     type SpectralLuminousEfficiency = Real(final quantity = "SpectralLuminousEfficiency", final unit = "1");
//     type CIESpectralTristimulusValues = Real(final quantity = "CIESpectralTristimulusValues", final unit = "1");
//     type ChromaticityCoordinates = Real(final quantity = "CromaticityCoordinates", final unit = "1");
//     type SpectralAbsorptionFactor = Real(final quantity = "SpectralAbsorptionFactor", final unit = "1");
//     type SpectralReflectionFactor = Real(final quantity = "SpectralReflectionFactor", final unit = "1");
//     type SpectralTransmissionFactor = Real(final quantity = "SpectralTransmissionFactor", final unit = "1");
//     type SpectralRadianceFactor = Real(final quantity = "SpectralRadianceFactor", final unit = "1");
//     type LinearAttenuationCoefficient = Real(final quantity = "AttenuationCoefficient", final unit = "m-1");
//     type LinearAbsorptionCoefficient = Real(final quantity = "LinearAbsorptionCoefficient", final unit = "m-1");
//     type MolarAbsorptionCoefficient = Real(final quantity = "MolarAbsorptionCoefficient", final unit = "m2/mol");
//     type RefractiveIndex = Real(final quantity = "RefractiveIndex", final unit = "1");
//     type StaticPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0);
//     type SoundPressure = StaticPressure;
//     type SoundParticleDisplacement = Real(final quantity = "Length", final unit = "m");
//     type SoundParticleVelocity = Real(final quantity = "Velocity", final unit = "m/s");
//     type SoundParticleAcceleration = Real(final quantity = "Acceleration", final unit = "m/s2");
//     type VelocityOfSound = Real(final quantity = "Velocity", final unit = "m/s");
//     type SoundEnergyDensity = Real(final quantity = "EnergyDensity", final unit = "J/m3");
//     type SoundPower = Real(final quantity = "Power", final unit = "W");
//     type SoundIntensity = Real(final quantity = "SoundIntensity", final unit = "W/m2");
//     type AcousticImpedance = Real(final quantity = "AcousticImpedance", final unit = "Pa.s/m3");
//     type SpecificAcousticImpedance = Real(final quantity = "SpecificAcousticImpedance", final unit = "Pa.s/m");
//     type MechanicalImpedance = Real(final quantity = "MechanicalImpedance", final unit = "N.s/m");
//     type SoundPressureLevel = Real(final quantity = "SoundPressureLevel", final unit = "dB");
//     type SoundPowerLevel = Real(final quantity = "SoundPowerLevel", final unit = "dB");
//     type DissipationCoefficient = Real(final quantity = "DissipationCoefficient", final unit = "1");
//     type ReflectionCoefficient = Real(final quantity = "ReflectionCoefficient", final unit = "1");
//     type TransmissionCoefficient = Real(final quantity = "TransmissionCoefficient", final unit = "1");
//     type AcousticAbsorptionCoefficient = Real(final quantity = "AcousticAbsorptionCoefficient", final unit = "1");
//     type SoundReductionIndex = Real(final quantity = "SoundReductionIndex", final unit = "dB");
//     type EquivalentAbsorptionArea = Real(final quantity = "Area", final unit = "m2");
//     type ReverberationTime = Real(final quantity = "Time", final unit = "s");
//     type LoundnessLevel = Real(final quantity = "LoundnessLevel", final unit = "phon");
//     type Loundness = Real(final quantity = "Loundness", final unit = "sone");
//     type RelativeAtomicMass = Real(final quantity = "RelativeAtomicMass", final unit = "1");
//     type RelativeMolecularMass = Real(final quantity = "RelativeMolecularMass", final unit = "1");
//     type NumberOfMolecules = Real(final quantity = "NumberOfMolecules", final unit = "1");
//     type AmountOfSubstance = Real(final quantity = "AmountOfSubstance", final unit = "mol", min = 0);
//     type MolarMass = Real(final quantity = "MolarMass", final unit = "kg/mol");
//     type MolarVolume = Real(final quantity = "MolarVolume", final unit = "m3/mol");
//     type MolarInternalEnergy = Real(final quantity = "MolarInternalEnergy", final unit = "J/mol");
//     type MolarHeatCapacity = Real(final quantity = "MolarHeatCapacity", final unit = "J/(mol.K)");
//     type MolarEntropy = Real(final quantity = "MolarEntropy", final unit = "J/(mol.K)");
//     type NumberDensityOfMolecules = Real(final quantity = "NumberDensityOfMolecules", final unit = "m-3");
//     type MolecularConcentration = Real(final quantity = "MolecularConcentration", final unit = "m-3");
//     type MassConcentration = Real(final quantity = "MassConcentration", final unit = "kg/m3");
//     type MassFraction = Real(final quantity = "MassFraction", final unit = "1");
//     type Concentration = Real(final quantity = "Concentration", final unit = "mol/m3");
//     type VolumeFraction = Real(final quantity = "VolumeFraction", final unit = "1");
//     type MoleFraction = Real(final quantity = "MoleFraction", final unit = "1");
//     type ChemicalPotential = Real(final quantity = "ChemicalPotential", final unit = "J/mol");
//     type AbsoluteActivity = Real(final quantity = "AbsoluteActivity", final unit = "1");
//     type PartialPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0);
//     type Fugacity = Real(final quantity = "Fugacity", final unit = "Pa");
//     type StandardAbsoluteActivity = Real(final quantity = "StandardAbsoluteActivity", final unit = "1");
//     type ActivityCoefficient = Real(final quantity = "ActivityCoefficient", final unit = "1");
//     type ActivityOfSolute = Real(final quantity = "ActivityOfSolute", final unit = "1");
//     type ActivityCoefficientOfSolute = Real(final quantity = "ActivityCoefficientOfSolute", final unit = "1");
//     type StandardAbsoluteActivityOfSolute = Real(final quantity = "StandardAbsoluteActivityOfSolute", final unit = "1");
//     type ActivityOfSolvent = Real(final quantity = "ActivityOfSolvent", final unit = "1");
//     type OsmoticCoefficientOfSolvent = Real(final quantity = "OsmoticCoefficientOfSolvent", final unit = "1");
//     type StandardAbsoluteActivityOfSolvent = Real(final quantity = "StandardAbsoluteActivityOfSolvent", final unit = "1");
//     type OsmoticPressure = Real(final quantity = "Pressure", final unit = "Pa", displayUnit = "bar", min = 0);
//     type StoichiometricNumber = Real(final quantity = "StoichiometricNumber", final unit = "1");
//     type Affinity = Real(final quantity = "Affinity", final unit = "J/mol");
//     type MassOfMolecule = Real(final quantity = "Mass", final unit = "kg");
//     type ElectricDipoleMomentOfMolecule = Real(final quantity = "ElectricDipoleMomentOfMolecule", final unit = "C.m");
//     type ElectricPolarizabilityOfAMolecule = Real(final quantity = "ElectricPolarizabilityOfAMolecule", final unit = "C.m2/V");
//     type MicrocanonicalPartitionFunction = Real(final quantity = "MicrocanonicalPartitionFunction", final unit = "1");
//     type CanonicalPartitionFunction = Real(final quantity = "CanonicalPartitionFunction", final unit = "1");
//     type GrandCanonicalPartitionFunction = Real(final quantity = "GrandCanonicalPartitionFunction", final unit = "1");
//     type MolecularPartitionFunction = Real(final quantity = "MolecularPartitionFunction", final unit = "1");
//     type StatisticalWeight = Real(final quantity = "StatisticalWeight", final unit = "1");
//     type MeanFreePath = Length;
//     type DiffusionCoefficient = Real(final quantity = "DiffusionCoefficient", final unit = "m2/s");
//     type ThermalDiffusionRatio = Real(final quantity = "ThermalDiffusionRatio", final unit = "1");
//     type ThermalDiffusionFactor = Real(final quantity = "ThermalDiffusionFactor", final unit = "1");
//     type ThermalDiffusionCoefficient = Real(final quantity = "ThermalDiffusionCoefficient", final unit = "m2/s");
//     type ElementaryCharge = Real(final quantity = "ElementaryCharge", final unit = "C");
//     type ChargeNumberOfIon = Real(final quantity = "ChargeNumberOfIon", final unit = "1");
//     type FaradayConstant = Real(final quantity = "FaradayConstant", final unit = "C/mol");
//     type IonicStrength = Real(final quantity = "IonicStrength", final unit = "mol/kg");
//     type DegreeOfDissociation = Real(final quantity = "DegreeOfDissociation", final unit = "1");
//     type ElectrolyticConductivity = Real(final quantity = "ElectrolyticConductivity", final unit = "S/m");
//     type MolarConductivity = Real(final quantity = "MolarConductivity", final unit = "S.m2/mol");
//     type TransportNumberOfIonic = Real(final quantity = "TransportNumberOfIonic", final unit = "1");
//     type ProtonNumber = Real(final quantity = "ProtonNumber", final unit = "1");
//     type NeutronNumber = Real(final quantity = "NeutronNumber", final unit = "1");
//     type NucleonNumber = Real(final quantity = "NucleonNumber", final unit = "1");
//     type AtomicMassConstant = Real(final quantity = "Mass", final unit = "kg");
//     type MassOfElectron = Real(final quantity = "Mass", final unit = "kg");
//     type MassOfProton = Real(final quantity = "Mass", final unit = "kg");
//     type MassOfNeutron = Real(final quantity = "Mass", final unit = "kg");
//     type HartreeEnergy = Real(final quantity = "Energy", final unit = "J");
//     type MagneticMomentOfParticle = Real(final quantity = "MagneticMomentOfParticle", final unit = "A.m2");
//     type BohrMagneton = MagneticMomentOfParticle;
//     type NuclearMagneton = MagneticMomentOfParticle;
//     type GyromagneticCoefficient = Real(final quantity = "GyromagneticCoefficient", final unit = "A.m2/(J.s)");
//     type GFactorOfAtom = Real(final quantity = "GFactorOfAtom", final unit = "1");
//     type GFactorOfNucleus = Real(final quantity = "GFactorOfNucleus", final unit = "1");
//     type LarmorAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1");
//     type NuclearPrecessionAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1");
//     type CyclotronAngularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1");
//     type NuclearQuadrupoleMoment = Real(final quantity = "NuclearQuadrupoleMoment", final unit = "m2");
//     type NuclearRadius = Real(final quantity = "Length", final unit = "m");
//     type ElectronRadius = Real(final quantity = "Length", final unit = "m");
//     type ComptonWavelength = Real(final quantity = "Length", final unit = "m");
//     type MassExcess = Real(final quantity = "Mass", final unit = "kg");
//     type MassDefect = Real(final quantity = "Mass", final unit = "kg");
//     type RelativeMassExcess = Real(final quantity = "RelativeMassExcess", final unit = "1");
//     type RelativeMassDefect = Real(final quantity = "RelativeMassDefect", final unit = "1");
//     type PackingFraction = Real(final quantity = "PackingFraction", final unit = "1");
//     type BindingFraction = Real(final quantity = "BindingFraction", final unit = "1");
//     type MeanLife = Real(final quantity = "Time", final unit = "s");
//     type LevelWidth = Real(final quantity = "LevelWidth", final unit = "J");
//     type Activity = Real(final quantity = "Activity", final unit = "Bq");
//     type SpecificActivity = Real(final quantity = "SpecificActivity", final unit = "Bq/kg");
//     type DecayConstant = Real(final quantity = "DecayConstant", final unit = "s-1");
//     type HalfLife = Real(final quantity = "Time", final unit = "s");
//     type AlphaDisintegrationEnergy = Real(final quantity = "Energy", final unit = "J");
//     type MaximumBetaParticleEnergy = Real(final quantity = "Energy", final unit = "J");
//     type BetaDisintegrationEnergy = Real(final quantity = "Energy", final unit = "J");
//     type ReactionEnergy = Real(final quantity = "Energy", final unit = "J");
//     type ResonanceEnergy = Real(final quantity = "Energy", final unit = "J");
//     type CrossSection = Real(final quantity = "Area", final unit = "m2");
//     type TotalCrossSection = Real(final quantity = "Area", final unit = "m2");
//     type AngularCrossSection = Real(final quantity = "AngularCrossSection", final unit = "m2/sr");
//     type SpectralCrossSection = Real(final quantity = "SpectralCrossSection", final unit = "m2/J");
//     type SpectralAngularCrossSection = Real(final quantity = "SpectralAngularCrossSection", final unit = "m2/(sr.J)");
//     type MacroscopicCrossSection = Real(final quantity = "MacroscopicCrossSection", final unit = "m-1");
//     type TotalMacroscopicCrossSection = Real(final quantity = "TotalMacroscopicCrossSection", final unit = "m-1");
//     type ParticleFluence = Real(final quantity = "ParticleFluence", final unit = "m-2");
//     type ParticleFluenceRate = Real(final quantity = "ParticleFluenceRate", final unit = "s-1.m2");
//     type EnergyFluence = Real(final quantity = "EnergyFluence", final unit = "J/m2");
//     type EnergyFluenceRate = Real(final quantity = "EnergyFluenceRate", final unit = "W/m2");
//     type CurrentDensityOfParticles = Real(final quantity = "CurrentDensityOfParticles", final unit = "m-2.s-1");
//     type MassAttenuationCoefficient = Real(final quantity = "MassAttenuationCoefficient", final unit = "m2/kg");
//     type MolarAttenuationCoefficient = Real(final quantity = "MolarAttenuationCoefficient", final unit = "m2/mol");
//     type AtomicAttenuationCoefficient = Real(final quantity = "AtomicAttenuationCoefficient", final unit = "m2");
//     type HalfThickness = Real(final quantity = "Length", final unit = "m");
//     type TotalLinearStoppingPower = Real(final quantity = "TotalLinearStoppingPower", final unit = "J/m");
//     type TotalAtomicStoppingPower = Real(final quantity = "TotalAtomicStoppingPower", final unit = "J.m2");
//     type TotalMassStoppingPower = Real(final quantity = "TotalMassStoppingPower", final unit = "J.m2/kg");
//     type MeanLinearRange = Real(final quantity = "Length", final unit = "m");
//     type MeanMassRange = Real(final quantity = "MeanMassRange", final unit = "kg/m2");
//     type LinearIonization = Real(final quantity = "LinearIonization", final unit = "m-1");
//     type TotalIonization = Real(final quantity = "TotalIonization", final unit = "1");
//     type Mobility = Real(final quantity = "Mobility", final unit = "m2/V.s");
//     type IonNumberDensity = Real(final quantity = "IonNumberDensity", final unit = "m-3");
//     type RecombinationCoefficient = Real(final quantity = "RecombinationCoefficient", final unit = "m3/s");
//     type NeutronNumberDensity = Real(final quantity = "NeutronNumberDensity", final unit = "m-3");
//     type NeutronSpeed = Real(final quantity = "Velocity", final unit = "m/s");
//     type NeutronFluenceRate = Real(final quantity = "NeutronFluenceRate", final unit = "s-1.m-2");
//     type TotalNeutronSourceDensity = Real(final quantity = "TotalNeutronSourceDesity", final unit = "s-1.m-3");
//     type SlowingDownDensity = Real(final quantity = "SlowingDownDensity", final unit = "s-1.m-3");
//     type ResonanceEscapeProbability = Real(final quantity = "ResonanceEscapeProbability", final unit = "1");
//     type Lethargy = Real(final quantity = "Lethargy", final unit = "1");
//     type SlowingDownArea = Real(final quantity = "Area", final unit = "m2");
//     type DiffusionArea = Real(final quantity = "Area", final unit = "m2");
//     type MigrationArea = Real(final quantity = "Area", final unit = "m2");
//     type SlowingDownLength = Real(final quantity = "SLength", final unit = "m");
//     type DiffusionLength = Length;
//     type MigrationLength = Length;
//     type NeutronYieldPerFission = Real(final quantity = "NeutronYieldPerFission", final unit = "1");
//     type NeutronYieldPerAbsorption = Real(final quantity = "NeutronYieldPerAbsorption", final unit = "1");
//     type FastFissionFactor = Real(final quantity = "FastFissionFactor", final unit = "1");
//     type ThermalUtilizationFactor = Real(final quantity = "ThermalUtilizationFactor", final unit = "1");
//     type NonLeakageProbability = Real(final quantity = "NonLeakageProbability", final unit = "1");
//     type Reactivity = Real(final quantity = "Reactivity", final unit = "1");
//     type ReactorTimeConstant = Real(final quantity = "Time", final unit = "s");
//     type EnergyImparted = Real(final quantity = "Energy", final unit = "J");
//     type MeanEnergyImparted = Real(final quantity = "Energy", final unit = "J");
//     type SpecificEnergyImparted = Real(final quantity = "SpecificEnergy", final unit = "Gy");
//     type AbsorbedDose = Real(final quantity = "AbsorbedDose", final unit = "Gy");
//     type DoseEquivalent = Real(final quantity = "DoseEquivalent", final unit = "Sv");
//     type AbsorbedDoseRate = Real(final quantity = "AbsorbedDoseRate", final unit = "Gy/s");
//     type LinearEnergyTransfer = Real(final quantity = "LinearEnergyTransfer", final unit = "J/m");
//     type Kerma = Real(final quantity = "Kerma", final unit = "Gy");
//     type KermaRate = Real(final quantity = "KermaRate", final unit = "Gy/s");
//     type MassEnergyTransferCoefficient = Real(final quantity = "MassEnergyTransferCoefficient", final unit = "m2/kg");
//     type Exposure = Real(final quantity = "Exposure", final unit = "C/kg");
//     type ExposureRate = Real(final quantity = "ExposureRate", final unit = "C/(kg.s)");
//     type ReynoldsNumber = Real(final quantity = "ReynoldsNumber", final unit = "1");
//     type EulerNumber = Real(final quantity = "EulerNumber", final unit = "1");
//     type FroudeNumber = Real(final quantity = "FroudeNumber", final unit = "1");
//     type GrashofNumber = Real(final quantity = "GrashofNumber", final unit = "1");
//     type WeberNumber = Real(final quantity = "WeberNumber", final unit = "1");
//     type MachNumber = Real(final quantity = "MachNumber", final unit = "1");
//     type KnudsenNumber = Real(final quantity = "KnudsenNumber", final unit = "1");
//     type StrouhalNumber = Real(final quantity = "StrouhalNumber", final unit = "1");
//     type FourierNumber = Real(final quantity = "FourierNumber", final unit = "1");
//     type PecletNumber = Real(final quantity = "PecletNumber", final unit = "1");
//     type RayleighNumber = Real(final quantity = "RayleighNumber", final unit = "1");
//     type NusseltNumber = Real(final quantity = "NusseltNumber", final unit = "1");
//     type BiotNumber = NusseltNumber;
//     type StantonNumber = Real(final quantity = "StantonNumber", final unit = "1");
//     type FourierNumberOfMassTransfer = Real(final quantity = "FourierNumberOfMassTransfer", final unit = "1");
//     type PecletNumberOfMassTransfer = Real(final quantity = "PecletNumberOfMassTransfer", final unit = "1");
//     type GrashofNumberOfMassTransfer = Real(final quantity = "GrashofNumberOfMassTransfer", final unit = "1");
//     type NusseltNumberOfMassTransfer = Real(final quantity = "NusseltNumberOfMassTransfer", final unit = "1");
//     type StantonNumberOfMassTransfer = Real(final quantity = "StantonNumberOfMassTransfer", final unit = "1");
//     type PrandtlNumber = Real(final quantity = "PrandtlNumber", final unit = "1");
//     type SchmidtNumber = Real(final quantity = "SchmidtNumber", final unit = "1");
//     type LewisNumber = Real(final quantity = "LewisNumber", final unit = "1");
//     type MagneticReynoldsNumber = Real(final quantity = "MagneticReynoldsNumber", final unit = "1");
//     type AlfvenNumber = Real(final quantity = "AlfvenNumber", final unit = "1");
//     type HartmannNumber = Real(final quantity = "HartmannNumber", final unit = "1");
//     type CowlingNumber = Real(final quantity = "CowlingNumber", final unit = "1");
//     type BraggAngle = Angle;
//     type OrderOfReflexion = Real(final quantity = "OrderOfReflexion", final unit = "1");
//     type ShortRangeOrderParameter = Real(final quantity = "RangeOrderParameter", final unit = "1");
//     type LongRangeOrderParameter = Real(final quantity = "RangeOrderParameter", final unit = "1");
//     type DebyeWallerFactor = Real(final quantity = "DebyeWallerFactor", final unit = "1");
//     type CircularWavenumber = Real(final quantity = "CircularWavenumber", final unit = "m-1");
//     type FermiCircularWavenumber = Real(final quantity = "FermiCircularWavenumber", final unit = "m-1");
//     type DebyeCircularWavenumber = Real(final quantity = "DebyeCircularWavenumber", final unit = "m-1");
//     type DebyeCircularFrequency = Real(final quantity = "AngularFrequency", final unit = "s-1");
//     type DebyeTemperature = ThermodynamicTemperature;
//     type SpectralConcentration = Real(final quantity = "SpectralConcentration", final unit = "s/m3");
//     type GrueneisenParameter = Real(final quantity = "GrueneisenParameter", final unit = "1");
//     type MadelungConstant = Real(final quantity = "MadelungConstant", final unit = "1");
//     type DensityOfStates = Real(final quantity = "DensityOfStates", final unit = "J-1/m-3");
//     type ResidualResistivity = Real(final quantity = "ResidualResistivity", final unit = "Ohm.m");
//     type LorenzCoefficient = Real(final quantity = "LorenzCoefficient", final unit = "V2/K2");
//     type HallCoefficient = Real(final quantity = "HallCoefficient", final unit = "m3/C");
//     type ThermoelectromotiveForce = Real(final quantity = "ThermoelectromotiveForce", final unit = "V");
//     type SeebeckCoefficient = Real(final quantity = "SeebeckCoefficient", final unit = "V/K");
//     type PeltierCoefficient = Real(final quantity = "PeltierCoefficient", final unit = "V");
//     type ThomsonCoefficient = Real(final quantity = "ThomsonCoefficient", final unit = "V/K");
//     type RichardsonConstant = Real(final quantity = "RichardsonConstant", final unit = "A/(m2.K2)");
//     type FermiEnergy = Real(final quantity = "Energy", final unit = "eV");
//     type GapEnergy = Real(final quantity = "Energy", final unit = "eV");
//     type DonorIonizationEnergy = Real(final quantity = "Energy", final unit = "eV");
//     type AcceptorIonizationEnergy = Real(final quantity = "Energy", final unit = "eV");
//     type FermiTemperature = ThermodynamicTemperature;
//     type ElectronNumberDensity = Real(final quantity = "ElectronNumberDensity", final unit = "m-3");
//     type HoleNumberDensity = Real(final quantity = "HoleNumberDensity", final unit = "m-3");
//     type IntrinsicNumberDensity = Real(final quantity = "IntrinsicNumberDensity", final unit = "m-3");
//     type DonorNumberDensity = Real(final quantity = "DonorNumberDensity", final unit = "m-3");
//     type AcceptorNumberDensity = Real(final quantity = "AcceptorNumberDensity", final unit = "m-3");
//     type EffectiveMass = Mass;
//     type MobilityRatio = Real(final quantity = "MobilityRatio", final unit = "1");
//     type RelaxationTime = Time;
//     type CarrierLifeTime = Time;
//     type ExchangeIntegral = Real(final quantity = "Energy", final unit = "eV");
//     type CurieTemperature = ThermodynamicTemperature;
//     type NeelTemperature = ThermodynamicTemperature;
//     type LondonPenetrationDepth = Length;
//     type CoherenceLength = Length;
//     type LandauGinzburgParameter = Real(final quantity = "LandauGinzburgParameter", final unit = "1");
//     type FluxiodQuantum = Real(final quantity = "FluxiodQuantum", final unit = "Wb");
//     annotation(Window(x = 0.08, y = 0.04, width = 0.58, height = 0.84, library = 1, autolayout = 1), Invisible = true, Icon(Text(extent = [ -63, -13;45, -67], string = "[kg.m2]", style(color = 0))), Documentation(info = "<html>
// 
// <p>This package provides predefined types, such as <i>Mass</i>,
// <i>Length</i>, <i>Time</i>, based on the international standard
// on units:</p>
// 
// <ul>
// <li>ISO 31-1992 \"General principles concerning
//     quantities, units and symbols\"</li>
// <li>ISO 1000-1992 \"SI units and recommendations for the use
//     of their multiples and of certain other units\".</li>
// </ul>
// 
// <p>For more information on units, see also the book of
// Francois Cardarelli \"Scientific Unit Conversion - A Practical
// Guide to Metrication\"
// (Springer 1997).</p>
// 
// <p>The following conventions are used in this package:</p>
// 
// <ul>
// <li>Modelica quantity names are defined according to the recommendations
//     of ISO 31. Some of these name are rather long, such as
//     \"ThermodynamicTemperature\". Shorter alias names are defined, e.g.,
//     \"type Temp_K = ThermodynamicTemperature;\".</li>
// 
// <li>Modelica units are defined according to the SI base units without
//     multiples (only exception \"kg\").</li>
// 
// <li>For some quantities, more convenient units for an engineer are
//     defined as \"displayUnit\", i.e., the default unit for display
//     purposes (e.g., displayUnit=\"deg\" for quantity=\"Angle\").</li>
// 
// <li>The type name is identical to the quantity name, following
//     the convention of type names.</li>
// 
// <li>All quantity and unit attributes are defined as final in order
//     that they cannot be redefined to another value.</li>
// 
// <li>Similiar quantities, such as \"Length, Breadth, Height, Thickness,
//     Radius\" are defined as the same quantity (here: \"Length\").</li>
// 
// <li>The ordering of the type declarations in this package follows ISO 31:
// <pre>
//   Chapter  1: <b>Space and Time</b>
//   Chapter  2: <b>Periodic and Related Phenomena</b>
//   Chapter  3: <b>Mechanics</b>
//   Chapter  4: <b>Heat</b>
//   Chapter  5: <b>Electricity and Magnetism</b>
//   Chapter  6: <b>Light and Related Electro-Magnetic Radiations</b>
//   Chapter  7: <b>Acoustics</b>
//   Chapter  8: <b>Physical Chemistry</b>
//   Chapter  9: <b>Atomic and Nuclear Physics</b>
//   Chapter 10: <b>Nuclear Reactions and Ionizing Radiations</b>
//   Chapter 11: (not defined in ISO 31-1992)
//   Chapter 12: <b>Characteristic Numbers</b>
//   Chapter 13: <b>Solid State Physics</b>
// </pre>
// </li>
// 
// <li>Conversion functions between SI and non-SI units are available in subpackage
//     <b>Conversions</b>.</li>
// </ul>
// 
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)<br>
//     Oberpfaffenhofen<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <br>
// 
// 
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>October 21, 2002</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
//        Added new package <b>Conversions</b>. Corrected typo <i>Wavelenght</i>.</li>
// 
// <li><i>June 6, 2000</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Introduced the following new types<br>
//        type Temperature = ThermodynamicTemperature;<br>
//        types DerDensityByEnthalpy, DerDensityByPressure,
//        DerDensityByTemperature, DerEnthalpyByPressure,
//        DerEnergyByDensity, DerEnergyByPressure<br>
//        Attribute \"final\" removed from min and max values
//        in order that these values can still be changed to narrow
//        the allowed range of values.<br>
//        Quantity=\"Stress\" removed from type \"Stress\", in order
//        that a type \"Stress\" can be connected to a type \"Pressure\".</li>
// 
// <li><i>Oct. 27, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        New types due to electrical library: Transconductance, InversePotential,
//        Damping.</li>
// 
// <li><i>Sept. 18, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Renamed from SIunit to SIunits. Subpackages expanded, i.e., the
//        SIunits package, does no longer contain subpackages.</li>
// 
// <li><i>Aug 12, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Type \"Pressure\" renamed to \"AbsolutePressure\" and introduced a new
//        type \"Pressure\" which does not contain a minimum of zero in order
//        to allow convenient handling of relative pressure. Redefined
//        BulkModulus as an alias to AbsolutePressure instead of Stress, since
//        needed in hydraulics.</li>
// 
// <li><i>June 29, 1999</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
//        Bug-fix: Double definition of \"Compressibility\" removed
//        and appropriate \"extends Heat\" clause introduced in
//        package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
// 
// <li><i>April 8, 1998</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and Astrid Jaschinski:<br>
//        Complete ISO 31 chapters realized.</li>
// 
// <li><i>Nov. 15, 1997</i>
//        by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
//        and <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a>:<br>
//        Some chapters realized.</li>
// </ul>
// <br>
// 
// <p><b>Copyright &copy; 1999-2002, Modelica Association and DLR.</b></p>
// 
// <p><i>The Modelica package is free software; it can be redistributed and/or modified
// under the terms of the <b>Modelica license</b>, see the license conditions
// and the accompanying <b>disclaimer</b> in the documentation of package
// Modelica in file \"Modelica/package.mo\".</i></p>
// 
// </HTML>"), Diagram(Rectangle(extent = [169,86;349,236], style(fillColor = 30, fillPattern = 1)), Polygon(points = [169,236;189,256;369,256;349,236;169,236], style(fillColor = 30, fillPattern = 1)), Polygon(points = [369,256;369,106;349,86;349,236;369,256], style(fillColor = 30, fillPattern = 1)), Text(extent = [179,226;339,196], string = "Library", style(color = 9, fillColor = 0, fillPattern = 1)), Text(extent = [206,173;314,119], string = "[kg.m2]", style(color = 0)), Text(extent = [163,320;406,264], string = "Modelica.SIunits", style(color = 1))));
//   end SIunits;
// end Modelica;
// 
// "
// endResult
