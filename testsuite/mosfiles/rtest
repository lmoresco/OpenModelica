#!/usr/bin/perl -w


$OPENMODELICAHOME = $ENV{'OPENMODELICAHOME'};
$pathToOMC = $OPENMODELICAHOME."/bin/omc";

$gotone = 0;
$threads=2;

$successes=0;
$total=0;
$setbaseline=0;
$verbose="yes";
$pager="cat";
$log="";
$thisStartTime = "".time();
$uniqueId = $$."-".$thisStartTime;
$tmpPath = "/tmp/omctesting/"; # double slash to work on *nix to.
$tmp1 = "$tmpPath/equations-1-".$uniqueId;
$tmp2 = "$tmpPath/equations-2-".$uniqueId;
$tmp3 = "$tmpPath/equations-diff-".$uniqueId;
$tmp4 = "$tmpPath/baseline-".$uniqueId;
$retString ="";
@keys = ();
$collectkeys = 0;
$collectcases = 0;
%knownkeys = ();
$filearg = 0;
$status = 0;
$statusfilter = "all";
$epsilon = 1.0e-3;

# Creates a baseline, i.e. the stores the actual result as the expected result
sub setbaseline
{

    my $f = shift;
    $log = "$tmpPath/log-".$uniqueId."-$f";
	
	system "$pathToOMC $f >$log 2>&1";
	
    open(RES,">$tmp4");
    open(LOG,"<$log");    
    open(SRC,"<$f");
    
    while(<SRC>) {
     if (/^\/\/ Result:/../^\/\/ endResult/) {
       
      } else {
	print RES $_;
      }
    }
    print RES "// Result:\n";
    while(<LOG>) {
	print RES "// ";
	  print RES $_;
        
    }
    print RES "// endResult\n";
    close RES;
    close LOG;
    close SRC;
    print "Set baseline for ";print $f;print "\n"; 
    $total = $total + 1;
    
    open(SRC,"<$tmp4");
    open(DST,">$f");
    while(<SRC>) {
      print DST $_;
    } 
    return 0;
}

sub runone
{
    my $mismatch = 0;
    my ($f,%info) = @_;
	
	
	$preTime = time();
	
	
    system "$pathToOMC $f >$log 2>&1";
#    system "../Compiler/omc +d=daedump $f >$log 2>&1";
#    system "../omc $f >$log 2>&1";
    
    if ( $? != 0 ) {
	if ($info{"status"} eq "incorrect") {
		$runTime = time() - $preTime;
		$retString  = "ok [time: ".$runTime."]\n";	    
	    return 0;
	}
	$retString = "nonzero exit status\n";
	return 1;
    }

    system "egrep -s '^#|Execution failed!' $log";
    if ( $? == 0 ) {
	if ($info{"status"} eq "incorrect") {
	    $runTime = time() - $preTime;
		$retString = "ok [time: ".$runTime."]\n";
	    return 0;
	}
	$retString = "execution failed\n";
	return 1;
    }

    if ($info{"status"} eq "incorrect") {
	$retString = "this test should have failed\n";
	return 1;
    }

    # Extract the result
    open(RES,">$tmp1");
    open(LOG,"<$log");
    while(<LOG>) {
      s/^[ \t]*//;
      s/[ \t]+/ /;
      print RES $_;
    }
    close LOG;
    close RES;

    # Compare
    # system "sort $tmp1 > $tmp1-sorted";
    # system "sort $tmp2 > $tmp2-sorted";
    system "diff -w $tmp1 $tmp2 > $tmp3";

	# adrpo - 2006-12-06 
	# if we have only numbers see if their difference is < 1.0e-5 
	# which is the dassl integration step!
	# some array for handline what we "expect" and what we "got"
	my @expect; 
    my @got;
    my $majorNumberDifferences = 0;
	my $corrCounter = 0;
	my $totCounter = 0;
    
    if ( $? != 0 ) 
    {  
      # open the log first, as we need to put in the differences!
      open(LOG,">>$log");
	  print LOG "\n";
	  print LOG "Equation diff:\n\n";
    
	  open(DIFF,"<$tmp3");
	  while(<DIFF>) 
	  {
	      if (/^>(.*)$/) 
	      {
	      	my $line = $1;
	      	chomp($line);
	      	$line = trim($line);
		  	push @expect, $line; # push the expected content in @expect
	      } 
	      elsif (/^<(.*)$/) 
	      {
	      	my $line = $1;
	      	chomp($line);
	      	$line = trim($line);
	      	push @got, $line;    # push the calculated content in @got
	      }
	  }
	  close DIFF;
	  # now we have what we need in @expect and @got
	  if (@expect == @got) # are they equal in size?
	  {
		  while ( my $e = pop @expect )
	      { 
	    	my $g = pop @got;
#print("RAW-1: ($e) \nvs\nRAW-2: ($g)\n");
	    	#check if $e and $g are numbers or arrays!
	    	# first try normal numbers!
	    	if (isNumber($e) && isNumber($g))
	    	{
#				print(" is NUmber\n\n");
	    		if (LessThanEpsilon($e,$g,$epsilon) == 0)
	    		{
		    	  print LOG "expected:$e - got:$g > epsilon-1:$epsilon\n";
		    	  $majorNumberDifferences = 1;
		    	  goto DEFAULT;	    			
	    		}
	    		else
	    		{ 
					if(!($e == $g)){
						print LOG "expected:$e - got:$g < epsilon:$epsilon\n";
					}
	    		}
	    	}
	    	else # here we should have arrays of numbers {0.1, 1.2, ..., nn.mm}
	    	{
#				print(" ENTER #2\n");
	    		# get rid of { and }				
				$e =~ s/\(//g; $e =~ s/\)//g; 
	    		$g =~ s/\(//g; $g =~ s/\)//g; 
	    		$e =~ s/\{//g; $e =~ s/\}//g; $e =~ s/  / /g;
	    		$g =~ s/\{//g; $g =~ s/\}//g; $g =~ s/  / /g;
				
	    		@expect_array = split /,/ , $e;
	    		@got_array = split /,/ , $g;
				@expect_array2 = split /,/ , $e;
				@got_array2 = split /,/ , $g;
	  			if (@expect_array == @got_array) # are they equal in size?
	  			{
#					print(" EQUAL SIZE \n");
#					print(@expect_array); print( "\n"); print(@got_array); print("\n");
#					print($#expect_array . "\n");

#						print(@expect_array2); print("\n");
#						print(@got_array2); print("\n");
						while($#expect_array2 >= 0)
						{
#print($#expect_array2 . "\n");
#print($#got_array2 . "\n");
						my $ec1 = pop @expect_array2;
						my $ec2 = pop @got_array2;
#print(" raw: ($ec1) vs ($ec2)\n");

						@field=split(/ /,$ec1);
						@field2=split(/ /,$ec2);
						while ($#field >=0)
						{
#							print(" ENTER FIELD\n");
							my $ecf1 = pop @field;
							my $ecf2 = pop @field2;
#print "$ecf1 -VS- $ecf2\n";
						
							if (isNumber($ecf2) && isNumber($ecf1))
							{
#print(" --NUMBER expected($ecf1) got($ecf2)\n");
								if (LessThanEpsilon($ecf2,$ecf1,$epsilon) == 0)
								{
									print LOG "expected:$ecf1 - got:$ecf2 > epsilon-3:$epsilon\n";
#										print(" ERROR ");
									$majorNumberDifferences = 1;
									goto DEFAULT;	    			
								}
								if (LessThanEpsilon($ecf2,$ecf1,$epsilon) == 1)
								{
#										print(" OK ");
								}
							}
							else
							{
#								print(" NONUMBER expected($ecf1) got($ecf2)\n");
								if(! ($ecf2 eq $ecf1))
								{
									print LOG "expected:$ecf1 - got:$ecf2 > epsilon-4:$epsilon\n";
									$majorNumberDifferences = 1;
									goto DEFAULT;
								}
							}
						}
#						print(" left: @field and @field2 \n");
					}
					$corrCounter = $totCounter;
	    		}				
	    		else 
	    		{
	    			goto DEFAULT;
	    		}
	    	} 
	      }
	      if ($majorNumberDifferences == 0)
	      {
			$postTime = time();
			$runTime = $postTime - $preTime;
	        $retString =  "warning - numeric differences less than 1.0e-5 [time: ".$runTime."]\n";
	        $retString =  $retString . "\t* for details please check: $log\n";			
	        close LOG;
			
	        return 0;
	      }
	  }
	  
	  DEFAULT:
	  open(DIFF,"<$tmp3");
	  while(<DIFF>) {
	      if (/^>(.*)$/) {
		  print LOG "expected:$1\n";
		  $mismatch = 1;
	      } elsif (/^<(.*)$/) {
		  if (/^< *String(.*)\.unit;$/) {
		      # igore missing units
		  } elsif (/^<.*\.unit = \"\";$/) {
		      # igore missing units
		  } else {
		      print LOG "got:     $1\n";
		      $mismatch = 1;
		  }
	      }
	  }
	  close DIFF;
	  close LOG;

	  if ($mismatch) {
	      $retString =  "equation mismatch\n";
	      return 1;
	  }
      }
    
	$runTime = time() - $preTime;
	$retString =  "ok [time: ".$runTime."]\n";
    return 0;
}

sub dofile
{
	# reset variables if we use threading, we will get colliding names.
	$uniqueId = $$."-".time();
	$tmp1 = "$tmpPath/equations-1-".$uniqueId;
	$tmp2 = "$tmpPath/equations-2-".$uniqueId;
	$tmp3 = "$tmpPath/equations-diff-".$uniqueId;
	$tmp4 = "$tmpPath/baseline-".$uniqueId;
	
    my $f = shift;
    my %info = ("status"   => "unknown",
		"name"     => $f,
		"keywords" => "unknown");
    $log = "$tmpPath/log-".$uniqueId."-$f";
    $tc_err = 1;
    # Find the expected result
    open(OUT,">$tmp2");
    open(IN,"<$f");
    while(<IN>) {
	if (/^\/\/[ \\|]([a-z]*): *([^\r|^\n]*)$/) {
	    $info{$1} = $2;
	    # print "Noticed $1 = $2\n";
	} elsif (/^\/\/ Result:/../^\/\/ endResult/) {
	    s/^[ \t]*//;
	    s/^\/\/ Result://;
	    s/^\/\/ endResult//;
	    s/[ \t]+/ /;
	    if (/^.../) {
		print OUT substr($_,3);
	    }
	    elsif ($tc_err == 0)  {
		print "Error in testcase: $f\n";
		$tc_err = 1;		
	    }
	}
    }
    close IN;
    close OUT;

    # Check for keyword match
    if ($#keys >=0) {
	my %ks;
	for (split(/ *, */,$info{"keywords"})) { $ks{$_} = 1; }
	for (@keys) {
	    if (! $ks{$_}) {
		return 0;
	    }
	}
    }

    # Check for status match
     if ($statusfilter ne "all") {
 	if ($info{"status"} ne $statusfilter) {
 	    return 0;
 	}
     }

    # Collecting files
    if ($collectcases) {
	if ($info{'status'} ne "unknown") {
	    print $info{'name'}."\n";
	}
	return 0;
    }

    # Collecting keys?
    if ($collectkeys) {
	if ($info{"keywords"}) {
	    for (split(/ *, */, $info{"keywords"})) {
		if (!$knownkeys{$_}) {
		    $knownkeys{$_} = 1;
		} else {
		    $knownkeys{$_} += 1;
		}
	    }
	}
	return 0;
    }

    
    $total = $total + 1;

    if ( $info{"status"} !~ /^(erroneous|(in|)correct)$/ ) {
	printf(" %s %-31s... %s", $info{'status'} eq 'correct'?'+':'-', $info{'name'},$retString);
	print "unknown testcase status\n";
	kill "USR2",$parent; # Failing test case, notify parent
	return 1;
    }

    $status = runone $f,%info;
    if ($status == 0) {
		printf(" %s %-31s... %s", $info{'status'} eq 'correct'?'+':'-', $info{'name'},$retString);
		$successes = $successes + 1;
		kill "USR1",$parent; # Succeding test case, notify parent
    } 
	else {
		if ($verbose eq "yes" ) {
			printf(" %s %-31s... %s", $info{'status'} eq 'correct'?'+':'-', $info{'name'},$retString);
			print "\n";
			print "==== Log $log\n";
			system "$pager $log";
		}
		else{
			printf(" %s %-31s... %s", $info{'status'} eq 'correct'?'+':'-', $info{'name'},$retString);
		}
		kill "USR2",$parent; # Failing test case, notify parent
    }
}
while ($#ARGV >= 0) {
    $arg = shift(@ARGV);
    if ($arg eq "-v") {
		$verbose="yes";
    }
	elsif ($arg eq "-b") {
        $setbaseline = 1;
    } 
	elsif ($arg eq "-p") {
		if ($ENV{"PAGER"} eq "") {
			$pager="more";
		}
		else {
			$pager=$ENV{"PAGER"};
		}
    } 
	elsif ($arg eq "-k") {
		if ($#ARGV < 0) {
			print "-m needs an argument\n";
			exit 1;
		}
		@keys = split(/,/,shift(@ARGV));
    } 
	elsif ($arg eq "-s") {
		if ($#ARGV < 0) {
			print "-s needs an argument\n";
			exit 1;
		}
		$statusfilter = shift;
    } 
	elsif ($arg eq "-pr") {
		if ($#ARGV < 0) {
			print "-pr needs an argument\n";
			exit 1;
		}
		$threads = shift;
    }
	elsif ($arg eq "-e") {
		if ($#ARGV < 0) {
			print "-e needs an argument\n";
			exit 1;
		}
		$epsilon = shift;
    }
	elsif ($arg eq "-l") {
		$collectkeys = 1;
    }	
	elsif ($arg eq "-L") {
		$collectcases = 1;
    } 
	else 
	{	
		$filearg = 1;
		if ($setbaseline) 
		{
          setbaseline $arg
		}
		else 
		{
			$activeProcesses =0;
			$SIG{USR1} = "succSig";
			$SIG{USR2} = "failSig";
			$parent = $$;
			#print( @ARGV );
			#splice @ARGV, 1, 0, $arg;
			push(@ARGV,$arg); # re-add "current" element to end of array(first element have been removed to find what type it is)
			while($#ARGV >= 0)
			{
				#printf(" if $activeProcesses < $threads then kör\n");
				if($activeProcesses<$threads)
				{
					$arg = shift(@ARGV);
					$pid = fork();
					
					if (not defined $pid) {
						print "ERROR, Unable to fork, trying same test again\n";
						splice @ARGV, 0, 1, $arg;
						sleep(1);
					}
					else{
					$activeProcesses++;
					if($pid == 0)
					{
						#print("\n*** NEW child(# $activeProcesses ) doing: $arg\n");
						#print(" child doing $arg\n" );
						dofile $arg;
						#kill "USR1",$parent;
						exit(0);
						printf("\n** ERROR, no kill signal from child **\n");
					}
					else
					{
						
						#if($$ == $parent){ printf("parent inc to: $activeProcesses \n");}
						$total++;
					}
					}
				}
				if($activeProcesses == $threads)
				{
					#print(" parent sleeping \n");
					while ($gotone <= 0) 
					{
						wait();						
					}
					
					#print("*** DEL CHILD, parent awakening $activeProcesses\n");
					$gotone--;
				}
			}
			while($activeProcesses > 0)
			{
				#print(" FINAL SLEEP $activeProcesses , gotone: $gotone \n");
				while ($gotone <= 0) 
				{
					wait();
				}
				#print(" final awakening $activeProcesses\n");
				$gotone--;
				
			}
		}
		
	}
}

sub succSig {
	$gotone++;
	$successes++;
	$activeProcesses--;
}
sub failSig {
	$gotone++;
	$activeProcesses--;
}

##################################################################
## Sub Name: isNumber
## Description: returns 1 if is an integer or a real, else 0
## @author adrpo
##################################################################
sub isNumber
{
    eval
    {
        local $SIG{__WARN__} = sub { die };

        scalar ($_[0] == $_[0]);
    };

    !$@;
}
#@author adrpo
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}


##################################################################
## Sub Name: LessThanEpsilon.
## Description: This sub check if $1 - $2 < $3
## @author adrpo
##################################################################
sub LessThanEpsilon
{
	my $e       = shift;
	my $g       = shift;
	my $epsilon = shift;
    if (abs($e - $g) < $epsilon) 
    {
    		return 1;
    }
    else 
    {
    		return 0;	
    }	
}

# Check for no file args
if ($filearg == 0) {
    system "mkdir /tmp/log-drmodelica";
    for (glob '*.mo ') { dofile $_; }
    system "rm -rf /tmp/log-drmodelica";
}

# Final output. Statistics and stuff
if ($collectkeys || $collectcases) {
    for (sort(keys %knownkeys)) {
	printf "  %3d %s\n", $knownkeys{$_}, $_;
    }
} elsif ($setbaseline) {
  printf "\n== set new baseline for %d tests\n",$total;
} else {
    printf "\n== %d out of %d tests succeeded,[time: %d]\n", $successes, $total,(time()-$thisStartTime);
}

