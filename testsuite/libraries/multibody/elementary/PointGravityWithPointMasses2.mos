// name:     Modelica3.x.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2
// keywords: multibody, balancing, instantiation
// status:   correct
// 
//  Modelica MultiBody 3.x: instantiation and balance checking of the PointGravityWithPointMasses2 model
//

loadFile("_ElementaryTotal.mo");
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2);
getErrorString();
// check model doesn't work yet for this model.
checkModel(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2);
getErrorString();
system("rm -f *.so *.dll *.log *.c* *.makefile *.libs");

// Result:
// true
// ""
// "function Modelica.Math.Vectors.length "Inline before index reduction"
//   input Real[:] v "Vector";
//   output Real result "Length of vector v";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize "Inline before index reduction"
//   input Real[:] v "Vector";
//   input Real eps = 1e-13 "if |v| < eps then result = v/eps";
//   output Real[size(v,1)] result "Input vector v normalized to length=1";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector resolved in frame 2";
//   input Real[3] v2_der "= der(v2)";
//   output Real[3] v1_der "Derivative of vector v resolved in frame 1";
// algorithm
//   v1_der := Modelica.Mechanics.MultiBody.Frames.resolve1(R,{v2_der[1] + R.w[2] * v2[3] - R.w[3] * v2[2],v2_der[2] + R.w[3] * v2[1] - R.w[1] * v2[3],v2_der[3] + R.w[1] * v2[2] - R.w[2] * v2[1]});
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector resolved in frame 1";
//   input Real[3] v1_der "= der(v1)";
//   output Real[3] v2_der "Derivative of vector v resolved in frame 2";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1_der[1],v1_der[2],v1_der[3]}) - cross({R.w[1],R.w[2],R.w[3]},Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation "Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation"
// input Real[3, 3] T;
// input Real(quantity="AngularVelocity", unit="rad/s")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
//   output Real[3] residue "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
// algorithm
//   residue := {Modelica.Math.atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),Modelica.Math.atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),Modelica.Math.atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation.equalityConstraint "Inline before index reduction"
//   input Real[4] Q1 "Quaternions orientation object to rotate frame 0 into frame 1";
//   input Real[4] Q2 "Quaternions orientation object to rotate frame 0 into frame 2";
//   output Real[3] residue "The half of the rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (shall be zero)";
// algorithm
//   residue := {Q1[4] * Q2[1] + Q1[3] * Q2[2] + -Q1[2] * Q2[3] + -Q1[1] * Q2[4],-Q1[3] * Q2[1] + Q1[4] * Q2[2] + Q1[1] * Q2[3] + -Q1[2] * Q2[4],Q1[2] * Q2[1] + -Q1[1] * Q2[2] + Q1[4] * Q2[3] + -Q1[3] * Q2[4]};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2 "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   input Real[4] der_Q(unit = "1/s") "Derivative of Q";
//   output Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
// algorithm
//   w := {2.0 * (Q[4] * der_Q[1] + Q[3] * der_Q[2] + -Q[2] * der_Q[3] + -Q[1] * der_Q[4]),2.0 * (-Q[3] * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + -Q[2] * der_Q[4]),2.0 * (Q[2] * der_Q[1] + -Q[1] * der_Q[2] + Q[4] * der_Q[3] + -Q[3] * der_Q[4])};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T
//   input Real[3, 3] T "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
//   input Real[4] Q_guess = Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation() "Guess value for Q (there are 2 solutions; the one close to Q_guess is used";
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := (1.0 + T[1,1]) - T[2,2] - T[3,3];
//   c2 := (1.0 + T[2,2]) - T[1,1] - T[3,3];
//   c3 := (1.0 + T[3,3]) - T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 OR c4 > c1 AND c4 > c2 AND c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 AND c1 > c3 AND c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 AND c2 > c3 AND c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation "Inline before index reduction"
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   output Real[1] residue "Residue constraint (shall be zero)";
// algorithm
//   residue := {(Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation "Inline before index reduction"
//   input Real[3, 3] T1 "Orientation object to rotate frame 0 into frame 1";
//   input Real[3, 3] T_rel "Orientation object to rotate frame 1 into frame 2";
//   output Real[3, 3] T2 "Orientation object to rotate frame 0 into frame 2";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation "Inline before index reduction"
//   input Integer axis(min = 1, max = 3) "Rotate around 'axis' of frame 1";
//   input Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,Modelica.Math.cos(angle),Modelica.Math.sin(angle);0.0,-Modelica.Math.sin(angle),Modelica.Math.cos(angle)] else if axis == 2 then <matrix>[Modelica.Math.cos(angle),0.0,-Modelica.Math.sin(angle);0.0,1.0,0.0;Modelica.Math.sin(angle),0.0,Modelica.Math.cos(angle)] else <matrix>[Modelica.Math.cos(angle),Modelica.Math.sin(angle),0.0;-Modelica.Math.sin(angle),Modelica.Math.cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy
//   input Real[3] n_x(unit = "1") "Vector in direction of x-axis of frame 2, resolved in frame 1";
//   input Real[3] n_y(unit = "1") "Vector in direction of y-axis of frame 2, resolved in frame 1";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = "1") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = "1") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = "1") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = "1") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = "1") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation "Inline before index reduction"
//   input Real[3] e(unit = "1") "Normalized axis of rotation (must have length=1)";
//   input Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along axis e";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   T := (<matrix>[e[1] ^ 2.0,e[1] * e[2],e[1] * e[3];e[2] * e[1],e[2] ^ 2.0,e[2] * e[3];e[3] * e[1],e[3] * e[2],e[3] ^ 2.0] + ({{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0}} - <matrix>[e[1] ^ 2.0,e[1] * e[2],e[1] * e[3];e[2] * e[1],e[2] ^ 2.0,e[2] * e[3];e[3] * e[1],e[3] * e[2],e[3] ^ 2.0]) * Modelica.Math.cos(angle)) - <matrix>[0.0,-Modelica.Math.sin(angle) * e[3],Modelica.Math.sin(angle) * e[2];Modelica.Math.sin(angle) * e[3],0.0,-Modelica.Math.sin(angle) * e[1];-Modelica.Math.sin(angle) * e[2],Modelica.Math.sin(angle) * e[1],0.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 "Inline before index reduction"
//   input Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector in frame 2";
//   output Real[3] v1 "Vector in frame 1";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2 "Inline before index reduction"
//   input Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector in frame 1";
//   output Real[3] v2 "Vector in frame 2";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel "Orientation object to rotate frame 1 into frame 2";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   output Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations "Inline before index reduction"
//   input Integer[3] sequence = {1,2,3} "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
//   input Real[3] angles(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angles around the axes defined in 'sequence'";
//   input Real[3] der_angles(quantity = "AngularVelocity", unit = "rad/s") "= der(angles)";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Integer[3] sequence = {1,2,3} "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
//   input Real guessAngle1(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Select angles[1] such that |angles[1] - guessAngle1| is a minimum";
//   output Real[3] angles(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi";
//   protected Real[3] e1_1(unit = "1") "First rotation axis, resolved in frame 1";
//   protected Real[3] e2_1a(unit = "1") "Second rotation axis, resolved in frame 1a";
//   protected Real[3] e3_1(unit = "1") "Third rotation axis, resolved in frame 1";
//   protected Real[3] e3_2(unit = "1") "Third rotation axis, resolved in frame 2";
//   protected Real A "Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
//   protected Real B "Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
//   protected Real angle_1a(quantity = "Angle", unit = "rad", displayUnit = "deg") "Solution 1 for angles[1]";
//   protected Real angle_1b(quantity = "Angle", unit = "rad", displayUnit = "deg") "Solution 2 for angles[1]";
//   protected Real[3, 3] T_1a "Orientation object to rotate frame 1 into frame 1a";
// algorithm
//   assert( sequence[1] <> sequence[2] AND sequence[2] <> sequence[3], "input argument 'sequence[1:3]' is not valid");
//   e1_1 := /*/tp:REAL[3]/*/(if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,1,0} else {0,0,1});
//   e2_1a := /*/tp:REAL[3]/*/(if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {0,1,0} else {0,0,1});
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := /*/tp:REAL[3]/*/(if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,1,0} else {0,0,1});
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 AND abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := Modelica.Math.atan2(A,-B);
//     angle_1b := Modelica.Math.atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis "Inline before index reduction"
//   input Integer axis(min = 1, max = 3) "Axis vector to be returned";
//   output Real[3] e(unit = "1") "Unit axis vector";
// algorithm
//   e := /*/tp:REAL[3]/*/(if axis == 1 then {1,0,0} else if axis == 2 then {0,1,0} else {0,0,1});
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   input Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity from frame 2 with respect to frame 1, resolved in frame 2";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[1] * Q[2] + Q[3] * Q[4]),2.0 * (Q[1] * Q[3] - Q[2] * Q[4]);2.0 * (Q[2] * Q[1] - Q[3] * Q[4]),2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[2] * Q[3] + Q[1] * Q[4]);2.0 * (Q[3] * Q[1] + Q[2] * Q[4]),2.0 * (Q[3] * Q[2] - Q[1] * Q[4]),2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation "Inline before index reduction"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object such that frame 1 and frame 2 are identical";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation({{1.0,0.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0}},{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle "Inline before index reduction"
//   input Real[3] e(unit = "1") "Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)";
//   input Real[3] v1 "A vector v resolved in frame 1 (shall not be parallel to e)";
//   input Real[3] v2 "Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)";
//   output Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi";
// algorithm
//   angle := Modelica.Math.atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],(v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3]) - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1 "Inline after index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector in frame 2";
//   output Real[3] v1 "Vector in frame 1";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2 "Inline after index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector in frame 1";
//   output Real[3] v2 "Vector in frame 2";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[4] Q_guess = Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation() "Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used";
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration
//   input Real[3] r(quantity = "Length", unit = "m") "Position vector from world frame to actual point, resolved in world frame";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType "Type of gravity field";
//   input Real[3] g(quantity = "Acceleration", unit = "m/s2") "Constant gravity acceleration, resolved in world frame, if gravityType=1";
//   input Real mue(unit = "m3/s2") "Field constant of point gravity field, if gravityType=2";
//   output Real[3] gravity(quantity = "Acceleration", unit = "m/s2") "Gravity acceleration at point r, resolved in world frame";
// algorithm
//   gravity := if gravityType == GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration
//   input Real[3] r(quantity = "Length", unit = "m") "Position vector from world frame to actual point, resolved in world frame";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType "Type of gravity field";
//   input Real[3] g(quantity = "Acceleration", unit = "m/s2") "Constant gravity acceleration, resolved in world frame, if gravityType=1";
//   input Real mue(unit = "m3/s2") "Field constant of point gravity field, if gravityType=2";
//   output Real[3] gravity(quantity = "Acceleration", unit = "m/s2") "Gravity acceleration at point r, resolved in world frame";
// algorithm
//   gravity := if gravityType == GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial "Inline before index reduction"
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape "Inline before index reduction"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// fclass Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2
//   Real world.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real world.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real world.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean world.enableAnimation = true "= true, if animation of all components is enabled";
//   parameter Boolean world.animateWorld = true "= true, if world coordinate system shall be visualized";
//   parameter Boolean world.animateGravity = true "= true, if gravity field shall be visualized (acceleration vector or field center)";
//   parameter String world.label1 = "x" "Label of horizontal axis in icon";
//   parameter String world.label2 = "y" "Label of vertical axis in icon";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity "Type of gravity field";
//   parameter Real world.g(quantity = "Acceleration", unit = "m/s2") = 9.81 "Constant gravity acceleration";
//   parameter Real world.n[1](unit = "1") = 0.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.n[2](unit = "1") = -1.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.n[3](unit = "1") = 0.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.mue(unit = "m3/s2", min = 0.0) = 5.0 "Gravity field constant (default = field constant of earth)";
//   parameter Boolean world.driveTrainMechanics3D = true "= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account";
//   parameter Real world.axisLength(quantity = "Length", unit = "m", min = 0.0) = world.nominalLength / 2.0 "Length of world axes arrows";
//   parameter Real world.axisDiameter(quantity = "Length", unit = "m", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction "Diameter of world axes arrows";
//   parameter Boolean world.axisShowLabels = true "= true, if labels shall be shown";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] "Color of z-arrow";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] "Color of z-arrow";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] "Color of z-arrow";
//   parameter Real world.gravityArrowTail[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowTail[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowTail[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowLength(quantity = "Length", unit = "m") = world.axisLength / 2.0 "Length of gravity arrow";
//   parameter Real world.gravityArrowDiameter(quantity = "Length", unit = "m", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction "Diameter of gravity arrow";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 "Color of gravity arrow";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 "Color of gravity arrow";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 "Color of gravity arrow";
//   parameter Real world.gravitySphereDiameter(quantity = "Length", unit = "m", min = 0.0) = 12742000.0 "Diameter of sphere representing gravity center (default = mean diameter of earth)";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 "Color of gravity sphere";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 "Color of gravity sphere";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 "Color of gravity sphere";
//   parameter Real world.nominalLength(quantity = "Length", unit = "m") = 1.0 "\"Nominal\" length of multi-body system";
//   parameter Real world.defaultAxisLength(quantity = "Length", unit = "m") = world.nominalLength / 5.0 "Default for length of a frame axis (but not world frame)";
//   parameter Real world.defaultJointLength(quantity = "Length", unit = "m") = world.nominalLength / 10.0 "Default for the fixed length of a shape representing a joint";
//   parameter Real world.defaultJointWidth(quantity = "Length", unit = "m") = world.nominalLength / 20.0 "Default for the fixed width of a shape representing a joint";
//   parameter Real world.defaultForceLength(quantity = "Length", unit = "m") = world.nominalLength / 10.0 "Default for the fixed length of a shape representing a force (e.g. damper)";
//   parameter Real world.defaultForceWidth(quantity = "Length", unit = "m") = world.nominalLength / 20.0 "Default for the fixed width of a shape represening a force (e.g. spring, bushing)";
//   parameter Real world.defaultBodyDiameter(quantity = "Length", unit = "m") = world.nominalLength / 9.0 "Default for diameter of sphere representing the center of mass of a body";
//   parameter Real world.defaultWidthFraction = 20.0 "Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)";
//   parameter Real world.defaultArrowDiameter(quantity = "Length", unit = "m") = world.nominalLength / 40.0 "Default for arrow diameter (e.g., of forces, torques, sensors)";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 "Default for arrow diameter of a coordinate system as a fraction of axis length";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 "Default reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Real world.defaultN_to_m(unit = "N/m", min = 0.0) = 1000.0 "Default scaling of force arrows (length = force/defaultN_to_m)";
//   parameter Real world.defaultNm_to_m(unit = "N.m/m", min = 0.0) = 1000.0 "Default scaling of torque arrows (length = torque/defaultNm_to_m)";
//   protected parameter Integer world.ndim = if world.enableAnimation AND world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation AND world.animateWorld AND world.axisShowLabels then 1 else 0;
//   protected parameter Real world.headLength(quantity = "Length", unit = "m") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = "Length", unit = "m") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineLength(quantity = "Length", unit = "m") = max(0.0,world.axisLength - world.headLength);
//   protected parameter Real world.lineWidth(quantity = "Length", unit = "m") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = "Length", unit = "m") = 3.0 * world.axisDiameter;
//   protected parameter Real world.labelStart(quantity = "Length", unit = "m") = 1.05 * world.axisLength;
//   parameter String world.x_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.x_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.x_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.x_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) "Color of shape";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) "Color of shape";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) "Color of shape";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = "1") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = "1") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = "1") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.r[1](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.x_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.x_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.x_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) "Color of shape";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) "Color of shape";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) "Color of shape";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = "1") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = "1") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = "1") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   input Real world.x_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r_lines[1](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.r_lines[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.r_lines[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[1](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[2](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[3](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[1](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[2](unit = "1") = 1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,2,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] "Color of cylinders";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] "Color of cylinders";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] "Color of cylinders";
//   input Real world.x_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.x_label.n = 2 "Number of cylinders";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][3];
//   protected Real world.x_label.r_abs[1](quantity = "Length", unit = "m") = world.x_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[1];
//   protected Real world.x_label.r_abs[2](quantity = "Length", unit = "m") = world.x_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[2];
//   protected Real world.x_label.r_abs[3](quantity = "Length", unit = "m") = world.x_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[3];
//   parameter String world.x_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.x_label.cylinders[1].width(quantity = "Length", unit = "m") = world.x_label.diameter "Width of visual object";
//   input Real world.x_label.cylinders[1].height(quantity = "Length", unit = "m") = world.x_label.diameter "Height of visual object";
//   input Real world.x_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) "Color of shape";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) "Color of shape";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) "Color of shape";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = "1") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = "1") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = "1") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.x_label.cylinders[2].width(quantity = "Length", unit = "m") = world.x_label.diameter "Width of visual object";
//   input Real world.x_label.cylinders[2].height(quantity = "Length", unit = "m") = world.x_label.diameter "Height of visual object";
//   input Real world.x_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) "Color of shape";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) "Color of shape";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) "Color of shape";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = "1") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = "1") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = "1") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   parameter String world.y_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[2](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[1](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[2](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.y_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.y_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.y_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) "Color of shape";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) "Color of shape";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) "Color of shape";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = "1") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = "1") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = "1") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r[2](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[2](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[1](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[2](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.y_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.y_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.y_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) "Color of shape";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) "Color of shape";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) "Color of shape";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = "1") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = "1") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = "1") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r_lines[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.r_lines[2](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.r_lines[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[1](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[2](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[3](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[1](unit = "1") = -1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[2](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,2,2](quantity = "Length", unit = "m") = 1.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,1,2](quantity = "Length", unit = "m") = 1.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,2,1](quantity = "Length", unit = "m") = 0.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,2,2](quantity = "Length", unit = "m") = 0.75 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] "Color of cylinders";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] "Color of cylinders";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] "Color of cylinders";
//   input Real world.y_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.y_label.n = 2 "Number of cylinders";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][3];
//   protected Real world.y_label.r_abs[1](quantity = "Length", unit = "m") = world.y_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[1];
//   protected Real world.y_label.r_abs[2](quantity = "Length", unit = "m") = world.y_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[2];
//   protected Real world.y_label.r_abs[3](quantity = "Length", unit = "m") = world.y_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[3];
//   parameter String world.y_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.y_label.cylinders[1].width(quantity = "Length", unit = "m") = world.y_label.diameter "Width of visual object";
//   input Real world.y_label.cylinders[1].height(quantity = "Length", unit = "m") = world.y_label.diameter "Height of visual object";
//   input Real world.y_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) "Color of shape";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) "Color of shape";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) "Color of shape";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = "1") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = "1") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = "1") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.y_label.cylinders[2].width(quantity = "Length", unit = "m") = world.y_label.diameter "Width of visual object";
//   input Real world.y_label.cylinders[2].height(quantity = "Length", unit = "m") = world.y_label.diameter "Height of visual object";
//   input Real world.y_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) "Color of shape";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) "Color of shape";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) "Color of shape";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = "1") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = "1") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = "1") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   parameter String world.z_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[3](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.z_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.z_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.z_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) "Color of shape";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) "Color of shape";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) "Color of shape";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = "1") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = "1") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = "1") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r[3](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[3](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.z_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.z_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.z_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) "Color of shape";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) "Color of shape";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) "Color of shape";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = "1") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = "1") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = "1") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r_lines[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.r_lines[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.r_lines[3](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[1](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[2](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[3](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[1](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[2](unit = "1") = 1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,2,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] "Color of cylinders";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] "Color of cylinders";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] "Color of cylinders";
//   input Real world.z_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.z_label.n = 3 "Number of cylinders";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][3];
//   protected Real world.z_label.r_abs[1](quantity = "Length", unit = "m") = world.z_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[1];
//   protected Real world.z_label.r_abs[2](quantity = "Length", unit = "m") = world.z_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[2];
//   protected Real world.z_label.r_abs[3](quantity = "Length", unit = "m") = world.z_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[3];
//   parameter String world.z_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[1].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[1].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = "1") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = "1") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = "1") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[2].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[2].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = "1") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = "1") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = "1") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[3].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[3].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[3].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[3].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = "1") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = "1") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = "1") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Real world.gravityHeadLength(quantity = "Length", unit = "m") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = "Length", unit = "m") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = "Length", unit = "m") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation AND world.animateGravity AND world.gravityType == 2 then 1 else 0;
//   parameter String world.gravitySphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.gravitySphere.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravitySphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravitySphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravitySphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravitySphere.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravitySphere.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravitySphere.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravitySphere.r_shape[1](quantity = "Length", unit = "m") = (-world.gravitySphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravitySphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravitySphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravitySphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.gravitySphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.gravitySphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.gravitySphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravitySphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravitySphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravitySphere.length(quantity = "Length", unit = "m") = world.gravitySphereDiameter "Length of visual object";
//   input Real world.gravitySphere.width(quantity = "Length", unit = "m") = world.gravitySphereDiameter "Width of visual object";
//   input Real world.gravitySphere.height(quantity = "Length", unit = "m") = world.gravitySphereDiameter "Height of visual object";
//   input Real world.gravitySphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.gravitySphere.color[1] = Real(world.gravitySphereColor[1]) "Color of shape";
//   input Real world.gravitySphere.color[2] = Real(world.gravitySphereColor[2]) "Color of shape";
//   input Real world.gravitySphere.color[3] = Real(world.gravitySphereColor[3]) "Color of shape";
//   input Real world.gravitySphere.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.gravitySphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.gravitySphere.lengthDirection[1],world.gravitySphere.lengthDirection[2],world.gravitySphere.lengthDirection[3]});
//   protected Real world.gravitySphere.e_x[1](unit = "1") = if noEvent(world.gravitySphere.abs_n_x < 1e-10) then 1.0 else world.gravitySphere.lengthDirection[1] / world.gravitySphere.abs_n_x;
//   protected Real world.gravitySphere.e_x[2](unit = "1") = if noEvent(world.gravitySphere.abs_n_x < 1e-10) then 0.0 else world.gravitySphere.lengthDirection[2] / world.gravitySphere.abs_n_x;
//   protected Real world.gravitySphere.e_x[3](unit = "1") = if noEvent(world.gravitySphere.abs_n_x < 1e-10) then 0.0 else world.gravitySphere.lengthDirection[3] / world.gravitySphere.abs_n_x;
//   protected Real world.gravitySphere.n_z_aux[1](unit = "1") = world.gravitySphere.e_x[2] * world.gravitySphere.widthDirection[3] - world.gravitySphere.e_x[3] * world.gravitySphere.widthDirection[2];
//   protected Real world.gravitySphere.n_z_aux[2](unit = "1") = world.gravitySphere.e_x[3] * world.gravitySphere.widthDirection[1] - world.gravitySphere.e_x[1] * world.gravitySphere.widthDirection[3];
//   protected Real world.gravitySphere.n_z_aux[3](unit = "1") = world.gravitySphere.e_x[1] * world.gravitySphere.widthDirection[2] - world.gravitySphere.e_x[2] * world.gravitySphere.widthDirection[1];
//   protected Real world.gravitySphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]},if noEvent(world.gravitySphere.n_z_aux[1] ^ 2.0 + (world.gravitySphere.n_z_aux[2] ^ 2.0 + world.gravitySphere.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravitySphere.widthDirection[1],world.gravitySphere.widthDirection[2],world.gravitySphere.widthDirection[3]} else if noEvent(abs(world.gravitySphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]})[1];
//   protected Real world.gravitySphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]},if noEvent(world.gravitySphere.n_z_aux[1] ^ 2.0 + (world.gravitySphere.n_z_aux[2] ^ 2.0 + world.gravitySphere.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravitySphere.widthDirection[1],world.gravitySphere.widthDirection[2],world.gravitySphere.widthDirection[3]} else if noEvent(abs(world.gravitySphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]})[2];
//   protected Real world.gravitySphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]},if noEvent(world.gravitySphere.n_z_aux[1] ^ 2.0 + (world.gravitySphere.n_z_aux[2] ^ 2.0 + world.gravitySphere.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravitySphere.widthDirection[1],world.gravitySphere.widthDirection[2],world.gravitySphere.widthDirection[3]} else if noEvent(abs(world.gravitySphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravitySphere.e_x[1],world.gravitySphere.e_x[2],world.gravitySphere.e_x[3]})[3];
//   protected output Real world.gravitySphere.Form;
//   output Real world.gravitySphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravitySphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravitySphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravitySphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.gravitySphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravitySphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravitySphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravitySphere.Material;
//   protected output Real world.gravitySphere.Extra;
//   Real pointMass1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass1.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass1.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass1.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass1.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass1.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass1.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass1.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass1.r_0[1](quantity = "Length", unit = "m", start = 3.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass1.r_0[2](quantity = "Length", unit = "m", start = 0.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass1.r_0[3](quantity = "Length", unit = "m", start = 0.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass1.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass1.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass1.v_0[3](quantity = "Velocity", unit = "m/s", start = -1.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass1.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass1.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass1.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass1.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass1.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass1.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass1.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass1.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass1.sphere.r[1](quantity = "Length", unit = "m") = pointMass1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass1.sphere.r[2](quantity = "Length", unit = "m") = pointMass1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass1.sphere.r[3](quantity = "Length", unit = "m") = pointMass1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass1.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass1.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass1.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass1.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass1.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass1.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass1.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass1.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass1.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass1.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass1.sphere.length(quantity = "Length", unit = "m") = pointMass1.sphereDiameter "Length of visual object";
//   input Real pointMass1.sphere.width(quantity = "Length", unit = "m") = pointMass1.sphereDiameter "Width of visual object";
//   input Real pointMass1.sphere.height(quantity = "Length", unit = "m") = pointMass1.sphereDiameter "Height of visual object";
//   input Real pointMass1.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass1.sphere.color[1] = Real(pointMass1.sphereColor[1]) "Color of shape";
//   input Real pointMass1.sphere.color[2] = Real(pointMass1.sphereColor[2]) "Color of shape";
//   input Real pointMass1.sphere.color[3] = Real(pointMass1.sphereColor[3]) "Color of shape";
//   input Real pointMass1.sphere.specularCoefficient = pointMass1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass1.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass1.sphere.lengthDirection[1],pointMass1.sphere.lengthDirection[2],pointMass1.sphere.lengthDirection[3]});
//   protected Real pointMass1.sphere.e_x[1](unit = "1") = if noEvent(pointMass1.sphere.abs_n_x < 1e-10) then 1.0 else pointMass1.sphere.lengthDirection[1] / pointMass1.sphere.abs_n_x;
//   protected Real pointMass1.sphere.e_x[2](unit = "1") = if noEvent(pointMass1.sphere.abs_n_x < 1e-10) then 0.0 else pointMass1.sphere.lengthDirection[2] / pointMass1.sphere.abs_n_x;
//   protected Real pointMass1.sphere.e_x[3](unit = "1") = if noEvent(pointMass1.sphere.abs_n_x < 1e-10) then 0.0 else pointMass1.sphere.lengthDirection[3] / pointMass1.sphere.abs_n_x;
//   protected Real pointMass1.sphere.n_z_aux[1](unit = "1") = pointMass1.sphere.e_x[2] * pointMass1.sphere.widthDirection[3] - pointMass1.sphere.e_x[3] * pointMass1.sphere.widthDirection[2];
//   protected Real pointMass1.sphere.n_z_aux[2](unit = "1") = pointMass1.sphere.e_x[3] * pointMass1.sphere.widthDirection[1] - pointMass1.sphere.e_x[1] * pointMass1.sphere.widthDirection[3];
//   protected Real pointMass1.sphere.n_z_aux[3](unit = "1") = pointMass1.sphere.e_x[1] * pointMass1.sphere.widthDirection[2] - pointMass1.sphere.e_x[2] * pointMass1.sphere.widthDirection[1];
//   protected Real pointMass1.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]},if noEvent(pointMass1.sphere.n_z_aux[1] ^ 2.0 + (pointMass1.sphere.n_z_aux[2] ^ 2.0 + pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass1.sphere.widthDirection[1],pointMass1.sphere.widthDirection[2],pointMass1.sphere.widthDirection[3]} else if noEvent(abs(pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]})[1];
//   protected Real pointMass1.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]},if noEvent(pointMass1.sphere.n_z_aux[1] ^ 2.0 + (pointMass1.sphere.n_z_aux[2] ^ 2.0 + pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass1.sphere.widthDirection[1],pointMass1.sphere.widthDirection[2],pointMass1.sphere.widthDirection[3]} else if noEvent(abs(pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]})[2];
//   protected Real pointMass1.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]},if noEvent(pointMass1.sphere.n_z_aux[1] ^ 2.0 + (pointMass1.sphere.n_z_aux[2] ^ 2.0 + pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass1.sphere.widthDirection[1],pointMass1.sphere.widthDirection[2],pointMass1.sphere.widthDirection[3]} else if noEvent(abs(pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass1.sphere.e_x[1],pointMass1.sphere.e_x[2],pointMass1.sphere.e_x[3]})[3];
//   protected output Real pointMass1.sphere.Form;
//   output Real pointMass1.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass1.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass1.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass1.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass1.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass1.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass1.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass1.sphere.Material;
//   protected output Real pointMass1.sphere.Extra;
//   Real pointMass2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass2.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass2.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass2.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass2.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass2.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass2.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass2.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass2.r_0[1](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass2.r_0[2](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass2.r_0[3](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass2.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass2.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass2.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass2.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass2.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass2.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass2.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass2.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass2.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass2.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass2.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass2.sphere.r[1](quantity = "Length", unit = "m") = pointMass2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass2.sphere.r[2](quantity = "Length", unit = "m") = pointMass2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass2.sphere.r[3](quantity = "Length", unit = "m") = pointMass2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass2.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass2.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass2.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass2.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass2.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass2.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass2.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass2.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass2.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass2.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass2.sphere.length(quantity = "Length", unit = "m") = pointMass2.sphereDiameter "Length of visual object";
//   input Real pointMass2.sphere.width(quantity = "Length", unit = "m") = pointMass2.sphereDiameter "Width of visual object";
//   input Real pointMass2.sphere.height(quantity = "Length", unit = "m") = pointMass2.sphereDiameter "Height of visual object";
//   input Real pointMass2.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass2.sphere.color[1] = Real(pointMass2.sphereColor[1]) "Color of shape";
//   input Real pointMass2.sphere.color[2] = Real(pointMass2.sphereColor[2]) "Color of shape";
//   input Real pointMass2.sphere.color[3] = Real(pointMass2.sphereColor[3]) "Color of shape";
//   input Real pointMass2.sphere.specularCoefficient = pointMass2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass2.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass2.sphere.lengthDirection[1],pointMass2.sphere.lengthDirection[2],pointMass2.sphere.lengthDirection[3]});
//   protected Real pointMass2.sphere.e_x[1](unit = "1") = if noEvent(pointMass2.sphere.abs_n_x < 1e-10) then 1.0 else pointMass2.sphere.lengthDirection[1] / pointMass2.sphere.abs_n_x;
//   protected Real pointMass2.sphere.e_x[2](unit = "1") = if noEvent(pointMass2.sphere.abs_n_x < 1e-10) then 0.0 else pointMass2.sphere.lengthDirection[2] / pointMass2.sphere.abs_n_x;
//   protected Real pointMass2.sphere.e_x[3](unit = "1") = if noEvent(pointMass2.sphere.abs_n_x < 1e-10) then 0.0 else pointMass2.sphere.lengthDirection[3] / pointMass2.sphere.abs_n_x;
//   protected Real pointMass2.sphere.n_z_aux[1](unit = "1") = pointMass2.sphere.e_x[2] * pointMass2.sphere.widthDirection[3] - pointMass2.sphere.e_x[3] * pointMass2.sphere.widthDirection[2];
//   protected Real pointMass2.sphere.n_z_aux[2](unit = "1") = pointMass2.sphere.e_x[3] * pointMass2.sphere.widthDirection[1] - pointMass2.sphere.e_x[1] * pointMass2.sphere.widthDirection[3];
//   protected Real pointMass2.sphere.n_z_aux[3](unit = "1") = pointMass2.sphere.e_x[1] * pointMass2.sphere.widthDirection[2] - pointMass2.sphere.e_x[2] * pointMass2.sphere.widthDirection[1];
//   protected Real pointMass2.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]},if noEvent(pointMass2.sphere.n_z_aux[1] ^ 2.0 + (pointMass2.sphere.n_z_aux[2] ^ 2.0 + pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass2.sphere.widthDirection[1],pointMass2.sphere.widthDirection[2],pointMass2.sphere.widthDirection[3]} else if noEvent(abs(pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]})[1];
//   protected Real pointMass2.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]},if noEvent(pointMass2.sphere.n_z_aux[1] ^ 2.0 + (pointMass2.sphere.n_z_aux[2] ^ 2.0 + pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass2.sphere.widthDirection[1],pointMass2.sphere.widthDirection[2],pointMass2.sphere.widthDirection[3]} else if noEvent(abs(pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]})[2];
//   protected Real pointMass2.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]},if noEvent(pointMass2.sphere.n_z_aux[1] ^ 2.0 + (pointMass2.sphere.n_z_aux[2] ^ 2.0 + pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass2.sphere.widthDirection[1],pointMass2.sphere.widthDirection[2],pointMass2.sphere.widthDirection[3]} else if noEvent(abs(pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass2.sphere.e_x[1],pointMass2.sphere.e_x[2],pointMass2.sphere.e_x[3]})[3];
//   protected output Real pointMass2.sphere.Form;
//   output Real pointMass2.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass2.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass2.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass2.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass2.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass2.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass2.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass2.sphere.Material;
//   protected output Real pointMass2.sphere.Extra;
//   Real pointMass3.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass3.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass3.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass3.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass3.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass3.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass3.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass3.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass3.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass3.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass3.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass3.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass3.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass3.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass3.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass3.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass3.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass3.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass3.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass3.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass3.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass3.r_0[1](quantity = "Length", unit = "m", start = 2.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass3.r_0[2](quantity = "Length", unit = "m", start = 1.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass3.r_0[3](quantity = "Length", unit = "m", start = 0.0, fixed = true) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass3.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass3.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass3.v_0[3](quantity = "Velocity", unit = "m/s", start = -1.0, fixed = true) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass3.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass3.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass3.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass3.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass3.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass3.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass3.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass3.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass3.sphere.r[1](quantity = "Length", unit = "m") = pointMass3.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass3.sphere.r[2](quantity = "Length", unit = "m") = pointMass3.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass3.sphere.r[3](quantity = "Length", unit = "m") = pointMass3.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass3.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass3.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass3.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass3.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass3.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass3.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass3.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass3.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass3.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass3.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass3.sphere.length(quantity = "Length", unit = "m") = pointMass3.sphereDiameter "Length of visual object";
//   input Real pointMass3.sphere.width(quantity = "Length", unit = "m") = pointMass3.sphereDiameter "Width of visual object";
//   input Real pointMass3.sphere.height(quantity = "Length", unit = "m") = pointMass3.sphereDiameter "Height of visual object";
//   input Real pointMass3.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass3.sphere.color[1] = Real(pointMass3.sphereColor[1]) "Color of shape";
//   input Real pointMass3.sphere.color[2] = Real(pointMass3.sphereColor[2]) "Color of shape";
//   input Real pointMass3.sphere.color[3] = Real(pointMass3.sphereColor[3]) "Color of shape";
//   input Real pointMass3.sphere.specularCoefficient = pointMass3.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass3.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass3.sphere.lengthDirection[1],pointMass3.sphere.lengthDirection[2],pointMass3.sphere.lengthDirection[3]});
//   protected Real pointMass3.sphere.e_x[1](unit = "1") = if noEvent(pointMass3.sphere.abs_n_x < 1e-10) then 1.0 else pointMass3.sphere.lengthDirection[1] / pointMass3.sphere.abs_n_x;
//   protected Real pointMass3.sphere.e_x[2](unit = "1") = if noEvent(pointMass3.sphere.abs_n_x < 1e-10) then 0.0 else pointMass3.sphere.lengthDirection[2] / pointMass3.sphere.abs_n_x;
//   protected Real pointMass3.sphere.e_x[3](unit = "1") = if noEvent(pointMass3.sphere.abs_n_x < 1e-10) then 0.0 else pointMass3.sphere.lengthDirection[3] / pointMass3.sphere.abs_n_x;
//   protected Real pointMass3.sphere.n_z_aux[1](unit = "1") = pointMass3.sphere.e_x[2] * pointMass3.sphere.widthDirection[3] - pointMass3.sphere.e_x[3] * pointMass3.sphere.widthDirection[2];
//   protected Real pointMass3.sphere.n_z_aux[2](unit = "1") = pointMass3.sphere.e_x[3] * pointMass3.sphere.widthDirection[1] - pointMass3.sphere.e_x[1] * pointMass3.sphere.widthDirection[3];
//   protected Real pointMass3.sphere.n_z_aux[3](unit = "1") = pointMass3.sphere.e_x[1] * pointMass3.sphere.widthDirection[2] - pointMass3.sphere.e_x[2] * pointMass3.sphere.widthDirection[1];
//   protected Real pointMass3.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]},if noEvent(pointMass3.sphere.n_z_aux[1] ^ 2.0 + (pointMass3.sphere.n_z_aux[2] ^ 2.0 + pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass3.sphere.widthDirection[1],pointMass3.sphere.widthDirection[2],pointMass3.sphere.widthDirection[3]} else if noEvent(abs(pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]})[1];
//   protected Real pointMass3.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]},if noEvent(pointMass3.sphere.n_z_aux[1] ^ 2.0 + (pointMass3.sphere.n_z_aux[2] ^ 2.0 + pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass3.sphere.widthDirection[1],pointMass3.sphere.widthDirection[2],pointMass3.sphere.widthDirection[3]} else if noEvent(abs(pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]})[2];
//   protected Real pointMass3.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]},if noEvent(pointMass3.sphere.n_z_aux[1] ^ 2.0 + (pointMass3.sphere.n_z_aux[2] ^ 2.0 + pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass3.sphere.widthDirection[1],pointMass3.sphere.widthDirection[2],pointMass3.sphere.widthDirection[3]} else if noEvent(abs(pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass3.sphere.e_x[1],pointMass3.sphere.e_x[2],pointMass3.sphere.e_x[3]})[3];
//   protected output Real pointMass3.sphere.Form;
//   output Real pointMass3.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass3.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass3.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass3.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass3.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass3.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass3.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass3.sphere.Material;
//   protected output Real pointMass3.sphere.Extra;
//   Real pointMass4.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass4.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass4.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass4.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass4.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass4.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass4.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass4.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass4.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass4.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass4.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass4.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass4.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass4.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass4.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass4.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass4.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass4.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass4.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass4.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass4.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass4.r_0[1](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass4.r_0[2](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass4.r_0[3](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass4.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass4.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass4.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass4.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass4.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass4.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass4.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass4.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass4.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass4.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass4.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass4.sphere.r[1](quantity = "Length", unit = "m") = pointMass4.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass4.sphere.r[2](quantity = "Length", unit = "m") = pointMass4.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass4.sphere.r[3](quantity = "Length", unit = "m") = pointMass4.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass4.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass4.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass4.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass4.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass4.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass4.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass4.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass4.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass4.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass4.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass4.sphere.length(quantity = "Length", unit = "m") = pointMass4.sphereDiameter "Length of visual object";
//   input Real pointMass4.sphere.width(quantity = "Length", unit = "m") = pointMass4.sphereDiameter "Width of visual object";
//   input Real pointMass4.sphere.height(quantity = "Length", unit = "m") = pointMass4.sphereDiameter "Height of visual object";
//   input Real pointMass4.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass4.sphere.color[1] = Real(pointMass4.sphereColor[1]) "Color of shape";
//   input Real pointMass4.sphere.color[2] = Real(pointMass4.sphereColor[2]) "Color of shape";
//   input Real pointMass4.sphere.color[3] = Real(pointMass4.sphereColor[3]) "Color of shape";
//   input Real pointMass4.sphere.specularCoefficient = pointMass4.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass4.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass4.sphere.lengthDirection[1],pointMass4.sphere.lengthDirection[2],pointMass4.sphere.lengthDirection[3]});
//   protected Real pointMass4.sphere.e_x[1](unit = "1") = if noEvent(pointMass4.sphere.abs_n_x < 1e-10) then 1.0 else pointMass4.sphere.lengthDirection[1] / pointMass4.sphere.abs_n_x;
//   protected Real pointMass4.sphere.e_x[2](unit = "1") = if noEvent(pointMass4.sphere.abs_n_x < 1e-10) then 0.0 else pointMass4.sphere.lengthDirection[2] / pointMass4.sphere.abs_n_x;
//   protected Real pointMass4.sphere.e_x[3](unit = "1") = if noEvent(pointMass4.sphere.abs_n_x < 1e-10) then 0.0 else pointMass4.sphere.lengthDirection[3] / pointMass4.sphere.abs_n_x;
//   protected Real pointMass4.sphere.n_z_aux[1](unit = "1") = pointMass4.sphere.e_x[2] * pointMass4.sphere.widthDirection[3] - pointMass4.sphere.e_x[3] * pointMass4.sphere.widthDirection[2];
//   protected Real pointMass4.sphere.n_z_aux[2](unit = "1") = pointMass4.sphere.e_x[3] * pointMass4.sphere.widthDirection[1] - pointMass4.sphere.e_x[1] * pointMass4.sphere.widthDirection[3];
//   protected Real pointMass4.sphere.n_z_aux[3](unit = "1") = pointMass4.sphere.e_x[1] * pointMass4.sphere.widthDirection[2] - pointMass4.sphere.e_x[2] * pointMass4.sphere.widthDirection[1];
//   protected Real pointMass4.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]},if noEvent(pointMass4.sphere.n_z_aux[1] ^ 2.0 + (pointMass4.sphere.n_z_aux[2] ^ 2.0 + pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass4.sphere.widthDirection[1],pointMass4.sphere.widthDirection[2],pointMass4.sphere.widthDirection[3]} else if noEvent(abs(pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]})[1];
//   protected Real pointMass4.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]},if noEvent(pointMass4.sphere.n_z_aux[1] ^ 2.0 + (pointMass4.sphere.n_z_aux[2] ^ 2.0 + pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass4.sphere.widthDirection[1],pointMass4.sphere.widthDirection[2],pointMass4.sphere.widthDirection[3]} else if noEvent(abs(pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]})[2];
//   protected Real pointMass4.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]},if noEvent(pointMass4.sphere.n_z_aux[1] ^ 2.0 + (pointMass4.sphere.n_z_aux[2] ^ 2.0 + pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass4.sphere.widthDirection[1],pointMass4.sphere.widthDirection[2],pointMass4.sphere.widthDirection[3]} else if noEvent(abs(pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass4.sphere.e_x[1],pointMass4.sphere.e_x[2],pointMass4.sphere.e_x[3]})[3];
//   protected output Real pointMass4.sphere.Form;
//   output Real pointMass4.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass4.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass4.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass4.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass4.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass4.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass4.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass4.sphere.Material;
//   protected output Real pointMass4.sphere.Extra;
//   Real pointMass5.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass5.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass5.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass5.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass5.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass5.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass5.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass5.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass5.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass5.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass5.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass5.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass5.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass5.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass5.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass5.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass5.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass5.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass5.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass5.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass5.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass5.r_0[1](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass5.r_0[2](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass5.r_0[3](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass5.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass5.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass5.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass5.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass5.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass5.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass5.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass5.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass5.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass5.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass5.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass5.sphere.r[1](quantity = "Length", unit = "m") = pointMass5.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass5.sphere.r[2](quantity = "Length", unit = "m") = pointMass5.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass5.sphere.r[3](quantity = "Length", unit = "m") = pointMass5.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass5.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass5.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass5.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass5.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass5.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass5.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass5.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass5.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass5.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass5.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass5.sphere.length(quantity = "Length", unit = "m") = pointMass5.sphereDiameter "Length of visual object";
//   input Real pointMass5.sphere.width(quantity = "Length", unit = "m") = pointMass5.sphereDiameter "Width of visual object";
//   input Real pointMass5.sphere.height(quantity = "Length", unit = "m") = pointMass5.sphereDiameter "Height of visual object";
//   input Real pointMass5.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass5.sphere.color[1] = Real(pointMass5.sphereColor[1]) "Color of shape";
//   input Real pointMass5.sphere.color[2] = Real(pointMass5.sphereColor[2]) "Color of shape";
//   input Real pointMass5.sphere.color[3] = Real(pointMass5.sphereColor[3]) "Color of shape";
//   input Real pointMass5.sphere.specularCoefficient = pointMass5.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass5.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass5.sphere.lengthDirection[1],pointMass5.sphere.lengthDirection[2],pointMass5.sphere.lengthDirection[3]});
//   protected Real pointMass5.sphere.e_x[1](unit = "1") = if noEvent(pointMass5.sphere.abs_n_x < 1e-10) then 1.0 else pointMass5.sphere.lengthDirection[1] / pointMass5.sphere.abs_n_x;
//   protected Real pointMass5.sphere.e_x[2](unit = "1") = if noEvent(pointMass5.sphere.abs_n_x < 1e-10) then 0.0 else pointMass5.sphere.lengthDirection[2] / pointMass5.sphere.abs_n_x;
//   protected Real pointMass5.sphere.e_x[3](unit = "1") = if noEvent(pointMass5.sphere.abs_n_x < 1e-10) then 0.0 else pointMass5.sphere.lengthDirection[3] / pointMass5.sphere.abs_n_x;
//   protected Real pointMass5.sphere.n_z_aux[1](unit = "1") = pointMass5.sphere.e_x[2] * pointMass5.sphere.widthDirection[3] - pointMass5.sphere.e_x[3] * pointMass5.sphere.widthDirection[2];
//   protected Real pointMass5.sphere.n_z_aux[2](unit = "1") = pointMass5.sphere.e_x[3] * pointMass5.sphere.widthDirection[1] - pointMass5.sphere.e_x[1] * pointMass5.sphere.widthDirection[3];
//   protected Real pointMass5.sphere.n_z_aux[3](unit = "1") = pointMass5.sphere.e_x[1] * pointMass5.sphere.widthDirection[2] - pointMass5.sphere.e_x[2] * pointMass5.sphere.widthDirection[1];
//   protected Real pointMass5.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]},if noEvent(pointMass5.sphere.n_z_aux[1] ^ 2.0 + (pointMass5.sphere.n_z_aux[2] ^ 2.0 + pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass5.sphere.widthDirection[1],pointMass5.sphere.widthDirection[2],pointMass5.sphere.widthDirection[3]} else if noEvent(abs(pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]})[1];
//   protected Real pointMass5.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]},if noEvent(pointMass5.sphere.n_z_aux[1] ^ 2.0 + (pointMass5.sphere.n_z_aux[2] ^ 2.0 + pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass5.sphere.widthDirection[1],pointMass5.sphere.widthDirection[2],pointMass5.sphere.widthDirection[3]} else if noEvent(abs(pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]})[2];
//   protected Real pointMass5.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]},if noEvent(pointMass5.sphere.n_z_aux[1] ^ 2.0 + (pointMass5.sphere.n_z_aux[2] ^ 2.0 + pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass5.sphere.widthDirection[1],pointMass5.sphere.widthDirection[2],pointMass5.sphere.widthDirection[3]} else if noEvent(abs(pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass5.sphere.e_x[1],pointMass5.sphere.e_x[2],pointMass5.sphere.e_x[3]})[3];
//   protected output Real pointMass5.sphere.Form;
//   output Real pointMass5.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass5.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass5.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass5.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass5.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass5.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass5.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass5.sphere.Material;
//   protected output Real pointMass5.sphere.Extra;
//   Real pointMass6.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass6.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass6.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real pointMass6.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real pointMass6.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass6.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass6.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real pointMass6.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass6.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass6.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real pointMass6.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass6.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real pointMass6.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean pointMass6.animation = true "= true, if animation shall be enabled (show sphere)";
//   parameter Real pointMass6.m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of mass point";
//   input Real pointMass6.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer pointMass6.sphereColor[1](min = 0, max = 255) = 255 "Color of sphere";
//   input Integer pointMass6.sphereColor[2](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer pointMass6.sphereColor[3](min = 0, max = 255) = 0 "Color of sphere";
//   input Real pointMass6.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) pointMass6.stateSelect = StateSelect.avoid "Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states";
//   Real pointMass6.r_0[1](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass6.r_0[2](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass6.r_0[3](quantity = "Length", unit = "m", start = 0.0) "Position vector from origin of world frame to origin of frame_a, resolved in world frame";
//   Real pointMass6.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass6.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass6.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real pointMass6.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass6.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real pointMass6.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter String pointMass6.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real pointMass6.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real pointMass6.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass6.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass6.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real pointMass6.sphere.r[1](quantity = "Length", unit = "m") = pointMass6.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass6.sphere.r[2](quantity = "Length", unit = "m") = pointMass6.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass6.sphere.r[3](quantity = "Length", unit = "m") = pointMass6.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real pointMass6.sphere.r_shape[1](quantity = "Length", unit = "m") = (-pointMass6.sphereDiameter) / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass6.sphere.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass6.sphere.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real pointMass6.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass6.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass6.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real pointMass6.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass6.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass6.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real pointMass6.sphere.length(quantity = "Length", unit = "m") = pointMass6.sphereDiameter "Length of visual object";
//   input Real pointMass6.sphere.width(quantity = "Length", unit = "m") = pointMass6.sphereDiameter "Width of visual object";
//   input Real pointMass6.sphere.height(quantity = "Length", unit = "m") = pointMass6.sphereDiameter "Height of visual object";
//   input Real pointMass6.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real pointMass6.sphere.color[1] = Real(pointMass6.sphereColor[1]) "Color of shape";
//   input Real pointMass6.sphere.color[2] = Real(pointMass6.sphereColor[2]) "Color of shape";
//   input Real pointMass6.sphere.color[3] = Real(pointMass6.sphereColor[3]) "Color of shape";
//   input Real pointMass6.sphere.specularCoefficient = pointMass6.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real pointMass6.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({pointMass6.sphere.lengthDirection[1],pointMass6.sphere.lengthDirection[2],pointMass6.sphere.lengthDirection[3]});
//   protected Real pointMass6.sphere.e_x[1](unit = "1") = if noEvent(pointMass6.sphere.abs_n_x < 1e-10) then 1.0 else pointMass6.sphere.lengthDirection[1] / pointMass6.sphere.abs_n_x;
//   protected Real pointMass6.sphere.e_x[2](unit = "1") = if noEvent(pointMass6.sphere.abs_n_x < 1e-10) then 0.0 else pointMass6.sphere.lengthDirection[2] / pointMass6.sphere.abs_n_x;
//   protected Real pointMass6.sphere.e_x[3](unit = "1") = if noEvent(pointMass6.sphere.abs_n_x < 1e-10) then 0.0 else pointMass6.sphere.lengthDirection[3] / pointMass6.sphere.abs_n_x;
//   protected Real pointMass6.sphere.n_z_aux[1](unit = "1") = pointMass6.sphere.e_x[2] * pointMass6.sphere.widthDirection[3] - pointMass6.sphere.e_x[3] * pointMass6.sphere.widthDirection[2];
//   protected Real pointMass6.sphere.n_z_aux[2](unit = "1") = pointMass6.sphere.e_x[3] * pointMass6.sphere.widthDirection[1] - pointMass6.sphere.e_x[1] * pointMass6.sphere.widthDirection[3];
//   protected Real pointMass6.sphere.n_z_aux[3](unit = "1") = pointMass6.sphere.e_x[1] * pointMass6.sphere.widthDirection[2] - pointMass6.sphere.e_x[2] * pointMass6.sphere.widthDirection[1];
//   protected Real pointMass6.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]},if noEvent(pointMass6.sphere.n_z_aux[1] ^ 2.0 + (pointMass6.sphere.n_z_aux[2] ^ 2.0 + pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass6.sphere.widthDirection[1],pointMass6.sphere.widthDirection[2],pointMass6.sphere.widthDirection[3]} else if noEvent(abs(pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]})[1];
//   protected Real pointMass6.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]},if noEvent(pointMass6.sphere.n_z_aux[1] ^ 2.0 + (pointMass6.sphere.n_z_aux[2] ^ 2.0 + pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass6.sphere.widthDirection[1],pointMass6.sphere.widthDirection[2],pointMass6.sphere.widthDirection[3]} else if noEvent(abs(pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]})[2];
//   protected Real pointMass6.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]},if noEvent(pointMass6.sphere.n_z_aux[1] ^ 2.0 + (pointMass6.sphere.n_z_aux[2] ^ 2.0 + pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {pointMass6.sphere.widthDirection[1],pointMass6.sphere.widthDirection[2],pointMass6.sphere.widthDirection[3]} else if noEvent(abs(pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{pointMass6.sphere.e_x[1],pointMass6.sphere.e_x[2],pointMass6.sphere.e_x[3]})[3];
//   protected output Real pointMass6.sphere.Form;
//   output Real pointMass6.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real pointMass6.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass6.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real pointMass6.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real pointMass6.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass6.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass6.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real pointMass6.sphere.Material;
//   protected output Real pointMass6.sphere.Extra;
//   Real fixedTranslation.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation.r[1](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation.lengthDirection[1](unit = "1") = fixedTranslation.r[1] - fixedTranslation.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.lengthDirection[2](unit = "1") = fixedTranslation.r[2] - fixedTranslation.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.lengthDirection[3](unit = "1") = fixedTranslation.r[3] - fixedTranslation.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation.r[1] - fixedTranslation.r_shape[1],fixedTranslation.r[2] - fixedTranslation.r_shape[2],fixedTranslation.r[3] - fixedTranslation.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation.width " Height of shape.";
//   parameter Real fixedTranslation.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation.shape.shapeType = fixedTranslation.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation.shape.lengthDirection[1](unit = "1") = fixedTranslation.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation.shape.lengthDirection[2](unit = "1") = fixedTranslation.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation.shape.lengthDirection[3](unit = "1") = fixedTranslation.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation.shape.widthDirection[1](unit = "1") = fixedTranslation.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation.shape.widthDirection[2](unit = "1") = fixedTranslation.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation.shape.widthDirection[3](unit = "1") = fixedTranslation.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation.shape.length(quantity = "Length", unit = "m") = fixedTranslation.length "Length of visual object";
//   input Real fixedTranslation.shape.width(quantity = "Length", unit = "m") = fixedTranslation.width "Width of visual object";
//   input Real fixedTranslation.shape.height(quantity = "Length", unit = "m") = fixedTranslation.height "Height of visual object";
//   input Real fixedTranslation.shape.extra = fixedTranslation.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation.shape.color[1] = Real(fixedTranslation.color[1]) "Color of shape";
//   input Real fixedTranslation.shape.color[2] = Real(fixedTranslation.color[2]) "Color of shape";
//   input Real fixedTranslation.shape.color[3] = Real(fixedTranslation.color[3]) "Color of shape";
//   input Real fixedTranslation.shape.specularCoefficient = fixedTranslation.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation.shape.lengthDirection[1],fixedTranslation.shape.lengthDirection[2],fixedTranslation.shape.lengthDirection[3]});
//   protected Real fixedTranslation.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation.shape.lengthDirection[1] / fixedTranslation.shape.abs_n_x;
//   protected Real fixedTranslation.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation.shape.lengthDirection[2] / fixedTranslation.shape.abs_n_x;
//   protected Real fixedTranslation.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation.shape.lengthDirection[3] / fixedTranslation.shape.abs_n_x;
//   protected Real fixedTranslation.shape.n_z_aux[1](unit = "1") = fixedTranslation.shape.e_x[2] * fixedTranslation.shape.widthDirection[3] - fixedTranslation.shape.e_x[3] * fixedTranslation.shape.widthDirection[2];
//   protected Real fixedTranslation.shape.n_z_aux[2](unit = "1") = fixedTranslation.shape.e_x[3] * fixedTranslation.shape.widthDirection[1] - fixedTranslation.shape.e_x[1] * fixedTranslation.shape.widthDirection[3];
//   protected Real fixedTranslation.shape.n_z_aux[3](unit = "1") = fixedTranslation.shape.e_x[1] * fixedTranslation.shape.widthDirection[2] - fixedTranslation.shape.e_x[2] * fixedTranslation.shape.widthDirection[1];
//   protected Real fixedTranslation.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]},if noEvent(fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation.shape.n_z_aux[2] ^ 2.0 + fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.shape.widthDirection[1],fixedTranslation.shape.widthDirection[2],fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]})[1];
//   protected Real fixedTranslation.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]},if noEvent(fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation.shape.n_z_aux[2] ^ 2.0 + fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.shape.widthDirection[1],fixedTranslation.shape.widthDirection[2],fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]})[2];
//   protected Real fixedTranslation.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]},if noEvent(fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation.shape.n_z_aux[2] ^ 2.0 + fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation.shape.widthDirection[1],fixedTranslation.shape.widthDirection[2],fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation.shape.e_x[1],fixedTranslation.shape.e_x[2],fixedTranslation.shape.e_x[3]})[3];
//   protected output Real fixedTranslation.shape.Form;
//   output Real fixedTranslation.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation.shape.Material;
//   protected output Real fixedTranslation.shape.Extra;
//   Real fixedTranslation1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation1.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation1.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation1.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation1.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation1.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation1.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation1.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation1.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation1.r[1](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation1.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation1.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation1.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation1.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation1.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation1.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation1.lengthDirection[1](unit = "1") = fixedTranslation1.r[1] - fixedTranslation1.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.lengthDirection[2](unit = "1") = fixedTranslation1.r[2] - fixedTranslation1.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.lengthDirection[3](unit = "1") = fixedTranslation1.r[3] - fixedTranslation1.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation1.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation1.r[1] - fixedTranslation1.r_shape[1],fixedTranslation1.r[2] - fixedTranslation1.r_shape[2],fixedTranslation1.r[3] - fixedTranslation1.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation1.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation1.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation1.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation1.width " Height of shape.";
//   parameter Real fixedTranslation1.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation1.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation1.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation1.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation1.shape.shapeType = fixedTranslation1.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation1.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation1.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation1.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation1.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation1.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation1.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation1.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation1.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation1.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation1.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation1.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation1.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation1.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation1.shape.lengthDirection[1](unit = "1") = fixedTranslation1.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation1.shape.lengthDirection[2](unit = "1") = fixedTranslation1.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation1.shape.lengthDirection[3](unit = "1") = fixedTranslation1.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation1.shape.widthDirection[1](unit = "1") = fixedTranslation1.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation1.shape.widthDirection[2](unit = "1") = fixedTranslation1.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation1.shape.widthDirection[3](unit = "1") = fixedTranslation1.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation1.shape.length(quantity = "Length", unit = "m") = fixedTranslation1.length "Length of visual object";
//   input Real fixedTranslation1.shape.width(quantity = "Length", unit = "m") = fixedTranslation1.width "Width of visual object";
//   input Real fixedTranslation1.shape.height(quantity = "Length", unit = "m") = fixedTranslation1.height "Height of visual object";
//   input Real fixedTranslation1.shape.extra = fixedTranslation1.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation1.shape.color[1] = Real(fixedTranslation1.color[1]) "Color of shape";
//   input Real fixedTranslation1.shape.color[2] = Real(fixedTranslation1.color[2]) "Color of shape";
//   input Real fixedTranslation1.shape.color[3] = Real(fixedTranslation1.color[3]) "Color of shape";
//   input Real fixedTranslation1.shape.specularCoefficient = fixedTranslation1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation1.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation1.shape.lengthDirection[1],fixedTranslation1.shape.lengthDirection[2],fixedTranslation1.shape.lengthDirection[3]});
//   protected Real fixedTranslation1.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation1.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation1.shape.lengthDirection[1] / fixedTranslation1.shape.abs_n_x;
//   protected Real fixedTranslation1.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation1.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.shape.lengthDirection[2] / fixedTranslation1.shape.abs_n_x;
//   protected Real fixedTranslation1.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation1.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation1.shape.lengthDirection[3] / fixedTranslation1.shape.abs_n_x;
//   protected Real fixedTranslation1.shape.n_z_aux[1](unit = "1") = fixedTranslation1.shape.e_x[2] * fixedTranslation1.shape.widthDirection[3] - fixedTranslation1.shape.e_x[3] * fixedTranslation1.shape.widthDirection[2];
//   protected Real fixedTranslation1.shape.n_z_aux[2](unit = "1") = fixedTranslation1.shape.e_x[3] * fixedTranslation1.shape.widthDirection[1] - fixedTranslation1.shape.e_x[1] * fixedTranslation1.shape.widthDirection[3];
//   protected Real fixedTranslation1.shape.n_z_aux[3](unit = "1") = fixedTranslation1.shape.e_x[1] * fixedTranslation1.shape.widthDirection[2] - fixedTranslation1.shape.e_x[2] * fixedTranslation1.shape.widthDirection[1];
//   protected Real fixedTranslation1.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]},if noEvent(fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.shape.widthDirection[1],fixedTranslation1.shape.widthDirection[2],fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]})[1];
//   protected Real fixedTranslation1.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]},if noEvent(fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.shape.widthDirection[1],fixedTranslation1.shape.widthDirection[2],fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]})[2];
//   protected Real fixedTranslation1.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]},if noEvent(fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation1.shape.widthDirection[1],fixedTranslation1.shape.widthDirection[2],fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation1.shape.e_x[1],fixedTranslation1.shape.e_x[2],fixedTranslation1.shape.e_x[3]})[3];
//   protected output Real fixedTranslation1.shape.Form;
//   output Real fixedTranslation1.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation1.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation1.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation1.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation1.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation1.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation1.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation1.shape.Material;
//   protected output Real fixedTranslation1.shape.Extra;
//   Real fixedTranslation2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation2.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation2.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation2.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation2.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation2.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation2.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation2.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation2.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation2.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation2.r[2](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation2.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation2.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation2.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation2.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation2.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation2.lengthDirection[1](unit = "1") = fixedTranslation2.r[1] - fixedTranslation2.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.lengthDirection[2](unit = "1") = fixedTranslation2.r[2] - fixedTranslation2.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.lengthDirection[3](unit = "1") = fixedTranslation2.r[3] - fixedTranslation2.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation2.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation2.r[1] - fixedTranslation2.r_shape[1],fixedTranslation2.r[2] - fixedTranslation2.r_shape[2],fixedTranslation2.r[3] - fixedTranslation2.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation2.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation2.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation2.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation2.width " Height of shape.";
//   parameter Real fixedTranslation2.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation2.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation2.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation2.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation2.shape.shapeType = fixedTranslation2.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation2.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation2.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation2.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation2.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation2.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation2.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation2.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation2.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation2.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation2.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation2.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation2.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation2.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation2.shape.lengthDirection[1](unit = "1") = fixedTranslation2.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation2.shape.lengthDirection[2](unit = "1") = fixedTranslation2.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation2.shape.lengthDirection[3](unit = "1") = fixedTranslation2.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation2.shape.widthDirection[1](unit = "1") = fixedTranslation2.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation2.shape.widthDirection[2](unit = "1") = fixedTranslation2.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation2.shape.widthDirection[3](unit = "1") = fixedTranslation2.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation2.shape.length(quantity = "Length", unit = "m") = fixedTranslation2.length "Length of visual object";
//   input Real fixedTranslation2.shape.width(quantity = "Length", unit = "m") = fixedTranslation2.width "Width of visual object";
//   input Real fixedTranslation2.shape.height(quantity = "Length", unit = "m") = fixedTranslation2.height "Height of visual object";
//   input Real fixedTranslation2.shape.extra = fixedTranslation2.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation2.shape.color[1] = Real(fixedTranslation2.color[1]) "Color of shape";
//   input Real fixedTranslation2.shape.color[2] = Real(fixedTranslation2.color[2]) "Color of shape";
//   input Real fixedTranslation2.shape.color[3] = Real(fixedTranslation2.color[3]) "Color of shape";
//   input Real fixedTranslation2.shape.specularCoefficient = fixedTranslation2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation2.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation2.shape.lengthDirection[1],fixedTranslation2.shape.lengthDirection[2],fixedTranslation2.shape.lengthDirection[3]});
//   protected Real fixedTranslation2.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation2.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation2.shape.lengthDirection[1] / fixedTranslation2.shape.abs_n_x;
//   protected Real fixedTranslation2.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation2.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.shape.lengthDirection[2] / fixedTranslation2.shape.abs_n_x;
//   protected Real fixedTranslation2.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation2.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation2.shape.lengthDirection[3] / fixedTranslation2.shape.abs_n_x;
//   protected Real fixedTranslation2.shape.n_z_aux[1](unit = "1") = fixedTranslation2.shape.e_x[2] * fixedTranslation2.shape.widthDirection[3] - fixedTranslation2.shape.e_x[3] * fixedTranslation2.shape.widthDirection[2];
//   protected Real fixedTranslation2.shape.n_z_aux[2](unit = "1") = fixedTranslation2.shape.e_x[3] * fixedTranslation2.shape.widthDirection[1] - fixedTranslation2.shape.e_x[1] * fixedTranslation2.shape.widthDirection[3];
//   protected Real fixedTranslation2.shape.n_z_aux[3](unit = "1") = fixedTranslation2.shape.e_x[1] * fixedTranslation2.shape.widthDirection[2] - fixedTranslation2.shape.e_x[2] * fixedTranslation2.shape.widthDirection[1];
//   protected Real fixedTranslation2.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]},if noEvent(fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.shape.widthDirection[1],fixedTranslation2.shape.widthDirection[2],fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]})[1];
//   protected Real fixedTranslation2.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]},if noEvent(fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.shape.widthDirection[1],fixedTranslation2.shape.widthDirection[2],fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]})[2];
//   protected Real fixedTranslation2.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]},if noEvent(fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation2.shape.widthDirection[1],fixedTranslation2.shape.widthDirection[2],fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation2.shape.e_x[1],fixedTranslation2.shape.e_x[2],fixedTranslation2.shape.e_x[3]})[3];
//   protected output Real fixedTranslation2.shape.Form;
//   output Real fixedTranslation2.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation2.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation2.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation2.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation2.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation2.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation2.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation2.shape.Material;
//   protected output Real fixedTranslation2.shape.Extra;
//   Real fixedTranslation3.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation3.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation3.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation3.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation3.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation3.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation3.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation3.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation3.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation3.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation3.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation3.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation3.r[2](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation3.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation3.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation3.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation3.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation3.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation3.lengthDirection[1](unit = "1") = fixedTranslation3.r[1] - fixedTranslation3.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.lengthDirection[2](unit = "1") = fixedTranslation3.r[2] - fixedTranslation3.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.lengthDirection[3](unit = "1") = fixedTranslation3.r[3] - fixedTranslation3.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation3.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation3.r[1] - fixedTranslation3.r_shape[1],fixedTranslation3.r[2] - fixedTranslation3.r_shape[2],fixedTranslation3.r[3] - fixedTranslation3.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation3.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation3.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation3.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation3.width " Height of shape.";
//   parameter Real fixedTranslation3.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation3.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation3.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation3.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation3.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation3.shape.shapeType = fixedTranslation3.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation3.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation3.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation3.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation3.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation3.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation3.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation3.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation3.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation3.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation3.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation3.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation3.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation3.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation3.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation3.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation3.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation3.shape.lengthDirection[1](unit = "1") = fixedTranslation3.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation3.shape.lengthDirection[2](unit = "1") = fixedTranslation3.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation3.shape.lengthDirection[3](unit = "1") = fixedTranslation3.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation3.shape.widthDirection[1](unit = "1") = fixedTranslation3.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation3.shape.widthDirection[2](unit = "1") = fixedTranslation3.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation3.shape.widthDirection[3](unit = "1") = fixedTranslation3.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation3.shape.length(quantity = "Length", unit = "m") = fixedTranslation3.length "Length of visual object";
//   input Real fixedTranslation3.shape.width(quantity = "Length", unit = "m") = fixedTranslation3.width "Width of visual object";
//   input Real fixedTranslation3.shape.height(quantity = "Length", unit = "m") = fixedTranslation3.height "Height of visual object";
//   input Real fixedTranslation3.shape.extra = fixedTranslation3.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation3.shape.color[1] = Real(fixedTranslation3.color[1]) "Color of shape";
//   input Real fixedTranslation3.shape.color[2] = Real(fixedTranslation3.color[2]) "Color of shape";
//   input Real fixedTranslation3.shape.color[3] = Real(fixedTranslation3.color[3]) "Color of shape";
//   input Real fixedTranslation3.shape.specularCoefficient = fixedTranslation3.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation3.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation3.shape.lengthDirection[1],fixedTranslation3.shape.lengthDirection[2],fixedTranslation3.shape.lengthDirection[3]});
//   protected Real fixedTranslation3.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation3.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation3.shape.lengthDirection[1] / fixedTranslation3.shape.abs_n_x;
//   protected Real fixedTranslation3.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation3.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.shape.lengthDirection[2] / fixedTranslation3.shape.abs_n_x;
//   protected Real fixedTranslation3.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation3.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation3.shape.lengthDirection[3] / fixedTranslation3.shape.abs_n_x;
//   protected Real fixedTranslation3.shape.n_z_aux[1](unit = "1") = fixedTranslation3.shape.e_x[2] * fixedTranslation3.shape.widthDirection[3] - fixedTranslation3.shape.e_x[3] * fixedTranslation3.shape.widthDirection[2];
//   protected Real fixedTranslation3.shape.n_z_aux[2](unit = "1") = fixedTranslation3.shape.e_x[3] * fixedTranslation3.shape.widthDirection[1] - fixedTranslation3.shape.e_x[1] * fixedTranslation3.shape.widthDirection[3];
//   protected Real fixedTranslation3.shape.n_z_aux[3](unit = "1") = fixedTranslation3.shape.e_x[1] * fixedTranslation3.shape.widthDirection[2] - fixedTranslation3.shape.e_x[2] * fixedTranslation3.shape.widthDirection[1];
//   protected Real fixedTranslation3.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]},if noEvent(fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.shape.widthDirection[1],fixedTranslation3.shape.widthDirection[2],fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]})[1];
//   protected Real fixedTranslation3.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]},if noEvent(fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.shape.widthDirection[1],fixedTranslation3.shape.widthDirection[2],fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]})[2];
//   protected Real fixedTranslation3.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]},if noEvent(fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation3.shape.widthDirection[1],fixedTranslation3.shape.widthDirection[2],fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation3.shape.e_x[1],fixedTranslation3.shape.e_x[2],fixedTranslation3.shape.e_x[3]})[3];
//   protected output Real fixedTranslation3.shape.Form;
//   output Real fixedTranslation3.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation3.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation3.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation3.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation3.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation3.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation3.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation3.shape.Material;
//   protected output Real fixedTranslation3.shape.Extra;
//   Real fixedTranslation4.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation4.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation4.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation4.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation4.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation4.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation4.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation4.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation4.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation4.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation4.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation4.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation4.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation4.r[3](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation4.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation4.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation4.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation4.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation4.lengthDirection[1](unit = "1") = fixedTranslation4.r[1] - fixedTranslation4.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.lengthDirection[2](unit = "1") = fixedTranslation4.r[2] - fixedTranslation4.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.lengthDirection[3](unit = "1") = fixedTranslation4.r[3] - fixedTranslation4.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation4.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation4.r[1] - fixedTranslation4.r_shape[1],fixedTranslation4.r[2] - fixedTranslation4.r_shape[2],fixedTranslation4.r[3] - fixedTranslation4.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation4.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation4.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation4.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation4.width " Height of shape.";
//   parameter Real fixedTranslation4.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation4.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation4.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation4.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation4.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation4.shape.shapeType = fixedTranslation4.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation4.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation4.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation4.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation4.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation4.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation4.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation4.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation4.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation4.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation4.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation4.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation4.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation4.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation4.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation4.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation4.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation4.shape.lengthDirection[1](unit = "1") = fixedTranslation4.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation4.shape.lengthDirection[2](unit = "1") = fixedTranslation4.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation4.shape.lengthDirection[3](unit = "1") = fixedTranslation4.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation4.shape.widthDirection[1](unit = "1") = fixedTranslation4.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation4.shape.widthDirection[2](unit = "1") = fixedTranslation4.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation4.shape.widthDirection[3](unit = "1") = fixedTranslation4.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation4.shape.length(quantity = "Length", unit = "m") = fixedTranslation4.length "Length of visual object";
//   input Real fixedTranslation4.shape.width(quantity = "Length", unit = "m") = fixedTranslation4.width "Width of visual object";
//   input Real fixedTranslation4.shape.height(quantity = "Length", unit = "m") = fixedTranslation4.height "Height of visual object";
//   input Real fixedTranslation4.shape.extra = fixedTranslation4.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation4.shape.color[1] = Real(fixedTranslation4.color[1]) "Color of shape";
//   input Real fixedTranslation4.shape.color[2] = Real(fixedTranslation4.color[2]) "Color of shape";
//   input Real fixedTranslation4.shape.color[3] = Real(fixedTranslation4.color[3]) "Color of shape";
//   input Real fixedTranslation4.shape.specularCoefficient = fixedTranslation4.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation4.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation4.shape.lengthDirection[1],fixedTranslation4.shape.lengthDirection[2],fixedTranslation4.shape.lengthDirection[3]});
//   protected Real fixedTranslation4.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation4.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation4.shape.lengthDirection[1] / fixedTranslation4.shape.abs_n_x;
//   protected Real fixedTranslation4.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation4.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation4.shape.lengthDirection[2] / fixedTranslation4.shape.abs_n_x;
//   protected Real fixedTranslation4.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation4.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation4.shape.lengthDirection[3] / fixedTranslation4.shape.abs_n_x;
//   protected Real fixedTranslation4.shape.n_z_aux[1](unit = "1") = fixedTranslation4.shape.e_x[2] * fixedTranslation4.shape.widthDirection[3] - fixedTranslation4.shape.e_x[3] * fixedTranslation4.shape.widthDirection[2];
//   protected Real fixedTranslation4.shape.n_z_aux[2](unit = "1") = fixedTranslation4.shape.e_x[3] * fixedTranslation4.shape.widthDirection[1] - fixedTranslation4.shape.e_x[1] * fixedTranslation4.shape.widthDirection[3];
//   protected Real fixedTranslation4.shape.n_z_aux[3](unit = "1") = fixedTranslation4.shape.e_x[1] * fixedTranslation4.shape.widthDirection[2] - fixedTranslation4.shape.e_x[2] * fixedTranslation4.shape.widthDirection[1];
//   protected Real fixedTranslation4.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]},if noEvent(fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.shape.widthDirection[1],fixedTranslation4.shape.widthDirection[2],fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]})[1];
//   protected Real fixedTranslation4.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]},if noEvent(fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.shape.widthDirection[1],fixedTranslation4.shape.widthDirection[2],fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]})[2];
//   protected Real fixedTranslation4.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]},if noEvent(fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation4.shape.widthDirection[1],fixedTranslation4.shape.widthDirection[2],fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation4.shape.e_x[1],fixedTranslation4.shape.e_x[2],fixedTranslation4.shape.e_x[3]})[3];
//   protected output Real fixedTranslation4.shape.Form;
//   output Real fixedTranslation4.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation4.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation4.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation4.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation4.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation4.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation4.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation4.shape.Material;
//   protected output Real fixedTranslation4.shape.Extra;
//   Real fixedTranslation5.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation5.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation5.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation5.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real fixedTranslation5.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real fixedTranslation5.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real fixedTranslation5.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real fixedTranslation5.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation5.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real fixedTranslation5.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean fixedTranslation5.animation = true "= true, if animation shall be enabled";
//   parameter Real fixedTranslation5.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation5.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real fixedTranslation5.r[3](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String fixedTranslation5.shapeType = "cylinder" " Type of shape";
//   parameter Real fixedTranslation5.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation5.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation5.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real fixedTranslation5.lengthDirection[1](unit = "1") = fixedTranslation5.r[1] - fixedTranslation5.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.lengthDirection[2](unit = "1") = fixedTranslation5.r[2] - fixedTranslation5.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.lengthDirection[3](unit = "1") = fixedTranslation5.r[3] - fixedTranslation5.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real fixedTranslation5.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({fixedTranslation5.r[1] - fixedTranslation5.r_shape[1],fixedTranslation5.r[2] - fixedTranslation5.r_shape[2],fixedTranslation5.r[3] - fixedTranslation5.r_shape[3]}) " Length of shape";
//   parameter Real fixedTranslation5.width(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation5.length / world.defaultWidthFraction " Width of shape";
//   parameter Real fixedTranslation5.height(quantity = "Length", unit = "m", min = 0.0) = fixedTranslation5.width " Height of shape.";
//   parameter Real fixedTranslation5.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer fixedTranslation5.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation5.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer fixedTranslation5.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real fixedTranslation5.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String fixedTranslation5.shape.shapeType = fixedTranslation5.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real fixedTranslation5.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real fixedTranslation5.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation5.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation5.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real fixedTranslation5.shape.r[1](quantity = "Length", unit = "m") = fixedTranslation5.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation5.shape.r[2](quantity = "Length", unit = "m") = fixedTranslation5.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation5.shape.r[3](quantity = "Length", unit = "m") = fixedTranslation5.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real fixedTranslation5.shape.r_shape[1](quantity = "Length", unit = "m") = fixedTranslation5.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation5.shape.r_shape[2](quantity = "Length", unit = "m") = fixedTranslation5.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation5.shape.r_shape[3](quantity = "Length", unit = "m") = fixedTranslation5.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real fixedTranslation5.shape.lengthDirection[1](unit = "1") = fixedTranslation5.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation5.shape.lengthDirection[2](unit = "1") = fixedTranslation5.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation5.shape.lengthDirection[3](unit = "1") = fixedTranslation5.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real fixedTranslation5.shape.widthDirection[1](unit = "1") = fixedTranslation5.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation5.shape.widthDirection[2](unit = "1") = fixedTranslation5.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation5.shape.widthDirection[3](unit = "1") = fixedTranslation5.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real fixedTranslation5.shape.length(quantity = "Length", unit = "m") = fixedTranslation5.length "Length of visual object";
//   input Real fixedTranslation5.shape.width(quantity = "Length", unit = "m") = fixedTranslation5.width "Width of visual object";
//   input Real fixedTranslation5.shape.height(quantity = "Length", unit = "m") = fixedTranslation5.height "Height of visual object";
//   input Real fixedTranslation5.shape.extra = fixedTranslation5.extra "Additional size data for some of the shape types";
//   input Real fixedTranslation5.shape.color[1] = Real(fixedTranslation5.color[1]) "Color of shape";
//   input Real fixedTranslation5.shape.color[2] = Real(fixedTranslation5.color[2]) "Color of shape";
//   input Real fixedTranslation5.shape.color[3] = Real(fixedTranslation5.color[3]) "Color of shape";
//   input Real fixedTranslation5.shape.specularCoefficient = fixedTranslation5.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real fixedTranslation5.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({fixedTranslation5.shape.lengthDirection[1],fixedTranslation5.shape.lengthDirection[2],fixedTranslation5.shape.lengthDirection[3]});
//   protected Real fixedTranslation5.shape.e_x[1](unit = "1") = if noEvent(fixedTranslation5.shape.abs_n_x < 1e-10) then 1.0 else fixedTranslation5.shape.lengthDirection[1] / fixedTranslation5.shape.abs_n_x;
//   protected Real fixedTranslation5.shape.e_x[2](unit = "1") = if noEvent(fixedTranslation5.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation5.shape.lengthDirection[2] / fixedTranslation5.shape.abs_n_x;
//   protected Real fixedTranslation5.shape.e_x[3](unit = "1") = if noEvent(fixedTranslation5.shape.abs_n_x < 1e-10) then 0.0 else fixedTranslation5.shape.lengthDirection[3] / fixedTranslation5.shape.abs_n_x;
//   protected Real fixedTranslation5.shape.n_z_aux[1](unit = "1") = fixedTranslation5.shape.e_x[2] * fixedTranslation5.shape.widthDirection[3] - fixedTranslation5.shape.e_x[3] * fixedTranslation5.shape.widthDirection[2];
//   protected Real fixedTranslation5.shape.n_z_aux[2](unit = "1") = fixedTranslation5.shape.e_x[3] * fixedTranslation5.shape.widthDirection[1] - fixedTranslation5.shape.e_x[1] * fixedTranslation5.shape.widthDirection[3];
//   protected Real fixedTranslation5.shape.n_z_aux[3](unit = "1") = fixedTranslation5.shape.e_x[1] * fixedTranslation5.shape.widthDirection[2] - fixedTranslation5.shape.e_x[2] * fixedTranslation5.shape.widthDirection[1];
//   protected Real fixedTranslation5.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]},if noEvent(fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.shape.widthDirection[1],fixedTranslation5.shape.widthDirection[2],fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]})[1];
//   protected Real fixedTranslation5.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]},if noEvent(fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.shape.widthDirection[1],fixedTranslation5.shape.widthDirection[2],fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]})[2];
//   protected Real fixedTranslation5.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]},if noEvent(fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {fixedTranslation5.shape.widthDirection[1],fixedTranslation5.shape.widthDirection[2],fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{fixedTranslation5.shape.e_x[1],fixedTranslation5.shape.e_x[2],fixedTranslation5.shape.e_x[3]})[3];
//   protected output Real fixedTranslation5.shape.Form;
//   output Real fixedTranslation5.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real fixedTranslation5.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation5.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real fixedTranslation5.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real fixedTranslation5.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation5.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation5.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real fixedTranslation5.shape.Material;
//   protected output Real fixedTranslation5.shape.Extra;
//   Real freeMotion.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real freeMotion.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real freeMotion.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real freeMotion.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real freeMotion.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real freeMotion.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real freeMotion.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real freeMotion.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean freeMotion.animation = true "= true, if animation shall be enabled (show arrow from frame_a to frame_b)";
//   Real freeMotion.r_rel_a[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.always) "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
//   Real freeMotion.r_rel_a[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.always) "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
//   Real freeMotion.r_rel_a[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.always) "Position vector from origin of frame_a to origin of frame_b, resolved in frame_a";
//   Real freeMotion.v_rel_a[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.always) "= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a";
//   Real freeMotion.v_rel_a[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.always) "= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a";
//   Real freeMotion.v_rel_a[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.always) "= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a";
//   Real freeMotion.a_rel_a[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "= der(v_rel_a)";
//   Real freeMotion.a_rel_a[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "= der(v_rel_a)";
//   Real freeMotion.a_rel_a[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "= der(v_rel_a)";
//   parameter Boolean freeMotion.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real freeMotion.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real freeMotion.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real freeMotion.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer freeMotion.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer freeMotion.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer freeMotion.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean freeMotion.w_rel_a_fixed = false "= true, if w_rel_a_start are used as initial values, else as guess values";
//   parameter Real freeMotion.w_rel_a_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a";
//   parameter Real freeMotion.w_rel_a_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a";
//   parameter Real freeMotion.w_rel_a_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a";
//   parameter Boolean freeMotion.z_rel_a_fixed = false "= true, if z_rel_a_start are used as initial values, else as guess values";
//   parameter Real freeMotion.z_rel_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_rel_a = der(w_rel_a)";
//   parameter Real freeMotion.z_rel_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_rel_a = der(w_rel_a)";
//   parameter Real freeMotion.z_rel_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_rel_a = der(w_rel_a)";
//   parameter Real freeMotion.arrowDiameter(quantity = "Length", unit = "m") = world.defaultArrowDiameter "Diameter of arrow from frame_a to frame_b";
//   input Integer freeMotion.arrowColor[1](min = 0, max = 255) = 255 "Color of arrow";
//   input Integer freeMotion.arrowColor[2](min = 0, max = 255) = 255 "Color of arrow";
//   input Integer freeMotion.arrowColor[3](min = 0, max = 255) = 0 "Color of arrow";
//   input Real freeMotion.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean freeMotion.enforceStates = true " = true, if relative variables between frame_a and frame_b shall be used as states";
//   parameter Boolean freeMotion.useQuaternions = true " = true, if quaternions shall be used as states otherwise use 3 angles as states";
//   parameter Integer freeMotion.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states";
//   parameter Integer freeMotion.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states";
//   parameter Integer freeMotion.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states";
//   parameter Real freeMotion.R_rel_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real freeMotion.R_rel_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real freeMotion.R_rel_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real freeMotion.R_rel_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.r[1](quantity = "Length", unit = "m") = freeMotion.frame_a.r_0[1] "Position vector from origin of world frame to origin of arrow frame, resolved in world frame";
//   input Real freeMotion.arrow.r[2](quantity = "Length", unit = "m") = freeMotion.frame_a.r_0[2] "Position vector from origin of world frame to origin of arrow frame, resolved in world frame";
//   input Real freeMotion.arrow.r[3](quantity = "Length", unit = "m") = freeMotion.frame_a.r_0[3] "Position vector from origin of world frame to origin of arrow frame, resolved in world frame";
//   input Real freeMotion.arrow.r_tail[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of arrow frame to arrow tail, resolved in arrow frame";
//   input Real freeMotion.arrow.r_tail[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of arrow frame to arrow tail, resolved in arrow frame";
//   input Real freeMotion.arrow.r_tail[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of arrow frame to arrow tail, resolved in arrow frame";
//   input Real freeMotion.arrow.r_head[1](quantity = "Length", unit = "m") = freeMotion.r_rel_a[1] "Position vector from arrow tail to the head of the arrow, resolved in arrow frame";
//   input Real freeMotion.arrow.r_head[2](quantity = "Length", unit = "m") = freeMotion.r_rel_a[2] "Position vector from arrow tail to the head of the arrow, resolved in arrow frame";
//   input Real freeMotion.arrow.r_head[3](quantity = "Length", unit = "m") = freeMotion.r_rel_a[3] "Position vector from arrow tail to the head of the arrow, resolved in arrow frame";
//   input Real freeMotion.arrow.diameter(quantity = "Length", unit = "m", min = 0.0) = freeMotion.arrowDiameter "Diameter of arrow line";
//   input Integer freeMotion.arrow.color[1](min = 0, max = 255) = freeMotion.arrowColor[1] "Color of arrow";
//   input Integer freeMotion.arrow.color[2](min = 0, max = 255) = freeMotion.arrowColor[2] "Color of arrow";
//   input Integer freeMotion.arrow.color[3](min = 0, max = 255) = freeMotion.arrowColor[3] "Color of arrow";
//   input Real freeMotion.arrow.specularCoefficient = freeMotion.specularCoefficient "Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)";
//   protected Real freeMotion.arrow.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({freeMotion.arrow.r_head[1],freeMotion.arrow.r_head[2],freeMotion.arrow.r_head[3]}) "Length of arrow";
//   parameter String freeMotion.arrow.arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real freeMotion.arrow.arrowLine.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowLine.r[1](quantity = "Length", unit = "m") = freeMotion.arrow.r[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowLine.r[2](quantity = "Length", unit = "m") = freeMotion.arrow.r[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowLine.r[3](quantity = "Length", unit = "m") = freeMotion.arrow.r[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowLine.r_shape[1](quantity = "Length", unit = "m") = freeMotion.arrow.r_tail[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.r_shape[2](quantity = "Length", unit = "m") = freeMotion.arrow.r_tail[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.r_shape[3](quantity = "Length", unit = "m") = freeMotion.arrow.r_tail[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.lengthDirection[1](unit = "1") = freeMotion.arrow.r_head[1] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.lengthDirection[2](unit = "1") = freeMotion.arrow.r_head[2] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.lengthDirection[3](unit = "1") = freeMotion.arrow.r_head[3] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowLine.length(quantity = "Length", unit = "m") = max(0.0,freeMotion.arrow.length - 4.0 * freeMotion.arrow.diameter) "Length of visual object";
//   input Real freeMotion.arrow.arrowLine.width(quantity = "Length", unit = "m") = freeMotion.arrow.diameter "Width of visual object";
//   input Real freeMotion.arrow.arrowLine.height(quantity = "Length", unit = "m") = freeMotion.arrow.diameter "Height of visual object";
//   input Real freeMotion.arrow.arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real freeMotion.arrow.arrowLine.color[1] = Real(freeMotion.arrow.color[1]) "Color of shape";
//   input Real freeMotion.arrow.arrowLine.color[2] = Real(freeMotion.arrow.color[2]) "Color of shape";
//   input Real freeMotion.arrow.arrowLine.color[3] = Real(freeMotion.arrow.color[3]) "Color of shape";
//   input Real freeMotion.arrow.arrowLine.specularCoefficient = freeMotion.arrow.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real freeMotion.arrow.arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({freeMotion.arrow.arrowLine.lengthDirection[1],freeMotion.arrow.arrowLine.lengthDirection[2],freeMotion.arrow.arrowLine.lengthDirection[3]});
//   protected Real freeMotion.arrow.arrowLine.e_x[1](unit = "1") = if noEvent(freeMotion.arrow.arrowLine.abs_n_x < 1e-10) then 1.0 else freeMotion.arrow.arrowLine.lengthDirection[1] / freeMotion.arrow.arrowLine.abs_n_x;
//   protected Real freeMotion.arrow.arrowLine.e_x[2](unit = "1") = if noEvent(freeMotion.arrow.arrowLine.abs_n_x < 1e-10) then 0.0 else freeMotion.arrow.arrowLine.lengthDirection[2] / freeMotion.arrow.arrowLine.abs_n_x;
//   protected Real freeMotion.arrow.arrowLine.e_x[3](unit = "1") = if noEvent(freeMotion.arrow.arrowLine.abs_n_x < 1e-10) then 0.0 else freeMotion.arrow.arrowLine.lengthDirection[3] / freeMotion.arrow.arrowLine.abs_n_x;
//   protected Real freeMotion.arrow.arrowLine.n_z_aux[1](unit = "1") = freeMotion.arrow.arrowLine.e_x[2] * freeMotion.arrow.arrowLine.widthDirection[3] - freeMotion.arrow.arrowLine.e_x[3] * freeMotion.arrow.arrowLine.widthDirection[2];
//   protected Real freeMotion.arrow.arrowLine.n_z_aux[2](unit = "1") = freeMotion.arrow.arrowLine.e_x[3] * freeMotion.arrow.arrowLine.widthDirection[1] - freeMotion.arrow.arrowLine.e_x[1] * freeMotion.arrow.arrowLine.widthDirection[3];
//   protected Real freeMotion.arrow.arrowLine.n_z_aux[3](unit = "1") = freeMotion.arrow.arrowLine.e_x[1] * freeMotion.arrow.arrowLine.widthDirection[2] - freeMotion.arrow.arrowLine.e_x[2] * freeMotion.arrow.arrowLine.widthDirection[1];
//   protected Real freeMotion.arrow.arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]},if noEvent(freeMotion.arrow.arrowLine.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowLine.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowLine.widthDirection[1],freeMotion.arrow.arrowLine.widthDirection[2],freeMotion.arrow.arrowLine.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]})[1];
//   protected Real freeMotion.arrow.arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]},if noEvent(freeMotion.arrow.arrowLine.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowLine.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowLine.widthDirection[1],freeMotion.arrow.arrowLine.widthDirection[2],freeMotion.arrow.arrowLine.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]})[2];
//   protected Real freeMotion.arrow.arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]},if noEvent(freeMotion.arrow.arrowLine.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowLine.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowLine.widthDirection[1],freeMotion.arrow.arrowLine.widthDirection[2],freeMotion.arrow.arrowLine.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowLine.e_x[1],freeMotion.arrow.arrowLine.e_x[2],freeMotion.arrow.arrowLine.e_x[3]})[3];
//   protected output Real freeMotion.arrow.arrowLine.Form;
//   output Real freeMotion.arrow.arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real freeMotion.arrow.arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real freeMotion.arrow.arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowLine.Material;
//   protected output Real freeMotion.arrow.arrowLine.Extra;
//   parameter String freeMotion.arrow.arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real freeMotion.arrow.arrowHead.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real freeMotion.arrow.arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real freeMotion.arrow.arrowHead.r[1](quantity = "Length", unit = "m") = freeMotion.arrow.arrowLine.rvisobj[1] + freeMotion.arrow.arrowLine.length * freeMotion.arrow.arrowLine.rxvisobj[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowHead.r[2](quantity = "Length", unit = "m") = freeMotion.arrow.arrowLine.rvisobj[2] + freeMotion.arrow.arrowLine.length * freeMotion.arrow.arrowLine.rxvisobj[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowHead.r[3](quantity = "Length", unit = "m") = freeMotion.arrow.arrowLine.rvisobj[3] + freeMotion.arrow.arrowLine.length * freeMotion.arrow.arrowLine.rxvisobj[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real freeMotion.arrow.arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.lengthDirection[1](unit = "1") = freeMotion.arrow.r_head[1] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.lengthDirection[2](unit = "1") = freeMotion.arrow.r_head[2] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.lengthDirection[3](unit = "1") = freeMotion.arrow.r_head[3] "Vector in length direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real freeMotion.arrow.arrowHead.length(quantity = "Length", unit = "m") = max(0.0,min(freeMotion.arrow.length,4.0 * freeMotion.arrow.diameter)) "Length of visual object";
//   input Real freeMotion.arrow.arrowHead.width(quantity = "Length", unit = "m") = max(0.0,3.0 * freeMotion.arrow.diameter) "Width of visual object";
//   input Real freeMotion.arrow.arrowHead.height(quantity = "Length", unit = "m") = max(0.0,3.0 * freeMotion.arrow.diameter) "Height of visual object";
//   input Real freeMotion.arrow.arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real freeMotion.arrow.arrowHead.color[1] = Real(freeMotion.arrow.color[1]) "Color of shape";
//   input Real freeMotion.arrow.arrowHead.color[2] = Real(freeMotion.arrow.color[2]) "Color of shape";
//   input Real freeMotion.arrow.arrowHead.color[3] = Real(freeMotion.arrow.color[3]) "Color of shape";
//   input Real freeMotion.arrow.arrowHead.specularCoefficient = freeMotion.arrow.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real freeMotion.arrow.arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({freeMotion.arrow.arrowHead.lengthDirection[1],freeMotion.arrow.arrowHead.lengthDirection[2],freeMotion.arrow.arrowHead.lengthDirection[3]});
//   protected Real freeMotion.arrow.arrowHead.e_x[1](unit = "1") = if noEvent(freeMotion.arrow.arrowHead.abs_n_x < 1e-10) then 1.0 else freeMotion.arrow.arrowHead.lengthDirection[1] / freeMotion.arrow.arrowHead.abs_n_x;
//   protected Real freeMotion.arrow.arrowHead.e_x[2](unit = "1") = if noEvent(freeMotion.arrow.arrowHead.abs_n_x < 1e-10) then 0.0 else freeMotion.arrow.arrowHead.lengthDirection[2] / freeMotion.arrow.arrowHead.abs_n_x;
//   protected Real freeMotion.arrow.arrowHead.e_x[3](unit = "1") = if noEvent(freeMotion.arrow.arrowHead.abs_n_x < 1e-10) then 0.0 else freeMotion.arrow.arrowHead.lengthDirection[3] / freeMotion.arrow.arrowHead.abs_n_x;
//   protected Real freeMotion.arrow.arrowHead.n_z_aux[1](unit = "1") = freeMotion.arrow.arrowHead.e_x[2] * freeMotion.arrow.arrowHead.widthDirection[3] - freeMotion.arrow.arrowHead.e_x[3] * freeMotion.arrow.arrowHead.widthDirection[2];
//   protected Real freeMotion.arrow.arrowHead.n_z_aux[2](unit = "1") = freeMotion.arrow.arrowHead.e_x[3] * freeMotion.arrow.arrowHead.widthDirection[1] - freeMotion.arrow.arrowHead.e_x[1] * freeMotion.arrow.arrowHead.widthDirection[3];
//   protected Real freeMotion.arrow.arrowHead.n_z_aux[3](unit = "1") = freeMotion.arrow.arrowHead.e_x[1] * freeMotion.arrow.arrowHead.widthDirection[2] - freeMotion.arrow.arrowHead.e_x[2] * freeMotion.arrow.arrowHead.widthDirection[1];
//   protected Real freeMotion.arrow.arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]},if noEvent(freeMotion.arrow.arrowHead.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowHead.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowHead.widthDirection[1],freeMotion.arrow.arrowHead.widthDirection[2],freeMotion.arrow.arrowHead.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]})[1];
//   protected Real freeMotion.arrow.arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]},if noEvent(freeMotion.arrow.arrowHead.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowHead.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowHead.widthDirection[1],freeMotion.arrow.arrowHead.widthDirection[2],freeMotion.arrow.arrowHead.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]})[2];
//   protected Real freeMotion.arrow.arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]},if noEvent(freeMotion.arrow.arrowHead.n_z_aux[1] ^ 2.0 + (freeMotion.arrow.arrowHead.n_z_aux[2] ^ 2.0 + freeMotion.arrow.arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {freeMotion.arrow.arrowHead.widthDirection[1],freeMotion.arrow.arrowHead.widthDirection[2],freeMotion.arrow.arrowHead.widthDirection[3]} else if noEvent(abs(freeMotion.arrow.arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{freeMotion.arrow.arrowHead.e_x[1],freeMotion.arrow.arrowHead.e_x[2],freeMotion.arrow.arrowHead.e_x[3]})[3];
//   protected output Real freeMotion.arrow.arrowHead.Form;
//   output Real freeMotion.arrow.arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real freeMotion.arrow.arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real freeMotion.arrow.arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real freeMotion.arrow.arrowHead.Material;
//   protected output Real freeMotion.arrow.arrowHead.Extra;
//   protected parameter Real freeMotion.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(freeMotion.R_rel_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from frame_a to frame_b at initial time";
//   protected parameter Real freeMotion.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(freeMotion.R_rel_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from frame_a to frame_b at initial time";
//   protected parameter Real freeMotion.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(freeMotion.R_rel_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from frame_a to frame_b at initial time";
//   protected parameter Real freeMotion.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(freeMotion.R_rel_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from frame_a to frame_b at initial time";
//   protected Real freeMotion.Q[1](start = freeMotion.Q_start[1], StateSelect = StateSelect.prefer) "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";
//   protected Real freeMotion.Q[2](start = freeMotion.Q_start[2], StateSelect = StateSelect.prefer) "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";
//   protected Real freeMotion.Q[3](start = freeMotion.Q_start[3], StateSelect = StateSelect.prefer) "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";
//   protected Real freeMotion.Q[4](start = freeMotion.Q_start[4], StateSelect = StateSelect.prefer) "Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)";
//   protected parameter Real freeMotion.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if freeMotion.sequence_start[1] == freeMotion.sequence_angleStates[1] AND freeMotion.sequence_start[2] == freeMotion.sequence_angleStates[2] AND freeMotion.sequence_start[3] == freeMotion.sequence_angleStates[3] then freeMotion.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(freeMotion.R_rel_start,{freeMotion.sequence_angleStates[1],freeMotion.sequence_angleStates[2],freeMotion.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real freeMotion.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if freeMotion.sequence_start[1] == freeMotion.sequence_angleStates[1] AND freeMotion.sequence_start[2] == freeMotion.sequence_angleStates[2] AND freeMotion.sequence_start[3] == freeMotion.sequence_angleStates[3] then freeMotion.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(freeMotion.R_rel_start,{freeMotion.sequence_angleStates[1],freeMotion.sequence_angleStates[2],freeMotion.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real freeMotion.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if freeMotion.sequence_start[1] == freeMotion.sequence_angleStates[1] AND freeMotion.sequence_start[2] == freeMotion.sequence_angleStates[2] AND freeMotion.sequence_start[3] == freeMotion.sequence_angleStates[3] then freeMotion.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(freeMotion.R_rel_start,{freeMotion.sequence_angleStates[1],freeMotion.sequence_angleStates[2],freeMotion.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real freeMotion.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = freeMotion.phi_start[1], StateSelect = StateSelect.never) "Dummy or 3 angles to rotate frame_a into frame_b";
//   protected Real freeMotion.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = freeMotion.phi_start[2], StateSelect = StateSelect.never) "Dummy or 3 angles to rotate frame_a into frame_b";
//   protected Real freeMotion.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = freeMotion.phi_start[3], StateSelect = StateSelect.never) "Dummy or 3 angles to rotate frame_a into frame_b";
//   protected Real freeMotion.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.never) "= der(phi)";
//   protected Real freeMotion.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.never) "= der(phi)";
//   protected Real freeMotion.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.never) "= der(phi)";
//   protected Real freeMotion.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real freeMotion.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real freeMotion.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real freeMotion.w_rel_b[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(freeMotion.R_rel_start,{freeMotion.w_rel_a_start[1],freeMotion.w_rel_a_start[2],freeMotion.w_rel_a_start[3]})[1], fixed = freeMotion.w_rel_a_fixed, StateSelect = StateSelect.always) "Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b";
//   protected Real freeMotion.w_rel_b[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(freeMotion.R_rel_start,{freeMotion.w_rel_a_start[1],freeMotion.w_rel_a_start[2],freeMotion.w_rel_a_start[3]})[2], fixed = freeMotion.w_rel_a_fixed, StateSelect = StateSelect.always) "Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b";
//   protected Real freeMotion.w_rel_b[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(freeMotion.R_rel_start,{freeMotion.w_rel_a_start[1],freeMotion.w_rel_a_start[2],freeMotion.w_rel_a_start[3]})[3], fixed = freeMotion.w_rel_a_fixed, StateSelect = StateSelect.always) "Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b";
//   Real freeMotion.R_rel.T[1,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[1,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[1,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[2,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[2,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[2,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[3,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[3,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.T[3,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.R_rel.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.R_rel.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.R_rel_inv.T[1,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[1,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[1,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[2,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[2,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[2,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[3,1] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[3,2] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.T[3,3] "Transformation matrix from world frame to local frame";
//   Real freeMotion.R_rel_inv.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.R_rel_inv.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real freeMotion.R_rel_inv.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass1.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass1.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass1.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass1.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass1.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass1.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass1.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass1.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass1.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass1.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass1.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass1.r_0[1](quantity = "Length", unit = "m", start = 3.0, fixed = true, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass1.r_0[2](quantity = "Length", unit = "m", start = 0.0, fixed = true, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass1.r_0[3](quantity = "Length", unit = "m", start = 0.0, fixed = true, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass1.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass1.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, fixed = true, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass1.v_0[3](quantity = "Velocity", unit = "m/s", start = -1.0, fixed = true, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass1.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass1.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass1.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass1.angles_fixed = true "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass1.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass1.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass1.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass1.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass1.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass1.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass1.w_0_fixed = true "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass1.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass1.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass1.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass1.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass1.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass1.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass1.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass1.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass1.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass1.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass1.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass1.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass1.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass1.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass1.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass1.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass1.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass1.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass1.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass1.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass1.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass1.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass1.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass1.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass1.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass1.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass1.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass1.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass1.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass1.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass1.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass1.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass1.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass1.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.w_0_start[1],referenceSystem.pointMass1.w_0_start[2],referenceSystem.pointMass1.w_0_start[3]})[1], fixed = referenceSystem.pointMass1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.w_0_start[1],referenceSystem.pointMass1.w_0_start[2],referenceSystem.pointMass1.w_0_start[3]})[2], fixed = referenceSystem.pointMass1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.w_0_start[1],referenceSystem.pointMass1.w_0_start[2],referenceSystem.pointMass1.w_0_start[3]})[3], fixed = referenceSystem.pointMass1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[1], fixed = referenceSystem.pointMass1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[2], fixed = referenceSystem.pointMass1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.z_0_start[1],referenceSystem.pointMass1.z_0_start[2],referenceSystem.pointMass1.z_0_start[3]})[3], fixed = referenceSystem.pointMass1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass1.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass1.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass1.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass1.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass1.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass1.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass1.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass1.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass1.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass1.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass1.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass1.Q[1](start = referenceSystem.pointMass1.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass1.Q[2](start = referenceSystem.pointMass1.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass1.Q[3](start = referenceSystem.pointMass1.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass1.Q[4](start = referenceSystem.pointMass1.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass1.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass1.sequence_start[1] == referenceSystem.pointMass1.sequence_angleStates[1] AND referenceSystem.pointMass1.sequence_start[2] == referenceSystem.pointMass1.sequence_angleStates[2] AND referenceSystem.pointMass1.sequence_start[3] == referenceSystem.pointMass1.sequence_angleStates[3] then referenceSystem.pointMass1.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.sequence_angleStates[1],referenceSystem.pointMass1.sequence_angleStates[2],referenceSystem.pointMass1.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass1.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass1.sequence_start[1] == referenceSystem.pointMass1.sequence_angleStates[1] AND referenceSystem.pointMass1.sequence_start[2] == referenceSystem.pointMass1.sequence_angleStates[2] AND referenceSystem.pointMass1.sequence_start[3] == referenceSystem.pointMass1.sequence_angleStates[3] then referenceSystem.pointMass1.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.sequence_angleStates[1],referenceSystem.pointMass1.sequence_angleStates[2],referenceSystem.pointMass1.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass1.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass1.sequence_start[1] == referenceSystem.pointMass1.sequence_angleStates[1] AND referenceSystem.pointMass1.sequence_start[2] == referenceSystem.pointMass1.sequence_angleStates[2] AND referenceSystem.pointMass1.sequence_start[3] == referenceSystem.pointMass1.sequence_angleStates[3] then referenceSystem.pointMass1.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass1.R_start,{referenceSystem.pointMass1.sequence_angleStates[1],referenceSystem.pointMass1.sequence_angleStates[2],referenceSystem.pointMass1.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass1.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass1.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass1.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass1.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass1.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass1.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass1.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass1.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass1.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass1.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass1.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass1.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass1.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass1.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass1.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass1.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass1.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass1.r_CM[1],referenceSystem.pointMass1.r_CM[2],referenceSystem.pointMass1.r_CM[3]}) > referenceSystem.pointMass1.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass1.r_CM[1],referenceSystem.pointMass1.r_CM[2],referenceSystem.pointMass1.r_CM[3]}) - (if referenceSystem.pointMass1.cylinderDiameter > 1.1 * referenceSystem.pointMass1.sphereDiameter then referenceSystem.pointMass1.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass1.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass1.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass1.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass1.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass1.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass1.cylinder.color[1] = Real(referenceSystem.pointMass1.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass1.cylinder.color[2] = Real(referenceSystem.pointMass1.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass1.cylinder.color[3] = Real(referenceSystem.pointMass1.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass1.cylinder.specularCoefficient = referenceSystem.pointMass1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass1.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass1.cylinder.lengthDirection[1],referenceSystem.pointMass1.cylinder.lengthDirection[2],referenceSystem.pointMass1.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass1.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass1.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass1.cylinder.lengthDirection[1] / referenceSystem.pointMass1.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass1.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass1.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass1.cylinder.lengthDirection[2] / referenceSystem.pointMass1.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass1.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass1.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass1.cylinder.lengthDirection[3] / referenceSystem.pointMass1.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass1.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass1.cylinder.e_x[2] * referenceSystem.pointMass1.cylinder.widthDirection[3] - referenceSystem.pointMass1.cylinder.e_x[3] * referenceSystem.pointMass1.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass1.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass1.cylinder.e_x[3] * referenceSystem.pointMass1.cylinder.widthDirection[1] - referenceSystem.pointMass1.cylinder.e_x[1] * referenceSystem.pointMass1.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass1.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass1.cylinder.e_x[1] * referenceSystem.pointMass1.cylinder.widthDirection[2] - referenceSystem.pointMass1.cylinder.e_x[2] * referenceSystem.pointMass1.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass1.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass1.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.cylinder.widthDirection[1],referenceSystem.pointMass1.cylinder.widthDirection[2],referenceSystem.pointMass1.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass1.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass1.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.cylinder.widthDirection[1],referenceSystem.pointMass1.cylinder.widthDirection[2],referenceSystem.pointMass1.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass1.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass1.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.cylinder.widthDirection[1],referenceSystem.pointMass1.cylinder.widthDirection[2],referenceSystem.pointMass1.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.cylinder.e_x[1],referenceSystem.pointMass1.cylinder.e_x[2],referenceSystem.pointMass1.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass1.cylinder.Form;
//   output Real referenceSystem.pointMass1.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass1.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass1.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.cylinder.Material;
//   protected output Real referenceSystem.pointMass1.cylinder.Extra;
//   parameter String referenceSystem.pointMass1.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass1.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass1.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass1.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass1.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass1.r_CM[1] - referenceSystem.pointMass1.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass1.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass1.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass1.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass1.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass1.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass1.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass1.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass1.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass1.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass1.sphere.color[1] = Real(referenceSystem.pointMass1.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass1.sphere.color[2] = Real(referenceSystem.pointMass1.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass1.sphere.color[3] = Real(referenceSystem.pointMass1.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass1.sphere.specularCoefficient = referenceSystem.pointMass1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass1.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass1.sphere.lengthDirection[1],referenceSystem.pointMass1.sphere.lengthDirection[2],referenceSystem.pointMass1.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass1.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass1.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass1.sphere.lengthDirection[1] / referenceSystem.pointMass1.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass1.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass1.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass1.sphere.lengthDirection[2] / referenceSystem.pointMass1.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass1.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass1.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass1.sphere.lengthDirection[3] / referenceSystem.pointMass1.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass1.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass1.sphere.e_x[2] * referenceSystem.pointMass1.sphere.widthDirection[3] - referenceSystem.pointMass1.sphere.e_x[3] * referenceSystem.pointMass1.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass1.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass1.sphere.e_x[3] * referenceSystem.pointMass1.sphere.widthDirection[1] - referenceSystem.pointMass1.sphere.e_x[1] * referenceSystem.pointMass1.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass1.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass1.sphere.e_x[1] * referenceSystem.pointMass1.sphere.widthDirection[2] - referenceSystem.pointMass1.sphere.e_x[2] * referenceSystem.pointMass1.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass1.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]},if noEvent(referenceSystem.pointMass1.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.sphere.widthDirection[1],referenceSystem.pointMass1.sphere.widthDirection[2],referenceSystem.pointMass1.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass1.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]},if noEvent(referenceSystem.pointMass1.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.sphere.widthDirection[1],referenceSystem.pointMass1.sphere.widthDirection[2],referenceSystem.pointMass1.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass1.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]},if noEvent(referenceSystem.pointMass1.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass1.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass1.sphere.widthDirection[1],referenceSystem.pointMass1.sphere.widthDirection[2],referenceSystem.pointMass1.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass1.sphere.e_x[1],referenceSystem.pointMass1.sphere.e_x[2],referenceSystem.pointMass1.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass1.sphere.Form;
//   output Real referenceSystem.pointMass1.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass1.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass1.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass1.sphere.Material;
//   protected output Real referenceSystem.pointMass1.sphere.Extra;
//   Real referenceSystem.pointMass2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass2.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass2.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass2.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass2.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass2.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass2.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass2.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass2.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass2.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass2.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass2.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass2.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass2.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass2.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass2.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass2.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass2.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass2.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass2.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass2.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass2.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass2.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass2.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass2.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass2.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass2.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass2.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass2.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass2.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass2.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass2.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass2.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass2.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass2.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass2.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass2.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass2.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass2.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass2.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass2.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass2.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass2.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass2.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass2.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass2.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass2.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass2.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass2.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass2.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass2.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass2.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass2.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass2.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass2.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass2.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass2.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass2.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass2.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass2.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass2.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass2.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass2.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.w_0_start[1],referenceSystem.pointMass2.w_0_start[2],referenceSystem.pointMass2.w_0_start[3]})[1], fixed = referenceSystem.pointMass2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.w_0_start[1],referenceSystem.pointMass2.w_0_start[2],referenceSystem.pointMass2.w_0_start[3]})[2], fixed = referenceSystem.pointMass2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.w_0_start[1],referenceSystem.pointMass2.w_0_start[2],referenceSystem.pointMass2.w_0_start[3]})[3], fixed = referenceSystem.pointMass2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[1], fixed = referenceSystem.pointMass2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[2], fixed = referenceSystem.pointMass2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.z_0_start[1],referenceSystem.pointMass2.z_0_start[2],referenceSystem.pointMass2.z_0_start[3]})[3], fixed = referenceSystem.pointMass2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass2.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass2.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass2.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass2.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass2.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass2.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass2.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass2.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass2.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass2.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass2.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass2.Q[1](start = referenceSystem.pointMass2.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass2.Q[2](start = referenceSystem.pointMass2.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass2.Q[3](start = referenceSystem.pointMass2.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass2.Q[4](start = referenceSystem.pointMass2.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass2.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass2.sequence_start[1] == referenceSystem.pointMass2.sequence_angleStates[1] AND referenceSystem.pointMass2.sequence_start[2] == referenceSystem.pointMass2.sequence_angleStates[2] AND referenceSystem.pointMass2.sequence_start[3] == referenceSystem.pointMass2.sequence_angleStates[3] then referenceSystem.pointMass2.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.sequence_angleStates[1],referenceSystem.pointMass2.sequence_angleStates[2],referenceSystem.pointMass2.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass2.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass2.sequence_start[1] == referenceSystem.pointMass2.sequence_angleStates[1] AND referenceSystem.pointMass2.sequence_start[2] == referenceSystem.pointMass2.sequence_angleStates[2] AND referenceSystem.pointMass2.sequence_start[3] == referenceSystem.pointMass2.sequence_angleStates[3] then referenceSystem.pointMass2.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.sequence_angleStates[1],referenceSystem.pointMass2.sequence_angleStates[2],referenceSystem.pointMass2.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass2.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass2.sequence_start[1] == referenceSystem.pointMass2.sequence_angleStates[1] AND referenceSystem.pointMass2.sequence_start[2] == referenceSystem.pointMass2.sequence_angleStates[2] AND referenceSystem.pointMass2.sequence_start[3] == referenceSystem.pointMass2.sequence_angleStates[3] then referenceSystem.pointMass2.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass2.R_start,{referenceSystem.pointMass2.sequence_angleStates[1],referenceSystem.pointMass2.sequence_angleStates[2],referenceSystem.pointMass2.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass2.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass2.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass2.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass2.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass2.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass2.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass2.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass2.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass2.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass2.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass2.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass2.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass2.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass2.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass2.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass2.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass2.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass2.r_CM[1],referenceSystem.pointMass2.r_CM[2],referenceSystem.pointMass2.r_CM[3]}) > referenceSystem.pointMass2.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass2.r_CM[1],referenceSystem.pointMass2.r_CM[2],referenceSystem.pointMass2.r_CM[3]}) - (if referenceSystem.pointMass2.cylinderDiameter > 1.1 * referenceSystem.pointMass2.sphereDiameter then referenceSystem.pointMass2.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass2.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass2.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass2.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass2.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass2.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass2.cylinder.color[1] = Real(referenceSystem.pointMass2.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass2.cylinder.color[2] = Real(referenceSystem.pointMass2.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass2.cylinder.color[3] = Real(referenceSystem.pointMass2.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass2.cylinder.specularCoefficient = referenceSystem.pointMass2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass2.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass2.cylinder.lengthDirection[1],referenceSystem.pointMass2.cylinder.lengthDirection[2],referenceSystem.pointMass2.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass2.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass2.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass2.cylinder.lengthDirection[1] / referenceSystem.pointMass2.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass2.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass2.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass2.cylinder.lengthDirection[2] / referenceSystem.pointMass2.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass2.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass2.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass2.cylinder.lengthDirection[3] / referenceSystem.pointMass2.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass2.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass2.cylinder.e_x[2] * referenceSystem.pointMass2.cylinder.widthDirection[3] - referenceSystem.pointMass2.cylinder.e_x[3] * referenceSystem.pointMass2.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass2.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass2.cylinder.e_x[3] * referenceSystem.pointMass2.cylinder.widthDirection[1] - referenceSystem.pointMass2.cylinder.e_x[1] * referenceSystem.pointMass2.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass2.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass2.cylinder.e_x[1] * referenceSystem.pointMass2.cylinder.widthDirection[2] - referenceSystem.pointMass2.cylinder.e_x[2] * referenceSystem.pointMass2.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass2.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass2.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.cylinder.widthDirection[1],referenceSystem.pointMass2.cylinder.widthDirection[2],referenceSystem.pointMass2.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass2.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass2.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.cylinder.widthDirection[1],referenceSystem.pointMass2.cylinder.widthDirection[2],referenceSystem.pointMass2.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass2.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass2.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.cylinder.widthDirection[1],referenceSystem.pointMass2.cylinder.widthDirection[2],referenceSystem.pointMass2.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.cylinder.e_x[1],referenceSystem.pointMass2.cylinder.e_x[2],referenceSystem.pointMass2.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass2.cylinder.Form;
//   output Real referenceSystem.pointMass2.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass2.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass2.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.cylinder.Material;
//   protected output Real referenceSystem.pointMass2.cylinder.Extra;
//   parameter String referenceSystem.pointMass2.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass2.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass2.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass2.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass2.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass2.r_CM[1] - referenceSystem.pointMass2.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass2.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass2.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass2.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass2.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass2.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass2.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass2.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass2.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass2.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass2.sphere.color[1] = Real(referenceSystem.pointMass2.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass2.sphere.color[2] = Real(referenceSystem.pointMass2.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass2.sphere.color[3] = Real(referenceSystem.pointMass2.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass2.sphere.specularCoefficient = referenceSystem.pointMass2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass2.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass2.sphere.lengthDirection[1],referenceSystem.pointMass2.sphere.lengthDirection[2],referenceSystem.pointMass2.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass2.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass2.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass2.sphere.lengthDirection[1] / referenceSystem.pointMass2.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass2.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass2.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass2.sphere.lengthDirection[2] / referenceSystem.pointMass2.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass2.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass2.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass2.sphere.lengthDirection[3] / referenceSystem.pointMass2.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass2.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass2.sphere.e_x[2] * referenceSystem.pointMass2.sphere.widthDirection[3] - referenceSystem.pointMass2.sphere.e_x[3] * referenceSystem.pointMass2.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass2.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass2.sphere.e_x[3] * referenceSystem.pointMass2.sphere.widthDirection[1] - referenceSystem.pointMass2.sphere.e_x[1] * referenceSystem.pointMass2.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass2.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass2.sphere.e_x[1] * referenceSystem.pointMass2.sphere.widthDirection[2] - referenceSystem.pointMass2.sphere.e_x[2] * referenceSystem.pointMass2.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass2.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]},if noEvent(referenceSystem.pointMass2.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.sphere.widthDirection[1],referenceSystem.pointMass2.sphere.widthDirection[2],referenceSystem.pointMass2.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass2.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]},if noEvent(referenceSystem.pointMass2.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.sphere.widthDirection[1],referenceSystem.pointMass2.sphere.widthDirection[2],referenceSystem.pointMass2.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass2.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]},if noEvent(referenceSystem.pointMass2.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass2.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass2.sphere.widthDirection[1],referenceSystem.pointMass2.sphere.widthDirection[2],referenceSystem.pointMass2.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass2.sphere.e_x[1],referenceSystem.pointMass2.sphere.e_x[2],referenceSystem.pointMass2.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass2.sphere.Form;
//   output Real referenceSystem.pointMass2.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass2.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass2.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass2.sphere.Material;
//   protected output Real referenceSystem.pointMass2.sphere.Extra;
//   Real referenceSystem.pointMass3.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass3.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass3.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass3.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass3.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass3.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass3.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass3.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass3.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass3.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass3.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass3.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass3.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass3.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass3.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass3.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass3.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass3.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass3.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass3.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass3.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass3.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass3.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass3.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass3.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass3.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass3.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass3.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass3.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass3.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass3.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass3.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass3.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass3.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass3.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass3.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass3.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass3.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass3.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass3.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass3.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass3.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass3.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass3.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass3.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass3.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass3.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass3.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass3.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass3.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass3.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass3.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass3.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass3.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass3.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass3.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass3.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass3.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass3.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass3.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass3.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass3.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass3.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass3.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass3.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass3.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass3.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass3.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass3.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass3.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass3.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass3.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass3.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass3.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass3.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.w_0_start[1],referenceSystem.pointMass3.w_0_start[2],referenceSystem.pointMass3.w_0_start[3]})[1], fixed = referenceSystem.pointMass3.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.w_0_start[1],referenceSystem.pointMass3.w_0_start[2],referenceSystem.pointMass3.w_0_start[3]})[2], fixed = referenceSystem.pointMass3.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.w_0_start[1],referenceSystem.pointMass3.w_0_start[2],referenceSystem.pointMass3.w_0_start[3]})[3], fixed = referenceSystem.pointMass3.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[1], fixed = referenceSystem.pointMass3.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[2], fixed = referenceSystem.pointMass3.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.z_0_start[1],referenceSystem.pointMass3.z_0_start[2],referenceSystem.pointMass3.z_0_start[3]})[3], fixed = referenceSystem.pointMass3.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass3.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass3.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass3.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass3.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass3.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass3.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass3.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass3.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass3.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass3.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass3.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass3.Q[1](start = referenceSystem.pointMass3.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass3.Q[2](start = referenceSystem.pointMass3.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass3.Q[3](start = referenceSystem.pointMass3.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass3.Q[4](start = referenceSystem.pointMass3.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass3.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass3.sequence_start[1] == referenceSystem.pointMass3.sequence_angleStates[1] AND referenceSystem.pointMass3.sequence_start[2] == referenceSystem.pointMass3.sequence_angleStates[2] AND referenceSystem.pointMass3.sequence_start[3] == referenceSystem.pointMass3.sequence_angleStates[3] then referenceSystem.pointMass3.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.sequence_angleStates[1],referenceSystem.pointMass3.sequence_angleStates[2],referenceSystem.pointMass3.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass3.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass3.sequence_start[1] == referenceSystem.pointMass3.sequence_angleStates[1] AND referenceSystem.pointMass3.sequence_start[2] == referenceSystem.pointMass3.sequence_angleStates[2] AND referenceSystem.pointMass3.sequence_start[3] == referenceSystem.pointMass3.sequence_angleStates[3] then referenceSystem.pointMass3.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.sequence_angleStates[1],referenceSystem.pointMass3.sequence_angleStates[2],referenceSystem.pointMass3.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass3.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass3.sequence_start[1] == referenceSystem.pointMass3.sequence_angleStates[1] AND referenceSystem.pointMass3.sequence_start[2] == referenceSystem.pointMass3.sequence_angleStates[2] AND referenceSystem.pointMass3.sequence_start[3] == referenceSystem.pointMass3.sequence_angleStates[3] then referenceSystem.pointMass3.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass3.R_start,{referenceSystem.pointMass3.sequence_angleStates[1],referenceSystem.pointMass3.sequence_angleStates[2],referenceSystem.pointMass3.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass3.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass3.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass3.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass3.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass3.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass3.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass3.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass3.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass3.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass3.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass3.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass3.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass3.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass3.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass3.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass3.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass3.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass3.r_CM[1],referenceSystem.pointMass3.r_CM[2],referenceSystem.pointMass3.r_CM[3]}) > referenceSystem.pointMass3.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass3.r_CM[1],referenceSystem.pointMass3.r_CM[2],referenceSystem.pointMass3.r_CM[3]}) - (if referenceSystem.pointMass3.cylinderDiameter > 1.1 * referenceSystem.pointMass3.sphereDiameter then referenceSystem.pointMass3.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass3.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass3.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass3.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass3.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass3.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass3.cylinder.color[1] = Real(referenceSystem.pointMass3.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass3.cylinder.color[2] = Real(referenceSystem.pointMass3.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass3.cylinder.color[3] = Real(referenceSystem.pointMass3.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass3.cylinder.specularCoefficient = referenceSystem.pointMass3.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass3.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass3.cylinder.lengthDirection[1],referenceSystem.pointMass3.cylinder.lengthDirection[2],referenceSystem.pointMass3.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass3.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass3.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass3.cylinder.lengthDirection[1] / referenceSystem.pointMass3.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass3.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass3.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass3.cylinder.lengthDirection[2] / referenceSystem.pointMass3.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass3.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass3.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass3.cylinder.lengthDirection[3] / referenceSystem.pointMass3.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass3.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass3.cylinder.e_x[2] * referenceSystem.pointMass3.cylinder.widthDirection[3] - referenceSystem.pointMass3.cylinder.e_x[3] * referenceSystem.pointMass3.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass3.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass3.cylinder.e_x[3] * referenceSystem.pointMass3.cylinder.widthDirection[1] - referenceSystem.pointMass3.cylinder.e_x[1] * referenceSystem.pointMass3.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass3.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass3.cylinder.e_x[1] * referenceSystem.pointMass3.cylinder.widthDirection[2] - referenceSystem.pointMass3.cylinder.e_x[2] * referenceSystem.pointMass3.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass3.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass3.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.cylinder.widthDirection[1],referenceSystem.pointMass3.cylinder.widthDirection[2],referenceSystem.pointMass3.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass3.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass3.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.cylinder.widthDirection[1],referenceSystem.pointMass3.cylinder.widthDirection[2],referenceSystem.pointMass3.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass3.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass3.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.cylinder.widthDirection[1],referenceSystem.pointMass3.cylinder.widthDirection[2],referenceSystem.pointMass3.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.cylinder.e_x[1],referenceSystem.pointMass3.cylinder.e_x[2],referenceSystem.pointMass3.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass3.cylinder.Form;
//   output Real referenceSystem.pointMass3.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass3.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass3.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.cylinder.Material;
//   protected output Real referenceSystem.pointMass3.cylinder.Extra;
//   parameter String referenceSystem.pointMass3.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass3.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass3.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass3.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass3.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass3.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass3.r_CM[1] - referenceSystem.pointMass3.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass3.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass3.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass3.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass3.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass3.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass3.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass3.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass3.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass3.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass3.sphere.color[1] = Real(referenceSystem.pointMass3.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass3.sphere.color[2] = Real(referenceSystem.pointMass3.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass3.sphere.color[3] = Real(referenceSystem.pointMass3.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass3.sphere.specularCoefficient = referenceSystem.pointMass3.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass3.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass3.sphere.lengthDirection[1],referenceSystem.pointMass3.sphere.lengthDirection[2],referenceSystem.pointMass3.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass3.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass3.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass3.sphere.lengthDirection[1] / referenceSystem.pointMass3.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass3.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass3.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass3.sphere.lengthDirection[2] / referenceSystem.pointMass3.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass3.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass3.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass3.sphere.lengthDirection[3] / referenceSystem.pointMass3.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass3.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass3.sphere.e_x[2] * referenceSystem.pointMass3.sphere.widthDirection[3] - referenceSystem.pointMass3.sphere.e_x[3] * referenceSystem.pointMass3.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass3.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass3.sphere.e_x[3] * referenceSystem.pointMass3.sphere.widthDirection[1] - referenceSystem.pointMass3.sphere.e_x[1] * referenceSystem.pointMass3.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass3.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass3.sphere.e_x[1] * referenceSystem.pointMass3.sphere.widthDirection[2] - referenceSystem.pointMass3.sphere.e_x[2] * referenceSystem.pointMass3.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass3.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]},if noEvent(referenceSystem.pointMass3.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.sphere.widthDirection[1],referenceSystem.pointMass3.sphere.widthDirection[2],referenceSystem.pointMass3.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass3.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]},if noEvent(referenceSystem.pointMass3.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.sphere.widthDirection[1],referenceSystem.pointMass3.sphere.widthDirection[2],referenceSystem.pointMass3.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass3.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]},if noEvent(referenceSystem.pointMass3.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass3.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass3.sphere.widthDirection[1],referenceSystem.pointMass3.sphere.widthDirection[2],referenceSystem.pointMass3.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass3.sphere.e_x[1],referenceSystem.pointMass3.sphere.e_x[2],referenceSystem.pointMass3.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass3.sphere.Form;
//   output Real referenceSystem.pointMass3.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass3.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass3.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass3.sphere.Material;
//   protected output Real referenceSystem.pointMass3.sphere.Extra;
//   Real referenceSystem.pointMass4.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass4.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass4.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass4.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass4.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass4.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass4.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass4.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass4.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass4.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass4.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass4.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass4.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass4.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass4.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass4.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass4.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass4.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass4.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass4.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass4.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass4.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass4.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass4.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass4.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass4.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass4.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass4.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass4.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass4.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass4.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass4.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass4.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass4.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass4.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass4.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass4.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass4.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass4.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass4.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass4.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass4.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass4.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass4.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass4.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass4.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass4.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass4.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass4.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass4.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass4.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass4.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass4.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass4.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass4.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass4.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass4.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass4.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass4.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass4.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass4.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass4.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass4.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass4.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass4.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass4.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass4.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass4.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass4.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass4.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass4.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass4.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass4.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass4.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass4.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.w_0_start[1],referenceSystem.pointMass4.w_0_start[2],referenceSystem.pointMass4.w_0_start[3]})[1], fixed = referenceSystem.pointMass4.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.w_0_start[1],referenceSystem.pointMass4.w_0_start[2],referenceSystem.pointMass4.w_0_start[3]})[2], fixed = referenceSystem.pointMass4.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.w_0_start[1],referenceSystem.pointMass4.w_0_start[2],referenceSystem.pointMass4.w_0_start[3]})[3], fixed = referenceSystem.pointMass4.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[1], fixed = referenceSystem.pointMass4.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[2], fixed = referenceSystem.pointMass4.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.z_0_start[1],referenceSystem.pointMass4.z_0_start[2],referenceSystem.pointMass4.z_0_start[3]})[3], fixed = referenceSystem.pointMass4.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass4.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass4.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass4.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass4.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass4.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass4.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass4.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass4.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass4.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass4.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass4.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass4.Q[1](start = referenceSystem.pointMass4.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass4.Q[2](start = referenceSystem.pointMass4.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass4.Q[3](start = referenceSystem.pointMass4.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass4.Q[4](start = referenceSystem.pointMass4.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass4.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass4.sequence_start[1] == referenceSystem.pointMass4.sequence_angleStates[1] AND referenceSystem.pointMass4.sequence_start[2] == referenceSystem.pointMass4.sequence_angleStates[2] AND referenceSystem.pointMass4.sequence_start[3] == referenceSystem.pointMass4.sequence_angleStates[3] then referenceSystem.pointMass4.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.sequence_angleStates[1],referenceSystem.pointMass4.sequence_angleStates[2],referenceSystem.pointMass4.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass4.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass4.sequence_start[1] == referenceSystem.pointMass4.sequence_angleStates[1] AND referenceSystem.pointMass4.sequence_start[2] == referenceSystem.pointMass4.sequence_angleStates[2] AND referenceSystem.pointMass4.sequence_start[3] == referenceSystem.pointMass4.sequence_angleStates[3] then referenceSystem.pointMass4.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.sequence_angleStates[1],referenceSystem.pointMass4.sequence_angleStates[2],referenceSystem.pointMass4.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass4.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass4.sequence_start[1] == referenceSystem.pointMass4.sequence_angleStates[1] AND referenceSystem.pointMass4.sequence_start[2] == referenceSystem.pointMass4.sequence_angleStates[2] AND referenceSystem.pointMass4.sequence_start[3] == referenceSystem.pointMass4.sequence_angleStates[3] then referenceSystem.pointMass4.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass4.R_start,{referenceSystem.pointMass4.sequence_angleStates[1],referenceSystem.pointMass4.sequence_angleStates[2],referenceSystem.pointMass4.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass4.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass4.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass4.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass4.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass4.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass4.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass4.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass4.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass4.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass4.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass4.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass4.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass4.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass4.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass4.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass4.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass4.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass4.r_CM[1],referenceSystem.pointMass4.r_CM[2],referenceSystem.pointMass4.r_CM[3]}) > referenceSystem.pointMass4.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass4.r_CM[1],referenceSystem.pointMass4.r_CM[2],referenceSystem.pointMass4.r_CM[3]}) - (if referenceSystem.pointMass4.cylinderDiameter > 1.1 * referenceSystem.pointMass4.sphereDiameter then referenceSystem.pointMass4.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass4.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass4.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass4.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass4.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass4.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass4.cylinder.color[1] = Real(referenceSystem.pointMass4.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass4.cylinder.color[2] = Real(referenceSystem.pointMass4.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass4.cylinder.color[3] = Real(referenceSystem.pointMass4.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass4.cylinder.specularCoefficient = referenceSystem.pointMass4.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass4.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass4.cylinder.lengthDirection[1],referenceSystem.pointMass4.cylinder.lengthDirection[2],referenceSystem.pointMass4.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass4.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass4.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass4.cylinder.lengthDirection[1] / referenceSystem.pointMass4.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass4.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass4.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass4.cylinder.lengthDirection[2] / referenceSystem.pointMass4.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass4.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass4.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass4.cylinder.lengthDirection[3] / referenceSystem.pointMass4.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass4.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass4.cylinder.e_x[2] * referenceSystem.pointMass4.cylinder.widthDirection[3] - referenceSystem.pointMass4.cylinder.e_x[3] * referenceSystem.pointMass4.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass4.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass4.cylinder.e_x[3] * referenceSystem.pointMass4.cylinder.widthDirection[1] - referenceSystem.pointMass4.cylinder.e_x[1] * referenceSystem.pointMass4.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass4.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass4.cylinder.e_x[1] * referenceSystem.pointMass4.cylinder.widthDirection[2] - referenceSystem.pointMass4.cylinder.e_x[2] * referenceSystem.pointMass4.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass4.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass4.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.cylinder.widthDirection[1],referenceSystem.pointMass4.cylinder.widthDirection[2],referenceSystem.pointMass4.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass4.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass4.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.cylinder.widthDirection[1],referenceSystem.pointMass4.cylinder.widthDirection[2],referenceSystem.pointMass4.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass4.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass4.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.cylinder.widthDirection[1],referenceSystem.pointMass4.cylinder.widthDirection[2],referenceSystem.pointMass4.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.cylinder.e_x[1],referenceSystem.pointMass4.cylinder.e_x[2],referenceSystem.pointMass4.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass4.cylinder.Form;
//   output Real referenceSystem.pointMass4.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass4.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass4.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.cylinder.Material;
//   protected output Real referenceSystem.pointMass4.cylinder.Extra;
//   parameter String referenceSystem.pointMass4.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass4.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass4.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass4.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass4.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass4.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass4.r_CM[1] - referenceSystem.pointMass4.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass4.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass4.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass4.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass4.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass4.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass4.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass4.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass4.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass4.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass4.sphere.color[1] = Real(referenceSystem.pointMass4.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass4.sphere.color[2] = Real(referenceSystem.pointMass4.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass4.sphere.color[3] = Real(referenceSystem.pointMass4.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass4.sphere.specularCoefficient = referenceSystem.pointMass4.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass4.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass4.sphere.lengthDirection[1],referenceSystem.pointMass4.sphere.lengthDirection[2],referenceSystem.pointMass4.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass4.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass4.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass4.sphere.lengthDirection[1] / referenceSystem.pointMass4.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass4.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass4.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass4.sphere.lengthDirection[2] / referenceSystem.pointMass4.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass4.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass4.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass4.sphere.lengthDirection[3] / referenceSystem.pointMass4.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass4.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass4.sphere.e_x[2] * referenceSystem.pointMass4.sphere.widthDirection[3] - referenceSystem.pointMass4.sphere.e_x[3] * referenceSystem.pointMass4.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass4.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass4.sphere.e_x[3] * referenceSystem.pointMass4.sphere.widthDirection[1] - referenceSystem.pointMass4.sphere.e_x[1] * referenceSystem.pointMass4.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass4.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass4.sphere.e_x[1] * referenceSystem.pointMass4.sphere.widthDirection[2] - referenceSystem.pointMass4.sphere.e_x[2] * referenceSystem.pointMass4.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass4.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]},if noEvent(referenceSystem.pointMass4.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.sphere.widthDirection[1],referenceSystem.pointMass4.sphere.widthDirection[2],referenceSystem.pointMass4.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass4.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]},if noEvent(referenceSystem.pointMass4.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.sphere.widthDirection[1],referenceSystem.pointMass4.sphere.widthDirection[2],referenceSystem.pointMass4.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass4.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]},if noEvent(referenceSystem.pointMass4.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass4.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass4.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass4.sphere.widthDirection[1],referenceSystem.pointMass4.sphere.widthDirection[2],referenceSystem.pointMass4.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass4.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass4.sphere.e_x[1],referenceSystem.pointMass4.sphere.e_x[2],referenceSystem.pointMass4.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass4.sphere.Form;
//   output Real referenceSystem.pointMass4.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass4.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass4.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass4.sphere.Material;
//   protected output Real referenceSystem.pointMass4.sphere.Extra;
//   Real referenceSystem.pointMass5.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass5.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass5.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass5.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass5.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass5.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass5.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass5.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass5.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass5.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass5.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass5.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass5.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass5.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass5.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass5.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass5.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass5.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass5.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass5.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass5.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass5.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass5.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass5.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass5.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass5.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass5.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass5.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass5.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass5.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass5.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass5.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass5.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass5.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass5.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass5.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass5.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass5.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass5.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass5.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass5.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass5.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass5.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass5.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass5.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass5.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass5.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass5.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass5.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass5.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass5.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass5.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass5.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass5.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass5.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass5.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass5.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass5.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass5.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass5.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass5.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass5.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass5.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass5.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass5.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass5.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass5.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass5.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass5.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass5.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass5.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass5.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass5.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass5.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass5.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.w_0_start[1],referenceSystem.pointMass5.w_0_start[2],referenceSystem.pointMass5.w_0_start[3]})[1], fixed = referenceSystem.pointMass5.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.w_0_start[1],referenceSystem.pointMass5.w_0_start[2],referenceSystem.pointMass5.w_0_start[3]})[2], fixed = referenceSystem.pointMass5.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.w_0_start[1],referenceSystem.pointMass5.w_0_start[2],referenceSystem.pointMass5.w_0_start[3]})[3], fixed = referenceSystem.pointMass5.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[1], fixed = referenceSystem.pointMass5.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[2], fixed = referenceSystem.pointMass5.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.z_0_start[1],referenceSystem.pointMass5.z_0_start[2],referenceSystem.pointMass5.z_0_start[3]})[3], fixed = referenceSystem.pointMass5.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass5.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass5.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass5.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass5.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass5.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass5.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass5.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass5.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass5.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass5.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass5.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass5.Q[1](start = referenceSystem.pointMass5.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass5.Q[2](start = referenceSystem.pointMass5.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass5.Q[3](start = referenceSystem.pointMass5.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass5.Q[4](start = referenceSystem.pointMass5.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass5.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass5.sequence_start[1] == referenceSystem.pointMass5.sequence_angleStates[1] AND referenceSystem.pointMass5.sequence_start[2] == referenceSystem.pointMass5.sequence_angleStates[2] AND referenceSystem.pointMass5.sequence_start[3] == referenceSystem.pointMass5.sequence_angleStates[3] then referenceSystem.pointMass5.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.sequence_angleStates[1],referenceSystem.pointMass5.sequence_angleStates[2],referenceSystem.pointMass5.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass5.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass5.sequence_start[1] == referenceSystem.pointMass5.sequence_angleStates[1] AND referenceSystem.pointMass5.sequence_start[2] == referenceSystem.pointMass5.sequence_angleStates[2] AND referenceSystem.pointMass5.sequence_start[3] == referenceSystem.pointMass5.sequence_angleStates[3] then referenceSystem.pointMass5.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.sequence_angleStates[1],referenceSystem.pointMass5.sequence_angleStates[2],referenceSystem.pointMass5.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass5.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass5.sequence_start[1] == referenceSystem.pointMass5.sequence_angleStates[1] AND referenceSystem.pointMass5.sequence_start[2] == referenceSystem.pointMass5.sequence_angleStates[2] AND referenceSystem.pointMass5.sequence_start[3] == referenceSystem.pointMass5.sequence_angleStates[3] then referenceSystem.pointMass5.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass5.R_start,{referenceSystem.pointMass5.sequence_angleStates[1],referenceSystem.pointMass5.sequence_angleStates[2],referenceSystem.pointMass5.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass5.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass5.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass5.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass5.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass5.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass5.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass5.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass5.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass5.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass5.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass5.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass5.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass5.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass5.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass5.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass5.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass5.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass5.r_CM[1],referenceSystem.pointMass5.r_CM[2],referenceSystem.pointMass5.r_CM[3]}) > referenceSystem.pointMass5.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass5.r_CM[1],referenceSystem.pointMass5.r_CM[2],referenceSystem.pointMass5.r_CM[3]}) - (if referenceSystem.pointMass5.cylinderDiameter > 1.1 * referenceSystem.pointMass5.sphereDiameter then referenceSystem.pointMass5.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass5.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass5.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass5.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass5.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass5.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass5.cylinder.color[1] = Real(referenceSystem.pointMass5.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass5.cylinder.color[2] = Real(referenceSystem.pointMass5.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass5.cylinder.color[3] = Real(referenceSystem.pointMass5.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass5.cylinder.specularCoefficient = referenceSystem.pointMass5.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass5.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass5.cylinder.lengthDirection[1],referenceSystem.pointMass5.cylinder.lengthDirection[2],referenceSystem.pointMass5.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass5.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass5.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass5.cylinder.lengthDirection[1] / referenceSystem.pointMass5.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass5.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass5.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass5.cylinder.lengthDirection[2] / referenceSystem.pointMass5.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass5.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass5.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass5.cylinder.lengthDirection[3] / referenceSystem.pointMass5.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass5.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass5.cylinder.e_x[2] * referenceSystem.pointMass5.cylinder.widthDirection[3] - referenceSystem.pointMass5.cylinder.e_x[3] * referenceSystem.pointMass5.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass5.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass5.cylinder.e_x[3] * referenceSystem.pointMass5.cylinder.widthDirection[1] - referenceSystem.pointMass5.cylinder.e_x[1] * referenceSystem.pointMass5.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass5.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass5.cylinder.e_x[1] * referenceSystem.pointMass5.cylinder.widthDirection[2] - referenceSystem.pointMass5.cylinder.e_x[2] * referenceSystem.pointMass5.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass5.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass5.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.cylinder.widthDirection[1],referenceSystem.pointMass5.cylinder.widthDirection[2],referenceSystem.pointMass5.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass5.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass5.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.cylinder.widthDirection[1],referenceSystem.pointMass5.cylinder.widthDirection[2],referenceSystem.pointMass5.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass5.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass5.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.cylinder.widthDirection[1],referenceSystem.pointMass5.cylinder.widthDirection[2],referenceSystem.pointMass5.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.cylinder.e_x[1],referenceSystem.pointMass5.cylinder.e_x[2],referenceSystem.pointMass5.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass5.cylinder.Form;
//   output Real referenceSystem.pointMass5.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass5.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass5.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.cylinder.Material;
//   protected output Real referenceSystem.pointMass5.cylinder.Extra;
//   parameter String referenceSystem.pointMass5.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass5.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass5.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass5.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass5.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass5.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass5.r_CM[1] - referenceSystem.pointMass5.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass5.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass5.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass5.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass5.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass5.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass5.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass5.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass5.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass5.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass5.sphere.color[1] = Real(referenceSystem.pointMass5.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass5.sphere.color[2] = Real(referenceSystem.pointMass5.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass5.sphere.color[3] = Real(referenceSystem.pointMass5.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass5.sphere.specularCoefficient = referenceSystem.pointMass5.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass5.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass5.sphere.lengthDirection[1],referenceSystem.pointMass5.sphere.lengthDirection[2],referenceSystem.pointMass5.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass5.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass5.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass5.sphere.lengthDirection[1] / referenceSystem.pointMass5.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass5.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass5.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass5.sphere.lengthDirection[2] / referenceSystem.pointMass5.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass5.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass5.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass5.sphere.lengthDirection[3] / referenceSystem.pointMass5.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass5.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass5.sphere.e_x[2] * referenceSystem.pointMass5.sphere.widthDirection[3] - referenceSystem.pointMass5.sphere.e_x[3] * referenceSystem.pointMass5.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass5.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass5.sphere.e_x[3] * referenceSystem.pointMass5.sphere.widthDirection[1] - referenceSystem.pointMass5.sphere.e_x[1] * referenceSystem.pointMass5.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass5.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass5.sphere.e_x[1] * referenceSystem.pointMass5.sphere.widthDirection[2] - referenceSystem.pointMass5.sphere.e_x[2] * referenceSystem.pointMass5.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass5.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]},if noEvent(referenceSystem.pointMass5.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.sphere.widthDirection[1],referenceSystem.pointMass5.sphere.widthDirection[2],referenceSystem.pointMass5.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass5.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]},if noEvent(referenceSystem.pointMass5.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.sphere.widthDirection[1],referenceSystem.pointMass5.sphere.widthDirection[2],referenceSystem.pointMass5.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass5.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]},if noEvent(referenceSystem.pointMass5.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass5.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass5.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass5.sphere.widthDirection[1],referenceSystem.pointMass5.sphere.widthDirection[2],referenceSystem.pointMass5.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass5.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass5.sphere.e_x[1],referenceSystem.pointMass5.sphere.e_x[2],referenceSystem.pointMass5.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass5.sphere.Form;
//   output Real referenceSystem.pointMass5.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass5.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass5.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass5.sphere.Material;
//   protected output Real referenceSystem.pointMass5.sphere.Extra;
//   Real referenceSystem.pointMass6.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass6.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass6.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.pointMass6.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass6.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass6.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.pointMass6.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass6.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass6.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.pointMass6.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass6.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.pointMass6.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.pointMass6.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real referenceSystem.pointMass6.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass6.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass6.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real referenceSystem.pointMass6.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 1.0 "Mass of rigid body";
//   parameter Real referenceSystem.pointMass6.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass6.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real referenceSystem.pointMass6.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real referenceSystem.pointMass6.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass6.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real referenceSystem.pointMass6.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real referenceSystem.pointMass6.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass6.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass6.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real referenceSystem.pointMass6.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass6.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass6.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real referenceSystem.pointMass6.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass6.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real referenceSystem.pointMass6.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean referenceSystem.pointMass6.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass6.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass6.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real referenceSystem.pointMass6.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer referenceSystem.pointMass6.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass6.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer referenceSystem.pointMass6.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean referenceSystem.pointMass6.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass6.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass6.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real referenceSystem.pointMass6.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean referenceSystem.pointMass6.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real referenceSystem.pointMass6.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass6.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass6.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real referenceSystem.pointMass6.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer referenceSystem.pointMass6.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer referenceSystem.pointMass6.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer referenceSystem.pointMass6.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real referenceSystem.pointMass6.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.pointMass6.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer referenceSystem.pointMass6.cylinderColor[1](min = 0, max = 255) = referenceSystem.pointMass6.sphereColor[1] "Color of cylinder";
//   input Integer referenceSystem.pointMass6.cylinderColor[2](min = 0, max = 255) = referenceSystem.pointMass6.sphereColor[2] "Color of cylinder";
//   input Integer referenceSystem.pointMass6.cylinderColor[3](min = 0, max = 255) = referenceSystem.pointMass6.sphereColor[3] "Color of cylinder";
//   input Real referenceSystem.pointMass6.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean referenceSystem.pointMass6.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean referenceSystem.pointMass6.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer referenceSystem.pointMass6.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass6.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer referenceSystem.pointMass6.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real referenceSystem.pointMass6.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_11 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_21 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_22 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_31 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_32 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = referenceSystem.pointMass6.I_33 "inertia tensor";
//   parameter Real referenceSystem.pointMass6.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real referenceSystem.pointMass6.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass6.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass6.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real referenceSystem.pointMass6.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass6.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real referenceSystem.pointMass6.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real referenceSystem.pointMass6.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.w_0_start[1],referenceSystem.pointMass6.w_0_start[2],referenceSystem.pointMass6.w_0_start[3]})[1], fixed = referenceSystem.pointMass6.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.w_0_start[1],referenceSystem.pointMass6.w_0_start[2],referenceSystem.pointMass6.w_0_start[3]})[2], fixed = referenceSystem.pointMass6.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.w_0_start[1],referenceSystem.pointMass6.w_0_start[2],referenceSystem.pointMass6.w_0_start[3]})[3], fixed = referenceSystem.pointMass6.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[1], fixed = referenceSystem.pointMass6.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[2], fixed = referenceSystem.pointMass6.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.z_0_start[1],referenceSystem.pointMass6.z_0_start[2],referenceSystem.pointMass6.z_0_start[3]})[3], fixed = referenceSystem.pointMass6.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real referenceSystem.pointMass6.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass6.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real referenceSystem.pointMass6.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real referenceSystem.pointMass6.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass6.R_start,{0.0,0.0,0.0,1.0})[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass6.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass6.R_start,{0.0,0.0,0.0,1.0})[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass6.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass6.R_start,{0.0,0.0,0.0,1.0})[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real referenceSystem.pointMass6.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(referenceSystem.pointMass6.R_start,{0.0,0.0,0.0,1.0})[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real referenceSystem.pointMass6.Q[1](start = referenceSystem.pointMass6.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass6.Q[2](start = referenceSystem.pointMass6.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass6.Q[3](start = referenceSystem.pointMass6.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real referenceSystem.pointMass6.Q[4](start = referenceSystem.pointMass6.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real referenceSystem.pointMass6.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass6.sequence_start[1] == referenceSystem.pointMass6.sequence_angleStates[1] AND referenceSystem.pointMass6.sequence_start[2] == referenceSystem.pointMass6.sequence_angleStates[2] AND referenceSystem.pointMass6.sequence_start[3] == referenceSystem.pointMass6.sequence_angleStates[3] then referenceSystem.pointMass6.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.sequence_angleStates[1],referenceSystem.pointMass6.sequence_angleStates[2],referenceSystem.pointMass6.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass6.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass6.sequence_start[1] == referenceSystem.pointMass6.sequence_angleStates[1] AND referenceSystem.pointMass6.sequence_start[2] == referenceSystem.pointMass6.sequence_angleStates[2] AND referenceSystem.pointMass6.sequence_start[3] == referenceSystem.pointMass6.sequence_angleStates[3] then referenceSystem.pointMass6.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.sequence_angleStates[1],referenceSystem.pointMass6.sequence_angleStates[2],referenceSystem.pointMass6.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real referenceSystem.pointMass6.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if referenceSystem.pointMass6.sequence_start[1] == referenceSystem.pointMass6.sequence_angleStates[1] AND referenceSystem.pointMass6.sequence_start[2] == referenceSystem.pointMass6.sequence_angleStates[2] AND referenceSystem.pointMass6.sequence_start[3] == referenceSystem.pointMass6.sequence_angleStates[3] then referenceSystem.pointMass6.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(referenceSystem.pointMass6.R_start,{referenceSystem.pointMass6.sequence_angleStates[1],referenceSystem.pointMass6.sequence_angleStates[2],referenceSystem.pointMass6.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real referenceSystem.pointMass6.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass6.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass6.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass6.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass6.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = referenceSystem.pointMass6.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real referenceSystem.pointMass6.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass6.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass6.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real referenceSystem.pointMass6.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass6.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real referenceSystem.pointMass6.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String referenceSystem.pointMass6.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass6.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.cylinder.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.cylinder.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.cylinder.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.lengthDirection[1](unit = "1") = referenceSystem.pointMass6.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.lengthDirection[2](unit = "1") = referenceSystem.pointMass6.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.lengthDirection[3](unit = "1") = referenceSystem.pointMass6.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({referenceSystem.pointMass6.r_CM[1],referenceSystem.pointMass6.r_CM[2],referenceSystem.pointMass6.r_CM[3]}) > referenceSystem.pointMass6.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({referenceSystem.pointMass6.r_CM[1],referenceSystem.pointMass6.r_CM[2],referenceSystem.pointMass6.r_CM[3]}) - (if referenceSystem.pointMass6.cylinderDiameter > 1.1 * referenceSystem.pointMass6.sphereDiameter then referenceSystem.pointMass6.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real referenceSystem.pointMass6.cylinder.width(quantity = "Length", unit = "m") = referenceSystem.pointMass6.cylinderDiameter "Width of visual object";
//   input Real referenceSystem.pointMass6.cylinder.height(quantity = "Length", unit = "m") = referenceSystem.pointMass6.cylinderDiameter "Height of visual object";
//   input Real referenceSystem.pointMass6.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass6.cylinder.color[1] = Real(referenceSystem.pointMass6.cylinderColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass6.cylinder.color[2] = Real(referenceSystem.pointMass6.cylinderColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass6.cylinder.color[3] = Real(referenceSystem.pointMass6.cylinderColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass6.cylinder.specularCoefficient = referenceSystem.pointMass6.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass6.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass6.cylinder.lengthDirection[1],referenceSystem.pointMass6.cylinder.lengthDirection[2],referenceSystem.pointMass6.cylinder.lengthDirection[3]});
//   protected Real referenceSystem.pointMass6.cylinder.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass6.cylinder.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass6.cylinder.lengthDirection[1] / referenceSystem.pointMass6.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass6.cylinder.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass6.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass6.cylinder.lengthDirection[2] / referenceSystem.pointMass6.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass6.cylinder.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass6.cylinder.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass6.cylinder.lengthDirection[3] / referenceSystem.pointMass6.cylinder.abs_n_x;
//   protected Real referenceSystem.pointMass6.cylinder.n_z_aux[1](unit = "1") = referenceSystem.pointMass6.cylinder.e_x[2] * referenceSystem.pointMass6.cylinder.widthDirection[3] - referenceSystem.pointMass6.cylinder.e_x[3] * referenceSystem.pointMass6.cylinder.widthDirection[2];
//   protected Real referenceSystem.pointMass6.cylinder.n_z_aux[2](unit = "1") = referenceSystem.pointMass6.cylinder.e_x[3] * referenceSystem.pointMass6.cylinder.widthDirection[1] - referenceSystem.pointMass6.cylinder.e_x[1] * referenceSystem.pointMass6.cylinder.widthDirection[3];
//   protected Real referenceSystem.pointMass6.cylinder.n_z_aux[3](unit = "1") = referenceSystem.pointMass6.cylinder.e_x[1] * referenceSystem.pointMass6.cylinder.widthDirection[2] - referenceSystem.pointMass6.cylinder.e_x[2] * referenceSystem.pointMass6.cylinder.widthDirection[1];
//   protected Real referenceSystem.pointMass6.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass6.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.cylinder.widthDirection[1],referenceSystem.pointMass6.cylinder.widthDirection[2],referenceSystem.pointMass6.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]})[1];
//   protected Real referenceSystem.pointMass6.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass6.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.cylinder.widthDirection[1],referenceSystem.pointMass6.cylinder.widthDirection[2],referenceSystem.pointMass6.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]})[2];
//   protected Real referenceSystem.pointMass6.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]},if noEvent(referenceSystem.pointMass6.cylinder.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.cylinder.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.cylinder.widthDirection[1],referenceSystem.pointMass6.cylinder.widthDirection[2],referenceSystem.pointMass6.cylinder.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.cylinder.e_x[1],referenceSystem.pointMass6.cylinder.e_x[2],referenceSystem.pointMass6.cylinder.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass6.cylinder.Form;
//   output Real referenceSystem.pointMass6.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass6.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass6.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.cylinder.Material;
//   protected output Real referenceSystem.pointMass6.cylinder.Extra;
//   parameter String referenceSystem.pointMass6.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.pointMass6.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.pointMass6.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.pointMass6.sphere.r[1](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.sphere.r[2](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.sphere.r[3](quantity = "Length", unit = "m") = referenceSystem.pointMass6.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.pointMass6.sphere.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.pointMass6.r_CM[1] - referenceSystem.pointMass6.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.pointMass6.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.pointMass6.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.pointMass6.sphere.length(quantity = "Length", unit = "m") = referenceSystem.pointMass6.sphereDiameter "Length of visual object";
//   input Real referenceSystem.pointMass6.sphere.width(quantity = "Length", unit = "m") = referenceSystem.pointMass6.sphereDiameter "Width of visual object";
//   input Real referenceSystem.pointMass6.sphere.height(quantity = "Length", unit = "m") = referenceSystem.pointMass6.sphereDiameter "Height of visual object";
//   input Real referenceSystem.pointMass6.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real referenceSystem.pointMass6.sphere.color[1] = Real(referenceSystem.pointMass6.sphereColor[1]) "Color of shape";
//   input Real referenceSystem.pointMass6.sphere.color[2] = Real(referenceSystem.pointMass6.sphereColor[2]) "Color of shape";
//   input Real referenceSystem.pointMass6.sphere.color[3] = Real(referenceSystem.pointMass6.sphereColor[3]) "Color of shape";
//   input Real referenceSystem.pointMass6.sphere.specularCoefficient = referenceSystem.pointMass6.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.pointMass6.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.pointMass6.sphere.lengthDirection[1],referenceSystem.pointMass6.sphere.lengthDirection[2],referenceSystem.pointMass6.sphere.lengthDirection[3]});
//   protected Real referenceSystem.pointMass6.sphere.e_x[1](unit = "1") = if noEvent(referenceSystem.pointMass6.sphere.abs_n_x < 1e-10) then 1.0 else referenceSystem.pointMass6.sphere.lengthDirection[1] / referenceSystem.pointMass6.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass6.sphere.e_x[2](unit = "1") = if noEvent(referenceSystem.pointMass6.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass6.sphere.lengthDirection[2] / referenceSystem.pointMass6.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass6.sphere.e_x[3](unit = "1") = if noEvent(referenceSystem.pointMass6.sphere.abs_n_x < 1e-10) then 0.0 else referenceSystem.pointMass6.sphere.lengthDirection[3] / referenceSystem.pointMass6.sphere.abs_n_x;
//   protected Real referenceSystem.pointMass6.sphere.n_z_aux[1](unit = "1") = referenceSystem.pointMass6.sphere.e_x[2] * referenceSystem.pointMass6.sphere.widthDirection[3] - referenceSystem.pointMass6.sphere.e_x[3] * referenceSystem.pointMass6.sphere.widthDirection[2];
//   protected Real referenceSystem.pointMass6.sphere.n_z_aux[2](unit = "1") = referenceSystem.pointMass6.sphere.e_x[3] * referenceSystem.pointMass6.sphere.widthDirection[1] - referenceSystem.pointMass6.sphere.e_x[1] * referenceSystem.pointMass6.sphere.widthDirection[3];
//   protected Real referenceSystem.pointMass6.sphere.n_z_aux[3](unit = "1") = referenceSystem.pointMass6.sphere.e_x[1] * referenceSystem.pointMass6.sphere.widthDirection[2] - referenceSystem.pointMass6.sphere.e_x[2] * referenceSystem.pointMass6.sphere.widthDirection[1];
//   protected Real referenceSystem.pointMass6.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]},if noEvent(referenceSystem.pointMass6.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.sphere.widthDirection[1],referenceSystem.pointMass6.sphere.widthDirection[2],referenceSystem.pointMass6.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]})[1];
//   protected Real referenceSystem.pointMass6.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]},if noEvent(referenceSystem.pointMass6.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.sphere.widthDirection[1],referenceSystem.pointMass6.sphere.widthDirection[2],referenceSystem.pointMass6.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]})[2];
//   protected Real referenceSystem.pointMass6.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]},if noEvent(referenceSystem.pointMass6.sphere.n_z_aux[1] ^ 2.0 + (referenceSystem.pointMass6.sphere.n_z_aux[2] ^ 2.0 + referenceSystem.pointMass6.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.pointMass6.sphere.widthDirection[1],referenceSystem.pointMass6.sphere.widthDirection[2],referenceSystem.pointMass6.sphere.widthDirection[3]} else if noEvent(abs(referenceSystem.pointMass6.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.pointMass6.sphere.e_x[1],referenceSystem.pointMass6.sphere.e_x[2],referenceSystem.pointMass6.sphere.e_x[3]})[3];
//   protected output Real referenceSystem.pointMass6.sphere.Form;
//   output Real referenceSystem.pointMass6.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.pointMass6.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.pointMass6.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.pointMass6.sphere.Material;
//   protected output Real referenceSystem.pointMass6.sphere.Extra;
//   Real referenceSystem.fixedTranslation.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation.r[1](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation.r[1] - referenceSystem.fixedTranslation.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation.r[2] - referenceSystem.fixedTranslation.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation.r[3] - referenceSystem.fixedTranslation.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation.r[1] - referenceSystem.fixedTranslation.r_shape[1],referenceSystem.fixedTranslation.r[2] - referenceSystem.fixedTranslation.r_shape[2],referenceSystem.fixedTranslation.r[3] - referenceSystem.fixedTranslation.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation.shape.shapeType = referenceSystem.fixedTranslation.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation.shape.extra = referenceSystem.fixedTranslation.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation.shape.color[1] = Real(referenceSystem.fixedTranslation.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation.shape.color[2] = Real(referenceSystem.fixedTranslation.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation.shape.color[3] = Real(referenceSystem.fixedTranslation.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation.shape.specularCoefficient = referenceSystem.fixedTranslation.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation.shape.lengthDirection[1],referenceSystem.fixedTranslation.shape.lengthDirection[2],referenceSystem.fixedTranslation.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation.shape.lengthDirection[1] / referenceSystem.fixedTranslation.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation.shape.lengthDirection[2] / referenceSystem.fixedTranslation.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation.shape.lengthDirection[3] / referenceSystem.fixedTranslation.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation.shape.e_x[2] * referenceSystem.fixedTranslation.shape.widthDirection[3] - referenceSystem.fixedTranslation.shape.e_x[3] * referenceSystem.fixedTranslation.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation.shape.e_x[3] * referenceSystem.fixedTranslation.shape.widthDirection[1] - referenceSystem.fixedTranslation.shape.e_x[1] * referenceSystem.fixedTranslation.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation.shape.e_x[1] * referenceSystem.fixedTranslation.shape.widthDirection[2] - referenceSystem.fixedTranslation.shape.e_x[2] * referenceSystem.fixedTranslation.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation.shape.widthDirection[1],referenceSystem.fixedTranslation.shape.widthDirection[2],referenceSystem.fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation.shape.widthDirection[1],referenceSystem.fixedTranslation.shape.widthDirection[2],referenceSystem.fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation.shape.widthDirection[1],referenceSystem.fixedTranslation.shape.widthDirection[2],referenceSystem.fixedTranslation.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation.shape.e_x[1],referenceSystem.fixedTranslation.shape.e_x[2],referenceSystem.fixedTranslation.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation.shape.Form;
//   output Real referenceSystem.fixedTranslation.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation.shape.Material;
//   protected output Real referenceSystem.fixedTranslation.shape.Extra;
//   Real referenceSystem.fixedTranslation1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation1.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation1.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation1.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation1.r[1](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation1.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation1.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation1.r[1] - referenceSystem.fixedTranslation1.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation1.r[2] - referenceSystem.fixedTranslation1.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation1.r[3] - referenceSystem.fixedTranslation1.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation1.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation1.r[1] - referenceSystem.fixedTranslation1.r_shape[1],referenceSystem.fixedTranslation1.r[2] - referenceSystem.fixedTranslation1.r_shape[2],referenceSystem.fixedTranslation1.r[3] - referenceSystem.fixedTranslation1.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation1.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation1.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation1.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation1.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation1.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation1.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation1.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation1.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation1.shape.shapeType = referenceSystem.fixedTranslation1.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation1.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation1.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation1.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation1.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation1.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation1.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation1.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation1.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation1.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation1.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation1.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation1.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation1.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation1.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation1.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation1.shape.extra = referenceSystem.fixedTranslation1.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation1.shape.color[1] = Real(referenceSystem.fixedTranslation1.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation1.shape.color[2] = Real(referenceSystem.fixedTranslation1.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation1.shape.color[3] = Real(referenceSystem.fixedTranslation1.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation1.shape.specularCoefficient = referenceSystem.fixedTranslation1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation1.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation1.shape.lengthDirection[1],referenceSystem.fixedTranslation1.shape.lengthDirection[2],referenceSystem.fixedTranslation1.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation1.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation1.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation1.shape.lengthDirection[1] / referenceSystem.fixedTranslation1.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation1.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation1.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation1.shape.lengthDirection[2] / referenceSystem.fixedTranslation1.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation1.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation1.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation1.shape.lengthDirection[3] / referenceSystem.fixedTranslation1.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation1.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation1.shape.e_x[2] * referenceSystem.fixedTranslation1.shape.widthDirection[3] - referenceSystem.fixedTranslation1.shape.e_x[3] * referenceSystem.fixedTranslation1.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation1.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation1.shape.e_x[3] * referenceSystem.fixedTranslation1.shape.widthDirection[1] - referenceSystem.fixedTranslation1.shape.e_x[1] * referenceSystem.fixedTranslation1.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation1.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation1.shape.e_x[1] * referenceSystem.fixedTranslation1.shape.widthDirection[2] - referenceSystem.fixedTranslation1.shape.e_x[2] * referenceSystem.fixedTranslation1.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation1.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation1.shape.widthDirection[1],referenceSystem.fixedTranslation1.shape.widthDirection[2],referenceSystem.fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation1.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation1.shape.widthDirection[1],referenceSystem.fixedTranslation1.shape.widthDirection[2],referenceSystem.fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation1.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation1.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation1.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation1.shape.widthDirection[1],referenceSystem.fixedTranslation1.shape.widthDirection[2],referenceSystem.fixedTranslation1.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation1.shape.e_x[1],referenceSystem.fixedTranslation1.shape.e_x[2],referenceSystem.fixedTranslation1.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation1.shape.Form;
//   output Real referenceSystem.fixedTranslation1.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation1.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation1.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation1.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation1.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation1.shape.Material;
//   protected output Real referenceSystem.fixedTranslation1.shape.Extra;
//   Real referenceSystem.fixedTranslation2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation2.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation2.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation2.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation2.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.r[2](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation2.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation2.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation2.r[1] - referenceSystem.fixedTranslation2.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation2.r[2] - referenceSystem.fixedTranslation2.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation2.r[3] - referenceSystem.fixedTranslation2.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation2.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation2.r[1] - referenceSystem.fixedTranslation2.r_shape[1],referenceSystem.fixedTranslation2.r[2] - referenceSystem.fixedTranslation2.r_shape[2],referenceSystem.fixedTranslation2.r[3] - referenceSystem.fixedTranslation2.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation2.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation2.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation2.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation2.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation2.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation2.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation2.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation2.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation2.shape.shapeType = referenceSystem.fixedTranslation2.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation2.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation2.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation2.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation2.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation2.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation2.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation2.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation2.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation2.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation2.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation2.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation2.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation2.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation2.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation2.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation2.shape.extra = referenceSystem.fixedTranslation2.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation2.shape.color[1] = Real(referenceSystem.fixedTranslation2.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation2.shape.color[2] = Real(referenceSystem.fixedTranslation2.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation2.shape.color[3] = Real(referenceSystem.fixedTranslation2.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation2.shape.specularCoefficient = referenceSystem.fixedTranslation2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation2.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation2.shape.lengthDirection[1],referenceSystem.fixedTranslation2.shape.lengthDirection[2],referenceSystem.fixedTranslation2.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation2.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation2.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation2.shape.lengthDirection[1] / referenceSystem.fixedTranslation2.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation2.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation2.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation2.shape.lengthDirection[2] / referenceSystem.fixedTranslation2.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation2.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation2.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation2.shape.lengthDirection[3] / referenceSystem.fixedTranslation2.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation2.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation2.shape.e_x[2] * referenceSystem.fixedTranslation2.shape.widthDirection[3] - referenceSystem.fixedTranslation2.shape.e_x[3] * referenceSystem.fixedTranslation2.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation2.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation2.shape.e_x[3] * referenceSystem.fixedTranslation2.shape.widthDirection[1] - referenceSystem.fixedTranslation2.shape.e_x[1] * referenceSystem.fixedTranslation2.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation2.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation2.shape.e_x[1] * referenceSystem.fixedTranslation2.shape.widthDirection[2] - referenceSystem.fixedTranslation2.shape.e_x[2] * referenceSystem.fixedTranslation2.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation2.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation2.shape.widthDirection[1],referenceSystem.fixedTranslation2.shape.widthDirection[2],referenceSystem.fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation2.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation2.shape.widthDirection[1],referenceSystem.fixedTranslation2.shape.widthDirection[2],referenceSystem.fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation2.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation2.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation2.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation2.shape.widthDirection[1],referenceSystem.fixedTranslation2.shape.widthDirection[2],referenceSystem.fixedTranslation2.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation2.shape.e_x[1],referenceSystem.fixedTranslation2.shape.e_x[2],referenceSystem.fixedTranslation2.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation2.shape.Form;
//   output Real referenceSystem.fixedTranslation2.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation2.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation2.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation2.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation2.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation2.shape.Material;
//   protected output Real referenceSystem.fixedTranslation2.shape.Extra;
//   Real referenceSystem.fixedTranslation3.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation3.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation3.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation3.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation3.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.r[2](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation3.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation3.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation3.r[1] - referenceSystem.fixedTranslation3.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation3.r[2] - referenceSystem.fixedTranslation3.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation3.r[3] - referenceSystem.fixedTranslation3.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation3.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation3.r[1] - referenceSystem.fixedTranslation3.r_shape[1],referenceSystem.fixedTranslation3.r[2] - referenceSystem.fixedTranslation3.r_shape[2],referenceSystem.fixedTranslation3.r[3] - referenceSystem.fixedTranslation3.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation3.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation3.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation3.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation3.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation3.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation3.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation3.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation3.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation3.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation3.shape.shapeType = referenceSystem.fixedTranslation3.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation3.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation3.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation3.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation3.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation3.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation3.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation3.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation3.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation3.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation3.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation3.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation3.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation3.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation3.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation3.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation3.shape.extra = referenceSystem.fixedTranslation3.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation3.shape.color[1] = Real(referenceSystem.fixedTranslation3.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation3.shape.color[2] = Real(referenceSystem.fixedTranslation3.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation3.shape.color[3] = Real(referenceSystem.fixedTranslation3.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation3.shape.specularCoefficient = referenceSystem.fixedTranslation3.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation3.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation3.shape.lengthDirection[1],referenceSystem.fixedTranslation3.shape.lengthDirection[2],referenceSystem.fixedTranslation3.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation3.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation3.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation3.shape.lengthDirection[1] / referenceSystem.fixedTranslation3.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation3.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation3.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation3.shape.lengthDirection[2] / referenceSystem.fixedTranslation3.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation3.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation3.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation3.shape.lengthDirection[3] / referenceSystem.fixedTranslation3.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation3.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation3.shape.e_x[2] * referenceSystem.fixedTranslation3.shape.widthDirection[3] - referenceSystem.fixedTranslation3.shape.e_x[3] * referenceSystem.fixedTranslation3.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation3.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation3.shape.e_x[3] * referenceSystem.fixedTranslation3.shape.widthDirection[1] - referenceSystem.fixedTranslation3.shape.e_x[1] * referenceSystem.fixedTranslation3.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation3.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation3.shape.e_x[1] * referenceSystem.fixedTranslation3.shape.widthDirection[2] - referenceSystem.fixedTranslation3.shape.e_x[2] * referenceSystem.fixedTranslation3.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation3.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation3.shape.widthDirection[1],referenceSystem.fixedTranslation3.shape.widthDirection[2],referenceSystem.fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation3.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation3.shape.widthDirection[1],referenceSystem.fixedTranslation3.shape.widthDirection[2],referenceSystem.fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation3.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation3.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation3.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation3.shape.widthDirection[1],referenceSystem.fixedTranslation3.shape.widthDirection[2],referenceSystem.fixedTranslation3.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation3.shape.e_x[1],referenceSystem.fixedTranslation3.shape.e_x[2],referenceSystem.fixedTranslation3.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation3.shape.Form;
//   output Real referenceSystem.fixedTranslation3.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation3.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation3.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation3.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation3.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation3.shape.Material;
//   protected output Real referenceSystem.fixedTranslation3.shape.Extra;
//   Real referenceSystem.fixedTranslation4.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation4.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation4.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation4.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation4.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.r[3](quantity = "Length", unit = "m", start = 0.0) = 1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation4.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation4.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation4.r[1] - referenceSystem.fixedTranslation4.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation4.r[2] - referenceSystem.fixedTranslation4.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation4.r[3] - referenceSystem.fixedTranslation4.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation4.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation4.r[1] - referenceSystem.fixedTranslation4.r_shape[1],referenceSystem.fixedTranslation4.r[2] - referenceSystem.fixedTranslation4.r_shape[2],referenceSystem.fixedTranslation4.r[3] - referenceSystem.fixedTranslation4.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation4.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation4.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation4.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation4.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation4.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation4.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation4.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation4.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation4.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation4.shape.shapeType = referenceSystem.fixedTranslation4.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation4.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation4.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation4.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation4.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation4.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation4.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation4.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation4.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation4.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation4.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation4.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation4.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation4.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation4.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation4.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation4.shape.extra = referenceSystem.fixedTranslation4.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation4.shape.color[1] = Real(referenceSystem.fixedTranslation4.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation4.shape.color[2] = Real(referenceSystem.fixedTranslation4.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation4.shape.color[3] = Real(referenceSystem.fixedTranslation4.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation4.shape.specularCoefficient = referenceSystem.fixedTranslation4.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation4.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation4.shape.lengthDirection[1],referenceSystem.fixedTranslation4.shape.lengthDirection[2],referenceSystem.fixedTranslation4.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation4.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation4.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation4.shape.lengthDirection[1] / referenceSystem.fixedTranslation4.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation4.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation4.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation4.shape.lengthDirection[2] / referenceSystem.fixedTranslation4.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation4.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation4.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation4.shape.lengthDirection[3] / referenceSystem.fixedTranslation4.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation4.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation4.shape.e_x[2] * referenceSystem.fixedTranslation4.shape.widthDirection[3] - referenceSystem.fixedTranslation4.shape.e_x[3] * referenceSystem.fixedTranslation4.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation4.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation4.shape.e_x[3] * referenceSystem.fixedTranslation4.shape.widthDirection[1] - referenceSystem.fixedTranslation4.shape.e_x[1] * referenceSystem.fixedTranslation4.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation4.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation4.shape.e_x[1] * referenceSystem.fixedTranslation4.shape.widthDirection[2] - referenceSystem.fixedTranslation4.shape.e_x[2] * referenceSystem.fixedTranslation4.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation4.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation4.shape.widthDirection[1],referenceSystem.fixedTranslation4.shape.widthDirection[2],referenceSystem.fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation4.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation4.shape.widthDirection[1],referenceSystem.fixedTranslation4.shape.widthDirection[2],referenceSystem.fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation4.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation4.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation4.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation4.shape.widthDirection[1],referenceSystem.fixedTranslation4.shape.widthDirection[2],referenceSystem.fixedTranslation4.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation4.shape.e_x[1],referenceSystem.fixedTranslation4.shape.e_x[2],referenceSystem.fixedTranslation4.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation4.shape.Form;
//   output Real referenceSystem.fixedTranslation4.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation4.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation4.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation4.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation4.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation4.shape.Material;
//   protected output Real referenceSystem.fixedTranslation4.shape.Extra;
//   Real referenceSystem.fixedTranslation5.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real referenceSystem.fixedTranslation5.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real referenceSystem.fixedTranslation5.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean referenceSystem.fixedTranslation5.animation = true "= true, if animation shall be enabled";
//   parameter Real referenceSystem.fixedTranslation5.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.r[3](quantity = "Length", unit = "m", start = 0.0) = -1.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String referenceSystem.fixedTranslation5.shapeType = "cylinder" " Type of shape";
//   parameter Real referenceSystem.fixedTranslation5.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation5.r[1] - referenceSystem.fixedTranslation5.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation5.r[2] - referenceSystem.fixedTranslation5.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation5.r[3] - referenceSystem.fixedTranslation5.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real referenceSystem.fixedTranslation5.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation5.r[1] - referenceSystem.fixedTranslation5.r_shape[1],referenceSystem.fixedTranslation5.r[2] - referenceSystem.fixedTranslation5.r_shape[2],referenceSystem.fixedTranslation5.r[3] - referenceSystem.fixedTranslation5.r_shape[3]}) " Length of shape";
//   parameter Real referenceSystem.fixedTranslation5.width(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation5.length / world.defaultWidthFraction " Width of shape";
//   parameter Real referenceSystem.fixedTranslation5.height(quantity = "Length", unit = "m", min = 0.0) = referenceSystem.fixedTranslation5.width " Height of shape.";
//   parameter Real referenceSystem.fixedTranslation5.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer referenceSystem.fixedTranslation5.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation5.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer referenceSystem.fixedTranslation5.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real referenceSystem.fixedTranslation5.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String referenceSystem.fixedTranslation5.shape.shapeType = referenceSystem.fixedTranslation5.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation5.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real referenceSystem.fixedTranslation5.shape.r[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation5.shape.r[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation5.shape.r[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real referenceSystem.fixedTranslation5.shape.r_shape[1](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.r_shape[2](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.r_shape[3](quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.lengthDirection[1](unit = "1") = referenceSystem.fixedTranslation5.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.lengthDirection[2](unit = "1") = referenceSystem.fixedTranslation5.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.lengthDirection[3](unit = "1") = referenceSystem.fixedTranslation5.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.widthDirection[1](unit = "1") = referenceSystem.fixedTranslation5.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.widthDirection[2](unit = "1") = referenceSystem.fixedTranslation5.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.widthDirection[3](unit = "1") = referenceSystem.fixedTranslation5.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real referenceSystem.fixedTranslation5.shape.length(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.length "Length of visual object";
//   input Real referenceSystem.fixedTranslation5.shape.width(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.width "Width of visual object";
//   input Real referenceSystem.fixedTranslation5.shape.height(quantity = "Length", unit = "m") = referenceSystem.fixedTranslation5.height "Height of visual object";
//   input Real referenceSystem.fixedTranslation5.shape.extra = referenceSystem.fixedTranslation5.extra "Additional size data for some of the shape types";
//   input Real referenceSystem.fixedTranslation5.shape.color[1] = Real(referenceSystem.fixedTranslation5.color[1]) "Color of shape";
//   input Real referenceSystem.fixedTranslation5.shape.color[2] = Real(referenceSystem.fixedTranslation5.color[2]) "Color of shape";
//   input Real referenceSystem.fixedTranslation5.shape.color[3] = Real(referenceSystem.fixedTranslation5.color[3]) "Color of shape";
//   input Real referenceSystem.fixedTranslation5.shape.specularCoefficient = referenceSystem.fixedTranslation5.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real referenceSystem.fixedTranslation5.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({referenceSystem.fixedTranslation5.shape.lengthDirection[1],referenceSystem.fixedTranslation5.shape.lengthDirection[2],referenceSystem.fixedTranslation5.shape.lengthDirection[3]});
//   protected Real referenceSystem.fixedTranslation5.shape.e_x[1](unit = "1") = if noEvent(referenceSystem.fixedTranslation5.shape.abs_n_x < 1e-10) then 1.0 else referenceSystem.fixedTranslation5.shape.lengthDirection[1] / referenceSystem.fixedTranslation5.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation5.shape.e_x[2](unit = "1") = if noEvent(referenceSystem.fixedTranslation5.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation5.shape.lengthDirection[2] / referenceSystem.fixedTranslation5.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation5.shape.e_x[3](unit = "1") = if noEvent(referenceSystem.fixedTranslation5.shape.abs_n_x < 1e-10) then 0.0 else referenceSystem.fixedTranslation5.shape.lengthDirection[3] / referenceSystem.fixedTranslation5.shape.abs_n_x;
//   protected Real referenceSystem.fixedTranslation5.shape.n_z_aux[1](unit = "1") = referenceSystem.fixedTranslation5.shape.e_x[2] * referenceSystem.fixedTranslation5.shape.widthDirection[3] - referenceSystem.fixedTranslation5.shape.e_x[3] * referenceSystem.fixedTranslation5.shape.widthDirection[2];
//   protected Real referenceSystem.fixedTranslation5.shape.n_z_aux[2](unit = "1") = referenceSystem.fixedTranslation5.shape.e_x[3] * referenceSystem.fixedTranslation5.shape.widthDirection[1] - referenceSystem.fixedTranslation5.shape.e_x[1] * referenceSystem.fixedTranslation5.shape.widthDirection[3];
//   protected Real referenceSystem.fixedTranslation5.shape.n_z_aux[3](unit = "1") = referenceSystem.fixedTranslation5.shape.e_x[1] * referenceSystem.fixedTranslation5.shape.widthDirection[2] - referenceSystem.fixedTranslation5.shape.e_x[2] * referenceSystem.fixedTranslation5.shape.widthDirection[1];
//   protected Real referenceSystem.fixedTranslation5.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation5.shape.widthDirection[1],referenceSystem.fixedTranslation5.shape.widthDirection[2],referenceSystem.fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]})[1];
//   protected Real referenceSystem.fixedTranslation5.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation5.shape.widthDirection[1],referenceSystem.fixedTranslation5.shape.widthDirection[2],referenceSystem.fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]})[2];
//   protected Real referenceSystem.fixedTranslation5.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]},if noEvent(referenceSystem.fixedTranslation5.shape.n_z_aux[1] ^ 2.0 + (referenceSystem.fixedTranslation5.shape.n_z_aux[2] ^ 2.0 + referenceSystem.fixedTranslation5.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {referenceSystem.fixedTranslation5.shape.widthDirection[1],referenceSystem.fixedTranslation5.shape.widthDirection[2],referenceSystem.fixedTranslation5.shape.widthDirection[3]} else if noEvent(abs(referenceSystem.fixedTranslation5.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{referenceSystem.fixedTranslation5.shape.e_x[1],referenceSystem.fixedTranslation5.shape.e_x[2],referenceSystem.fixedTranslation5.shape.e_x[3]})[3];
//   protected output Real referenceSystem.fixedTranslation5.shape.Form;
//   output Real referenceSystem.fixedTranslation5.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real referenceSystem.fixedTranslation5.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real referenceSystem.fixedTranslation5.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation5.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation5.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real referenceSystem.fixedTranslation5.shape.Material;
//   protected output Real referenceSystem.fixedTranslation5.shape.Extra;
// initial equation
//   {0.0,0.0,0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation.equalityConstraint({referenceSystem.pointMass1.Q[1],referenceSystem.pointMass1.Q[2],referenceSystem.pointMass1.Q[3],referenceSystem.pointMass1.Q[4]},{referenceSystem.pointMass1.Q_start[1],referenceSystem.pointMass1.Q_start[2],referenceSystem.pointMass1.Q_start[3],referenceSystem.pointMass1.Q_start[4]});
// equation
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[1].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[1].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[1].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[2].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[2].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[2].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[1].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[1].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[1].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[2].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[2].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[2].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[1].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[1].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[1].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[2].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[2].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[2].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[3].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[3].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[3].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.gravitySphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravitySphere.shapeType);
//   world.gravitySphere.rxvisobj[1] = world.gravitySphere.R.T[1,1] * world.gravitySphere.e_x[1] + (world.gravitySphere.R.T[2,1] * world.gravitySphere.e_x[2] + world.gravitySphere.R.T[3,1] * world.gravitySphere.e_x[3]);
//   world.gravitySphere.rxvisobj[2] = world.gravitySphere.R.T[1,2] * world.gravitySphere.e_x[1] + (world.gravitySphere.R.T[2,2] * world.gravitySphere.e_x[2] + world.gravitySphere.R.T[3,2] * world.gravitySphere.e_x[3]);
//   world.gravitySphere.rxvisobj[3] = world.gravitySphere.R.T[1,3] * world.gravitySphere.e_x[1] + (world.gravitySphere.R.T[2,3] * world.gravitySphere.e_x[2] + world.gravitySphere.R.T[3,3] * world.gravitySphere.e_x[3]);
//   world.gravitySphere.ryvisobj[1] = world.gravitySphere.R.T[1,1] * world.gravitySphere.e_y[1] + (world.gravitySphere.R.T[2,1] * world.gravitySphere.e_y[2] + world.gravitySphere.R.T[3,1] * world.gravitySphere.e_y[3]);
//   world.gravitySphere.ryvisobj[2] = world.gravitySphere.R.T[1,2] * world.gravitySphere.e_y[1] + (world.gravitySphere.R.T[2,2] * world.gravitySphere.e_y[2] + world.gravitySphere.R.T[3,2] * world.gravitySphere.e_y[3]);
//   world.gravitySphere.ryvisobj[3] = world.gravitySphere.R.T[1,3] * world.gravitySphere.e_y[1] + (world.gravitySphere.R.T[2,3] * world.gravitySphere.e_y[2] + world.gravitySphere.R.T[3,3] * world.gravitySphere.e_y[3]);
//   world.gravitySphere.rvisobj = world.gravitySphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravitySphere.R.T[1,1],world.gravitySphere.R.T[1,2],world.gravitySphere.R.T[1,3]},{world.gravitySphere.R.T[2,1],world.gravitySphere.R.T[2,2],world.gravitySphere.R.T[2,3]},{world.gravitySphere.R.T[3,1],world.gravitySphere.R.T[3,2],world.gravitySphere.R.T[3,3]}},{world.gravitySphere.r_shape[1],world.gravitySphere.r_shape[2],world.gravitySphere.r_shape[3]});
//   world.gravitySphere.size[1] = world.gravitySphere.length;
//   world.gravitySphere.size[2] = world.gravitySphere.width;
//   world.gravitySphere.size[3] = world.gravitySphere.height;
//   world.gravitySphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravitySphere.color[1] / 255.0,world.gravitySphere.color[2] / 255.0,world.gravitySphere.color[3] / 255.0,world.gravitySphere.specularCoefficient);
//   world.gravitySphere.Extra = world.gravitySphere.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,"Parameter n of World object is wrong (lenght(n) > 0 required)");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   pointMass1.sphere.R.T[1,1] = pointMass1.frame_a.R.T[1,1];
//   pointMass1.sphere.R.T[1,2] = pointMass1.frame_a.R.T[1,2];
//   pointMass1.sphere.R.T[1,3] = pointMass1.frame_a.R.T[1,3];
//   pointMass1.sphere.R.T[2,1] = pointMass1.frame_a.R.T[2,1];
//   pointMass1.sphere.R.T[2,2] = pointMass1.frame_a.R.T[2,2];
//   pointMass1.sphere.R.T[2,3] = pointMass1.frame_a.R.T[2,3];
//   pointMass1.sphere.R.T[3,1] = pointMass1.frame_a.R.T[3,1];
//   pointMass1.sphere.R.T[3,2] = pointMass1.frame_a.R.T[3,2];
//   pointMass1.sphere.R.T[3,3] = pointMass1.frame_a.R.T[3,3];
//   pointMass1.sphere.R.w[1] = pointMass1.frame_a.R.w[1];
//   pointMass1.sphere.R.w[2] = pointMass1.frame_a.R.w[2];
//   pointMass1.sphere.R.w[3] = pointMass1.frame_a.R.w[3];
//   pointMass1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass1.sphere.shapeType);
//   pointMass1.sphere.rxvisobj[1] = pointMass1.sphere.R.T[1,1] * pointMass1.sphere.e_x[1] + (pointMass1.sphere.R.T[2,1] * pointMass1.sphere.e_x[2] + pointMass1.sphere.R.T[3,1] * pointMass1.sphere.e_x[3]);
//   pointMass1.sphere.rxvisobj[2] = pointMass1.sphere.R.T[1,2] * pointMass1.sphere.e_x[1] + (pointMass1.sphere.R.T[2,2] * pointMass1.sphere.e_x[2] + pointMass1.sphere.R.T[3,2] * pointMass1.sphere.e_x[3]);
//   pointMass1.sphere.rxvisobj[3] = pointMass1.sphere.R.T[1,3] * pointMass1.sphere.e_x[1] + (pointMass1.sphere.R.T[2,3] * pointMass1.sphere.e_x[2] + pointMass1.sphere.R.T[3,3] * pointMass1.sphere.e_x[3]);
//   pointMass1.sphere.ryvisobj[1] = pointMass1.sphere.R.T[1,1] * pointMass1.sphere.e_y[1] + (pointMass1.sphere.R.T[2,1] * pointMass1.sphere.e_y[2] + pointMass1.sphere.R.T[3,1] * pointMass1.sphere.e_y[3]);
//   pointMass1.sphere.ryvisobj[2] = pointMass1.sphere.R.T[1,2] * pointMass1.sphere.e_y[1] + (pointMass1.sphere.R.T[2,2] * pointMass1.sphere.e_y[2] + pointMass1.sphere.R.T[3,2] * pointMass1.sphere.e_y[3]);
//   pointMass1.sphere.ryvisobj[3] = pointMass1.sphere.R.T[1,3] * pointMass1.sphere.e_y[1] + (pointMass1.sphere.R.T[2,3] * pointMass1.sphere.e_y[2] + pointMass1.sphere.R.T[3,3] * pointMass1.sphere.e_y[3]);
//   pointMass1.sphere.rvisobj = pointMass1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass1.sphere.R.T[1,1],pointMass1.sphere.R.T[1,2],pointMass1.sphere.R.T[1,3]},{pointMass1.sphere.R.T[2,1],pointMass1.sphere.R.T[2,2],pointMass1.sphere.R.T[2,3]},{pointMass1.sphere.R.T[3,1],pointMass1.sphere.R.T[3,2],pointMass1.sphere.R.T[3,3]}},{pointMass1.sphere.r_shape[1],pointMass1.sphere.r_shape[2],pointMass1.sphere.r_shape[3]});
//   pointMass1.sphere.size[1] = pointMass1.sphere.length;
//   pointMass1.sphere.size[2] = pointMass1.sphere.width;
//   pointMass1.sphere.size[3] = pointMass1.sphere.height;
//   pointMass1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass1.sphere.color[1] / 255.0,pointMass1.sphere.color[2] / 255.0,pointMass1.sphere.color[3] / 255.0,pointMass1.sphere.specularCoefficient);
//   pointMass1.sphere.Extra = pointMass1.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass1.frame_a.R.w[3] = 0.0;
//   pointMass1.frame_a.R.w[2] = 0.0;
//   pointMass1.frame_a.R.w[1] = 0.0;
//   pointMass1.frame_a.R.T[3,3] = 1.0;
//   pointMass1.frame_a.R.T[3,2] = 0.0;
//   pointMass1.frame_a.R.T[3,1] = 0.0;
//   pointMass1.frame_a.R.T[2,3] = 0.0;
//   pointMass1.frame_a.R.T[2,2] = 1.0;
//   pointMass1.frame_a.R.T[2,1] = 0.0;
//   pointMass1.frame_a.R.T[1,3] = 0.0;
//   pointMass1.frame_a.R.T[1,2] = 0.0;
//   pointMass1.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass1.frame_a.t[1] = 0.0;
//   pointMass1.frame_a.t[2] = 0.0;
//   pointMass1.frame_a.t[3] = 0.0;
//   end if;
//   pointMass1.r_0[1] = pointMass1.frame_a.r_0[1];
//   pointMass1.r_0[2] = pointMass1.frame_a.r_0[2];
//   pointMass1.r_0[3] = pointMass1.frame_a.r_0[3];
//   pointMass1.v_0[1] = der(pointMass1.r_0[1]);
//   pointMass1.v_0[2] = der(pointMass1.r_0[2]);
//   pointMass1.v_0[3] = der(pointMass1.r_0[3]);
//   pointMass1.a_0[1] = der(pointMass1.v_0[1]);
//   pointMass1.a_0[2] = der(pointMass1.v_0[2]);
//   pointMass1.a_0[3] = der(pointMass1.v_0[3]);
//   pointMass1.frame_a.f = pointMass1.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass1.frame_a.R,{pointMass1.a_0[1],pointMass1.a_0[2],pointMass1.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass1.r_0[1],pointMass1.r_0[2],pointMass1.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   pointMass2.sphere.R.T[1,1] = pointMass2.frame_a.R.T[1,1];
//   pointMass2.sphere.R.T[1,2] = pointMass2.frame_a.R.T[1,2];
//   pointMass2.sphere.R.T[1,3] = pointMass2.frame_a.R.T[1,3];
//   pointMass2.sphere.R.T[2,1] = pointMass2.frame_a.R.T[2,1];
//   pointMass2.sphere.R.T[2,2] = pointMass2.frame_a.R.T[2,2];
//   pointMass2.sphere.R.T[2,3] = pointMass2.frame_a.R.T[2,3];
//   pointMass2.sphere.R.T[3,1] = pointMass2.frame_a.R.T[3,1];
//   pointMass2.sphere.R.T[3,2] = pointMass2.frame_a.R.T[3,2];
//   pointMass2.sphere.R.T[3,3] = pointMass2.frame_a.R.T[3,3];
//   pointMass2.sphere.R.w[1] = pointMass2.frame_a.R.w[1];
//   pointMass2.sphere.R.w[2] = pointMass2.frame_a.R.w[2];
//   pointMass2.sphere.R.w[3] = pointMass2.frame_a.R.w[3];
//   pointMass2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass2.sphere.shapeType);
//   pointMass2.sphere.rxvisobj[1] = pointMass2.sphere.R.T[1,1] * pointMass2.sphere.e_x[1] + (pointMass2.sphere.R.T[2,1] * pointMass2.sphere.e_x[2] + pointMass2.sphere.R.T[3,1] * pointMass2.sphere.e_x[3]);
//   pointMass2.sphere.rxvisobj[2] = pointMass2.sphere.R.T[1,2] * pointMass2.sphere.e_x[1] + (pointMass2.sphere.R.T[2,2] * pointMass2.sphere.e_x[2] + pointMass2.sphere.R.T[3,2] * pointMass2.sphere.e_x[3]);
//   pointMass2.sphere.rxvisobj[3] = pointMass2.sphere.R.T[1,3] * pointMass2.sphere.e_x[1] + (pointMass2.sphere.R.T[2,3] * pointMass2.sphere.e_x[2] + pointMass2.sphere.R.T[3,3] * pointMass2.sphere.e_x[3]);
//   pointMass2.sphere.ryvisobj[1] = pointMass2.sphere.R.T[1,1] * pointMass2.sphere.e_y[1] + (pointMass2.sphere.R.T[2,1] * pointMass2.sphere.e_y[2] + pointMass2.sphere.R.T[3,1] * pointMass2.sphere.e_y[3]);
//   pointMass2.sphere.ryvisobj[2] = pointMass2.sphere.R.T[1,2] * pointMass2.sphere.e_y[1] + (pointMass2.sphere.R.T[2,2] * pointMass2.sphere.e_y[2] + pointMass2.sphere.R.T[3,2] * pointMass2.sphere.e_y[3]);
//   pointMass2.sphere.ryvisobj[3] = pointMass2.sphere.R.T[1,3] * pointMass2.sphere.e_y[1] + (pointMass2.sphere.R.T[2,3] * pointMass2.sphere.e_y[2] + pointMass2.sphere.R.T[3,3] * pointMass2.sphere.e_y[3]);
//   pointMass2.sphere.rvisobj = pointMass2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass2.sphere.R.T[1,1],pointMass2.sphere.R.T[1,2],pointMass2.sphere.R.T[1,3]},{pointMass2.sphere.R.T[2,1],pointMass2.sphere.R.T[2,2],pointMass2.sphere.R.T[2,3]},{pointMass2.sphere.R.T[3,1],pointMass2.sphere.R.T[3,2],pointMass2.sphere.R.T[3,3]}},{pointMass2.sphere.r_shape[1],pointMass2.sphere.r_shape[2],pointMass2.sphere.r_shape[3]});
//   pointMass2.sphere.size[1] = pointMass2.sphere.length;
//   pointMass2.sphere.size[2] = pointMass2.sphere.width;
//   pointMass2.sphere.size[3] = pointMass2.sphere.height;
//   pointMass2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass2.sphere.color[1] / 255.0,pointMass2.sphere.color[2] / 255.0,pointMass2.sphere.color[3] / 255.0,pointMass2.sphere.specularCoefficient);
//   pointMass2.sphere.Extra = pointMass2.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass2.frame_a.R.w[3] = 0.0;
//   pointMass2.frame_a.R.w[2] = 0.0;
//   pointMass2.frame_a.R.w[1] = 0.0;
//   pointMass2.frame_a.R.T[3,3] = 1.0;
//   pointMass2.frame_a.R.T[3,2] = 0.0;
//   pointMass2.frame_a.R.T[3,1] = 0.0;
//   pointMass2.frame_a.R.T[2,3] = 0.0;
//   pointMass2.frame_a.R.T[2,2] = 1.0;
//   pointMass2.frame_a.R.T[2,1] = 0.0;
//   pointMass2.frame_a.R.T[1,3] = 0.0;
//   pointMass2.frame_a.R.T[1,2] = 0.0;
//   pointMass2.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass2.frame_a.t[1] = 0.0;
//   pointMass2.frame_a.t[2] = 0.0;
//   pointMass2.frame_a.t[3] = 0.0;
//   end if;
//   pointMass2.r_0[1] = pointMass2.frame_a.r_0[1];
//   pointMass2.r_0[2] = pointMass2.frame_a.r_0[2];
//   pointMass2.r_0[3] = pointMass2.frame_a.r_0[3];
//   pointMass2.v_0[1] = der(pointMass2.r_0[1]);
//   pointMass2.v_0[2] = der(pointMass2.r_0[2]);
//   pointMass2.v_0[3] = der(pointMass2.r_0[3]);
//   pointMass2.a_0[1] = der(pointMass2.v_0[1]);
//   pointMass2.a_0[2] = der(pointMass2.v_0[2]);
//   pointMass2.a_0[3] = der(pointMass2.v_0[3]);
//   pointMass2.frame_a.f = pointMass2.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass2.frame_a.R,{pointMass2.a_0[1],pointMass2.a_0[2],pointMass2.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass2.r_0[1],pointMass2.r_0[2],pointMass2.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   pointMass3.sphere.R.T[1,1] = pointMass3.frame_a.R.T[1,1];
//   pointMass3.sphere.R.T[1,2] = pointMass3.frame_a.R.T[1,2];
//   pointMass3.sphere.R.T[1,3] = pointMass3.frame_a.R.T[1,3];
//   pointMass3.sphere.R.T[2,1] = pointMass3.frame_a.R.T[2,1];
//   pointMass3.sphere.R.T[2,2] = pointMass3.frame_a.R.T[2,2];
//   pointMass3.sphere.R.T[2,3] = pointMass3.frame_a.R.T[2,3];
//   pointMass3.sphere.R.T[3,1] = pointMass3.frame_a.R.T[3,1];
//   pointMass3.sphere.R.T[3,2] = pointMass3.frame_a.R.T[3,2];
//   pointMass3.sphere.R.T[3,3] = pointMass3.frame_a.R.T[3,3];
//   pointMass3.sphere.R.w[1] = pointMass3.frame_a.R.w[1];
//   pointMass3.sphere.R.w[2] = pointMass3.frame_a.R.w[2];
//   pointMass3.sphere.R.w[3] = pointMass3.frame_a.R.w[3];
//   pointMass3.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass3.sphere.shapeType);
//   pointMass3.sphere.rxvisobj[1] = pointMass3.sphere.R.T[1,1] * pointMass3.sphere.e_x[1] + (pointMass3.sphere.R.T[2,1] * pointMass3.sphere.e_x[2] + pointMass3.sphere.R.T[3,1] * pointMass3.sphere.e_x[3]);
//   pointMass3.sphere.rxvisobj[2] = pointMass3.sphere.R.T[1,2] * pointMass3.sphere.e_x[1] + (pointMass3.sphere.R.T[2,2] * pointMass3.sphere.e_x[2] + pointMass3.sphere.R.T[3,2] * pointMass3.sphere.e_x[3]);
//   pointMass3.sphere.rxvisobj[3] = pointMass3.sphere.R.T[1,3] * pointMass3.sphere.e_x[1] + (pointMass3.sphere.R.T[2,3] * pointMass3.sphere.e_x[2] + pointMass3.sphere.R.T[3,3] * pointMass3.sphere.e_x[3]);
//   pointMass3.sphere.ryvisobj[1] = pointMass3.sphere.R.T[1,1] * pointMass3.sphere.e_y[1] + (pointMass3.sphere.R.T[2,1] * pointMass3.sphere.e_y[2] + pointMass3.sphere.R.T[3,1] * pointMass3.sphere.e_y[3]);
//   pointMass3.sphere.ryvisobj[2] = pointMass3.sphere.R.T[1,2] * pointMass3.sphere.e_y[1] + (pointMass3.sphere.R.T[2,2] * pointMass3.sphere.e_y[2] + pointMass3.sphere.R.T[3,2] * pointMass3.sphere.e_y[3]);
//   pointMass3.sphere.ryvisobj[3] = pointMass3.sphere.R.T[1,3] * pointMass3.sphere.e_y[1] + (pointMass3.sphere.R.T[2,3] * pointMass3.sphere.e_y[2] + pointMass3.sphere.R.T[3,3] * pointMass3.sphere.e_y[3]);
//   pointMass3.sphere.rvisobj = pointMass3.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass3.sphere.R.T[1,1],pointMass3.sphere.R.T[1,2],pointMass3.sphere.R.T[1,3]},{pointMass3.sphere.R.T[2,1],pointMass3.sphere.R.T[2,2],pointMass3.sphere.R.T[2,3]},{pointMass3.sphere.R.T[3,1],pointMass3.sphere.R.T[3,2],pointMass3.sphere.R.T[3,3]}},{pointMass3.sphere.r_shape[1],pointMass3.sphere.r_shape[2],pointMass3.sphere.r_shape[3]});
//   pointMass3.sphere.size[1] = pointMass3.sphere.length;
//   pointMass3.sphere.size[2] = pointMass3.sphere.width;
//   pointMass3.sphere.size[3] = pointMass3.sphere.height;
//   pointMass3.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass3.sphere.color[1] / 255.0,pointMass3.sphere.color[2] / 255.0,pointMass3.sphere.color[3] / 255.0,pointMass3.sphere.specularCoefficient);
//   pointMass3.sphere.Extra = pointMass3.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass3.frame_a.R.w[3] = 0.0;
//   pointMass3.frame_a.R.w[2] = 0.0;
//   pointMass3.frame_a.R.w[1] = 0.0;
//   pointMass3.frame_a.R.T[3,3] = 1.0;
//   pointMass3.frame_a.R.T[3,2] = 0.0;
//   pointMass3.frame_a.R.T[3,1] = 0.0;
//   pointMass3.frame_a.R.T[2,3] = 0.0;
//   pointMass3.frame_a.R.T[2,2] = 1.0;
//   pointMass3.frame_a.R.T[2,1] = 0.0;
//   pointMass3.frame_a.R.T[1,3] = 0.0;
//   pointMass3.frame_a.R.T[1,2] = 0.0;
//   pointMass3.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass3.frame_a.t[1] = 0.0;
//   pointMass3.frame_a.t[2] = 0.0;
//   pointMass3.frame_a.t[3] = 0.0;
//   end if;
//   pointMass3.r_0[1] = pointMass3.frame_a.r_0[1];
//   pointMass3.r_0[2] = pointMass3.frame_a.r_0[2];
//   pointMass3.r_0[3] = pointMass3.frame_a.r_0[3];
//   pointMass3.v_0[1] = der(pointMass3.r_0[1]);
//   pointMass3.v_0[2] = der(pointMass3.r_0[2]);
//   pointMass3.v_0[3] = der(pointMass3.r_0[3]);
//   pointMass3.a_0[1] = der(pointMass3.v_0[1]);
//   pointMass3.a_0[2] = der(pointMass3.v_0[2]);
//   pointMass3.a_0[3] = der(pointMass3.v_0[3]);
//   pointMass3.frame_a.f = pointMass3.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass3.frame_a.R,{pointMass3.a_0[1],pointMass3.a_0[2],pointMass3.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass3.r_0[1],pointMass3.r_0[2],pointMass3.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   pointMass4.sphere.R.T[1,1] = pointMass4.frame_a.R.T[1,1];
//   pointMass4.sphere.R.T[1,2] = pointMass4.frame_a.R.T[1,2];
//   pointMass4.sphere.R.T[1,3] = pointMass4.frame_a.R.T[1,3];
//   pointMass4.sphere.R.T[2,1] = pointMass4.frame_a.R.T[2,1];
//   pointMass4.sphere.R.T[2,2] = pointMass4.frame_a.R.T[2,2];
//   pointMass4.sphere.R.T[2,3] = pointMass4.frame_a.R.T[2,3];
//   pointMass4.sphere.R.T[3,1] = pointMass4.frame_a.R.T[3,1];
//   pointMass4.sphere.R.T[3,2] = pointMass4.frame_a.R.T[3,2];
//   pointMass4.sphere.R.T[3,3] = pointMass4.frame_a.R.T[3,3];
//   pointMass4.sphere.R.w[1] = pointMass4.frame_a.R.w[1];
//   pointMass4.sphere.R.w[2] = pointMass4.frame_a.R.w[2];
//   pointMass4.sphere.R.w[3] = pointMass4.frame_a.R.w[3];
//   pointMass4.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass4.sphere.shapeType);
//   pointMass4.sphere.rxvisobj[1] = pointMass4.sphere.R.T[1,1] * pointMass4.sphere.e_x[1] + (pointMass4.sphere.R.T[2,1] * pointMass4.sphere.e_x[2] + pointMass4.sphere.R.T[3,1] * pointMass4.sphere.e_x[3]);
//   pointMass4.sphere.rxvisobj[2] = pointMass4.sphere.R.T[1,2] * pointMass4.sphere.e_x[1] + (pointMass4.sphere.R.T[2,2] * pointMass4.sphere.e_x[2] + pointMass4.sphere.R.T[3,2] * pointMass4.sphere.e_x[3]);
//   pointMass4.sphere.rxvisobj[3] = pointMass4.sphere.R.T[1,3] * pointMass4.sphere.e_x[1] + (pointMass4.sphere.R.T[2,3] * pointMass4.sphere.e_x[2] + pointMass4.sphere.R.T[3,3] * pointMass4.sphere.e_x[3]);
//   pointMass4.sphere.ryvisobj[1] = pointMass4.sphere.R.T[1,1] * pointMass4.sphere.e_y[1] + (pointMass4.sphere.R.T[2,1] * pointMass4.sphere.e_y[2] + pointMass4.sphere.R.T[3,1] * pointMass4.sphere.e_y[3]);
//   pointMass4.sphere.ryvisobj[2] = pointMass4.sphere.R.T[1,2] * pointMass4.sphere.e_y[1] + (pointMass4.sphere.R.T[2,2] * pointMass4.sphere.e_y[2] + pointMass4.sphere.R.T[3,2] * pointMass4.sphere.e_y[3]);
//   pointMass4.sphere.ryvisobj[3] = pointMass4.sphere.R.T[1,3] * pointMass4.sphere.e_y[1] + (pointMass4.sphere.R.T[2,3] * pointMass4.sphere.e_y[2] + pointMass4.sphere.R.T[3,3] * pointMass4.sphere.e_y[3]);
//   pointMass4.sphere.rvisobj = pointMass4.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass4.sphere.R.T[1,1],pointMass4.sphere.R.T[1,2],pointMass4.sphere.R.T[1,3]},{pointMass4.sphere.R.T[2,1],pointMass4.sphere.R.T[2,2],pointMass4.sphere.R.T[2,3]},{pointMass4.sphere.R.T[3,1],pointMass4.sphere.R.T[3,2],pointMass4.sphere.R.T[3,3]}},{pointMass4.sphere.r_shape[1],pointMass4.sphere.r_shape[2],pointMass4.sphere.r_shape[3]});
//   pointMass4.sphere.size[1] = pointMass4.sphere.length;
//   pointMass4.sphere.size[2] = pointMass4.sphere.width;
//   pointMass4.sphere.size[3] = pointMass4.sphere.height;
//   pointMass4.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass4.sphere.color[1] / 255.0,pointMass4.sphere.color[2] / 255.0,pointMass4.sphere.color[3] / 255.0,pointMass4.sphere.specularCoefficient);
//   pointMass4.sphere.Extra = pointMass4.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass4.frame_a.R.w[3] = 0.0;
//   pointMass4.frame_a.R.w[2] = 0.0;
//   pointMass4.frame_a.R.w[1] = 0.0;
//   pointMass4.frame_a.R.T[3,3] = 1.0;
//   pointMass4.frame_a.R.T[3,2] = 0.0;
//   pointMass4.frame_a.R.T[3,1] = 0.0;
//   pointMass4.frame_a.R.T[2,3] = 0.0;
//   pointMass4.frame_a.R.T[2,2] = 1.0;
//   pointMass4.frame_a.R.T[2,1] = 0.0;
//   pointMass4.frame_a.R.T[1,3] = 0.0;
//   pointMass4.frame_a.R.T[1,2] = 0.0;
//   pointMass4.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass4.frame_a.t[1] = 0.0;
//   pointMass4.frame_a.t[2] = 0.0;
//   pointMass4.frame_a.t[3] = 0.0;
//   end if;
//   pointMass4.r_0[1] = pointMass4.frame_a.r_0[1];
//   pointMass4.r_0[2] = pointMass4.frame_a.r_0[2];
//   pointMass4.r_0[3] = pointMass4.frame_a.r_0[3];
//   pointMass4.v_0[1] = der(pointMass4.r_0[1]);
//   pointMass4.v_0[2] = der(pointMass4.r_0[2]);
//   pointMass4.v_0[3] = der(pointMass4.r_0[3]);
//   pointMass4.a_0[1] = der(pointMass4.v_0[1]);
//   pointMass4.a_0[2] = der(pointMass4.v_0[2]);
//   pointMass4.a_0[3] = der(pointMass4.v_0[3]);
//   pointMass4.frame_a.f = pointMass4.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass4.frame_a.R,{pointMass4.a_0[1],pointMass4.a_0[2],pointMass4.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass4.r_0[1],pointMass4.r_0[2],pointMass4.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   pointMass5.sphere.R.T[1,1] = pointMass5.frame_a.R.T[1,1];
//   pointMass5.sphere.R.T[1,2] = pointMass5.frame_a.R.T[1,2];
//   pointMass5.sphere.R.T[1,3] = pointMass5.frame_a.R.T[1,3];
//   pointMass5.sphere.R.T[2,1] = pointMass5.frame_a.R.T[2,1];
//   pointMass5.sphere.R.T[2,2] = pointMass5.frame_a.R.T[2,2];
//   pointMass5.sphere.R.T[2,3] = pointMass5.frame_a.R.T[2,3];
//   pointMass5.sphere.R.T[3,1] = pointMass5.frame_a.R.T[3,1];
//   pointMass5.sphere.R.T[3,2] = pointMass5.frame_a.R.T[3,2];
//   pointMass5.sphere.R.T[3,3] = pointMass5.frame_a.R.T[3,3];
//   pointMass5.sphere.R.w[1] = pointMass5.frame_a.R.w[1];
//   pointMass5.sphere.R.w[2] = pointMass5.frame_a.R.w[2];
//   pointMass5.sphere.R.w[3] = pointMass5.frame_a.R.w[3];
//   pointMass5.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass5.sphere.shapeType);
//   pointMass5.sphere.rxvisobj[1] = pointMass5.sphere.R.T[1,1] * pointMass5.sphere.e_x[1] + (pointMass5.sphere.R.T[2,1] * pointMass5.sphere.e_x[2] + pointMass5.sphere.R.T[3,1] * pointMass5.sphere.e_x[3]);
//   pointMass5.sphere.rxvisobj[2] = pointMass5.sphere.R.T[1,2] * pointMass5.sphere.e_x[1] + (pointMass5.sphere.R.T[2,2] * pointMass5.sphere.e_x[2] + pointMass5.sphere.R.T[3,2] * pointMass5.sphere.e_x[3]);
//   pointMass5.sphere.rxvisobj[3] = pointMass5.sphere.R.T[1,3] * pointMass5.sphere.e_x[1] + (pointMass5.sphere.R.T[2,3] * pointMass5.sphere.e_x[2] + pointMass5.sphere.R.T[3,3] * pointMass5.sphere.e_x[3]);
//   pointMass5.sphere.ryvisobj[1] = pointMass5.sphere.R.T[1,1] * pointMass5.sphere.e_y[1] + (pointMass5.sphere.R.T[2,1] * pointMass5.sphere.e_y[2] + pointMass5.sphere.R.T[3,1] * pointMass5.sphere.e_y[3]);
//   pointMass5.sphere.ryvisobj[2] = pointMass5.sphere.R.T[1,2] * pointMass5.sphere.e_y[1] + (pointMass5.sphere.R.T[2,2] * pointMass5.sphere.e_y[2] + pointMass5.sphere.R.T[3,2] * pointMass5.sphere.e_y[3]);
//   pointMass5.sphere.ryvisobj[3] = pointMass5.sphere.R.T[1,3] * pointMass5.sphere.e_y[1] + (pointMass5.sphere.R.T[2,3] * pointMass5.sphere.e_y[2] + pointMass5.sphere.R.T[3,3] * pointMass5.sphere.e_y[3]);
//   pointMass5.sphere.rvisobj = pointMass5.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass5.sphere.R.T[1,1],pointMass5.sphere.R.T[1,2],pointMass5.sphere.R.T[1,3]},{pointMass5.sphere.R.T[2,1],pointMass5.sphere.R.T[2,2],pointMass5.sphere.R.T[2,3]},{pointMass5.sphere.R.T[3,1],pointMass5.sphere.R.T[3,2],pointMass5.sphere.R.T[3,3]}},{pointMass5.sphere.r_shape[1],pointMass5.sphere.r_shape[2],pointMass5.sphere.r_shape[3]});
//   pointMass5.sphere.size[1] = pointMass5.sphere.length;
//   pointMass5.sphere.size[2] = pointMass5.sphere.width;
//   pointMass5.sphere.size[3] = pointMass5.sphere.height;
//   pointMass5.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass5.sphere.color[1] / 255.0,pointMass5.sphere.color[2] / 255.0,pointMass5.sphere.color[3] / 255.0,pointMass5.sphere.specularCoefficient);
//   pointMass5.sphere.Extra = pointMass5.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass5.frame_a.R.w[3] = 0.0;
//   pointMass5.frame_a.R.w[2] = 0.0;
//   pointMass5.frame_a.R.w[1] = 0.0;
//   pointMass5.frame_a.R.T[3,3] = 1.0;
//   pointMass5.frame_a.R.T[3,2] = 0.0;
//   pointMass5.frame_a.R.T[3,1] = 0.0;
//   pointMass5.frame_a.R.T[2,3] = 0.0;
//   pointMass5.frame_a.R.T[2,2] = 1.0;
//   pointMass5.frame_a.R.T[2,1] = 0.0;
//   pointMass5.frame_a.R.T[1,3] = 0.0;
//   pointMass5.frame_a.R.T[1,2] = 0.0;
//   pointMass5.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass5.frame_a.t[1] = 0.0;
//   pointMass5.frame_a.t[2] = 0.0;
//   pointMass5.frame_a.t[3] = 0.0;
//   end if;
//   pointMass5.r_0[1] = pointMass5.frame_a.r_0[1];
//   pointMass5.r_0[2] = pointMass5.frame_a.r_0[2];
//   pointMass5.r_0[3] = pointMass5.frame_a.r_0[3];
//   pointMass5.v_0[1] = der(pointMass5.r_0[1]);
//   pointMass5.v_0[2] = der(pointMass5.r_0[2]);
//   pointMass5.v_0[3] = der(pointMass5.r_0[3]);
//   pointMass5.a_0[1] = der(pointMass5.v_0[1]);
//   pointMass5.a_0[2] = der(pointMass5.v_0[2]);
//   pointMass5.a_0[3] = der(pointMass5.v_0[3]);
//   pointMass5.frame_a.f = pointMass5.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass5.frame_a.R,{pointMass5.a_0[1],pointMass5.a_0[2],pointMass5.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass5.r_0[1],pointMass5.r_0[2],pointMass5.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   pointMass6.sphere.R.T[1,1] = pointMass6.frame_a.R.T[1,1];
//   pointMass6.sphere.R.T[1,2] = pointMass6.frame_a.R.T[1,2];
//   pointMass6.sphere.R.T[1,3] = pointMass6.frame_a.R.T[1,3];
//   pointMass6.sphere.R.T[2,1] = pointMass6.frame_a.R.T[2,1];
//   pointMass6.sphere.R.T[2,2] = pointMass6.frame_a.R.T[2,2];
//   pointMass6.sphere.R.T[2,3] = pointMass6.frame_a.R.T[2,3];
//   pointMass6.sphere.R.T[3,1] = pointMass6.frame_a.R.T[3,1];
//   pointMass6.sphere.R.T[3,2] = pointMass6.frame_a.R.T[3,2];
//   pointMass6.sphere.R.T[3,3] = pointMass6.frame_a.R.T[3,3];
//   pointMass6.sphere.R.w[1] = pointMass6.frame_a.R.w[1];
//   pointMass6.sphere.R.w[2] = pointMass6.frame_a.R.w[2];
//   pointMass6.sphere.R.w[3] = pointMass6.frame_a.R.w[3];
//   pointMass6.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(pointMass6.sphere.shapeType);
//   pointMass6.sphere.rxvisobj[1] = pointMass6.sphere.R.T[1,1] * pointMass6.sphere.e_x[1] + (pointMass6.sphere.R.T[2,1] * pointMass6.sphere.e_x[2] + pointMass6.sphere.R.T[3,1] * pointMass6.sphere.e_x[3]);
//   pointMass6.sphere.rxvisobj[2] = pointMass6.sphere.R.T[1,2] * pointMass6.sphere.e_x[1] + (pointMass6.sphere.R.T[2,2] * pointMass6.sphere.e_x[2] + pointMass6.sphere.R.T[3,2] * pointMass6.sphere.e_x[3]);
//   pointMass6.sphere.rxvisobj[3] = pointMass6.sphere.R.T[1,3] * pointMass6.sphere.e_x[1] + (pointMass6.sphere.R.T[2,3] * pointMass6.sphere.e_x[2] + pointMass6.sphere.R.T[3,3] * pointMass6.sphere.e_x[3]);
//   pointMass6.sphere.ryvisobj[1] = pointMass6.sphere.R.T[1,1] * pointMass6.sphere.e_y[1] + (pointMass6.sphere.R.T[2,1] * pointMass6.sphere.e_y[2] + pointMass6.sphere.R.T[3,1] * pointMass6.sphere.e_y[3]);
//   pointMass6.sphere.ryvisobj[2] = pointMass6.sphere.R.T[1,2] * pointMass6.sphere.e_y[1] + (pointMass6.sphere.R.T[2,2] * pointMass6.sphere.e_y[2] + pointMass6.sphere.R.T[3,2] * pointMass6.sphere.e_y[3]);
//   pointMass6.sphere.ryvisobj[3] = pointMass6.sphere.R.T[1,3] * pointMass6.sphere.e_y[1] + (pointMass6.sphere.R.T[2,3] * pointMass6.sphere.e_y[2] + pointMass6.sphere.R.T[3,3] * pointMass6.sphere.e_y[3]);
//   pointMass6.sphere.rvisobj = pointMass6.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{pointMass6.sphere.R.T[1,1],pointMass6.sphere.R.T[1,2],pointMass6.sphere.R.T[1,3]},{pointMass6.sphere.R.T[2,1],pointMass6.sphere.R.T[2,2],pointMass6.sphere.R.T[2,3]},{pointMass6.sphere.R.T[3,1],pointMass6.sphere.R.T[3,2],pointMass6.sphere.R.T[3,3]}},{pointMass6.sphere.r_shape[1],pointMass6.sphere.r_shape[2],pointMass6.sphere.r_shape[3]});
//   pointMass6.sphere.size[1] = pointMass6.sphere.length;
//   pointMass6.sphere.size[2] = pointMass6.sphere.width;
//   pointMass6.sphere.size[3] = pointMass6.sphere.height;
//   pointMass6.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(pointMass6.sphere.color[1] / 255.0,pointMass6.sphere.color[2] / 255.0,pointMass6.sphere.color[3] / 255.0,pointMass6.sphere.specularCoefficient);
//   pointMass6.sphere.Extra = pointMass6.sphere.extra;
//   if false then
//   assert(false,"
// A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
// a way, so that no equations are present to compute frame_a.R
// (the orientation object in the connector). Setting frame_a.R to
// an arbitrary value in the PointMass model, might lead to a wrong
// overall model, depending on how the PointMass model is used.
//    You can avoid this message, by providing equations that
// compute the orientation object, e.g., by using the
// Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
//    If a PointMass model is not connected at all, the
// orientation object is set to a unit rotation. But this is
// the only case where this is done.
// ");
//   pointMass6.frame_a.R.w[3] = 0.0;
//   pointMass6.frame_a.R.w[2] = 0.0;
//   pointMass6.frame_a.R.w[1] = 0.0;
//   pointMass6.frame_a.R.T[3,3] = 1.0;
//   pointMass6.frame_a.R.T[3,2] = 0.0;
//   pointMass6.frame_a.R.T[3,1] = 0.0;
//   pointMass6.frame_a.R.T[2,3] = 0.0;
//   pointMass6.frame_a.R.T[2,2] = 1.0;
//   pointMass6.frame_a.R.T[2,1] = 0.0;
//   pointMass6.frame_a.R.T[1,3] = 0.0;
//   pointMass6.frame_a.R.T[1,2] = 0.0;
//   pointMass6.frame_a.R.T[1,1] = 1.0;
//   else
//   pointMass6.frame_a.t[1] = 0.0;
//   pointMass6.frame_a.t[2] = 0.0;
//   pointMass6.frame_a.t[3] = 0.0;
//   end if;
//   pointMass6.r_0[1] = pointMass6.frame_a.r_0[1];
//   pointMass6.r_0[2] = pointMass6.frame_a.r_0[2];
//   pointMass6.r_0[3] = pointMass6.frame_a.r_0[3];
//   pointMass6.v_0[1] = der(pointMass6.r_0[1]);
//   pointMass6.v_0[2] = der(pointMass6.r_0[2]);
//   pointMass6.v_0[3] = der(pointMass6.r_0[3]);
//   pointMass6.a_0[1] = der(pointMass6.v_0[1]);
//   pointMass6.a_0[2] = der(pointMass6.v_0[2]);
//   pointMass6.a_0[3] = der(pointMass6.v_0[3]);
//   pointMass6.frame_a.f = pointMass6.m * Modelica.Mechanics.MultiBody.Frames.resolve2(pointMass6.frame_a.R,{pointMass6.a_0[1],pointMass6.a_0[2],pointMass6.a_0[3]} - Modelica.Mechanics.MultiBody.Parts.PointMass.world.gravityAcceleration({pointMass6.r_0[1],pointMass6.r_0[2],pointMass6.r_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue));
//   fixedTranslation.shape.R.T[1,1] = fixedTranslation.frame_a.R.T[1,1];
//   fixedTranslation.shape.R.T[1,2] = fixedTranslation.frame_a.R.T[1,2];
//   fixedTranslation.shape.R.T[1,3] = fixedTranslation.frame_a.R.T[1,3];
//   fixedTranslation.shape.R.T[2,1] = fixedTranslation.frame_a.R.T[2,1];
//   fixedTranslation.shape.R.T[2,2] = fixedTranslation.frame_a.R.T[2,2];
//   fixedTranslation.shape.R.T[2,3] = fixedTranslation.frame_a.R.T[2,3];
//   fixedTranslation.shape.R.T[3,1] = fixedTranslation.frame_a.R.T[3,1];
//   fixedTranslation.shape.R.T[3,2] = fixedTranslation.frame_a.R.T[3,2];
//   fixedTranslation.shape.R.T[3,3] = fixedTranslation.frame_a.R.T[3,3];
//   fixedTranslation.shape.R.w[1] = fixedTranslation.frame_a.R.w[1];
//   fixedTranslation.shape.R.w[2] = fixedTranslation.frame_a.R.w[2];
//   fixedTranslation.shape.R.w[3] = fixedTranslation.frame_a.R.w[3];
//   fixedTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation.shape.shapeType);
//   fixedTranslation.shape.rxvisobj[1] = fixedTranslation.shape.R.T[1,1] * fixedTranslation.shape.e_x[1] + (fixedTranslation.shape.R.T[2,1] * fixedTranslation.shape.e_x[2] + fixedTranslation.shape.R.T[3,1] * fixedTranslation.shape.e_x[3]);
//   fixedTranslation.shape.rxvisobj[2] = fixedTranslation.shape.R.T[1,2] * fixedTranslation.shape.e_x[1] + (fixedTranslation.shape.R.T[2,2] * fixedTranslation.shape.e_x[2] + fixedTranslation.shape.R.T[3,2] * fixedTranslation.shape.e_x[3]);
//   fixedTranslation.shape.rxvisobj[3] = fixedTranslation.shape.R.T[1,3] * fixedTranslation.shape.e_x[1] + (fixedTranslation.shape.R.T[2,3] * fixedTranslation.shape.e_x[2] + fixedTranslation.shape.R.T[3,3] * fixedTranslation.shape.e_x[3]);
//   fixedTranslation.shape.ryvisobj[1] = fixedTranslation.shape.R.T[1,1] * fixedTranslation.shape.e_y[1] + (fixedTranslation.shape.R.T[2,1] * fixedTranslation.shape.e_y[2] + fixedTranslation.shape.R.T[3,1] * fixedTranslation.shape.e_y[3]);
//   fixedTranslation.shape.ryvisobj[2] = fixedTranslation.shape.R.T[1,2] * fixedTranslation.shape.e_y[1] + (fixedTranslation.shape.R.T[2,2] * fixedTranslation.shape.e_y[2] + fixedTranslation.shape.R.T[3,2] * fixedTranslation.shape.e_y[3]);
//   fixedTranslation.shape.ryvisobj[3] = fixedTranslation.shape.R.T[1,3] * fixedTranslation.shape.e_y[1] + (fixedTranslation.shape.R.T[2,3] * fixedTranslation.shape.e_y[2] + fixedTranslation.shape.R.T[3,3] * fixedTranslation.shape.e_y[3]);
//   fixedTranslation.shape.rvisobj = fixedTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation.shape.R.T[1,1],fixedTranslation.shape.R.T[1,2],fixedTranslation.shape.R.T[1,3]},{fixedTranslation.shape.R.T[2,1],fixedTranslation.shape.R.T[2,2],fixedTranslation.shape.R.T[2,3]},{fixedTranslation.shape.R.T[3,1],fixedTranslation.shape.R.T[3,2],fixedTranslation.shape.R.T[3,3]}},{fixedTranslation.shape.r_shape[1],fixedTranslation.shape.r_shape[2],fixedTranslation.shape.r_shape[3]});
//   fixedTranslation.shape.size[1] = fixedTranslation.shape.length;
//   fixedTranslation.shape.size[2] = fixedTranslation.shape.width;
//   fixedTranslation.shape.size[3] = fixedTranslation.shape.height;
//   fixedTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation.shape.color[1] / 255.0,fixedTranslation.shape.color[2] / 255.0,fixedTranslation.shape.color[3] / 255.0,fixedTranslation.shape.specularCoefficient);
//   fixedTranslation.shape.Extra = fixedTranslation.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation.frame_b.r_0 = fixedTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation.frame_a.R,{fixedTranslation.r[1],fixedTranslation.r[2],fixedTranslation.r[3]});
//   fixedTranslation.frame_b.R.T[1,1] = fixedTranslation.frame_a.R.T[1,1];
//   fixedTranslation.frame_b.R.T[1,2] = fixedTranslation.frame_a.R.T[1,2];
//   fixedTranslation.frame_b.R.T[1,3] = fixedTranslation.frame_a.R.T[1,3];
//   fixedTranslation.frame_b.R.T[2,1] = fixedTranslation.frame_a.R.T[2,1];
//   fixedTranslation.frame_b.R.T[2,2] = fixedTranslation.frame_a.R.T[2,2];
//   fixedTranslation.frame_b.R.T[2,3] = fixedTranslation.frame_a.R.T[2,3];
//   fixedTranslation.frame_b.R.T[3,1] = fixedTranslation.frame_a.R.T[3,1];
//   fixedTranslation.frame_b.R.T[3,2] = fixedTranslation.frame_a.R.T[3,2];
//   fixedTranslation.frame_b.R.T[3,3] = fixedTranslation.frame_a.R.T[3,3];
//   fixedTranslation.frame_b.R.w[1] = fixedTranslation.frame_a.R.w[1];
//   fixedTranslation.frame_b.R.w[2] = fixedTranslation.frame_a.R.w[2];
//   fixedTranslation.frame_b.R.w[3] = fixedTranslation.frame_a.R.w[3];
//   0.0 = fixedTranslation.frame_a.f[1] + fixedTranslation.frame_b.f[1];
//   0.0 = fixedTranslation.frame_a.f[2] + fixedTranslation.frame_b.f[2];
//   0.0 = fixedTranslation.frame_a.f[3] + fixedTranslation.frame_b.f[3];
//   0.0 = fixedTranslation.frame_a.t[1] + (fixedTranslation.frame_b.t[1] + (fixedTranslation.r[2] * fixedTranslation.frame_b.f[3] + (-fixedTranslation.r[3] * fixedTranslation.frame_b.f[2])));
//   0.0 = fixedTranslation.frame_a.t[2] + (fixedTranslation.frame_b.t[2] + (fixedTranslation.r[3] * fixedTranslation.frame_b.f[1] + (-fixedTranslation.r[1] * fixedTranslation.frame_b.f[3])));
//   0.0 = fixedTranslation.frame_a.t[3] + (fixedTranslation.frame_b.t[3] + (fixedTranslation.r[1] * fixedTranslation.frame_b.f[2] + (-fixedTranslation.r[2] * fixedTranslation.frame_b.f[1])));
//   fixedTranslation1.shape.R.T[1,1] = fixedTranslation1.frame_a.R.T[1,1];
//   fixedTranslation1.shape.R.T[1,2] = fixedTranslation1.frame_a.R.T[1,2];
//   fixedTranslation1.shape.R.T[1,3] = fixedTranslation1.frame_a.R.T[1,3];
//   fixedTranslation1.shape.R.T[2,1] = fixedTranslation1.frame_a.R.T[2,1];
//   fixedTranslation1.shape.R.T[2,2] = fixedTranslation1.frame_a.R.T[2,2];
//   fixedTranslation1.shape.R.T[2,3] = fixedTranslation1.frame_a.R.T[2,3];
//   fixedTranslation1.shape.R.T[3,1] = fixedTranslation1.frame_a.R.T[3,1];
//   fixedTranslation1.shape.R.T[3,2] = fixedTranslation1.frame_a.R.T[3,2];
//   fixedTranslation1.shape.R.T[3,3] = fixedTranslation1.frame_a.R.T[3,3];
//   fixedTranslation1.shape.R.w[1] = fixedTranslation1.frame_a.R.w[1];
//   fixedTranslation1.shape.R.w[2] = fixedTranslation1.frame_a.R.w[2];
//   fixedTranslation1.shape.R.w[3] = fixedTranslation1.frame_a.R.w[3];
//   fixedTranslation1.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation1.shape.shapeType);
//   fixedTranslation1.shape.rxvisobj[1] = fixedTranslation1.shape.R.T[1,1] * fixedTranslation1.shape.e_x[1] + (fixedTranslation1.shape.R.T[2,1] * fixedTranslation1.shape.e_x[2] + fixedTranslation1.shape.R.T[3,1] * fixedTranslation1.shape.e_x[3]);
//   fixedTranslation1.shape.rxvisobj[2] = fixedTranslation1.shape.R.T[1,2] * fixedTranslation1.shape.e_x[1] + (fixedTranslation1.shape.R.T[2,2] * fixedTranslation1.shape.e_x[2] + fixedTranslation1.shape.R.T[3,2] * fixedTranslation1.shape.e_x[3]);
//   fixedTranslation1.shape.rxvisobj[3] = fixedTranslation1.shape.R.T[1,3] * fixedTranslation1.shape.e_x[1] + (fixedTranslation1.shape.R.T[2,3] * fixedTranslation1.shape.e_x[2] + fixedTranslation1.shape.R.T[3,3] * fixedTranslation1.shape.e_x[3]);
//   fixedTranslation1.shape.ryvisobj[1] = fixedTranslation1.shape.R.T[1,1] * fixedTranslation1.shape.e_y[1] + (fixedTranslation1.shape.R.T[2,1] * fixedTranslation1.shape.e_y[2] + fixedTranslation1.shape.R.T[3,1] * fixedTranslation1.shape.e_y[3]);
//   fixedTranslation1.shape.ryvisobj[2] = fixedTranslation1.shape.R.T[1,2] * fixedTranslation1.shape.e_y[1] + (fixedTranslation1.shape.R.T[2,2] * fixedTranslation1.shape.e_y[2] + fixedTranslation1.shape.R.T[3,2] * fixedTranslation1.shape.e_y[3]);
//   fixedTranslation1.shape.ryvisobj[3] = fixedTranslation1.shape.R.T[1,3] * fixedTranslation1.shape.e_y[1] + (fixedTranslation1.shape.R.T[2,3] * fixedTranslation1.shape.e_y[2] + fixedTranslation1.shape.R.T[3,3] * fixedTranslation1.shape.e_y[3]);
//   fixedTranslation1.shape.rvisobj = fixedTranslation1.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation1.shape.R.T[1,1],fixedTranslation1.shape.R.T[1,2],fixedTranslation1.shape.R.T[1,3]},{fixedTranslation1.shape.R.T[2,1],fixedTranslation1.shape.R.T[2,2],fixedTranslation1.shape.R.T[2,3]},{fixedTranslation1.shape.R.T[3,1],fixedTranslation1.shape.R.T[3,2],fixedTranslation1.shape.R.T[3,3]}},{fixedTranslation1.shape.r_shape[1],fixedTranslation1.shape.r_shape[2],fixedTranslation1.shape.r_shape[3]});
//   fixedTranslation1.shape.size[1] = fixedTranslation1.shape.length;
//   fixedTranslation1.shape.size[2] = fixedTranslation1.shape.width;
//   fixedTranslation1.shape.size[3] = fixedTranslation1.shape.height;
//   fixedTranslation1.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation1.shape.color[1] / 255.0,fixedTranslation1.shape.color[2] / 255.0,fixedTranslation1.shape.color[3] / 255.0,fixedTranslation1.shape.specularCoefficient);
//   fixedTranslation1.shape.Extra = fixedTranslation1.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation1.frame_b.r_0 = fixedTranslation1.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation1.frame_a.R,{fixedTranslation1.r[1],fixedTranslation1.r[2],fixedTranslation1.r[3]});
//   fixedTranslation1.frame_b.R.T[1,1] = fixedTranslation1.frame_a.R.T[1,1];
//   fixedTranslation1.frame_b.R.T[1,2] = fixedTranslation1.frame_a.R.T[1,2];
//   fixedTranslation1.frame_b.R.T[1,3] = fixedTranslation1.frame_a.R.T[1,3];
//   fixedTranslation1.frame_b.R.T[2,1] = fixedTranslation1.frame_a.R.T[2,1];
//   fixedTranslation1.frame_b.R.T[2,2] = fixedTranslation1.frame_a.R.T[2,2];
//   fixedTranslation1.frame_b.R.T[2,3] = fixedTranslation1.frame_a.R.T[2,3];
//   fixedTranslation1.frame_b.R.T[3,1] = fixedTranslation1.frame_a.R.T[3,1];
//   fixedTranslation1.frame_b.R.T[3,2] = fixedTranslation1.frame_a.R.T[3,2];
//   fixedTranslation1.frame_b.R.T[3,3] = fixedTranslation1.frame_a.R.T[3,3];
//   fixedTranslation1.frame_b.R.w[1] = fixedTranslation1.frame_a.R.w[1];
//   fixedTranslation1.frame_b.R.w[2] = fixedTranslation1.frame_a.R.w[2];
//   fixedTranslation1.frame_b.R.w[3] = fixedTranslation1.frame_a.R.w[3];
//   0.0 = fixedTranslation1.frame_a.f[1] + fixedTranslation1.frame_b.f[1];
//   0.0 = fixedTranslation1.frame_a.f[2] + fixedTranslation1.frame_b.f[2];
//   0.0 = fixedTranslation1.frame_a.f[3] + fixedTranslation1.frame_b.f[3];
//   0.0 = fixedTranslation1.frame_a.t[1] + (fixedTranslation1.frame_b.t[1] + (fixedTranslation1.r[2] * fixedTranslation1.frame_b.f[3] + (-fixedTranslation1.r[3] * fixedTranslation1.frame_b.f[2])));
//   0.0 = fixedTranslation1.frame_a.t[2] + (fixedTranslation1.frame_b.t[2] + (fixedTranslation1.r[3] * fixedTranslation1.frame_b.f[1] + (-fixedTranslation1.r[1] * fixedTranslation1.frame_b.f[3])));
//   0.0 = fixedTranslation1.frame_a.t[3] + (fixedTranslation1.frame_b.t[3] + (fixedTranslation1.r[1] * fixedTranslation1.frame_b.f[2] + (-fixedTranslation1.r[2] * fixedTranslation1.frame_b.f[1])));
//   fixedTranslation2.shape.R.T[1,1] = fixedTranslation2.frame_a.R.T[1,1];
//   fixedTranslation2.shape.R.T[1,2] = fixedTranslation2.frame_a.R.T[1,2];
//   fixedTranslation2.shape.R.T[1,3] = fixedTranslation2.frame_a.R.T[1,3];
//   fixedTranslation2.shape.R.T[2,1] = fixedTranslation2.frame_a.R.T[2,1];
//   fixedTranslation2.shape.R.T[2,2] = fixedTranslation2.frame_a.R.T[2,2];
//   fixedTranslation2.shape.R.T[2,3] = fixedTranslation2.frame_a.R.T[2,3];
//   fixedTranslation2.shape.R.T[3,1] = fixedTranslation2.frame_a.R.T[3,1];
//   fixedTranslation2.shape.R.T[3,2] = fixedTranslation2.frame_a.R.T[3,2];
//   fixedTranslation2.shape.R.T[3,3] = fixedTranslation2.frame_a.R.T[3,3];
//   fixedTranslation2.shape.R.w[1] = fixedTranslation2.frame_a.R.w[1];
//   fixedTranslation2.shape.R.w[2] = fixedTranslation2.frame_a.R.w[2];
//   fixedTranslation2.shape.R.w[3] = fixedTranslation2.frame_a.R.w[3];
//   fixedTranslation2.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation2.shape.shapeType);
//   fixedTranslation2.shape.rxvisobj[1] = fixedTranslation2.shape.R.T[1,1] * fixedTranslation2.shape.e_x[1] + (fixedTranslation2.shape.R.T[2,1] * fixedTranslation2.shape.e_x[2] + fixedTranslation2.shape.R.T[3,1] * fixedTranslation2.shape.e_x[3]);
//   fixedTranslation2.shape.rxvisobj[2] = fixedTranslation2.shape.R.T[1,2] * fixedTranslation2.shape.e_x[1] + (fixedTranslation2.shape.R.T[2,2] * fixedTranslation2.shape.e_x[2] + fixedTranslation2.shape.R.T[3,2] * fixedTranslation2.shape.e_x[3]);
//   fixedTranslation2.shape.rxvisobj[3] = fixedTranslation2.shape.R.T[1,3] * fixedTranslation2.shape.e_x[1] + (fixedTranslation2.shape.R.T[2,3] * fixedTranslation2.shape.e_x[2] + fixedTranslation2.shape.R.T[3,3] * fixedTranslation2.shape.e_x[3]);
//   fixedTranslation2.shape.ryvisobj[1] = fixedTranslation2.shape.R.T[1,1] * fixedTranslation2.shape.e_y[1] + (fixedTranslation2.shape.R.T[2,1] * fixedTranslation2.shape.e_y[2] + fixedTranslation2.shape.R.T[3,1] * fixedTranslation2.shape.e_y[3]);
//   fixedTranslation2.shape.ryvisobj[2] = fixedTranslation2.shape.R.T[1,2] * fixedTranslation2.shape.e_y[1] + (fixedTranslation2.shape.R.T[2,2] * fixedTranslation2.shape.e_y[2] + fixedTranslation2.shape.R.T[3,2] * fixedTranslation2.shape.e_y[3]);
//   fixedTranslation2.shape.ryvisobj[3] = fixedTranslation2.shape.R.T[1,3] * fixedTranslation2.shape.e_y[1] + (fixedTranslation2.shape.R.T[2,3] * fixedTranslation2.shape.e_y[2] + fixedTranslation2.shape.R.T[3,3] * fixedTranslation2.shape.e_y[3]);
//   fixedTranslation2.shape.rvisobj = fixedTranslation2.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation2.shape.R.T[1,1],fixedTranslation2.shape.R.T[1,2],fixedTranslation2.shape.R.T[1,3]},{fixedTranslation2.shape.R.T[2,1],fixedTranslation2.shape.R.T[2,2],fixedTranslation2.shape.R.T[2,3]},{fixedTranslation2.shape.R.T[3,1],fixedTranslation2.shape.R.T[3,2],fixedTranslation2.shape.R.T[3,3]}},{fixedTranslation2.shape.r_shape[1],fixedTranslation2.shape.r_shape[2],fixedTranslation2.shape.r_shape[3]});
//   fixedTranslation2.shape.size[1] = fixedTranslation2.shape.length;
//   fixedTranslation2.shape.size[2] = fixedTranslation2.shape.width;
//   fixedTranslation2.shape.size[3] = fixedTranslation2.shape.height;
//   fixedTranslation2.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation2.shape.color[1] / 255.0,fixedTranslation2.shape.color[2] / 255.0,fixedTranslation2.shape.color[3] / 255.0,fixedTranslation2.shape.specularCoefficient);
//   fixedTranslation2.shape.Extra = fixedTranslation2.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation2.frame_b.r_0 = fixedTranslation2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation2.frame_a.R,{fixedTranslation2.r[1],fixedTranslation2.r[2],fixedTranslation2.r[3]});
//   fixedTranslation2.frame_b.R.T[1,1] = fixedTranslation2.frame_a.R.T[1,1];
//   fixedTranslation2.frame_b.R.T[1,2] = fixedTranslation2.frame_a.R.T[1,2];
//   fixedTranslation2.frame_b.R.T[1,3] = fixedTranslation2.frame_a.R.T[1,3];
//   fixedTranslation2.frame_b.R.T[2,1] = fixedTranslation2.frame_a.R.T[2,1];
//   fixedTranslation2.frame_b.R.T[2,2] = fixedTranslation2.frame_a.R.T[2,2];
//   fixedTranslation2.frame_b.R.T[2,3] = fixedTranslation2.frame_a.R.T[2,3];
//   fixedTranslation2.frame_b.R.T[3,1] = fixedTranslation2.frame_a.R.T[3,1];
//   fixedTranslation2.frame_b.R.T[3,2] = fixedTranslation2.frame_a.R.T[3,2];
//   fixedTranslation2.frame_b.R.T[3,3] = fixedTranslation2.frame_a.R.T[3,3];
//   fixedTranslation2.frame_b.R.w[1] = fixedTranslation2.frame_a.R.w[1];
//   fixedTranslation2.frame_b.R.w[2] = fixedTranslation2.frame_a.R.w[2];
//   fixedTranslation2.frame_b.R.w[3] = fixedTranslation2.frame_a.R.w[3];
//   0.0 = fixedTranslation2.frame_a.f[1] + fixedTranslation2.frame_b.f[1];
//   0.0 = fixedTranslation2.frame_a.f[2] + fixedTranslation2.frame_b.f[2];
//   0.0 = fixedTranslation2.frame_a.f[3] + fixedTranslation2.frame_b.f[3];
//   0.0 = fixedTranslation2.frame_a.t[1] + (fixedTranslation2.frame_b.t[1] + (fixedTranslation2.r[2] * fixedTranslation2.frame_b.f[3] + (-fixedTranslation2.r[3] * fixedTranslation2.frame_b.f[2])));
//   0.0 = fixedTranslation2.frame_a.t[2] + (fixedTranslation2.frame_b.t[2] + (fixedTranslation2.r[3] * fixedTranslation2.frame_b.f[1] + (-fixedTranslation2.r[1] * fixedTranslation2.frame_b.f[3])));
//   0.0 = fixedTranslation2.frame_a.t[3] + (fixedTranslation2.frame_b.t[3] + (fixedTranslation2.r[1] * fixedTranslation2.frame_b.f[2] + (-fixedTranslation2.r[2] * fixedTranslation2.frame_b.f[1])));
//   fixedTranslation3.shape.R.T[1,1] = fixedTranslation3.frame_a.R.T[1,1];
//   fixedTranslation3.shape.R.T[1,2] = fixedTranslation3.frame_a.R.T[1,2];
//   fixedTranslation3.shape.R.T[1,3] = fixedTranslation3.frame_a.R.T[1,3];
//   fixedTranslation3.shape.R.T[2,1] = fixedTranslation3.frame_a.R.T[2,1];
//   fixedTranslation3.shape.R.T[2,2] = fixedTranslation3.frame_a.R.T[2,2];
//   fixedTranslation3.shape.R.T[2,3] = fixedTranslation3.frame_a.R.T[2,3];
//   fixedTranslation3.shape.R.T[3,1] = fixedTranslation3.frame_a.R.T[3,1];
//   fixedTranslation3.shape.R.T[3,2] = fixedTranslation3.frame_a.R.T[3,2];
//   fixedTranslation3.shape.R.T[3,3] = fixedTranslation3.frame_a.R.T[3,3];
//   fixedTranslation3.shape.R.w[1] = fixedTranslation3.frame_a.R.w[1];
//   fixedTranslation3.shape.R.w[2] = fixedTranslation3.frame_a.R.w[2];
//   fixedTranslation3.shape.R.w[3] = fixedTranslation3.frame_a.R.w[3];
//   fixedTranslation3.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation3.shape.shapeType);
//   fixedTranslation3.shape.rxvisobj[1] = fixedTranslation3.shape.R.T[1,1] * fixedTranslation3.shape.e_x[1] + (fixedTranslation3.shape.R.T[2,1] * fixedTranslation3.shape.e_x[2] + fixedTranslation3.shape.R.T[3,1] * fixedTranslation3.shape.e_x[3]);
//   fixedTranslation3.shape.rxvisobj[2] = fixedTranslation3.shape.R.T[1,2] * fixedTranslation3.shape.e_x[1] + (fixedTranslation3.shape.R.T[2,2] * fixedTranslation3.shape.e_x[2] + fixedTranslation3.shape.R.T[3,2] * fixedTranslation3.shape.e_x[3]);
//   fixedTranslation3.shape.rxvisobj[3] = fixedTranslation3.shape.R.T[1,3] * fixedTranslation3.shape.e_x[1] + (fixedTranslation3.shape.R.T[2,3] * fixedTranslation3.shape.e_x[2] + fixedTranslation3.shape.R.T[3,3] * fixedTranslation3.shape.e_x[3]);
//   fixedTranslation3.shape.ryvisobj[1] = fixedTranslation3.shape.R.T[1,1] * fixedTranslation3.shape.e_y[1] + (fixedTranslation3.shape.R.T[2,1] * fixedTranslation3.shape.e_y[2] + fixedTranslation3.shape.R.T[3,1] * fixedTranslation3.shape.e_y[3]);
//   fixedTranslation3.shape.ryvisobj[2] = fixedTranslation3.shape.R.T[1,2] * fixedTranslation3.shape.e_y[1] + (fixedTranslation3.shape.R.T[2,2] * fixedTranslation3.shape.e_y[2] + fixedTranslation3.shape.R.T[3,2] * fixedTranslation3.shape.e_y[3]);
//   fixedTranslation3.shape.ryvisobj[3] = fixedTranslation3.shape.R.T[1,3] * fixedTranslation3.shape.e_y[1] + (fixedTranslation3.shape.R.T[2,3] * fixedTranslation3.shape.e_y[2] + fixedTranslation3.shape.R.T[3,3] * fixedTranslation3.shape.e_y[3]);
//   fixedTranslation3.shape.rvisobj = fixedTranslation3.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation3.shape.R.T[1,1],fixedTranslation3.shape.R.T[1,2],fixedTranslation3.shape.R.T[1,3]},{fixedTranslation3.shape.R.T[2,1],fixedTranslation3.shape.R.T[2,2],fixedTranslation3.shape.R.T[2,3]},{fixedTranslation3.shape.R.T[3,1],fixedTranslation3.shape.R.T[3,2],fixedTranslation3.shape.R.T[3,3]}},{fixedTranslation3.shape.r_shape[1],fixedTranslation3.shape.r_shape[2],fixedTranslation3.shape.r_shape[3]});
//   fixedTranslation3.shape.size[1] = fixedTranslation3.shape.length;
//   fixedTranslation3.shape.size[2] = fixedTranslation3.shape.width;
//   fixedTranslation3.shape.size[3] = fixedTranslation3.shape.height;
//   fixedTranslation3.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation3.shape.color[1] / 255.0,fixedTranslation3.shape.color[2] / 255.0,fixedTranslation3.shape.color[3] / 255.0,fixedTranslation3.shape.specularCoefficient);
//   fixedTranslation3.shape.Extra = fixedTranslation3.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation3.frame_b.r_0 = fixedTranslation3.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation3.frame_a.R,{fixedTranslation3.r[1],fixedTranslation3.r[2],fixedTranslation3.r[3]});
//   fixedTranslation3.frame_b.R.T[1,1] = fixedTranslation3.frame_a.R.T[1,1];
//   fixedTranslation3.frame_b.R.T[1,2] = fixedTranslation3.frame_a.R.T[1,2];
//   fixedTranslation3.frame_b.R.T[1,3] = fixedTranslation3.frame_a.R.T[1,3];
//   fixedTranslation3.frame_b.R.T[2,1] = fixedTranslation3.frame_a.R.T[2,1];
//   fixedTranslation3.frame_b.R.T[2,2] = fixedTranslation3.frame_a.R.T[2,2];
//   fixedTranslation3.frame_b.R.T[2,3] = fixedTranslation3.frame_a.R.T[2,3];
//   fixedTranslation3.frame_b.R.T[3,1] = fixedTranslation3.frame_a.R.T[3,1];
//   fixedTranslation3.frame_b.R.T[3,2] = fixedTranslation3.frame_a.R.T[3,2];
//   fixedTranslation3.frame_b.R.T[3,3] = fixedTranslation3.frame_a.R.T[3,3];
//   fixedTranslation3.frame_b.R.w[1] = fixedTranslation3.frame_a.R.w[1];
//   fixedTranslation3.frame_b.R.w[2] = fixedTranslation3.frame_a.R.w[2];
//   fixedTranslation3.frame_b.R.w[3] = fixedTranslation3.frame_a.R.w[3];
//   0.0 = fixedTranslation3.frame_a.f[1] + fixedTranslation3.frame_b.f[1];
//   0.0 = fixedTranslation3.frame_a.f[2] + fixedTranslation3.frame_b.f[2];
//   0.0 = fixedTranslation3.frame_a.f[3] + fixedTranslation3.frame_b.f[3];
//   0.0 = fixedTranslation3.frame_a.t[1] + (fixedTranslation3.frame_b.t[1] + (fixedTranslation3.r[2] * fixedTranslation3.frame_b.f[3] + (-fixedTranslation3.r[3] * fixedTranslation3.frame_b.f[2])));
//   0.0 = fixedTranslation3.frame_a.t[2] + (fixedTranslation3.frame_b.t[2] + (fixedTranslation3.r[3] * fixedTranslation3.frame_b.f[1] + (-fixedTranslation3.r[1] * fixedTranslation3.frame_b.f[3])));
//   0.0 = fixedTranslation3.frame_a.t[3] + (fixedTranslation3.frame_b.t[3] + (fixedTranslation3.r[1] * fixedTranslation3.frame_b.f[2] + (-fixedTranslation3.r[2] * fixedTranslation3.frame_b.f[1])));
//   fixedTranslation4.shape.R.T[1,1] = fixedTranslation4.frame_a.R.T[1,1];
//   fixedTranslation4.shape.R.T[1,2] = fixedTranslation4.frame_a.R.T[1,2];
//   fixedTranslation4.shape.R.T[1,3] = fixedTranslation4.frame_a.R.T[1,3];
//   fixedTranslation4.shape.R.T[2,1] = fixedTranslation4.frame_a.R.T[2,1];
//   fixedTranslation4.shape.R.T[2,2] = fixedTranslation4.frame_a.R.T[2,2];
//   fixedTranslation4.shape.R.T[2,3] = fixedTranslation4.frame_a.R.T[2,3];
//   fixedTranslation4.shape.R.T[3,1] = fixedTranslation4.frame_a.R.T[3,1];
//   fixedTranslation4.shape.R.T[3,2] = fixedTranslation4.frame_a.R.T[3,2];
//   fixedTranslation4.shape.R.T[3,3] = fixedTranslation4.frame_a.R.T[3,3];
//   fixedTranslation4.shape.R.w[1] = fixedTranslation4.frame_a.R.w[1];
//   fixedTranslation4.shape.R.w[2] = fixedTranslation4.frame_a.R.w[2];
//   fixedTranslation4.shape.R.w[3] = fixedTranslation4.frame_a.R.w[3];
//   fixedTranslation4.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation4.shape.shapeType);
//   fixedTranslation4.shape.rxvisobj[1] = fixedTranslation4.shape.R.T[1,1] * fixedTranslation4.shape.e_x[1] + (fixedTranslation4.shape.R.T[2,1] * fixedTranslation4.shape.e_x[2] + fixedTranslation4.shape.R.T[3,1] * fixedTranslation4.shape.e_x[3]);
//   fixedTranslation4.shape.rxvisobj[2] = fixedTranslation4.shape.R.T[1,2] * fixedTranslation4.shape.e_x[1] + (fixedTranslation4.shape.R.T[2,2] * fixedTranslation4.shape.e_x[2] + fixedTranslation4.shape.R.T[3,2] * fixedTranslation4.shape.e_x[3]);
//   fixedTranslation4.shape.rxvisobj[3] = fixedTranslation4.shape.R.T[1,3] * fixedTranslation4.shape.e_x[1] + (fixedTranslation4.shape.R.T[2,3] * fixedTranslation4.shape.e_x[2] + fixedTranslation4.shape.R.T[3,3] * fixedTranslation4.shape.e_x[3]);
//   fixedTranslation4.shape.ryvisobj[1] = fixedTranslation4.shape.R.T[1,1] * fixedTranslation4.shape.e_y[1] + (fixedTranslation4.shape.R.T[2,1] * fixedTranslation4.shape.e_y[2] + fixedTranslation4.shape.R.T[3,1] * fixedTranslation4.shape.e_y[3]);
//   fixedTranslation4.shape.ryvisobj[2] = fixedTranslation4.shape.R.T[1,2] * fixedTranslation4.shape.e_y[1] + (fixedTranslation4.shape.R.T[2,2] * fixedTranslation4.shape.e_y[2] + fixedTranslation4.shape.R.T[3,2] * fixedTranslation4.shape.e_y[3]);
//   fixedTranslation4.shape.ryvisobj[3] = fixedTranslation4.shape.R.T[1,3] * fixedTranslation4.shape.e_y[1] + (fixedTranslation4.shape.R.T[2,3] * fixedTranslation4.shape.e_y[2] + fixedTranslation4.shape.R.T[3,3] * fixedTranslation4.shape.e_y[3]);
//   fixedTranslation4.shape.rvisobj = fixedTranslation4.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation4.shape.R.T[1,1],fixedTranslation4.shape.R.T[1,2],fixedTranslation4.shape.R.T[1,3]},{fixedTranslation4.shape.R.T[2,1],fixedTranslation4.shape.R.T[2,2],fixedTranslation4.shape.R.T[2,3]},{fixedTranslation4.shape.R.T[3,1],fixedTranslation4.shape.R.T[3,2],fixedTranslation4.shape.R.T[3,3]}},{fixedTranslation4.shape.r_shape[1],fixedTranslation4.shape.r_shape[2],fixedTranslation4.shape.r_shape[3]});
//   fixedTranslation4.shape.size[1] = fixedTranslation4.shape.length;
//   fixedTranslation4.shape.size[2] = fixedTranslation4.shape.width;
//   fixedTranslation4.shape.size[3] = fixedTranslation4.shape.height;
//   fixedTranslation4.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation4.shape.color[1] / 255.0,fixedTranslation4.shape.color[2] / 255.0,fixedTranslation4.shape.color[3] / 255.0,fixedTranslation4.shape.specularCoefficient);
//   fixedTranslation4.shape.Extra = fixedTranslation4.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation4.frame_b.r_0 = fixedTranslation4.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation4.frame_a.R,{fixedTranslation4.r[1],fixedTranslation4.r[2],fixedTranslation4.r[3]});
//   fixedTranslation4.frame_b.R.T[1,1] = fixedTranslation4.frame_a.R.T[1,1];
//   fixedTranslation4.frame_b.R.T[1,2] = fixedTranslation4.frame_a.R.T[1,2];
//   fixedTranslation4.frame_b.R.T[1,3] = fixedTranslation4.frame_a.R.T[1,3];
//   fixedTranslation4.frame_b.R.T[2,1] = fixedTranslation4.frame_a.R.T[2,1];
//   fixedTranslation4.frame_b.R.T[2,2] = fixedTranslation4.frame_a.R.T[2,2];
//   fixedTranslation4.frame_b.R.T[2,3] = fixedTranslation4.frame_a.R.T[2,3];
//   fixedTranslation4.frame_b.R.T[3,1] = fixedTranslation4.frame_a.R.T[3,1];
//   fixedTranslation4.frame_b.R.T[3,2] = fixedTranslation4.frame_a.R.T[3,2];
//   fixedTranslation4.frame_b.R.T[3,3] = fixedTranslation4.frame_a.R.T[3,3];
//   fixedTranslation4.frame_b.R.w[1] = fixedTranslation4.frame_a.R.w[1];
//   fixedTranslation4.frame_b.R.w[2] = fixedTranslation4.frame_a.R.w[2];
//   fixedTranslation4.frame_b.R.w[3] = fixedTranslation4.frame_a.R.w[3];
//   0.0 = fixedTranslation4.frame_a.f[1] + fixedTranslation4.frame_b.f[1];
//   0.0 = fixedTranslation4.frame_a.f[2] + fixedTranslation4.frame_b.f[2];
//   0.0 = fixedTranslation4.frame_a.f[3] + fixedTranslation4.frame_b.f[3];
//   0.0 = fixedTranslation4.frame_a.t[1] + (fixedTranslation4.frame_b.t[1] + (fixedTranslation4.r[2] * fixedTranslation4.frame_b.f[3] + (-fixedTranslation4.r[3] * fixedTranslation4.frame_b.f[2])));
//   0.0 = fixedTranslation4.frame_a.t[2] + (fixedTranslation4.frame_b.t[2] + (fixedTranslation4.r[3] * fixedTranslation4.frame_b.f[1] + (-fixedTranslation4.r[1] * fixedTranslation4.frame_b.f[3])));
//   0.0 = fixedTranslation4.frame_a.t[3] + (fixedTranslation4.frame_b.t[3] + (fixedTranslation4.r[1] * fixedTranslation4.frame_b.f[2] + (-fixedTranslation4.r[2] * fixedTranslation4.frame_b.f[1])));
//   fixedTranslation5.shape.R.T[1,1] = fixedTranslation5.frame_a.R.T[1,1];
//   fixedTranslation5.shape.R.T[1,2] = fixedTranslation5.frame_a.R.T[1,2];
//   fixedTranslation5.shape.R.T[1,3] = fixedTranslation5.frame_a.R.T[1,3];
//   fixedTranslation5.shape.R.T[2,1] = fixedTranslation5.frame_a.R.T[2,1];
//   fixedTranslation5.shape.R.T[2,2] = fixedTranslation5.frame_a.R.T[2,2];
//   fixedTranslation5.shape.R.T[2,3] = fixedTranslation5.frame_a.R.T[2,3];
//   fixedTranslation5.shape.R.T[3,1] = fixedTranslation5.frame_a.R.T[3,1];
//   fixedTranslation5.shape.R.T[3,2] = fixedTranslation5.frame_a.R.T[3,2];
//   fixedTranslation5.shape.R.T[3,3] = fixedTranslation5.frame_a.R.T[3,3];
//   fixedTranslation5.shape.R.w[1] = fixedTranslation5.frame_a.R.w[1];
//   fixedTranslation5.shape.R.w[2] = fixedTranslation5.frame_a.R.w[2];
//   fixedTranslation5.shape.R.w[3] = fixedTranslation5.frame_a.R.w[3];
//   fixedTranslation5.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(fixedTranslation5.shape.shapeType);
//   fixedTranslation5.shape.rxvisobj[1] = fixedTranslation5.shape.R.T[1,1] * fixedTranslation5.shape.e_x[1] + (fixedTranslation5.shape.R.T[2,1] * fixedTranslation5.shape.e_x[2] + fixedTranslation5.shape.R.T[3,1] * fixedTranslation5.shape.e_x[3]);
//   fixedTranslation5.shape.rxvisobj[2] = fixedTranslation5.shape.R.T[1,2] * fixedTranslation5.shape.e_x[1] + (fixedTranslation5.shape.R.T[2,2] * fixedTranslation5.shape.e_x[2] + fixedTranslation5.shape.R.T[3,2] * fixedTranslation5.shape.e_x[3]);
//   fixedTranslation5.shape.rxvisobj[3] = fixedTranslation5.shape.R.T[1,3] * fixedTranslation5.shape.e_x[1] + (fixedTranslation5.shape.R.T[2,3] * fixedTranslation5.shape.e_x[2] + fixedTranslation5.shape.R.T[3,3] * fixedTranslation5.shape.e_x[3]);
//   fixedTranslation5.shape.ryvisobj[1] = fixedTranslation5.shape.R.T[1,1] * fixedTranslation5.shape.e_y[1] + (fixedTranslation5.shape.R.T[2,1] * fixedTranslation5.shape.e_y[2] + fixedTranslation5.shape.R.T[3,1] * fixedTranslation5.shape.e_y[3]);
//   fixedTranslation5.shape.ryvisobj[2] = fixedTranslation5.shape.R.T[1,2] * fixedTranslation5.shape.e_y[1] + (fixedTranslation5.shape.R.T[2,2] * fixedTranslation5.shape.e_y[2] + fixedTranslation5.shape.R.T[3,2] * fixedTranslation5.shape.e_y[3]);
//   fixedTranslation5.shape.ryvisobj[3] = fixedTranslation5.shape.R.T[1,3] * fixedTranslation5.shape.e_y[1] + (fixedTranslation5.shape.R.T[2,3] * fixedTranslation5.shape.e_y[2] + fixedTranslation5.shape.R.T[3,3] * fixedTranslation5.shape.e_y[3]);
//   fixedTranslation5.shape.rvisobj = fixedTranslation5.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{fixedTranslation5.shape.R.T[1,1],fixedTranslation5.shape.R.T[1,2],fixedTranslation5.shape.R.T[1,3]},{fixedTranslation5.shape.R.T[2,1],fixedTranslation5.shape.R.T[2,2],fixedTranslation5.shape.R.T[2,3]},{fixedTranslation5.shape.R.T[3,1],fixedTranslation5.shape.R.T[3,2],fixedTranslation5.shape.R.T[3,3]}},{fixedTranslation5.shape.r_shape[1],fixedTranslation5.shape.r_shape[2],fixedTranslation5.shape.r_shape[3]});
//   fixedTranslation5.shape.size[1] = fixedTranslation5.shape.length;
//   fixedTranslation5.shape.size[2] = fixedTranslation5.shape.width;
//   fixedTranslation5.shape.size[3] = fixedTranslation5.shape.height;
//   fixedTranslation5.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(fixedTranslation5.shape.color[1] / 255.0,fixedTranslation5.shape.color[2] / 255.0,fixedTranslation5.shape.color[3] / 255.0,fixedTranslation5.shape.specularCoefficient);
//   fixedTranslation5.shape.Extra = fixedTranslation5.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   fixedTranslation5.frame_b.r_0 = fixedTranslation5.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(fixedTranslation5.frame_a.R,{fixedTranslation5.r[1],fixedTranslation5.r[2],fixedTranslation5.r[3]});
//   fixedTranslation5.frame_b.R.T[1,1] = fixedTranslation5.frame_a.R.T[1,1];
//   fixedTranslation5.frame_b.R.T[1,2] = fixedTranslation5.frame_a.R.T[1,2];
//   fixedTranslation5.frame_b.R.T[1,3] = fixedTranslation5.frame_a.R.T[1,3];
//   fixedTranslation5.frame_b.R.T[2,1] = fixedTranslation5.frame_a.R.T[2,1];
//   fixedTranslation5.frame_b.R.T[2,2] = fixedTranslation5.frame_a.R.T[2,2];
//   fixedTranslation5.frame_b.R.T[2,3] = fixedTranslation5.frame_a.R.T[2,3];
//   fixedTranslation5.frame_b.R.T[3,1] = fixedTranslation5.frame_a.R.T[3,1];
//   fixedTranslation5.frame_b.R.T[3,2] = fixedTranslation5.frame_a.R.T[3,2];
//   fixedTranslation5.frame_b.R.T[3,3] = fixedTranslation5.frame_a.R.T[3,3];
//   fixedTranslation5.frame_b.R.w[1] = fixedTranslation5.frame_a.R.w[1];
//   fixedTranslation5.frame_b.R.w[2] = fixedTranslation5.frame_a.R.w[2];
//   fixedTranslation5.frame_b.R.w[3] = fixedTranslation5.frame_a.R.w[3];
//   0.0 = fixedTranslation5.frame_a.f[1] + fixedTranslation5.frame_b.f[1];
//   0.0 = fixedTranslation5.frame_a.f[2] + fixedTranslation5.frame_b.f[2];
//   0.0 = fixedTranslation5.frame_a.f[3] + fixedTranslation5.frame_b.f[3];
//   0.0 = fixedTranslation5.frame_a.t[1] + (fixedTranslation5.frame_b.t[1] + (fixedTranslation5.r[2] * fixedTranslation5.frame_b.f[3] + (-fixedTranslation5.r[3] * fixedTranslation5.frame_b.f[2])));
//   0.0 = fixedTranslation5.frame_a.t[2] + (fixedTranslation5.frame_b.t[2] + (fixedTranslation5.r[3] * fixedTranslation5.frame_b.f[1] + (-fixedTranslation5.r[1] * fixedTranslation5.frame_b.f[3])));
//   0.0 = fixedTranslation5.frame_a.t[3] + (fixedTranslation5.frame_b.t[3] + (fixedTranslation5.r[1] * fixedTranslation5.frame_b.f[2] + (-fixedTranslation5.r[2] * fixedTranslation5.frame_b.f[1])));
//   freeMotion.arrow.R.T[1,1] = freeMotion.frame_a.R.T[1,1];
//   freeMotion.arrow.R.T[1,2] = freeMotion.frame_a.R.T[1,2];
//   freeMotion.arrow.R.T[1,3] = freeMotion.frame_a.R.T[1,3];
//   freeMotion.arrow.R.T[2,1] = freeMotion.frame_a.R.T[2,1];
//   freeMotion.arrow.R.T[2,2] = freeMotion.frame_a.R.T[2,2];
//   freeMotion.arrow.R.T[2,3] = freeMotion.frame_a.R.T[2,3];
//   freeMotion.arrow.R.T[3,1] = freeMotion.frame_a.R.T[3,1];
//   freeMotion.arrow.R.T[3,2] = freeMotion.frame_a.R.T[3,2];
//   freeMotion.arrow.R.T[3,3] = freeMotion.frame_a.R.T[3,3];
//   freeMotion.arrow.R.w[1] = freeMotion.frame_a.R.w[1];
//   freeMotion.arrow.R.w[2] = freeMotion.frame_a.R.w[2];
//   freeMotion.arrow.R.w[3] = freeMotion.frame_a.R.w[3];
//   freeMotion.arrow.arrowLine.R.T[1,1] = freeMotion.arrow.R.T[1,1];
//   freeMotion.arrow.arrowLine.R.T[1,2] = freeMotion.arrow.R.T[1,2];
//   freeMotion.arrow.arrowLine.R.T[1,3] = freeMotion.arrow.R.T[1,3];
//   freeMotion.arrow.arrowLine.R.T[2,1] = freeMotion.arrow.R.T[2,1];
//   freeMotion.arrow.arrowLine.R.T[2,2] = freeMotion.arrow.R.T[2,2];
//   freeMotion.arrow.arrowLine.R.T[2,3] = freeMotion.arrow.R.T[2,3];
//   freeMotion.arrow.arrowLine.R.T[3,1] = freeMotion.arrow.R.T[3,1];
//   freeMotion.arrow.arrowLine.R.T[3,2] = freeMotion.arrow.R.T[3,2];
//   freeMotion.arrow.arrowLine.R.T[3,3] = freeMotion.arrow.R.T[3,3];
//   freeMotion.arrow.arrowLine.R.w[1] = freeMotion.arrow.R.w[1];
//   freeMotion.arrow.arrowLine.R.w[2] = freeMotion.arrow.R.w[2];
//   freeMotion.arrow.arrowLine.R.w[3] = freeMotion.arrow.R.w[3];
//   freeMotion.arrow.arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(freeMotion.arrow.arrowLine.shapeType);
//   freeMotion.arrow.arrowLine.rxvisobj[1] = freeMotion.arrow.arrowLine.R.T[1,1] * freeMotion.arrow.arrowLine.e_x[1] + (freeMotion.arrow.arrowLine.R.T[2,1] * freeMotion.arrow.arrowLine.e_x[2] + freeMotion.arrow.arrowLine.R.T[3,1] * freeMotion.arrow.arrowLine.e_x[3]);
//   freeMotion.arrow.arrowLine.rxvisobj[2] = freeMotion.arrow.arrowLine.R.T[1,2] * freeMotion.arrow.arrowLine.e_x[1] + (freeMotion.arrow.arrowLine.R.T[2,2] * freeMotion.arrow.arrowLine.e_x[2] + freeMotion.arrow.arrowLine.R.T[3,2] * freeMotion.arrow.arrowLine.e_x[3]);
//   freeMotion.arrow.arrowLine.rxvisobj[3] = freeMotion.arrow.arrowLine.R.T[1,3] * freeMotion.arrow.arrowLine.e_x[1] + (freeMotion.arrow.arrowLine.R.T[2,3] * freeMotion.arrow.arrowLine.e_x[2] + freeMotion.arrow.arrowLine.R.T[3,3] * freeMotion.arrow.arrowLine.e_x[3]);
//   freeMotion.arrow.arrowLine.ryvisobj[1] = freeMotion.arrow.arrowLine.R.T[1,1] * freeMotion.arrow.arrowLine.e_y[1] + (freeMotion.arrow.arrowLine.R.T[2,1] * freeMotion.arrow.arrowLine.e_y[2] + freeMotion.arrow.arrowLine.R.T[3,1] * freeMotion.arrow.arrowLine.e_y[3]);
//   freeMotion.arrow.arrowLine.ryvisobj[2] = freeMotion.arrow.arrowLine.R.T[1,2] * freeMotion.arrow.arrowLine.e_y[1] + (freeMotion.arrow.arrowLine.R.T[2,2] * freeMotion.arrow.arrowLine.e_y[2] + freeMotion.arrow.arrowLine.R.T[3,2] * freeMotion.arrow.arrowLine.e_y[3]);
//   freeMotion.arrow.arrowLine.ryvisobj[3] = freeMotion.arrow.arrowLine.R.T[1,3] * freeMotion.arrow.arrowLine.e_y[1] + (freeMotion.arrow.arrowLine.R.T[2,3] * freeMotion.arrow.arrowLine.e_y[2] + freeMotion.arrow.arrowLine.R.T[3,3] * freeMotion.arrow.arrowLine.e_y[3]);
//   freeMotion.arrow.arrowLine.rvisobj = freeMotion.arrow.arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{freeMotion.arrow.arrowLine.R.T[1,1],freeMotion.arrow.arrowLine.R.T[1,2],freeMotion.arrow.arrowLine.R.T[1,3]},{freeMotion.arrow.arrowLine.R.T[2,1],freeMotion.arrow.arrowLine.R.T[2,2],freeMotion.arrow.arrowLine.R.T[2,3]},{freeMotion.arrow.arrowLine.R.T[3,1],freeMotion.arrow.arrowLine.R.T[3,2],freeMotion.arrow.arrowLine.R.T[3,3]}},{freeMotion.arrow.arrowLine.r_shape[1],freeMotion.arrow.arrowLine.r_shape[2],freeMotion.arrow.arrowLine.r_shape[3]});
//   freeMotion.arrow.arrowLine.size[1] = freeMotion.arrow.arrowLine.length;
//   freeMotion.arrow.arrowLine.size[2] = freeMotion.arrow.arrowLine.width;
//   freeMotion.arrow.arrowLine.size[3] = freeMotion.arrow.arrowLine.height;
//   freeMotion.arrow.arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(freeMotion.arrow.arrowLine.color[1] / 255.0,freeMotion.arrow.arrowLine.color[2] / 255.0,freeMotion.arrow.arrowLine.color[3] / 255.0,freeMotion.arrow.arrowLine.specularCoefficient);
//   freeMotion.arrow.arrowLine.Extra = freeMotion.arrow.arrowLine.extra;
//   freeMotion.arrow.arrowHead.R.T[1,1] = freeMotion.arrow.R.T[1,1];
//   freeMotion.arrow.arrowHead.R.T[1,2] = freeMotion.arrow.R.T[1,2];
//   freeMotion.arrow.arrowHead.R.T[1,3] = freeMotion.arrow.R.T[1,3];
//   freeMotion.arrow.arrowHead.R.T[2,1] = freeMotion.arrow.R.T[2,1];
//   freeMotion.arrow.arrowHead.R.T[2,2] = freeMotion.arrow.R.T[2,2];
//   freeMotion.arrow.arrowHead.R.T[2,3] = freeMotion.arrow.R.T[2,3];
//   freeMotion.arrow.arrowHead.R.T[3,1] = freeMotion.arrow.R.T[3,1];
//   freeMotion.arrow.arrowHead.R.T[3,2] = freeMotion.arrow.R.T[3,2];
//   freeMotion.arrow.arrowHead.R.T[3,3] = freeMotion.arrow.R.T[3,3];
//   freeMotion.arrow.arrowHead.R.w[1] = freeMotion.arrow.R.w[1];
//   freeMotion.arrow.arrowHead.R.w[2] = freeMotion.arrow.R.w[2];
//   freeMotion.arrow.arrowHead.R.w[3] = freeMotion.arrow.R.w[3];
//   freeMotion.arrow.arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(freeMotion.arrow.arrowHead.shapeType);
//   freeMotion.arrow.arrowHead.rxvisobj[1] = freeMotion.arrow.arrowHead.R.T[1,1] * freeMotion.arrow.arrowHead.e_x[1] + (freeMotion.arrow.arrowHead.R.T[2,1] * freeMotion.arrow.arrowHead.e_x[2] + freeMotion.arrow.arrowHead.R.T[3,1] * freeMotion.arrow.arrowHead.e_x[3]);
//   freeMotion.arrow.arrowHead.rxvisobj[2] = freeMotion.arrow.arrowHead.R.T[1,2] * freeMotion.arrow.arrowHead.e_x[1] + (freeMotion.arrow.arrowHead.R.T[2,2] * freeMotion.arrow.arrowHead.e_x[2] + freeMotion.arrow.arrowHead.R.T[3,2] * freeMotion.arrow.arrowHead.e_x[3]);
//   freeMotion.arrow.arrowHead.rxvisobj[3] = freeMotion.arrow.arrowHead.R.T[1,3] * freeMotion.arrow.arrowHead.e_x[1] + (freeMotion.arrow.arrowHead.R.T[2,3] * freeMotion.arrow.arrowHead.e_x[2] + freeMotion.arrow.arrowHead.R.T[3,3] * freeMotion.arrow.arrowHead.e_x[3]);
//   freeMotion.arrow.arrowHead.ryvisobj[1] = freeMotion.arrow.arrowHead.R.T[1,1] * freeMotion.arrow.arrowHead.e_y[1] + (freeMotion.arrow.arrowHead.R.T[2,1] * freeMotion.arrow.arrowHead.e_y[2] + freeMotion.arrow.arrowHead.R.T[3,1] * freeMotion.arrow.arrowHead.e_y[3]);
//   freeMotion.arrow.arrowHead.ryvisobj[2] = freeMotion.arrow.arrowHead.R.T[1,2] * freeMotion.arrow.arrowHead.e_y[1] + (freeMotion.arrow.arrowHead.R.T[2,2] * freeMotion.arrow.arrowHead.e_y[2] + freeMotion.arrow.arrowHead.R.T[3,2] * freeMotion.arrow.arrowHead.e_y[3]);
//   freeMotion.arrow.arrowHead.ryvisobj[3] = freeMotion.arrow.arrowHead.R.T[1,3] * freeMotion.arrow.arrowHead.e_y[1] + (freeMotion.arrow.arrowHead.R.T[2,3] * freeMotion.arrow.arrowHead.e_y[2] + freeMotion.arrow.arrowHead.R.T[3,3] * freeMotion.arrow.arrowHead.e_y[3]);
//   freeMotion.arrow.arrowHead.rvisobj = freeMotion.arrow.arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{freeMotion.arrow.arrowHead.R.T[1,1],freeMotion.arrow.arrowHead.R.T[1,2],freeMotion.arrow.arrowHead.R.T[1,3]},{freeMotion.arrow.arrowHead.R.T[2,1],freeMotion.arrow.arrowHead.R.T[2,2],freeMotion.arrow.arrowHead.R.T[2,3]},{freeMotion.arrow.arrowHead.R.T[3,1],freeMotion.arrow.arrowHead.R.T[3,2],freeMotion.arrow.arrowHead.R.T[3,3]}},{freeMotion.arrow.arrowHead.r_shape[1],freeMotion.arrow.arrowHead.r_shape[2],freeMotion.arrow.arrowHead.r_shape[3]});
//   freeMotion.arrow.arrowHead.size[1] = freeMotion.arrow.arrowHead.length;
//   freeMotion.arrow.arrowHead.size[2] = freeMotion.arrow.arrowHead.width;
//   freeMotion.arrow.arrowHead.size[3] = freeMotion.arrow.arrowHead.height;
//   freeMotion.arrow.arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(freeMotion.arrow.arrowHead.color[1] / 255.0,freeMotion.arrow.arrowHead.color[2] / 255.0,freeMotion.arrow.arrowHead.color[3] / 255.0,freeMotion.arrow.arrowHead.specularCoefficient);
//   freeMotion.arrow.arrowHead.Extra = freeMotion.arrow.arrowHead.extra;
//   der(freeMotion.r_rel_a[1]) = freeMotion.v_rel_a[1];
//   der(freeMotion.r_rel_a[2]) = freeMotion.v_rel_a[2];
//   der(freeMotion.r_rel_a[3]) = freeMotion.v_rel_a[3];
//   der(freeMotion.v_rel_a[1]) = freeMotion.a_rel_a[1];
//   der(freeMotion.v_rel_a[2]) = freeMotion.a_rel_a[2];
//   der(freeMotion.v_rel_a[3]) = freeMotion.a_rel_a[3];
//   freeMotion.frame_b.r_0 = freeMotion.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(freeMotion.frame_a.R,{freeMotion.r_rel_a[1],freeMotion.r_rel_a[2],freeMotion.r_rel_a[3]});
//   freeMotion.frame_a.f[1] = 0.0;
//   freeMotion.frame_a.f[2] = 0.0;
//   freeMotion.frame_a.f[3] = 0.0;
//   freeMotion.frame_a.t[1] = 0.0;
//   freeMotion.frame_a.t[2] = 0.0;
//   freeMotion.frame_a.t[3] = 0.0;
//   freeMotion.frame_b.f[1] = 0.0;
//   freeMotion.frame_b.f[2] = 0.0;
//   freeMotion.frame_b.f[3] = 0.0;
//   freeMotion.frame_b.t[1] = 0.0;
//   freeMotion.frame_b.t[2] = 0.0;
//   freeMotion.frame_b.t[3] = 0.0;
//   freeMotion.R_rel_inv.w[3] = 0.0;
//   freeMotion.R_rel_inv.w[2] = 0.0;
//   freeMotion.R_rel_inv.w[1] = 0.0;
//   freeMotion.R_rel_inv.T[3,3] = 1.0;
//   freeMotion.R_rel_inv.T[3,2] = 0.0;
//   freeMotion.R_rel_inv.T[3,1] = 0.0;
//   freeMotion.R_rel_inv.T[2,3] = 0.0;
//   freeMotion.R_rel_inv.T[2,2] = 1.0;
//   freeMotion.R_rel_inv.T[2,1] = 0.0;
//   freeMotion.R_rel_inv.T[1,3] = 0.0;
//   freeMotion.R_rel_inv.T[1,2] = 0.0;
//   freeMotion.R_rel_inv.T[1,1] = 1.0;
//   freeMotion.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(freeMotion.frame_a.R,freeMotion.R_rel);
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({freeMotion.Q[1],freeMotion.Q[2],freeMotion.Q[3],freeMotion.Q[4]});
//   freeMotion.w_rel_b = Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({freeMotion.Q[1],freeMotion.Q[2],freeMotion.Q[3],freeMotion.Q[4]},{der(freeMotion.Q[1]),der(freeMotion.Q[2]),der(freeMotion.Q[3]),der(freeMotion.Q[4])});
//   freeMotion.R_rel = Modelica.Mechanics.MultiBody.Frames.from_Q({freeMotion.Q[1],freeMotion.Q[2],freeMotion.Q[3],freeMotion.Q[4]},{freeMotion.w_rel_b[1],freeMotion.w_rel_b[2],freeMotion.w_rel_b[3]});
//   freeMotion.phi[1] = 0.0;
//   freeMotion.phi[2] = 0.0;
//   freeMotion.phi[3] = 0.0;
//   freeMotion.phi_d[1] = 0.0;
//   freeMotion.phi_d[2] = 0.0;
//   freeMotion.phi_d[3] = 0.0;
//   freeMotion.phi_dd[1] = 0.0;
//   freeMotion.phi_dd[2] = 0.0;
//   freeMotion.phi_dd[3] = 0.0;
//   assert(true,"Connector frame_a of component is not connected");
//   assert(true,"Connector frame_b of component is not connected");
//   referenceSystem.pointMass1.cylinder.R.T[1,1] = referenceSystem.pointMass1.frame_a.R.T[1,1];
//   referenceSystem.pointMass1.cylinder.R.T[1,2] = referenceSystem.pointMass1.frame_a.R.T[1,2];
//   referenceSystem.pointMass1.cylinder.R.T[1,3] = referenceSystem.pointMass1.frame_a.R.T[1,3];
//   referenceSystem.pointMass1.cylinder.R.T[2,1] = referenceSystem.pointMass1.frame_a.R.T[2,1];
//   referenceSystem.pointMass1.cylinder.R.T[2,2] = referenceSystem.pointMass1.frame_a.R.T[2,2];
//   referenceSystem.pointMass1.cylinder.R.T[2,3] = referenceSystem.pointMass1.frame_a.R.T[2,3];
//   referenceSystem.pointMass1.cylinder.R.T[3,1] = referenceSystem.pointMass1.frame_a.R.T[3,1];
//   referenceSystem.pointMass1.cylinder.R.T[3,2] = referenceSystem.pointMass1.frame_a.R.T[3,2];
//   referenceSystem.pointMass1.cylinder.R.T[3,3] = referenceSystem.pointMass1.frame_a.R.T[3,3];
//   referenceSystem.pointMass1.cylinder.R.w[1] = referenceSystem.pointMass1.frame_a.R.w[1];
//   referenceSystem.pointMass1.cylinder.R.w[2] = referenceSystem.pointMass1.frame_a.R.w[2];
//   referenceSystem.pointMass1.cylinder.R.w[3] = referenceSystem.pointMass1.frame_a.R.w[3];
//   referenceSystem.pointMass1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass1.cylinder.shapeType);
//   referenceSystem.pointMass1.cylinder.rxvisobj[1] = referenceSystem.pointMass1.cylinder.R.T[1,1] * referenceSystem.pointMass1.cylinder.e_x[1] + (referenceSystem.pointMass1.cylinder.R.T[2,1] * referenceSystem.pointMass1.cylinder.e_x[2] + referenceSystem.pointMass1.cylinder.R.T[3,1] * referenceSystem.pointMass1.cylinder.e_x[3]);
//   referenceSystem.pointMass1.cylinder.rxvisobj[2] = referenceSystem.pointMass1.cylinder.R.T[1,2] * referenceSystem.pointMass1.cylinder.e_x[1] + (referenceSystem.pointMass1.cylinder.R.T[2,2] * referenceSystem.pointMass1.cylinder.e_x[2] + referenceSystem.pointMass1.cylinder.R.T[3,2] * referenceSystem.pointMass1.cylinder.e_x[3]);
//   referenceSystem.pointMass1.cylinder.rxvisobj[3] = referenceSystem.pointMass1.cylinder.R.T[1,3] * referenceSystem.pointMass1.cylinder.e_x[1] + (referenceSystem.pointMass1.cylinder.R.T[2,3] * referenceSystem.pointMass1.cylinder.e_x[2] + referenceSystem.pointMass1.cylinder.R.T[3,3] * referenceSystem.pointMass1.cylinder.e_x[3]);
//   referenceSystem.pointMass1.cylinder.ryvisobj[1] = referenceSystem.pointMass1.cylinder.R.T[1,1] * referenceSystem.pointMass1.cylinder.e_y[1] + (referenceSystem.pointMass1.cylinder.R.T[2,1] * referenceSystem.pointMass1.cylinder.e_y[2] + referenceSystem.pointMass1.cylinder.R.T[3,1] * referenceSystem.pointMass1.cylinder.e_y[3]);
//   referenceSystem.pointMass1.cylinder.ryvisobj[2] = referenceSystem.pointMass1.cylinder.R.T[1,2] * referenceSystem.pointMass1.cylinder.e_y[1] + (referenceSystem.pointMass1.cylinder.R.T[2,2] * referenceSystem.pointMass1.cylinder.e_y[2] + referenceSystem.pointMass1.cylinder.R.T[3,2] * referenceSystem.pointMass1.cylinder.e_y[3]);
//   referenceSystem.pointMass1.cylinder.ryvisobj[3] = referenceSystem.pointMass1.cylinder.R.T[1,3] * referenceSystem.pointMass1.cylinder.e_y[1] + (referenceSystem.pointMass1.cylinder.R.T[2,3] * referenceSystem.pointMass1.cylinder.e_y[2] + referenceSystem.pointMass1.cylinder.R.T[3,3] * referenceSystem.pointMass1.cylinder.e_y[3]);
//   referenceSystem.pointMass1.cylinder.rvisobj = referenceSystem.pointMass1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass1.cylinder.R.T[1,1],referenceSystem.pointMass1.cylinder.R.T[1,2],referenceSystem.pointMass1.cylinder.R.T[1,3]},{referenceSystem.pointMass1.cylinder.R.T[2,1],referenceSystem.pointMass1.cylinder.R.T[2,2],referenceSystem.pointMass1.cylinder.R.T[2,3]},{referenceSystem.pointMass1.cylinder.R.T[3,1],referenceSystem.pointMass1.cylinder.R.T[3,2],referenceSystem.pointMass1.cylinder.R.T[3,3]}},{referenceSystem.pointMass1.cylinder.r_shape[1],referenceSystem.pointMass1.cylinder.r_shape[2],referenceSystem.pointMass1.cylinder.r_shape[3]});
//   referenceSystem.pointMass1.cylinder.size[1] = referenceSystem.pointMass1.cylinder.length;
//   referenceSystem.pointMass1.cylinder.size[2] = referenceSystem.pointMass1.cylinder.width;
//   referenceSystem.pointMass1.cylinder.size[3] = referenceSystem.pointMass1.cylinder.height;
//   referenceSystem.pointMass1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass1.cylinder.color[1] / 255.0,referenceSystem.pointMass1.cylinder.color[2] / 255.0,referenceSystem.pointMass1.cylinder.color[3] / 255.0,referenceSystem.pointMass1.cylinder.specularCoefficient);
//   referenceSystem.pointMass1.cylinder.Extra = referenceSystem.pointMass1.cylinder.extra;
//   referenceSystem.pointMass1.sphere.R.T[1,1] = referenceSystem.pointMass1.frame_a.R.T[1,1];
//   referenceSystem.pointMass1.sphere.R.T[1,2] = referenceSystem.pointMass1.frame_a.R.T[1,2];
//   referenceSystem.pointMass1.sphere.R.T[1,3] = referenceSystem.pointMass1.frame_a.R.T[1,3];
//   referenceSystem.pointMass1.sphere.R.T[2,1] = referenceSystem.pointMass1.frame_a.R.T[2,1];
//   referenceSystem.pointMass1.sphere.R.T[2,2] = referenceSystem.pointMass1.frame_a.R.T[2,2];
//   referenceSystem.pointMass1.sphere.R.T[2,3] = referenceSystem.pointMass1.frame_a.R.T[2,3];
//   referenceSystem.pointMass1.sphere.R.T[3,1] = referenceSystem.pointMass1.frame_a.R.T[3,1];
//   referenceSystem.pointMass1.sphere.R.T[3,2] = referenceSystem.pointMass1.frame_a.R.T[3,2];
//   referenceSystem.pointMass1.sphere.R.T[3,3] = referenceSystem.pointMass1.frame_a.R.T[3,3];
//   referenceSystem.pointMass1.sphere.R.w[1] = referenceSystem.pointMass1.frame_a.R.w[1];
//   referenceSystem.pointMass1.sphere.R.w[2] = referenceSystem.pointMass1.frame_a.R.w[2];
//   referenceSystem.pointMass1.sphere.R.w[3] = referenceSystem.pointMass1.frame_a.R.w[3];
//   referenceSystem.pointMass1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass1.sphere.shapeType);
//   referenceSystem.pointMass1.sphere.rxvisobj[1] = referenceSystem.pointMass1.sphere.R.T[1,1] * referenceSystem.pointMass1.sphere.e_x[1] + (referenceSystem.pointMass1.sphere.R.T[2,1] * referenceSystem.pointMass1.sphere.e_x[2] + referenceSystem.pointMass1.sphere.R.T[3,1] * referenceSystem.pointMass1.sphere.e_x[3]);
//   referenceSystem.pointMass1.sphere.rxvisobj[2] = referenceSystem.pointMass1.sphere.R.T[1,2] * referenceSystem.pointMass1.sphere.e_x[1] + (referenceSystem.pointMass1.sphere.R.T[2,2] * referenceSystem.pointMass1.sphere.e_x[2] + referenceSystem.pointMass1.sphere.R.T[3,2] * referenceSystem.pointMass1.sphere.e_x[3]);
//   referenceSystem.pointMass1.sphere.rxvisobj[3] = referenceSystem.pointMass1.sphere.R.T[1,3] * referenceSystem.pointMass1.sphere.e_x[1] + (referenceSystem.pointMass1.sphere.R.T[2,3] * referenceSystem.pointMass1.sphere.e_x[2] + referenceSystem.pointMass1.sphere.R.T[3,3] * referenceSystem.pointMass1.sphere.e_x[3]);
//   referenceSystem.pointMass1.sphere.ryvisobj[1] = referenceSystem.pointMass1.sphere.R.T[1,1] * referenceSystem.pointMass1.sphere.e_y[1] + (referenceSystem.pointMass1.sphere.R.T[2,1] * referenceSystem.pointMass1.sphere.e_y[2] + referenceSystem.pointMass1.sphere.R.T[3,1] * referenceSystem.pointMass1.sphere.e_y[3]);
//   referenceSystem.pointMass1.sphere.ryvisobj[2] = referenceSystem.pointMass1.sphere.R.T[1,2] * referenceSystem.pointMass1.sphere.e_y[1] + (referenceSystem.pointMass1.sphere.R.T[2,2] * referenceSystem.pointMass1.sphere.e_y[2] + referenceSystem.pointMass1.sphere.R.T[3,2] * referenceSystem.pointMass1.sphere.e_y[3]);
//   referenceSystem.pointMass1.sphere.ryvisobj[3] = referenceSystem.pointMass1.sphere.R.T[1,3] * referenceSystem.pointMass1.sphere.e_y[1] + (referenceSystem.pointMass1.sphere.R.T[2,3] * referenceSystem.pointMass1.sphere.e_y[2] + referenceSystem.pointMass1.sphere.R.T[3,3] * referenceSystem.pointMass1.sphere.e_y[3]);
//   referenceSystem.pointMass1.sphere.rvisobj = referenceSystem.pointMass1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass1.sphere.R.T[1,1],referenceSystem.pointMass1.sphere.R.T[1,2],referenceSystem.pointMass1.sphere.R.T[1,3]},{referenceSystem.pointMass1.sphere.R.T[2,1],referenceSystem.pointMass1.sphere.R.T[2,2],referenceSystem.pointMass1.sphere.R.T[2,3]},{referenceSystem.pointMass1.sphere.R.T[3,1],referenceSystem.pointMass1.sphere.R.T[3,2],referenceSystem.pointMass1.sphere.R.T[3,3]}},{referenceSystem.pointMass1.sphere.r_shape[1],referenceSystem.pointMass1.sphere.r_shape[2],referenceSystem.pointMass1.sphere.r_shape[3]});
//   referenceSystem.pointMass1.sphere.size[1] = referenceSystem.pointMass1.sphere.length;
//   referenceSystem.pointMass1.sphere.size[2] = referenceSystem.pointMass1.sphere.width;
//   referenceSystem.pointMass1.sphere.size[3] = referenceSystem.pointMass1.sphere.height;
//   referenceSystem.pointMass1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass1.sphere.color[1] / 255.0,referenceSystem.pointMass1.sphere.color[2] / 255.0,referenceSystem.pointMass1.sphere.color[3] / 255.0,referenceSystem.pointMass1.sphere.specularCoefficient);
//   referenceSystem.pointMass1.sphere.Extra = referenceSystem.pointMass1.sphere.extra;
//   referenceSystem.pointMass1.r_0[1] = referenceSystem.pointMass1.frame_a.r_0[1];
//   referenceSystem.pointMass1.r_0[2] = referenceSystem.pointMass1.frame_a.r_0[2];
//   referenceSystem.pointMass1.r_0[3] = referenceSystem.pointMass1.frame_a.r_0[3];
//   if false then
//   referenceSystem.pointMass1.Q[1] = 0.0;
//   referenceSystem.pointMass1.Q[2] = 0.0;
//   referenceSystem.pointMass1.Q[3] = 0.0;
//   referenceSystem.pointMass1.Q[4] = 1.0;
//   referenceSystem.pointMass1.phi[1] = 0.0;
//   referenceSystem.pointMass1.phi[2] = 0.0;
//   referenceSystem.pointMass1.phi[3] = 0.0;
//   referenceSystem.pointMass1.phi_d[1] = 0.0;
//   referenceSystem.pointMass1.phi_d[2] = 0.0;
//   referenceSystem.pointMass1.phi_d[3] = 0.0;
//   referenceSystem.pointMass1.phi_dd[1] = 0.0;
//   referenceSystem.pointMass1.phi_dd[2] = 0.0;
//   referenceSystem.pointMass1.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass1.useQuaternions then
//   referenceSystem.pointMass1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass1.Q[1],referenceSystem.pointMass1.Q[2],referenceSystem.pointMass1.Q[3],referenceSystem.pointMass1.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass1.Q[1],referenceSystem.pointMass1.Q[2],referenceSystem.pointMass1.Q[3],referenceSystem.pointMass1.Q[4]},{der(referenceSystem.pointMass1.Q[1]),der(referenceSystem.pointMass1.Q[2]),der(referenceSystem.pointMass1.Q[3]),der(referenceSystem.pointMass1.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass1.Q[1],referenceSystem.pointMass1.Q[2],referenceSystem.pointMass1.Q[3],referenceSystem.pointMass1.Q[4]});
//   referenceSystem.pointMass1.phi[1] = 0.0;
//   referenceSystem.pointMass1.phi[2] = 0.0;
//   referenceSystem.pointMass1.phi[3] = 0.0;
//   referenceSystem.pointMass1.phi_d[1] = 0.0;
//   referenceSystem.pointMass1.phi_d[2] = 0.0;
//   referenceSystem.pointMass1.phi_d[3] = 0.0;
//   referenceSystem.pointMass1.phi_dd[1] = 0.0;
//   referenceSystem.pointMass1.phi_dd[2] = 0.0;
//   referenceSystem.pointMass1.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass1.phi_d[1] = der(referenceSystem.pointMass1.phi[1]);
//   referenceSystem.pointMass1.phi_d[2] = der(referenceSystem.pointMass1.phi[2]);
//   referenceSystem.pointMass1.phi_d[3] = der(referenceSystem.pointMass1.phi[3]);
//   referenceSystem.pointMass1.phi_dd[1] = der(referenceSystem.pointMass1.phi_d[1]);
//   referenceSystem.pointMass1.phi_dd[2] = der(referenceSystem.pointMass1.phi_d[2]);
//   referenceSystem.pointMass1.phi_dd[3] = der(referenceSystem.pointMass1.phi_d[3]);
//   referenceSystem.pointMass1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass1.sequence_angleStates[1],referenceSystem.pointMass1.sequence_angleStates[2],referenceSystem.pointMass1.sequence_angleStates[3]},{referenceSystem.pointMass1.phi[1],referenceSystem.pointMass1.phi[2],referenceSystem.pointMass1.phi[3]},{referenceSystem.pointMass1.phi_d[1],referenceSystem.pointMass1.phi_d[2],referenceSystem.pointMass1.phi_d[3]});
//   referenceSystem.pointMass1.Q[1] = 0.0;
//   referenceSystem.pointMass1.Q[2] = 0.0;
//   referenceSystem.pointMass1.Q[3] = 0.0;
//   referenceSystem.pointMass1.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass1.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass1.frame_a.r_0[1],referenceSystem.pointMass1.frame_a.r_0[2],referenceSystem.pointMass1.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass1.frame_a.R,{referenceSystem.pointMass1.r_CM[1],referenceSystem.pointMass1.r_CM[2],referenceSystem.pointMass1.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass1.v_0[1] = der(referenceSystem.pointMass1.frame_a.r_0[1]);
//   referenceSystem.pointMass1.v_0[2] = der(referenceSystem.pointMass1.frame_a.r_0[2]);
//   referenceSystem.pointMass1.v_0[3] = der(referenceSystem.pointMass1.frame_a.r_0[3]);
//   referenceSystem.pointMass1.a_0[1] = der(referenceSystem.pointMass1.v_0[1]);
//   referenceSystem.pointMass1.a_0[2] = der(referenceSystem.pointMass1.v_0[2]);
//   referenceSystem.pointMass1.a_0[3] = der(referenceSystem.pointMass1.v_0[3]);
//   referenceSystem.pointMass1.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass1.frame_a.R);
//   referenceSystem.pointMass1.z_a[1] = der(referenceSystem.pointMass1.w_a[1]);
//   referenceSystem.pointMass1.z_a[2] = der(referenceSystem.pointMass1.w_a[2]);
//   referenceSystem.pointMass1.z_a[3] = der(referenceSystem.pointMass1.w_a[3]);
//   referenceSystem.pointMass1.frame_a.f = referenceSystem.pointMass1.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass1.frame_a.R,{referenceSystem.pointMass1.a_0[1] - referenceSystem.pointMass1.g_0[1],referenceSystem.pointMass1.a_0[2] - referenceSystem.pointMass1.g_0[2],referenceSystem.pointMass1.a_0[3] - referenceSystem.pointMass1.g_0[3]}) + {referenceSystem.pointMass1.z_a[2] * referenceSystem.pointMass1.r_CM[3] - referenceSystem.pointMass1.z_a[3] * referenceSystem.pointMass1.r_CM[2],referenceSystem.pointMass1.z_a[3] * referenceSystem.pointMass1.r_CM[1] - referenceSystem.pointMass1.z_a[1] * referenceSystem.pointMass1.r_CM[3],referenceSystem.pointMass1.z_a[1] * referenceSystem.pointMass1.r_CM[2] - referenceSystem.pointMass1.z_a[2] * referenceSystem.pointMass1.r_CM[1]} + {referenceSystem.pointMass1.w_a[2] * (referenceSystem.pointMass1.w_a[1] * referenceSystem.pointMass1.r_CM[2] - referenceSystem.pointMass1.w_a[2] * referenceSystem.pointMass1.r_CM[1]) - referenceSystem.pointMass1.w_a[3] * (referenceSystem.pointMass1.w_a[3] * referenceSystem.pointMass1.r_CM[1] - referenceSystem.pointMass1.w_a[1] * referenceSystem.pointMass1.r_CM[3]),referenceSystem.pointMass1.w_a[3] * (referenceSystem.pointMass1.w_a[2] * referenceSystem.pointMass1.r_CM[3] - referenceSystem.pointMass1.w_a[3] * referenceSystem.pointMass1.r_CM[2]) - referenceSystem.pointMass1.w_a[1] * (referenceSystem.pointMass1.w_a[1] * referenceSystem.pointMass1.r_CM[2] - referenceSystem.pointMass1.w_a[2] * referenceSystem.pointMass1.r_CM[1]),referenceSystem.pointMass1.w_a[1] * (referenceSystem.pointMass1.w_a[3] * referenceSystem.pointMass1.r_CM[1] - referenceSystem.pointMass1.w_a[1] * referenceSystem.pointMass1.r_CM[3]) - referenceSystem.pointMass1.w_a[2] * (referenceSystem.pointMass1.w_a[2] * referenceSystem.pointMass1.r_CM[3] - referenceSystem.pointMass1.w_a[3] * referenceSystem.pointMass1.r_CM[2])});
//   referenceSystem.pointMass1.frame_a.t[1] = referenceSystem.pointMass1.I[1,1] * referenceSystem.pointMass1.z_a[1] + (referenceSystem.pointMass1.I[1,2] * referenceSystem.pointMass1.z_a[2] + (referenceSystem.pointMass1.I[1,3] * referenceSystem.pointMass1.z_a[3] + (referenceSystem.pointMass1.w_a[2] * (referenceSystem.pointMass1.I[3,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[3,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[3,3] * referenceSystem.pointMass1.w_a[3])) + ((-referenceSystem.pointMass1.w_a[3] * (referenceSystem.pointMass1.I[2,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[2,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[2,3] * referenceSystem.pointMass1.w_a[3]))) + (referenceSystem.pointMass1.r_CM[2] * referenceSystem.pointMass1.frame_a.f[3] + (-referenceSystem.pointMass1.r_CM[3] * referenceSystem.pointMass1.frame_a.f[2]))))));
//   referenceSystem.pointMass1.frame_a.t[2] = referenceSystem.pointMass1.I[2,1] * referenceSystem.pointMass1.z_a[1] + (referenceSystem.pointMass1.I[2,2] * referenceSystem.pointMass1.z_a[2] + (referenceSystem.pointMass1.I[2,3] * referenceSystem.pointMass1.z_a[3] + (referenceSystem.pointMass1.w_a[3] * (referenceSystem.pointMass1.I[1,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[1,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[1,3] * referenceSystem.pointMass1.w_a[3])) + ((-referenceSystem.pointMass1.w_a[1] * (referenceSystem.pointMass1.I[3,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[3,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[3,3] * referenceSystem.pointMass1.w_a[3]))) + (referenceSystem.pointMass1.r_CM[3] * referenceSystem.pointMass1.frame_a.f[1] + (-referenceSystem.pointMass1.r_CM[1] * referenceSystem.pointMass1.frame_a.f[3]))))));
//   referenceSystem.pointMass1.frame_a.t[3] = referenceSystem.pointMass1.I[3,1] * referenceSystem.pointMass1.z_a[1] + (referenceSystem.pointMass1.I[3,2] * referenceSystem.pointMass1.z_a[2] + (referenceSystem.pointMass1.I[3,3] * referenceSystem.pointMass1.z_a[3] + (referenceSystem.pointMass1.w_a[1] * (referenceSystem.pointMass1.I[2,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[2,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[2,3] * referenceSystem.pointMass1.w_a[3])) + ((-referenceSystem.pointMass1.w_a[2] * (referenceSystem.pointMass1.I[1,1] * referenceSystem.pointMass1.w_a[1] + (referenceSystem.pointMass1.I[1,2] * referenceSystem.pointMass1.w_a[2] + referenceSystem.pointMass1.I[1,3] * referenceSystem.pointMass1.w_a[3]))) + (referenceSystem.pointMass1.r_CM[1] * referenceSystem.pointMass1.frame_a.f[2] + (-referenceSystem.pointMass1.r_CM[2] * referenceSystem.pointMass1.frame_a.f[1]))))));
//   referenceSystem.pointMass2.cylinder.R.T[1,1] = referenceSystem.pointMass2.frame_a.R.T[1,1];
//   referenceSystem.pointMass2.cylinder.R.T[1,2] = referenceSystem.pointMass2.frame_a.R.T[1,2];
//   referenceSystem.pointMass2.cylinder.R.T[1,3] = referenceSystem.pointMass2.frame_a.R.T[1,3];
//   referenceSystem.pointMass2.cylinder.R.T[2,1] = referenceSystem.pointMass2.frame_a.R.T[2,1];
//   referenceSystem.pointMass2.cylinder.R.T[2,2] = referenceSystem.pointMass2.frame_a.R.T[2,2];
//   referenceSystem.pointMass2.cylinder.R.T[2,3] = referenceSystem.pointMass2.frame_a.R.T[2,3];
//   referenceSystem.pointMass2.cylinder.R.T[3,1] = referenceSystem.pointMass2.frame_a.R.T[3,1];
//   referenceSystem.pointMass2.cylinder.R.T[3,2] = referenceSystem.pointMass2.frame_a.R.T[3,2];
//   referenceSystem.pointMass2.cylinder.R.T[3,3] = referenceSystem.pointMass2.frame_a.R.T[3,3];
//   referenceSystem.pointMass2.cylinder.R.w[1] = referenceSystem.pointMass2.frame_a.R.w[1];
//   referenceSystem.pointMass2.cylinder.R.w[2] = referenceSystem.pointMass2.frame_a.R.w[2];
//   referenceSystem.pointMass2.cylinder.R.w[3] = referenceSystem.pointMass2.frame_a.R.w[3];
//   referenceSystem.pointMass2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass2.cylinder.shapeType);
//   referenceSystem.pointMass2.cylinder.rxvisobj[1] = referenceSystem.pointMass2.cylinder.R.T[1,1] * referenceSystem.pointMass2.cylinder.e_x[1] + (referenceSystem.pointMass2.cylinder.R.T[2,1] * referenceSystem.pointMass2.cylinder.e_x[2] + referenceSystem.pointMass2.cylinder.R.T[3,1] * referenceSystem.pointMass2.cylinder.e_x[3]);
//   referenceSystem.pointMass2.cylinder.rxvisobj[2] = referenceSystem.pointMass2.cylinder.R.T[1,2] * referenceSystem.pointMass2.cylinder.e_x[1] + (referenceSystem.pointMass2.cylinder.R.T[2,2] * referenceSystem.pointMass2.cylinder.e_x[2] + referenceSystem.pointMass2.cylinder.R.T[3,2] * referenceSystem.pointMass2.cylinder.e_x[3]);
//   referenceSystem.pointMass2.cylinder.rxvisobj[3] = referenceSystem.pointMass2.cylinder.R.T[1,3] * referenceSystem.pointMass2.cylinder.e_x[1] + (referenceSystem.pointMass2.cylinder.R.T[2,3] * referenceSystem.pointMass2.cylinder.e_x[2] + referenceSystem.pointMass2.cylinder.R.T[3,3] * referenceSystem.pointMass2.cylinder.e_x[3]);
//   referenceSystem.pointMass2.cylinder.ryvisobj[1] = referenceSystem.pointMass2.cylinder.R.T[1,1] * referenceSystem.pointMass2.cylinder.e_y[1] + (referenceSystem.pointMass2.cylinder.R.T[2,1] * referenceSystem.pointMass2.cylinder.e_y[2] + referenceSystem.pointMass2.cylinder.R.T[3,1] * referenceSystem.pointMass2.cylinder.e_y[3]);
//   referenceSystem.pointMass2.cylinder.ryvisobj[2] = referenceSystem.pointMass2.cylinder.R.T[1,2] * referenceSystem.pointMass2.cylinder.e_y[1] + (referenceSystem.pointMass2.cylinder.R.T[2,2] * referenceSystem.pointMass2.cylinder.e_y[2] + referenceSystem.pointMass2.cylinder.R.T[3,2] * referenceSystem.pointMass2.cylinder.e_y[3]);
//   referenceSystem.pointMass2.cylinder.ryvisobj[3] = referenceSystem.pointMass2.cylinder.R.T[1,3] * referenceSystem.pointMass2.cylinder.e_y[1] + (referenceSystem.pointMass2.cylinder.R.T[2,3] * referenceSystem.pointMass2.cylinder.e_y[2] + referenceSystem.pointMass2.cylinder.R.T[3,3] * referenceSystem.pointMass2.cylinder.e_y[3]);
//   referenceSystem.pointMass2.cylinder.rvisobj = referenceSystem.pointMass2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass2.cylinder.R.T[1,1],referenceSystem.pointMass2.cylinder.R.T[1,2],referenceSystem.pointMass2.cylinder.R.T[1,3]},{referenceSystem.pointMass2.cylinder.R.T[2,1],referenceSystem.pointMass2.cylinder.R.T[2,2],referenceSystem.pointMass2.cylinder.R.T[2,3]},{referenceSystem.pointMass2.cylinder.R.T[3,1],referenceSystem.pointMass2.cylinder.R.T[3,2],referenceSystem.pointMass2.cylinder.R.T[3,3]}},{referenceSystem.pointMass2.cylinder.r_shape[1],referenceSystem.pointMass2.cylinder.r_shape[2],referenceSystem.pointMass2.cylinder.r_shape[3]});
//   referenceSystem.pointMass2.cylinder.size[1] = referenceSystem.pointMass2.cylinder.length;
//   referenceSystem.pointMass2.cylinder.size[2] = referenceSystem.pointMass2.cylinder.width;
//   referenceSystem.pointMass2.cylinder.size[3] = referenceSystem.pointMass2.cylinder.height;
//   referenceSystem.pointMass2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass2.cylinder.color[1] / 255.0,referenceSystem.pointMass2.cylinder.color[2] / 255.0,referenceSystem.pointMass2.cylinder.color[3] / 255.0,referenceSystem.pointMass2.cylinder.specularCoefficient);
//   referenceSystem.pointMass2.cylinder.Extra = referenceSystem.pointMass2.cylinder.extra;
//   referenceSystem.pointMass2.sphere.R.T[1,1] = referenceSystem.pointMass2.frame_a.R.T[1,1];
//   referenceSystem.pointMass2.sphere.R.T[1,2] = referenceSystem.pointMass2.frame_a.R.T[1,2];
//   referenceSystem.pointMass2.sphere.R.T[1,3] = referenceSystem.pointMass2.frame_a.R.T[1,3];
//   referenceSystem.pointMass2.sphere.R.T[2,1] = referenceSystem.pointMass2.frame_a.R.T[2,1];
//   referenceSystem.pointMass2.sphere.R.T[2,2] = referenceSystem.pointMass2.frame_a.R.T[2,2];
//   referenceSystem.pointMass2.sphere.R.T[2,3] = referenceSystem.pointMass2.frame_a.R.T[2,3];
//   referenceSystem.pointMass2.sphere.R.T[3,1] = referenceSystem.pointMass2.frame_a.R.T[3,1];
//   referenceSystem.pointMass2.sphere.R.T[3,2] = referenceSystem.pointMass2.frame_a.R.T[3,2];
//   referenceSystem.pointMass2.sphere.R.T[3,3] = referenceSystem.pointMass2.frame_a.R.T[3,3];
//   referenceSystem.pointMass2.sphere.R.w[1] = referenceSystem.pointMass2.frame_a.R.w[1];
//   referenceSystem.pointMass2.sphere.R.w[2] = referenceSystem.pointMass2.frame_a.R.w[2];
//   referenceSystem.pointMass2.sphere.R.w[3] = referenceSystem.pointMass2.frame_a.R.w[3];
//   referenceSystem.pointMass2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass2.sphere.shapeType);
//   referenceSystem.pointMass2.sphere.rxvisobj[1] = referenceSystem.pointMass2.sphere.R.T[1,1] * referenceSystem.pointMass2.sphere.e_x[1] + (referenceSystem.pointMass2.sphere.R.T[2,1] * referenceSystem.pointMass2.sphere.e_x[2] + referenceSystem.pointMass2.sphere.R.T[3,1] * referenceSystem.pointMass2.sphere.e_x[3]);
//   referenceSystem.pointMass2.sphere.rxvisobj[2] = referenceSystem.pointMass2.sphere.R.T[1,2] * referenceSystem.pointMass2.sphere.e_x[1] + (referenceSystem.pointMass2.sphere.R.T[2,2] * referenceSystem.pointMass2.sphere.e_x[2] + referenceSystem.pointMass2.sphere.R.T[3,2] * referenceSystem.pointMass2.sphere.e_x[3]);
//   referenceSystem.pointMass2.sphere.rxvisobj[3] = referenceSystem.pointMass2.sphere.R.T[1,3] * referenceSystem.pointMass2.sphere.e_x[1] + (referenceSystem.pointMass2.sphere.R.T[2,3] * referenceSystem.pointMass2.sphere.e_x[2] + referenceSystem.pointMass2.sphere.R.T[3,3] * referenceSystem.pointMass2.sphere.e_x[3]);
//   referenceSystem.pointMass2.sphere.ryvisobj[1] = referenceSystem.pointMass2.sphere.R.T[1,1] * referenceSystem.pointMass2.sphere.e_y[1] + (referenceSystem.pointMass2.sphere.R.T[2,1] * referenceSystem.pointMass2.sphere.e_y[2] + referenceSystem.pointMass2.sphere.R.T[3,1] * referenceSystem.pointMass2.sphere.e_y[3]);
//   referenceSystem.pointMass2.sphere.ryvisobj[2] = referenceSystem.pointMass2.sphere.R.T[1,2] * referenceSystem.pointMass2.sphere.e_y[1] + (referenceSystem.pointMass2.sphere.R.T[2,2] * referenceSystem.pointMass2.sphere.e_y[2] + referenceSystem.pointMass2.sphere.R.T[3,2] * referenceSystem.pointMass2.sphere.e_y[3]);
//   referenceSystem.pointMass2.sphere.ryvisobj[3] = referenceSystem.pointMass2.sphere.R.T[1,3] * referenceSystem.pointMass2.sphere.e_y[1] + (referenceSystem.pointMass2.sphere.R.T[2,3] * referenceSystem.pointMass2.sphere.e_y[2] + referenceSystem.pointMass2.sphere.R.T[3,3] * referenceSystem.pointMass2.sphere.e_y[3]);
//   referenceSystem.pointMass2.sphere.rvisobj = referenceSystem.pointMass2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass2.sphere.R.T[1,1],referenceSystem.pointMass2.sphere.R.T[1,2],referenceSystem.pointMass2.sphere.R.T[1,3]},{referenceSystem.pointMass2.sphere.R.T[2,1],referenceSystem.pointMass2.sphere.R.T[2,2],referenceSystem.pointMass2.sphere.R.T[2,3]},{referenceSystem.pointMass2.sphere.R.T[3,1],referenceSystem.pointMass2.sphere.R.T[3,2],referenceSystem.pointMass2.sphere.R.T[3,3]}},{referenceSystem.pointMass2.sphere.r_shape[1],referenceSystem.pointMass2.sphere.r_shape[2],referenceSystem.pointMass2.sphere.r_shape[3]});
//   referenceSystem.pointMass2.sphere.size[1] = referenceSystem.pointMass2.sphere.length;
//   referenceSystem.pointMass2.sphere.size[2] = referenceSystem.pointMass2.sphere.width;
//   referenceSystem.pointMass2.sphere.size[3] = referenceSystem.pointMass2.sphere.height;
//   referenceSystem.pointMass2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass2.sphere.color[1] / 255.0,referenceSystem.pointMass2.sphere.color[2] / 255.0,referenceSystem.pointMass2.sphere.color[3] / 255.0,referenceSystem.pointMass2.sphere.specularCoefficient);
//   referenceSystem.pointMass2.sphere.Extra = referenceSystem.pointMass2.sphere.extra;
//   referenceSystem.pointMass2.r_0[1] = referenceSystem.pointMass2.frame_a.r_0[1];
//   referenceSystem.pointMass2.r_0[2] = referenceSystem.pointMass2.frame_a.r_0[2];
//   referenceSystem.pointMass2.r_0[3] = referenceSystem.pointMass2.frame_a.r_0[3];
//   if true then
//   referenceSystem.pointMass2.Q[1] = 0.0;
//   referenceSystem.pointMass2.Q[2] = 0.0;
//   referenceSystem.pointMass2.Q[3] = 0.0;
//   referenceSystem.pointMass2.Q[4] = 1.0;
//   referenceSystem.pointMass2.phi[1] = 0.0;
//   referenceSystem.pointMass2.phi[2] = 0.0;
//   referenceSystem.pointMass2.phi[3] = 0.0;
//   referenceSystem.pointMass2.phi_d[1] = 0.0;
//   referenceSystem.pointMass2.phi_d[2] = 0.0;
//   referenceSystem.pointMass2.phi_d[3] = 0.0;
//   referenceSystem.pointMass2.phi_dd[1] = 0.0;
//   referenceSystem.pointMass2.phi_dd[2] = 0.0;
//   referenceSystem.pointMass2.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass2.useQuaternions then
//   referenceSystem.pointMass2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass2.Q[1],referenceSystem.pointMass2.Q[2],referenceSystem.pointMass2.Q[3],referenceSystem.pointMass2.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass2.Q[1],referenceSystem.pointMass2.Q[2],referenceSystem.pointMass2.Q[3],referenceSystem.pointMass2.Q[4]},{der(referenceSystem.pointMass2.Q[1]),der(referenceSystem.pointMass2.Q[2]),der(referenceSystem.pointMass2.Q[3]),der(referenceSystem.pointMass2.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass2.Q[1],referenceSystem.pointMass2.Q[2],referenceSystem.pointMass2.Q[3],referenceSystem.pointMass2.Q[4]});
//   referenceSystem.pointMass2.phi[1] = 0.0;
//   referenceSystem.pointMass2.phi[2] = 0.0;
//   referenceSystem.pointMass2.phi[3] = 0.0;
//   referenceSystem.pointMass2.phi_d[1] = 0.0;
//   referenceSystem.pointMass2.phi_d[2] = 0.0;
//   referenceSystem.pointMass2.phi_d[3] = 0.0;
//   referenceSystem.pointMass2.phi_dd[1] = 0.0;
//   referenceSystem.pointMass2.phi_dd[2] = 0.0;
//   referenceSystem.pointMass2.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass2.phi_d[1] = der(referenceSystem.pointMass2.phi[1]);
//   referenceSystem.pointMass2.phi_d[2] = der(referenceSystem.pointMass2.phi[2]);
//   referenceSystem.pointMass2.phi_d[3] = der(referenceSystem.pointMass2.phi[3]);
//   referenceSystem.pointMass2.phi_dd[1] = der(referenceSystem.pointMass2.phi_d[1]);
//   referenceSystem.pointMass2.phi_dd[2] = der(referenceSystem.pointMass2.phi_d[2]);
//   referenceSystem.pointMass2.phi_dd[3] = der(referenceSystem.pointMass2.phi_d[3]);
//   referenceSystem.pointMass2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass2.sequence_angleStates[1],referenceSystem.pointMass2.sequence_angleStates[2],referenceSystem.pointMass2.sequence_angleStates[3]},{referenceSystem.pointMass2.phi[1],referenceSystem.pointMass2.phi[2],referenceSystem.pointMass2.phi[3]},{referenceSystem.pointMass2.phi_d[1],referenceSystem.pointMass2.phi_d[2],referenceSystem.pointMass2.phi_d[3]});
//   referenceSystem.pointMass2.Q[1] = 0.0;
//   referenceSystem.pointMass2.Q[2] = 0.0;
//   referenceSystem.pointMass2.Q[3] = 0.0;
//   referenceSystem.pointMass2.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass2.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass2.frame_a.r_0[1],referenceSystem.pointMass2.frame_a.r_0[2],referenceSystem.pointMass2.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass2.frame_a.R,{referenceSystem.pointMass2.r_CM[1],referenceSystem.pointMass2.r_CM[2],referenceSystem.pointMass2.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass2.v_0[1] = der(referenceSystem.pointMass2.frame_a.r_0[1]);
//   referenceSystem.pointMass2.v_0[2] = der(referenceSystem.pointMass2.frame_a.r_0[2]);
//   referenceSystem.pointMass2.v_0[3] = der(referenceSystem.pointMass2.frame_a.r_0[3]);
//   referenceSystem.pointMass2.a_0[1] = der(referenceSystem.pointMass2.v_0[1]);
//   referenceSystem.pointMass2.a_0[2] = der(referenceSystem.pointMass2.v_0[2]);
//   referenceSystem.pointMass2.a_0[3] = der(referenceSystem.pointMass2.v_0[3]);
//   referenceSystem.pointMass2.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass2.frame_a.R);
//   referenceSystem.pointMass2.z_a[1] = der(referenceSystem.pointMass2.w_a[1]);
//   referenceSystem.pointMass2.z_a[2] = der(referenceSystem.pointMass2.w_a[2]);
//   referenceSystem.pointMass2.z_a[3] = der(referenceSystem.pointMass2.w_a[3]);
//   referenceSystem.pointMass2.frame_a.f = referenceSystem.pointMass2.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass2.frame_a.R,{referenceSystem.pointMass2.a_0[1] - referenceSystem.pointMass2.g_0[1],referenceSystem.pointMass2.a_0[2] - referenceSystem.pointMass2.g_0[2],referenceSystem.pointMass2.a_0[3] - referenceSystem.pointMass2.g_0[3]}) + {referenceSystem.pointMass2.z_a[2] * referenceSystem.pointMass2.r_CM[3] - referenceSystem.pointMass2.z_a[3] * referenceSystem.pointMass2.r_CM[2],referenceSystem.pointMass2.z_a[3] * referenceSystem.pointMass2.r_CM[1] - referenceSystem.pointMass2.z_a[1] * referenceSystem.pointMass2.r_CM[3],referenceSystem.pointMass2.z_a[1] * referenceSystem.pointMass2.r_CM[2] - referenceSystem.pointMass2.z_a[2] * referenceSystem.pointMass2.r_CM[1]} + {referenceSystem.pointMass2.w_a[2] * (referenceSystem.pointMass2.w_a[1] * referenceSystem.pointMass2.r_CM[2] - referenceSystem.pointMass2.w_a[2] * referenceSystem.pointMass2.r_CM[1]) - referenceSystem.pointMass2.w_a[3] * (referenceSystem.pointMass2.w_a[3] * referenceSystem.pointMass2.r_CM[1] - referenceSystem.pointMass2.w_a[1] * referenceSystem.pointMass2.r_CM[3]),referenceSystem.pointMass2.w_a[3] * (referenceSystem.pointMass2.w_a[2] * referenceSystem.pointMass2.r_CM[3] - referenceSystem.pointMass2.w_a[3] * referenceSystem.pointMass2.r_CM[2]) - referenceSystem.pointMass2.w_a[1] * (referenceSystem.pointMass2.w_a[1] * referenceSystem.pointMass2.r_CM[2] - referenceSystem.pointMass2.w_a[2] * referenceSystem.pointMass2.r_CM[1]),referenceSystem.pointMass2.w_a[1] * (referenceSystem.pointMass2.w_a[3] * referenceSystem.pointMass2.r_CM[1] - referenceSystem.pointMass2.w_a[1] * referenceSystem.pointMass2.r_CM[3]) - referenceSystem.pointMass2.w_a[2] * (referenceSystem.pointMass2.w_a[2] * referenceSystem.pointMass2.r_CM[3] - referenceSystem.pointMass2.w_a[3] * referenceSystem.pointMass2.r_CM[2])});
//   referenceSystem.pointMass2.frame_a.t[1] = referenceSystem.pointMass2.I[1,1] * referenceSystem.pointMass2.z_a[1] + (referenceSystem.pointMass2.I[1,2] * referenceSystem.pointMass2.z_a[2] + (referenceSystem.pointMass2.I[1,3] * referenceSystem.pointMass2.z_a[3] + (referenceSystem.pointMass2.w_a[2] * (referenceSystem.pointMass2.I[3,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[3,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[3,3] * referenceSystem.pointMass2.w_a[3])) + ((-referenceSystem.pointMass2.w_a[3] * (referenceSystem.pointMass2.I[2,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[2,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[2,3] * referenceSystem.pointMass2.w_a[3]))) + (referenceSystem.pointMass2.r_CM[2] * referenceSystem.pointMass2.frame_a.f[3] + (-referenceSystem.pointMass2.r_CM[3] * referenceSystem.pointMass2.frame_a.f[2]))))));
//   referenceSystem.pointMass2.frame_a.t[2] = referenceSystem.pointMass2.I[2,1] * referenceSystem.pointMass2.z_a[1] + (referenceSystem.pointMass2.I[2,2] * referenceSystem.pointMass2.z_a[2] + (referenceSystem.pointMass2.I[2,3] * referenceSystem.pointMass2.z_a[3] + (referenceSystem.pointMass2.w_a[3] * (referenceSystem.pointMass2.I[1,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[1,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[1,3] * referenceSystem.pointMass2.w_a[3])) + ((-referenceSystem.pointMass2.w_a[1] * (referenceSystem.pointMass2.I[3,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[3,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[3,3] * referenceSystem.pointMass2.w_a[3]))) + (referenceSystem.pointMass2.r_CM[3] * referenceSystem.pointMass2.frame_a.f[1] + (-referenceSystem.pointMass2.r_CM[1] * referenceSystem.pointMass2.frame_a.f[3]))))));
//   referenceSystem.pointMass2.frame_a.t[3] = referenceSystem.pointMass2.I[3,1] * referenceSystem.pointMass2.z_a[1] + (referenceSystem.pointMass2.I[3,2] * referenceSystem.pointMass2.z_a[2] + (referenceSystem.pointMass2.I[3,3] * referenceSystem.pointMass2.z_a[3] + (referenceSystem.pointMass2.w_a[1] * (referenceSystem.pointMass2.I[2,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[2,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[2,3] * referenceSystem.pointMass2.w_a[3])) + ((-referenceSystem.pointMass2.w_a[2] * (referenceSystem.pointMass2.I[1,1] * referenceSystem.pointMass2.w_a[1] + (referenceSystem.pointMass2.I[1,2] * referenceSystem.pointMass2.w_a[2] + referenceSystem.pointMass2.I[1,3] * referenceSystem.pointMass2.w_a[3]))) + (referenceSystem.pointMass2.r_CM[1] * referenceSystem.pointMass2.frame_a.f[2] + (-referenceSystem.pointMass2.r_CM[2] * referenceSystem.pointMass2.frame_a.f[1]))))));
//   referenceSystem.pointMass3.cylinder.R.T[1,1] = referenceSystem.pointMass3.frame_a.R.T[1,1];
//   referenceSystem.pointMass3.cylinder.R.T[1,2] = referenceSystem.pointMass3.frame_a.R.T[1,2];
//   referenceSystem.pointMass3.cylinder.R.T[1,3] = referenceSystem.pointMass3.frame_a.R.T[1,3];
//   referenceSystem.pointMass3.cylinder.R.T[2,1] = referenceSystem.pointMass3.frame_a.R.T[2,1];
//   referenceSystem.pointMass3.cylinder.R.T[2,2] = referenceSystem.pointMass3.frame_a.R.T[2,2];
//   referenceSystem.pointMass3.cylinder.R.T[2,3] = referenceSystem.pointMass3.frame_a.R.T[2,3];
//   referenceSystem.pointMass3.cylinder.R.T[3,1] = referenceSystem.pointMass3.frame_a.R.T[3,1];
//   referenceSystem.pointMass3.cylinder.R.T[3,2] = referenceSystem.pointMass3.frame_a.R.T[3,2];
//   referenceSystem.pointMass3.cylinder.R.T[3,3] = referenceSystem.pointMass3.frame_a.R.T[3,3];
//   referenceSystem.pointMass3.cylinder.R.w[1] = referenceSystem.pointMass3.frame_a.R.w[1];
//   referenceSystem.pointMass3.cylinder.R.w[2] = referenceSystem.pointMass3.frame_a.R.w[2];
//   referenceSystem.pointMass3.cylinder.R.w[3] = referenceSystem.pointMass3.frame_a.R.w[3];
//   referenceSystem.pointMass3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass3.cylinder.shapeType);
//   referenceSystem.pointMass3.cylinder.rxvisobj[1] = referenceSystem.pointMass3.cylinder.R.T[1,1] * referenceSystem.pointMass3.cylinder.e_x[1] + (referenceSystem.pointMass3.cylinder.R.T[2,1] * referenceSystem.pointMass3.cylinder.e_x[2] + referenceSystem.pointMass3.cylinder.R.T[3,1] * referenceSystem.pointMass3.cylinder.e_x[3]);
//   referenceSystem.pointMass3.cylinder.rxvisobj[2] = referenceSystem.pointMass3.cylinder.R.T[1,2] * referenceSystem.pointMass3.cylinder.e_x[1] + (referenceSystem.pointMass3.cylinder.R.T[2,2] * referenceSystem.pointMass3.cylinder.e_x[2] + referenceSystem.pointMass3.cylinder.R.T[3,2] * referenceSystem.pointMass3.cylinder.e_x[3]);
//   referenceSystem.pointMass3.cylinder.rxvisobj[3] = referenceSystem.pointMass3.cylinder.R.T[1,3] * referenceSystem.pointMass3.cylinder.e_x[1] + (referenceSystem.pointMass3.cylinder.R.T[2,3] * referenceSystem.pointMass3.cylinder.e_x[2] + referenceSystem.pointMass3.cylinder.R.T[3,3] * referenceSystem.pointMass3.cylinder.e_x[3]);
//   referenceSystem.pointMass3.cylinder.ryvisobj[1] = referenceSystem.pointMass3.cylinder.R.T[1,1] * referenceSystem.pointMass3.cylinder.e_y[1] + (referenceSystem.pointMass3.cylinder.R.T[2,1] * referenceSystem.pointMass3.cylinder.e_y[2] + referenceSystem.pointMass3.cylinder.R.T[3,1] * referenceSystem.pointMass3.cylinder.e_y[3]);
//   referenceSystem.pointMass3.cylinder.ryvisobj[2] = referenceSystem.pointMass3.cylinder.R.T[1,2] * referenceSystem.pointMass3.cylinder.e_y[1] + (referenceSystem.pointMass3.cylinder.R.T[2,2] * referenceSystem.pointMass3.cylinder.e_y[2] + referenceSystem.pointMass3.cylinder.R.T[3,2] * referenceSystem.pointMass3.cylinder.e_y[3]);
//   referenceSystem.pointMass3.cylinder.ryvisobj[3] = referenceSystem.pointMass3.cylinder.R.T[1,3] * referenceSystem.pointMass3.cylinder.e_y[1] + (referenceSystem.pointMass3.cylinder.R.T[2,3] * referenceSystem.pointMass3.cylinder.e_y[2] + referenceSystem.pointMass3.cylinder.R.T[3,3] * referenceSystem.pointMass3.cylinder.e_y[3]);
//   referenceSystem.pointMass3.cylinder.rvisobj = referenceSystem.pointMass3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass3.cylinder.R.T[1,1],referenceSystem.pointMass3.cylinder.R.T[1,2],referenceSystem.pointMass3.cylinder.R.T[1,3]},{referenceSystem.pointMass3.cylinder.R.T[2,1],referenceSystem.pointMass3.cylinder.R.T[2,2],referenceSystem.pointMass3.cylinder.R.T[2,3]},{referenceSystem.pointMass3.cylinder.R.T[3,1],referenceSystem.pointMass3.cylinder.R.T[3,2],referenceSystem.pointMass3.cylinder.R.T[3,3]}},{referenceSystem.pointMass3.cylinder.r_shape[1],referenceSystem.pointMass3.cylinder.r_shape[2],referenceSystem.pointMass3.cylinder.r_shape[3]});
//   referenceSystem.pointMass3.cylinder.size[1] = referenceSystem.pointMass3.cylinder.length;
//   referenceSystem.pointMass3.cylinder.size[2] = referenceSystem.pointMass3.cylinder.width;
//   referenceSystem.pointMass3.cylinder.size[3] = referenceSystem.pointMass3.cylinder.height;
//   referenceSystem.pointMass3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass3.cylinder.color[1] / 255.0,referenceSystem.pointMass3.cylinder.color[2] / 255.0,referenceSystem.pointMass3.cylinder.color[3] / 255.0,referenceSystem.pointMass3.cylinder.specularCoefficient);
//   referenceSystem.pointMass3.cylinder.Extra = referenceSystem.pointMass3.cylinder.extra;
//   referenceSystem.pointMass3.sphere.R.T[1,1] = referenceSystem.pointMass3.frame_a.R.T[1,1];
//   referenceSystem.pointMass3.sphere.R.T[1,2] = referenceSystem.pointMass3.frame_a.R.T[1,2];
//   referenceSystem.pointMass3.sphere.R.T[1,3] = referenceSystem.pointMass3.frame_a.R.T[1,3];
//   referenceSystem.pointMass3.sphere.R.T[2,1] = referenceSystem.pointMass3.frame_a.R.T[2,1];
//   referenceSystem.pointMass3.sphere.R.T[2,2] = referenceSystem.pointMass3.frame_a.R.T[2,2];
//   referenceSystem.pointMass3.sphere.R.T[2,3] = referenceSystem.pointMass3.frame_a.R.T[2,3];
//   referenceSystem.pointMass3.sphere.R.T[3,1] = referenceSystem.pointMass3.frame_a.R.T[3,1];
//   referenceSystem.pointMass3.sphere.R.T[3,2] = referenceSystem.pointMass3.frame_a.R.T[3,2];
//   referenceSystem.pointMass3.sphere.R.T[3,3] = referenceSystem.pointMass3.frame_a.R.T[3,3];
//   referenceSystem.pointMass3.sphere.R.w[1] = referenceSystem.pointMass3.frame_a.R.w[1];
//   referenceSystem.pointMass3.sphere.R.w[2] = referenceSystem.pointMass3.frame_a.R.w[2];
//   referenceSystem.pointMass3.sphere.R.w[3] = referenceSystem.pointMass3.frame_a.R.w[3];
//   referenceSystem.pointMass3.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass3.sphere.shapeType);
//   referenceSystem.pointMass3.sphere.rxvisobj[1] = referenceSystem.pointMass3.sphere.R.T[1,1] * referenceSystem.pointMass3.sphere.e_x[1] + (referenceSystem.pointMass3.sphere.R.T[2,1] * referenceSystem.pointMass3.sphere.e_x[2] + referenceSystem.pointMass3.sphere.R.T[3,1] * referenceSystem.pointMass3.sphere.e_x[3]);
//   referenceSystem.pointMass3.sphere.rxvisobj[2] = referenceSystem.pointMass3.sphere.R.T[1,2] * referenceSystem.pointMass3.sphere.e_x[1] + (referenceSystem.pointMass3.sphere.R.T[2,2] * referenceSystem.pointMass3.sphere.e_x[2] + referenceSystem.pointMass3.sphere.R.T[3,2] * referenceSystem.pointMass3.sphere.e_x[3]);
//   referenceSystem.pointMass3.sphere.rxvisobj[3] = referenceSystem.pointMass3.sphere.R.T[1,3] * referenceSystem.pointMass3.sphere.e_x[1] + (referenceSystem.pointMass3.sphere.R.T[2,3] * referenceSystem.pointMass3.sphere.e_x[2] + referenceSystem.pointMass3.sphere.R.T[3,3] * referenceSystem.pointMass3.sphere.e_x[3]);
//   referenceSystem.pointMass3.sphere.ryvisobj[1] = referenceSystem.pointMass3.sphere.R.T[1,1] * referenceSystem.pointMass3.sphere.e_y[1] + (referenceSystem.pointMass3.sphere.R.T[2,1] * referenceSystem.pointMass3.sphere.e_y[2] + referenceSystem.pointMass3.sphere.R.T[3,1] * referenceSystem.pointMass3.sphere.e_y[3]);
//   referenceSystem.pointMass3.sphere.ryvisobj[2] = referenceSystem.pointMass3.sphere.R.T[1,2] * referenceSystem.pointMass3.sphere.e_y[1] + (referenceSystem.pointMass3.sphere.R.T[2,2] * referenceSystem.pointMass3.sphere.e_y[2] + referenceSystem.pointMass3.sphere.R.T[3,2] * referenceSystem.pointMass3.sphere.e_y[3]);
//   referenceSystem.pointMass3.sphere.ryvisobj[3] = referenceSystem.pointMass3.sphere.R.T[1,3] * referenceSystem.pointMass3.sphere.e_y[1] + (referenceSystem.pointMass3.sphere.R.T[2,3] * referenceSystem.pointMass3.sphere.e_y[2] + referenceSystem.pointMass3.sphere.R.T[3,3] * referenceSystem.pointMass3.sphere.e_y[3]);
//   referenceSystem.pointMass3.sphere.rvisobj = referenceSystem.pointMass3.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass3.sphere.R.T[1,1],referenceSystem.pointMass3.sphere.R.T[1,2],referenceSystem.pointMass3.sphere.R.T[1,3]},{referenceSystem.pointMass3.sphere.R.T[2,1],referenceSystem.pointMass3.sphere.R.T[2,2],referenceSystem.pointMass3.sphere.R.T[2,3]},{referenceSystem.pointMass3.sphere.R.T[3,1],referenceSystem.pointMass3.sphere.R.T[3,2],referenceSystem.pointMass3.sphere.R.T[3,3]}},{referenceSystem.pointMass3.sphere.r_shape[1],referenceSystem.pointMass3.sphere.r_shape[2],referenceSystem.pointMass3.sphere.r_shape[3]});
//   referenceSystem.pointMass3.sphere.size[1] = referenceSystem.pointMass3.sphere.length;
//   referenceSystem.pointMass3.sphere.size[2] = referenceSystem.pointMass3.sphere.width;
//   referenceSystem.pointMass3.sphere.size[3] = referenceSystem.pointMass3.sphere.height;
//   referenceSystem.pointMass3.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass3.sphere.color[1] / 255.0,referenceSystem.pointMass3.sphere.color[2] / 255.0,referenceSystem.pointMass3.sphere.color[3] / 255.0,referenceSystem.pointMass3.sphere.specularCoefficient);
//   referenceSystem.pointMass3.sphere.Extra = referenceSystem.pointMass3.sphere.extra;
//   referenceSystem.pointMass3.r_0[1] = referenceSystem.pointMass3.frame_a.r_0[1];
//   referenceSystem.pointMass3.r_0[2] = referenceSystem.pointMass3.frame_a.r_0[2];
//   referenceSystem.pointMass3.r_0[3] = referenceSystem.pointMass3.frame_a.r_0[3];
//   if true then
//   referenceSystem.pointMass3.Q[1] = 0.0;
//   referenceSystem.pointMass3.Q[2] = 0.0;
//   referenceSystem.pointMass3.Q[3] = 0.0;
//   referenceSystem.pointMass3.Q[4] = 1.0;
//   referenceSystem.pointMass3.phi[1] = 0.0;
//   referenceSystem.pointMass3.phi[2] = 0.0;
//   referenceSystem.pointMass3.phi[3] = 0.0;
//   referenceSystem.pointMass3.phi_d[1] = 0.0;
//   referenceSystem.pointMass3.phi_d[2] = 0.0;
//   referenceSystem.pointMass3.phi_d[3] = 0.0;
//   referenceSystem.pointMass3.phi_dd[1] = 0.0;
//   referenceSystem.pointMass3.phi_dd[2] = 0.0;
//   referenceSystem.pointMass3.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass3.useQuaternions then
//   referenceSystem.pointMass3.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass3.Q[1],referenceSystem.pointMass3.Q[2],referenceSystem.pointMass3.Q[3],referenceSystem.pointMass3.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass3.Q[1],referenceSystem.pointMass3.Q[2],referenceSystem.pointMass3.Q[3],referenceSystem.pointMass3.Q[4]},{der(referenceSystem.pointMass3.Q[1]),der(referenceSystem.pointMass3.Q[2]),der(referenceSystem.pointMass3.Q[3]),der(referenceSystem.pointMass3.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass3.Q[1],referenceSystem.pointMass3.Q[2],referenceSystem.pointMass3.Q[3],referenceSystem.pointMass3.Q[4]});
//   referenceSystem.pointMass3.phi[1] = 0.0;
//   referenceSystem.pointMass3.phi[2] = 0.0;
//   referenceSystem.pointMass3.phi[3] = 0.0;
//   referenceSystem.pointMass3.phi_d[1] = 0.0;
//   referenceSystem.pointMass3.phi_d[2] = 0.0;
//   referenceSystem.pointMass3.phi_d[3] = 0.0;
//   referenceSystem.pointMass3.phi_dd[1] = 0.0;
//   referenceSystem.pointMass3.phi_dd[2] = 0.0;
//   referenceSystem.pointMass3.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass3.phi_d[1] = der(referenceSystem.pointMass3.phi[1]);
//   referenceSystem.pointMass3.phi_d[2] = der(referenceSystem.pointMass3.phi[2]);
//   referenceSystem.pointMass3.phi_d[3] = der(referenceSystem.pointMass3.phi[3]);
//   referenceSystem.pointMass3.phi_dd[1] = der(referenceSystem.pointMass3.phi_d[1]);
//   referenceSystem.pointMass3.phi_dd[2] = der(referenceSystem.pointMass3.phi_d[2]);
//   referenceSystem.pointMass3.phi_dd[3] = der(referenceSystem.pointMass3.phi_d[3]);
//   referenceSystem.pointMass3.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass3.sequence_angleStates[1],referenceSystem.pointMass3.sequence_angleStates[2],referenceSystem.pointMass3.sequence_angleStates[3]},{referenceSystem.pointMass3.phi[1],referenceSystem.pointMass3.phi[2],referenceSystem.pointMass3.phi[3]},{referenceSystem.pointMass3.phi_d[1],referenceSystem.pointMass3.phi_d[2],referenceSystem.pointMass3.phi_d[3]});
//   referenceSystem.pointMass3.Q[1] = 0.0;
//   referenceSystem.pointMass3.Q[2] = 0.0;
//   referenceSystem.pointMass3.Q[3] = 0.0;
//   referenceSystem.pointMass3.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass3.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass3.frame_a.r_0[1],referenceSystem.pointMass3.frame_a.r_0[2],referenceSystem.pointMass3.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass3.frame_a.R,{referenceSystem.pointMass3.r_CM[1],referenceSystem.pointMass3.r_CM[2],referenceSystem.pointMass3.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass3.v_0[1] = der(referenceSystem.pointMass3.frame_a.r_0[1]);
//   referenceSystem.pointMass3.v_0[2] = der(referenceSystem.pointMass3.frame_a.r_0[2]);
//   referenceSystem.pointMass3.v_0[3] = der(referenceSystem.pointMass3.frame_a.r_0[3]);
//   referenceSystem.pointMass3.a_0[1] = der(referenceSystem.pointMass3.v_0[1]);
//   referenceSystem.pointMass3.a_0[2] = der(referenceSystem.pointMass3.v_0[2]);
//   referenceSystem.pointMass3.a_0[3] = der(referenceSystem.pointMass3.v_0[3]);
//   referenceSystem.pointMass3.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass3.frame_a.R);
//   referenceSystem.pointMass3.z_a[1] = der(referenceSystem.pointMass3.w_a[1]);
//   referenceSystem.pointMass3.z_a[2] = der(referenceSystem.pointMass3.w_a[2]);
//   referenceSystem.pointMass3.z_a[3] = der(referenceSystem.pointMass3.w_a[3]);
//   referenceSystem.pointMass3.frame_a.f = referenceSystem.pointMass3.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass3.frame_a.R,{referenceSystem.pointMass3.a_0[1] - referenceSystem.pointMass3.g_0[1],referenceSystem.pointMass3.a_0[2] - referenceSystem.pointMass3.g_0[2],referenceSystem.pointMass3.a_0[3] - referenceSystem.pointMass3.g_0[3]}) + {referenceSystem.pointMass3.z_a[2] * referenceSystem.pointMass3.r_CM[3] - referenceSystem.pointMass3.z_a[3] * referenceSystem.pointMass3.r_CM[2],referenceSystem.pointMass3.z_a[3] * referenceSystem.pointMass3.r_CM[1] - referenceSystem.pointMass3.z_a[1] * referenceSystem.pointMass3.r_CM[3],referenceSystem.pointMass3.z_a[1] * referenceSystem.pointMass3.r_CM[2] - referenceSystem.pointMass3.z_a[2] * referenceSystem.pointMass3.r_CM[1]} + {referenceSystem.pointMass3.w_a[2] * (referenceSystem.pointMass3.w_a[1] * referenceSystem.pointMass3.r_CM[2] - referenceSystem.pointMass3.w_a[2] * referenceSystem.pointMass3.r_CM[1]) - referenceSystem.pointMass3.w_a[3] * (referenceSystem.pointMass3.w_a[3] * referenceSystem.pointMass3.r_CM[1] - referenceSystem.pointMass3.w_a[1] * referenceSystem.pointMass3.r_CM[3]),referenceSystem.pointMass3.w_a[3] * (referenceSystem.pointMass3.w_a[2] * referenceSystem.pointMass3.r_CM[3] - referenceSystem.pointMass3.w_a[3] * referenceSystem.pointMass3.r_CM[2]) - referenceSystem.pointMass3.w_a[1] * (referenceSystem.pointMass3.w_a[1] * referenceSystem.pointMass3.r_CM[2] - referenceSystem.pointMass3.w_a[2] * referenceSystem.pointMass3.r_CM[1]),referenceSystem.pointMass3.w_a[1] * (referenceSystem.pointMass3.w_a[3] * referenceSystem.pointMass3.r_CM[1] - referenceSystem.pointMass3.w_a[1] * referenceSystem.pointMass3.r_CM[3]) - referenceSystem.pointMass3.w_a[2] * (referenceSystem.pointMass3.w_a[2] * referenceSystem.pointMass3.r_CM[3] - referenceSystem.pointMass3.w_a[3] * referenceSystem.pointMass3.r_CM[2])});
//   referenceSystem.pointMass3.frame_a.t[1] = referenceSystem.pointMass3.I[1,1] * referenceSystem.pointMass3.z_a[1] + (referenceSystem.pointMass3.I[1,2] * referenceSystem.pointMass3.z_a[2] + (referenceSystem.pointMass3.I[1,3] * referenceSystem.pointMass3.z_a[3] + (referenceSystem.pointMass3.w_a[2] * (referenceSystem.pointMass3.I[3,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[3,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[3,3] * referenceSystem.pointMass3.w_a[3])) + ((-referenceSystem.pointMass3.w_a[3] * (referenceSystem.pointMass3.I[2,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[2,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[2,3] * referenceSystem.pointMass3.w_a[3]))) + (referenceSystem.pointMass3.r_CM[2] * referenceSystem.pointMass3.frame_a.f[3] + (-referenceSystem.pointMass3.r_CM[3] * referenceSystem.pointMass3.frame_a.f[2]))))));
//   referenceSystem.pointMass3.frame_a.t[2] = referenceSystem.pointMass3.I[2,1] * referenceSystem.pointMass3.z_a[1] + (referenceSystem.pointMass3.I[2,2] * referenceSystem.pointMass3.z_a[2] + (referenceSystem.pointMass3.I[2,3] * referenceSystem.pointMass3.z_a[3] + (referenceSystem.pointMass3.w_a[3] * (referenceSystem.pointMass3.I[1,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[1,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[1,3] * referenceSystem.pointMass3.w_a[3])) + ((-referenceSystem.pointMass3.w_a[1] * (referenceSystem.pointMass3.I[3,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[3,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[3,3] * referenceSystem.pointMass3.w_a[3]))) + (referenceSystem.pointMass3.r_CM[3] * referenceSystem.pointMass3.frame_a.f[1] + (-referenceSystem.pointMass3.r_CM[1] * referenceSystem.pointMass3.frame_a.f[3]))))));
//   referenceSystem.pointMass3.frame_a.t[3] = referenceSystem.pointMass3.I[3,1] * referenceSystem.pointMass3.z_a[1] + (referenceSystem.pointMass3.I[3,2] * referenceSystem.pointMass3.z_a[2] + (referenceSystem.pointMass3.I[3,3] * referenceSystem.pointMass3.z_a[3] + (referenceSystem.pointMass3.w_a[1] * (referenceSystem.pointMass3.I[2,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[2,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[2,3] * referenceSystem.pointMass3.w_a[3])) + ((-referenceSystem.pointMass3.w_a[2] * (referenceSystem.pointMass3.I[1,1] * referenceSystem.pointMass3.w_a[1] + (referenceSystem.pointMass3.I[1,2] * referenceSystem.pointMass3.w_a[2] + referenceSystem.pointMass3.I[1,3] * referenceSystem.pointMass3.w_a[3]))) + (referenceSystem.pointMass3.r_CM[1] * referenceSystem.pointMass3.frame_a.f[2] + (-referenceSystem.pointMass3.r_CM[2] * referenceSystem.pointMass3.frame_a.f[1]))))));
//   referenceSystem.pointMass4.cylinder.R.T[1,1] = referenceSystem.pointMass4.frame_a.R.T[1,1];
//   referenceSystem.pointMass4.cylinder.R.T[1,2] = referenceSystem.pointMass4.frame_a.R.T[1,2];
//   referenceSystem.pointMass4.cylinder.R.T[1,3] = referenceSystem.pointMass4.frame_a.R.T[1,3];
//   referenceSystem.pointMass4.cylinder.R.T[2,1] = referenceSystem.pointMass4.frame_a.R.T[2,1];
//   referenceSystem.pointMass4.cylinder.R.T[2,2] = referenceSystem.pointMass4.frame_a.R.T[2,2];
//   referenceSystem.pointMass4.cylinder.R.T[2,3] = referenceSystem.pointMass4.frame_a.R.T[2,3];
//   referenceSystem.pointMass4.cylinder.R.T[3,1] = referenceSystem.pointMass4.frame_a.R.T[3,1];
//   referenceSystem.pointMass4.cylinder.R.T[3,2] = referenceSystem.pointMass4.frame_a.R.T[3,2];
//   referenceSystem.pointMass4.cylinder.R.T[3,3] = referenceSystem.pointMass4.frame_a.R.T[3,3];
//   referenceSystem.pointMass4.cylinder.R.w[1] = referenceSystem.pointMass4.frame_a.R.w[1];
//   referenceSystem.pointMass4.cylinder.R.w[2] = referenceSystem.pointMass4.frame_a.R.w[2];
//   referenceSystem.pointMass4.cylinder.R.w[3] = referenceSystem.pointMass4.frame_a.R.w[3];
//   referenceSystem.pointMass4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass4.cylinder.shapeType);
//   referenceSystem.pointMass4.cylinder.rxvisobj[1] = referenceSystem.pointMass4.cylinder.R.T[1,1] * referenceSystem.pointMass4.cylinder.e_x[1] + (referenceSystem.pointMass4.cylinder.R.T[2,1] * referenceSystem.pointMass4.cylinder.e_x[2] + referenceSystem.pointMass4.cylinder.R.T[3,1] * referenceSystem.pointMass4.cylinder.e_x[3]);
//   referenceSystem.pointMass4.cylinder.rxvisobj[2] = referenceSystem.pointMass4.cylinder.R.T[1,2] * referenceSystem.pointMass4.cylinder.e_x[1] + (referenceSystem.pointMass4.cylinder.R.T[2,2] * referenceSystem.pointMass4.cylinder.e_x[2] + referenceSystem.pointMass4.cylinder.R.T[3,2] * referenceSystem.pointMass4.cylinder.e_x[3]);
//   referenceSystem.pointMass4.cylinder.rxvisobj[3] = referenceSystem.pointMass4.cylinder.R.T[1,3] * referenceSystem.pointMass4.cylinder.e_x[1] + (referenceSystem.pointMass4.cylinder.R.T[2,3] * referenceSystem.pointMass4.cylinder.e_x[2] + referenceSystem.pointMass4.cylinder.R.T[3,3] * referenceSystem.pointMass4.cylinder.e_x[3]);
//   referenceSystem.pointMass4.cylinder.ryvisobj[1] = referenceSystem.pointMass4.cylinder.R.T[1,1] * referenceSystem.pointMass4.cylinder.e_y[1] + (referenceSystem.pointMass4.cylinder.R.T[2,1] * referenceSystem.pointMass4.cylinder.e_y[2] + referenceSystem.pointMass4.cylinder.R.T[3,1] * referenceSystem.pointMass4.cylinder.e_y[3]);
//   referenceSystem.pointMass4.cylinder.ryvisobj[2] = referenceSystem.pointMass4.cylinder.R.T[1,2] * referenceSystem.pointMass4.cylinder.e_y[1] + (referenceSystem.pointMass4.cylinder.R.T[2,2] * referenceSystem.pointMass4.cylinder.e_y[2] + referenceSystem.pointMass4.cylinder.R.T[3,2] * referenceSystem.pointMass4.cylinder.e_y[3]);
//   referenceSystem.pointMass4.cylinder.ryvisobj[3] = referenceSystem.pointMass4.cylinder.R.T[1,3] * referenceSystem.pointMass4.cylinder.e_y[1] + (referenceSystem.pointMass4.cylinder.R.T[2,3] * referenceSystem.pointMass4.cylinder.e_y[2] + referenceSystem.pointMass4.cylinder.R.T[3,3] * referenceSystem.pointMass4.cylinder.e_y[3]);
//   referenceSystem.pointMass4.cylinder.rvisobj = referenceSystem.pointMass4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass4.cylinder.R.T[1,1],referenceSystem.pointMass4.cylinder.R.T[1,2],referenceSystem.pointMass4.cylinder.R.T[1,3]},{referenceSystem.pointMass4.cylinder.R.T[2,1],referenceSystem.pointMass4.cylinder.R.T[2,2],referenceSystem.pointMass4.cylinder.R.T[2,3]},{referenceSystem.pointMass4.cylinder.R.T[3,1],referenceSystem.pointMass4.cylinder.R.T[3,2],referenceSystem.pointMass4.cylinder.R.T[3,3]}},{referenceSystem.pointMass4.cylinder.r_shape[1],referenceSystem.pointMass4.cylinder.r_shape[2],referenceSystem.pointMass4.cylinder.r_shape[3]});
//   referenceSystem.pointMass4.cylinder.size[1] = referenceSystem.pointMass4.cylinder.length;
//   referenceSystem.pointMass4.cylinder.size[2] = referenceSystem.pointMass4.cylinder.width;
//   referenceSystem.pointMass4.cylinder.size[3] = referenceSystem.pointMass4.cylinder.height;
//   referenceSystem.pointMass4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass4.cylinder.color[1] / 255.0,referenceSystem.pointMass4.cylinder.color[2] / 255.0,referenceSystem.pointMass4.cylinder.color[3] / 255.0,referenceSystem.pointMass4.cylinder.specularCoefficient);
//   referenceSystem.pointMass4.cylinder.Extra = referenceSystem.pointMass4.cylinder.extra;
//   referenceSystem.pointMass4.sphere.R.T[1,1] = referenceSystem.pointMass4.frame_a.R.T[1,1];
//   referenceSystem.pointMass4.sphere.R.T[1,2] = referenceSystem.pointMass4.frame_a.R.T[1,2];
//   referenceSystem.pointMass4.sphere.R.T[1,3] = referenceSystem.pointMass4.frame_a.R.T[1,3];
//   referenceSystem.pointMass4.sphere.R.T[2,1] = referenceSystem.pointMass4.frame_a.R.T[2,1];
//   referenceSystem.pointMass4.sphere.R.T[2,2] = referenceSystem.pointMass4.frame_a.R.T[2,2];
//   referenceSystem.pointMass4.sphere.R.T[2,3] = referenceSystem.pointMass4.frame_a.R.T[2,3];
//   referenceSystem.pointMass4.sphere.R.T[3,1] = referenceSystem.pointMass4.frame_a.R.T[3,1];
//   referenceSystem.pointMass4.sphere.R.T[3,2] = referenceSystem.pointMass4.frame_a.R.T[3,2];
//   referenceSystem.pointMass4.sphere.R.T[3,3] = referenceSystem.pointMass4.frame_a.R.T[3,3];
//   referenceSystem.pointMass4.sphere.R.w[1] = referenceSystem.pointMass4.frame_a.R.w[1];
//   referenceSystem.pointMass4.sphere.R.w[2] = referenceSystem.pointMass4.frame_a.R.w[2];
//   referenceSystem.pointMass4.sphere.R.w[3] = referenceSystem.pointMass4.frame_a.R.w[3];
//   referenceSystem.pointMass4.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass4.sphere.shapeType);
//   referenceSystem.pointMass4.sphere.rxvisobj[1] = referenceSystem.pointMass4.sphere.R.T[1,1] * referenceSystem.pointMass4.sphere.e_x[1] + (referenceSystem.pointMass4.sphere.R.T[2,1] * referenceSystem.pointMass4.sphere.e_x[2] + referenceSystem.pointMass4.sphere.R.T[3,1] * referenceSystem.pointMass4.sphere.e_x[3]);
//   referenceSystem.pointMass4.sphere.rxvisobj[2] = referenceSystem.pointMass4.sphere.R.T[1,2] * referenceSystem.pointMass4.sphere.e_x[1] + (referenceSystem.pointMass4.sphere.R.T[2,2] * referenceSystem.pointMass4.sphere.e_x[2] + referenceSystem.pointMass4.sphere.R.T[3,2] * referenceSystem.pointMass4.sphere.e_x[3]);
//   referenceSystem.pointMass4.sphere.rxvisobj[3] = referenceSystem.pointMass4.sphere.R.T[1,3] * referenceSystem.pointMass4.sphere.e_x[1] + (referenceSystem.pointMass4.sphere.R.T[2,3] * referenceSystem.pointMass4.sphere.e_x[2] + referenceSystem.pointMass4.sphere.R.T[3,3] * referenceSystem.pointMass4.sphere.e_x[3]);
//   referenceSystem.pointMass4.sphere.ryvisobj[1] = referenceSystem.pointMass4.sphere.R.T[1,1] * referenceSystem.pointMass4.sphere.e_y[1] + (referenceSystem.pointMass4.sphere.R.T[2,1] * referenceSystem.pointMass4.sphere.e_y[2] + referenceSystem.pointMass4.sphere.R.T[3,1] * referenceSystem.pointMass4.sphere.e_y[3]);
//   referenceSystem.pointMass4.sphere.ryvisobj[2] = referenceSystem.pointMass4.sphere.R.T[1,2] * referenceSystem.pointMass4.sphere.e_y[1] + (referenceSystem.pointMass4.sphere.R.T[2,2] * referenceSystem.pointMass4.sphere.e_y[2] + referenceSystem.pointMass4.sphere.R.T[3,2] * referenceSystem.pointMass4.sphere.e_y[3]);
//   referenceSystem.pointMass4.sphere.ryvisobj[3] = referenceSystem.pointMass4.sphere.R.T[1,3] * referenceSystem.pointMass4.sphere.e_y[1] + (referenceSystem.pointMass4.sphere.R.T[2,3] * referenceSystem.pointMass4.sphere.e_y[2] + referenceSystem.pointMass4.sphere.R.T[3,3] * referenceSystem.pointMass4.sphere.e_y[3]);
//   referenceSystem.pointMass4.sphere.rvisobj = referenceSystem.pointMass4.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass4.sphere.R.T[1,1],referenceSystem.pointMass4.sphere.R.T[1,2],referenceSystem.pointMass4.sphere.R.T[1,3]},{referenceSystem.pointMass4.sphere.R.T[2,1],referenceSystem.pointMass4.sphere.R.T[2,2],referenceSystem.pointMass4.sphere.R.T[2,3]},{referenceSystem.pointMass4.sphere.R.T[3,1],referenceSystem.pointMass4.sphere.R.T[3,2],referenceSystem.pointMass4.sphere.R.T[3,3]}},{referenceSystem.pointMass4.sphere.r_shape[1],referenceSystem.pointMass4.sphere.r_shape[2],referenceSystem.pointMass4.sphere.r_shape[3]});
//   referenceSystem.pointMass4.sphere.size[1] = referenceSystem.pointMass4.sphere.length;
//   referenceSystem.pointMass4.sphere.size[2] = referenceSystem.pointMass4.sphere.width;
//   referenceSystem.pointMass4.sphere.size[3] = referenceSystem.pointMass4.sphere.height;
//   referenceSystem.pointMass4.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass4.sphere.color[1] / 255.0,referenceSystem.pointMass4.sphere.color[2] / 255.0,referenceSystem.pointMass4.sphere.color[3] / 255.0,referenceSystem.pointMass4.sphere.specularCoefficient);
//   referenceSystem.pointMass4.sphere.Extra = referenceSystem.pointMass4.sphere.extra;
//   referenceSystem.pointMass4.r_0[1] = referenceSystem.pointMass4.frame_a.r_0[1];
//   referenceSystem.pointMass4.r_0[2] = referenceSystem.pointMass4.frame_a.r_0[2];
//   referenceSystem.pointMass4.r_0[3] = referenceSystem.pointMass4.frame_a.r_0[3];
//   if true then
//   referenceSystem.pointMass4.Q[1] = 0.0;
//   referenceSystem.pointMass4.Q[2] = 0.0;
//   referenceSystem.pointMass4.Q[3] = 0.0;
//   referenceSystem.pointMass4.Q[4] = 1.0;
//   referenceSystem.pointMass4.phi[1] = 0.0;
//   referenceSystem.pointMass4.phi[2] = 0.0;
//   referenceSystem.pointMass4.phi[3] = 0.0;
//   referenceSystem.pointMass4.phi_d[1] = 0.0;
//   referenceSystem.pointMass4.phi_d[2] = 0.0;
//   referenceSystem.pointMass4.phi_d[3] = 0.0;
//   referenceSystem.pointMass4.phi_dd[1] = 0.0;
//   referenceSystem.pointMass4.phi_dd[2] = 0.0;
//   referenceSystem.pointMass4.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass4.useQuaternions then
//   referenceSystem.pointMass4.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass4.Q[1],referenceSystem.pointMass4.Q[2],referenceSystem.pointMass4.Q[3],referenceSystem.pointMass4.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass4.Q[1],referenceSystem.pointMass4.Q[2],referenceSystem.pointMass4.Q[3],referenceSystem.pointMass4.Q[4]},{der(referenceSystem.pointMass4.Q[1]),der(referenceSystem.pointMass4.Q[2]),der(referenceSystem.pointMass4.Q[3]),der(referenceSystem.pointMass4.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass4.Q[1],referenceSystem.pointMass4.Q[2],referenceSystem.pointMass4.Q[3],referenceSystem.pointMass4.Q[4]});
//   referenceSystem.pointMass4.phi[1] = 0.0;
//   referenceSystem.pointMass4.phi[2] = 0.0;
//   referenceSystem.pointMass4.phi[3] = 0.0;
//   referenceSystem.pointMass4.phi_d[1] = 0.0;
//   referenceSystem.pointMass4.phi_d[2] = 0.0;
//   referenceSystem.pointMass4.phi_d[3] = 0.0;
//   referenceSystem.pointMass4.phi_dd[1] = 0.0;
//   referenceSystem.pointMass4.phi_dd[2] = 0.0;
//   referenceSystem.pointMass4.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass4.phi_d[1] = der(referenceSystem.pointMass4.phi[1]);
//   referenceSystem.pointMass4.phi_d[2] = der(referenceSystem.pointMass4.phi[2]);
//   referenceSystem.pointMass4.phi_d[3] = der(referenceSystem.pointMass4.phi[3]);
//   referenceSystem.pointMass4.phi_dd[1] = der(referenceSystem.pointMass4.phi_d[1]);
//   referenceSystem.pointMass4.phi_dd[2] = der(referenceSystem.pointMass4.phi_d[2]);
//   referenceSystem.pointMass4.phi_dd[3] = der(referenceSystem.pointMass4.phi_d[3]);
//   referenceSystem.pointMass4.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass4.sequence_angleStates[1],referenceSystem.pointMass4.sequence_angleStates[2],referenceSystem.pointMass4.sequence_angleStates[3]},{referenceSystem.pointMass4.phi[1],referenceSystem.pointMass4.phi[2],referenceSystem.pointMass4.phi[3]},{referenceSystem.pointMass4.phi_d[1],referenceSystem.pointMass4.phi_d[2],referenceSystem.pointMass4.phi_d[3]});
//   referenceSystem.pointMass4.Q[1] = 0.0;
//   referenceSystem.pointMass4.Q[2] = 0.0;
//   referenceSystem.pointMass4.Q[3] = 0.0;
//   referenceSystem.pointMass4.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass4.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass4.frame_a.r_0[1],referenceSystem.pointMass4.frame_a.r_0[2],referenceSystem.pointMass4.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass4.frame_a.R,{referenceSystem.pointMass4.r_CM[1],referenceSystem.pointMass4.r_CM[2],referenceSystem.pointMass4.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass4.v_0[1] = der(referenceSystem.pointMass4.frame_a.r_0[1]);
//   referenceSystem.pointMass4.v_0[2] = der(referenceSystem.pointMass4.frame_a.r_0[2]);
//   referenceSystem.pointMass4.v_0[3] = der(referenceSystem.pointMass4.frame_a.r_0[3]);
//   referenceSystem.pointMass4.a_0[1] = der(referenceSystem.pointMass4.v_0[1]);
//   referenceSystem.pointMass4.a_0[2] = der(referenceSystem.pointMass4.v_0[2]);
//   referenceSystem.pointMass4.a_0[3] = der(referenceSystem.pointMass4.v_0[3]);
//   referenceSystem.pointMass4.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass4.frame_a.R);
//   referenceSystem.pointMass4.z_a[1] = der(referenceSystem.pointMass4.w_a[1]);
//   referenceSystem.pointMass4.z_a[2] = der(referenceSystem.pointMass4.w_a[2]);
//   referenceSystem.pointMass4.z_a[3] = der(referenceSystem.pointMass4.w_a[3]);
//   referenceSystem.pointMass4.frame_a.f = referenceSystem.pointMass4.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass4.frame_a.R,{referenceSystem.pointMass4.a_0[1] - referenceSystem.pointMass4.g_0[1],referenceSystem.pointMass4.a_0[2] - referenceSystem.pointMass4.g_0[2],referenceSystem.pointMass4.a_0[3] - referenceSystem.pointMass4.g_0[3]}) + {referenceSystem.pointMass4.z_a[2] * referenceSystem.pointMass4.r_CM[3] - referenceSystem.pointMass4.z_a[3] * referenceSystem.pointMass4.r_CM[2],referenceSystem.pointMass4.z_a[3] * referenceSystem.pointMass4.r_CM[1] - referenceSystem.pointMass4.z_a[1] * referenceSystem.pointMass4.r_CM[3],referenceSystem.pointMass4.z_a[1] * referenceSystem.pointMass4.r_CM[2] - referenceSystem.pointMass4.z_a[2] * referenceSystem.pointMass4.r_CM[1]} + {referenceSystem.pointMass4.w_a[2] * (referenceSystem.pointMass4.w_a[1] * referenceSystem.pointMass4.r_CM[2] - referenceSystem.pointMass4.w_a[2] * referenceSystem.pointMass4.r_CM[1]) - referenceSystem.pointMass4.w_a[3] * (referenceSystem.pointMass4.w_a[3] * referenceSystem.pointMass4.r_CM[1] - referenceSystem.pointMass4.w_a[1] * referenceSystem.pointMass4.r_CM[3]),referenceSystem.pointMass4.w_a[3] * (referenceSystem.pointMass4.w_a[2] * referenceSystem.pointMass4.r_CM[3] - referenceSystem.pointMass4.w_a[3] * referenceSystem.pointMass4.r_CM[2]) - referenceSystem.pointMass4.w_a[1] * (referenceSystem.pointMass4.w_a[1] * referenceSystem.pointMass4.r_CM[2] - referenceSystem.pointMass4.w_a[2] * referenceSystem.pointMass4.r_CM[1]),referenceSystem.pointMass4.w_a[1] * (referenceSystem.pointMass4.w_a[3] * referenceSystem.pointMass4.r_CM[1] - referenceSystem.pointMass4.w_a[1] * referenceSystem.pointMass4.r_CM[3]) - referenceSystem.pointMass4.w_a[2] * (referenceSystem.pointMass4.w_a[2] * referenceSystem.pointMass4.r_CM[3] - referenceSystem.pointMass4.w_a[3] * referenceSystem.pointMass4.r_CM[2])});
//   referenceSystem.pointMass4.frame_a.t[1] = referenceSystem.pointMass4.I[1,1] * referenceSystem.pointMass4.z_a[1] + (referenceSystem.pointMass4.I[1,2] * referenceSystem.pointMass4.z_a[2] + (referenceSystem.pointMass4.I[1,3] * referenceSystem.pointMass4.z_a[3] + (referenceSystem.pointMass4.w_a[2] * (referenceSystem.pointMass4.I[3,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[3,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[3,3] * referenceSystem.pointMass4.w_a[3])) + ((-referenceSystem.pointMass4.w_a[3] * (referenceSystem.pointMass4.I[2,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[2,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[2,3] * referenceSystem.pointMass4.w_a[3]))) + (referenceSystem.pointMass4.r_CM[2] * referenceSystem.pointMass4.frame_a.f[3] + (-referenceSystem.pointMass4.r_CM[3] * referenceSystem.pointMass4.frame_a.f[2]))))));
//   referenceSystem.pointMass4.frame_a.t[2] = referenceSystem.pointMass4.I[2,1] * referenceSystem.pointMass4.z_a[1] + (referenceSystem.pointMass4.I[2,2] * referenceSystem.pointMass4.z_a[2] + (referenceSystem.pointMass4.I[2,3] * referenceSystem.pointMass4.z_a[3] + (referenceSystem.pointMass4.w_a[3] * (referenceSystem.pointMass4.I[1,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[1,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[1,3] * referenceSystem.pointMass4.w_a[3])) + ((-referenceSystem.pointMass4.w_a[1] * (referenceSystem.pointMass4.I[3,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[3,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[3,3] * referenceSystem.pointMass4.w_a[3]))) + (referenceSystem.pointMass4.r_CM[3] * referenceSystem.pointMass4.frame_a.f[1] + (-referenceSystem.pointMass4.r_CM[1] * referenceSystem.pointMass4.frame_a.f[3]))))));
//   referenceSystem.pointMass4.frame_a.t[3] = referenceSystem.pointMass4.I[3,1] * referenceSystem.pointMass4.z_a[1] + (referenceSystem.pointMass4.I[3,2] * referenceSystem.pointMass4.z_a[2] + (referenceSystem.pointMass4.I[3,3] * referenceSystem.pointMass4.z_a[3] + (referenceSystem.pointMass4.w_a[1] * (referenceSystem.pointMass4.I[2,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[2,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[2,3] * referenceSystem.pointMass4.w_a[3])) + ((-referenceSystem.pointMass4.w_a[2] * (referenceSystem.pointMass4.I[1,1] * referenceSystem.pointMass4.w_a[1] + (referenceSystem.pointMass4.I[1,2] * referenceSystem.pointMass4.w_a[2] + referenceSystem.pointMass4.I[1,3] * referenceSystem.pointMass4.w_a[3]))) + (referenceSystem.pointMass4.r_CM[1] * referenceSystem.pointMass4.frame_a.f[2] + (-referenceSystem.pointMass4.r_CM[2] * referenceSystem.pointMass4.frame_a.f[1]))))));
//   referenceSystem.pointMass5.cylinder.R.T[1,1] = referenceSystem.pointMass5.frame_a.R.T[1,1];
//   referenceSystem.pointMass5.cylinder.R.T[1,2] = referenceSystem.pointMass5.frame_a.R.T[1,2];
//   referenceSystem.pointMass5.cylinder.R.T[1,3] = referenceSystem.pointMass5.frame_a.R.T[1,3];
//   referenceSystem.pointMass5.cylinder.R.T[2,1] = referenceSystem.pointMass5.frame_a.R.T[2,1];
//   referenceSystem.pointMass5.cylinder.R.T[2,2] = referenceSystem.pointMass5.frame_a.R.T[2,2];
//   referenceSystem.pointMass5.cylinder.R.T[2,3] = referenceSystem.pointMass5.frame_a.R.T[2,3];
//   referenceSystem.pointMass5.cylinder.R.T[3,1] = referenceSystem.pointMass5.frame_a.R.T[3,1];
//   referenceSystem.pointMass5.cylinder.R.T[3,2] = referenceSystem.pointMass5.frame_a.R.T[3,2];
//   referenceSystem.pointMass5.cylinder.R.T[3,3] = referenceSystem.pointMass5.frame_a.R.T[3,3];
//   referenceSystem.pointMass5.cylinder.R.w[1] = referenceSystem.pointMass5.frame_a.R.w[1];
//   referenceSystem.pointMass5.cylinder.R.w[2] = referenceSystem.pointMass5.frame_a.R.w[2];
//   referenceSystem.pointMass5.cylinder.R.w[3] = referenceSystem.pointMass5.frame_a.R.w[3];
//   referenceSystem.pointMass5.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass5.cylinder.shapeType);
//   referenceSystem.pointMass5.cylinder.rxvisobj[1] = referenceSystem.pointMass5.cylinder.R.T[1,1] * referenceSystem.pointMass5.cylinder.e_x[1] + (referenceSystem.pointMass5.cylinder.R.T[2,1] * referenceSystem.pointMass5.cylinder.e_x[2] + referenceSystem.pointMass5.cylinder.R.T[3,1] * referenceSystem.pointMass5.cylinder.e_x[3]);
//   referenceSystem.pointMass5.cylinder.rxvisobj[2] = referenceSystem.pointMass5.cylinder.R.T[1,2] * referenceSystem.pointMass5.cylinder.e_x[1] + (referenceSystem.pointMass5.cylinder.R.T[2,2] * referenceSystem.pointMass5.cylinder.e_x[2] + referenceSystem.pointMass5.cylinder.R.T[3,2] * referenceSystem.pointMass5.cylinder.e_x[3]);
//   referenceSystem.pointMass5.cylinder.rxvisobj[3] = referenceSystem.pointMass5.cylinder.R.T[1,3] * referenceSystem.pointMass5.cylinder.e_x[1] + (referenceSystem.pointMass5.cylinder.R.T[2,3] * referenceSystem.pointMass5.cylinder.e_x[2] + referenceSystem.pointMass5.cylinder.R.T[3,3] * referenceSystem.pointMass5.cylinder.e_x[3]);
//   referenceSystem.pointMass5.cylinder.ryvisobj[1] = referenceSystem.pointMass5.cylinder.R.T[1,1] * referenceSystem.pointMass5.cylinder.e_y[1] + (referenceSystem.pointMass5.cylinder.R.T[2,1] * referenceSystem.pointMass5.cylinder.e_y[2] + referenceSystem.pointMass5.cylinder.R.T[3,1] * referenceSystem.pointMass5.cylinder.e_y[3]);
//   referenceSystem.pointMass5.cylinder.ryvisobj[2] = referenceSystem.pointMass5.cylinder.R.T[1,2] * referenceSystem.pointMass5.cylinder.e_y[1] + (referenceSystem.pointMass5.cylinder.R.T[2,2] * referenceSystem.pointMass5.cylinder.e_y[2] + referenceSystem.pointMass5.cylinder.R.T[3,2] * referenceSystem.pointMass5.cylinder.e_y[3]);
//   referenceSystem.pointMass5.cylinder.ryvisobj[3] = referenceSystem.pointMass5.cylinder.R.T[1,3] * referenceSystem.pointMass5.cylinder.e_y[1] + (referenceSystem.pointMass5.cylinder.R.T[2,3] * referenceSystem.pointMass5.cylinder.e_y[2] + referenceSystem.pointMass5.cylinder.R.T[3,3] * referenceSystem.pointMass5.cylinder.e_y[3]);
//   referenceSystem.pointMass5.cylinder.rvisobj = referenceSystem.pointMass5.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass5.cylinder.R.T[1,1],referenceSystem.pointMass5.cylinder.R.T[1,2],referenceSystem.pointMass5.cylinder.R.T[1,3]},{referenceSystem.pointMass5.cylinder.R.T[2,1],referenceSystem.pointMass5.cylinder.R.T[2,2],referenceSystem.pointMass5.cylinder.R.T[2,3]},{referenceSystem.pointMass5.cylinder.R.T[3,1],referenceSystem.pointMass5.cylinder.R.T[3,2],referenceSystem.pointMass5.cylinder.R.T[3,3]}},{referenceSystem.pointMass5.cylinder.r_shape[1],referenceSystem.pointMass5.cylinder.r_shape[2],referenceSystem.pointMass5.cylinder.r_shape[3]});
//   referenceSystem.pointMass5.cylinder.size[1] = referenceSystem.pointMass5.cylinder.length;
//   referenceSystem.pointMass5.cylinder.size[2] = referenceSystem.pointMass5.cylinder.width;
//   referenceSystem.pointMass5.cylinder.size[3] = referenceSystem.pointMass5.cylinder.height;
//   referenceSystem.pointMass5.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass5.cylinder.color[1] / 255.0,referenceSystem.pointMass5.cylinder.color[2] / 255.0,referenceSystem.pointMass5.cylinder.color[3] / 255.0,referenceSystem.pointMass5.cylinder.specularCoefficient);
//   referenceSystem.pointMass5.cylinder.Extra = referenceSystem.pointMass5.cylinder.extra;
//   referenceSystem.pointMass5.sphere.R.T[1,1] = referenceSystem.pointMass5.frame_a.R.T[1,1];
//   referenceSystem.pointMass5.sphere.R.T[1,2] = referenceSystem.pointMass5.frame_a.R.T[1,2];
//   referenceSystem.pointMass5.sphere.R.T[1,3] = referenceSystem.pointMass5.frame_a.R.T[1,3];
//   referenceSystem.pointMass5.sphere.R.T[2,1] = referenceSystem.pointMass5.frame_a.R.T[2,1];
//   referenceSystem.pointMass5.sphere.R.T[2,2] = referenceSystem.pointMass5.frame_a.R.T[2,2];
//   referenceSystem.pointMass5.sphere.R.T[2,3] = referenceSystem.pointMass5.frame_a.R.T[2,3];
//   referenceSystem.pointMass5.sphere.R.T[3,1] = referenceSystem.pointMass5.frame_a.R.T[3,1];
//   referenceSystem.pointMass5.sphere.R.T[3,2] = referenceSystem.pointMass5.frame_a.R.T[3,2];
//   referenceSystem.pointMass5.sphere.R.T[3,3] = referenceSystem.pointMass5.frame_a.R.T[3,3];
//   referenceSystem.pointMass5.sphere.R.w[1] = referenceSystem.pointMass5.frame_a.R.w[1];
//   referenceSystem.pointMass5.sphere.R.w[2] = referenceSystem.pointMass5.frame_a.R.w[2];
//   referenceSystem.pointMass5.sphere.R.w[3] = referenceSystem.pointMass5.frame_a.R.w[3];
//   referenceSystem.pointMass5.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass5.sphere.shapeType);
//   referenceSystem.pointMass5.sphere.rxvisobj[1] = referenceSystem.pointMass5.sphere.R.T[1,1] * referenceSystem.pointMass5.sphere.e_x[1] + (referenceSystem.pointMass5.sphere.R.T[2,1] * referenceSystem.pointMass5.sphere.e_x[2] + referenceSystem.pointMass5.sphere.R.T[3,1] * referenceSystem.pointMass5.sphere.e_x[3]);
//   referenceSystem.pointMass5.sphere.rxvisobj[2] = referenceSystem.pointMass5.sphere.R.T[1,2] * referenceSystem.pointMass5.sphere.e_x[1] + (referenceSystem.pointMass5.sphere.R.T[2,2] * referenceSystem.pointMass5.sphere.e_x[2] + referenceSystem.pointMass5.sphere.R.T[3,2] * referenceSystem.pointMass5.sphere.e_x[3]);
//   referenceSystem.pointMass5.sphere.rxvisobj[3] = referenceSystem.pointMass5.sphere.R.T[1,3] * referenceSystem.pointMass5.sphere.e_x[1] + (referenceSystem.pointMass5.sphere.R.T[2,3] * referenceSystem.pointMass5.sphere.e_x[2] + referenceSystem.pointMass5.sphere.R.T[3,3] * referenceSystem.pointMass5.sphere.e_x[3]);
//   referenceSystem.pointMass5.sphere.ryvisobj[1] = referenceSystem.pointMass5.sphere.R.T[1,1] * referenceSystem.pointMass5.sphere.e_y[1] + (referenceSystem.pointMass5.sphere.R.T[2,1] * referenceSystem.pointMass5.sphere.e_y[2] + referenceSystem.pointMass5.sphere.R.T[3,1] * referenceSystem.pointMass5.sphere.e_y[3]);
//   referenceSystem.pointMass5.sphere.ryvisobj[2] = referenceSystem.pointMass5.sphere.R.T[1,2] * referenceSystem.pointMass5.sphere.e_y[1] + (referenceSystem.pointMass5.sphere.R.T[2,2] * referenceSystem.pointMass5.sphere.e_y[2] + referenceSystem.pointMass5.sphere.R.T[3,2] * referenceSystem.pointMass5.sphere.e_y[3]);
//   referenceSystem.pointMass5.sphere.ryvisobj[3] = referenceSystem.pointMass5.sphere.R.T[1,3] * referenceSystem.pointMass5.sphere.e_y[1] + (referenceSystem.pointMass5.sphere.R.T[2,3] * referenceSystem.pointMass5.sphere.e_y[2] + referenceSystem.pointMass5.sphere.R.T[3,3] * referenceSystem.pointMass5.sphere.e_y[3]);
//   referenceSystem.pointMass5.sphere.rvisobj = referenceSystem.pointMass5.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass5.sphere.R.T[1,1],referenceSystem.pointMass5.sphere.R.T[1,2],referenceSystem.pointMass5.sphere.R.T[1,3]},{referenceSystem.pointMass5.sphere.R.T[2,1],referenceSystem.pointMass5.sphere.R.T[2,2],referenceSystem.pointMass5.sphere.R.T[2,3]},{referenceSystem.pointMass5.sphere.R.T[3,1],referenceSystem.pointMass5.sphere.R.T[3,2],referenceSystem.pointMass5.sphere.R.T[3,3]}},{referenceSystem.pointMass5.sphere.r_shape[1],referenceSystem.pointMass5.sphere.r_shape[2],referenceSystem.pointMass5.sphere.r_shape[3]});
//   referenceSystem.pointMass5.sphere.size[1] = referenceSystem.pointMass5.sphere.length;
//   referenceSystem.pointMass5.sphere.size[2] = referenceSystem.pointMass5.sphere.width;
//   referenceSystem.pointMass5.sphere.size[3] = referenceSystem.pointMass5.sphere.height;
//   referenceSystem.pointMass5.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass5.sphere.color[1] / 255.0,referenceSystem.pointMass5.sphere.color[2] / 255.0,referenceSystem.pointMass5.sphere.color[3] / 255.0,referenceSystem.pointMass5.sphere.specularCoefficient);
//   referenceSystem.pointMass5.sphere.Extra = referenceSystem.pointMass5.sphere.extra;
//   referenceSystem.pointMass5.r_0[1] = referenceSystem.pointMass5.frame_a.r_0[1];
//   referenceSystem.pointMass5.r_0[2] = referenceSystem.pointMass5.frame_a.r_0[2];
//   referenceSystem.pointMass5.r_0[3] = referenceSystem.pointMass5.frame_a.r_0[3];
//   if true then
//   referenceSystem.pointMass5.Q[1] = 0.0;
//   referenceSystem.pointMass5.Q[2] = 0.0;
//   referenceSystem.pointMass5.Q[3] = 0.0;
//   referenceSystem.pointMass5.Q[4] = 1.0;
//   referenceSystem.pointMass5.phi[1] = 0.0;
//   referenceSystem.pointMass5.phi[2] = 0.0;
//   referenceSystem.pointMass5.phi[3] = 0.0;
//   referenceSystem.pointMass5.phi_d[1] = 0.0;
//   referenceSystem.pointMass5.phi_d[2] = 0.0;
//   referenceSystem.pointMass5.phi_d[3] = 0.0;
//   referenceSystem.pointMass5.phi_dd[1] = 0.0;
//   referenceSystem.pointMass5.phi_dd[2] = 0.0;
//   referenceSystem.pointMass5.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass5.useQuaternions then
//   referenceSystem.pointMass5.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass5.Q[1],referenceSystem.pointMass5.Q[2],referenceSystem.pointMass5.Q[3],referenceSystem.pointMass5.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass5.Q[1],referenceSystem.pointMass5.Q[2],referenceSystem.pointMass5.Q[3],referenceSystem.pointMass5.Q[4]},{der(referenceSystem.pointMass5.Q[1]),der(referenceSystem.pointMass5.Q[2]),der(referenceSystem.pointMass5.Q[3]),der(referenceSystem.pointMass5.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass5.Q[1],referenceSystem.pointMass5.Q[2],referenceSystem.pointMass5.Q[3],referenceSystem.pointMass5.Q[4]});
//   referenceSystem.pointMass5.phi[1] = 0.0;
//   referenceSystem.pointMass5.phi[2] = 0.0;
//   referenceSystem.pointMass5.phi[3] = 0.0;
//   referenceSystem.pointMass5.phi_d[1] = 0.0;
//   referenceSystem.pointMass5.phi_d[2] = 0.0;
//   referenceSystem.pointMass5.phi_d[3] = 0.0;
//   referenceSystem.pointMass5.phi_dd[1] = 0.0;
//   referenceSystem.pointMass5.phi_dd[2] = 0.0;
//   referenceSystem.pointMass5.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass5.phi_d[1] = der(referenceSystem.pointMass5.phi[1]);
//   referenceSystem.pointMass5.phi_d[2] = der(referenceSystem.pointMass5.phi[2]);
//   referenceSystem.pointMass5.phi_d[3] = der(referenceSystem.pointMass5.phi[3]);
//   referenceSystem.pointMass5.phi_dd[1] = der(referenceSystem.pointMass5.phi_d[1]);
//   referenceSystem.pointMass5.phi_dd[2] = der(referenceSystem.pointMass5.phi_d[2]);
//   referenceSystem.pointMass5.phi_dd[3] = der(referenceSystem.pointMass5.phi_d[3]);
//   referenceSystem.pointMass5.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass5.sequence_angleStates[1],referenceSystem.pointMass5.sequence_angleStates[2],referenceSystem.pointMass5.sequence_angleStates[3]},{referenceSystem.pointMass5.phi[1],referenceSystem.pointMass5.phi[2],referenceSystem.pointMass5.phi[3]},{referenceSystem.pointMass5.phi_d[1],referenceSystem.pointMass5.phi_d[2],referenceSystem.pointMass5.phi_d[3]});
//   referenceSystem.pointMass5.Q[1] = 0.0;
//   referenceSystem.pointMass5.Q[2] = 0.0;
//   referenceSystem.pointMass5.Q[3] = 0.0;
//   referenceSystem.pointMass5.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass5.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass5.frame_a.r_0[1],referenceSystem.pointMass5.frame_a.r_0[2],referenceSystem.pointMass5.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass5.frame_a.R,{referenceSystem.pointMass5.r_CM[1],referenceSystem.pointMass5.r_CM[2],referenceSystem.pointMass5.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass5.v_0[1] = der(referenceSystem.pointMass5.frame_a.r_0[1]);
//   referenceSystem.pointMass5.v_0[2] = der(referenceSystem.pointMass5.frame_a.r_0[2]);
//   referenceSystem.pointMass5.v_0[3] = der(referenceSystem.pointMass5.frame_a.r_0[3]);
//   referenceSystem.pointMass5.a_0[1] = der(referenceSystem.pointMass5.v_0[1]);
//   referenceSystem.pointMass5.a_0[2] = der(referenceSystem.pointMass5.v_0[2]);
//   referenceSystem.pointMass5.a_0[3] = der(referenceSystem.pointMass5.v_0[3]);
//   referenceSystem.pointMass5.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass5.frame_a.R);
//   referenceSystem.pointMass5.z_a[1] = der(referenceSystem.pointMass5.w_a[1]);
//   referenceSystem.pointMass5.z_a[2] = der(referenceSystem.pointMass5.w_a[2]);
//   referenceSystem.pointMass5.z_a[3] = der(referenceSystem.pointMass5.w_a[3]);
//   referenceSystem.pointMass5.frame_a.f = referenceSystem.pointMass5.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass5.frame_a.R,{referenceSystem.pointMass5.a_0[1] - referenceSystem.pointMass5.g_0[1],referenceSystem.pointMass5.a_0[2] - referenceSystem.pointMass5.g_0[2],referenceSystem.pointMass5.a_0[3] - referenceSystem.pointMass5.g_0[3]}) + {referenceSystem.pointMass5.z_a[2] * referenceSystem.pointMass5.r_CM[3] - referenceSystem.pointMass5.z_a[3] * referenceSystem.pointMass5.r_CM[2],referenceSystem.pointMass5.z_a[3] * referenceSystem.pointMass5.r_CM[1] - referenceSystem.pointMass5.z_a[1] * referenceSystem.pointMass5.r_CM[3],referenceSystem.pointMass5.z_a[1] * referenceSystem.pointMass5.r_CM[2] - referenceSystem.pointMass5.z_a[2] * referenceSystem.pointMass5.r_CM[1]} + {referenceSystem.pointMass5.w_a[2] * (referenceSystem.pointMass5.w_a[1] * referenceSystem.pointMass5.r_CM[2] - referenceSystem.pointMass5.w_a[2] * referenceSystem.pointMass5.r_CM[1]) - referenceSystem.pointMass5.w_a[3] * (referenceSystem.pointMass5.w_a[3] * referenceSystem.pointMass5.r_CM[1] - referenceSystem.pointMass5.w_a[1] * referenceSystem.pointMass5.r_CM[3]),referenceSystem.pointMass5.w_a[3] * (referenceSystem.pointMass5.w_a[2] * referenceSystem.pointMass5.r_CM[3] - referenceSystem.pointMass5.w_a[3] * referenceSystem.pointMass5.r_CM[2]) - referenceSystem.pointMass5.w_a[1] * (referenceSystem.pointMass5.w_a[1] * referenceSystem.pointMass5.r_CM[2] - referenceSystem.pointMass5.w_a[2] * referenceSystem.pointMass5.r_CM[1]),referenceSystem.pointMass5.w_a[1] * (referenceSystem.pointMass5.w_a[3] * referenceSystem.pointMass5.r_CM[1] - referenceSystem.pointMass5.w_a[1] * referenceSystem.pointMass5.r_CM[3]) - referenceSystem.pointMass5.w_a[2] * (referenceSystem.pointMass5.w_a[2] * referenceSystem.pointMass5.r_CM[3] - referenceSystem.pointMass5.w_a[3] * referenceSystem.pointMass5.r_CM[2])});
//   referenceSystem.pointMass5.frame_a.t[1] = referenceSystem.pointMass5.I[1,1] * referenceSystem.pointMass5.z_a[1] + (referenceSystem.pointMass5.I[1,2] * referenceSystem.pointMass5.z_a[2] + (referenceSystem.pointMass5.I[1,3] * referenceSystem.pointMass5.z_a[3] + (referenceSystem.pointMass5.w_a[2] * (referenceSystem.pointMass5.I[3,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[3,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[3,3] * referenceSystem.pointMass5.w_a[3])) + ((-referenceSystem.pointMass5.w_a[3] * (referenceSystem.pointMass5.I[2,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[2,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[2,3] * referenceSystem.pointMass5.w_a[3]))) + (referenceSystem.pointMass5.r_CM[2] * referenceSystem.pointMass5.frame_a.f[3] + (-referenceSystem.pointMass5.r_CM[3] * referenceSystem.pointMass5.frame_a.f[2]))))));
//   referenceSystem.pointMass5.frame_a.t[2] = referenceSystem.pointMass5.I[2,1] * referenceSystem.pointMass5.z_a[1] + (referenceSystem.pointMass5.I[2,2] * referenceSystem.pointMass5.z_a[2] + (referenceSystem.pointMass5.I[2,3] * referenceSystem.pointMass5.z_a[3] + (referenceSystem.pointMass5.w_a[3] * (referenceSystem.pointMass5.I[1,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[1,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[1,3] * referenceSystem.pointMass5.w_a[3])) + ((-referenceSystem.pointMass5.w_a[1] * (referenceSystem.pointMass5.I[3,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[3,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[3,3] * referenceSystem.pointMass5.w_a[3]))) + (referenceSystem.pointMass5.r_CM[3] * referenceSystem.pointMass5.frame_a.f[1] + (-referenceSystem.pointMass5.r_CM[1] * referenceSystem.pointMass5.frame_a.f[3]))))));
//   referenceSystem.pointMass5.frame_a.t[3] = referenceSystem.pointMass5.I[3,1] * referenceSystem.pointMass5.z_a[1] + (referenceSystem.pointMass5.I[3,2] * referenceSystem.pointMass5.z_a[2] + (referenceSystem.pointMass5.I[3,3] * referenceSystem.pointMass5.z_a[3] + (referenceSystem.pointMass5.w_a[1] * (referenceSystem.pointMass5.I[2,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[2,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[2,3] * referenceSystem.pointMass5.w_a[3])) + ((-referenceSystem.pointMass5.w_a[2] * (referenceSystem.pointMass5.I[1,1] * referenceSystem.pointMass5.w_a[1] + (referenceSystem.pointMass5.I[1,2] * referenceSystem.pointMass5.w_a[2] + referenceSystem.pointMass5.I[1,3] * referenceSystem.pointMass5.w_a[3]))) + (referenceSystem.pointMass5.r_CM[1] * referenceSystem.pointMass5.frame_a.f[2] + (-referenceSystem.pointMass5.r_CM[2] * referenceSystem.pointMass5.frame_a.f[1]))))));
//   referenceSystem.pointMass6.cylinder.R.T[1,1] = referenceSystem.pointMass6.frame_a.R.T[1,1];
//   referenceSystem.pointMass6.cylinder.R.T[1,2] = referenceSystem.pointMass6.frame_a.R.T[1,2];
//   referenceSystem.pointMass6.cylinder.R.T[1,3] = referenceSystem.pointMass6.frame_a.R.T[1,3];
//   referenceSystem.pointMass6.cylinder.R.T[2,1] = referenceSystem.pointMass6.frame_a.R.T[2,1];
//   referenceSystem.pointMass6.cylinder.R.T[2,2] = referenceSystem.pointMass6.frame_a.R.T[2,2];
//   referenceSystem.pointMass6.cylinder.R.T[2,3] = referenceSystem.pointMass6.frame_a.R.T[2,3];
//   referenceSystem.pointMass6.cylinder.R.T[3,1] = referenceSystem.pointMass6.frame_a.R.T[3,1];
//   referenceSystem.pointMass6.cylinder.R.T[3,2] = referenceSystem.pointMass6.frame_a.R.T[3,2];
//   referenceSystem.pointMass6.cylinder.R.T[3,3] = referenceSystem.pointMass6.frame_a.R.T[3,3];
//   referenceSystem.pointMass6.cylinder.R.w[1] = referenceSystem.pointMass6.frame_a.R.w[1];
//   referenceSystem.pointMass6.cylinder.R.w[2] = referenceSystem.pointMass6.frame_a.R.w[2];
//   referenceSystem.pointMass6.cylinder.R.w[3] = referenceSystem.pointMass6.frame_a.R.w[3];
//   referenceSystem.pointMass6.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass6.cylinder.shapeType);
//   referenceSystem.pointMass6.cylinder.rxvisobj[1] = referenceSystem.pointMass6.cylinder.R.T[1,1] * referenceSystem.pointMass6.cylinder.e_x[1] + (referenceSystem.pointMass6.cylinder.R.T[2,1] * referenceSystem.pointMass6.cylinder.e_x[2] + referenceSystem.pointMass6.cylinder.R.T[3,1] * referenceSystem.pointMass6.cylinder.e_x[3]);
//   referenceSystem.pointMass6.cylinder.rxvisobj[2] = referenceSystem.pointMass6.cylinder.R.T[1,2] * referenceSystem.pointMass6.cylinder.e_x[1] + (referenceSystem.pointMass6.cylinder.R.T[2,2] * referenceSystem.pointMass6.cylinder.e_x[2] + referenceSystem.pointMass6.cylinder.R.T[3,2] * referenceSystem.pointMass6.cylinder.e_x[3]);
//   referenceSystem.pointMass6.cylinder.rxvisobj[3] = referenceSystem.pointMass6.cylinder.R.T[1,3] * referenceSystem.pointMass6.cylinder.e_x[1] + (referenceSystem.pointMass6.cylinder.R.T[2,3] * referenceSystem.pointMass6.cylinder.e_x[2] + referenceSystem.pointMass6.cylinder.R.T[3,3] * referenceSystem.pointMass6.cylinder.e_x[3]);
//   referenceSystem.pointMass6.cylinder.ryvisobj[1] = referenceSystem.pointMass6.cylinder.R.T[1,1] * referenceSystem.pointMass6.cylinder.e_y[1] + (referenceSystem.pointMass6.cylinder.R.T[2,1] * referenceSystem.pointMass6.cylinder.e_y[2] + referenceSystem.pointMass6.cylinder.R.T[3,1] * referenceSystem.pointMass6.cylinder.e_y[3]);
//   referenceSystem.pointMass6.cylinder.ryvisobj[2] = referenceSystem.pointMass6.cylinder.R.T[1,2] * referenceSystem.pointMass6.cylinder.e_y[1] + (referenceSystem.pointMass6.cylinder.R.T[2,2] * referenceSystem.pointMass6.cylinder.e_y[2] + referenceSystem.pointMass6.cylinder.R.T[3,2] * referenceSystem.pointMass6.cylinder.e_y[3]);
//   referenceSystem.pointMass6.cylinder.ryvisobj[3] = referenceSystem.pointMass6.cylinder.R.T[1,3] * referenceSystem.pointMass6.cylinder.e_y[1] + (referenceSystem.pointMass6.cylinder.R.T[2,3] * referenceSystem.pointMass6.cylinder.e_y[2] + referenceSystem.pointMass6.cylinder.R.T[3,3] * referenceSystem.pointMass6.cylinder.e_y[3]);
//   referenceSystem.pointMass6.cylinder.rvisobj = referenceSystem.pointMass6.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass6.cylinder.R.T[1,1],referenceSystem.pointMass6.cylinder.R.T[1,2],referenceSystem.pointMass6.cylinder.R.T[1,3]},{referenceSystem.pointMass6.cylinder.R.T[2,1],referenceSystem.pointMass6.cylinder.R.T[2,2],referenceSystem.pointMass6.cylinder.R.T[2,3]},{referenceSystem.pointMass6.cylinder.R.T[3,1],referenceSystem.pointMass6.cylinder.R.T[3,2],referenceSystem.pointMass6.cylinder.R.T[3,3]}},{referenceSystem.pointMass6.cylinder.r_shape[1],referenceSystem.pointMass6.cylinder.r_shape[2],referenceSystem.pointMass6.cylinder.r_shape[3]});
//   referenceSystem.pointMass6.cylinder.size[1] = referenceSystem.pointMass6.cylinder.length;
//   referenceSystem.pointMass6.cylinder.size[2] = referenceSystem.pointMass6.cylinder.width;
//   referenceSystem.pointMass6.cylinder.size[3] = referenceSystem.pointMass6.cylinder.height;
//   referenceSystem.pointMass6.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass6.cylinder.color[1] / 255.0,referenceSystem.pointMass6.cylinder.color[2] / 255.0,referenceSystem.pointMass6.cylinder.color[3] / 255.0,referenceSystem.pointMass6.cylinder.specularCoefficient);
//   referenceSystem.pointMass6.cylinder.Extra = referenceSystem.pointMass6.cylinder.extra;
//   referenceSystem.pointMass6.sphere.R.T[1,1] = referenceSystem.pointMass6.frame_a.R.T[1,1];
//   referenceSystem.pointMass6.sphere.R.T[1,2] = referenceSystem.pointMass6.frame_a.R.T[1,2];
//   referenceSystem.pointMass6.sphere.R.T[1,3] = referenceSystem.pointMass6.frame_a.R.T[1,3];
//   referenceSystem.pointMass6.sphere.R.T[2,1] = referenceSystem.pointMass6.frame_a.R.T[2,1];
//   referenceSystem.pointMass6.sphere.R.T[2,2] = referenceSystem.pointMass6.frame_a.R.T[2,2];
//   referenceSystem.pointMass6.sphere.R.T[2,3] = referenceSystem.pointMass6.frame_a.R.T[2,3];
//   referenceSystem.pointMass6.sphere.R.T[3,1] = referenceSystem.pointMass6.frame_a.R.T[3,1];
//   referenceSystem.pointMass6.sphere.R.T[3,2] = referenceSystem.pointMass6.frame_a.R.T[3,2];
//   referenceSystem.pointMass6.sphere.R.T[3,3] = referenceSystem.pointMass6.frame_a.R.T[3,3];
//   referenceSystem.pointMass6.sphere.R.w[1] = referenceSystem.pointMass6.frame_a.R.w[1];
//   referenceSystem.pointMass6.sphere.R.w[2] = referenceSystem.pointMass6.frame_a.R.w[2];
//   referenceSystem.pointMass6.sphere.R.w[3] = referenceSystem.pointMass6.frame_a.R.w[3];
//   referenceSystem.pointMass6.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.pointMass6.sphere.shapeType);
//   referenceSystem.pointMass6.sphere.rxvisobj[1] = referenceSystem.pointMass6.sphere.R.T[1,1] * referenceSystem.pointMass6.sphere.e_x[1] + (referenceSystem.pointMass6.sphere.R.T[2,1] * referenceSystem.pointMass6.sphere.e_x[2] + referenceSystem.pointMass6.sphere.R.T[3,1] * referenceSystem.pointMass6.sphere.e_x[3]);
//   referenceSystem.pointMass6.sphere.rxvisobj[2] = referenceSystem.pointMass6.sphere.R.T[1,2] * referenceSystem.pointMass6.sphere.e_x[1] + (referenceSystem.pointMass6.sphere.R.T[2,2] * referenceSystem.pointMass6.sphere.e_x[2] + referenceSystem.pointMass6.sphere.R.T[3,2] * referenceSystem.pointMass6.sphere.e_x[3]);
//   referenceSystem.pointMass6.sphere.rxvisobj[3] = referenceSystem.pointMass6.sphere.R.T[1,3] * referenceSystem.pointMass6.sphere.e_x[1] + (referenceSystem.pointMass6.sphere.R.T[2,3] * referenceSystem.pointMass6.sphere.e_x[2] + referenceSystem.pointMass6.sphere.R.T[3,3] * referenceSystem.pointMass6.sphere.e_x[3]);
//   referenceSystem.pointMass6.sphere.ryvisobj[1] = referenceSystem.pointMass6.sphere.R.T[1,1] * referenceSystem.pointMass6.sphere.e_y[1] + (referenceSystem.pointMass6.sphere.R.T[2,1] * referenceSystem.pointMass6.sphere.e_y[2] + referenceSystem.pointMass6.sphere.R.T[3,1] * referenceSystem.pointMass6.sphere.e_y[3]);
//   referenceSystem.pointMass6.sphere.ryvisobj[2] = referenceSystem.pointMass6.sphere.R.T[1,2] * referenceSystem.pointMass6.sphere.e_y[1] + (referenceSystem.pointMass6.sphere.R.T[2,2] * referenceSystem.pointMass6.sphere.e_y[2] + referenceSystem.pointMass6.sphere.R.T[3,2] * referenceSystem.pointMass6.sphere.e_y[3]);
//   referenceSystem.pointMass6.sphere.ryvisobj[3] = referenceSystem.pointMass6.sphere.R.T[1,3] * referenceSystem.pointMass6.sphere.e_y[1] + (referenceSystem.pointMass6.sphere.R.T[2,3] * referenceSystem.pointMass6.sphere.e_y[2] + referenceSystem.pointMass6.sphere.R.T[3,3] * referenceSystem.pointMass6.sphere.e_y[3]);
//   referenceSystem.pointMass6.sphere.rvisobj = referenceSystem.pointMass6.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.pointMass6.sphere.R.T[1,1],referenceSystem.pointMass6.sphere.R.T[1,2],referenceSystem.pointMass6.sphere.R.T[1,3]},{referenceSystem.pointMass6.sphere.R.T[2,1],referenceSystem.pointMass6.sphere.R.T[2,2],referenceSystem.pointMass6.sphere.R.T[2,3]},{referenceSystem.pointMass6.sphere.R.T[3,1],referenceSystem.pointMass6.sphere.R.T[3,2],referenceSystem.pointMass6.sphere.R.T[3,3]}},{referenceSystem.pointMass6.sphere.r_shape[1],referenceSystem.pointMass6.sphere.r_shape[2],referenceSystem.pointMass6.sphere.r_shape[3]});
//   referenceSystem.pointMass6.sphere.size[1] = referenceSystem.pointMass6.sphere.length;
//   referenceSystem.pointMass6.sphere.size[2] = referenceSystem.pointMass6.sphere.width;
//   referenceSystem.pointMass6.sphere.size[3] = referenceSystem.pointMass6.sphere.height;
//   referenceSystem.pointMass6.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.pointMass6.sphere.color[1] / 255.0,referenceSystem.pointMass6.sphere.color[2] / 255.0,referenceSystem.pointMass6.sphere.color[3] / 255.0,referenceSystem.pointMass6.sphere.specularCoefficient);
//   referenceSystem.pointMass6.sphere.Extra = referenceSystem.pointMass6.sphere.extra;
//   referenceSystem.pointMass6.r_0[1] = referenceSystem.pointMass6.frame_a.r_0[1];
//   referenceSystem.pointMass6.r_0[2] = referenceSystem.pointMass6.frame_a.r_0[2];
//   referenceSystem.pointMass6.r_0[3] = referenceSystem.pointMass6.frame_a.r_0[3];
//   if true then
//   referenceSystem.pointMass6.Q[1] = 0.0;
//   referenceSystem.pointMass6.Q[2] = 0.0;
//   referenceSystem.pointMass6.Q[3] = 0.0;
//   referenceSystem.pointMass6.Q[4] = 1.0;
//   referenceSystem.pointMass6.phi[1] = 0.0;
//   referenceSystem.pointMass6.phi[2] = 0.0;
//   referenceSystem.pointMass6.phi[3] = 0.0;
//   referenceSystem.pointMass6.phi_d[1] = 0.0;
//   referenceSystem.pointMass6.phi_d[2] = 0.0;
//   referenceSystem.pointMass6.phi_d[3] = 0.0;
//   referenceSystem.pointMass6.phi_dd[1] = 0.0;
//   referenceSystem.pointMass6.phi_dd[2] = 0.0;
//   referenceSystem.pointMass6.phi_dd[3] = 0.0;
//   elseif referenceSystem.pointMass6.useQuaternions then
//   referenceSystem.pointMass6.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({referenceSystem.pointMass6.Q[1],referenceSystem.pointMass6.Q[2],referenceSystem.pointMass6.Q[3],referenceSystem.pointMass6.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({referenceSystem.pointMass6.Q[1],referenceSystem.pointMass6.Q[2],referenceSystem.pointMass6.Q[3],referenceSystem.pointMass6.Q[4]},{der(referenceSystem.pointMass6.Q[1]),der(referenceSystem.pointMass6.Q[2]),der(referenceSystem.pointMass6.Q[3]),der(referenceSystem.pointMass6.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({referenceSystem.pointMass6.Q[1],referenceSystem.pointMass6.Q[2],referenceSystem.pointMass6.Q[3],referenceSystem.pointMass6.Q[4]});
//   referenceSystem.pointMass6.phi[1] = 0.0;
//   referenceSystem.pointMass6.phi[2] = 0.0;
//   referenceSystem.pointMass6.phi[3] = 0.0;
//   referenceSystem.pointMass6.phi_d[1] = 0.0;
//   referenceSystem.pointMass6.phi_d[2] = 0.0;
//   referenceSystem.pointMass6.phi_d[3] = 0.0;
//   referenceSystem.pointMass6.phi_dd[1] = 0.0;
//   referenceSystem.pointMass6.phi_dd[2] = 0.0;
//   referenceSystem.pointMass6.phi_dd[3] = 0.0;
//   else
//   referenceSystem.pointMass6.phi_d[1] = der(referenceSystem.pointMass6.phi[1]);
//   referenceSystem.pointMass6.phi_d[2] = der(referenceSystem.pointMass6.phi[2]);
//   referenceSystem.pointMass6.phi_d[3] = der(referenceSystem.pointMass6.phi[3]);
//   referenceSystem.pointMass6.phi_dd[1] = der(referenceSystem.pointMass6.phi_d[1]);
//   referenceSystem.pointMass6.phi_dd[2] = der(referenceSystem.pointMass6.phi_d[2]);
//   referenceSystem.pointMass6.phi_dd[3] = der(referenceSystem.pointMass6.phi_d[3]);
//   referenceSystem.pointMass6.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({referenceSystem.pointMass6.sequence_angleStates[1],referenceSystem.pointMass6.sequence_angleStates[2],referenceSystem.pointMass6.sequence_angleStates[3]},{referenceSystem.pointMass6.phi[1],referenceSystem.pointMass6.phi[2],referenceSystem.pointMass6.phi[3]},{referenceSystem.pointMass6.phi_d[1],referenceSystem.pointMass6.phi_d[2],referenceSystem.pointMass6.phi_d[3]});
//   referenceSystem.pointMass6.Q[1] = 0.0;
//   referenceSystem.pointMass6.Q[2] = 0.0;
//   referenceSystem.pointMass6.Q[3] = 0.0;
//   referenceSystem.pointMass6.Q[4] = 1.0;
//   end if;
//   referenceSystem.pointMass6.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({referenceSystem.pointMass6.frame_a.r_0[1],referenceSystem.pointMass6.frame_a.r_0[2],referenceSystem.pointMass6.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.pointMass6.frame_a.R,{referenceSystem.pointMass6.r_CM[1],referenceSystem.pointMass6.r_CM[2],referenceSystem.pointMass6.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   referenceSystem.pointMass6.v_0[1] = der(referenceSystem.pointMass6.frame_a.r_0[1]);
//   referenceSystem.pointMass6.v_0[2] = der(referenceSystem.pointMass6.frame_a.r_0[2]);
//   referenceSystem.pointMass6.v_0[3] = der(referenceSystem.pointMass6.frame_a.r_0[3]);
//   referenceSystem.pointMass6.a_0[1] = der(referenceSystem.pointMass6.v_0[1]);
//   referenceSystem.pointMass6.a_0[2] = der(referenceSystem.pointMass6.v_0[2]);
//   referenceSystem.pointMass6.a_0[3] = der(referenceSystem.pointMass6.v_0[3]);
//   referenceSystem.pointMass6.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(referenceSystem.pointMass6.frame_a.R);
//   referenceSystem.pointMass6.z_a[1] = der(referenceSystem.pointMass6.w_a[1]);
//   referenceSystem.pointMass6.z_a[2] = der(referenceSystem.pointMass6.w_a[2]);
//   referenceSystem.pointMass6.z_a[3] = der(referenceSystem.pointMass6.w_a[3]);
//   referenceSystem.pointMass6.frame_a.f = referenceSystem.pointMass6.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(referenceSystem.pointMass6.frame_a.R,{referenceSystem.pointMass6.a_0[1] - referenceSystem.pointMass6.g_0[1],referenceSystem.pointMass6.a_0[2] - referenceSystem.pointMass6.g_0[2],referenceSystem.pointMass6.a_0[3] - referenceSystem.pointMass6.g_0[3]}) + {referenceSystem.pointMass6.z_a[2] * referenceSystem.pointMass6.r_CM[3] - referenceSystem.pointMass6.z_a[3] * referenceSystem.pointMass6.r_CM[2],referenceSystem.pointMass6.z_a[3] * referenceSystem.pointMass6.r_CM[1] - referenceSystem.pointMass6.z_a[1] * referenceSystem.pointMass6.r_CM[3],referenceSystem.pointMass6.z_a[1] * referenceSystem.pointMass6.r_CM[2] - referenceSystem.pointMass6.z_a[2] * referenceSystem.pointMass6.r_CM[1]} + {referenceSystem.pointMass6.w_a[2] * (referenceSystem.pointMass6.w_a[1] * referenceSystem.pointMass6.r_CM[2] - referenceSystem.pointMass6.w_a[2] * referenceSystem.pointMass6.r_CM[1]) - referenceSystem.pointMass6.w_a[3] * (referenceSystem.pointMass6.w_a[3] * referenceSystem.pointMass6.r_CM[1] - referenceSystem.pointMass6.w_a[1] * referenceSystem.pointMass6.r_CM[3]),referenceSystem.pointMass6.w_a[3] * (referenceSystem.pointMass6.w_a[2] * referenceSystem.pointMass6.r_CM[3] - referenceSystem.pointMass6.w_a[3] * referenceSystem.pointMass6.r_CM[2]) - referenceSystem.pointMass6.w_a[1] * (referenceSystem.pointMass6.w_a[1] * referenceSystem.pointMass6.r_CM[2] - referenceSystem.pointMass6.w_a[2] * referenceSystem.pointMass6.r_CM[1]),referenceSystem.pointMass6.w_a[1] * (referenceSystem.pointMass6.w_a[3] * referenceSystem.pointMass6.r_CM[1] - referenceSystem.pointMass6.w_a[1] * referenceSystem.pointMass6.r_CM[3]) - referenceSystem.pointMass6.w_a[2] * (referenceSystem.pointMass6.w_a[2] * referenceSystem.pointMass6.r_CM[3] - referenceSystem.pointMass6.w_a[3] * referenceSystem.pointMass6.r_CM[2])});
//   referenceSystem.pointMass6.frame_a.t[1] = referenceSystem.pointMass6.I[1,1] * referenceSystem.pointMass6.z_a[1] + (referenceSystem.pointMass6.I[1,2] * referenceSystem.pointMass6.z_a[2] + (referenceSystem.pointMass6.I[1,3] * referenceSystem.pointMass6.z_a[3] + (referenceSystem.pointMass6.w_a[2] * (referenceSystem.pointMass6.I[3,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[3,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[3,3] * referenceSystem.pointMass6.w_a[3])) + ((-referenceSystem.pointMass6.w_a[3] * (referenceSystem.pointMass6.I[2,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[2,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[2,3] * referenceSystem.pointMass6.w_a[3]))) + (referenceSystem.pointMass6.r_CM[2] * referenceSystem.pointMass6.frame_a.f[3] + (-referenceSystem.pointMass6.r_CM[3] * referenceSystem.pointMass6.frame_a.f[2]))))));
//   referenceSystem.pointMass6.frame_a.t[2] = referenceSystem.pointMass6.I[2,1] * referenceSystem.pointMass6.z_a[1] + (referenceSystem.pointMass6.I[2,2] * referenceSystem.pointMass6.z_a[2] + (referenceSystem.pointMass6.I[2,3] * referenceSystem.pointMass6.z_a[3] + (referenceSystem.pointMass6.w_a[3] * (referenceSystem.pointMass6.I[1,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[1,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[1,3] * referenceSystem.pointMass6.w_a[3])) + ((-referenceSystem.pointMass6.w_a[1] * (referenceSystem.pointMass6.I[3,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[3,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[3,3] * referenceSystem.pointMass6.w_a[3]))) + (referenceSystem.pointMass6.r_CM[3] * referenceSystem.pointMass6.frame_a.f[1] + (-referenceSystem.pointMass6.r_CM[1] * referenceSystem.pointMass6.frame_a.f[3]))))));
//   referenceSystem.pointMass6.frame_a.t[3] = referenceSystem.pointMass6.I[3,1] * referenceSystem.pointMass6.z_a[1] + (referenceSystem.pointMass6.I[3,2] * referenceSystem.pointMass6.z_a[2] + (referenceSystem.pointMass6.I[3,3] * referenceSystem.pointMass6.z_a[3] + (referenceSystem.pointMass6.w_a[1] * (referenceSystem.pointMass6.I[2,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[2,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[2,3] * referenceSystem.pointMass6.w_a[3])) + ((-referenceSystem.pointMass6.w_a[2] * (referenceSystem.pointMass6.I[1,1] * referenceSystem.pointMass6.w_a[1] + (referenceSystem.pointMass6.I[1,2] * referenceSystem.pointMass6.w_a[2] + referenceSystem.pointMass6.I[1,3] * referenceSystem.pointMass6.w_a[3]))) + (referenceSystem.pointMass6.r_CM[1] * referenceSystem.pointMass6.frame_a.f[2] + (-referenceSystem.pointMass6.r_CM[2] * referenceSystem.pointMass6.frame_a.f[1]))))));
//   referenceSystem.fixedTranslation.shape.R.T[1,1] = referenceSystem.fixedTranslation.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation.shape.R.T[1,2] = referenceSystem.fixedTranslation.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation.shape.R.T[1,3] = referenceSystem.fixedTranslation.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation.shape.R.T[2,1] = referenceSystem.fixedTranslation.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation.shape.R.T[2,2] = referenceSystem.fixedTranslation.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation.shape.R.T[2,3] = referenceSystem.fixedTranslation.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation.shape.R.T[3,1] = referenceSystem.fixedTranslation.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation.shape.R.T[3,2] = referenceSystem.fixedTranslation.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation.shape.R.T[3,3] = referenceSystem.fixedTranslation.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation.shape.R.w[1] = referenceSystem.fixedTranslation.frame_a.R.w[1];
//   referenceSystem.fixedTranslation.shape.R.w[2] = referenceSystem.fixedTranslation.frame_a.R.w[2];
//   referenceSystem.fixedTranslation.shape.R.w[3] = referenceSystem.fixedTranslation.frame_a.R.w[3];
//   referenceSystem.fixedTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation.shape.shapeType);
//   referenceSystem.fixedTranslation.shape.rxvisobj[1] = referenceSystem.fixedTranslation.shape.R.T[1,1] * referenceSystem.fixedTranslation.shape.e_x[1] + (referenceSystem.fixedTranslation.shape.R.T[2,1] * referenceSystem.fixedTranslation.shape.e_x[2] + referenceSystem.fixedTranslation.shape.R.T[3,1] * referenceSystem.fixedTranslation.shape.e_x[3]);
//   referenceSystem.fixedTranslation.shape.rxvisobj[2] = referenceSystem.fixedTranslation.shape.R.T[1,2] * referenceSystem.fixedTranslation.shape.e_x[1] + (referenceSystem.fixedTranslation.shape.R.T[2,2] * referenceSystem.fixedTranslation.shape.e_x[2] + referenceSystem.fixedTranslation.shape.R.T[3,2] * referenceSystem.fixedTranslation.shape.e_x[3]);
//   referenceSystem.fixedTranslation.shape.rxvisobj[3] = referenceSystem.fixedTranslation.shape.R.T[1,3] * referenceSystem.fixedTranslation.shape.e_x[1] + (referenceSystem.fixedTranslation.shape.R.T[2,3] * referenceSystem.fixedTranslation.shape.e_x[2] + referenceSystem.fixedTranslation.shape.R.T[3,3] * referenceSystem.fixedTranslation.shape.e_x[3]);
//   referenceSystem.fixedTranslation.shape.ryvisobj[1] = referenceSystem.fixedTranslation.shape.R.T[1,1] * referenceSystem.fixedTranslation.shape.e_y[1] + (referenceSystem.fixedTranslation.shape.R.T[2,1] * referenceSystem.fixedTranslation.shape.e_y[2] + referenceSystem.fixedTranslation.shape.R.T[3,1] * referenceSystem.fixedTranslation.shape.e_y[3]);
//   referenceSystem.fixedTranslation.shape.ryvisobj[2] = referenceSystem.fixedTranslation.shape.R.T[1,2] * referenceSystem.fixedTranslation.shape.e_y[1] + (referenceSystem.fixedTranslation.shape.R.T[2,2] * referenceSystem.fixedTranslation.shape.e_y[2] + referenceSystem.fixedTranslation.shape.R.T[3,2] * referenceSystem.fixedTranslation.shape.e_y[3]);
//   referenceSystem.fixedTranslation.shape.ryvisobj[3] = referenceSystem.fixedTranslation.shape.R.T[1,3] * referenceSystem.fixedTranslation.shape.e_y[1] + (referenceSystem.fixedTranslation.shape.R.T[2,3] * referenceSystem.fixedTranslation.shape.e_y[2] + referenceSystem.fixedTranslation.shape.R.T[3,3] * referenceSystem.fixedTranslation.shape.e_y[3]);
//   referenceSystem.fixedTranslation.shape.rvisobj = referenceSystem.fixedTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation.shape.R.T[1,1],referenceSystem.fixedTranslation.shape.R.T[1,2],referenceSystem.fixedTranslation.shape.R.T[1,3]},{referenceSystem.fixedTranslation.shape.R.T[2,1],referenceSystem.fixedTranslation.shape.R.T[2,2],referenceSystem.fixedTranslation.shape.R.T[2,3]},{referenceSystem.fixedTranslation.shape.R.T[3,1],referenceSystem.fixedTranslation.shape.R.T[3,2],referenceSystem.fixedTranslation.shape.R.T[3,3]}},{referenceSystem.fixedTranslation.shape.r_shape[1],referenceSystem.fixedTranslation.shape.r_shape[2],referenceSystem.fixedTranslation.shape.r_shape[3]});
//   referenceSystem.fixedTranslation.shape.size[1] = referenceSystem.fixedTranslation.shape.length;
//   referenceSystem.fixedTranslation.shape.size[2] = referenceSystem.fixedTranslation.shape.width;
//   referenceSystem.fixedTranslation.shape.size[3] = referenceSystem.fixedTranslation.shape.height;
//   referenceSystem.fixedTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation.shape.color[1] / 255.0,referenceSystem.fixedTranslation.shape.color[2] / 255.0,referenceSystem.fixedTranslation.shape.color[3] / 255.0,referenceSystem.fixedTranslation.shape.specularCoefficient);
//   referenceSystem.fixedTranslation.shape.Extra = referenceSystem.fixedTranslation.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation.frame_b.r_0 = referenceSystem.fixedTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation.frame_a.R,{referenceSystem.fixedTranslation.r[1],referenceSystem.fixedTranslation.r[2],referenceSystem.fixedTranslation.r[3]});
//   referenceSystem.fixedTranslation.frame_b.R.T[1,1] = referenceSystem.fixedTranslation.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[1,2] = referenceSystem.fixedTranslation.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[1,3] = referenceSystem.fixedTranslation.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,1] = referenceSystem.fixedTranslation.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,2] = referenceSystem.fixedTranslation.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,3] = referenceSystem.fixedTranslation.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,1] = referenceSystem.fixedTranslation.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,2] = referenceSystem.fixedTranslation.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,3] = referenceSystem.fixedTranslation.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation.frame_b.R.w[1] = referenceSystem.fixedTranslation.frame_a.R.w[1];
//   referenceSystem.fixedTranslation.frame_b.R.w[2] = referenceSystem.fixedTranslation.frame_a.R.w[2];
//   referenceSystem.fixedTranslation.frame_b.R.w[3] = referenceSystem.fixedTranslation.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation.frame_a.f[1] + referenceSystem.fixedTranslation.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation.frame_a.f[2] + referenceSystem.fixedTranslation.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation.frame_a.f[3] + referenceSystem.fixedTranslation.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation.frame_a.t[1] + (referenceSystem.fixedTranslation.frame_b.t[1] + (referenceSystem.fixedTranslation.r[2] * referenceSystem.fixedTranslation.frame_b.f[3] + (-referenceSystem.fixedTranslation.r[3] * referenceSystem.fixedTranslation.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation.frame_a.t[2] + (referenceSystem.fixedTranslation.frame_b.t[2] + (referenceSystem.fixedTranslation.r[3] * referenceSystem.fixedTranslation.frame_b.f[1] + (-referenceSystem.fixedTranslation.r[1] * referenceSystem.fixedTranslation.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation.frame_a.t[3] + (referenceSystem.fixedTranslation.frame_b.t[3] + (referenceSystem.fixedTranslation.r[1] * referenceSystem.fixedTranslation.frame_b.f[2] + (-referenceSystem.fixedTranslation.r[2] * referenceSystem.fixedTranslation.frame_b.f[1])));
//   referenceSystem.fixedTranslation1.shape.R.T[1,1] = referenceSystem.fixedTranslation1.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation1.shape.R.T[1,2] = referenceSystem.fixedTranslation1.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation1.shape.R.T[1,3] = referenceSystem.fixedTranslation1.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation1.shape.R.T[2,1] = referenceSystem.fixedTranslation1.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation1.shape.R.T[2,2] = referenceSystem.fixedTranslation1.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation1.shape.R.T[2,3] = referenceSystem.fixedTranslation1.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation1.shape.R.T[3,1] = referenceSystem.fixedTranslation1.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation1.shape.R.T[3,2] = referenceSystem.fixedTranslation1.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation1.shape.R.T[3,3] = referenceSystem.fixedTranslation1.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation1.shape.R.w[1] = referenceSystem.fixedTranslation1.frame_a.R.w[1];
//   referenceSystem.fixedTranslation1.shape.R.w[2] = referenceSystem.fixedTranslation1.frame_a.R.w[2];
//   referenceSystem.fixedTranslation1.shape.R.w[3] = referenceSystem.fixedTranslation1.frame_a.R.w[3];
//   referenceSystem.fixedTranslation1.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation1.shape.shapeType);
//   referenceSystem.fixedTranslation1.shape.rxvisobj[1] = referenceSystem.fixedTranslation1.shape.R.T[1,1] * referenceSystem.fixedTranslation1.shape.e_x[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,1] * referenceSystem.fixedTranslation1.shape.e_x[2] + referenceSystem.fixedTranslation1.shape.R.T[3,1] * referenceSystem.fixedTranslation1.shape.e_x[3]);
//   referenceSystem.fixedTranslation1.shape.rxvisobj[2] = referenceSystem.fixedTranslation1.shape.R.T[1,2] * referenceSystem.fixedTranslation1.shape.e_x[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,2] * referenceSystem.fixedTranslation1.shape.e_x[2] + referenceSystem.fixedTranslation1.shape.R.T[3,2] * referenceSystem.fixedTranslation1.shape.e_x[3]);
//   referenceSystem.fixedTranslation1.shape.rxvisobj[3] = referenceSystem.fixedTranslation1.shape.R.T[1,3] * referenceSystem.fixedTranslation1.shape.e_x[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,3] * referenceSystem.fixedTranslation1.shape.e_x[2] + referenceSystem.fixedTranslation1.shape.R.T[3,3] * referenceSystem.fixedTranslation1.shape.e_x[3]);
//   referenceSystem.fixedTranslation1.shape.ryvisobj[1] = referenceSystem.fixedTranslation1.shape.R.T[1,1] * referenceSystem.fixedTranslation1.shape.e_y[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,1] * referenceSystem.fixedTranslation1.shape.e_y[2] + referenceSystem.fixedTranslation1.shape.R.T[3,1] * referenceSystem.fixedTranslation1.shape.e_y[3]);
//   referenceSystem.fixedTranslation1.shape.ryvisobj[2] = referenceSystem.fixedTranslation1.shape.R.T[1,2] * referenceSystem.fixedTranslation1.shape.e_y[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,2] * referenceSystem.fixedTranslation1.shape.e_y[2] + referenceSystem.fixedTranslation1.shape.R.T[3,2] * referenceSystem.fixedTranslation1.shape.e_y[3]);
//   referenceSystem.fixedTranslation1.shape.ryvisobj[3] = referenceSystem.fixedTranslation1.shape.R.T[1,3] * referenceSystem.fixedTranslation1.shape.e_y[1] + (referenceSystem.fixedTranslation1.shape.R.T[2,3] * referenceSystem.fixedTranslation1.shape.e_y[2] + referenceSystem.fixedTranslation1.shape.R.T[3,3] * referenceSystem.fixedTranslation1.shape.e_y[3]);
//   referenceSystem.fixedTranslation1.shape.rvisobj = referenceSystem.fixedTranslation1.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation1.shape.R.T[1,1],referenceSystem.fixedTranslation1.shape.R.T[1,2],referenceSystem.fixedTranslation1.shape.R.T[1,3]},{referenceSystem.fixedTranslation1.shape.R.T[2,1],referenceSystem.fixedTranslation1.shape.R.T[2,2],referenceSystem.fixedTranslation1.shape.R.T[2,3]},{referenceSystem.fixedTranslation1.shape.R.T[3,1],referenceSystem.fixedTranslation1.shape.R.T[3,2],referenceSystem.fixedTranslation1.shape.R.T[3,3]}},{referenceSystem.fixedTranslation1.shape.r_shape[1],referenceSystem.fixedTranslation1.shape.r_shape[2],referenceSystem.fixedTranslation1.shape.r_shape[3]});
//   referenceSystem.fixedTranslation1.shape.size[1] = referenceSystem.fixedTranslation1.shape.length;
//   referenceSystem.fixedTranslation1.shape.size[2] = referenceSystem.fixedTranslation1.shape.width;
//   referenceSystem.fixedTranslation1.shape.size[3] = referenceSystem.fixedTranslation1.shape.height;
//   referenceSystem.fixedTranslation1.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation1.shape.color[1] / 255.0,referenceSystem.fixedTranslation1.shape.color[2] / 255.0,referenceSystem.fixedTranslation1.shape.color[3] / 255.0,referenceSystem.fixedTranslation1.shape.specularCoefficient);
//   referenceSystem.fixedTranslation1.shape.Extra = referenceSystem.fixedTranslation1.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation1.frame_b.r_0 = referenceSystem.fixedTranslation1.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation1.frame_a.R,{referenceSystem.fixedTranslation1.r[1],referenceSystem.fixedTranslation1.r[2],referenceSystem.fixedTranslation1.r[3]});
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,1] = referenceSystem.fixedTranslation1.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,2] = referenceSystem.fixedTranslation1.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,3] = referenceSystem.fixedTranslation1.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,1] = referenceSystem.fixedTranslation1.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,2] = referenceSystem.fixedTranslation1.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,3] = referenceSystem.fixedTranslation1.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,1] = referenceSystem.fixedTranslation1.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,2] = referenceSystem.fixedTranslation1.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,3] = referenceSystem.fixedTranslation1.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation1.frame_b.R.w[1] = referenceSystem.fixedTranslation1.frame_a.R.w[1];
//   referenceSystem.fixedTranslation1.frame_b.R.w[2] = referenceSystem.fixedTranslation1.frame_a.R.w[2];
//   referenceSystem.fixedTranslation1.frame_b.R.w[3] = referenceSystem.fixedTranslation1.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation1.frame_a.f[1] + referenceSystem.fixedTranslation1.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation1.frame_a.f[2] + referenceSystem.fixedTranslation1.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation1.frame_a.f[3] + referenceSystem.fixedTranslation1.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation1.frame_a.t[1] + (referenceSystem.fixedTranslation1.frame_b.t[1] + (referenceSystem.fixedTranslation1.r[2] * referenceSystem.fixedTranslation1.frame_b.f[3] + (-referenceSystem.fixedTranslation1.r[3] * referenceSystem.fixedTranslation1.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation1.frame_a.t[2] + (referenceSystem.fixedTranslation1.frame_b.t[2] + (referenceSystem.fixedTranslation1.r[3] * referenceSystem.fixedTranslation1.frame_b.f[1] + (-referenceSystem.fixedTranslation1.r[1] * referenceSystem.fixedTranslation1.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation1.frame_a.t[3] + (referenceSystem.fixedTranslation1.frame_b.t[3] + (referenceSystem.fixedTranslation1.r[1] * referenceSystem.fixedTranslation1.frame_b.f[2] + (-referenceSystem.fixedTranslation1.r[2] * referenceSystem.fixedTranslation1.frame_b.f[1])));
//   referenceSystem.fixedTranslation2.shape.R.T[1,1] = referenceSystem.fixedTranslation2.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation2.shape.R.T[1,2] = referenceSystem.fixedTranslation2.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation2.shape.R.T[1,3] = referenceSystem.fixedTranslation2.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation2.shape.R.T[2,1] = referenceSystem.fixedTranslation2.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation2.shape.R.T[2,2] = referenceSystem.fixedTranslation2.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation2.shape.R.T[2,3] = referenceSystem.fixedTranslation2.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation2.shape.R.T[3,1] = referenceSystem.fixedTranslation2.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation2.shape.R.T[3,2] = referenceSystem.fixedTranslation2.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation2.shape.R.T[3,3] = referenceSystem.fixedTranslation2.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation2.shape.R.w[1] = referenceSystem.fixedTranslation2.frame_a.R.w[1];
//   referenceSystem.fixedTranslation2.shape.R.w[2] = referenceSystem.fixedTranslation2.frame_a.R.w[2];
//   referenceSystem.fixedTranslation2.shape.R.w[3] = referenceSystem.fixedTranslation2.frame_a.R.w[3];
//   referenceSystem.fixedTranslation2.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation2.shape.shapeType);
//   referenceSystem.fixedTranslation2.shape.rxvisobj[1] = referenceSystem.fixedTranslation2.shape.R.T[1,1] * referenceSystem.fixedTranslation2.shape.e_x[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,1] * referenceSystem.fixedTranslation2.shape.e_x[2] + referenceSystem.fixedTranslation2.shape.R.T[3,1] * referenceSystem.fixedTranslation2.shape.e_x[3]);
//   referenceSystem.fixedTranslation2.shape.rxvisobj[2] = referenceSystem.fixedTranslation2.shape.R.T[1,2] * referenceSystem.fixedTranslation2.shape.e_x[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,2] * referenceSystem.fixedTranslation2.shape.e_x[2] + referenceSystem.fixedTranslation2.shape.R.T[3,2] * referenceSystem.fixedTranslation2.shape.e_x[3]);
//   referenceSystem.fixedTranslation2.shape.rxvisobj[3] = referenceSystem.fixedTranslation2.shape.R.T[1,3] * referenceSystem.fixedTranslation2.shape.e_x[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,3] * referenceSystem.fixedTranslation2.shape.e_x[2] + referenceSystem.fixedTranslation2.shape.R.T[3,3] * referenceSystem.fixedTranslation2.shape.e_x[3]);
//   referenceSystem.fixedTranslation2.shape.ryvisobj[1] = referenceSystem.fixedTranslation2.shape.R.T[1,1] * referenceSystem.fixedTranslation2.shape.e_y[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,1] * referenceSystem.fixedTranslation2.shape.e_y[2] + referenceSystem.fixedTranslation2.shape.R.T[3,1] * referenceSystem.fixedTranslation2.shape.e_y[3]);
//   referenceSystem.fixedTranslation2.shape.ryvisobj[2] = referenceSystem.fixedTranslation2.shape.R.T[1,2] * referenceSystem.fixedTranslation2.shape.e_y[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,2] * referenceSystem.fixedTranslation2.shape.e_y[2] + referenceSystem.fixedTranslation2.shape.R.T[3,2] * referenceSystem.fixedTranslation2.shape.e_y[3]);
//   referenceSystem.fixedTranslation2.shape.ryvisobj[3] = referenceSystem.fixedTranslation2.shape.R.T[1,3] * referenceSystem.fixedTranslation2.shape.e_y[1] + (referenceSystem.fixedTranslation2.shape.R.T[2,3] * referenceSystem.fixedTranslation2.shape.e_y[2] + referenceSystem.fixedTranslation2.shape.R.T[3,3] * referenceSystem.fixedTranslation2.shape.e_y[3]);
//   referenceSystem.fixedTranslation2.shape.rvisobj = referenceSystem.fixedTranslation2.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation2.shape.R.T[1,1],referenceSystem.fixedTranslation2.shape.R.T[1,2],referenceSystem.fixedTranslation2.shape.R.T[1,3]},{referenceSystem.fixedTranslation2.shape.R.T[2,1],referenceSystem.fixedTranslation2.shape.R.T[2,2],referenceSystem.fixedTranslation2.shape.R.T[2,3]},{referenceSystem.fixedTranslation2.shape.R.T[3,1],referenceSystem.fixedTranslation2.shape.R.T[3,2],referenceSystem.fixedTranslation2.shape.R.T[3,3]}},{referenceSystem.fixedTranslation2.shape.r_shape[1],referenceSystem.fixedTranslation2.shape.r_shape[2],referenceSystem.fixedTranslation2.shape.r_shape[3]});
//   referenceSystem.fixedTranslation2.shape.size[1] = referenceSystem.fixedTranslation2.shape.length;
//   referenceSystem.fixedTranslation2.shape.size[2] = referenceSystem.fixedTranslation2.shape.width;
//   referenceSystem.fixedTranslation2.shape.size[3] = referenceSystem.fixedTranslation2.shape.height;
//   referenceSystem.fixedTranslation2.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation2.shape.color[1] / 255.0,referenceSystem.fixedTranslation2.shape.color[2] / 255.0,referenceSystem.fixedTranslation2.shape.color[3] / 255.0,referenceSystem.fixedTranslation2.shape.specularCoefficient);
//   referenceSystem.fixedTranslation2.shape.Extra = referenceSystem.fixedTranslation2.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation2.frame_b.r_0 = referenceSystem.fixedTranslation2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation2.frame_a.R,{referenceSystem.fixedTranslation2.r[1],referenceSystem.fixedTranslation2.r[2],referenceSystem.fixedTranslation2.r[3]});
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,1] = referenceSystem.fixedTranslation2.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,2] = referenceSystem.fixedTranslation2.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,3] = referenceSystem.fixedTranslation2.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,1] = referenceSystem.fixedTranslation2.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,2] = referenceSystem.fixedTranslation2.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,3] = referenceSystem.fixedTranslation2.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,1] = referenceSystem.fixedTranslation2.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,2] = referenceSystem.fixedTranslation2.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,3] = referenceSystem.fixedTranslation2.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation2.frame_b.R.w[1] = referenceSystem.fixedTranslation2.frame_a.R.w[1];
//   referenceSystem.fixedTranslation2.frame_b.R.w[2] = referenceSystem.fixedTranslation2.frame_a.R.w[2];
//   referenceSystem.fixedTranslation2.frame_b.R.w[3] = referenceSystem.fixedTranslation2.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation2.frame_a.f[1] + referenceSystem.fixedTranslation2.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation2.frame_a.f[2] + referenceSystem.fixedTranslation2.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation2.frame_a.f[3] + referenceSystem.fixedTranslation2.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation2.frame_a.t[1] + (referenceSystem.fixedTranslation2.frame_b.t[1] + (referenceSystem.fixedTranslation2.r[2] * referenceSystem.fixedTranslation2.frame_b.f[3] + (-referenceSystem.fixedTranslation2.r[3] * referenceSystem.fixedTranslation2.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation2.frame_a.t[2] + (referenceSystem.fixedTranslation2.frame_b.t[2] + (referenceSystem.fixedTranslation2.r[3] * referenceSystem.fixedTranslation2.frame_b.f[1] + (-referenceSystem.fixedTranslation2.r[1] * referenceSystem.fixedTranslation2.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation2.frame_a.t[3] + (referenceSystem.fixedTranslation2.frame_b.t[3] + (referenceSystem.fixedTranslation2.r[1] * referenceSystem.fixedTranslation2.frame_b.f[2] + (-referenceSystem.fixedTranslation2.r[2] * referenceSystem.fixedTranslation2.frame_b.f[1])));
//   referenceSystem.fixedTranslation3.shape.R.T[1,1] = referenceSystem.fixedTranslation3.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation3.shape.R.T[1,2] = referenceSystem.fixedTranslation3.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation3.shape.R.T[1,3] = referenceSystem.fixedTranslation3.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation3.shape.R.T[2,1] = referenceSystem.fixedTranslation3.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation3.shape.R.T[2,2] = referenceSystem.fixedTranslation3.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation3.shape.R.T[2,3] = referenceSystem.fixedTranslation3.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation3.shape.R.T[3,1] = referenceSystem.fixedTranslation3.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation3.shape.R.T[3,2] = referenceSystem.fixedTranslation3.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation3.shape.R.T[3,3] = referenceSystem.fixedTranslation3.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation3.shape.R.w[1] = referenceSystem.fixedTranslation3.frame_a.R.w[1];
//   referenceSystem.fixedTranslation3.shape.R.w[2] = referenceSystem.fixedTranslation3.frame_a.R.w[2];
//   referenceSystem.fixedTranslation3.shape.R.w[3] = referenceSystem.fixedTranslation3.frame_a.R.w[3];
//   referenceSystem.fixedTranslation3.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation3.shape.shapeType);
//   referenceSystem.fixedTranslation3.shape.rxvisobj[1] = referenceSystem.fixedTranslation3.shape.R.T[1,1] * referenceSystem.fixedTranslation3.shape.e_x[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,1] * referenceSystem.fixedTranslation3.shape.e_x[2] + referenceSystem.fixedTranslation3.shape.R.T[3,1] * referenceSystem.fixedTranslation3.shape.e_x[3]);
//   referenceSystem.fixedTranslation3.shape.rxvisobj[2] = referenceSystem.fixedTranslation3.shape.R.T[1,2] * referenceSystem.fixedTranslation3.shape.e_x[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,2] * referenceSystem.fixedTranslation3.shape.e_x[2] + referenceSystem.fixedTranslation3.shape.R.T[3,2] * referenceSystem.fixedTranslation3.shape.e_x[3]);
//   referenceSystem.fixedTranslation3.shape.rxvisobj[3] = referenceSystem.fixedTranslation3.shape.R.T[1,3] * referenceSystem.fixedTranslation3.shape.e_x[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,3] * referenceSystem.fixedTranslation3.shape.e_x[2] + referenceSystem.fixedTranslation3.shape.R.T[3,3] * referenceSystem.fixedTranslation3.shape.e_x[3]);
//   referenceSystem.fixedTranslation3.shape.ryvisobj[1] = referenceSystem.fixedTranslation3.shape.R.T[1,1] * referenceSystem.fixedTranslation3.shape.e_y[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,1] * referenceSystem.fixedTranslation3.shape.e_y[2] + referenceSystem.fixedTranslation3.shape.R.T[3,1] * referenceSystem.fixedTranslation3.shape.e_y[3]);
//   referenceSystem.fixedTranslation3.shape.ryvisobj[2] = referenceSystem.fixedTranslation3.shape.R.T[1,2] * referenceSystem.fixedTranslation3.shape.e_y[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,2] * referenceSystem.fixedTranslation3.shape.e_y[2] + referenceSystem.fixedTranslation3.shape.R.T[3,2] * referenceSystem.fixedTranslation3.shape.e_y[3]);
//   referenceSystem.fixedTranslation3.shape.ryvisobj[3] = referenceSystem.fixedTranslation3.shape.R.T[1,3] * referenceSystem.fixedTranslation3.shape.e_y[1] + (referenceSystem.fixedTranslation3.shape.R.T[2,3] * referenceSystem.fixedTranslation3.shape.e_y[2] + referenceSystem.fixedTranslation3.shape.R.T[3,3] * referenceSystem.fixedTranslation3.shape.e_y[3]);
//   referenceSystem.fixedTranslation3.shape.rvisobj = referenceSystem.fixedTranslation3.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation3.shape.R.T[1,1],referenceSystem.fixedTranslation3.shape.R.T[1,2],referenceSystem.fixedTranslation3.shape.R.T[1,3]},{referenceSystem.fixedTranslation3.shape.R.T[2,1],referenceSystem.fixedTranslation3.shape.R.T[2,2],referenceSystem.fixedTranslation3.shape.R.T[2,3]},{referenceSystem.fixedTranslation3.shape.R.T[3,1],referenceSystem.fixedTranslation3.shape.R.T[3,2],referenceSystem.fixedTranslation3.shape.R.T[3,3]}},{referenceSystem.fixedTranslation3.shape.r_shape[1],referenceSystem.fixedTranslation3.shape.r_shape[2],referenceSystem.fixedTranslation3.shape.r_shape[3]});
//   referenceSystem.fixedTranslation3.shape.size[1] = referenceSystem.fixedTranslation3.shape.length;
//   referenceSystem.fixedTranslation3.shape.size[2] = referenceSystem.fixedTranslation3.shape.width;
//   referenceSystem.fixedTranslation3.shape.size[3] = referenceSystem.fixedTranslation3.shape.height;
//   referenceSystem.fixedTranslation3.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation3.shape.color[1] / 255.0,referenceSystem.fixedTranslation3.shape.color[2] / 255.0,referenceSystem.fixedTranslation3.shape.color[3] / 255.0,referenceSystem.fixedTranslation3.shape.specularCoefficient);
//   referenceSystem.fixedTranslation3.shape.Extra = referenceSystem.fixedTranslation3.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation3.frame_b.r_0 = referenceSystem.fixedTranslation3.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation3.frame_a.R,{referenceSystem.fixedTranslation3.r[1],referenceSystem.fixedTranslation3.r[2],referenceSystem.fixedTranslation3.r[3]});
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,1] = referenceSystem.fixedTranslation3.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,2] = referenceSystem.fixedTranslation3.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,3] = referenceSystem.fixedTranslation3.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,1] = referenceSystem.fixedTranslation3.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,2] = referenceSystem.fixedTranslation3.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,3] = referenceSystem.fixedTranslation3.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,1] = referenceSystem.fixedTranslation3.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,2] = referenceSystem.fixedTranslation3.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,3] = referenceSystem.fixedTranslation3.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation3.frame_b.R.w[1] = referenceSystem.fixedTranslation3.frame_a.R.w[1];
//   referenceSystem.fixedTranslation3.frame_b.R.w[2] = referenceSystem.fixedTranslation3.frame_a.R.w[2];
//   referenceSystem.fixedTranslation3.frame_b.R.w[3] = referenceSystem.fixedTranslation3.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation3.frame_a.f[1] + referenceSystem.fixedTranslation3.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation3.frame_a.f[2] + referenceSystem.fixedTranslation3.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation3.frame_a.f[3] + referenceSystem.fixedTranslation3.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation3.frame_a.t[1] + (referenceSystem.fixedTranslation3.frame_b.t[1] + (referenceSystem.fixedTranslation3.r[2] * referenceSystem.fixedTranslation3.frame_b.f[3] + (-referenceSystem.fixedTranslation3.r[3] * referenceSystem.fixedTranslation3.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation3.frame_a.t[2] + (referenceSystem.fixedTranslation3.frame_b.t[2] + (referenceSystem.fixedTranslation3.r[3] * referenceSystem.fixedTranslation3.frame_b.f[1] + (-referenceSystem.fixedTranslation3.r[1] * referenceSystem.fixedTranslation3.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation3.frame_a.t[3] + (referenceSystem.fixedTranslation3.frame_b.t[3] + (referenceSystem.fixedTranslation3.r[1] * referenceSystem.fixedTranslation3.frame_b.f[2] + (-referenceSystem.fixedTranslation3.r[2] * referenceSystem.fixedTranslation3.frame_b.f[1])));
//   referenceSystem.fixedTranslation4.shape.R.T[1,1] = referenceSystem.fixedTranslation4.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation4.shape.R.T[1,2] = referenceSystem.fixedTranslation4.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation4.shape.R.T[1,3] = referenceSystem.fixedTranslation4.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation4.shape.R.T[2,1] = referenceSystem.fixedTranslation4.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation4.shape.R.T[2,2] = referenceSystem.fixedTranslation4.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation4.shape.R.T[2,3] = referenceSystem.fixedTranslation4.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation4.shape.R.T[3,1] = referenceSystem.fixedTranslation4.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation4.shape.R.T[3,2] = referenceSystem.fixedTranslation4.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation4.shape.R.T[3,3] = referenceSystem.fixedTranslation4.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation4.shape.R.w[1] = referenceSystem.fixedTranslation4.frame_a.R.w[1];
//   referenceSystem.fixedTranslation4.shape.R.w[2] = referenceSystem.fixedTranslation4.frame_a.R.w[2];
//   referenceSystem.fixedTranslation4.shape.R.w[3] = referenceSystem.fixedTranslation4.frame_a.R.w[3];
//   referenceSystem.fixedTranslation4.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation4.shape.shapeType);
//   referenceSystem.fixedTranslation4.shape.rxvisobj[1] = referenceSystem.fixedTranslation4.shape.R.T[1,1] * referenceSystem.fixedTranslation4.shape.e_x[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,1] * referenceSystem.fixedTranslation4.shape.e_x[2] + referenceSystem.fixedTranslation4.shape.R.T[3,1] * referenceSystem.fixedTranslation4.shape.e_x[3]);
//   referenceSystem.fixedTranslation4.shape.rxvisobj[2] = referenceSystem.fixedTranslation4.shape.R.T[1,2] * referenceSystem.fixedTranslation4.shape.e_x[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,2] * referenceSystem.fixedTranslation4.shape.e_x[2] + referenceSystem.fixedTranslation4.shape.R.T[3,2] * referenceSystem.fixedTranslation4.shape.e_x[3]);
//   referenceSystem.fixedTranslation4.shape.rxvisobj[3] = referenceSystem.fixedTranslation4.shape.R.T[1,3] * referenceSystem.fixedTranslation4.shape.e_x[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,3] * referenceSystem.fixedTranslation4.shape.e_x[2] + referenceSystem.fixedTranslation4.shape.R.T[3,3] * referenceSystem.fixedTranslation4.shape.e_x[3]);
//   referenceSystem.fixedTranslation4.shape.ryvisobj[1] = referenceSystem.fixedTranslation4.shape.R.T[1,1] * referenceSystem.fixedTranslation4.shape.e_y[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,1] * referenceSystem.fixedTranslation4.shape.e_y[2] + referenceSystem.fixedTranslation4.shape.R.T[3,1] * referenceSystem.fixedTranslation4.shape.e_y[3]);
//   referenceSystem.fixedTranslation4.shape.ryvisobj[2] = referenceSystem.fixedTranslation4.shape.R.T[1,2] * referenceSystem.fixedTranslation4.shape.e_y[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,2] * referenceSystem.fixedTranslation4.shape.e_y[2] + referenceSystem.fixedTranslation4.shape.R.T[3,2] * referenceSystem.fixedTranslation4.shape.e_y[3]);
//   referenceSystem.fixedTranslation4.shape.ryvisobj[3] = referenceSystem.fixedTranslation4.shape.R.T[1,3] * referenceSystem.fixedTranslation4.shape.e_y[1] + (referenceSystem.fixedTranslation4.shape.R.T[2,3] * referenceSystem.fixedTranslation4.shape.e_y[2] + referenceSystem.fixedTranslation4.shape.R.T[3,3] * referenceSystem.fixedTranslation4.shape.e_y[3]);
//   referenceSystem.fixedTranslation4.shape.rvisobj = referenceSystem.fixedTranslation4.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation4.shape.R.T[1,1],referenceSystem.fixedTranslation4.shape.R.T[1,2],referenceSystem.fixedTranslation4.shape.R.T[1,3]},{referenceSystem.fixedTranslation4.shape.R.T[2,1],referenceSystem.fixedTranslation4.shape.R.T[2,2],referenceSystem.fixedTranslation4.shape.R.T[2,3]},{referenceSystem.fixedTranslation4.shape.R.T[3,1],referenceSystem.fixedTranslation4.shape.R.T[3,2],referenceSystem.fixedTranslation4.shape.R.T[3,3]}},{referenceSystem.fixedTranslation4.shape.r_shape[1],referenceSystem.fixedTranslation4.shape.r_shape[2],referenceSystem.fixedTranslation4.shape.r_shape[3]});
//   referenceSystem.fixedTranslation4.shape.size[1] = referenceSystem.fixedTranslation4.shape.length;
//   referenceSystem.fixedTranslation4.shape.size[2] = referenceSystem.fixedTranslation4.shape.width;
//   referenceSystem.fixedTranslation4.shape.size[3] = referenceSystem.fixedTranslation4.shape.height;
//   referenceSystem.fixedTranslation4.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation4.shape.color[1] / 255.0,referenceSystem.fixedTranslation4.shape.color[2] / 255.0,referenceSystem.fixedTranslation4.shape.color[3] / 255.0,referenceSystem.fixedTranslation4.shape.specularCoefficient);
//   referenceSystem.fixedTranslation4.shape.Extra = referenceSystem.fixedTranslation4.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation4.frame_b.r_0 = referenceSystem.fixedTranslation4.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation4.frame_a.R,{referenceSystem.fixedTranslation4.r[1],referenceSystem.fixedTranslation4.r[2],referenceSystem.fixedTranslation4.r[3]});
//   referenceSystem.fixedTranslation4.frame_b.R.T[1,1] = referenceSystem.fixedTranslation4.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation4.frame_b.R.T[1,2] = referenceSystem.fixedTranslation4.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation4.frame_b.R.T[1,3] = referenceSystem.fixedTranslation4.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation4.frame_b.R.T[2,1] = referenceSystem.fixedTranslation4.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation4.frame_b.R.T[2,2] = referenceSystem.fixedTranslation4.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation4.frame_b.R.T[2,3] = referenceSystem.fixedTranslation4.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation4.frame_b.R.T[3,1] = referenceSystem.fixedTranslation4.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation4.frame_b.R.T[3,2] = referenceSystem.fixedTranslation4.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation4.frame_b.R.T[3,3] = referenceSystem.fixedTranslation4.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation4.frame_b.R.w[1] = referenceSystem.fixedTranslation4.frame_a.R.w[1];
//   referenceSystem.fixedTranslation4.frame_b.R.w[2] = referenceSystem.fixedTranslation4.frame_a.R.w[2];
//   referenceSystem.fixedTranslation4.frame_b.R.w[3] = referenceSystem.fixedTranslation4.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation4.frame_a.f[1] + referenceSystem.fixedTranslation4.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation4.frame_a.f[2] + referenceSystem.fixedTranslation4.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation4.frame_a.f[3] + referenceSystem.fixedTranslation4.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation4.frame_a.t[1] + (referenceSystem.fixedTranslation4.frame_b.t[1] + (referenceSystem.fixedTranslation4.r[2] * referenceSystem.fixedTranslation4.frame_b.f[3] + (-referenceSystem.fixedTranslation4.r[3] * referenceSystem.fixedTranslation4.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation4.frame_a.t[2] + (referenceSystem.fixedTranslation4.frame_b.t[2] + (referenceSystem.fixedTranslation4.r[3] * referenceSystem.fixedTranslation4.frame_b.f[1] + (-referenceSystem.fixedTranslation4.r[1] * referenceSystem.fixedTranslation4.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation4.frame_a.t[3] + (referenceSystem.fixedTranslation4.frame_b.t[3] + (referenceSystem.fixedTranslation4.r[1] * referenceSystem.fixedTranslation4.frame_b.f[2] + (-referenceSystem.fixedTranslation4.r[2] * referenceSystem.fixedTranslation4.frame_b.f[1])));
//   referenceSystem.fixedTranslation5.shape.R.T[1,1] = referenceSystem.fixedTranslation5.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation5.shape.R.T[1,2] = referenceSystem.fixedTranslation5.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation5.shape.R.T[1,3] = referenceSystem.fixedTranslation5.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation5.shape.R.T[2,1] = referenceSystem.fixedTranslation5.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation5.shape.R.T[2,2] = referenceSystem.fixedTranslation5.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation5.shape.R.T[2,3] = referenceSystem.fixedTranslation5.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation5.shape.R.T[3,1] = referenceSystem.fixedTranslation5.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation5.shape.R.T[3,2] = referenceSystem.fixedTranslation5.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation5.shape.R.T[3,3] = referenceSystem.fixedTranslation5.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation5.shape.R.w[1] = referenceSystem.fixedTranslation5.frame_a.R.w[1];
//   referenceSystem.fixedTranslation5.shape.R.w[2] = referenceSystem.fixedTranslation5.frame_a.R.w[2];
//   referenceSystem.fixedTranslation5.shape.R.w[3] = referenceSystem.fixedTranslation5.frame_a.R.w[3];
//   referenceSystem.fixedTranslation5.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(referenceSystem.fixedTranslation5.shape.shapeType);
//   referenceSystem.fixedTranslation5.shape.rxvisobj[1] = referenceSystem.fixedTranslation5.shape.R.T[1,1] * referenceSystem.fixedTranslation5.shape.e_x[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,1] * referenceSystem.fixedTranslation5.shape.e_x[2] + referenceSystem.fixedTranslation5.shape.R.T[3,1] * referenceSystem.fixedTranslation5.shape.e_x[3]);
//   referenceSystem.fixedTranslation5.shape.rxvisobj[2] = referenceSystem.fixedTranslation5.shape.R.T[1,2] * referenceSystem.fixedTranslation5.shape.e_x[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,2] * referenceSystem.fixedTranslation5.shape.e_x[2] + referenceSystem.fixedTranslation5.shape.R.T[3,2] * referenceSystem.fixedTranslation5.shape.e_x[3]);
//   referenceSystem.fixedTranslation5.shape.rxvisobj[3] = referenceSystem.fixedTranslation5.shape.R.T[1,3] * referenceSystem.fixedTranslation5.shape.e_x[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,3] * referenceSystem.fixedTranslation5.shape.e_x[2] + referenceSystem.fixedTranslation5.shape.R.T[3,3] * referenceSystem.fixedTranslation5.shape.e_x[3]);
//   referenceSystem.fixedTranslation5.shape.ryvisobj[1] = referenceSystem.fixedTranslation5.shape.R.T[1,1] * referenceSystem.fixedTranslation5.shape.e_y[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,1] * referenceSystem.fixedTranslation5.shape.e_y[2] + referenceSystem.fixedTranslation5.shape.R.T[3,1] * referenceSystem.fixedTranslation5.shape.e_y[3]);
//   referenceSystem.fixedTranslation5.shape.ryvisobj[2] = referenceSystem.fixedTranslation5.shape.R.T[1,2] * referenceSystem.fixedTranslation5.shape.e_y[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,2] * referenceSystem.fixedTranslation5.shape.e_y[2] + referenceSystem.fixedTranslation5.shape.R.T[3,2] * referenceSystem.fixedTranslation5.shape.e_y[3]);
//   referenceSystem.fixedTranslation5.shape.ryvisobj[3] = referenceSystem.fixedTranslation5.shape.R.T[1,3] * referenceSystem.fixedTranslation5.shape.e_y[1] + (referenceSystem.fixedTranslation5.shape.R.T[2,3] * referenceSystem.fixedTranslation5.shape.e_y[2] + referenceSystem.fixedTranslation5.shape.R.T[3,3] * referenceSystem.fixedTranslation5.shape.e_y[3]);
//   referenceSystem.fixedTranslation5.shape.rvisobj = referenceSystem.fixedTranslation5.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{referenceSystem.fixedTranslation5.shape.R.T[1,1],referenceSystem.fixedTranslation5.shape.R.T[1,2],referenceSystem.fixedTranslation5.shape.R.T[1,3]},{referenceSystem.fixedTranslation5.shape.R.T[2,1],referenceSystem.fixedTranslation5.shape.R.T[2,2],referenceSystem.fixedTranslation5.shape.R.T[2,3]},{referenceSystem.fixedTranslation5.shape.R.T[3,1],referenceSystem.fixedTranslation5.shape.R.T[3,2],referenceSystem.fixedTranslation5.shape.R.T[3,3]}},{referenceSystem.fixedTranslation5.shape.r_shape[1],referenceSystem.fixedTranslation5.shape.r_shape[2],referenceSystem.fixedTranslation5.shape.r_shape[3]});
//   referenceSystem.fixedTranslation5.shape.size[1] = referenceSystem.fixedTranslation5.shape.length;
//   referenceSystem.fixedTranslation5.shape.size[2] = referenceSystem.fixedTranslation5.shape.width;
//   referenceSystem.fixedTranslation5.shape.size[3] = referenceSystem.fixedTranslation5.shape.height;
//   referenceSystem.fixedTranslation5.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(referenceSystem.fixedTranslation5.shape.color[1] / 255.0,referenceSystem.fixedTranslation5.shape.color[2] / 255.0,referenceSystem.fixedTranslation5.shape.color[3] / 255.0,referenceSystem.fixedTranslation5.shape.specularCoefficient);
//   referenceSystem.fixedTranslation5.shape.Extra = referenceSystem.fixedTranslation5.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   referenceSystem.fixedTranslation5.frame_b.r_0 = referenceSystem.fixedTranslation5.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(referenceSystem.fixedTranslation5.frame_a.R,{referenceSystem.fixedTranslation5.r[1],referenceSystem.fixedTranslation5.r[2],referenceSystem.fixedTranslation5.r[3]});
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,1] = referenceSystem.fixedTranslation5.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,2] = referenceSystem.fixedTranslation5.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,3] = referenceSystem.fixedTranslation5.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,1] = referenceSystem.fixedTranslation5.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,2] = referenceSystem.fixedTranslation5.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,3] = referenceSystem.fixedTranslation5.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,1] = referenceSystem.fixedTranslation5.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,2] = referenceSystem.fixedTranslation5.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,3] = referenceSystem.fixedTranslation5.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation5.frame_b.R.w[1] = referenceSystem.fixedTranslation5.frame_a.R.w[1];
//   referenceSystem.fixedTranslation5.frame_b.R.w[2] = referenceSystem.fixedTranslation5.frame_a.R.w[2];
//   referenceSystem.fixedTranslation5.frame_b.R.w[3] = referenceSystem.fixedTranslation5.frame_a.R.w[3];
//   0.0 = referenceSystem.fixedTranslation5.frame_a.f[1] + referenceSystem.fixedTranslation5.frame_b.f[1];
//   0.0 = referenceSystem.fixedTranslation5.frame_a.f[2] + referenceSystem.fixedTranslation5.frame_b.f[2];
//   0.0 = referenceSystem.fixedTranslation5.frame_a.f[3] + referenceSystem.fixedTranslation5.frame_b.f[3];
//   0.0 = referenceSystem.fixedTranslation5.frame_a.t[1] + (referenceSystem.fixedTranslation5.frame_b.t[1] + (referenceSystem.fixedTranslation5.r[2] * referenceSystem.fixedTranslation5.frame_b.f[3] + (-referenceSystem.fixedTranslation5.r[3] * referenceSystem.fixedTranslation5.frame_b.f[2])));
//   0.0 = referenceSystem.fixedTranslation5.frame_a.t[2] + (referenceSystem.fixedTranslation5.frame_b.t[2] + (referenceSystem.fixedTranslation5.r[3] * referenceSystem.fixedTranslation5.frame_b.f[1] + (-referenceSystem.fixedTranslation5.r[1] * referenceSystem.fixedTranslation5.frame_b.f[3])));
//   0.0 = referenceSystem.fixedTranslation5.frame_a.t[3] + (referenceSystem.fixedTranslation5.frame_b.t[3] + (referenceSystem.fixedTranslation5.r[1] * referenceSystem.fixedTranslation5.frame_b.f[2] + (-referenceSystem.fixedTranslation5.r[2] * referenceSystem.fixedTranslation5.frame_b.f[1])));
//   referenceSystem.fixedTranslation1.frame_b.t[1] + referenceSystem.pointMass2.frame_a.t[1] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.t[2] + referenceSystem.pointMass2.frame_a.t[2] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.t[3] + referenceSystem.pointMass2.frame_a.t[3] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.f[1] + referenceSystem.pointMass2.frame_a.f[1] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.f[2] + referenceSystem.pointMass2.frame_a.f[2] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.f[3] + referenceSystem.pointMass2.frame_a.f[3] = 0.0;
//   referenceSystem.fixedTranslation1.frame_b.R.w[1] = referenceSystem.pointMass2.frame_a.R.w[1];
//   referenceSystem.fixedTranslation1.frame_b.R.w[2] = referenceSystem.pointMass2.frame_a.R.w[2];
//   referenceSystem.fixedTranslation1.frame_b.R.w[3] = referenceSystem.pointMass2.frame_a.R.w[3];
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,1] = referenceSystem.pointMass2.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,2] = referenceSystem.pointMass2.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[1,3] = referenceSystem.pointMass2.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,1] = referenceSystem.pointMass2.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,2] = referenceSystem.pointMass2.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[2,3] = referenceSystem.pointMass2.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,1] = referenceSystem.pointMass2.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,2] = referenceSystem.pointMass2.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation1.frame_b.R.T[3,3] = referenceSystem.pointMass2.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation1.frame_b.r_0[1] = referenceSystem.pointMass2.frame_a.r_0[1];
//   referenceSystem.fixedTranslation1.frame_b.r_0[2] = referenceSystem.pointMass2.frame_a.r_0[2];
//   referenceSystem.fixedTranslation1.frame_b.r_0[3] = referenceSystem.pointMass2.frame_a.r_0[3];
//   referenceSystem.fixedTranslation.frame_b.t[1] + referenceSystem.pointMass1.frame_a.t[1] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.t[2] + referenceSystem.pointMass1.frame_a.t[2] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.t[3] + referenceSystem.pointMass1.frame_a.t[3] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.f[1] + referenceSystem.pointMass1.frame_a.f[1] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.f[2] + referenceSystem.pointMass1.frame_a.f[2] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.f[3] + referenceSystem.pointMass1.frame_a.f[3] = 0.0;
//   referenceSystem.fixedTranslation.frame_b.R.w[1] = referenceSystem.pointMass1.frame_a.R.w[1];
//   referenceSystem.fixedTranslation.frame_b.R.w[2] = referenceSystem.pointMass1.frame_a.R.w[2];
//   referenceSystem.fixedTranslation.frame_b.R.w[3] = referenceSystem.pointMass1.frame_a.R.w[3];
//   referenceSystem.fixedTranslation.frame_b.R.T[1,1] = referenceSystem.pointMass1.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[1,2] = referenceSystem.pointMass1.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[1,3] = referenceSystem.pointMass1.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,1] = referenceSystem.pointMass1.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,2] = referenceSystem.pointMass1.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[2,3] = referenceSystem.pointMass1.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,1] = referenceSystem.pointMass1.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,2] = referenceSystem.pointMass1.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation.frame_b.R.T[3,3] = referenceSystem.pointMass1.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation.frame_b.r_0[1] = referenceSystem.pointMass1.frame_a.r_0[1];
//   referenceSystem.fixedTranslation.frame_b.r_0[2] = referenceSystem.pointMass1.frame_a.r_0[2];
//   referenceSystem.fixedTranslation.frame_b.r_0[3] = referenceSystem.pointMass1.frame_a.r_0[3];
//   referenceSystem.fixedTranslation5.frame_b.t[1] + referenceSystem.pointMass6.frame_a.t[1] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.t[2] + referenceSystem.pointMass6.frame_a.t[2] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.t[3] + referenceSystem.pointMass6.frame_a.t[3] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.f[1] + referenceSystem.pointMass6.frame_a.f[1] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.f[2] + referenceSystem.pointMass6.frame_a.f[2] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.f[3] + referenceSystem.pointMass6.frame_a.f[3] = 0.0;
//   referenceSystem.fixedTranslation5.frame_b.R.w[1] = referenceSystem.pointMass6.frame_a.R.w[1];
//   referenceSystem.fixedTranslation5.frame_b.R.w[2] = referenceSystem.pointMass6.frame_a.R.w[2];
//   referenceSystem.fixedTranslation5.frame_b.R.w[3] = referenceSystem.pointMass6.frame_a.R.w[3];
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,1] = referenceSystem.pointMass6.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,2] = referenceSystem.pointMass6.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[1,3] = referenceSystem.pointMass6.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,1] = referenceSystem.pointMass6.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,2] = referenceSystem.pointMass6.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[2,3] = referenceSystem.pointMass6.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,1] = referenceSystem.pointMass6.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,2] = referenceSystem.pointMass6.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation5.frame_b.R.T[3,3] = referenceSystem.pointMass6.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation5.frame_b.r_0[1] = referenceSystem.pointMass6.frame_a.r_0[1];
//   referenceSystem.fixedTranslation5.frame_b.r_0[2] = referenceSystem.pointMass6.frame_a.r_0[2];
//   referenceSystem.fixedTranslation5.frame_b.r_0[3] = referenceSystem.pointMass6.frame_a.r_0[3];
//   referenceSystem.pointMass5.frame_a.t[1] + referenceSystem.fixedTranslation4.frame_b.t[1] = 0.0;
//   referenceSystem.pointMass5.frame_a.t[2] + referenceSystem.fixedTranslation4.frame_b.t[2] = 0.0;
//   referenceSystem.pointMass5.frame_a.t[3] + referenceSystem.fixedTranslation4.frame_b.t[3] = 0.0;
//   referenceSystem.pointMass5.frame_a.f[1] + referenceSystem.fixedTranslation4.frame_b.f[1] = 0.0;
//   referenceSystem.pointMass5.frame_a.f[2] + referenceSystem.fixedTranslation4.frame_b.f[2] = 0.0;
//   referenceSystem.pointMass5.frame_a.f[3] + referenceSystem.fixedTranslation4.frame_b.f[3] = 0.0;
//   referenceSystem.pointMass5.frame_a.R.w[1] = referenceSystem.fixedTranslation4.frame_b.R.w[1];
//   referenceSystem.pointMass5.frame_a.R.w[2] = referenceSystem.fixedTranslation4.frame_b.R.w[2];
//   referenceSystem.pointMass5.frame_a.R.w[3] = referenceSystem.fixedTranslation4.frame_b.R.w[3];
//   referenceSystem.pointMass5.frame_a.R.T[1,1] = referenceSystem.fixedTranslation4.frame_b.R.T[1,1];
//   referenceSystem.pointMass5.frame_a.R.T[1,2] = referenceSystem.fixedTranslation4.frame_b.R.T[1,2];
//   referenceSystem.pointMass5.frame_a.R.T[1,3] = referenceSystem.fixedTranslation4.frame_b.R.T[1,3];
//   referenceSystem.pointMass5.frame_a.R.T[2,1] = referenceSystem.fixedTranslation4.frame_b.R.T[2,1];
//   referenceSystem.pointMass5.frame_a.R.T[2,2] = referenceSystem.fixedTranslation4.frame_b.R.T[2,2];
//   referenceSystem.pointMass5.frame_a.R.T[2,3] = referenceSystem.fixedTranslation4.frame_b.R.T[2,3];
//   referenceSystem.pointMass5.frame_a.R.T[3,1] = referenceSystem.fixedTranslation4.frame_b.R.T[3,1];
//   referenceSystem.pointMass5.frame_a.R.T[3,2] = referenceSystem.fixedTranslation4.frame_b.R.T[3,2];
//   referenceSystem.pointMass5.frame_a.R.T[3,3] = referenceSystem.fixedTranslation4.frame_b.R.T[3,3];
//   referenceSystem.pointMass5.frame_a.r_0[1] = referenceSystem.fixedTranslation4.frame_b.r_0[1];
//   referenceSystem.pointMass5.frame_a.r_0[2] = referenceSystem.fixedTranslation4.frame_b.r_0[2];
//   referenceSystem.pointMass5.frame_a.r_0[3] = referenceSystem.fixedTranslation4.frame_b.r_0[3];
//   referenceSystem.fixedTranslation3.frame_b.t[1] + referenceSystem.pointMass4.frame_a.t[1] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.t[2] + referenceSystem.pointMass4.frame_a.t[2] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.t[3] + referenceSystem.pointMass4.frame_a.t[3] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.f[1] + referenceSystem.pointMass4.frame_a.f[1] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.f[2] + referenceSystem.pointMass4.frame_a.f[2] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.f[3] + referenceSystem.pointMass4.frame_a.f[3] = 0.0;
//   referenceSystem.fixedTranslation3.frame_b.R.w[1] = referenceSystem.pointMass4.frame_a.R.w[1];
//   referenceSystem.fixedTranslation3.frame_b.R.w[2] = referenceSystem.pointMass4.frame_a.R.w[2];
//   referenceSystem.fixedTranslation3.frame_b.R.w[3] = referenceSystem.pointMass4.frame_a.R.w[3];
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,1] = referenceSystem.pointMass4.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,2] = referenceSystem.pointMass4.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[1,3] = referenceSystem.pointMass4.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,1] = referenceSystem.pointMass4.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,2] = referenceSystem.pointMass4.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[2,3] = referenceSystem.pointMass4.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,1] = referenceSystem.pointMass4.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,2] = referenceSystem.pointMass4.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation3.frame_b.R.T[3,3] = referenceSystem.pointMass4.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation3.frame_b.r_0[1] = referenceSystem.pointMass4.frame_a.r_0[1];
//   referenceSystem.fixedTranslation3.frame_b.r_0[2] = referenceSystem.pointMass4.frame_a.r_0[2];
//   referenceSystem.fixedTranslation3.frame_b.r_0[3] = referenceSystem.pointMass4.frame_a.r_0[3];
//   referenceSystem.fixedTranslation2.frame_b.t[1] + referenceSystem.pointMass3.frame_a.t[1] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.t[2] + referenceSystem.pointMass3.frame_a.t[2] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.t[3] + referenceSystem.pointMass3.frame_a.t[3] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.f[1] + referenceSystem.pointMass3.frame_a.f[1] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.f[2] + referenceSystem.pointMass3.frame_a.f[2] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.f[3] + referenceSystem.pointMass3.frame_a.f[3] = 0.0;
//   referenceSystem.fixedTranslation2.frame_b.R.w[1] = referenceSystem.pointMass3.frame_a.R.w[1];
//   referenceSystem.fixedTranslation2.frame_b.R.w[2] = referenceSystem.pointMass3.frame_a.R.w[2];
//   referenceSystem.fixedTranslation2.frame_b.R.w[3] = referenceSystem.pointMass3.frame_a.R.w[3];
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,1] = referenceSystem.pointMass3.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,2] = referenceSystem.pointMass3.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[1,3] = referenceSystem.pointMass3.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,1] = referenceSystem.pointMass3.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,2] = referenceSystem.pointMass3.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[2,3] = referenceSystem.pointMass3.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,1] = referenceSystem.pointMass3.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,2] = referenceSystem.pointMass3.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation2.frame_b.R.T[3,3] = referenceSystem.pointMass3.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation2.frame_b.r_0[1] = referenceSystem.pointMass3.frame_a.r_0[1];
//   referenceSystem.fixedTranslation2.frame_b.r_0[2] = referenceSystem.pointMass3.frame_a.r_0[2];
//   referenceSystem.fixedTranslation2.frame_b.r_0[3] = referenceSystem.pointMass3.frame_a.r_0[3];
//   referenceSystem.fixedTranslation5.frame_a.t[1] + (referenceSystem.fixedTranslation3.frame_a.t[1] + (referenceSystem.fixedTranslation1.frame_a.t[1] + (referenceSystem.fixedTranslation.frame_a.t[1] + (referenceSystem.fixedTranslation2.frame_a.t[1] + referenceSystem.fixedTranslation4.frame_a.t[1])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.t[2] + (referenceSystem.fixedTranslation3.frame_a.t[2] + (referenceSystem.fixedTranslation1.frame_a.t[2] + (referenceSystem.fixedTranslation.frame_a.t[2] + (referenceSystem.fixedTranslation2.frame_a.t[2] + referenceSystem.fixedTranslation4.frame_a.t[2])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.t[3] + (referenceSystem.fixedTranslation3.frame_a.t[3] + (referenceSystem.fixedTranslation1.frame_a.t[3] + (referenceSystem.fixedTranslation.frame_a.t[3] + (referenceSystem.fixedTranslation2.frame_a.t[3] + referenceSystem.fixedTranslation4.frame_a.t[3])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.f[1] + (referenceSystem.fixedTranslation3.frame_a.f[1] + (referenceSystem.fixedTranslation1.frame_a.f[1] + (referenceSystem.fixedTranslation.frame_a.f[1] + (referenceSystem.fixedTranslation2.frame_a.f[1] + referenceSystem.fixedTranslation4.frame_a.f[1])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.f[2] + (referenceSystem.fixedTranslation3.frame_a.f[2] + (referenceSystem.fixedTranslation1.frame_a.f[2] + (referenceSystem.fixedTranslation.frame_a.f[2] + (referenceSystem.fixedTranslation2.frame_a.f[2] + referenceSystem.fixedTranslation4.frame_a.f[2])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.f[3] + (referenceSystem.fixedTranslation3.frame_a.f[3] + (referenceSystem.fixedTranslation1.frame_a.f[3] + (referenceSystem.fixedTranslation.frame_a.f[3] + (referenceSystem.fixedTranslation2.frame_a.f[3] + referenceSystem.fixedTranslation4.frame_a.f[3])))) = 0.0;
//   referenceSystem.fixedTranslation5.frame_a.R.w[1] = referenceSystem.fixedTranslation3.frame_a.R.w[1];
//   referenceSystem.fixedTranslation3.frame_a.R.w[1] = referenceSystem.fixedTranslation1.frame_a.R.w[1];
//   referenceSystem.fixedTranslation1.frame_a.R.w[1] = referenceSystem.fixedTranslation.frame_a.R.w[1];
//   referenceSystem.fixedTranslation.frame_a.R.w[1] = referenceSystem.fixedTranslation2.frame_a.R.w[1];
//   referenceSystem.fixedTranslation2.frame_a.R.w[1] = referenceSystem.fixedTranslation4.frame_a.R.w[1];
//   referenceSystem.fixedTranslation5.frame_a.R.w[2] = referenceSystem.fixedTranslation3.frame_a.R.w[2];
//   referenceSystem.fixedTranslation3.frame_a.R.w[2] = referenceSystem.fixedTranslation1.frame_a.R.w[2];
//   referenceSystem.fixedTranslation1.frame_a.R.w[2] = referenceSystem.fixedTranslation.frame_a.R.w[2];
//   referenceSystem.fixedTranslation.frame_a.R.w[2] = referenceSystem.fixedTranslation2.frame_a.R.w[2];
//   referenceSystem.fixedTranslation2.frame_a.R.w[2] = referenceSystem.fixedTranslation4.frame_a.R.w[2];
//   referenceSystem.fixedTranslation5.frame_a.R.w[3] = referenceSystem.fixedTranslation3.frame_a.R.w[3];
//   referenceSystem.fixedTranslation3.frame_a.R.w[3] = referenceSystem.fixedTranslation1.frame_a.R.w[3];
//   referenceSystem.fixedTranslation1.frame_a.R.w[3] = referenceSystem.fixedTranslation.frame_a.R.w[3];
//   referenceSystem.fixedTranslation.frame_a.R.w[3] = referenceSystem.fixedTranslation2.frame_a.R.w[3];
//   referenceSystem.fixedTranslation2.frame_a.R.w[3] = referenceSystem.fixedTranslation4.frame_a.R.w[3];
//   referenceSystem.fixedTranslation5.frame_a.R.T[1,1] = referenceSystem.fixedTranslation3.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation3.frame_a.R.T[1,1] = referenceSystem.fixedTranslation1.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation1.frame_a.R.T[1,1] = referenceSystem.fixedTranslation.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation.frame_a.R.T[1,1] = referenceSystem.fixedTranslation2.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation2.frame_a.R.T[1,1] = referenceSystem.fixedTranslation4.frame_a.R.T[1,1];
//   referenceSystem.fixedTranslation5.frame_a.R.T[1,2] = referenceSystem.fixedTranslation3.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation3.frame_a.R.T[1,2] = referenceSystem.fixedTranslation1.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation1.frame_a.R.T[1,2] = referenceSystem.fixedTranslation.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation.frame_a.R.T[1,2] = referenceSystem.fixedTranslation2.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation2.frame_a.R.T[1,2] = referenceSystem.fixedTranslation4.frame_a.R.T[1,2];
//   referenceSystem.fixedTranslation5.frame_a.R.T[1,3] = referenceSystem.fixedTranslation3.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation3.frame_a.R.T[1,3] = referenceSystem.fixedTranslation1.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation1.frame_a.R.T[1,3] = referenceSystem.fixedTranslation.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation.frame_a.R.T[1,3] = referenceSystem.fixedTranslation2.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation2.frame_a.R.T[1,3] = referenceSystem.fixedTranslation4.frame_a.R.T[1,3];
//   referenceSystem.fixedTranslation5.frame_a.R.T[2,1] = referenceSystem.fixedTranslation3.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation3.frame_a.R.T[2,1] = referenceSystem.fixedTranslation1.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation1.frame_a.R.T[2,1] = referenceSystem.fixedTranslation.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation.frame_a.R.T[2,1] = referenceSystem.fixedTranslation2.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation2.frame_a.R.T[2,1] = referenceSystem.fixedTranslation4.frame_a.R.T[2,1];
//   referenceSystem.fixedTranslation5.frame_a.R.T[2,2] = referenceSystem.fixedTranslation3.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation3.frame_a.R.T[2,2] = referenceSystem.fixedTranslation1.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation1.frame_a.R.T[2,2] = referenceSystem.fixedTranslation.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation.frame_a.R.T[2,2] = referenceSystem.fixedTranslation2.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation2.frame_a.R.T[2,2] = referenceSystem.fixedTranslation4.frame_a.R.T[2,2];
//   referenceSystem.fixedTranslation5.frame_a.R.T[2,3] = referenceSystem.fixedTranslation3.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation3.frame_a.R.T[2,3] = referenceSystem.fixedTranslation1.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation1.frame_a.R.T[2,3] = referenceSystem.fixedTranslation.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation.frame_a.R.T[2,3] = referenceSystem.fixedTranslation2.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation2.frame_a.R.T[2,3] = referenceSystem.fixedTranslation4.frame_a.R.T[2,3];
//   referenceSystem.fixedTranslation5.frame_a.R.T[3,1] = referenceSystem.fixedTranslation3.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation3.frame_a.R.T[3,1] = referenceSystem.fixedTranslation1.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation1.frame_a.R.T[3,1] = referenceSystem.fixedTranslation.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation.frame_a.R.T[3,1] = referenceSystem.fixedTranslation2.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation2.frame_a.R.T[3,1] = referenceSystem.fixedTranslation4.frame_a.R.T[3,1];
//   referenceSystem.fixedTranslation5.frame_a.R.T[3,2] = referenceSystem.fixedTranslation3.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation3.frame_a.R.T[3,2] = referenceSystem.fixedTranslation1.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation1.frame_a.R.T[3,2] = referenceSystem.fixedTranslation.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation.frame_a.R.T[3,2] = referenceSystem.fixedTranslation2.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation2.frame_a.R.T[3,2] = referenceSystem.fixedTranslation4.frame_a.R.T[3,2];
//   referenceSystem.fixedTranslation5.frame_a.R.T[3,3] = referenceSystem.fixedTranslation3.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation3.frame_a.R.T[3,3] = referenceSystem.fixedTranslation1.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation1.frame_a.R.T[3,3] = referenceSystem.fixedTranslation.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation.frame_a.R.T[3,3] = referenceSystem.fixedTranslation2.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation2.frame_a.R.T[3,3] = referenceSystem.fixedTranslation4.frame_a.R.T[3,3];
//   referenceSystem.fixedTranslation5.frame_a.r_0[1] = referenceSystem.fixedTranslation3.frame_a.r_0[1];
//   referenceSystem.fixedTranslation3.frame_a.r_0[1] = referenceSystem.fixedTranslation1.frame_a.r_0[1];
//   referenceSystem.fixedTranslation1.frame_a.r_0[1] = referenceSystem.fixedTranslation.frame_a.r_0[1];
//   referenceSystem.fixedTranslation.frame_a.r_0[1] = referenceSystem.fixedTranslation2.frame_a.r_0[1];
//   referenceSystem.fixedTranslation2.frame_a.r_0[1] = referenceSystem.fixedTranslation4.frame_a.r_0[1];
//   referenceSystem.fixedTranslation5.frame_a.r_0[2] = referenceSystem.fixedTranslation3.frame_a.r_0[2];
//   referenceSystem.fixedTranslation3.frame_a.r_0[2] = referenceSystem.fixedTranslation1.frame_a.r_0[2];
//   referenceSystem.fixedTranslation1.frame_a.r_0[2] = referenceSystem.fixedTranslation.frame_a.r_0[2];
//   referenceSystem.fixedTranslation.frame_a.r_0[2] = referenceSystem.fixedTranslation2.frame_a.r_0[2];
//   referenceSystem.fixedTranslation2.frame_a.r_0[2] = referenceSystem.fixedTranslation4.frame_a.r_0[2];
//   referenceSystem.fixedTranslation5.frame_a.r_0[3] = referenceSystem.fixedTranslation3.frame_a.r_0[3];
//   referenceSystem.fixedTranslation3.frame_a.r_0[3] = referenceSystem.fixedTranslation1.frame_a.r_0[3];
//   referenceSystem.fixedTranslation1.frame_a.r_0[3] = referenceSystem.fixedTranslation.frame_a.r_0[3];
//   referenceSystem.fixedTranslation.frame_a.r_0[3] = referenceSystem.fixedTranslation2.frame_a.r_0[3];
//   referenceSystem.fixedTranslation2.frame_a.r_0[3] = referenceSystem.fixedTranslation4.frame_a.r_0[3];
//   freeMotion.frame_b.t[1] + (fixedTranslation5.frame_a.t[1] + (fixedTranslation3.frame_a.t[1] + (fixedTranslation1.frame_a.t[1] + (fixedTranslation.frame_a.t[1] + (fixedTranslation2.frame_a.t[1] + fixedTranslation4.frame_a.t[1]))))) = 0.0;
//   freeMotion.frame_b.t[2] + (fixedTranslation5.frame_a.t[2] + (fixedTranslation3.frame_a.t[2] + (fixedTranslation1.frame_a.t[2] + (fixedTranslation.frame_a.t[2] + (fixedTranslation2.frame_a.t[2] + fixedTranslation4.frame_a.t[2]))))) = 0.0;
//   freeMotion.frame_b.t[3] + (fixedTranslation5.frame_a.t[3] + (fixedTranslation3.frame_a.t[3] + (fixedTranslation1.frame_a.t[3] + (fixedTranslation.frame_a.t[3] + (fixedTranslation2.frame_a.t[3] + fixedTranslation4.frame_a.t[3]))))) = 0.0;
//   freeMotion.frame_b.f[1] + (fixedTranslation5.frame_a.f[1] + (fixedTranslation3.frame_a.f[1] + (fixedTranslation1.frame_a.f[1] + (fixedTranslation.frame_a.f[1] + (fixedTranslation2.frame_a.f[1] + fixedTranslation4.frame_a.f[1]))))) = 0.0;
//   freeMotion.frame_b.f[2] + (fixedTranslation5.frame_a.f[2] + (fixedTranslation3.frame_a.f[2] + (fixedTranslation1.frame_a.f[2] + (fixedTranslation.frame_a.f[2] + (fixedTranslation2.frame_a.f[2] + fixedTranslation4.frame_a.f[2]))))) = 0.0;
//   freeMotion.frame_b.f[3] + (fixedTranslation5.frame_a.f[3] + (fixedTranslation3.frame_a.f[3] + (fixedTranslation1.frame_a.f[3] + (fixedTranslation.frame_a.f[3] + (fixedTranslation2.frame_a.f[3] + fixedTranslation4.frame_a.f[3]))))) = 0.0;
//   freeMotion.frame_b.R.w[1] = fixedTranslation5.frame_a.R.w[1];
//   fixedTranslation5.frame_a.R.w[1] = fixedTranslation3.frame_a.R.w[1];
//   fixedTranslation3.frame_a.R.w[1] = fixedTranslation1.frame_a.R.w[1];
//   fixedTranslation1.frame_a.R.w[1] = fixedTranslation.frame_a.R.w[1];
//   fixedTranslation.frame_a.R.w[1] = fixedTranslation2.frame_a.R.w[1];
//   fixedTranslation2.frame_a.R.w[1] = fixedTranslation4.frame_a.R.w[1];
//   freeMotion.frame_b.R.w[2] = fixedTranslation5.frame_a.R.w[2];
//   fixedTranslation5.frame_a.R.w[2] = fixedTranslation3.frame_a.R.w[2];
//   fixedTranslation3.frame_a.R.w[2] = fixedTranslation1.frame_a.R.w[2];
//   fixedTranslation1.frame_a.R.w[2] = fixedTranslation.frame_a.R.w[2];
//   fixedTranslation.frame_a.R.w[2] = fixedTranslation2.frame_a.R.w[2];
//   fixedTranslation2.frame_a.R.w[2] = fixedTranslation4.frame_a.R.w[2];
//   freeMotion.frame_b.R.w[3] = fixedTranslation5.frame_a.R.w[3];
//   fixedTranslation5.frame_a.R.w[3] = fixedTranslation3.frame_a.R.w[3];
//   fixedTranslation3.frame_a.R.w[3] = fixedTranslation1.frame_a.R.w[3];
//   fixedTranslation1.frame_a.R.w[3] = fixedTranslation.frame_a.R.w[3];
//   fixedTranslation.frame_a.R.w[3] = fixedTranslation2.frame_a.R.w[3];
//   fixedTranslation2.frame_a.R.w[3] = fixedTranslation4.frame_a.R.w[3];
//   freeMotion.frame_b.R.T[1,1] = fixedTranslation5.frame_a.R.T[1,1];
//   fixedTranslation5.frame_a.R.T[1,1] = fixedTranslation3.frame_a.R.T[1,1];
//   fixedTranslation3.frame_a.R.T[1,1] = fixedTranslation1.frame_a.R.T[1,1];
//   fixedTranslation1.frame_a.R.T[1,1] = fixedTranslation.frame_a.R.T[1,1];
//   fixedTranslation.frame_a.R.T[1,1] = fixedTranslation2.frame_a.R.T[1,1];
//   fixedTranslation2.frame_a.R.T[1,1] = fixedTranslation4.frame_a.R.T[1,1];
//   freeMotion.frame_b.R.T[1,2] = fixedTranslation5.frame_a.R.T[1,2];
//   fixedTranslation5.frame_a.R.T[1,2] = fixedTranslation3.frame_a.R.T[1,2];
//   fixedTranslation3.frame_a.R.T[1,2] = fixedTranslation1.frame_a.R.T[1,2];
//   fixedTranslation1.frame_a.R.T[1,2] = fixedTranslation.frame_a.R.T[1,2];
//   fixedTranslation.frame_a.R.T[1,2] = fixedTranslation2.frame_a.R.T[1,2];
//   fixedTranslation2.frame_a.R.T[1,2] = fixedTranslation4.frame_a.R.T[1,2];
//   freeMotion.frame_b.R.T[1,3] = fixedTranslation5.frame_a.R.T[1,3];
//   fixedTranslation5.frame_a.R.T[1,3] = fixedTranslation3.frame_a.R.T[1,3];
//   fixedTranslation3.frame_a.R.T[1,3] = fixedTranslation1.frame_a.R.T[1,3];
//   fixedTranslation1.frame_a.R.T[1,3] = fixedTranslation.frame_a.R.T[1,3];
//   fixedTranslation.frame_a.R.T[1,3] = fixedTranslation2.frame_a.R.T[1,3];
//   fixedTranslation2.frame_a.R.T[1,3] = fixedTranslation4.frame_a.R.T[1,3];
//   freeMotion.frame_b.R.T[2,1] = fixedTranslation5.frame_a.R.T[2,1];
//   fixedTranslation5.frame_a.R.T[2,1] = fixedTranslation3.frame_a.R.T[2,1];
//   fixedTranslation3.frame_a.R.T[2,1] = fixedTranslation1.frame_a.R.T[2,1];
//   fixedTranslation1.frame_a.R.T[2,1] = fixedTranslation.frame_a.R.T[2,1];
//   fixedTranslation.frame_a.R.T[2,1] = fixedTranslation2.frame_a.R.T[2,1];
//   fixedTranslation2.frame_a.R.T[2,1] = fixedTranslation4.frame_a.R.T[2,1];
//   freeMotion.frame_b.R.T[2,2] = fixedTranslation5.frame_a.R.T[2,2];
//   fixedTranslation5.frame_a.R.T[2,2] = fixedTranslation3.frame_a.R.T[2,2];
//   fixedTranslation3.frame_a.R.T[2,2] = fixedTranslation1.frame_a.R.T[2,2];
//   fixedTranslation1.frame_a.R.T[2,2] = fixedTranslation.frame_a.R.T[2,2];
//   fixedTranslation.frame_a.R.T[2,2] = fixedTranslation2.frame_a.R.T[2,2];
//   fixedTranslation2.frame_a.R.T[2,2] = fixedTranslation4.frame_a.R.T[2,2];
//   freeMotion.frame_b.R.T[2,3] = fixedTranslation5.frame_a.R.T[2,3];
//   fixedTranslation5.frame_a.R.T[2,3] = fixedTranslation3.frame_a.R.T[2,3];
//   fixedTranslation3.frame_a.R.T[2,3] = fixedTranslation1.frame_a.R.T[2,3];
//   fixedTranslation1.frame_a.R.T[2,3] = fixedTranslation.frame_a.R.T[2,3];
//   fixedTranslation.frame_a.R.T[2,3] = fixedTranslation2.frame_a.R.T[2,3];
//   fixedTranslation2.frame_a.R.T[2,3] = fixedTranslation4.frame_a.R.T[2,3];
//   freeMotion.frame_b.R.T[3,1] = fixedTranslation5.frame_a.R.T[3,1];
//   fixedTranslation5.frame_a.R.T[3,1] = fixedTranslation3.frame_a.R.T[3,1];
//   fixedTranslation3.frame_a.R.T[3,1] = fixedTranslation1.frame_a.R.T[3,1];
//   fixedTranslation1.frame_a.R.T[3,1] = fixedTranslation.frame_a.R.T[3,1];
//   fixedTranslation.frame_a.R.T[3,1] = fixedTranslation2.frame_a.R.T[3,1];
//   fixedTranslation2.frame_a.R.T[3,1] = fixedTranslation4.frame_a.R.T[3,1];
//   freeMotion.frame_b.R.T[3,2] = fixedTranslation5.frame_a.R.T[3,2];
//   fixedTranslation5.frame_a.R.T[3,2] = fixedTranslation3.frame_a.R.T[3,2];
//   fixedTranslation3.frame_a.R.T[3,2] = fixedTranslation1.frame_a.R.T[3,2];
//   fixedTranslation1.frame_a.R.T[3,2] = fixedTranslation.frame_a.R.T[3,2];
//   fixedTranslation.frame_a.R.T[3,2] = fixedTranslation2.frame_a.R.T[3,2];
//   fixedTranslation2.frame_a.R.T[3,2] = fixedTranslation4.frame_a.R.T[3,2];
//   freeMotion.frame_b.R.T[3,3] = fixedTranslation5.frame_a.R.T[3,3];
//   fixedTranslation5.frame_a.R.T[3,3] = fixedTranslation3.frame_a.R.T[3,3];
//   fixedTranslation3.frame_a.R.T[3,3] = fixedTranslation1.frame_a.R.T[3,3];
//   fixedTranslation1.frame_a.R.T[3,3] = fixedTranslation.frame_a.R.T[3,3];
//   fixedTranslation.frame_a.R.T[3,3] = fixedTranslation2.frame_a.R.T[3,3];
//   fixedTranslation2.frame_a.R.T[3,3] = fixedTranslation4.frame_a.R.T[3,3];
//   freeMotion.frame_b.r_0[1] = fixedTranslation5.frame_a.r_0[1];
//   fixedTranslation5.frame_a.r_0[1] = fixedTranslation3.frame_a.r_0[1];
//   fixedTranslation3.frame_a.r_0[1] = fixedTranslation1.frame_a.r_0[1];
//   fixedTranslation1.frame_a.r_0[1] = fixedTranslation.frame_a.r_0[1];
//   fixedTranslation.frame_a.r_0[1] = fixedTranslation2.frame_a.r_0[1];
//   fixedTranslation2.frame_a.r_0[1] = fixedTranslation4.frame_a.r_0[1];
//   freeMotion.frame_b.r_0[2] = fixedTranslation5.frame_a.r_0[2];
//   fixedTranslation5.frame_a.r_0[2] = fixedTranslation3.frame_a.r_0[2];
//   fixedTranslation3.frame_a.r_0[2] = fixedTranslation1.frame_a.r_0[2];
//   fixedTranslation1.frame_a.r_0[2] = fixedTranslation.frame_a.r_0[2];
//   fixedTranslation.frame_a.r_0[2] = fixedTranslation2.frame_a.r_0[2];
//   fixedTranslation2.frame_a.r_0[2] = fixedTranslation4.frame_a.r_0[2];
//   freeMotion.frame_b.r_0[3] = fixedTranslation5.frame_a.r_0[3];
//   fixedTranslation5.frame_a.r_0[3] = fixedTranslation3.frame_a.r_0[3];
//   fixedTranslation3.frame_a.r_0[3] = fixedTranslation1.frame_a.r_0[3];
//   fixedTranslation1.frame_a.r_0[3] = fixedTranslation.frame_a.r_0[3];
//   fixedTranslation.frame_a.r_0[3] = fixedTranslation2.frame_a.r_0[3];
//   fixedTranslation2.frame_a.r_0[3] = fixedTranslation4.frame_a.r_0[3];
//   world.frame_b.t[1] + freeMotion.frame_a.t[1] = 0.0;
//   world.frame_b.t[2] + freeMotion.frame_a.t[2] = 0.0;
//   world.frame_b.t[3] + freeMotion.frame_a.t[3] = 0.0;
//   world.frame_b.f[1] + freeMotion.frame_a.f[1] = 0.0;
//   world.frame_b.f[2] + freeMotion.frame_a.f[2] = 0.0;
//   world.frame_b.f[3] + freeMotion.frame_a.f[3] = 0.0;
//   world.frame_b.R.w[1] = freeMotion.frame_a.R.w[1];
//   world.frame_b.R.w[2] = freeMotion.frame_a.R.w[2];
//   world.frame_b.R.w[3] = freeMotion.frame_a.R.w[3];
//   world.frame_b.R.T[1,1] = freeMotion.frame_a.R.T[1,1];
//   world.frame_b.R.T[1,2] = freeMotion.frame_a.R.T[1,2];
//   world.frame_b.R.T[1,3] = freeMotion.frame_a.R.T[1,3];
//   world.frame_b.R.T[2,1] = freeMotion.frame_a.R.T[2,1];
//   world.frame_b.R.T[2,2] = freeMotion.frame_a.R.T[2,2];
//   world.frame_b.R.T[2,3] = freeMotion.frame_a.R.T[2,3];
//   world.frame_b.R.T[3,1] = freeMotion.frame_a.R.T[3,1];
//   world.frame_b.R.T[3,2] = freeMotion.frame_a.R.T[3,2];
//   world.frame_b.R.T[3,3] = freeMotion.frame_a.R.T[3,3];
//   world.frame_b.r_0[1] = freeMotion.frame_a.r_0[1];
//   world.frame_b.r_0[2] = freeMotion.frame_a.r_0[2];
//   world.frame_b.r_0[3] = freeMotion.frame_a.r_0[3];
//   fixedTranslation1.frame_b.t[1] + pointMass2.frame_a.t[1] = 0.0;
//   fixedTranslation1.frame_b.t[2] + pointMass2.frame_a.t[2] = 0.0;
//   fixedTranslation1.frame_b.t[3] + pointMass2.frame_a.t[3] = 0.0;
//   fixedTranslation1.frame_b.f[1] + pointMass2.frame_a.f[1] = 0.0;
//   fixedTranslation1.frame_b.f[2] + pointMass2.frame_a.f[2] = 0.0;
//   fixedTranslation1.frame_b.f[3] + pointMass2.frame_a.f[3] = 0.0;
//   fixedTranslation1.frame_b.R.w[1] = pointMass2.frame_a.R.w[1];
//   fixedTranslation1.frame_b.R.w[2] = pointMass2.frame_a.R.w[2];
//   fixedTranslation1.frame_b.R.w[3] = pointMass2.frame_a.R.w[3];
//   fixedTranslation1.frame_b.R.T[1,1] = pointMass2.frame_a.R.T[1,1];
//   fixedTranslation1.frame_b.R.T[1,2] = pointMass2.frame_a.R.T[1,2];
//   fixedTranslation1.frame_b.R.T[1,3] = pointMass2.frame_a.R.T[1,3];
//   fixedTranslation1.frame_b.R.T[2,1] = pointMass2.frame_a.R.T[2,1];
//   fixedTranslation1.frame_b.R.T[2,2] = pointMass2.frame_a.R.T[2,2];
//   fixedTranslation1.frame_b.R.T[2,3] = pointMass2.frame_a.R.T[2,3];
//   fixedTranslation1.frame_b.R.T[3,1] = pointMass2.frame_a.R.T[3,1];
//   fixedTranslation1.frame_b.R.T[3,2] = pointMass2.frame_a.R.T[3,2];
//   fixedTranslation1.frame_b.R.T[3,3] = pointMass2.frame_a.R.T[3,3];
//   fixedTranslation1.frame_b.r_0[1] = pointMass2.frame_a.r_0[1];
//   fixedTranslation1.frame_b.r_0[2] = pointMass2.frame_a.r_0[2];
//   fixedTranslation1.frame_b.r_0[3] = pointMass2.frame_a.r_0[3];
//   fixedTranslation.frame_b.t[1] + pointMass1.frame_a.t[1] = 0.0;
//   fixedTranslation.frame_b.t[2] + pointMass1.frame_a.t[2] = 0.0;
//   fixedTranslation.frame_b.t[3] + pointMass1.frame_a.t[3] = 0.0;
//   fixedTranslation.frame_b.f[1] + pointMass1.frame_a.f[1] = 0.0;
//   fixedTranslation.frame_b.f[2] + pointMass1.frame_a.f[2] = 0.0;
//   fixedTranslation.frame_b.f[3] + pointMass1.frame_a.f[3] = 0.0;
//   fixedTranslation.frame_b.R.w[1] = pointMass1.frame_a.R.w[1];
//   fixedTranslation.frame_b.R.w[2] = pointMass1.frame_a.R.w[2];
//   fixedTranslation.frame_b.R.w[3] = pointMass1.frame_a.R.w[3];
//   fixedTranslation.frame_b.R.T[1,1] = pointMass1.frame_a.R.T[1,1];
//   fixedTranslation.frame_b.R.T[1,2] = pointMass1.frame_a.R.T[1,2];
//   fixedTranslation.frame_b.R.T[1,3] = pointMass1.frame_a.R.T[1,3];
//   fixedTranslation.frame_b.R.T[2,1] = pointMass1.frame_a.R.T[2,1];
//   fixedTranslation.frame_b.R.T[2,2] = pointMass1.frame_a.R.T[2,2];
//   fixedTranslation.frame_b.R.T[2,3] = pointMass1.frame_a.R.T[2,3];
//   fixedTranslation.frame_b.R.T[3,1] = pointMass1.frame_a.R.T[3,1];
//   fixedTranslation.frame_b.R.T[3,2] = pointMass1.frame_a.R.T[3,2];
//   fixedTranslation.frame_b.R.T[3,3] = pointMass1.frame_a.R.T[3,3];
//   fixedTranslation.frame_b.r_0[1] = pointMass1.frame_a.r_0[1];
//   fixedTranslation.frame_b.r_0[2] = pointMass1.frame_a.r_0[2];
//   fixedTranslation.frame_b.r_0[3] = pointMass1.frame_a.r_0[3];
//   fixedTranslation5.frame_b.t[1] + pointMass6.frame_a.t[1] = 0.0;
//   fixedTranslation5.frame_b.t[2] + pointMass6.frame_a.t[2] = 0.0;
//   fixedTranslation5.frame_b.t[3] + pointMass6.frame_a.t[3] = 0.0;
//   fixedTranslation5.frame_b.f[1] + pointMass6.frame_a.f[1] = 0.0;
//   fixedTranslation5.frame_b.f[2] + pointMass6.frame_a.f[2] = 0.0;
//   fixedTranslation5.frame_b.f[3] + pointMass6.frame_a.f[3] = 0.0;
//   fixedTranslation5.frame_b.R.w[1] = pointMass6.frame_a.R.w[1];
//   fixedTranslation5.frame_b.R.w[2] = pointMass6.frame_a.R.w[2];
//   fixedTranslation5.frame_b.R.w[3] = pointMass6.frame_a.R.w[3];
//   fixedTranslation5.frame_b.R.T[1,1] = pointMass6.frame_a.R.T[1,1];
//   fixedTranslation5.frame_b.R.T[1,2] = pointMass6.frame_a.R.T[1,2];
//   fixedTranslation5.frame_b.R.T[1,3] = pointMass6.frame_a.R.T[1,3];
//   fixedTranslation5.frame_b.R.T[2,1] = pointMass6.frame_a.R.T[2,1];
//   fixedTranslation5.frame_b.R.T[2,2] = pointMass6.frame_a.R.T[2,2];
//   fixedTranslation5.frame_b.R.T[2,3] = pointMass6.frame_a.R.T[2,3];
//   fixedTranslation5.frame_b.R.T[3,1] = pointMass6.frame_a.R.T[3,1];
//   fixedTranslation5.frame_b.R.T[3,2] = pointMass6.frame_a.R.T[3,2];
//   fixedTranslation5.frame_b.R.T[3,3] = pointMass6.frame_a.R.T[3,3];
//   fixedTranslation5.frame_b.r_0[1] = pointMass6.frame_a.r_0[1];
//   fixedTranslation5.frame_b.r_0[2] = pointMass6.frame_a.r_0[2];
//   fixedTranslation5.frame_b.r_0[3] = pointMass6.frame_a.r_0[3];
//   pointMass5.frame_a.t[1] + fixedTranslation4.frame_b.t[1] = 0.0;
//   pointMass5.frame_a.t[2] + fixedTranslation4.frame_b.t[2] = 0.0;
//   pointMass5.frame_a.t[3] + fixedTranslation4.frame_b.t[3] = 0.0;
//   pointMass5.frame_a.f[1] + fixedTranslation4.frame_b.f[1] = 0.0;
//   pointMass5.frame_a.f[2] + fixedTranslation4.frame_b.f[2] = 0.0;
//   pointMass5.frame_a.f[3] + fixedTranslation4.frame_b.f[3] = 0.0;
//   pointMass5.frame_a.R.w[1] = fixedTranslation4.frame_b.R.w[1];
//   pointMass5.frame_a.R.w[2] = fixedTranslation4.frame_b.R.w[2];
//   pointMass5.frame_a.R.w[3] = fixedTranslation4.frame_b.R.w[3];
//   pointMass5.frame_a.R.T[1,1] = fixedTranslation4.frame_b.R.T[1,1];
//   pointMass5.frame_a.R.T[1,2] = fixedTranslation4.frame_b.R.T[1,2];
//   pointMass5.frame_a.R.T[1,3] = fixedTranslation4.frame_b.R.T[1,3];
//   pointMass5.frame_a.R.T[2,1] = fixedTranslation4.frame_b.R.T[2,1];
//   pointMass5.frame_a.R.T[2,2] = fixedTranslation4.frame_b.R.T[2,2];
//   pointMass5.frame_a.R.T[2,3] = fixedTranslation4.frame_b.R.T[2,3];
//   pointMass5.frame_a.R.T[3,1] = fixedTranslation4.frame_b.R.T[3,1];
//   pointMass5.frame_a.R.T[3,2] = fixedTranslation4.frame_b.R.T[3,2];
//   pointMass5.frame_a.R.T[3,3] = fixedTranslation4.frame_b.R.T[3,3];
//   pointMass5.frame_a.r_0[1] = fixedTranslation4.frame_b.r_0[1];
//   pointMass5.frame_a.r_0[2] = fixedTranslation4.frame_b.r_0[2];
//   pointMass5.frame_a.r_0[3] = fixedTranslation4.frame_b.r_0[3];
//   fixedTranslation3.frame_b.t[1] + pointMass4.frame_a.t[1] = 0.0;
//   fixedTranslation3.frame_b.t[2] + pointMass4.frame_a.t[2] = 0.0;
//   fixedTranslation3.frame_b.t[3] + pointMass4.frame_a.t[3] = 0.0;
//   fixedTranslation3.frame_b.f[1] + pointMass4.frame_a.f[1] = 0.0;
//   fixedTranslation3.frame_b.f[2] + pointMass4.frame_a.f[2] = 0.0;
//   fixedTranslation3.frame_b.f[3] + pointMass4.frame_a.f[3] = 0.0;
//   fixedTranslation3.frame_b.R.w[1] = pointMass4.frame_a.R.w[1];
//   fixedTranslation3.frame_b.R.w[2] = pointMass4.frame_a.R.w[2];
//   fixedTranslation3.frame_b.R.w[3] = pointMass4.frame_a.R.w[3];
//   fixedTranslation3.frame_b.R.T[1,1] = pointMass4.frame_a.R.T[1,1];
//   fixedTranslation3.frame_b.R.T[1,2] = pointMass4.frame_a.R.T[1,2];
//   fixedTranslation3.frame_b.R.T[1,3] = pointMass4.frame_a.R.T[1,3];
//   fixedTranslation3.frame_b.R.T[2,1] = pointMass4.frame_a.R.T[2,1];
//   fixedTranslation3.frame_b.R.T[2,2] = pointMass4.frame_a.R.T[2,2];
//   fixedTranslation3.frame_b.R.T[2,3] = pointMass4.frame_a.R.T[2,3];
//   fixedTranslation3.frame_b.R.T[3,1] = pointMass4.frame_a.R.T[3,1];
//   fixedTranslation3.frame_b.R.T[3,2] = pointMass4.frame_a.R.T[3,2];
//   fixedTranslation3.frame_b.R.T[3,3] = pointMass4.frame_a.R.T[3,3];
//   fixedTranslation3.frame_b.r_0[1] = pointMass4.frame_a.r_0[1];
//   fixedTranslation3.frame_b.r_0[2] = pointMass4.frame_a.r_0[2];
//   fixedTranslation3.frame_b.r_0[3] = pointMass4.frame_a.r_0[3];
//   fixedTranslation2.frame_b.t[1] + pointMass3.frame_a.t[1] = 0.0;
//   fixedTranslation2.frame_b.t[2] + pointMass3.frame_a.t[2] = 0.0;
//   fixedTranslation2.frame_b.t[3] + pointMass3.frame_a.t[3] = 0.0;
//   fixedTranslation2.frame_b.f[1] + pointMass3.frame_a.f[1] = 0.0;
//   fixedTranslation2.frame_b.f[2] + pointMass3.frame_a.f[2] = 0.0;
//   fixedTranslation2.frame_b.f[3] + pointMass3.frame_a.f[3] = 0.0;
//   fixedTranslation2.frame_b.R.w[1] = pointMass3.frame_a.R.w[1];
//   fixedTranslation2.frame_b.R.w[2] = pointMass3.frame_a.R.w[2];
//   fixedTranslation2.frame_b.R.w[3] = pointMass3.frame_a.R.w[3];
//   fixedTranslation2.frame_b.R.T[1,1] = pointMass3.frame_a.R.T[1,1];
//   fixedTranslation2.frame_b.R.T[1,2] = pointMass3.frame_a.R.T[1,2];
//   fixedTranslation2.frame_b.R.T[1,3] = pointMass3.frame_a.R.T[1,3];
//   fixedTranslation2.frame_b.R.T[2,1] = pointMass3.frame_a.R.T[2,1];
//   fixedTranslation2.frame_b.R.T[2,2] = pointMass3.frame_a.R.T[2,2];
//   fixedTranslation2.frame_b.R.T[2,3] = pointMass3.frame_a.R.T[2,3];
//   fixedTranslation2.frame_b.R.T[3,1] = pointMass3.frame_a.R.T[3,1];
//   fixedTranslation2.frame_b.R.T[3,2] = pointMass3.frame_a.R.T[3,2];
//   fixedTranslation2.frame_b.R.T[3,3] = pointMass3.frame_a.R.T[3,3];
//   fixedTranslation2.frame_b.r_0[1] = pointMass3.frame_a.r_0[1];
//   fixedTranslation2.frame_b.r_0[2] = pointMass3.frame_a.r_0[2];
//   fixedTranslation2.frame_b.r_0[3] = pointMass3.frame_a.r_0[3];
// end Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2 completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2 has 4066 equation(s) and 4074 variable(s).
// 2553 of these are trivial equation(s).
// "
// ""
// 0
// endResult
