// name:     Modelica3.x.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses
// keywords: multibody, balancing, instantiation
// status:   correct
// 
//  Modelica MultiBody 3.x: instantiation and balance checking of the LineForceWithTwoMasses model
//

loadFile("_ElementaryTotal.mo");
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses);
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses);
getErrorString();
system("rm -f *.so *.dll *.log *.c* *.makefile *.libs");

// Result:
// true
// ""
// "function Modelica.Math.Vectors.length "Inline before index reduction"
//   input Real[:] v "Vector";
//   output Real result "Length of vector v";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize "Inline before index reduction"
//   input Real[:] v "Vector";
//   input Real eps = 1e-13 "if |v| < eps then result = v/eps";
//   output Real[size(v,1)] result "Input vector v normalized to length=1";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses.world.gravityAcceleration
//   input Real[3] r(quantity = "Length", unit = "m") "Position vector from world frame to actual point, resolved in world frame";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType "Type of gravity field";
//   input Real[3] g(quantity = "Acceleration", unit = "m/s2") "Constant gravity acceleration, resolved in world frame, if gravityType=1";
//   input Real mue(unit = "m3/s2") "Field constant of point gravity field, if gravityType=2";
//   output Real[3] gravity(quantity = "Acceleration", unit = "m/s2") "Gravity acceleration at point r, resolved in world frame";
// algorithm
//   gravity := if gravityType == GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses.world.gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent
//   input Real u1;
//   input Real u2;
//   output Real y;
//   protected Integer dummy;
// algorithm
//   y := if u1 > u2 then u1 else u2;
//   dummy := 0;
// end Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d
//   input Real u1;
//   input Real u2;
//   input Real u1_d;
//   input Real u2_d;
//   output Real y_d;
//   protected Integer dummy;
// algorithm
//   y_d := if u1 > u2 then u1_d else u2_d;
//   dummy := 0;
// end Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd
//   input Real u1;
//   input Real u2;
//   input Real u1_d;
//   input Real u2_d;
//   input Real u1_dd;
//   input Real u2_dd;
//   output Real y_dd;
// algorithm
//   y_dd := if u1 > u2 then u1_dd else u2_dd;
// end Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector resolved in frame 2";
//   input Real[3] v2_der "= der(v2)";
//   output Real[3] v1_der "Derivative of vector v resolved in frame 1";
// algorithm
//   v1_der := Modelica.Mechanics.MultiBody.Frames.resolve1(R,{v2_der[1] + R.w[2] * v2[3] - R.w[3] * v2[2],v2_der[2] + R.w[3] * v2[1] - R.w[1] * v2[3],v2_der[3] + R.w[1] * v2[2] - R.w[2] * v2[1]});
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector resolved in frame 1";
//   input Real[3] v1_der "= der(v1)";
//   output Real[3] v2_der "Derivative of vector v resolved in frame 2";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1_der[1],v1_der[2],v1_der[3]}) - cross({R.w[1],R.w[2],R.w[3]},Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der "Inline before index reduction"
//   input Real[3] v1 "Vector in frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
//   input Real[3] v1_der "= der(v1)";
//   output Real[3] v2_der "Derivative of vector v resolved in frame 2";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolveRelative({v1_der[1] + R1.w[2] * v1[3] - R1.w[3] * v1[2],v1_der[2] + R1.w[3] * v1[1] - R1.w[1] * v1[3],v1_der[3] + R1.w[1] * v1[2] - R1.w[2] * v1[1]},R1,R2) - cross({R2.w[1],R2.w[2],R2.w[3]},Modelica.Mechanics.MultiBody.Frames.resolveRelative({v1[1],v1[2],v1[3]},R1,R2));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation "Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation"
// input Real[3, 3] T;
// input Real(quantity="AngularVelocity", unit="rad/s")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
//   output Real[3] residue "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
// algorithm
//   residue := {Modelica.Math.atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),Modelica.Math.atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),Modelica.Math.atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2 "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   input Real[4] der_Q(unit = "1/s") "Derivative of Q";
//   output Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
// algorithm
//   w := {2.0 * (Q[4] * der_Q[1] + Q[3] * der_Q[2] + -Q[2] * der_Q[3] + -Q[1] * der_Q[4]),2.0 * (-Q[3] * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + -Q[2] * der_Q[4]),2.0 * (Q[2] * der_Q[1] + -Q[1] * der_Q[2] + Q[4] * der_Q[3] + -Q[3] * der_Q[4])};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T
//   input Real[3, 3] T "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} "Guess value for Q (there are 2 solutions; the one close to Q_guess is used";
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := (1.0 + T[1,1]) - T[2,2] - T[3,3];
//   c2 := (1.0 + T[2,2]) - T[1,1] - T[3,3];
//   c3 := (1.0 + T[3,3]) - T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 OR c4 > c1 AND c4 > c2 AND c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 AND c1 > c3 AND c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 AND c2 > c3 AND c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation "Inline before index reduction"
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   output Real[1] residue "Residue constraint (shall be zero)";
// algorithm
//   residue := {(Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation "Inline before index reduction"
//   input Real[3, 3] T1 "Orientation object to rotate frame 0 into frame 1";
//   input Real[3, 3] T_rel "Orientation object to rotate frame 1 into frame 2";
//   output Real[3, 3] T2 "Orientation object to rotate frame 0 into frame 2";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation "Inline before index reduction"
//   input Integer axis(min = 1, max = 3) "Rotate around 'axis' of frame 1";
//   input Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,Modelica.Math.cos(angle),Modelica.Math.sin(angle);0.0,-Modelica.Math.sin(angle),Modelica.Math.cos(angle)] else if axis == 2 then <matrix>[Modelica.Math.cos(angle),0.0,-Modelica.Math.sin(angle);0.0,1.0,0.0;Modelica.Math.sin(angle),0.0,Modelica.Math.cos(angle)] else <matrix>[Modelica.Math.cos(angle),Modelica.Math.sin(angle),0.0;-Modelica.Math.sin(angle),Modelica.Math.cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy
//   input Real[3] n_x(unit = "1") "Vector in direction of x-axis of frame 2, resolved in frame 1";
//   input Real[3] n_y(unit = "1") "Vector in direction of y-axis of frame 2, resolved in frame 1";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = "1") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = "1") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = "1") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = "1") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = "1") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation "Inline before index reduction"
//   input Real[3] e(unit = "1") "Normalized axis of rotation (must have length=1)";
//   input Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along axis e";
//   output Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   T := <matrix>[e[1] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + Modelica.Math.cos(angle) * -e[1] * e[2]) - -Modelica.Math.sin(angle) * e[3],(e[1] * e[3] + Modelica.Math.cos(angle) * -e[1] * e[3]) - Modelica.Math.sin(angle) * e[2];(e[2] * e[1] + Modelica.Math.cos(angle) * -e[2] * e[1]) - Modelica.Math.sin(angle) * e[3],e[2] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + Modelica.Math.cos(angle) * -e[2] * e[3]) - -Modelica.Math.sin(angle) * e[1];(e[3] * e[1] + Modelica.Math.cos(angle) * -e[3] * e[1]) - -Modelica.Math.sin(angle) * e[2],(e[3] * e[2] + Modelica.Math.cos(angle) * -e[3] * e[2]) - Modelica.Math.sin(angle) * e[1],e[3] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[3] ^ 2.0)];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 "Inline before index reduction"
//   input Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector in frame 2";
//   output Real[3] v1 "Vector in frame 1";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2 "Inline before index reduction"
//   input Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector in frame 1";
//   output Real[3] v2 "Vector in frame 2";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel "Orientation object to rotate frame 1 into frame 2";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   output Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of frame 2 with respect to frame 1 resolved in frame 2";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations "Inline before index reduction"
//   input Integer[3] sequence = {1,2,3} "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
//   input Real[3] angles(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angles around the axes defined in 'sequence'";
//   input Real[3] der_angles(quantity = "AngularVelocity", unit = "rad/s") "= der(angles)";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Integer[3] sequence = {1,2,3} "Sequence of rotations from frame 1 to frame 2 along axis sequence[i]";
//   input Real guessAngle1(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Select angles[1] such that |angles[1] - guessAngle1| is a minimum";
//   output Real[3] angles(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi";
//   protected Real[3] e1_1(unit = "1") "First rotation axis, resolved in frame 1";
//   protected Real[3] e2_1a(unit = "1") "Second rotation axis, resolved in frame 1a";
//   protected Real[3] e3_1(unit = "1") "Third rotation axis, resolved in frame 1";
//   protected Real[3] e3_2(unit = "1") "Third rotation axis, resolved in frame 2";
//   protected Real A "Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
//   protected Real B "Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0";
//   protected Real angle_1a(quantity = "Angle", unit = "rad", displayUnit = "deg") "Solution 1 for angles[1]";
//   protected Real angle_1b(quantity = "Angle", unit = "rad", displayUnit = "deg") "Solution 2 for angles[1]";
//   protected Real[3, 3] T_1a "Orientation object to rotate frame 1 into frame 1a";
// algorithm
//   assert( sequence[1] <> sequence[2] AND sequence[2] <> sequence[3], "input argument 'sequence[1:3]' is not valid");
//   e1_1 := /*/tp:REAL[3]/*/(if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,1,0} else {0,0,1});
//   e2_1a := /*/tp:REAL[3]/*/(if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {0,1,0} else {0,0,1});
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := /*/tp:REAL[3]/*/(if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,1,0} else {0,0,1});
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 AND abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := Modelica.Math.atan2(A,-B);
//     angle_1b := Modelica.Math.atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis "Inline before index reduction"
//   input Integer axis(min = 1, max = 3) "Axis vector to be returned";
//   output Real[3] e(unit = "1") "Unit axis vector";
// algorithm
//   e := /*/tp:REAL[3]/*/(if axis == 1 then {1,0,0} else if axis == 2 then {0,1,0} else {0,0,1});
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q "Inline before index reduction"
//   input Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
//   input Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity from frame 2 with respect to frame 1, resolved in frame 2";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[1] * Q[2] + Q[3] * Q[4]),2.0 * (Q[1] * Q[3] - Q[2] * Q[4]);2.0 * (Q[2] * Q[1] - Q[3] * Q[4]),2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[2] * Q[3] + Q[1] * Q[4]);2.0 * (Q[3] * Q[1] + Q[2] * Q[4]),2.0 * (Q[3] * Q[2] - Q[1] * Q[4]),2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_T "Inline before index reduction"
//   input Real[3, 3] T "Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)";
//   input Real[3] w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity from frame 2 with respect to frame 1, resolved in frame 2 (skew(w)=T*der(transpose(T)))";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[T[1,1],T[1,2],T[1,3];T[2,1],T[2,2],T[2,3];T[3,1],T[3,2],T[3,3]],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_nxy
//   input Real[3] n_x(unit = "1") "Vector in direction of x-axis of frame 2, resolved in frame 1";
//   input Real[3] n_y(unit = "1") "Vector in direction of y-axis of frame 2, resolved in frame 1";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = "1") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = "1") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = "1") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = "1") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = "1") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation "Inline before index reduction"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object such that frame 1 and frame 2 are identical";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation "Inline before index reduction"
//   input Real[3] e(unit = "1") "Normalized axis of rotation (must have length=1)";
//   input Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along axis e";
//   input Real der_angle(quantity = "AngularVelocity", unit = "rad/s") "= der(angle)";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + Modelica.Math.cos(angle) * -e[1] * e[2]) - -Modelica.Math.sin(angle) * e[3],(e[1] * e[3] + Modelica.Math.cos(angle) * -e[1] * e[3]) - Modelica.Math.sin(angle) * e[2];(e[2] * e[1] + Modelica.Math.cos(angle) * -e[2] * e[1]) - Modelica.Math.sin(angle) * e[3],e[2] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + Modelica.Math.cos(angle) * -e[2] * e[3]) - -Modelica.Math.sin(angle) * e[1];(e[3] * e[1] + Modelica.Math.cos(angle) * -e[3] * e[1]) - -Modelica.Math.sin(angle) * e[2],(e[3] * e[2] + Modelica.Math.cos(angle) * -e[3] * e[2]) - Modelica.Math.sin(angle) * e[1],e[3] ^ 2.0 + Modelica.Math.cos(angle) * (1.0 - e[3] ^ 2.0)],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle "Inline before index reduction"
//   input Real[3] e(unit = "1") "Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)";
//   input Real[3] v1 "A vector v resolved in frame 1 (shall not be parallel to e)";
//   input Real[3] v2 "Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)";
//   output Real angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi";
// algorithm
//   angle := Modelica.Math.atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],(v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3]) - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1 "Inline after index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector in frame 2";
//   output Real[3] v1 "Vector in frame 1";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2 "Inline after index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v1 "Vector in frame 1";
//   output Real[3] v2 "Vector in frame 2";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolveDyade1 "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[3, 3] D2 "Second order tensor resolved in frame 2";
//   output Real[3, 3] D1 "Second order tensor resolved in frame 1";
// algorithm
//   D1 := <matrix>[(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,1] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,1] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,1],(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,2] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,2] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,2],(R.T[1,1] * D2[1,1] + R.T[2,1] * D2[2,1] + R.T[3,1] * D2[3,1]) * R.T[1,3] + (R.T[1,1] * D2[1,2] + R.T[2,1] * D2[2,2] + R.T[3,1] * D2[3,2]) * R.T[2,3] + (R.T[1,1] * D2[1,3] + R.T[2,1] * D2[2,3] + R.T[3,1] * D2[3,3]) * R.T[3,3];(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,1] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,1] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,1],(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,2] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,2] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,2],(R.T[1,2] * D2[1,1] + R.T[2,2] * D2[2,1] + R.T[3,2] * D2[3,1]) * R.T[1,3] + (R.T[1,2] * D2[1,2] + R.T[2,2] * D2[2,2] + R.T[3,2] * D2[3,2]) * R.T[2,3] + (R.T[1,2] * D2[1,3] + R.T[2,2] * D2[2,3] + R.T[3,2] * D2[3,3]) * R.T[3,3];(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,1] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,1] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,1],(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,2] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,2] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,2],(R.T[1,3] * D2[1,1] + R.T[2,3] * D2[2,1] + R.T[3,3] * D2[3,1]) * R.T[1,3] + (R.T[1,3] * D2[1,2] + R.T[2,3] * D2[2,2] + R.T[3,3] * D2[3,2]) * R.T[2,3] + (R.T[1,3] * D2[1,3] + R.T[2,3] * D2[2,3] + R.T[3,3] * D2[3,3]) * R.T[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.resolveDyade1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolveRelative "Inline after index reduction"
//   input Real[3] v1 "Vector in frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 "Orientation object to rotate frame 0 into frame 1";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 "Orientation object to rotate frame 0 into frame 2";
//   output Real[3] v2 "Vector in frame 2";
// algorithm
//   v2 := Modelica.Mechanics.MultiBody.Frames.resolve2(R2,Modelica.Mechanics.MultiBody.Frames.resolve1(R1,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.resolveRelative;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q "Inline before index reduction"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object to rotate frame 1 into frame 2";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} "Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used";
//   output Real[4] Q "Quaternions orientation object to rotate frame 1 into frame 2";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration
//   input Real[3] r(quantity = "Length", unit = "m") "Position vector from world frame to actual point, resolved in world frame";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType "Type of gravity field";
//   input Real[3] g(quantity = "Acceleration", unit = "m/s2") "Constant gravity acceleration, resolved in world frame, if gravityType=1";
//   input Real mue(unit = "m3/s2") "Field constant of point gravity field, if gravityType=2";
//   output Real[3] gravity(quantity = "Acceleration", unit = "m/s2") "Gravity acceleration at point r, resolved in world frame";
// algorithm
//   gravity := if gravityType == GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial "Inline before index reduction"
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape "Inline before index reduction"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses
//   Real world.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real world.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real world.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real world.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real world.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real world.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real world.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean world.enableAnimation = true "= true, if animation of all components is enabled";
//   parameter Boolean world.animateWorld = true "= true, if world coordinate system shall be visualized";
//   parameter Boolean world.animateGravity = true "= true, if gravity field shall be visualized (acceleration vector or field center)";
//   parameter String world.label1 = "x" "Label of horizontal axis in icon";
//   parameter String world.label2 = "y" "Label of vertical axis in icon";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = GravityTypes.UniformGravity "Type of gravity field";
//   parameter Real world.g(quantity = "Acceleration", unit = "m/s2") = 9.81 "Constant gravity acceleration";
//   parameter Real world.n[1](unit = "1") = 0.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.n[2](unit = "1") = -1.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.n[3](unit = "1") = 0.0 "Direction of gravity resolved in world frame (gravity = g*n/length(n))";
//   parameter Real world.mue(unit = "m3/s2", min = 0.0) = 398600000000000.0 "Gravity field constant (default = field constant of earth)";
//   parameter Boolean world.driveTrainMechanics3D = true "= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account";
//   parameter Real world.axisLength(quantity = "Length", unit = "m", min = 0.0) = world.nominalLength / 2.0 "Length of world axes arrows";
//   parameter Real world.axisDiameter(quantity = "Length", unit = "m", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction "Diameter of world axes arrows";
//   parameter Boolean world.axisShowLabels = true "= true, if labels shall be shown";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 "Color of x-arrow";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] "Color of z-arrow";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] "Color of z-arrow";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] "Color of z-arrow";
//   parameter Real world.gravityArrowTail[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowTail[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowTail[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to arrow tail, resolved in world frame";
//   parameter Real world.gravityArrowLength(quantity = "Length", unit = "m") = world.axisLength / 2.0 "Length of gravity arrow";
//   parameter Real world.gravityArrowDiameter(quantity = "Length", unit = "m", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction "Diameter of gravity arrow";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 "Color of gravity arrow";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 "Color of gravity arrow";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 "Color of gravity arrow";
//   parameter Real world.gravitySphereDiameter(quantity = "Length", unit = "m", min = 0.0) = 12742000.0 "Diameter of sphere representing gravity center (default = mean diameter of earth)";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 "Color of gravity sphere";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 "Color of gravity sphere";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 "Color of gravity sphere";
//   parameter Real world.nominalLength(quantity = "Length", unit = "m") = 1.0 "\"Nominal\" length of multi-body system";
//   parameter Real world.defaultAxisLength(quantity = "Length", unit = "m") = world.nominalLength / 5.0 "Default for length of a frame axis (but not world frame)";
//   parameter Real world.defaultJointLength(quantity = "Length", unit = "m") = world.nominalLength / 10.0 "Default for the fixed length of a shape representing a joint";
//   parameter Real world.defaultJointWidth(quantity = "Length", unit = "m") = world.nominalLength / 20.0 "Default for the fixed width of a shape representing a joint";
//   parameter Real world.defaultForceLength(quantity = "Length", unit = "m") = world.nominalLength / 10.0 "Default for the fixed length of a shape representing a force (e.g. damper)";
//   parameter Real world.defaultForceWidth(quantity = "Length", unit = "m") = world.nominalLength / 20.0 "Default for the fixed width of a shape represening a force (e.g. spring, bushing)";
//   parameter Real world.defaultBodyDiameter(quantity = "Length", unit = "m") = world.nominalLength / 9.0 "Default for diameter of sphere representing the center of mass of a body";
//   parameter Real world.defaultWidthFraction = 20.0 "Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)";
//   parameter Real world.defaultArrowDiameter(quantity = "Length", unit = "m") = world.nominalLength / 40.0 "Default for arrow diameter (e.g., of forces, torques, sensors)";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 "Default for arrow diameter of a coordinate system as a fraction of axis length";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 "Default reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Real world.defaultN_to_m(unit = "N/m", min = 0.0) = 1000.0 "Default scaling of force arrows (length = force/defaultN_to_m)";
//   parameter Real world.defaultNm_to_m(unit = "N.m/m", min = 0.0) = 1000.0 "Default scaling of torque arrows (length = torque/defaultNm_to_m)";
//   protected parameter Integer world.ndim = if world.enableAnimation AND world.animateWorld then 1 else 0;
//   protected parameter Integer world.ndim2 = if world.enableAnimation AND world.animateWorld AND world.axisShowLabels then 1 else 0;
//   protected parameter Real world.headLength(quantity = "Length", unit = "m") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = "Length", unit = "m") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineLength(quantity = "Length", unit = "m") = max(0.0,world.axisLength - world.headLength);
//   protected parameter Real world.lineWidth(quantity = "Length", unit = "m") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = "Length", unit = "m") = 3.0 * world.axisDiameter;
//   protected parameter Real world.labelStart(quantity = "Length", unit = "m") = 1.05 * world.axisLength;
//   parameter String world.x_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.x_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.x_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.x_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) "Color of shape";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) "Color of shape";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) "Color of shape";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = "1") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = "1") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = "1") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = "1") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_arrowHead.r[1](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.x_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.x_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.x_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) "Color of shape";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) "Color of shape";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) "Color of shape";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = "1") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = "1") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = "1") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = "1") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   input Real world.x_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.x_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.r_lines[1](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.r_lines[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.r_lines[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[1](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[2](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_x[3](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[1](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[2](unit = "1") = 1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.x_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[1,2,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.lines[2,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.x_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] "Color of cylinders";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] "Color of cylinders";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] "Color of cylinders";
//   input Real world.x_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.x_label.n = 2 "Number of cylinders";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][3];
//   protected Real world.x_label.r_abs[1](quantity = "Length", unit = "m") = world.x_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[1];
//   protected Real world.x_label.r_abs[2](quantity = "Length", unit = "m") = world.x_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[2];
//   protected Real world.x_label.r_abs[3](quantity = "Length", unit = "m") = world.x_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[3];
//   parameter String world.x_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.x_label.cylinders[1].width(quantity = "Length", unit = "m") = world.x_label.diameter "Width of visual object";
//   input Real world.x_label.cylinders[1].height(quantity = "Length", unit = "m") = world.x_label.diameter "Height of visual object";
//   input Real world.x_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) "Color of shape";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) "Color of shape";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) "Color of shape";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = "1") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = "1") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = "1") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.x_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.x_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.x_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.x_label.cylinders[2].width(quantity = "Length", unit = "m") = world.x_label.diameter "Width of visual object";
//   input Real world.x_label.cylinders[2].height(quantity = "Length", unit = "m") = world.x_label.diameter "Height of visual object";
//   input Real world.x_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) "Color of shape";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) "Color of shape";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) "Color of shape";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = "1") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = "1") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = "1") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   parameter String world.y_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[2](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[1](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[2](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.y_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.y_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.y_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) "Color of shape";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) "Color of shape";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) "Color of shape";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = "1") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = "1") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = "1") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = "1") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_arrowHead.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r[2](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[2](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[1](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[2](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.y_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.y_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.y_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) "Color of shape";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) "Color of shape";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) "Color of shape";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = "1") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = "1") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = "1") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = "1") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   input Real world.y_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.y_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.r_lines[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.r_lines[2](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.r_lines[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[1](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[2](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_x[3](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[1](unit = "1") = -1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[2](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.y_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[1,2,2](quantity = "Length", unit = "m") = 1.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,1,2](quantity = "Length", unit = "m") = 1.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,2,1](quantity = "Length", unit = "m") = 0.5 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.lines[2,2,2](quantity = "Length", unit = "m") = 0.75 * world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.y_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] "Color of cylinders";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] "Color of cylinders";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] "Color of cylinders";
//   input Real world.y_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.y_label.n = 2 "Number of cylinders";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][3];
//   protected Real world.y_label.r_abs[1](quantity = "Length", unit = "m") = world.y_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[1];
//   protected Real world.y_label.r_abs[2](quantity = "Length", unit = "m") = world.y_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[2];
//   protected Real world.y_label.r_abs[3](quantity = "Length", unit = "m") = world.y_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[3];
//   parameter String world.y_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.y_label.cylinders[1].width(quantity = "Length", unit = "m") = world.y_label.diameter "Width of visual object";
//   input Real world.y_label.cylinders[1].height(quantity = "Length", unit = "m") = world.y_label.diameter "Height of visual object";
//   input Real world.y_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) "Color of shape";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) "Color of shape";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) "Color of shape";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = "1") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = "1") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = "1") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.y_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.y_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.y_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.y_label.cylinders[2].width(quantity = "Length", unit = "m") = world.y_label.diameter "Width of visual object";
//   input Real world.y_label.cylinders[2].height(quantity = "Length", unit = "m") = world.y_label.diameter "Height of visual object";
//   input Real world.y_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) "Color of shape";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) "Color of shape";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) "Color of shape";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = "1") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = "1") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = "1") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   parameter String world.z_arrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowLine.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.lengthDirection[3](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowLine.length(quantity = "Length", unit = "m") = world.lineLength "Length of visual object";
//   input Real world.z_arrowLine.width(quantity = "Length", unit = "m") = world.lineWidth "Width of visual object";
//   input Real world.z_arrowLine.height(quantity = "Length", unit = "m") = world.lineWidth "Height of visual object";
//   input Real world.z_arrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) "Color of shape";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) "Color of shape";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) "Color of shape";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_arrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = "1") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = "1") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = "1") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = "1") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_arrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_arrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_arrowHead.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r[3](quantity = "Length", unit = "m") = world.lineLength "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_arrowHead.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[1](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.lengthDirection[3](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_arrowHead.length(quantity = "Length", unit = "m") = world.headLength "Length of visual object";
//   input Real world.z_arrowHead.width(quantity = "Length", unit = "m") = world.headWidth "Width of visual object";
//   input Real world.z_arrowHead.height(quantity = "Length", unit = "m") = world.headWidth "Height of visual object";
//   input Real world.z_arrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) "Color of shape";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) "Color of shape";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) "Color of shape";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_arrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = "1") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = "1") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = "1") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = "1") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_arrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_arrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   input Real world.z_label.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.z_label.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.r_lines[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.r_lines[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.r_lines[3](quantity = "Length", unit = "m") = world.labelStart "Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[1](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[2](unit = "1") = 0.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_x[3](unit = "1") = 1.0 "Vector in direction of x-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[1](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[2](unit = "1") = 1.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.n_y[3](unit = "1") = 0.0 "Vector in direction of y-axis of 'lines' frame, resolved in object frame";
//   input Real world.z_label.lines[1,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,1,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[1,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[2,2,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,1,1](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,1,2](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,2,1](quantity = "Length", unit = "m") = world.scaledLabel "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.lines[3,2,2](quantity = "Length", unit = "m") = 0.0 "List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}";
//   input Real world.z_label.diameter(quantity = "Length", unit = "m", min = 0.0) = world.axisDiameter "Diameter of the cylinders defined by lines";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] "Color of cylinders";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] "Color of cylinders";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] "Color of cylinders";
//   input Real world.z_label.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected parameter Integer world.z_label.n = 3 "Number of cylinders";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][3];
//   protected Real world.z_label.r_abs[1](quantity = "Length", unit = "m") = world.z_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[1];
//   protected Real world.z_label.r_abs[2](quantity = "Length", unit = "m") = world.z_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[2];
//   protected Real world.z_label.r_abs[3](quantity = "Length", unit = "m") = world.z_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[3];
//   parameter String world.z_label.cylinders[1].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[1].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[1].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[1].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[1].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[1].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[1].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = "1") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = "1") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = "1") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[2].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[2].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[2].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[2].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[2].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[2].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = "1") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = "1") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = "1") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.z_label.cylinders[3].R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.z_label.cylinders[3].r[1](quantity = "Length", unit = "m") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r[2](quantity = "Length", unit = "m") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r[3](quantity = "Length", unit = "m") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = "1") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] "Vector in length direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.z_label.cylinders[3].length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) "Length of visual object";
//   input Real world.z_label.cylinders[3].width(quantity = "Length", unit = "m") = world.z_label.diameter "Width of visual object";
//   input Real world.z_label.cylinders[3].height(quantity = "Length", unit = "m") = world.z_label.diameter "Height of visual object";
//   input Real world.z_label.cylinders[3].extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) "Color of shape";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) "Color of shape";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) "Color of shape";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = "1") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = "1") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = "1") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = "1") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Real world.gravityHeadLength(quantity = "Length", unit = "m") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = "Length", unit = "m") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = "Length", unit = "m") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   parameter String world.gravityArrowLine.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.gravityArrowLine.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowLine.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowLine.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowLine.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowLine.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowLine.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowLine.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowLine.r_shape[1](quantity = "Length", unit = "m") = world.gravityArrowTail[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowLine.r_shape[2](quantity = "Length", unit = "m") = world.gravityArrowTail[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowLine.r_shape[3](quantity = "Length", unit = "m") = world.gravityArrowTail[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowLine.lengthDirection[1](unit = "1") = world.n[1] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowLine.lengthDirection[2](unit = "1") = world.n[2] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowLine.lengthDirection[3](unit = "1") = world.n[3] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowLine.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowLine.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowLine.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowLine.length(quantity = "Length", unit = "m") = world.gravityLineLength "Length of visual object";
//   input Real world.gravityArrowLine.width(quantity = "Length", unit = "m") = world.gravityArrowDiameter "Width of visual object";
//   input Real world.gravityArrowLine.height(quantity = "Length", unit = "m") = world.gravityArrowDiameter "Height of visual object";
//   input Real world.gravityArrowLine.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.gravityArrowLine.color[1] = Real(world.gravityArrowColor[1]) "Color of shape";
//   input Real world.gravityArrowLine.color[2] = Real(world.gravityArrowColor[2]) "Color of shape";
//   input Real world.gravityArrowLine.color[3] = Real(world.gravityArrowColor[3]) "Color of shape";
//   input Real world.gravityArrowLine.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.gravityArrowLine.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.gravityArrowLine.lengthDirection[1],world.gravityArrowLine.lengthDirection[2],world.gravityArrowLine.lengthDirection[3]});
//   protected Real world.gravityArrowLine.e_x[1](unit = "1") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 1.0 else world.gravityArrowLine.lengthDirection[1] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[2](unit = "1") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[2] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[3](unit = "1") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[3] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.n_z_aux[1](unit = "1") = world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[3] - world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[2];
//   protected Real world.gravityArrowLine.n_z_aux[2](unit = "1") = world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[1] - world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[3];
//   protected Real world.gravityArrowLine.n_z_aux[3](unit = "1") = world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[2] - world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[1];
//   protected Real world.gravityArrowLine.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[1];
//   protected Real world.gravityArrowLine.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[2];
//   protected Real world.gravityArrowLine.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[3];
//   protected output Real world.gravityArrowLine.Form;
//   output Real world.gravityArrowLine.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowLine.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravityArrowLine.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravityArrowLine.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.gravityArrowLine.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowLine.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowLine.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowLine.Material;
//   protected output Real world.gravityArrowLine.Extra;
//   parameter String world.gravityArrowHead.shapeType = "cone" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real world.gravityArrowHead.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real world.gravityArrowHead.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowHead.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowHead.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real world.gravityArrowHead.r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowHead.r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowHead.r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real world.gravityArrowHead.r_shape[1](quantity = "Length", unit = "m") = world.gravityArrowTail[1] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[1] * world.gravityLineLength "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowHead.r_shape[2](quantity = "Length", unit = "m") = world.gravityArrowTail[2] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[2] * world.gravityLineLength "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowHead.r_shape[3](quantity = "Length", unit = "m") = world.gravityArrowTail[3] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[3] * world.gravityLineLength "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real world.gravityArrowHead.lengthDirection[1](unit = "1") = world.n[1] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowHead.lengthDirection[2](unit = "1") = world.n[2] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowHead.lengthDirection[3](unit = "1") = world.n[3] "Vector in length direction, resolved in object frame";
//   input Real world.gravityArrowHead.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowHead.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowHead.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real world.gravityArrowHead.length(quantity = "Length", unit = "m") = world.gravityHeadLength "Length of visual object";
//   input Real world.gravityArrowHead.width(quantity = "Length", unit = "m") = world.gravityHeadWidth "Width of visual object";
//   input Real world.gravityArrowHead.height(quantity = "Length", unit = "m") = world.gravityHeadWidth "Height of visual object";
//   input Real world.gravityArrowHead.extra = 0.0 "Additional size data for some of the shape types";
//   input Real world.gravityArrowHead.color[1] = Real(world.gravityArrowColor[1]) "Color of shape";
//   input Real world.gravityArrowHead.color[2] = Real(world.gravityArrowColor[2]) "Color of shape";
//   input Real world.gravityArrowHead.color[3] = Real(world.gravityArrowColor[3]) "Color of shape";
//   input Real world.gravityArrowHead.specularCoefficient = 0.0 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real world.gravityArrowHead.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({world.gravityArrowHead.lengthDirection[1],world.gravityArrowHead.lengthDirection[2],world.gravityArrowHead.lengthDirection[3]});
//   protected Real world.gravityArrowHead.e_x[1](unit = "1") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 1.0 else world.gravityArrowHead.lengthDirection[1] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[2](unit = "1") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[2] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[3](unit = "1") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[3] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.n_z_aux[1](unit = "1") = world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[3] - world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[2];
//   protected Real world.gravityArrowHead.n_z_aux[2](unit = "1") = world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[1] - world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[3];
//   protected Real world.gravityArrowHead.n_z_aux[3](unit = "1") = world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[2] - world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[1];
//   protected Real world.gravityArrowHead.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[1];
//   protected Real world.gravityArrowHead.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[2];
//   protected Real world.gravityArrowHead.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[3];
//   protected output Real world.gravityArrowHead.Form;
//   output Real world.gravityArrowHead.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real world.gravityArrowHead.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravityArrowHead.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real world.gravityArrowHead.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real world.gravityArrowHead.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowHead.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowHead.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real world.gravityArrowHead.Material;
//   protected output Real world.gravityArrowHead.Extra;
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation AND world.animateGravity AND world.gravityType == 2 then 1 else 0;
//   parameter Real m(quantity = "Mass", unit = "kg", min = 0.0) = 1.0 "Mass of point masses";
//   Real rod_f_diff[1](quantity = "Force", unit = "N") = rod1.frame_b.f[1] - rod3.frame_b.f[1] "Difference of cut-forces in rod1 and rod3";
//   Real rod_f_diff[2](quantity = "Force", unit = "N") = rod1.frame_b.f[2] - rod3.frame_b.f[2] "Difference of cut-forces in rod1 and rod3";
//   Real rod_f_diff[3](quantity = "Force", unit = "N") = rod1.frame_b.f[3] - rod3.frame_b.f[3] "Difference of cut-forces in rod1 and rod3";
//   Real body_f_diff[1](quantity = "Force", unit = "N") = bodyBox1.frame_b.f[1] - bodyBox2.frame_b.f[1] "Difference of cut-forces in bodyBox1 and bodyBox2";
//   Real body_f_diff[2](quantity = "Force", unit = "N") = bodyBox1.frame_b.f[2] - bodyBox2.frame_b.f[2] "Difference of cut-forces in bodyBox1 and bodyBox2";
//   Real body_f_diff[3](quantity = "Force", unit = "N") = bodyBox1.frame_b.f[3] - bodyBox2.frame_b.f[3] "Difference of cut-forces in bodyBox1 and bodyBox2";
//   Real revolute1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute1.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute1.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute1.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute1.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute1.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean revolute1.useAxisFlange = false "= true, if axis flange is enabled";
//   parameter Boolean revolute1.animation = true "= true, if animation shall be enabled (show axis as cylinder)";
//   parameter Real revolute1.n[1](unit = "1") = 0.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   parameter Real revolute1.n[2](unit = "1") = 0.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   parameter Real revolute1.n[3](unit = "1") = 1.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   constant Real revolute1.phi_offset(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Relative angle offset (angle = phi_offset + phi)";
//   parameter Real revolute1.cylinderLength(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointLength "Length of cylinder representing the joint axis";
//   parameter Real revolute1.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointWidth "Diameter of cylinder representing the joint axis";
//   input Integer revolute1.cylinderColor[1](min = 0, max = 255) = 255 "Color of cylinder representing the joint axis";
//   input Integer revolute1.cylinderColor[2](min = 0, max = 255) = 0 "Color of cylinder representing the joint axis";
//   input Integer revolute1.cylinderColor[3](min = 0, max = 255) = 0 "Color of cylinder representing the joint axis";
//   input Real revolute1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) revolute1.stateSelect = StateSelect.prefer "Priority to use joint angle phi and w=der(phi) as states";
//   Real revolute1.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) "Relative rotation angle from frame_a to frame_b";
//   Real revolute1.w(quantity = "AngularVelocity", unit = "rad/s", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) "First derivative of angle phi (relative angular velocity)";
//   Real revolute1.a(quantity = "AngularAcceleration", unit = "rad/s2", start = 0.0) "Second derivative of angle phi (relative angular acceleration)";
//   Real revolute1.tau(quantity = "Torque", unit = "N.m") "Driving torque in direction of axis of rotation";
//   Real revolute1.angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "= phi_offset + phi";
//   protected parameter Real revolute1.e[1](unit = "1") = Modelica.Math.Vectors.normalize({revolute1.n[1],revolute1.n[2],revolute1.n[3]},1e-13)[1] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   protected parameter Real revolute1.e[2](unit = "1") = Modelica.Math.Vectors.normalize({revolute1.n[1],revolute1.n[2],revolute1.n[3]},1e-13)[2] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   protected parameter Real revolute1.e[3](unit = "1") = Modelica.Math.Vectors.normalize({revolute1.n[1],revolute1.n[2],revolute1.n[3]},1e-13)[3] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   Real revolute1.R_rel.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute1.R_rel.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.R_rel.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute1.R_rel.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   parameter String revolute1.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real revolute1.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real revolute1.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute1.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute1.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute1.cylinder.r[1](quantity = "Length", unit = "m") = revolute1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute1.cylinder.r[2](quantity = "Length", unit = "m") = revolute1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute1.cylinder.r[3](quantity = "Length", unit = "m") = revolute1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute1.cylinder.r_shape[1](quantity = "Length", unit = "m") = (-revolute1.cylinderLength) * revolute1.e[1] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute1.cylinder.r_shape[2](quantity = "Length", unit = "m") = (-revolute1.cylinderLength) * revolute1.e[2] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute1.cylinder.r_shape[3](quantity = "Length", unit = "m") = (-revolute1.cylinderLength) * revolute1.e[3] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute1.cylinder.lengthDirection[1](unit = "1") = revolute1.e[1] "Vector in length direction, resolved in object frame";
//   input Real revolute1.cylinder.lengthDirection[2](unit = "1") = revolute1.e[2] "Vector in length direction, resolved in object frame";
//   input Real revolute1.cylinder.lengthDirection[3](unit = "1") = revolute1.e[3] "Vector in length direction, resolved in object frame";
//   input Real revolute1.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real revolute1.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real revolute1.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real revolute1.cylinder.length(quantity = "Length", unit = "m") = revolute1.cylinderLength "Length of visual object";
//   input Real revolute1.cylinder.width(quantity = "Length", unit = "m") = revolute1.cylinderDiameter "Width of visual object";
//   input Real revolute1.cylinder.height(quantity = "Length", unit = "m") = revolute1.cylinderDiameter "Height of visual object";
//   input Real revolute1.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real revolute1.cylinder.color[1] = Real(revolute1.cylinderColor[1]) "Color of shape";
//   input Real revolute1.cylinder.color[2] = Real(revolute1.cylinderColor[2]) "Color of shape";
//   input Real revolute1.cylinder.color[3] = Real(revolute1.cylinderColor[3]) "Color of shape";
//   input Real revolute1.cylinder.specularCoefficient = revolute1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real revolute1.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({revolute1.cylinder.lengthDirection[1],revolute1.cylinder.lengthDirection[2],revolute1.cylinder.lengthDirection[3]});
//   protected Real revolute1.cylinder.e_x[1](unit = "1") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 1.0 else revolute1.cylinder.lengthDirection[1] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[2](unit = "1") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[2] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.e_x[3](unit = "1") = if noEvent(revolute1.cylinder.abs_n_x < 1e-10) then 0.0 else revolute1.cylinder.lengthDirection[3] / revolute1.cylinder.abs_n_x;
//   protected Real revolute1.cylinder.n_z_aux[1](unit = "1") = revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[3] - revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[2];
//   protected Real revolute1.cylinder.n_z_aux[2](unit = "1") = revolute1.cylinder.e_x[3] * revolute1.cylinder.widthDirection[1] - revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[3];
//   protected Real revolute1.cylinder.n_z_aux[3](unit = "1") = revolute1.cylinder.e_x[1] * revolute1.cylinder.widthDirection[2] - revolute1.cylinder.e_x[2] * revolute1.cylinder.widthDirection[1];
//   protected Real revolute1.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[1];
//   protected Real revolute1.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[2];
//   protected Real revolute1.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]},if noEvent(revolute1.cylinder.n_z_aux[1] ^ 2.0 + (revolute1.cylinder.n_z_aux[2] ^ 2.0 + revolute1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute1.cylinder.widthDirection[1],revolute1.cylinder.widthDirection[2],revolute1.cylinder.widthDirection[3]} else if noEvent(abs(revolute1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute1.cylinder.e_x[1],revolute1.cylinder.e_x[2],revolute1.cylinder.e_x[3]})[3];
//   protected output Real revolute1.cylinder.Form;
//   output Real revolute1.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute1.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real revolute1.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real revolute1.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real revolute1.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute1.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute1.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute1.cylinder.Material;
//   protected output Real revolute1.cylinder.Extra;
//   parameter Real revolute1.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real revolute1.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute1.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   input Real revolute1.internalAxis.tau(quantity = "Torque", unit = "N.m") = revolute1.tau "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)";
//   Real revolute1.internalAxis.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "External support angle (= flange.phi)";
//   Real revolute1.internalAxis.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute1.internalAxis.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Boolean revolute1.constantTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real revolute1.constantTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute1.constantTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real revolute1.constantTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real revolute1.constantTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real revolute1.constantTorque.tau_constant(quantity = "Torque", unit = "N.m") = 0.0 "Constant torque (if negative, torque is acting as load)";
//   Real revolute1.constantTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   Real bodyBox1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox1.animation = true "= true, if animation shall be enabled (show box between frame_a and frame_b)";
//   parameter Real bodyBox1.r[1](quantity = "Length", unit = "m", start = 0.1) = 0.7 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox1.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox1.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox1.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox1.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox1.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox1.lengthDirection[1](unit = "1") = bodyBox1.r[1] - bodyBox1.r_shape[1] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox1.lengthDirection[2](unit = "1") = bodyBox1.r[2] - bodyBox1.r_shape[2] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox1.lengthDirection[3](unit = "1") = bodyBox1.r[3] - bodyBox1.r_shape[3] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox1.widthDirection[1](unit = "1") = 0.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox1.widthDirection[2](unit = "1") = 1.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox1.widthDirection[3](unit = "1") = 0.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox1.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({bodyBox1.r[1] - bodyBox1.r_shape[1],bodyBox1.r[2] - bodyBox1.r_shape[2],bodyBox1.r[3] - bodyBox1.r_shape[3]}) "Length of box";
//   parameter Real bodyBox1.width(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.length / world.defaultWidthFraction "Width of box";
//   parameter Real bodyBox1.height(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.width "Height of box";
//   parameter Real bodyBox1.innerWidth(quantity = "Length", unit = "m", min = 0.0) = 0.0 "Width of inner box surface (0 <= innerWidth <= width)";
//   parameter Real bodyBox1.innerHeight(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.innerWidth "Height of inner box surface (0 <= innerHeight <= height)";
//   parameter Real bodyBox1.density(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 7700.0 "Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)";
//   input Integer bodyBox1.color[1](min = 0, max = 255) = 0 "Color of box";
//   input Integer bodyBox1.color[2](min = 0, max = 255) = 128 "Color of box";
//   input Integer bodyBox1.color[3](min = 0, max = 255) = 255 "Color of box";
//   input Real bodyBox1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   Real bodyBox1.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox1.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox1.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean bodyBox1.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox1.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox1.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer bodyBox1.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox1.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox1.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean bodyBox1.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox1.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox1.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean bodyBox1.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox1.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox1.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Boolean bodyBox1.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean bodyBox1.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer bodyBox1.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox1.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox1.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real bodyBox1.mo(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox1.density * (bodyBox1.length * (bodyBox1.width * bodyBox1.height)) "Mass of box without hole";
//   parameter Real bodyBox1.mi(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox1.density * (bodyBox1.length * (bodyBox1.innerWidth * bodyBox1.innerHeight)) "Mass of hole of box";
//   parameter Real bodyBox1.m(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox1.mo - bodyBox1.mi "Mass of box";
//   parameter Real bodyBox1.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.r_CM[1](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox1.r[1],bodyBox1.r[2],bodyBox1.r[3]},1e-13)[1] * bodyBox1.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.r_CM[2](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox1.r[1],bodyBox1.r[2],bodyBox1.r[3]},1e-13)[2] * bodyBox1.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.r_CM[3](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox1.r[1],bodyBox1.r[2],bodyBox1.r[3]},1e-13)[3] * bodyBox1.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[1][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[1][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[1][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[2][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[2][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[2][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[3][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[3][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox1.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox1.R,{{bodyBox1.mo * (bodyBox1.width ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.innerWidth ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.height ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox1.mo * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.width ^ 2.0 / 12.0) - bodyBox1.mi * (bodyBox1.length ^ 2.0 / 12.0 + bodyBox1.innerWidth ^ 2.0 / 12.0)}})[3][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   Real bodyBox1.body.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.body.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.body.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.body.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.body.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.body.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.body.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.body.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.body.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.body.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.body.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.body.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.body.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox1.body.animation = false "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real bodyBox1.body.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r_CM[1] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.body.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r_CM[2] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.body.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r_CM[3] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox1.body.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = bodyBox1.m "Mass of rigid body";
//   parameter Real bodyBox1.body.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox1.I[1,1] " (1,1) element of inertia tensor";
//   parameter Real bodyBox1.body.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox1.I[2,2] " (2,2) element of inertia tensor";
//   parameter Real bodyBox1.body.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox1.I[3,3] " (3,3) element of inertia tensor";
//   parameter Real bodyBox1.body.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox1.I[2,1] " (2,1) element of inertia tensor";
//   parameter Real bodyBox1.body.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox1.I[3,1] " (3,1) element of inertia tensor";
//   parameter Real bodyBox1.body.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox1.I[3,2] " (3,2) element of inertia tensor";
//   Real bodyBox1.body.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.body.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.body.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox1.body.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.body.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.body.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox1.body.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox1.body.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox1.body.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean bodyBox1.body.angles_fixed = bodyBox1.angles_fixed "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.body.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox1.angles_start[1] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox1.body.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox1.angles_start[2] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox1.body.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox1.angles_start[3] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer bodyBox1.body.sequence_start[1](min = 1, max = 3) = bodyBox1.sequence_start[1] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox1.body.sequence_start[2](min = 1, max = 3) = bodyBox1.sequence_start[2] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox1.body.sequence_start[3](min = 1, max = 3) = bodyBox1.sequence_start[3] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean bodyBox1.body.w_0_fixed = bodyBox1.w_0_fixed "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.body.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = bodyBox1.w_0_start[1] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox1.body.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = bodyBox1.w_0_start[2] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox1.body.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = bodyBox1.w_0_start[3] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean bodyBox1.body.z_0_fixed = bodyBox1.z_0_fixed "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox1.body.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox1.z_0_start[1] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox1.body.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox1.z_0_start[2] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox1.body.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox1.z_0_start[3] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox1.body.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer bodyBox1.body.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer bodyBox1.body.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer bodyBox1.body.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real bodyBox1.body.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.body.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer bodyBox1.body.cylinderColor[1](min = 0, max = 255) = bodyBox1.body.sphereColor[1] "Color of cylinder";
//   input Integer bodyBox1.body.cylinderColor[2](min = 0, max = 255) = bodyBox1.body.sphereColor[2] "Color of cylinder";
//   input Integer bodyBox1.body.cylinderColor[3](min = 0, max = 255) = bodyBox1.body.sphereColor[3] "Color of cylinder";
//   input Real bodyBox1.body.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean bodyBox1.body.enforceStates = bodyBox1.enforceStates " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean bodyBox1.body.useQuaternions = bodyBox1.useQuaternions " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer bodyBox1.body.sequence_angleStates[1](min = 1, max = 3) = bodyBox1.sequence_angleStates[1] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox1.body.sequence_angleStates[2](min = 1, max = 3) = bodyBox1.sequence_angleStates[2] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox1.body.sequence_angleStates[3](min = 1, max = 3) = bodyBox1.sequence_angleStates[3] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real bodyBox1.body.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_11 "inertia tensor";
//   parameter Real bodyBox1.body.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_21 "inertia tensor";
//   parameter Real bodyBox1.body.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_31 "inertia tensor";
//   parameter Real bodyBox1.body.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_21 "inertia tensor";
//   parameter Real bodyBox1.body.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_22 "inertia tensor";
//   parameter Real bodyBox1.body.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_32 "inertia tensor";
//   parameter Real bodyBox1.body.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_31 "inertia tensor";
//   parameter Real bodyBox1.body.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_32 "inertia tensor";
//   parameter Real bodyBox1.body.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox1.body.I_33 "inertia tensor";
//   parameter Real bodyBox1.body.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox1.body.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.body.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.body.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox1.body.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real bodyBox1.body.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real bodyBox1.body.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real bodyBox1.body.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.w_0_start[1],bodyBox1.body.w_0_start[2],bodyBox1.body.w_0_start[3]})[1], fixed = bodyBox1.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox1.body.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.w_0_start[1],bodyBox1.body.w_0_start[2],bodyBox1.body.w_0_start[3]})[2], fixed = bodyBox1.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox1.body.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.w_0_start[1],bodyBox1.body.w_0_start[2],bodyBox1.body.w_0_start[3]})[3], fixed = bodyBox1.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox1.body.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[1], fixed = bodyBox1.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox1.body.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[2], fixed = bodyBox1.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox1.body.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.R_start,{bodyBox1.body.z_0_start[1],bodyBox1.body.z_0_start[2],bodyBox1.body.z_0_start[3]})[3], fixed = bodyBox1.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox1.body.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real bodyBox1.body.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real bodyBox1.body.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real bodyBox1.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox1.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox1.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox1.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real bodyBox1.body.Q[1](start = bodyBox1.body.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox1.body.Q[2](start = bodyBox1.body.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox1.body.Q[3](start = bodyBox1.body.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox1.body.Q[4](start = bodyBox1.body.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real bodyBox1.body.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox1.body.sequence_start[1] == bodyBox1.body.sequence_angleStates[1] AND bodyBox1.body.sequence_start[2] == bodyBox1.body.sequence_angleStates[2] AND bodyBox1.body.sequence_start[3] == bodyBox1.body.sequence_angleStates[3] then bodyBox1.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox1.body.R_start,{bodyBox1.body.sequence_angleStates[1],bodyBox1.body.sequence_angleStates[2],bodyBox1.body.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real bodyBox1.body.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox1.body.sequence_start[1] == bodyBox1.body.sequence_angleStates[1] AND bodyBox1.body.sequence_start[2] == bodyBox1.body.sequence_angleStates[2] AND bodyBox1.body.sequence_start[3] == bodyBox1.body.sequence_angleStates[3] then bodyBox1.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox1.body.R_start,{bodyBox1.body.sequence_angleStates[1],bodyBox1.body.sequence_angleStates[2],bodyBox1.body.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real bodyBox1.body.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox1.body.sequence_start[1] == bodyBox1.body.sequence_angleStates[1] AND bodyBox1.body.sequence_start[2] == bodyBox1.body.sequence_angleStates[2] AND bodyBox1.body.sequence_start[3] == bodyBox1.body.sequence_angleStates[3] then bodyBox1.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox1.body.R_start,{bodyBox1.body.sequence_angleStates[1],bodyBox1.body.sequence_angleStates[2],bodyBox1.body.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real bodyBox1.body.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox1.body.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox1.body.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox1.body.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox1.body.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox1.body.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox1.body.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox1.body.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox1.body.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox1.body.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real bodyBox1.body.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real bodyBox1.body.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   Real bodyBox1.frameTranslation.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox1.frameTranslation.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox1.frameTranslation.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox1.frameTranslation.animation = bodyBox1.animation "= true, if animation shall be enabled";
//   parameter Real bodyBox1.frameTranslation.r[1](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r[1] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.r[2](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r[2] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.r[3](quantity = "Length", unit = "m", start = 0.0) = bodyBox1.r[3] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String bodyBox1.frameTranslation.shapeType = "box" " Type of shape";
//   parameter Real bodyBox1.frameTranslation.r_shape[1](quantity = "Length", unit = "m") = bodyBox1.r_shape[1] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.r_shape[2](quantity = "Length", unit = "m") = bodyBox1.r_shape[2] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.r_shape[3](quantity = "Length", unit = "m") = bodyBox1.r_shape[3] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.lengthDirection[1](unit = "1") = bodyBox1.lengthDirection[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.lengthDirection[2](unit = "1") = bodyBox1.lengthDirection[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.lengthDirection[3](unit = "1") = bodyBox1.lengthDirection[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.widthDirection[1](unit = "1") = bodyBox1.widthDirection[1] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.widthDirection[2](unit = "1") = bodyBox1.widthDirection[2] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.widthDirection[3](unit = "1") = bodyBox1.widthDirection[3] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox1.frameTranslation.length(quantity = "Length", unit = "m") = bodyBox1.length " Length of shape";
//   parameter Real bodyBox1.frameTranslation.width(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.width " Width of shape";
//   parameter Real bodyBox1.frameTranslation.height(quantity = "Length", unit = "m", min = 0.0) = bodyBox1.height " Height of shape.";
//   parameter Real bodyBox1.frameTranslation.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer bodyBox1.frameTranslation.color[1](min = 0, max = 255) = bodyBox1.color[1] " Color of shape";
//   input Integer bodyBox1.frameTranslation.color[2](min = 0, max = 255) = bodyBox1.color[2] " Color of shape";
//   input Integer bodyBox1.frameTranslation.color[3](min = 0, max = 255) = bodyBox1.color[3] " Color of shape";
//   input Real bodyBox1.frameTranslation.specularCoefficient = bodyBox1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String bodyBox1.frameTranslation.shape.shapeType = bodyBox1.frameTranslation.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real bodyBox1.frameTranslation.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox1.frameTranslation.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox1.frameTranslation.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox1.frameTranslation.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox1.frameTranslation.shape.r[1](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox1.frameTranslation.shape.r[2](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox1.frameTranslation.shape.r[3](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox1.frameTranslation.shape.r_shape[1](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.r_shape[2](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.r_shape[3](quantity = "Length", unit = "m") = bodyBox1.frameTranslation.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.lengthDirection[1](unit = "1") = bodyBox1.frameTranslation.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.lengthDirection[2](unit = "1") = bodyBox1.frameTranslation.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.lengthDirection[3](unit = "1") = bodyBox1.frameTranslation.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.widthDirection[1](unit = "1") = bodyBox1.frameTranslation.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.widthDirection[2](unit = "1") = bodyBox1.frameTranslation.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.widthDirection[3](unit = "1") = bodyBox1.frameTranslation.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real bodyBox1.frameTranslation.shape.length(quantity = "Length", unit = "m") = bodyBox1.frameTranslation.length "Length of visual object";
//   input Real bodyBox1.frameTranslation.shape.width(quantity = "Length", unit = "m") = bodyBox1.frameTranslation.width "Width of visual object";
//   input Real bodyBox1.frameTranslation.shape.height(quantity = "Length", unit = "m") = bodyBox1.frameTranslation.height "Height of visual object";
//   input Real bodyBox1.frameTranslation.shape.extra = bodyBox1.frameTranslation.extra "Additional size data for some of the shape types";
//   input Real bodyBox1.frameTranslation.shape.color[1] = Real(bodyBox1.frameTranslation.color[1]) "Color of shape";
//   input Real bodyBox1.frameTranslation.shape.color[2] = Real(bodyBox1.frameTranslation.color[2]) "Color of shape";
//   input Real bodyBox1.frameTranslation.shape.color[3] = Real(bodyBox1.frameTranslation.color[3]) "Color of shape";
//   input Real bodyBox1.frameTranslation.shape.specularCoefficient = bodyBox1.frameTranslation.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real bodyBox1.frameTranslation.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({bodyBox1.frameTranslation.shape.lengthDirection[1],bodyBox1.frameTranslation.shape.lengthDirection[2],bodyBox1.frameTranslation.shape.lengthDirection[3]});
//   protected Real bodyBox1.frameTranslation.shape.e_x[1](unit = "1") = if noEvent(bodyBox1.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else bodyBox1.frameTranslation.shape.lengthDirection[1] / bodyBox1.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox1.frameTranslation.shape.e_x[2](unit = "1") = if noEvent(bodyBox1.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else bodyBox1.frameTranslation.shape.lengthDirection[2] / bodyBox1.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox1.frameTranslation.shape.e_x[3](unit = "1") = if noEvent(bodyBox1.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else bodyBox1.frameTranslation.shape.lengthDirection[3] / bodyBox1.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox1.frameTranslation.shape.n_z_aux[1](unit = "1") = bodyBox1.frameTranslation.shape.e_x[2] * bodyBox1.frameTranslation.shape.widthDirection[3] - bodyBox1.frameTranslation.shape.e_x[3] * bodyBox1.frameTranslation.shape.widthDirection[2];
//   protected Real bodyBox1.frameTranslation.shape.n_z_aux[2](unit = "1") = bodyBox1.frameTranslation.shape.e_x[3] * bodyBox1.frameTranslation.shape.widthDirection[1] - bodyBox1.frameTranslation.shape.e_x[1] * bodyBox1.frameTranslation.shape.widthDirection[3];
//   protected Real bodyBox1.frameTranslation.shape.n_z_aux[3](unit = "1") = bodyBox1.frameTranslation.shape.e_x[1] * bodyBox1.frameTranslation.shape.widthDirection[2] - bodyBox1.frameTranslation.shape.e_x[2] * bodyBox1.frameTranslation.shape.widthDirection[1];
//   protected Real bodyBox1.frameTranslation.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]},if noEvent(bodyBox1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox1.frameTranslation.shape.widthDirection[1],bodyBox1.frameTranslation.shape.widthDirection[2],bodyBox1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]})[1];
//   protected Real bodyBox1.frameTranslation.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]},if noEvent(bodyBox1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox1.frameTranslation.shape.widthDirection[1],bodyBox1.frameTranslation.shape.widthDirection[2],bodyBox1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]})[2];
//   protected Real bodyBox1.frameTranslation.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]},if noEvent(bodyBox1.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox1.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox1.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox1.frameTranslation.shape.widthDirection[1],bodyBox1.frameTranslation.shape.widthDirection[2],bodyBox1.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox1.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox1.frameTranslation.shape.e_x[1],bodyBox1.frameTranslation.shape.e_x[2],bodyBox1.frameTranslation.shape.e_x[3]})[3];
//   protected output Real bodyBox1.frameTranslation.shape.Form;
//   output Real bodyBox1.frameTranslation.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real bodyBox1.frameTranslation.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real bodyBox1.frameTranslation.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox1.frameTranslation.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox1.frameTranslation.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox1.frameTranslation.shape.Material;
//   protected output Real bodyBox1.frameTranslation.shape.Extra;
//   Real rod1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod1.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod1.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod1.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod1.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod1.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod1.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod1.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean rod1.animation = false "= true, if animation shall be enabled";
//   parameter Real rod1.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod1.r[2](quantity = "Length", unit = "m", start = 0.0) = -0.9 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod1.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String rod1.shapeType = "cylinder" " Type of shape";
//   parameter Real rod1.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod1.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod1.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod1.lengthDirection[1](unit = "1") = rod1.r[1] - rod1.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod1.lengthDirection[2](unit = "1") = rod1.r[2] - rod1.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod1.lengthDirection[3](unit = "1") = rod1.r[3] - rod1.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod1.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod1.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod1.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod1.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({rod1.r[1] - rod1.r_shape[1],rod1.r[2] - rod1.r_shape[2],rod1.r[3] - rod1.r_shape[3]}) " Length of shape";
//   parameter Real rod1.width(quantity = "Length", unit = "m", min = 0.0) = 0.01 " Width of shape";
//   parameter Real rod1.height(quantity = "Length", unit = "m", min = 0.0) = rod1.width " Height of shape.";
//   parameter Real rod1.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer rod1.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod1.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod1.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real rod1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   Real jointUPS.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ia.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ia.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ia.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ia.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ia.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ia.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ia.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ia.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ia.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ia.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ia.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ia.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ia.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ib.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ib.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ib.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real jointUPS.frame_ib.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.frame_ib.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ib.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ib.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.frame_ib.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ib.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ib.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real jointUPS.frame_ib.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ib.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.frame_ib.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real jointUPS.axis.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real jointUPS.axis.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real jointUPS.bearing.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real jointUPS.bearing.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Boolean jointUPS.animation = true "= true, if animation shall be enabled";
//   parameter Boolean jointUPS.showUniversalAxes = true " = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)";
//   parameter Real jointUPS.n1_a[1](unit = "1") = 0.0 "Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)";
//   parameter Real jointUPS.n1_a[2](unit = "1") = 0.0 "Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)";
//   parameter Real jointUPS.n1_a[3](unit = "1") = 1.0 "Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to line from universal to spherical joint)";
//   parameter Real jointUPS.nAxis_ia[1](quantity = "Length", unit = "m") = 0.7 "Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.nAxis_ia[2](quantity = "Length", unit = "m") = 1.2 "Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.nAxis_ia[3](quantity = "Length", unit = "m") = 0.0 "Axis vector along line from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.s_offset(quantity = "Length", unit = "m") = 0.0 "Relative distance offset (distance between frame_a and frame_b = s(t) + s_offset)";
//   parameter Real jointUPS.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointLength "Diameter of spheres representing the spherical joints";
//   input Integer jointUPS.sphereColor[1](min = 0, max = 255) = 255 "Color of spheres representing the spherical joints";
//   input Integer jointUPS.sphereColor[2](min = 0, max = 255) = 0 "Color of spheres representing the spherical joints";
//   input Integer jointUPS.sphereColor[3](min = 0, max = 255) = 0 "Color of spheres representing the spherical joints";
//   parameter Real jointUPS.axisDiameter(quantity = "Length", unit = "m", min = 0.0) = jointUPS.sphereDiameter / 2.0 "Diameter of cylinder on the connecting line from frame_a to frame_b";
//   input Integer jointUPS.axisColor[1](min = 0, max = 255) = 255 "Color of cylinder on the connecting line from frame_a to frame_b";
//   input Integer jointUPS.axisColor[2](min = 0, max = 255) = 255 "Color of cylinder on the connecting line from frame_a to frame_b";
//   input Integer jointUPS.axisColor[3](min = 0, max = 255) = 0 "Color of cylinder on the connecting line from frame_a to frame_b";
//   input Real jointUPS.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Real jointUPS.cylinderLength(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointLength "Length of cylinders representing the two universal joint axes";
//   parameter Real jointUPS.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointWidth "Diameter of cylinders representing the two universal joint axes";
//   input Integer jointUPS.cylinderColor[1](min = 0, max = 255) = 255 "Color of cylinders representing the two universal joint axes";
//   input Integer jointUPS.cylinderColor[2](min = 0, max = 255) = 0 "Color of cylinders representing the two universal joint axes";
//   input Integer jointUPS.cylinderColor[3](min = 0, max = 255) = 0 "Color of cylinders representing the two universal joint axes";
//   parameter Boolean jointUPS.checkTotalPower = false "= true, if total power flowing into this component shall be determined (must be zero)";
//   parameter Real jointUPS.eAxis_ia[1](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.nAxis_ia[1],jointUPS.nAxis_ia[2],jointUPS.nAxis_ia[3]},1e-13)[1] "Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.eAxis_ia[2](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.nAxis_ia[1],jointUPS.nAxis_ia[2],jointUPS.nAxis_ia[3]},1e-13)[2] "Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.eAxis_ia[3](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.nAxis_ia[1],jointUPS.nAxis_ia[2],jointUPS.nAxis_ia[3]},1e-13)[3] "Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia";
//   parameter Real jointUPS.e2_ia[1](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.n1_a[2] * jointUPS.eAxis_ia[3] - jointUPS.n1_a[3] * jointUPS.eAxis_ia[2],jointUPS.n1_a[3] * jointUPS.eAxis_ia[1] - jointUPS.n1_a[1] * jointUPS.eAxis_ia[3],jointUPS.n1_a[1] * jointUPS.eAxis_ia[2] - jointUPS.n1_a[2] * jointUPS.eAxis_ia[1]},1e-13)[1] "Unit vector in direction of second rotation axis of universal joint, resolved in frame_ia";
//   parameter Real jointUPS.e2_ia[2](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.n1_a[2] * jointUPS.eAxis_ia[3] - jointUPS.n1_a[3] * jointUPS.eAxis_ia[2],jointUPS.n1_a[3] * jointUPS.eAxis_ia[1] - jointUPS.n1_a[1] * jointUPS.eAxis_ia[3],jointUPS.n1_a[1] * jointUPS.eAxis_ia[2] - jointUPS.n1_a[2] * jointUPS.eAxis_ia[1]},1e-13)[2] "Unit vector in direction of second rotation axis of universal joint, resolved in frame_ia";
//   parameter Real jointUPS.e2_ia[3](unit = "1") = Modelica.Math.Vectors.normalize({jointUPS.n1_a[2] * jointUPS.eAxis_ia[3] - jointUPS.n1_a[3] * jointUPS.eAxis_ia[2],jointUPS.n1_a[3] * jointUPS.eAxis_ia[1] - jointUPS.n1_a[1] * jointUPS.eAxis_ia[3],jointUPS.n1_a[1] * jointUPS.eAxis_ia[2] - jointUPS.n1_a[2] * jointUPS.eAxis_ia[1]},1e-13)[3] "Unit vector in direction of second rotation axis of universal joint, resolved in frame_ia";
//   parameter Real jointUPS.e3_ia[1](unit = "1") = jointUPS.eAxis_ia[2] * jointUPS.e2_ia[3] - jointUPS.eAxis_ia[3] * jointUPS.e2_ia[2] "Unit vector perpendicular to eAxis_ia and e2_ia, resolved in frame_ia";
//   parameter Real jointUPS.e3_ia[2](unit = "1") = jointUPS.eAxis_ia[3] * jointUPS.e2_ia[1] - jointUPS.eAxis_ia[1] * jointUPS.e2_ia[3] "Unit vector perpendicular to eAxis_ia and e2_ia, resolved in frame_ia";
//   parameter Real jointUPS.e3_ia[3](unit = "1") = jointUPS.eAxis_ia[1] * jointUPS.e2_ia[2] - jointUPS.eAxis_ia[2] * jointUPS.e2_ia[1] "Unit vector perpendicular to eAxis_ia and e2_ia, resolved in frame_ia";
//   Real jointUPS.s(quantity = "Length", unit = "m") "Relative distance between frame_a and frame_b along axis nAxis = s + s_offset";
//   Real jointUPS.f(quantity = "Force", unit = "N") "= axis.f (driving force in the axis; = -bearing.f)";
//   Real jointUPS.axisLength(quantity = "Length", unit = "m") "Distance between frame_a and frame_b";
//   Real jointUPS.totalPower(quantity = "Power", unit = "W") "Total power flowing into this element, if checkTotalPower=true (otherwise dummy)";
//   protected Real jointUPS.f_c_a[1](quantity = "Force", unit = "N") "frame_ia.f resolved in frame_a";
//   protected Real jointUPS.f_c_a[2](quantity = "Force", unit = "N") "frame_ia.f resolved in frame_a";
//   protected Real jointUPS.f_c_a[3](quantity = "Force", unit = "N") "frame_ia.f resolved in frame_a";
//   protected Real jointUPS.t_cd_a[1](quantity = "Torque", unit = "N.m") "frame_ia.t + frame_ib.t resolved in frame_a";
//   protected Real jointUPS.t_cd_a[2](quantity = "Torque", unit = "N.m") "frame_ia.t + frame_ib.t resolved in frame_a";
//   protected Real jointUPS.t_cd_a[3](quantity = "Torque", unit = "N.m") "frame_ia.t + frame_ib.t resolved in frame_a";
//   protected Real jointUPS.f_bd_a[1](quantity = "Force", unit = "N") "frame_b.f + frame_ib.f resolved in frame_a";
//   protected Real jointUPS.f_bd_a[2](quantity = "Force", unit = "N") "frame_b.f + frame_ib.f resolved in frame_a";
//   protected Real jointUPS.f_bd_a[3](quantity = "Force", unit = "N") "frame_b.f + frame_ib.f resolved in frame_a";
//   protected Real jointUPS.rAxis_0[1](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
//   protected Real jointUPS.rAxis_0[2](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
//   protected Real jointUPS.rAxis_0[3](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in world frame";
//   protected Real jointUPS.rAxis_a[1](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in frame_a";
//   protected Real jointUPS.rAxis_a[2](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in frame_a";
//   protected Real jointUPS.rAxis_a[3](quantity = "Length", unit = "m") "Position vector from origin of frame_a to origin of frame_b resolved in frame_a";
//   protected Real jointUPS.eAxis_a[1](unit = "1") "Unit vector in direction of rAxis_a, resolved in frame_a";
//   protected Real jointUPS.eAxis_a[2](unit = "1") "Unit vector in direction of rAxis_a, resolved in frame_a";
//   protected Real jointUPS.eAxis_a[3](unit = "1") "Unit vector in direction of rAxis_a, resolved in frame_a";
//   protected Real jointUPS.e2_a[1](unit = "1") "Unit vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.e2_a[2](unit = "1") "Unit vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.e2_a[3](unit = "1") "Unit vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.e3_a[1](unit = "1") "Unit vector perpendicular to eAxis_a and e2_a, resolved in frame_a";
//   protected Real jointUPS.e3_a[2](unit = "1") "Unit vector perpendicular to eAxis_a and e2_a, resolved in frame_a";
//   protected Real jointUPS.e3_a[3](unit = "1") "Unit vector perpendicular to eAxis_a and e2_a, resolved in frame_a";
//   protected Real jointUPS.n2_a[1](unit = "1") "Vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.n2_a[2](unit = "1") "Vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.n2_a[3](unit = "1") "Vector in direction of second rotation axis of universal joint, resolved in frame_a";
//   protected Real jointUPS.length2_n2_a(unit = "m2") "Square of length of vector n2_a";
//   protected Real jointUPS.length_n2_a(quantity = "Length", unit = "m") "Length of vector n2_a";
//   protected Real jointUPS.der_rAxis_a_L[1](unit = "1/s") "= der(rAxis_a)/axisLength";
//   protected Real jointUPS.der_rAxis_a_L[2](unit = "1/s") "= der(rAxis_a)/axisLength";
//   protected Real jointUPS.der_rAxis_a_L[3](unit = "1/s") "= der(rAxis_a)/axisLength";
//   protected Real jointUPS.w_rel_ia1[1](quantity = "AngularVelocity", unit = "rad/s");
//   protected Real jointUPS.w_rel_ia1[2](quantity = "AngularVelocity", unit = "rad/s");
//   protected Real jointUPS.w_rel_ia1[3](quantity = "AngularVelocity", unit = "rad/s");
//   Real jointUPS.R_ia1_a.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia1_a.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia1_a.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia1_a.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia2_a.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia2_a.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia2_a.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia2_a.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia_a.T[1,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[1,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[1,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[2,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[2,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[2,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[3,1] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[3,2] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.T[3,3] "Transformation matrix from world frame to local frame";
//   Real jointUPS.R_ia_a.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia_a.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real jointUPS.R_ia_a.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   parameter String jointUPS.axisCylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real jointUPS.axisCylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.axisCylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.axisCylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.axisCylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.axisCylinder.r[1](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.axisCylinder.r[2](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.axisCylinder.r[3](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.axisCylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.axisCylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.axisCylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.axisCylinder.lengthDirection[1](unit = "1") = jointUPS.eAxis_ia[1] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.lengthDirection[2](unit = "1") = jointUPS.eAxis_ia[2] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.lengthDirection[3](unit = "1") = jointUPS.eAxis_ia[3] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.widthDirection[1](unit = "1") = jointUPS.e2_ia[1] "Vector in width direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.widthDirection[2](unit = "1") = jointUPS.e2_ia[2] "Vector in width direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.widthDirection[3](unit = "1") = jointUPS.e2_ia[3] "Vector in width direction, resolved in object frame";
//   input Real jointUPS.axisCylinder.length(quantity = "Length", unit = "m") = jointUPS.axisLength "Length of visual object";
//   input Real jointUPS.axisCylinder.width(quantity = "Length", unit = "m") = jointUPS.axisDiameter "Width of visual object";
//   input Real jointUPS.axisCylinder.height(quantity = "Length", unit = "m") = jointUPS.axisDiameter "Height of visual object";
//   input Real jointUPS.axisCylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real jointUPS.axisCylinder.color[1] = Real(jointUPS.axisColor[1]) "Color of shape";
//   input Real jointUPS.axisCylinder.color[2] = Real(jointUPS.axisColor[2]) "Color of shape";
//   input Real jointUPS.axisCylinder.color[3] = Real(jointUPS.axisColor[3]) "Color of shape";
//   input Real jointUPS.axisCylinder.specularCoefficient = jointUPS.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real jointUPS.axisCylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({jointUPS.axisCylinder.lengthDirection[1],jointUPS.axisCylinder.lengthDirection[2],jointUPS.axisCylinder.lengthDirection[3]});
//   protected Real jointUPS.axisCylinder.e_x[1](unit = "1") = if noEvent(jointUPS.axisCylinder.abs_n_x < 1e-10) then 1.0 else jointUPS.axisCylinder.lengthDirection[1] / jointUPS.axisCylinder.abs_n_x;
//   protected Real jointUPS.axisCylinder.e_x[2](unit = "1") = if noEvent(jointUPS.axisCylinder.abs_n_x < 1e-10) then 0.0 else jointUPS.axisCylinder.lengthDirection[2] / jointUPS.axisCylinder.abs_n_x;
//   protected Real jointUPS.axisCylinder.e_x[3](unit = "1") = if noEvent(jointUPS.axisCylinder.abs_n_x < 1e-10) then 0.0 else jointUPS.axisCylinder.lengthDirection[3] / jointUPS.axisCylinder.abs_n_x;
//   protected Real jointUPS.axisCylinder.n_z_aux[1](unit = "1") = jointUPS.axisCylinder.e_x[2] * jointUPS.axisCylinder.widthDirection[3] - jointUPS.axisCylinder.e_x[3] * jointUPS.axisCylinder.widthDirection[2];
//   protected Real jointUPS.axisCylinder.n_z_aux[2](unit = "1") = jointUPS.axisCylinder.e_x[3] * jointUPS.axisCylinder.widthDirection[1] - jointUPS.axisCylinder.e_x[1] * jointUPS.axisCylinder.widthDirection[3];
//   protected Real jointUPS.axisCylinder.n_z_aux[3](unit = "1") = jointUPS.axisCylinder.e_x[1] * jointUPS.axisCylinder.widthDirection[2] - jointUPS.axisCylinder.e_x[2] * jointUPS.axisCylinder.widthDirection[1];
//   protected Real jointUPS.axisCylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]},if noEvent(jointUPS.axisCylinder.n_z_aux[1] ^ 2.0 + (jointUPS.axisCylinder.n_z_aux[2] ^ 2.0 + jointUPS.axisCylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.axisCylinder.widthDirection[1],jointUPS.axisCylinder.widthDirection[2],jointUPS.axisCylinder.widthDirection[3]} else if noEvent(abs(jointUPS.axisCylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]})[1];
//   protected Real jointUPS.axisCylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]},if noEvent(jointUPS.axisCylinder.n_z_aux[1] ^ 2.0 + (jointUPS.axisCylinder.n_z_aux[2] ^ 2.0 + jointUPS.axisCylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.axisCylinder.widthDirection[1],jointUPS.axisCylinder.widthDirection[2],jointUPS.axisCylinder.widthDirection[3]} else if noEvent(abs(jointUPS.axisCylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]})[2];
//   protected Real jointUPS.axisCylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]},if noEvent(jointUPS.axisCylinder.n_z_aux[1] ^ 2.0 + (jointUPS.axisCylinder.n_z_aux[2] ^ 2.0 + jointUPS.axisCylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.axisCylinder.widthDirection[1],jointUPS.axisCylinder.widthDirection[2],jointUPS.axisCylinder.widthDirection[3]} else if noEvent(abs(jointUPS.axisCylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.axisCylinder.e_x[1],jointUPS.axisCylinder.e_x[2],jointUPS.axisCylinder.e_x[3]})[3];
//   protected output Real jointUPS.axisCylinder.Form;
//   output Real jointUPS.axisCylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.axisCylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.axisCylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.axisCylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real jointUPS.axisCylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.axisCylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.axisCylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.axisCylinder.Material;
//   protected output Real jointUPS.axisCylinder.Extra;
//   parameter String jointUPS.sphericalShape_b.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real jointUPS.sphericalShape_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_b.r[1](quantity = "Length", unit = "m") = jointUPS.frame_b.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_b.r[2](quantity = "Length", unit = "m") = jointUPS.frame_b.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_b.r[3](quantity = "Length", unit = "m") = jointUPS.frame_b.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_b.r_shape[1](quantity = "Length", unit = "m") = -0.5 * jointUPS.sphereDiameter "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_b.length(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Length of visual object";
//   input Real jointUPS.sphericalShape_b.width(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Width of visual object";
//   input Real jointUPS.sphericalShape_b.height(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Height of visual object";
//   input Real jointUPS.sphericalShape_b.extra = 0.0 "Additional size data for some of the shape types";
//   input Real jointUPS.sphericalShape_b.color[1] = Real(jointUPS.sphereColor[1]) "Color of shape";
//   input Real jointUPS.sphericalShape_b.color[2] = Real(jointUPS.sphereColor[2]) "Color of shape";
//   input Real jointUPS.sphericalShape_b.color[3] = Real(jointUPS.sphereColor[3]) "Color of shape";
//   input Real jointUPS.sphericalShape_b.specularCoefficient = jointUPS.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real jointUPS.sphericalShape_b.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({jointUPS.sphericalShape_b.lengthDirection[1],jointUPS.sphericalShape_b.lengthDirection[2],jointUPS.sphericalShape_b.lengthDirection[3]});
//   protected Real jointUPS.sphericalShape_b.e_x[1](unit = "1") = if noEvent(jointUPS.sphericalShape_b.abs_n_x < 1e-10) then 1.0 else jointUPS.sphericalShape_b.lengthDirection[1] / jointUPS.sphericalShape_b.abs_n_x;
//   protected Real jointUPS.sphericalShape_b.e_x[2](unit = "1") = if noEvent(jointUPS.sphericalShape_b.abs_n_x < 1e-10) then 0.0 else jointUPS.sphericalShape_b.lengthDirection[2] / jointUPS.sphericalShape_b.abs_n_x;
//   protected Real jointUPS.sphericalShape_b.e_x[3](unit = "1") = if noEvent(jointUPS.sphericalShape_b.abs_n_x < 1e-10) then 0.0 else jointUPS.sphericalShape_b.lengthDirection[3] / jointUPS.sphericalShape_b.abs_n_x;
//   protected Real jointUPS.sphericalShape_b.n_z_aux[1](unit = "1") = jointUPS.sphericalShape_b.e_x[2] * jointUPS.sphericalShape_b.widthDirection[3] - jointUPS.sphericalShape_b.e_x[3] * jointUPS.sphericalShape_b.widthDirection[2];
//   protected Real jointUPS.sphericalShape_b.n_z_aux[2](unit = "1") = jointUPS.sphericalShape_b.e_x[3] * jointUPS.sphericalShape_b.widthDirection[1] - jointUPS.sphericalShape_b.e_x[1] * jointUPS.sphericalShape_b.widthDirection[3];
//   protected Real jointUPS.sphericalShape_b.n_z_aux[3](unit = "1") = jointUPS.sphericalShape_b.e_x[1] * jointUPS.sphericalShape_b.widthDirection[2] - jointUPS.sphericalShape_b.e_x[2] * jointUPS.sphericalShape_b.widthDirection[1];
//   protected Real jointUPS.sphericalShape_b.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]},if noEvent(jointUPS.sphericalShape_b.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_b.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_b.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_b.widthDirection[1],jointUPS.sphericalShape_b.widthDirection[2],jointUPS.sphericalShape_b.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]})[1];
//   protected Real jointUPS.sphericalShape_b.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]},if noEvent(jointUPS.sphericalShape_b.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_b.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_b.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_b.widthDirection[1],jointUPS.sphericalShape_b.widthDirection[2],jointUPS.sphericalShape_b.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]})[2];
//   protected Real jointUPS.sphericalShape_b.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]},if noEvent(jointUPS.sphericalShape_b.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_b.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_b.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_b.widthDirection[1],jointUPS.sphericalShape_b.widthDirection[2],jointUPS.sphericalShape_b.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_b.e_x[1],jointUPS.sphericalShape_b.e_x[2],jointUPS.sphericalShape_b.e_x[3]})[3];
//   protected output Real jointUPS.sphericalShape_b.Form;
//   output Real jointUPS.sphericalShape_b.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.sphericalShape_b.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real jointUPS.sphericalShape_b.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_b.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_b.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_b.Material;
//   protected output Real jointUPS.sphericalShape_b.Extra;
//   parameter String jointUPS.sphericalShape_a.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real jointUPS.sphericalShape_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.sphericalShape_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.sphericalShape_a.r[1](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_a.r[2](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_a.r[3](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.sphericalShape_a.r_shape[1](quantity = "Length", unit = "m") = -0.5 * jointUPS.sphereDiameter "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.sphericalShape_a.length(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Length of visual object";
//   input Real jointUPS.sphericalShape_a.width(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Width of visual object";
//   input Real jointUPS.sphericalShape_a.height(quantity = "Length", unit = "m") = jointUPS.sphereDiameter "Height of visual object";
//   input Real jointUPS.sphericalShape_a.extra = 0.0 "Additional size data for some of the shape types";
//   input Real jointUPS.sphericalShape_a.color[1] = Real(jointUPS.sphereColor[1]) "Color of shape";
//   input Real jointUPS.sphericalShape_a.color[2] = Real(jointUPS.sphereColor[2]) "Color of shape";
//   input Real jointUPS.sphericalShape_a.color[3] = Real(jointUPS.sphereColor[3]) "Color of shape";
//   input Real jointUPS.sphericalShape_a.specularCoefficient = jointUPS.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real jointUPS.sphericalShape_a.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({jointUPS.sphericalShape_a.lengthDirection[1],jointUPS.sphericalShape_a.lengthDirection[2],jointUPS.sphericalShape_a.lengthDirection[3]});
//   protected Real jointUPS.sphericalShape_a.e_x[1](unit = "1") = if noEvent(jointUPS.sphericalShape_a.abs_n_x < 1e-10) then 1.0 else jointUPS.sphericalShape_a.lengthDirection[1] / jointUPS.sphericalShape_a.abs_n_x;
//   protected Real jointUPS.sphericalShape_a.e_x[2](unit = "1") = if noEvent(jointUPS.sphericalShape_a.abs_n_x < 1e-10) then 0.0 else jointUPS.sphericalShape_a.lengthDirection[2] / jointUPS.sphericalShape_a.abs_n_x;
//   protected Real jointUPS.sphericalShape_a.e_x[3](unit = "1") = if noEvent(jointUPS.sphericalShape_a.abs_n_x < 1e-10) then 0.0 else jointUPS.sphericalShape_a.lengthDirection[3] / jointUPS.sphericalShape_a.abs_n_x;
//   protected Real jointUPS.sphericalShape_a.n_z_aux[1](unit = "1") = jointUPS.sphericalShape_a.e_x[2] * jointUPS.sphericalShape_a.widthDirection[3] - jointUPS.sphericalShape_a.e_x[3] * jointUPS.sphericalShape_a.widthDirection[2];
//   protected Real jointUPS.sphericalShape_a.n_z_aux[2](unit = "1") = jointUPS.sphericalShape_a.e_x[3] * jointUPS.sphericalShape_a.widthDirection[1] - jointUPS.sphericalShape_a.e_x[1] * jointUPS.sphericalShape_a.widthDirection[3];
//   protected Real jointUPS.sphericalShape_a.n_z_aux[3](unit = "1") = jointUPS.sphericalShape_a.e_x[1] * jointUPS.sphericalShape_a.widthDirection[2] - jointUPS.sphericalShape_a.e_x[2] * jointUPS.sphericalShape_a.widthDirection[1];
//   protected Real jointUPS.sphericalShape_a.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]},if noEvent(jointUPS.sphericalShape_a.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_a.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_a.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_a.widthDirection[1],jointUPS.sphericalShape_a.widthDirection[2],jointUPS.sphericalShape_a.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]})[1];
//   protected Real jointUPS.sphericalShape_a.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]},if noEvent(jointUPS.sphericalShape_a.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_a.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_a.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_a.widthDirection[1],jointUPS.sphericalShape_a.widthDirection[2],jointUPS.sphericalShape_a.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]})[2];
//   protected Real jointUPS.sphericalShape_a.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]},if noEvent(jointUPS.sphericalShape_a.n_z_aux[1] ^ 2.0 + (jointUPS.sphericalShape_a.n_z_aux[2] ^ 2.0 + jointUPS.sphericalShape_a.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.sphericalShape_a.widthDirection[1],jointUPS.sphericalShape_a.widthDirection[2],jointUPS.sphericalShape_a.widthDirection[3]} else if noEvent(abs(jointUPS.sphericalShape_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.sphericalShape_a.e_x[1],jointUPS.sphericalShape_a.e_x[2],jointUPS.sphericalShape_a.e_x[3]})[3];
//   protected output Real jointUPS.sphericalShape_a.Form;
//   output Real jointUPS.sphericalShape_a.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.sphericalShape_a.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real jointUPS.sphericalShape_a.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_a.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_a.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.sphericalShape_a.Material;
//   protected output Real jointUPS.sphericalShape_a.Extra;
//   parameter String jointUPS.universalShape1.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real jointUPS.universalShape1.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape1.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape1.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape1.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape1.r[1](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape1.r[2](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape1.r[3](quantity = "Length", unit = "m") = jointUPS.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape1.r_shape[1](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.n1_a[1] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape1.r_shape[2](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.n1_a[2] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape1.r_shape[3](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.n1_a[3] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape1.lengthDirection[1](unit = "1") = jointUPS.n1_a[1] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape1.lengthDirection[2](unit = "1") = jointUPS.n1_a[2] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape1.lengthDirection[3](unit = "1") = jointUPS.n1_a[3] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape1.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape1.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape1.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape1.length(quantity = "Length", unit = "m") = jointUPS.cylinderLength "Length of visual object";
//   input Real jointUPS.universalShape1.width(quantity = "Length", unit = "m") = jointUPS.cylinderDiameter "Width of visual object";
//   input Real jointUPS.universalShape1.height(quantity = "Length", unit = "m") = jointUPS.cylinderDiameter "Height of visual object";
//   input Real jointUPS.universalShape1.extra = 0.0 "Additional size data for some of the shape types";
//   input Real jointUPS.universalShape1.color[1] = Real(jointUPS.cylinderColor[1]) "Color of shape";
//   input Real jointUPS.universalShape1.color[2] = Real(jointUPS.cylinderColor[2]) "Color of shape";
//   input Real jointUPS.universalShape1.color[3] = Real(jointUPS.cylinderColor[3]) "Color of shape";
//   input Real jointUPS.universalShape1.specularCoefficient = jointUPS.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real jointUPS.universalShape1.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({jointUPS.universalShape1.lengthDirection[1],jointUPS.universalShape1.lengthDirection[2],jointUPS.universalShape1.lengthDirection[3]});
//   protected Real jointUPS.universalShape1.e_x[1](unit = "1") = if noEvent(jointUPS.universalShape1.abs_n_x < 1e-10) then 1.0 else jointUPS.universalShape1.lengthDirection[1] / jointUPS.universalShape1.abs_n_x;
//   protected Real jointUPS.universalShape1.e_x[2](unit = "1") = if noEvent(jointUPS.universalShape1.abs_n_x < 1e-10) then 0.0 else jointUPS.universalShape1.lengthDirection[2] / jointUPS.universalShape1.abs_n_x;
//   protected Real jointUPS.universalShape1.e_x[3](unit = "1") = if noEvent(jointUPS.universalShape1.abs_n_x < 1e-10) then 0.0 else jointUPS.universalShape1.lengthDirection[3] / jointUPS.universalShape1.abs_n_x;
//   protected Real jointUPS.universalShape1.n_z_aux[1](unit = "1") = jointUPS.universalShape1.e_x[2] * jointUPS.universalShape1.widthDirection[3] - jointUPS.universalShape1.e_x[3] * jointUPS.universalShape1.widthDirection[2];
//   protected Real jointUPS.universalShape1.n_z_aux[2](unit = "1") = jointUPS.universalShape1.e_x[3] * jointUPS.universalShape1.widthDirection[1] - jointUPS.universalShape1.e_x[1] * jointUPS.universalShape1.widthDirection[3];
//   protected Real jointUPS.universalShape1.n_z_aux[3](unit = "1") = jointUPS.universalShape1.e_x[1] * jointUPS.universalShape1.widthDirection[2] - jointUPS.universalShape1.e_x[2] * jointUPS.universalShape1.widthDirection[1];
//   protected Real jointUPS.universalShape1.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]},if noEvent(jointUPS.universalShape1.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape1.n_z_aux[2] ^ 2.0 + jointUPS.universalShape1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape1.widthDirection[1],jointUPS.universalShape1.widthDirection[2],jointUPS.universalShape1.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]})[1];
//   protected Real jointUPS.universalShape1.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]},if noEvent(jointUPS.universalShape1.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape1.n_z_aux[2] ^ 2.0 + jointUPS.universalShape1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape1.widthDirection[1],jointUPS.universalShape1.widthDirection[2],jointUPS.universalShape1.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]})[2];
//   protected Real jointUPS.universalShape1.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]},if noEvent(jointUPS.universalShape1.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape1.n_z_aux[2] ^ 2.0 + jointUPS.universalShape1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape1.widthDirection[1],jointUPS.universalShape1.widthDirection[2],jointUPS.universalShape1.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape1.e_x[1],jointUPS.universalShape1.e_x[2],jointUPS.universalShape1.e_x[3]})[3];
//   protected output Real jointUPS.universalShape1.Form;
//   output Real jointUPS.universalShape1.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape1.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.universalShape1.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.universalShape1.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real jointUPS.universalShape1.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape1.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape1.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape1.Material;
//   protected output Real jointUPS.universalShape1.Extra;
//   parameter String jointUPS.universalShape2.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real jointUPS.universalShape2.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real jointUPS.universalShape2.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape2.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape2.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real jointUPS.universalShape2.r[1](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape2.r[2](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape2.r[3](quantity = "Length", unit = "m") = jointUPS.frame_ia.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real jointUPS.universalShape2.r_shape[1](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.e2_ia[1] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape2.r_shape[2](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.e2_ia[2] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape2.r_shape[3](quantity = "Length", unit = "m") = (-jointUPS.cylinderLength) * jointUPS.e2_ia[3] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real jointUPS.universalShape2.lengthDirection[1](unit = "1") = jointUPS.e2_ia[1] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape2.lengthDirection[2](unit = "1") = jointUPS.e2_ia[2] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape2.lengthDirection[3](unit = "1") = jointUPS.e2_ia[3] "Vector in length direction, resolved in object frame";
//   input Real jointUPS.universalShape2.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape2.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape2.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real jointUPS.universalShape2.length(quantity = "Length", unit = "m") = jointUPS.cylinderLength "Length of visual object";
//   input Real jointUPS.universalShape2.width(quantity = "Length", unit = "m") = jointUPS.cylinderDiameter "Width of visual object";
//   input Real jointUPS.universalShape2.height(quantity = "Length", unit = "m") = jointUPS.cylinderDiameter "Height of visual object";
//   input Real jointUPS.universalShape2.extra = 0.0 "Additional size data for some of the shape types";
//   input Real jointUPS.universalShape2.color[1] = Real(jointUPS.cylinderColor[1]) "Color of shape";
//   input Real jointUPS.universalShape2.color[2] = Real(jointUPS.cylinderColor[2]) "Color of shape";
//   input Real jointUPS.universalShape2.color[3] = Real(jointUPS.cylinderColor[3]) "Color of shape";
//   input Real jointUPS.universalShape2.specularCoefficient = jointUPS.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real jointUPS.universalShape2.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({jointUPS.universalShape2.lengthDirection[1],jointUPS.universalShape2.lengthDirection[2],jointUPS.universalShape2.lengthDirection[3]});
//   protected Real jointUPS.universalShape2.e_x[1](unit = "1") = if noEvent(jointUPS.universalShape2.abs_n_x < 1e-10) then 1.0 else jointUPS.universalShape2.lengthDirection[1] / jointUPS.universalShape2.abs_n_x;
//   protected Real jointUPS.universalShape2.e_x[2](unit = "1") = if noEvent(jointUPS.universalShape2.abs_n_x < 1e-10) then 0.0 else jointUPS.universalShape2.lengthDirection[2] / jointUPS.universalShape2.abs_n_x;
//   protected Real jointUPS.universalShape2.e_x[3](unit = "1") = if noEvent(jointUPS.universalShape2.abs_n_x < 1e-10) then 0.0 else jointUPS.universalShape2.lengthDirection[3] / jointUPS.universalShape2.abs_n_x;
//   protected Real jointUPS.universalShape2.n_z_aux[1](unit = "1") = jointUPS.universalShape2.e_x[2] * jointUPS.universalShape2.widthDirection[3] - jointUPS.universalShape2.e_x[3] * jointUPS.universalShape2.widthDirection[2];
//   protected Real jointUPS.universalShape2.n_z_aux[2](unit = "1") = jointUPS.universalShape2.e_x[3] * jointUPS.universalShape2.widthDirection[1] - jointUPS.universalShape2.e_x[1] * jointUPS.universalShape2.widthDirection[3];
//   protected Real jointUPS.universalShape2.n_z_aux[3](unit = "1") = jointUPS.universalShape2.e_x[1] * jointUPS.universalShape2.widthDirection[2] - jointUPS.universalShape2.e_x[2] * jointUPS.universalShape2.widthDirection[1];
//   protected Real jointUPS.universalShape2.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]},if noEvent(jointUPS.universalShape2.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape2.n_z_aux[2] ^ 2.0 + jointUPS.universalShape2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape2.widthDirection[1],jointUPS.universalShape2.widthDirection[2],jointUPS.universalShape2.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]})[1];
//   protected Real jointUPS.universalShape2.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]},if noEvent(jointUPS.universalShape2.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape2.n_z_aux[2] ^ 2.0 + jointUPS.universalShape2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape2.widthDirection[1],jointUPS.universalShape2.widthDirection[2],jointUPS.universalShape2.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]})[2];
//   protected Real jointUPS.universalShape2.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]},if noEvent(jointUPS.universalShape2.n_z_aux[1] ^ 2.0 + (jointUPS.universalShape2.n_z_aux[2] ^ 2.0 + jointUPS.universalShape2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointUPS.universalShape2.widthDirection[1],jointUPS.universalShape2.widthDirection[2],jointUPS.universalShape2.widthDirection[3]} else if noEvent(abs(jointUPS.universalShape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointUPS.universalShape2.e_x[1],jointUPS.universalShape2.e_x[2],jointUPS.universalShape2.e_x[3]})[3];
//   protected output Real jointUPS.universalShape2.Form;
//   output Real jointUPS.universalShape2.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real jointUPS.universalShape2.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.universalShape2.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real jointUPS.universalShape2.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real jointUPS.universalShape2.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape2.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape2.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real jointUPS.universalShape2.Material;
//   protected output Real jointUPS.universalShape2.Extra;
//   Real body1.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body1.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body1.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body1.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real body1.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body1.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body1.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body1.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body1.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body1.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body1.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real body1.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real body1.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean body1.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real body1.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = 0.2 * jointUPS.eAxis_ia[1] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body1.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = 0.2 * jointUPS.eAxis_ia[2] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body1.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = 0.2 * jointUPS.eAxis_ia[3] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body1.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = m "Mass of rigid body";
//   parameter Real body1.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real body1.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real body1.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real body1.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real body1.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real body1.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real body1.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body1.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body1.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body1.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body1.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body1.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body1.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real body1.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real body1.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean body1.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real body1.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real body1.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real body1.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer body1.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer body1.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer body1.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean body1.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real body1.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real body1.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real body1.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean body1.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real body1.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body1.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body1.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body1.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer body1.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer body1.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer body1.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real body1.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = 0.05 "Diameter of cylinder";
//   input Integer body1.cylinderColor[1](min = 0, max = 255) = body1.sphereColor[1] "Color of cylinder";
//   input Integer body1.cylinderColor[2](min = 0, max = 255) = body1.sphereColor[2] "Color of cylinder";
//   input Integer body1.cylinderColor[3](min = 0, max = 255) = body1.sphereColor[3] "Color of cylinder";
//   input Real body1.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean body1.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean body1.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer body1.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer body1.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer body1.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real body1.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_11 "inertia tensor";
//   parameter Real body1.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_21 "inertia tensor";
//   parameter Real body1.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_31 "inertia tensor";
//   parameter Real body1.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_21 "inertia tensor";
//   parameter Real body1.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_22 "inertia tensor";
//   parameter Real body1.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_32 "inertia tensor";
//   parameter Real body1.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_31 "inertia tensor";
//   parameter Real body1.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_32 "inertia tensor";
//   parameter Real body1.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = body1.I_33 "inertia tensor";
//   parameter Real body1.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body1.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body1.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body1.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body1.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real body1.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real body1.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real body1.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[1], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body1.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[2], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body1.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[3], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body1.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[1], fixed = body1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body1.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[2], fixed = body1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body1.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[3], fixed = body1.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body1.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real body1.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real body1.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real body1.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body1.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body1.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body1.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real body1.Q[1](start = body1.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body1.Q[2](start = body1.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body1.Q[3](start = body1.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body1.Q[4](start = body1.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real body1.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real body1.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real body1.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real body1.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body1.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body1.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body1.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body1.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body1.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body1.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body1.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body1.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body1.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real body1.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real body1.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String body1.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real body1.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real body1.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.cylinder.r[1](quantity = "Length", unit = "m") = body1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.cylinder.r[2](quantity = "Length", unit = "m") = body1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.cylinder.r[3](quantity = "Length", unit = "m") = body1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.cylinder.lengthDirection[1](unit = "1") = body1.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real body1.cylinder.lengthDirection[2](unit = "1") = body1.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real body1.cylinder.lengthDirection[3](unit = "1") = body1.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real body1.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body1.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real body1.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body1.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}) > body1.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}) - (if body1.cylinderDiameter > 1.1 * body1.sphereDiameter then body1.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real body1.cylinder.width(quantity = "Length", unit = "m") = body1.cylinderDiameter "Width of visual object";
//   input Real body1.cylinder.height(quantity = "Length", unit = "m") = body1.cylinderDiameter "Height of visual object";
//   input Real body1.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real body1.cylinder.color[1] = Real(body1.cylinderColor[1]) "Color of shape";
//   input Real body1.cylinder.color[2] = Real(body1.cylinderColor[2]) "Color of shape";
//   input Real body1.cylinder.color[3] = Real(body1.cylinderColor[3]) "Color of shape";
//   input Real body1.cylinder.specularCoefficient = body1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real body1.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({body1.cylinder.lengthDirection[1],body1.cylinder.lengthDirection[2],body1.cylinder.lengthDirection[3]});
//   protected Real body1.cylinder.e_x[1](unit = "1") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 1.0 else body1.cylinder.lengthDirection[1] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.e_x[2](unit = "1") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 0.0 else body1.cylinder.lengthDirection[2] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.e_x[3](unit = "1") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 0.0 else body1.cylinder.lengthDirection[3] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.n_z_aux[1](unit = "1") = body1.cylinder.e_x[2] * body1.cylinder.widthDirection[3] - body1.cylinder.e_x[3] * body1.cylinder.widthDirection[2];
//   protected Real body1.cylinder.n_z_aux[2](unit = "1") = body1.cylinder.e_x[3] * body1.cylinder.widthDirection[1] - body1.cylinder.e_x[1] * body1.cylinder.widthDirection[3];
//   protected Real body1.cylinder.n_z_aux[3](unit = "1") = body1.cylinder.e_x[1] * body1.cylinder.widthDirection[2] - body1.cylinder.e_x[2] * body1.cylinder.widthDirection[1];
//   protected Real body1.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[1];
//   protected Real body1.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[2];
//   protected Real body1.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[3];
//   protected output Real body1.cylinder.Form;
//   output Real body1.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body1.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body1.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real body1.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.cylinder.Material;
//   protected output Real body1.cylinder.Extra;
//   parameter String body1.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real body1.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real body1.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body1.sphere.r[1](quantity = "Length", unit = "m") = body1.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.sphere.r[2](quantity = "Length", unit = "m") = body1.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.sphere.r[3](quantity = "Length", unit = "m") = body1.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body1.sphere.r_shape[1](quantity = "Length", unit = "m") = body1.r_CM[1] - body1.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.sphere.r_shape[2](quantity = "Length", unit = "m") = body1.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.sphere.r_shape[3](quantity = "Length", unit = "m") = body1.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body1.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real body1.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real body1.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real body1.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body1.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real body1.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body1.sphere.length(quantity = "Length", unit = "m") = body1.sphereDiameter "Length of visual object";
//   input Real body1.sphere.width(quantity = "Length", unit = "m") = body1.sphereDiameter "Width of visual object";
//   input Real body1.sphere.height(quantity = "Length", unit = "m") = body1.sphereDiameter "Height of visual object";
//   input Real body1.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real body1.sphere.color[1] = Real(body1.sphereColor[1]) "Color of shape";
//   input Real body1.sphere.color[2] = Real(body1.sphereColor[2]) "Color of shape";
//   input Real body1.sphere.color[3] = Real(body1.sphereColor[3]) "Color of shape";
//   input Real body1.sphere.specularCoefficient = body1.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real body1.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = "1") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = "1") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = "1") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = "1") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = "1") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = "1") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body1.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body1.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body1.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real body1.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   Real body2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real body2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real body2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real body2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real body2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real body2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real body2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean body2.animation = true "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real body2.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = -0.2 * jointUPS.eAxis_ia[1] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body2.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = -0.2 * jointUPS.eAxis_ia[2] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body2.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = -0.2 * jointUPS.eAxis_ia[3] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real body2.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = m "Mass of rigid body";
//   parameter Real body2.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (1,1) element of inertia tensor";
//   parameter Real body2.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (2,2) element of inertia tensor";
//   parameter Real body2.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 0.0 " (3,3) element of inertia tensor";
//   parameter Real body2.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (2,1) element of inertia tensor";
//   parameter Real body2.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,1) element of inertia tensor";
//   parameter Real body2.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = 0.0 " (3,2) element of inertia tensor";
//   Real body2.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body2.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body2.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real body2.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body2.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body2.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real body2.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real body2.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real body2.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean body2.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real body2.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real body2.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real body2.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer body2.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer body2.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer body2.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean body2.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real body2.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real body2.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real body2.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean body2.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real body2.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body2.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body2.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real body2.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer body2.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer body2.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer body2.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real body2.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = 0.05 "Diameter of cylinder";
//   input Integer body2.cylinderColor[1](min = 0, max = 255) = body2.sphereColor[1] "Color of cylinder";
//   input Integer body2.cylinderColor[2](min = 0, max = 255) = body2.sphereColor[2] "Color of cylinder";
//   input Integer body2.cylinderColor[3](min = 0, max = 255) = body2.sphereColor[3] "Color of cylinder";
//   input Real body2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean body2.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean body2.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer body2.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer body2.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer body2.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real body2.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_11 "inertia tensor";
//   parameter Real body2.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_21 "inertia tensor";
//   parameter Real body2.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_31 "inertia tensor";
//   parameter Real body2.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_21 "inertia tensor";
//   parameter Real body2.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_22 "inertia tensor";
//   parameter Real body2.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_32 "inertia tensor";
//   parameter Real body2.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_31 "inertia tensor";
//   parameter Real body2.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_32 "inertia tensor";
//   parameter Real body2.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = body2.I_33 "inertia tensor";
//   parameter Real body2.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real body2.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body2.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body2.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real body2.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real body2.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real body2.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real body2.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[1], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body2.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[2], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body2.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[3], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real body2.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[1], fixed = body2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body2.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[2], fixed = body2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body2.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[3], fixed = body2.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real body2.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real body2.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real body2.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real body2.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body2.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body2.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real body2.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real body2.Q[1](start = body2.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body2.Q[2](start = body2.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body2.Q[3](start = body2.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real body2.Q[4](start = body2.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real body2.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real body2.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real body2.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real body2.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body2.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body2.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body2.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body2.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = body2.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real body2.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body2.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body2.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real body2.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real body2.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real body2.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   parameter String body2.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real body2.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real body2.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.cylinder.r[1](quantity = "Length", unit = "m") = body2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.cylinder.r[2](quantity = "Length", unit = "m") = body2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.cylinder.r[3](quantity = "Length", unit = "m") = body2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.cylinder.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.cylinder.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.cylinder.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.cylinder.lengthDirection[1](unit = "1") = body2.r_CM[1] "Vector in length direction, resolved in object frame";
//   input Real body2.cylinder.lengthDirection[2](unit = "1") = body2.r_CM[2] "Vector in length direction, resolved in object frame";
//   input Real body2.cylinder.lengthDirection[3](unit = "1") = body2.r_CM[3] "Vector in length direction, resolved in object frame";
//   input Real body2.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body2.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real body2.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body2.cylinder.length(quantity = "Length", unit = "m") = if Modelica.Math.Vectors.length({body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}) > body2.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}) - (if body2.cylinderDiameter > 1.1 * body2.sphereDiameter then body2.sphereDiameter / 2.0 else 0.0) else 0.0 "Length of visual object";
//   input Real body2.cylinder.width(quantity = "Length", unit = "m") = body2.cylinderDiameter "Width of visual object";
//   input Real body2.cylinder.height(quantity = "Length", unit = "m") = body2.cylinderDiameter "Height of visual object";
//   input Real body2.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real body2.cylinder.color[1] = Real(body2.cylinderColor[1]) "Color of shape";
//   input Real body2.cylinder.color[2] = Real(body2.cylinderColor[2]) "Color of shape";
//   input Real body2.cylinder.color[3] = Real(body2.cylinderColor[3]) "Color of shape";
//   input Real body2.cylinder.specularCoefficient = body2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real body2.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({body2.cylinder.lengthDirection[1],body2.cylinder.lengthDirection[2],body2.cylinder.lengthDirection[3]});
//   protected Real body2.cylinder.e_x[1](unit = "1") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 1.0 else body2.cylinder.lengthDirection[1] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.e_x[2](unit = "1") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 0.0 else body2.cylinder.lengthDirection[2] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.e_x[3](unit = "1") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 0.0 else body2.cylinder.lengthDirection[3] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.n_z_aux[1](unit = "1") = body2.cylinder.e_x[2] * body2.cylinder.widthDirection[3] - body2.cylinder.e_x[3] * body2.cylinder.widthDirection[2];
//   protected Real body2.cylinder.n_z_aux[2](unit = "1") = body2.cylinder.e_x[3] * body2.cylinder.widthDirection[1] - body2.cylinder.e_x[1] * body2.cylinder.widthDirection[3];
//   protected Real body2.cylinder.n_z_aux[3](unit = "1") = body2.cylinder.e_x[1] * body2.cylinder.widthDirection[2] - body2.cylinder.e_x[2] * body2.cylinder.widthDirection[1];
//   protected Real body2.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[1];
//   protected Real body2.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[2];
//   protected Real body2.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[3];
//   protected output Real body2.cylinder.Form;
//   output Real body2.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body2.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body2.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real body2.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.cylinder.Material;
//   protected output Real body2.cylinder.Extra;
//   parameter String body2.sphere.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real body2.sphere.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real body2.sphere.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.sphere.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.sphere.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real body2.sphere.r[1](quantity = "Length", unit = "m") = body2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.sphere.r[2](quantity = "Length", unit = "m") = body2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.sphere.r[3](quantity = "Length", unit = "m") = body2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real body2.sphere.r_shape[1](quantity = "Length", unit = "m") = body2.r_CM[1] - body2.sphereDiameter / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.sphere.r_shape[2](quantity = "Length", unit = "m") = body2.r_CM[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.sphere.r_shape[3](quantity = "Length", unit = "m") = body2.r_CM[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real body2.sphere.lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real body2.sphere.lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real body2.sphere.lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real body2.sphere.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body2.sphere.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real body2.sphere.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real body2.sphere.length(quantity = "Length", unit = "m") = body2.sphereDiameter "Length of visual object";
//   input Real body2.sphere.width(quantity = "Length", unit = "m") = body2.sphereDiameter "Width of visual object";
//   input Real body2.sphere.height(quantity = "Length", unit = "m") = body2.sphereDiameter "Height of visual object";
//   input Real body2.sphere.extra = 0.0 "Additional size data for some of the shape types";
//   input Real body2.sphere.color[1] = Real(body2.sphereColor[1]) "Color of shape";
//   input Real body2.sphere.color[2] = Real(body2.sphereColor[2]) "Color of shape";
//   input Real body2.sphere.color[3] = Real(body2.sphereColor[3]) "Color of shape";
//   input Real body2.sphere.specularCoefficient = body2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real body2.sphere.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({body2.sphere.lengthDirection[1],body2.sphere.lengthDirection[2],body2.sphere.lengthDirection[3]});
//   protected Real body2.sphere.e_x[1](unit = "1") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 1.0 else body2.sphere.lengthDirection[1] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[2](unit = "1") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[2] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[3](unit = "1") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[3] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.n_z_aux[1](unit = "1") = body2.sphere.e_x[2] * body2.sphere.widthDirection[3] - body2.sphere.e_x[3] * body2.sphere.widthDirection[2];
//   protected Real body2.sphere.n_z_aux[2](unit = "1") = body2.sphere.e_x[3] * body2.sphere.widthDirection[1] - body2.sphere.e_x[1] * body2.sphere.widthDirection[3];
//   protected Real body2.sphere.n_z_aux[3](unit = "1") = body2.sphere.e_x[1] * body2.sphere.widthDirection[2] - body2.sphere.e_x[2] * body2.sphere.widthDirection[1];
//   protected Real body2.sphere.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[1];
//   protected Real body2.sphere.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[2];
//   protected Real body2.sphere.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[3];
//   protected output Real body2.sphere.Form;
//   output Real body2.sphere.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real body2.sphere.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body2.sphere.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real body2.sphere.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real body2.sphere.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.sphere.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.sphere.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real body2.sphere.Material;
//   protected output Real body2.sphere.Extra;
//   Real rod2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod2.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod2.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod2.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod2.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod2.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod2.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod2.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean rod2.animation = false "= true, if animation shall be enabled";
//   parameter Real rod2.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod2.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.3 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod2.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String rod2.shapeType = "cylinder" " Type of shape";
//   parameter Real rod2.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod2.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod2.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod2.lengthDirection[1](unit = "1") = rod2.r[1] - rod2.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod2.lengthDirection[2](unit = "1") = rod2.r[2] - rod2.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod2.lengthDirection[3](unit = "1") = rod2.r[3] - rod2.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod2.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod2.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod2.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod2.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({rod2.r[1] - rod2.r_shape[1],rod2.r[2] - rod2.r_shape[2],rod2.r[3] - rod2.r_shape[3]}) " Length of shape";
//   parameter Real rod2.width(quantity = "Length", unit = "m", min = 0.0) = 0.01 " Width of shape";
//   parameter Real rod2.height(quantity = "Length", unit = "m", min = 0.0) = rod2.width " Height of shape.";
//   parameter Real rod2.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer rod2.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod2.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod2.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real rod2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) damper1.stateSelect = StateSelect.prefer "Priority to use phi_rel and w_rel as states";
//   parameter Real damper1.s_nominal(quantity = "Length", unit = "m", min = 0.0) = 0.0001 "Nominal value of s_rel (used for scaling)";
//   Real damper1.s_rel(quantity = "Length", unit = "m", min = 0.0, start = 0.0, nominal = damper1.s_nominal, StateSelect = StateSelect.prefer) "Relative distance (= flange_b.s - flange_a.s)";
//   Real damper1.v_rel(quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.prefer) "Relative velocity (= der(s_rel))";
//   Real damper1.f(quantity = "Force", unit = "N") "Forces between flanges (= flange_b.f)";
//   Real damper1.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real damper1.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real damper1.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real damper1.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Real damper1.d(quantity = "TranslationalDampingConstant", unit = "N.s/m", min = 0.0, start = 0.0) = 3.0 "damping constant";
//   Real revolute2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute2.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real revolute2.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real revolute2.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute2.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real revolute2.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean revolute2.useAxisFlange = false "= true, if axis flange is enabled";
//   parameter Boolean revolute2.animation = true "= true, if animation shall be enabled (show axis as cylinder)";
//   parameter Real revolute2.n[1](unit = "1") = 0.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   parameter Real revolute2.n[2](unit = "1") = 0.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   parameter Real revolute2.n[3](unit = "1") = 1.0 "Axis of rotation resolved in frame_a (= same as in frame_b)";
//   constant Real revolute2.phi_offset(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Relative angle offset (angle = phi_offset + phi)";
//   parameter Real revolute2.cylinderLength(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointLength "Length of cylinder representing the joint axis";
//   parameter Real revolute2.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultJointWidth "Diameter of cylinder representing the joint axis";
//   input Integer revolute2.cylinderColor[1](min = 0, max = 255) = 255 "Color of cylinder representing the joint axis";
//   input Integer revolute2.cylinderColor[2](min = 0, max = 255) = 0 "Color of cylinder representing the joint axis";
//   input Integer revolute2.cylinderColor[3](min = 0, max = 255) = 0 "Color of cylinder representing the joint axis";
//   input Real revolute2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) revolute2.stateSelect = StateSelect.prefer "Priority to use joint angle phi and w=der(phi) as states";
//   Real revolute2.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) "Relative rotation angle from frame_a to frame_b";
//   Real revolute2.w(quantity = "AngularVelocity", unit = "rad/s", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) "First derivative of angle phi (relative angular velocity)";
//   Real revolute2.a(quantity = "AngularAcceleration", unit = "rad/s2", start = 0.0) "Second derivative of angle phi (relative angular acceleration)";
//   Real revolute2.tau(quantity = "Torque", unit = "N.m") "Driving torque in direction of axis of rotation";
//   Real revolute2.angle(quantity = "Angle", unit = "rad", displayUnit = "deg") "= phi_offset + phi";
//   protected parameter Real revolute2.e[1](unit = "1") = Modelica.Math.Vectors.normalize({revolute2.n[1],revolute2.n[2],revolute2.n[3]},1e-13)[1] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   protected parameter Real revolute2.e[2](unit = "1") = Modelica.Math.Vectors.normalize({revolute2.n[1],revolute2.n[2],revolute2.n[3]},1e-13)[2] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   protected parameter Real revolute2.e[3](unit = "1") = Modelica.Math.Vectors.normalize({revolute2.n[1],revolute2.n[2],revolute2.n[3]},1e-13)[3] "Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)";
//   Real revolute2.R_rel.T[1,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[1,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[1,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[2,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[2,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[2,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[3,1] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[3,2] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.T[3,3] "Transformation matrix from world frame to local frame";
//   Real revolute2.R_rel.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.R_rel.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real revolute2.R_rel.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   parameter String revolute2.cylinder.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real revolute2.cylinder.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real revolute2.cylinder.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute2.cylinder.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute2.cylinder.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real revolute2.cylinder.r[1](quantity = "Length", unit = "m") = revolute2.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute2.cylinder.r[2](quantity = "Length", unit = "m") = revolute2.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute2.cylinder.r[3](quantity = "Length", unit = "m") = revolute2.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real revolute2.cylinder.r_shape[1](quantity = "Length", unit = "m") = (-revolute2.cylinderLength) * revolute2.e[1] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute2.cylinder.r_shape[2](quantity = "Length", unit = "m") = (-revolute2.cylinderLength) * revolute2.e[2] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute2.cylinder.r_shape[3](quantity = "Length", unit = "m") = (-revolute2.cylinderLength) * revolute2.e[3] / 2.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real revolute2.cylinder.lengthDirection[1](unit = "1") = revolute2.e[1] "Vector in length direction, resolved in object frame";
//   input Real revolute2.cylinder.lengthDirection[2](unit = "1") = revolute2.e[2] "Vector in length direction, resolved in object frame";
//   input Real revolute2.cylinder.lengthDirection[3](unit = "1") = revolute2.e[3] "Vector in length direction, resolved in object frame";
//   input Real revolute2.cylinder.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real revolute2.cylinder.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real revolute2.cylinder.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real revolute2.cylinder.length(quantity = "Length", unit = "m") = revolute2.cylinderLength "Length of visual object";
//   input Real revolute2.cylinder.width(quantity = "Length", unit = "m") = revolute2.cylinderDiameter "Width of visual object";
//   input Real revolute2.cylinder.height(quantity = "Length", unit = "m") = revolute2.cylinderDiameter "Height of visual object";
//   input Real revolute2.cylinder.extra = 0.0 "Additional size data for some of the shape types";
//   input Real revolute2.cylinder.color[1] = Real(revolute2.cylinderColor[1]) "Color of shape";
//   input Real revolute2.cylinder.color[2] = Real(revolute2.cylinderColor[2]) "Color of shape";
//   input Real revolute2.cylinder.color[3] = Real(revolute2.cylinderColor[3]) "Color of shape";
//   input Real revolute2.cylinder.specularCoefficient = revolute2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real revolute2.cylinder.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({revolute2.cylinder.lengthDirection[1],revolute2.cylinder.lengthDirection[2],revolute2.cylinder.lengthDirection[3]});
//   protected Real revolute2.cylinder.e_x[1](unit = "1") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 1.0 else revolute2.cylinder.lengthDirection[1] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[2](unit = "1") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[2] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.e_x[3](unit = "1") = if noEvent(revolute2.cylinder.abs_n_x < 1e-10) then 0.0 else revolute2.cylinder.lengthDirection[3] / revolute2.cylinder.abs_n_x;
//   protected Real revolute2.cylinder.n_z_aux[1](unit = "1") = revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[3] - revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[2];
//   protected Real revolute2.cylinder.n_z_aux[2](unit = "1") = revolute2.cylinder.e_x[3] * revolute2.cylinder.widthDirection[1] - revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[3];
//   protected Real revolute2.cylinder.n_z_aux[3](unit = "1") = revolute2.cylinder.e_x[1] * revolute2.cylinder.widthDirection[2] - revolute2.cylinder.e_x[2] * revolute2.cylinder.widthDirection[1];
//   protected Real revolute2.cylinder.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[1];
//   protected Real revolute2.cylinder.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[2];
//   protected Real revolute2.cylinder.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]},if noEvent(revolute2.cylinder.n_z_aux[1] ^ 2.0 + (revolute2.cylinder.n_z_aux[2] ^ 2.0 + revolute2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {revolute2.cylinder.widthDirection[1],revolute2.cylinder.widthDirection[2],revolute2.cylinder.widthDirection[3]} else if noEvent(abs(revolute2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{revolute2.cylinder.e_x[1],revolute2.cylinder.e_x[2],revolute2.cylinder.e_x[3]})[3];
//   protected output Real revolute2.cylinder.Form;
//   output Real revolute2.cylinder.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real revolute2.cylinder.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real revolute2.cylinder.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real revolute2.cylinder.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real revolute2.cylinder.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute2.cylinder.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute2.cylinder.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real revolute2.cylinder.Material;
//   protected output Real revolute2.cylinder.Extra;
//   parameter Real revolute2.fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real revolute2.fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute2.fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   input Real revolute2.internalAxis.tau(quantity = "Torque", unit = "N.m") = revolute2.tau "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)";
//   Real revolute2.internalAxis.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "External support angle (= flange.phi)";
//   Real revolute2.internalAxis.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute2.internalAxis.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Boolean revolute2.constantTorque.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real revolute2.constantTorque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real revolute2.constantTorque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real revolute2.constantTorque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   Real revolute2.constantTorque.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of flange with respect to support (= flange.phi - support.phi)";
//   parameter Real revolute2.constantTorque.tau_constant(quantity = "Torque", unit = "N.m") = 0.0 "Constant torque (if negative, torque is acting as load)";
//   Real revolute2.constantTorque.tau(quantity = "Torque", unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
//   Real bodyBox2.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox2.animation = true "= true, if animation shall be enabled (show box between frame_a and frame_b)";
//   parameter Real bodyBox2.r[1](quantity = "Length", unit = "m", start = 0.1) = 0.7 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox2.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox2.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox2.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox2.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox2.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Vector from frame_a to box origin, resolved in frame_a";
//   parameter Real bodyBox2.lengthDirection[1](unit = "1") = bodyBox2.r[1] - bodyBox2.r_shape[1] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox2.lengthDirection[2](unit = "1") = bodyBox2.r[2] - bodyBox2.r_shape[2] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox2.lengthDirection[3](unit = "1") = bodyBox2.r[3] - bodyBox2.r_shape[3] "Vector in length direction of box, resolved in frame_a";
//   parameter Real bodyBox2.widthDirection[1](unit = "1") = 0.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox2.widthDirection[2](unit = "1") = 1.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox2.widthDirection[3](unit = "1") = 0.0 "Vector in width direction of box, resolved in frame_a";
//   parameter Real bodyBox2.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({bodyBox2.r[1] - bodyBox2.r_shape[1],bodyBox2.r[2] - bodyBox2.r_shape[2],bodyBox2.r[3] - bodyBox2.r_shape[3]}) "Length of box";
//   parameter Real bodyBox2.width(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.length / world.defaultWidthFraction "Width of box";
//   parameter Real bodyBox2.height(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.width "Height of box";
//   parameter Real bodyBox2.innerWidth(quantity = "Length", unit = "m", min = 0.0) = 0.0 "Width of inner box surface (0 <= innerWidth <= width)";
//   parameter Real bodyBox2.innerHeight(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.innerWidth "Height of inner box surface (0 <= innerHeight <= height)";
//   parameter Real bodyBox2.density(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 7700.0 "Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)";
//   input Integer bodyBox2.color[1](min = 0, max = 255) = 0 "Color of box";
//   input Integer bodyBox2.color[2](min = 0, max = 255) = 128 "Color of box";
//   input Integer bodyBox2.color[3](min = 0, max = 255) = 255 "Color of box";
//   input Real bodyBox2.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   Real bodyBox2.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox2.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox2.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean bodyBox2.angles_fixed = false "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox2.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox2.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer bodyBox2.sequence_start[1](min = 1, max = 3) = 1 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox2.sequence_start[2](min = 1, max = 3) = 2 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox2.sequence_start[3](min = 1, max = 3) = 3 "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean bodyBox2.w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox2.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox2.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean bodyBox2.z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox2.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox2.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Boolean bodyBox2.enforceStates = false " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean bodyBox2.useQuaternions = true " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer bodyBox2.sequence_angleStates[1](min = 1, max = 3) = 1 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox2.sequence_angleStates[2](min = 1, max = 3) = 2 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox2.sequence_angleStates[3](min = 1, max = 3) = 3 " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real bodyBox2.mo(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox2.density * (bodyBox2.length * (bodyBox2.width * bodyBox2.height)) "Mass of box without hole";
//   parameter Real bodyBox2.mi(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox2.density * (bodyBox2.length * (bodyBox2.innerWidth * bodyBox2.innerHeight)) "Mass of hole of box";
//   parameter Real bodyBox2.m(quantity = "Mass", unit = "kg", min = 0.0) = bodyBox2.mo - bodyBox2.mi "Mass of box";
//   parameter Real bodyBox2.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.r_CM[1](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox2.r[1],bodyBox2.r[2],bodyBox2.r[3]},1e-13)[1] * bodyBox2.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.r_CM[2](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox2.r[1],bodyBox2.r[2],bodyBox2.r[3]},1e-13)[2] * bodyBox2.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.r_CM[3](quantity = "Length", unit = "m") = Modelica.Math.Vectors.normalize({bodyBox2.r[1],bodyBox2.r[2],bodyBox2.r[3]},1e-13)[3] * bodyBox2.length / 2.0 "Position vector from origin of frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[1][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[1][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[1][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[2][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[2][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[2][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[3][1] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[3][2] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   parameter Real bodyBox2.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = Modelica.Mechanics.MultiBody.Frames.resolveDyade1(bodyBox2.R,{{bodyBox2.mo * (bodyBox2.width ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.innerWidth ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0,0.0},{0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.height ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerHeight ^ 2.0 / 12.0),0.0},{0.0,0.0,bodyBox2.mo * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.width ^ 2.0 / 12.0) - bodyBox2.mi * (bodyBox2.length ^ 2.0 / 12.0 + bodyBox2.innerWidth ^ 2.0 / 12.0)}})[3][3] "Inertia tensor of body box with respect to center of mass, parallel to frame_a";
//   Real bodyBox2.body.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.body.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.body.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.body.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.body.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.body.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.body.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.body.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.body.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.body.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.body.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.body.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.body.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox2.body.animation = false "= true, if animation shall be enabled (show cylinder and sphere)";
//   parameter Real bodyBox2.body.r_CM[1](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r_CM[1] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.body.r_CM[2](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r_CM[2] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.body.r_CM[3](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r_CM[3] "Vector from frame_a to center of mass, resolved in frame_a";
//   parameter Real bodyBox2.body.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = bodyBox2.m "Mass of rigid body";
//   parameter Real bodyBox2.body.I_11(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox2.I[1,1] " (1,1) element of inertia tensor";
//   parameter Real bodyBox2.body.I_22(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox2.I[2,2] " (2,2) element of inertia tensor";
//   parameter Real bodyBox2.body.I_33(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = bodyBox2.I[3,3] " (3,3) element of inertia tensor";
//   parameter Real bodyBox2.body.I_21(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox2.I[2,1] " (2,1) element of inertia tensor";
//   parameter Real bodyBox2.body.I_31(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox2.I[3,1] " (3,1) element of inertia tensor";
//   parameter Real bodyBox2.body.I_32(quantity = "MomentOfInertia", unit = "kg.m2", min = -1e+60) = bodyBox2.I[3,2] " (3,2) element of inertia tensor";
//   Real bodyBox2.body.r_0[1](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.body.r_0[2](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.body.r_0[3](quantity = "Length", unit = "m", start = 0.0, StateSelect = StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a";
//   Real bodyBox2.body.v_0[1](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.body.v_0[2](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.body.v_0[3](quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))";
//   Real bodyBox2.body.a_0[1](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox2.body.a_0[2](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   Real bodyBox2.body.a_0[3](quantity = "Acceleration", unit = "m/s2", start = 0.0) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))";
//   parameter Boolean bodyBox2.body.angles_fixed = bodyBox2.angles_fixed "= true, if angles_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.body.angles_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox2.angles_start[1] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox2.body.angles_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox2.angles_start[2] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Real bodyBox2.body.angles_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = bodyBox2.angles_start[3] "Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b";
//   parameter Integer bodyBox2.body.sequence_start[1](min = 1, max = 3) = bodyBox2.sequence_start[1] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox2.body.sequence_start[2](min = 1, max = 3) = bodyBox2.sequence_start[2] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Integer bodyBox2.body.sequence_start[3](min = 1, max = 3) = bodyBox2.sequence_start[3] "Sequence of rotations to rotate frame_a into frame_b at initial time";
//   parameter Boolean bodyBox2.body.w_0_fixed = bodyBox2.w_0_fixed "= true, if w_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.body.w_0_start[1](quantity = "AngularVelocity", unit = "rad/s") = bodyBox2.w_0_start[1] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox2.body.w_0_start[2](quantity = "AngularVelocity", unit = "rad/s") = bodyBox2.w_0_start[2] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Real bodyBox2.body.w_0_start[3](quantity = "AngularVelocity", unit = "rad/s") = bodyBox2.w_0_start[3] "Initial or guess values of angular velocity of frame_a resolved in world frame";
//   parameter Boolean bodyBox2.body.z_0_fixed = bodyBox2.z_0_fixed "= true, if z_0_start are used as initial values, else as guess values";
//   parameter Real bodyBox2.body.z_0_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox2.z_0_start[1] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox2.body.z_0_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox2.z_0_start[2] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox2.body.z_0_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = bodyBox2.z_0_start[3] "Initial values of angular acceleration z_0 = der(w_0)";
//   parameter Real bodyBox2.body.sphereDiameter(quantity = "Length", unit = "m", min = 0.0) = world.defaultBodyDiameter "Diameter of sphere";
//   input Integer bodyBox2.body.sphereColor[1](min = 0, max = 255) = 0 "Color of sphere";
//   input Integer bodyBox2.body.sphereColor[2](min = 0, max = 255) = 128 "Color of sphere";
//   input Integer bodyBox2.body.sphereColor[3](min = 0, max = 255) = 255 "Color of sphere";
//   parameter Real bodyBox2.body.cylinderDiameter(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.body.sphereDiameter / 3.0 "Diameter of cylinder";
//   input Integer bodyBox2.body.cylinderColor[1](min = 0, max = 255) = bodyBox2.body.sphereColor[1] "Color of cylinder";
//   input Integer bodyBox2.body.cylinderColor[2](min = 0, max = 255) = bodyBox2.body.sphereColor[2] "Color of cylinder";
//   input Integer bodyBox2.body.cylinderColor[3](min = 0, max = 255) = bodyBox2.body.sphereColor[3] "Color of cylinder";
//   input Real bodyBox2.body.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter Boolean bodyBox2.body.enforceStates = bodyBox2.enforceStates " = true, if absolute variables of body object shall be used as states (StateSelect.always)";
//   parameter Boolean bodyBox2.body.useQuaternions = bodyBox2.useQuaternions " = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states";
//   parameter Integer bodyBox2.body.sequence_angleStates[1](min = 1, max = 3) = bodyBox2.sequence_angleStates[1] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox2.body.sequence_angleStates[2](min = 1, max = 3) = bodyBox2.sequence_angleStates[2] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Integer bodyBox2.body.sequence_angleStates[3](min = 1, max = 3) = bodyBox2.sequence_angleStates[3] " Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states";
//   parameter Real bodyBox2.body.I[1,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_11 "inertia tensor";
//   parameter Real bodyBox2.body.I[1,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_21 "inertia tensor";
//   parameter Real bodyBox2.body.I[1,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_31 "inertia tensor";
//   parameter Real bodyBox2.body.I[2,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_21 "inertia tensor";
//   parameter Real bodyBox2.body.I[2,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_22 "inertia tensor";
//   parameter Real bodyBox2.body.I[2,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_32 "inertia tensor";
//   parameter Real bodyBox2.body.I[3,1](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_31 "inertia tensor";
//   parameter Real bodyBox2.body.I[3,2](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_32 "inertia tensor";
//   parameter Real bodyBox2.body.I[3,3](quantity = "MomentOfInertia", unit = "kg.m2") = bodyBox2.body.I_33 "inertia tensor";
//   parameter Real bodyBox2.body.R_start.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   parameter Real bodyBox2.body.R_start.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.body.R_start.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.body.R_start.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   parameter Real bodyBox2.body.z_a_start[1](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[1] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real bodyBox2.body.z_a_start[2](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[2] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   parameter Real bodyBox2.body.z_a_start[3](quantity = "AngularAcceleration", unit = "rad/s2") = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[3] "Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a";
//   Real bodyBox2.body.w_a[1](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.w_0_start[1],bodyBox2.body.w_0_start[2],bodyBox2.body.w_0_start[3]})[1], fixed = bodyBox2.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox2.body.w_a[2](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.w_0_start[1],bodyBox2.body.w_0_start[2],bodyBox2.body.w_0_start[3]})[2], fixed = bodyBox2.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox2.body.w_a[3](quantity = "AngularVelocity", unit = "rad/s", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.w_0_start[1],bodyBox2.body.w_0_start[2],bodyBox2.body.w_0_start[3]})[3], fixed = bodyBox2.body.w_0_fixed, StateSelect = StateSelect.avoid) "Absolute angular velocity of frame_a resolved in frame_a";
//   Real bodyBox2.body.z_a[1](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[1], fixed = bodyBox2.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox2.body.z_a[2](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[2], fixed = bodyBox2.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox2.body.z_a[3](quantity = "AngularAcceleration", unit = "rad/s2", start = Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.R_start,{bodyBox2.body.z_0_start[1],bodyBox2.body.z_0_start[2],bodyBox2.body.z_0_start[3]})[3], fixed = bodyBox2.body.z_0_fixed) "Absolute angular acceleration of frame_a resolved in frame_a";
//   Real bodyBox2.body.g_0[1](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real bodyBox2.body.g_0[2](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   Real bodyBox2.body.g_0[3](quantity = "Acceleration", unit = "m/s2") "Gravity acceleration resolved in world frame";
//   protected parameter Real bodyBox2.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox2.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox2.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected parameter Real bodyBox2.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(bodyBox2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] "Quaternion orientation object from world frame to frame_a at initial time";
//   protected Real bodyBox2.body.Q[1](start = bodyBox2.body.Q_start[1], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox2.body.Q[2](start = bodyBox2.body.Q_start[2], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox2.body.Q[3](start = bodyBox2.body.Q_start[3], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected Real bodyBox2.body.Q[4](start = bodyBox2.body.Q_start[4], StateSelect = StateSelect.avoid) "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
//   protected parameter Real bodyBox2.body.phi_start[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox2.body.sequence_start[1] == bodyBox2.body.sequence_angleStates[1] AND bodyBox2.body.sequence_start[2] == bodyBox2.body.sequence_angleStates[2] AND bodyBox2.body.sequence_start[3] == bodyBox2.body.sequence_angleStates[3] then bodyBox2.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox2.body.R_start,{bodyBox2.body.sequence_angleStates[1],bodyBox2.body.sequence_angleStates[2],bodyBox2.body.sequence_angleStates[3]},0.0)[1] "Potential angle states at initial time";
//   protected parameter Real bodyBox2.body.phi_start[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox2.body.sequence_start[1] == bodyBox2.body.sequence_angleStates[1] AND bodyBox2.body.sequence_start[2] == bodyBox2.body.sequence_angleStates[2] AND bodyBox2.body.sequence_start[3] == bodyBox2.body.sequence_angleStates[3] then bodyBox2.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox2.body.R_start,{bodyBox2.body.sequence_angleStates[1],bodyBox2.body.sequence_angleStates[2],bodyBox2.body.sequence_angleStates[3]},0.0)[2] "Potential angle states at initial time";
//   protected parameter Real bodyBox2.body.phi_start[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = if bodyBox2.body.sequence_start[1] == bodyBox2.body.sequence_angleStates[1] AND bodyBox2.body.sequence_start[2] == bodyBox2.body.sequence_angleStates[2] AND bodyBox2.body.sequence_start[3] == bodyBox2.body.sequence_angleStates[3] then bodyBox2.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(bodyBox2.body.R_start,{bodyBox2.body.sequence_angleStates[1],bodyBox2.body.sequence_angleStates[2],bodyBox2.body.sequence_angleStates[3]},0.0)[3] "Potential angle states at initial time";
//   protected Real bodyBox2.body.phi[1](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox2.body.phi_start[1], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox2.body.phi[2](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox2.body.phi_start[2], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox2.body.phi[3](quantity = "Angle", unit = "rad", displayUnit = "deg", start = bodyBox2.body.phi_start[3], StateSelect = StateSelect.avoid) "Dummy or 3 angles to rotate world frame into frame_a of body";
//   protected Real bodyBox2.body.phi_d[1](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox2.body.phi_d[2](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox2.body.phi_d[3](quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.avoid) "= der(phi)";
//   protected Real bodyBox2.body.phi_dd[1](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real bodyBox2.body.phi_dd[2](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   protected Real bodyBox2.body.phi_dd[3](quantity = "AngularAcceleration", unit = "rad/s2") "= der(phi_d)";
//   Real bodyBox2.frameTranslation.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real bodyBox2.frameTranslation.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real bodyBox2.frameTranslation.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean bodyBox2.frameTranslation.animation = bodyBox2.animation "= true, if animation shall be enabled";
//   parameter Real bodyBox2.frameTranslation.r[1](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r[1] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.r[2](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r[2] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.r[3](quantity = "Length", unit = "m", start = 0.0) = bodyBox2.r[3] "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String bodyBox2.frameTranslation.shapeType = "box" " Type of shape";
//   parameter Real bodyBox2.frameTranslation.r_shape[1](quantity = "Length", unit = "m") = bodyBox2.r_shape[1] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.r_shape[2](quantity = "Length", unit = "m") = bodyBox2.r_shape[2] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.r_shape[3](quantity = "Length", unit = "m") = bodyBox2.r_shape[3] " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.lengthDirection[1](unit = "1") = bodyBox2.lengthDirection[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.lengthDirection[2](unit = "1") = bodyBox2.lengthDirection[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.lengthDirection[3](unit = "1") = bodyBox2.lengthDirection[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.widthDirection[1](unit = "1") = bodyBox2.widthDirection[1] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.widthDirection[2](unit = "1") = bodyBox2.widthDirection[2] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.widthDirection[3](unit = "1") = bodyBox2.widthDirection[3] " Vector in width direction of shape, resolved in frame_a";
//   parameter Real bodyBox2.frameTranslation.length(quantity = "Length", unit = "m") = bodyBox2.length " Length of shape";
//   parameter Real bodyBox2.frameTranslation.width(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.width " Width of shape";
//   parameter Real bodyBox2.frameTranslation.height(quantity = "Length", unit = "m", min = 0.0) = bodyBox2.height " Height of shape.";
//   parameter Real bodyBox2.frameTranslation.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer bodyBox2.frameTranslation.color[1](min = 0, max = 255) = bodyBox2.color[1] " Color of shape";
//   input Integer bodyBox2.frameTranslation.color[2](min = 0, max = 255) = bodyBox2.color[2] " Color of shape";
//   input Integer bodyBox2.frameTranslation.color[3](min = 0, max = 255) = bodyBox2.color[3] " Color of shape";
//   input Real bodyBox2.frameTranslation.specularCoefficient = bodyBox2.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter String bodyBox2.frameTranslation.shape.shapeType = bodyBox2.frameTranslation.shapeType "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real bodyBox2.frameTranslation.shape.R.T[1,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[1,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[1,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[2,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[2,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[2,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[3,1] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[3,2] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.T[3,3] "Transformation matrix from world frame to local frame";
//   input Real bodyBox2.frameTranslation.shape.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox2.frameTranslation.shape.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox2.frameTranslation.shape.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   input Real bodyBox2.frameTranslation.shape.r[1](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox2.frameTranslation.shape.r[2](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox2.frameTranslation.shape.r[3](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real bodyBox2.frameTranslation.shape.r_shape[1](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.r_shape[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.r_shape[2](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.r_shape[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.r_shape[3](quantity = "Length", unit = "m") = bodyBox2.frameTranslation.r_shape[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.lengthDirection[1](unit = "1") = bodyBox2.frameTranslation.lengthDirection[1] "Vector in length direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.lengthDirection[2](unit = "1") = bodyBox2.frameTranslation.lengthDirection[2] "Vector in length direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.lengthDirection[3](unit = "1") = bodyBox2.frameTranslation.lengthDirection[3] "Vector in length direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.widthDirection[1](unit = "1") = bodyBox2.frameTranslation.widthDirection[1] "Vector in width direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.widthDirection[2](unit = "1") = bodyBox2.frameTranslation.widthDirection[2] "Vector in width direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.widthDirection[3](unit = "1") = bodyBox2.frameTranslation.widthDirection[3] "Vector in width direction, resolved in object frame";
//   input Real bodyBox2.frameTranslation.shape.length(quantity = "Length", unit = "m") = bodyBox2.frameTranslation.length "Length of visual object";
//   input Real bodyBox2.frameTranslation.shape.width(quantity = "Length", unit = "m") = bodyBox2.frameTranslation.width "Width of visual object";
//   input Real bodyBox2.frameTranslation.shape.height(quantity = "Length", unit = "m") = bodyBox2.frameTranslation.height "Height of visual object";
//   input Real bodyBox2.frameTranslation.shape.extra = bodyBox2.frameTranslation.extra "Additional size data for some of the shape types";
//   input Real bodyBox2.frameTranslation.shape.color[1] = Real(bodyBox2.frameTranslation.color[1]) "Color of shape";
//   input Real bodyBox2.frameTranslation.shape.color[2] = Real(bodyBox2.frameTranslation.color[2]) "Color of shape";
//   input Real bodyBox2.frameTranslation.shape.color[3] = Real(bodyBox2.frameTranslation.color[3]) "Color of shape";
//   input Real bodyBox2.frameTranslation.shape.specularCoefficient = bodyBox2.frameTranslation.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real bodyBox2.frameTranslation.shape.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({bodyBox2.frameTranslation.shape.lengthDirection[1],bodyBox2.frameTranslation.shape.lengthDirection[2],bodyBox2.frameTranslation.shape.lengthDirection[3]});
//   protected Real bodyBox2.frameTranslation.shape.e_x[1](unit = "1") = if noEvent(bodyBox2.frameTranslation.shape.abs_n_x < 1e-10) then 1.0 else bodyBox2.frameTranslation.shape.lengthDirection[1] / bodyBox2.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox2.frameTranslation.shape.e_x[2](unit = "1") = if noEvent(bodyBox2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else bodyBox2.frameTranslation.shape.lengthDirection[2] / bodyBox2.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox2.frameTranslation.shape.e_x[3](unit = "1") = if noEvent(bodyBox2.frameTranslation.shape.abs_n_x < 1e-10) then 0.0 else bodyBox2.frameTranslation.shape.lengthDirection[3] / bodyBox2.frameTranslation.shape.abs_n_x;
//   protected Real bodyBox2.frameTranslation.shape.n_z_aux[1](unit = "1") = bodyBox2.frameTranslation.shape.e_x[2] * bodyBox2.frameTranslation.shape.widthDirection[3] - bodyBox2.frameTranslation.shape.e_x[3] * bodyBox2.frameTranslation.shape.widthDirection[2];
//   protected Real bodyBox2.frameTranslation.shape.n_z_aux[2](unit = "1") = bodyBox2.frameTranslation.shape.e_x[3] * bodyBox2.frameTranslation.shape.widthDirection[1] - bodyBox2.frameTranslation.shape.e_x[1] * bodyBox2.frameTranslation.shape.widthDirection[3];
//   protected Real bodyBox2.frameTranslation.shape.n_z_aux[3](unit = "1") = bodyBox2.frameTranslation.shape.e_x[1] * bodyBox2.frameTranslation.shape.widthDirection[2] - bodyBox2.frameTranslation.shape.e_x[2] * bodyBox2.frameTranslation.shape.widthDirection[1];
//   protected Real bodyBox2.frameTranslation.shape.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]},if noEvent(bodyBox2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox2.frameTranslation.shape.widthDirection[1],bodyBox2.frameTranslation.shape.widthDirection[2],bodyBox2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]})[1];
//   protected Real bodyBox2.frameTranslation.shape.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]},if noEvent(bodyBox2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox2.frameTranslation.shape.widthDirection[1],bodyBox2.frameTranslation.shape.widthDirection[2],bodyBox2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]})[2];
//   protected Real bodyBox2.frameTranslation.shape.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]},if noEvent(bodyBox2.frameTranslation.shape.n_z_aux[1] ^ 2.0 + (bodyBox2.frameTranslation.shape.n_z_aux[2] ^ 2.0 + bodyBox2.frameTranslation.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {bodyBox2.frameTranslation.shape.widthDirection[1],bodyBox2.frameTranslation.shape.widthDirection[2],bodyBox2.frameTranslation.shape.widthDirection[3]} else if noEvent(abs(bodyBox2.frameTranslation.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{bodyBox2.frameTranslation.shape.e_x[1],bodyBox2.frameTranslation.shape.e_x[2],bodyBox2.frameTranslation.shape.e_x[3]})[3];
//   protected output Real bodyBox2.frameTranslation.shape.Form;
//   output Real bodyBox2.frameTranslation.shape.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real bodyBox2.frameTranslation.shape.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real bodyBox2.frameTranslation.shape.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox2.frameTranslation.shape.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox2.frameTranslation.shape.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real bodyBox2.frameTranslation.shape.Material;
//   protected output Real bodyBox2.frameTranslation.shape.Extra;
//   Real rod3.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod3.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod3.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod3.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod3.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod3.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod3.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod3.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod3.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod3.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean rod3.animation = false "= true, if animation shall be enabled";
//   parameter Real rod3.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod3.r[2](quantity = "Length", unit = "m", start = 0.0) = -0.9 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod3.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.3 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String rod3.shapeType = "cylinder" " Type of shape";
//   parameter Real rod3.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod3.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod3.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod3.lengthDirection[1](unit = "1") = rod3.r[1] - rod3.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod3.lengthDirection[2](unit = "1") = rod3.r[2] - rod3.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod3.lengthDirection[3](unit = "1") = rod3.r[3] - rod3.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod3.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod3.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod3.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod3.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({rod3.r[1] - rod3.r_shape[1],rod3.r[2] - rod3.r_shape[2],rod3.r[3] - rod3.r_shape[3]}) " Length of shape";
//   parameter Real rod3.width(quantity = "Length", unit = "m", min = 0.0) = 0.01 " Width of shape";
//   parameter Real rod3.height(quantity = "Length", unit = "m", min = 0.0) = rod3.width " Height of shape.";
//   parameter Real rod3.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer rod3.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod3.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod3.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real rod3.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   Real rod4.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod4.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod4.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod4.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real rod4.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real rod4.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real rod4.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real rod4.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod4.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real rod4.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   parameter Boolean rod4.animation = false "= true, if animation shall be enabled";
//   parameter Real rod4.r[1](quantity = "Length", unit = "m", start = 0.0) = 0.0 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod4.r[2](quantity = "Length", unit = "m", start = 0.0) = 0.3 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter Real rod4.r[3](quantity = "Length", unit = "m", start = 0.0) = 0.3 "Vector from frame_a to frame_b resolved in frame_a";
//   parameter String rod4.shapeType = "cylinder" " Type of shape";
//   parameter Real rod4.r_shape[1](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod4.r_shape[2](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod4.r_shape[3](quantity = "Length", unit = "m") = 0.0 " Vector from frame_a to shape origin, resolved in frame_a";
//   parameter Real rod4.lengthDirection[1](unit = "1") = rod4.r[1] - rod4.r_shape[1] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod4.lengthDirection[2](unit = "1") = rod4.r[2] - rod4.r_shape[2] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod4.lengthDirection[3](unit = "1") = rod4.r[3] - rod4.r_shape[3] " Vector in length direction of shape, resolved in frame_a";
//   parameter Real rod4.widthDirection[1](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod4.widthDirection[2](unit = "1") = 1.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod4.widthDirection[3](unit = "1") = 0.0 " Vector in width direction of shape, resolved in frame_a";
//   parameter Real rod4.length(quantity = "Length", unit = "m") = Modelica.Math.Vectors.length({rod4.r[1] - rod4.r_shape[1],rod4.r[2] - rod4.r_shape[2],rod4.r[3] - rod4.r_shape[3]}) " Length of shape";
//   parameter Real rod4.width(quantity = "Length", unit = "m", min = 0.0) = 0.01 " Width of shape";
//   parameter Real rod4.height(quantity = "Length", unit = "m", min = 0.0) = rod4.width " Height of shape.";
//   parameter Real rod4.extra = 0.0 " Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
//   input Integer rod4.color[1](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod4.color[2](min = 0, max = 255) = 155 " Color of shape";
//   input Integer rod4.color[3](min = 0, max = 255) = 155 " Color of shape";
//   input Real rod4.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   parameter enumeration(never, avoid, default, prefer, always) damper2.stateSelect = StateSelect.prefer "Priority to use phi_rel and w_rel as states";
//   parameter Real damper2.s_nominal(quantity = "Length", unit = "m", min = 0.0) = 0.0001 "Nominal value of s_rel (used for scaling)";
//   Real damper2.s_rel(quantity = "Length", unit = "m", min = 0.0, start = 0.0, nominal = damper2.s_nominal, StateSelect = StateSelect.prefer) "Relative distance (= flange_b.s - flange_a.s)";
//   Real damper2.v_rel(quantity = "Velocity", unit = "m/s", start = 0.0, StateSelect = StateSelect.prefer) "Relative velocity (= der(s_rel))";
//   Real damper2.f(quantity = "Force", unit = "N") "Forces between flanges (= flange_b.f)";
//   Real damper2.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real damper2.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real damper2.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real damper2.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Real damper2.d(quantity = "TranslationalDampingConstant", unit = "N.s/m", min = 0.0, start = 0.0) = 3.0 "damping constant";
//   Real lineForceWithTwoMasses.frame_a.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_a.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_a.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_a.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_a.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_a.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_a.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_a.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_a.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.r_0[1](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_b.r_0[2](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_b.r_0[3](quantity = "Length", unit = "m") "Position vector from world frame to the connector frame origin, resolved in world frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[1,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[1,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[1,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[2,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[2,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[2,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[3,1] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[3,2] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.T[3,3] "Transformation matrix from world frame to local frame";
//   Real lineForceWithTwoMasses.frame_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") "Absolute angular velocity of local frame, resolved in local frame";
//   Real lineForceWithTwoMasses.frame_b.f[1](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.f[2](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.f[3](quantity = "Force", unit = "N") "Cut-force resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.t[1](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.t[2](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.frame_b.t[3](quantity = "Torque", unit = "N.m") "Cut-torque resolved in connector frame";
//   Real lineForceWithTwoMasses.flange_b.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real lineForceWithTwoMasses.flange_b.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   Real lineForceWithTwoMasses.flange_a.s(quantity = "Length", unit = "m") "absolute position of flange";
//   Real lineForceWithTwoMasses.flange_a.f(quantity = "Force", unit = "N") "cut force directed into flange";
//   parameter Boolean lineForceWithTwoMasses.animate = true "= true, if animation shall be enabled";
//   parameter Boolean lineForceWithTwoMasses.animateMasses = true "= true, if point masses shall be visualized provided animate=true and m_a, m_b > 0";
//   parameter Real lineForceWithTwoMasses.m_a(quantity = "Mass", unit = "kg", min = 0.0) = m "Mass of point mass a on the connetion line between the origin of frame_a and the origin of frame_b";
//   parameter Real lineForceWithTwoMasses.m_b(quantity = "Mass", unit = "kg", min = 0.0) = m "Mass of point mass b on the connetion line between the origin of frame_a and the origin of frame_b";
//   parameter Real lineForceWithTwoMasses.L_a(quantity = "Length", unit = "m") = 0.2 "Distance between point mass a and frame_a (positive, if in direction of frame_b)";
//   parameter Real lineForceWithTwoMasses.L_b(quantity = "Length", unit = "m") = 0.2 "Distance between point mass b and frame_b (positive, if in direction of frame_a)";
//   input Real lineForceWithTwoMasses.cylinderDiameter_a(quantity = "Length", unit = "m", min = 0.0) = world.defaultForceWidth " Diameter of cylinder at frame_a";
//   parameter Real lineForceWithTwoMasses.cylinderLength_a(quantity = "Length", unit = "m") = 0.2 " Length of cylinder at frame_a";
//   input Integer lineForceWithTwoMasses.color_a[1](min = 0, max = 255) = 155 " Color of cylinder at frame_a";
//   input Integer lineForceWithTwoMasses.color_a[2](min = 0, max = 255) = 155 " Color of cylinder at frame_a";
//   input Integer lineForceWithTwoMasses.color_a[3](min = 0, max = 255) = 155 " Color of cylinder at frame_a";
//   input Real lineForceWithTwoMasses.specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   input Real lineForceWithTwoMasses.diameterFraction = 0.8 " Diameter of cylinder at frame_b with respect to diameter of cylinder at frame_a";
//   parameter Real lineForceWithTwoMasses.cylinderLength_b(quantity = "Length", unit = "m") = 1.2 " Length of cylinder at frame_b";
//   input Integer lineForceWithTwoMasses.color_b[1](min = 0, max = 255) = 100 " Color of cylinder at frame_b";
//   input Integer lineForceWithTwoMasses.color_b[2](min = 0, max = 255) = 100 " Color of cylinder at frame_b";
//   input Integer lineForceWithTwoMasses.color_b[3](min = 0, max = 255) = 100 " Color of cylinder at frame_b";
//   input Real lineForceWithTwoMasses.massDiameterFaction = 2.2 " Diameter of point mass spheres with respect to cylinderDiameter_a";
//   input Integer lineForceWithTwoMasses.massColor[1](min = 0, max = 255) = 0 " Color of point masses";
//   input Integer lineForceWithTwoMasses.massColor[2](min = 0, max = 255) = 128 " Color of point masses";
//   input Integer lineForceWithTwoMasses.massColor[3](min = 0, max = 255) = 255 " Color of point masses";
//   parameter Real lineForceWithTwoMasses.s_small(quantity = "Length", unit = "m") = 1e-10 " Prevent zero-division if distance between frame_a and frame_b is zero";
//   Real lineForceWithTwoMasses.length(quantity = "Length", unit = "m", min = 0.0) "Distance between the origin of frame_a and the origin of frame_b";
//   Real lineForceWithTwoMasses.r_rel_0[1](quantity = "Length", unit = "m") "Position vector from frame_a to frame_b resolved in world frame";
//   Real lineForceWithTwoMasses.r_rel_0[2](quantity = "Length", unit = "m") "Position vector from frame_a to frame_b resolved in world frame";
//   Real lineForceWithTwoMasses.r_rel_0[3](quantity = "Length", unit = "m") "Position vector from frame_a to frame_b resolved in world frame";
//   Real lineForceWithTwoMasses.e_rel_0[1](unit = "1") "Unit vector in direction from frame_a to frame_b, resolved in world frame";
//   Real lineForceWithTwoMasses.e_rel_0[2](unit = "1") "Unit vector in direction from frame_a to frame_b, resolved in world frame";
//   Real lineForceWithTwoMasses.e_rel_0[3](unit = "1") "Unit vector in direction from frame_a to frame_b, resolved in world frame";
//   protected Real lineForceWithTwoMasses.fa(quantity = "Force", unit = "N") "Force from flange_a";
//   protected Real lineForceWithTwoMasses.fb(quantity = "Force", unit = "N") "Force from flange_b";
//   protected Real lineForceWithTwoMasses.r_CM1_0[1](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 1, resolved in world frame";
//   protected Real lineForceWithTwoMasses.r_CM1_0[2](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 1, resolved in world frame";
//   protected Real lineForceWithTwoMasses.r_CM1_0[3](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 1, resolved in world frame";
//   protected Real lineForceWithTwoMasses.r_CM2_0[1](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 2, resolved in world frame";
//   protected Real lineForceWithTwoMasses.r_CM2_0[2](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 2, resolved in world frame";
//   protected Real lineForceWithTwoMasses.r_CM2_0[3](quantity = "Length", unit = "m", StateSelect = StateSelect.avoid) "Position vector from world frame to point mass 2, resolved in world frame";
//   protected Real lineForceWithTwoMasses.v_CM1_0[1](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_1_0) - velocity of point mass 1";
//   protected Real lineForceWithTwoMasses.v_CM1_0[2](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_1_0) - velocity of point mass 1";
//   protected Real lineForceWithTwoMasses.v_CM1_0[3](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_1_0) - velocity of point mass 1";
//   protected Real lineForceWithTwoMasses.v_CM2_0[1](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_2_0) - velocity of point mass 2";
//   protected Real lineForceWithTwoMasses.v_CM2_0[2](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_2_0) - velocity of point mass 2";
//   protected Real lineForceWithTwoMasses.v_CM2_0[3](quantity = "Velocity", unit = "m/s", StateSelect = StateSelect.avoid) "der(r_CM_2_0) - velocity of point mass 2";
//   protected Real lineForceWithTwoMasses.ag_CM1_0[1](quantity = "Acceleration", unit = "m/s2") "der(v_CM1_0) - gravityAcceleration(r_CM1_0)";
//   protected Real lineForceWithTwoMasses.ag_CM1_0[2](quantity = "Acceleration", unit = "m/s2") "der(v_CM1_0) - gravityAcceleration(r_CM1_0)";
//   protected Real lineForceWithTwoMasses.ag_CM1_0[3](quantity = "Acceleration", unit = "m/s2") "der(v_CM1_0) - gravityAcceleration(r_CM1_0)";
//   protected Real lineForceWithTwoMasses.ag_CM2_0[1](quantity = "Acceleration", unit = "m/s2") "der(v_CM2_0) - gravityAcceleration(r_CM2_0)";
//   protected Real lineForceWithTwoMasses.ag_CM2_0[2](quantity = "Acceleration", unit = "m/s2") "der(v_CM2_0) - gravityAcceleration(r_CM2_0)";
//   protected Real lineForceWithTwoMasses.ag_CM2_0[3](quantity = "Acceleration", unit = "m/s2") "der(v_CM2_0) - gravityAcceleration(r_CM2_0)";
//   protected Real lineForceWithTwoMasses.aux1_0[1](quantity = "Force", unit = "N") "Auxiliary force 1";
//   protected Real lineForceWithTwoMasses.aux1_0[2](quantity = "Force", unit = "N") "Auxiliary force 1";
//   protected Real lineForceWithTwoMasses.aux1_0[3](quantity = "Force", unit = "N") "Auxiliary force 1";
//   protected Real lineForceWithTwoMasses.aux2_0[1](quantity = "Force", unit = "N") "Auxiliary force 2";
//   protected Real lineForceWithTwoMasses.aux2_0[2](quantity = "Force", unit = "N") "Auxiliary force 2";
//   protected Real lineForceWithTwoMasses.aux2_0[3](quantity = "Force", unit = "N") "Auxiliary force 2";
//   protected input Real lineForceWithTwoMasses.cylinderDiameter_b(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_a * lineForceWithTwoMasses.diameterFraction;
//   protected input Real lineForceWithTwoMasses.massDiameter(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_a * lineForceWithTwoMasses.massDiameterFaction;
//   protected parameter Boolean lineForceWithTwoMasses.animateMasses2 = world.enableAnimation AND lineForceWithTwoMasses.animate AND lineForceWithTwoMasses.animateMasses AND lineForceWithTwoMasses.m_a > 0.0 AND lineForceWithTwoMasses.m_b > 0.0;
//   parameter String lineForceWithTwoMasses.cylinder_a.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r[1](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r[2](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r[3](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.lengthDirection[1](unit = "1") = lineForceWithTwoMasses.e_rel_0[1] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.lengthDirection[2](unit = "1") = lineForceWithTwoMasses.e_rel_0[2] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.lengthDirection[3](unit = "1") = lineForceWithTwoMasses.e_rel_0[3] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_a.length(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderLength_a "Length of visual object";
//   input Real lineForceWithTwoMasses.cylinder_a.width(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_a "Width of visual object";
//   input Real lineForceWithTwoMasses.cylinder_a.height(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_a "Height of visual object";
//   input Real lineForceWithTwoMasses.cylinder_a.extra = 0.0 "Additional size data for some of the shape types";
//   input Real lineForceWithTwoMasses.cylinder_a.color[1] = Real(lineForceWithTwoMasses.color_a[1]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_a.color[2] = Real(lineForceWithTwoMasses.color_a[2]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_a.color[3] = Real(lineForceWithTwoMasses.color_a[3]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_a.specularCoefficient = lineForceWithTwoMasses.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real lineForceWithTwoMasses.cylinder_a.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({lineForceWithTwoMasses.cylinder_a.lengthDirection[1],lineForceWithTwoMasses.cylinder_a.lengthDirection[2],lineForceWithTwoMasses.cylinder_a.lengthDirection[3]});
//   protected Real lineForceWithTwoMasses.cylinder_a.e_x[1](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_a.abs_n_x < 1e-10) then 1.0 else lineForceWithTwoMasses.cylinder_a.lengthDirection[1] / lineForceWithTwoMasses.cylinder_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_a.e_x[2](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_a.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.cylinder_a.lengthDirection[2] / lineForceWithTwoMasses.cylinder_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_a.e_x[3](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_a.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.cylinder_a.lengthDirection[3] / lineForceWithTwoMasses.cylinder_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_a.n_z_aux[1](unit = "1") = lineForceWithTwoMasses.cylinder_a.e_x[2] * lineForceWithTwoMasses.cylinder_a.widthDirection[3] - lineForceWithTwoMasses.cylinder_a.e_x[3] * lineForceWithTwoMasses.cylinder_a.widthDirection[2];
//   protected Real lineForceWithTwoMasses.cylinder_a.n_z_aux[2](unit = "1") = lineForceWithTwoMasses.cylinder_a.e_x[3] * lineForceWithTwoMasses.cylinder_a.widthDirection[1] - lineForceWithTwoMasses.cylinder_a.e_x[1] * lineForceWithTwoMasses.cylinder_a.widthDirection[3];
//   protected Real lineForceWithTwoMasses.cylinder_a.n_z_aux[3](unit = "1") = lineForceWithTwoMasses.cylinder_a.e_x[1] * lineForceWithTwoMasses.cylinder_a.widthDirection[2] - lineForceWithTwoMasses.cylinder_a.e_x[2] * lineForceWithTwoMasses.cylinder_a.widthDirection[1];
//   protected Real lineForceWithTwoMasses.cylinder_a.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_a.widthDirection[1],lineForceWithTwoMasses.cylinder_a.widthDirection[2],lineForceWithTwoMasses.cylinder_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]})[1];
//   protected Real lineForceWithTwoMasses.cylinder_a.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_a.widthDirection[1],lineForceWithTwoMasses.cylinder_a.widthDirection[2],lineForceWithTwoMasses.cylinder_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]})[2];
//   protected Real lineForceWithTwoMasses.cylinder_a.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_a.widthDirection[1],lineForceWithTwoMasses.cylinder_a.widthDirection[2],lineForceWithTwoMasses.cylinder_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_a.e_x[1],lineForceWithTwoMasses.cylinder_a.e_x[2],lineForceWithTwoMasses.cylinder_a.e_x[3]})[3];
//   protected output Real lineForceWithTwoMasses.cylinder_a.Form;
//   output Real lineForceWithTwoMasses.cylinder_a.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_a.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real lineForceWithTwoMasses.cylinder_a.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_a.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_a.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_a.Material;
//   protected output Real lineForceWithTwoMasses.cylinder_a.Extra;
//   parameter String lineForceWithTwoMasses.cylinder_b.shapeType = "cylinder" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r[1](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r[2](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r[3](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.lengthDirection[1](unit = "1") = -lineForceWithTwoMasses.e_rel_0[1] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.lengthDirection[2](unit = "1") = -lineForceWithTwoMasses.e_rel_0[2] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.lengthDirection[3](unit = "1") = -lineForceWithTwoMasses.e_rel_0[3] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.cylinder_b.length(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderLength_b "Length of visual object";
//   input Real lineForceWithTwoMasses.cylinder_b.width(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_b "Width of visual object";
//   input Real lineForceWithTwoMasses.cylinder_b.height(quantity = "Length", unit = "m") = lineForceWithTwoMasses.cylinderDiameter_b "Height of visual object";
//   input Real lineForceWithTwoMasses.cylinder_b.extra = 0.0 "Additional size data for some of the shape types";
//   input Real lineForceWithTwoMasses.cylinder_b.color[1] = Real(lineForceWithTwoMasses.color_b[1]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_b.color[2] = Real(lineForceWithTwoMasses.color_b[2]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_b.color[3] = Real(lineForceWithTwoMasses.color_b[3]) "Color of shape";
//   input Real lineForceWithTwoMasses.cylinder_b.specularCoefficient = lineForceWithTwoMasses.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real lineForceWithTwoMasses.cylinder_b.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({lineForceWithTwoMasses.cylinder_b.lengthDirection[1],lineForceWithTwoMasses.cylinder_b.lengthDirection[2],lineForceWithTwoMasses.cylinder_b.lengthDirection[3]});
//   protected Real lineForceWithTwoMasses.cylinder_b.e_x[1](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_b.abs_n_x < 1e-10) then 1.0 else lineForceWithTwoMasses.cylinder_b.lengthDirection[1] / lineForceWithTwoMasses.cylinder_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_b.e_x[2](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_b.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.cylinder_b.lengthDirection[2] / lineForceWithTwoMasses.cylinder_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_b.e_x[3](unit = "1") = if noEvent(lineForceWithTwoMasses.cylinder_b.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.cylinder_b.lengthDirection[3] / lineForceWithTwoMasses.cylinder_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.cylinder_b.n_z_aux[1](unit = "1") = lineForceWithTwoMasses.cylinder_b.e_x[2] * lineForceWithTwoMasses.cylinder_b.widthDirection[3] - lineForceWithTwoMasses.cylinder_b.e_x[3] * lineForceWithTwoMasses.cylinder_b.widthDirection[2];
//   protected Real lineForceWithTwoMasses.cylinder_b.n_z_aux[2](unit = "1") = lineForceWithTwoMasses.cylinder_b.e_x[3] * lineForceWithTwoMasses.cylinder_b.widthDirection[1] - lineForceWithTwoMasses.cylinder_b.e_x[1] * lineForceWithTwoMasses.cylinder_b.widthDirection[3];
//   protected Real lineForceWithTwoMasses.cylinder_b.n_z_aux[3](unit = "1") = lineForceWithTwoMasses.cylinder_b.e_x[1] * lineForceWithTwoMasses.cylinder_b.widthDirection[2] - lineForceWithTwoMasses.cylinder_b.e_x[2] * lineForceWithTwoMasses.cylinder_b.widthDirection[1];
//   protected Real lineForceWithTwoMasses.cylinder_b.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_b.widthDirection[1],lineForceWithTwoMasses.cylinder_b.widthDirection[2],lineForceWithTwoMasses.cylinder_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]})[1];
//   protected Real lineForceWithTwoMasses.cylinder_b.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_b.widthDirection[1],lineForceWithTwoMasses.cylinder_b.widthDirection[2],lineForceWithTwoMasses.cylinder_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]})[2];
//   protected Real lineForceWithTwoMasses.cylinder_b.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]},if noEvent(lineForceWithTwoMasses.cylinder_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.cylinder_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.cylinder_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.cylinder_b.widthDirection[1],lineForceWithTwoMasses.cylinder_b.widthDirection[2],lineForceWithTwoMasses.cylinder_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.cylinder_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.cylinder_b.e_x[1],lineForceWithTwoMasses.cylinder_b.e_x[2],lineForceWithTwoMasses.cylinder_b.e_x[3]})[3];
//   protected output Real lineForceWithTwoMasses.cylinder_b.Form;
//   output Real lineForceWithTwoMasses.cylinder_b.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.cylinder_b.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real lineForceWithTwoMasses.cylinder_b.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_b.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_b.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.cylinder_b.Material;
//   protected output Real lineForceWithTwoMasses.cylinder_b.Extra;
//   parameter String lineForceWithTwoMasses.sphere_a.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_a.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_a.r[1](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_a.r[2](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_a.r[3](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_a.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_a.r_shape[1](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.L_a - lineForceWithTwoMasses.massDiameter / 2.0) * lineForceWithTwoMasses.e_rel_0[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.r_shape[2](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.L_a - lineForceWithTwoMasses.massDiameter / 2.0) * lineForceWithTwoMasses.e_rel_0[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.r_shape[3](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.L_a - lineForceWithTwoMasses.massDiameter / 2.0) * lineForceWithTwoMasses.e_rel_0[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.lengthDirection[1](unit = "1") = lineForceWithTwoMasses.e_rel_0[1] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.lengthDirection[2](unit = "1") = lineForceWithTwoMasses.e_rel_0[2] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.lengthDirection[3](unit = "1") = lineForceWithTwoMasses.e_rel_0[3] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_a.length(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Length of visual object";
//   input Real lineForceWithTwoMasses.sphere_a.width(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Width of visual object";
//   input Real lineForceWithTwoMasses.sphere_a.height(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Height of visual object";
//   input Real lineForceWithTwoMasses.sphere_a.extra = 0.0 "Additional size data for some of the shape types";
//   input Real lineForceWithTwoMasses.sphere_a.color[1] = Real(lineForceWithTwoMasses.massColor[1]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_a.color[2] = Real(lineForceWithTwoMasses.massColor[2]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_a.color[3] = Real(lineForceWithTwoMasses.massColor[3]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_a.specularCoefficient = lineForceWithTwoMasses.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real lineForceWithTwoMasses.sphere_a.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({lineForceWithTwoMasses.sphere_a.lengthDirection[1],lineForceWithTwoMasses.sphere_a.lengthDirection[2],lineForceWithTwoMasses.sphere_a.lengthDirection[3]});
//   protected Real lineForceWithTwoMasses.sphere_a.e_x[1](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_a.abs_n_x < 1e-10) then 1.0 else lineForceWithTwoMasses.sphere_a.lengthDirection[1] / lineForceWithTwoMasses.sphere_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_a.e_x[2](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_a.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.sphere_a.lengthDirection[2] / lineForceWithTwoMasses.sphere_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_a.e_x[3](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_a.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.sphere_a.lengthDirection[3] / lineForceWithTwoMasses.sphere_a.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_a.n_z_aux[1](unit = "1") = lineForceWithTwoMasses.sphere_a.e_x[2] * lineForceWithTwoMasses.sphere_a.widthDirection[3] - lineForceWithTwoMasses.sphere_a.e_x[3] * lineForceWithTwoMasses.sphere_a.widthDirection[2];
//   protected Real lineForceWithTwoMasses.sphere_a.n_z_aux[2](unit = "1") = lineForceWithTwoMasses.sphere_a.e_x[3] * lineForceWithTwoMasses.sphere_a.widthDirection[1] - lineForceWithTwoMasses.sphere_a.e_x[1] * lineForceWithTwoMasses.sphere_a.widthDirection[3];
//   protected Real lineForceWithTwoMasses.sphere_a.n_z_aux[3](unit = "1") = lineForceWithTwoMasses.sphere_a.e_x[1] * lineForceWithTwoMasses.sphere_a.widthDirection[2] - lineForceWithTwoMasses.sphere_a.e_x[2] * lineForceWithTwoMasses.sphere_a.widthDirection[1];
//   protected Real lineForceWithTwoMasses.sphere_a.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_a.widthDirection[1],lineForceWithTwoMasses.sphere_a.widthDirection[2],lineForceWithTwoMasses.sphere_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]})[1];
//   protected Real lineForceWithTwoMasses.sphere_a.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_a.widthDirection[1],lineForceWithTwoMasses.sphere_a.widthDirection[2],lineForceWithTwoMasses.sphere_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]})[2];
//   protected Real lineForceWithTwoMasses.sphere_a.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_a.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_a.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_a.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_a.widthDirection[1],lineForceWithTwoMasses.sphere_a.widthDirection[2],lineForceWithTwoMasses.sphere_a.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_a.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_a.e_x[1],lineForceWithTwoMasses.sphere_a.e_x[2],lineForceWithTwoMasses.sphere_a.e_x[3]})[3];
//   protected output Real lineForceWithTwoMasses.sphere_a.Form;
//   output Real lineForceWithTwoMasses.sphere_a.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_a.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real lineForceWithTwoMasses.sphere_a.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_a.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_a.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_a.Material;
//   protected output Real lineForceWithTwoMasses.sphere_a.Extra;
//   parameter String lineForceWithTwoMasses.sphere_b.shapeType = "sphere" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_b.R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real lineForceWithTwoMasses.sphere_b.r[1](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[1] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_b.r[2](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[2] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_b.r[3](quantity = "Length", unit = "m") = lineForceWithTwoMasses.frame_b.r_0[3] "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real lineForceWithTwoMasses.sphere_b.r_shape[1](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.massDiameter / 2.0 - lineForceWithTwoMasses.L_b) * lineForceWithTwoMasses.e_rel_0[1] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.r_shape[2](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.massDiameter / 2.0 - lineForceWithTwoMasses.L_b) * lineForceWithTwoMasses.e_rel_0[2] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.r_shape[3](quantity = "Length", unit = "m") = (lineForceWithTwoMasses.massDiameter / 2.0 - lineForceWithTwoMasses.L_b) * lineForceWithTwoMasses.e_rel_0[3] "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.lengthDirection[1](unit = "1") = -lineForceWithTwoMasses.e_rel_0[1] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.lengthDirection[2](unit = "1") = -lineForceWithTwoMasses.e_rel_0[2] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.lengthDirection[3](unit = "1") = -lineForceWithTwoMasses.e_rel_0[3] "Vector in length direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real lineForceWithTwoMasses.sphere_b.length(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Length of visual object";
//   input Real lineForceWithTwoMasses.sphere_b.width(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Width of visual object";
//   input Real lineForceWithTwoMasses.sphere_b.height(quantity = "Length", unit = "m") = lineForceWithTwoMasses.massDiameter "Height of visual object";
//   input Real lineForceWithTwoMasses.sphere_b.extra = 0.0 "Additional size data for some of the shape types";
//   input Real lineForceWithTwoMasses.sphere_b.color[1] = Real(lineForceWithTwoMasses.massColor[1]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_b.color[2] = Real(lineForceWithTwoMasses.massColor[2]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_b.color[3] = Real(lineForceWithTwoMasses.massColor[3]) "Color of shape";
//   input Real lineForceWithTwoMasses.sphere_b.specularCoefficient = lineForceWithTwoMasses.specularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real lineForceWithTwoMasses.sphere_b.abs_n_x(unit = "1") = Modelica.Math.Vectors.length({lineForceWithTwoMasses.sphere_b.lengthDirection[1],lineForceWithTwoMasses.sphere_b.lengthDirection[2],lineForceWithTwoMasses.sphere_b.lengthDirection[3]});
//   protected Real lineForceWithTwoMasses.sphere_b.e_x[1](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_b.abs_n_x < 1e-10) then 1.0 else lineForceWithTwoMasses.sphere_b.lengthDirection[1] / lineForceWithTwoMasses.sphere_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_b.e_x[2](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_b.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.sphere_b.lengthDirection[2] / lineForceWithTwoMasses.sphere_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_b.e_x[3](unit = "1") = if noEvent(lineForceWithTwoMasses.sphere_b.abs_n_x < 1e-10) then 0.0 else lineForceWithTwoMasses.sphere_b.lengthDirection[3] / lineForceWithTwoMasses.sphere_b.abs_n_x;
//   protected Real lineForceWithTwoMasses.sphere_b.n_z_aux[1](unit = "1") = lineForceWithTwoMasses.sphere_b.e_x[2] * lineForceWithTwoMasses.sphere_b.widthDirection[3] - lineForceWithTwoMasses.sphere_b.e_x[3] * lineForceWithTwoMasses.sphere_b.widthDirection[2];
//   protected Real lineForceWithTwoMasses.sphere_b.n_z_aux[2](unit = "1") = lineForceWithTwoMasses.sphere_b.e_x[3] * lineForceWithTwoMasses.sphere_b.widthDirection[1] - lineForceWithTwoMasses.sphere_b.e_x[1] * lineForceWithTwoMasses.sphere_b.widthDirection[3];
//   protected Real lineForceWithTwoMasses.sphere_b.n_z_aux[3](unit = "1") = lineForceWithTwoMasses.sphere_b.e_x[1] * lineForceWithTwoMasses.sphere_b.widthDirection[2] - lineForceWithTwoMasses.sphere_b.e_x[2] * lineForceWithTwoMasses.sphere_b.widthDirection[1];
//   protected Real lineForceWithTwoMasses.sphere_b.e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_b.widthDirection[1],lineForceWithTwoMasses.sphere_b.widthDirection[2],lineForceWithTwoMasses.sphere_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]})[1];
//   protected Real lineForceWithTwoMasses.sphere_b.e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_b.widthDirection[1],lineForceWithTwoMasses.sphere_b.widthDirection[2],lineForceWithTwoMasses.sphere_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]})[2];
//   protected Real lineForceWithTwoMasses.sphere_b.e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]},if noEvent(lineForceWithTwoMasses.sphere_b.n_z_aux[1] ^ 2.0 + (lineForceWithTwoMasses.sphere_b.n_z_aux[2] ^ 2.0 + lineForceWithTwoMasses.sphere_b.n_z_aux[3] ^ 2.0) > 1e-06) then {lineForceWithTwoMasses.sphere_b.widthDirection[1],lineForceWithTwoMasses.sphere_b.widthDirection[2],lineForceWithTwoMasses.sphere_b.widthDirection[3]} else if noEvent(abs(lineForceWithTwoMasses.sphere_b.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{lineForceWithTwoMasses.sphere_b.e_x[1],lineForceWithTwoMasses.sphere_b.e_x[2],lineForceWithTwoMasses.sphere_b.e_x[3]})[3];
//   protected output Real lineForceWithTwoMasses.sphere_b.Form;
//   output Real lineForceWithTwoMasses.sphere_b.rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real lineForceWithTwoMasses.sphere_b.rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real lineForceWithTwoMasses.sphere_b.size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_b.size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_b.size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real lineForceWithTwoMasses.sphere_b.Material;
//   protected output Real lineForceWithTwoMasses.sphere_b.Extra;
// equation
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[1].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[1].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[1].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[2].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[2].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[2].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[1].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[1].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[1].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[2].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[2].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[2].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[1].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[1].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[1].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[2].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[2].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[2].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[3].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[3].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[3].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   world.gravityArrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowLine.shapeType);
//   world.gravityArrowLine.rxvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.ryvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.rvisobj = world.gravityArrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowLine.R.T[1,1],world.gravityArrowLine.R.T[1,2],world.gravityArrowLine.R.T[1,3]},{world.gravityArrowLine.R.T[2,1],world.gravityArrowLine.R.T[2,2],world.gravityArrowLine.R.T[2,3]},{world.gravityArrowLine.R.T[3,1],world.gravityArrowLine.R.T[3,2],world.gravityArrowLine.R.T[3,3]}},{world.gravityArrowLine.r_shape[1],world.gravityArrowLine.r_shape[2],world.gravityArrowLine.r_shape[3]});
//   world.gravityArrowLine.size[1] = world.gravityArrowLine.length;
//   world.gravityArrowLine.size[2] = world.gravityArrowLine.width;
//   world.gravityArrowLine.size[3] = world.gravityArrowLine.height;
//   world.gravityArrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowLine.color[1] / 255.0,world.gravityArrowLine.color[2] / 255.0,world.gravityArrowLine.color[3] / 255.0,world.gravityArrowLine.specularCoefficient);
//   world.gravityArrowLine.Extra = world.gravityArrowLine.extra;
//   world.gravityArrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowHead.shapeType);
//   world.gravityArrowHead.rxvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.ryvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.rvisobj = world.gravityArrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowHead.R.T[1,1],world.gravityArrowHead.R.T[1,2],world.gravityArrowHead.R.T[1,3]},{world.gravityArrowHead.R.T[2,1],world.gravityArrowHead.R.T[2,2],world.gravityArrowHead.R.T[2,3]},{world.gravityArrowHead.R.T[3,1],world.gravityArrowHead.R.T[3,2],world.gravityArrowHead.R.T[3,3]}},{world.gravityArrowHead.r_shape[1],world.gravityArrowHead.r_shape[2],world.gravityArrowHead.r_shape[3]});
//   world.gravityArrowHead.size[1] = world.gravityArrowHead.length;
//   world.gravityArrowHead.size[2] = world.gravityArrowHead.width;
//   world.gravityArrowHead.size[3] = world.gravityArrowHead.height;
//   world.gravityArrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowHead.color[1] / 255.0,world.gravityArrowHead.color[2] / 255.0,world.gravityArrowHead.color[3] / 255.0,world.gravityArrowHead.specularCoefficient);
//   world.gravityArrowHead.Extra = world.gravityArrowHead.extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,"Parameter n of World object is wrong (lenght(n) > 0 required)");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   revolute1.cylinder.R.T[1,1] = revolute1.frame_a.R.T[1,1];
//   revolute1.cylinder.R.T[1,2] = revolute1.frame_a.R.T[1,2];
//   revolute1.cylinder.R.T[1,3] = revolute1.frame_a.R.T[1,3];
//   revolute1.cylinder.R.T[2,1] = revolute1.frame_a.R.T[2,1];
//   revolute1.cylinder.R.T[2,2] = revolute1.frame_a.R.T[2,2];
//   revolute1.cylinder.R.T[2,3] = revolute1.frame_a.R.T[2,3];
//   revolute1.cylinder.R.T[3,1] = revolute1.frame_a.R.T[3,1];
//   revolute1.cylinder.R.T[3,2] = revolute1.frame_a.R.T[3,2];
//   revolute1.cylinder.R.T[3,3] = revolute1.frame_a.R.T[3,3];
//   revolute1.cylinder.R.w[1] = revolute1.frame_a.R.w[1];
//   revolute1.cylinder.R.w[2] = revolute1.frame_a.R.w[2];
//   revolute1.cylinder.R.w[3] = revolute1.frame_a.R.w[3];
//   revolute1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute1.cylinder.shapeType);
//   revolute1.cylinder.rxvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_x[1] + (revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_x[3]);
//   revolute1.cylinder.rxvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_x[1] + (revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_x[3]);
//   revolute1.cylinder.rxvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_x[1] + (revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_x[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_x[3]);
//   revolute1.cylinder.ryvisobj[1] = revolute1.cylinder.R.T[1,1] * revolute1.cylinder.e_y[1] + (revolute1.cylinder.R.T[2,1] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,1] * revolute1.cylinder.e_y[3]);
//   revolute1.cylinder.ryvisobj[2] = revolute1.cylinder.R.T[1,2] * revolute1.cylinder.e_y[1] + (revolute1.cylinder.R.T[2,2] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,2] * revolute1.cylinder.e_y[3]);
//   revolute1.cylinder.ryvisobj[3] = revolute1.cylinder.R.T[1,3] * revolute1.cylinder.e_y[1] + (revolute1.cylinder.R.T[2,3] * revolute1.cylinder.e_y[2] + revolute1.cylinder.R.T[3,3] * revolute1.cylinder.e_y[3]);
//   revolute1.cylinder.rvisobj = revolute1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute1.cylinder.R.T[1,1],revolute1.cylinder.R.T[1,2],revolute1.cylinder.R.T[1,3]},{revolute1.cylinder.R.T[2,1],revolute1.cylinder.R.T[2,2],revolute1.cylinder.R.T[2,3]},{revolute1.cylinder.R.T[3,1],revolute1.cylinder.R.T[3,2],revolute1.cylinder.R.T[3,3]}},{revolute1.cylinder.r_shape[1],revolute1.cylinder.r_shape[2],revolute1.cylinder.r_shape[3]});
//   revolute1.cylinder.size[1] = revolute1.cylinder.length;
//   revolute1.cylinder.size[2] = revolute1.cylinder.width;
//   revolute1.cylinder.size[3] = revolute1.cylinder.height;
//   revolute1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute1.cylinder.color[1] / 255.0,revolute1.cylinder.color[2] / 255.0,revolute1.cylinder.color[3] / 255.0,revolute1.cylinder.specularCoefficient);
//   revolute1.cylinder.Extra = revolute1.cylinder.extra;
//   revolute1.fixed.flange.phi = revolute1.fixed.phi0;
//   revolute1.internalAxis.flange.tau = revolute1.internalAxis.tau;
//   revolute1.internalAxis.flange.phi = revolute1.internalAxis.phi;
//   revolute1.constantTorque.tau = -revolute1.constantTorque.flange.tau;
//   revolute1.constantTorque.tau = revolute1.constantTorque.tau_constant;
//   revolute1.constantTorque.phi = revolute1.constantTorque.flange.phi - revolute1.constantTorque.phi_support;
//   revolute1.constantTorque.phi_support = 0.0;
//   assert(true,"Connector frame_a of revolute joint is not connected");
//   assert(true,"Connector frame_b of revolute joint is not connected");
//   revolute1.angle = revolute1.phi;
//   revolute1.w = der(revolute1.phi);
//   revolute1.a = der(revolute1.w);
//   revolute1.frame_b.r_0[1] = revolute1.frame_a.r_0[1];
//   revolute1.frame_b.r_0[2] = revolute1.frame_a.r_0[2];
//   revolute1.frame_b.r_0[3] = revolute1.frame_a.r_0[3];
//   revolute1.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({revolute1.e[1],revolute1.e[2],revolute1.e[3]},revolute1.phi,revolute1.w);
//   revolute1.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute1.frame_a.R,revolute1.R_rel);
//   revolute1.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel,{revolute1.frame_b.f[1],revolute1.frame_b.f[2],revolute1.frame_b.f[3]});
//   revolute1.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute1.R_rel,{revolute1.frame_b.t[1],revolute1.frame_b.t[2],revolute1.frame_b.t[3]});
//   revolute1.tau = (-revolute1.frame_b.t[1]) * revolute1.e[1] + ((-revolute1.frame_b.t[2]) * revolute1.e[2] + (-revolute1.frame_b.t[3]) * revolute1.e[3]);
//   revolute1.phi = revolute1.internalAxis.phi;
//   revolute1.constantTorque.flange.tau + revolute1.internalAxis.flange.tau = 0.0;
//   revolute1.constantTorque.flange.phi = revolute1.internalAxis.flange.phi;
//   revolute1.fixed.flange.tau = 0.0;
//   bodyBox1.body.r_0[1] = bodyBox1.body.frame_a.r_0[1];
//   bodyBox1.body.r_0[2] = bodyBox1.body.frame_a.r_0[2];
//   bodyBox1.body.r_0[3] = bodyBox1.body.frame_a.r_0[3];
//   if true then
//   bodyBox1.body.Q[1] = 0.0;
//   bodyBox1.body.Q[2] = 0.0;
//   bodyBox1.body.Q[3] = 0.0;
//   bodyBox1.body.Q[4] = 1.0;
//   bodyBox1.body.phi[1] = 0.0;
//   bodyBox1.body.phi[2] = 0.0;
//   bodyBox1.body.phi[3] = 0.0;
//   bodyBox1.body.phi_d[1] = 0.0;
//   bodyBox1.body.phi_d[2] = 0.0;
//   bodyBox1.body.phi_d[3] = 0.0;
//   bodyBox1.body.phi_dd[1] = 0.0;
//   bodyBox1.body.phi_dd[2] = 0.0;
//   bodyBox1.body.phi_dd[3] = 0.0;
//   elseif bodyBox1.body.useQuaternions then
//   bodyBox1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({bodyBox1.body.Q[1],bodyBox1.body.Q[2],bodyBox1.body.Q[3],bodyBox1.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({bodyBox1.body.Q[1],bodyBox1.body.Q[2],bodyBox1.body.Q[3],bodyBox1.body.Q[4]},{der(bodyBox1.body.Q[1]),der(bodyBox1.body.Q[2]),der(bodyBox1.body.Q[3]),der(bodyBox1.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({bodyBox1.body.Q[1],bodyBox1.body.Q[2],bodyBox1.body.Q[3],bodyBox1.body.Q[4]});
//   bodyBox1.body.phi[1] = 0.0;
//   bodyBox1.body.phi[2] = 0.0;
//   bodyBox1.body.phi[3] = 0.0;
//   bodyBox1.body.phi_d[1] = 0.0;
//   bodyBox1.body.phi_d[2] = 0.0;
//   bodyBox1.body.phi_d[3] = 0.0;
//   bodyBox1.body.phi_dd[1] = 0.0;
//   bodyBox1.body.phi_dd[2] = 0.0;
//   bodyBox1.body.phi_dd[3] = 0.0;
//   else
//   bodyBox1.body.phi_d[1] = der(bodyBox1.body.phi[1]);
//   bodyBox1.body.phi_d[2] = der(bodyBox1.body.phi[2]);
//   bodyBox1.body.phi_d[3] = der(bodyBox1.body.phi[3]);
//   bodyBox1.body.phi_dd[1] = der(bodyBox1.body.phi_d[1]);
//   bodyBox1.body.phi_dd[2] = der(bodyBox1.body.phi_d[2]);
//   bodyBox1.body.phi_dd[3] = der(bodyBox1.body.phi_d[3]);
//   bodyBox1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({bodyBox1.body.sequence_angleStates[1],bodyBox1.body.sequence_angleStates[2],bodyBox1.body.sequence_angleStates[3]},{bodyBox1.body.phi[1],bodyBox1.body.phi[2],bodyBox1.body.phi[3]},{bodyBox1.body.phi_d[1],bodyBox1.body.phi_d[2],bodyBox1.body.phi_d[3]});
//   bodyBox1.body.Q[1] = 0.0;
//   bodyBox1.body.Q[2] = 0.0;
//   bodyBox1.body.Q[3] = 0.0;
//   bodyBox1.body.Q[4] = 1.0;
//   end if;
//   bodyBox1.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({bodyBox1.body.frame_a.r_0[1],bodyBox1.body.frame_a.r_0[2],bodyBox1.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(bodyBox1.body.frame_a.R,{bodyBox1.body.r_CM[1],bodyBox1.body.r_CM[2],bodyBox1.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   bodyBox1.body.v_0[1] = der(bodyBox1.body.frame_a.r_0[1]);
//   bodyBox1.body.v_0[2] = der(bodyBox1.body.frame_a.r_0[2]);
//   bodyBox1.body.v_0[3] = der(bodyBox1.body.frame_a.r_0[3]);
//   bodyBox1.body.a_0[1] = der(bodyBox1.body.v_0[1]);
//   bodyBox1.body.a_0[2] = der(bodyBox1.body.v_0[2]);
//   bodyBox1.body.a_0[3] = der(bodyBox1.body.v_0[3]);
//   bodyBox1.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(bodyBox1.body.frame_a.R);
//   bodyBox1.body.z_a[1] = der(bodyBox1.body.w_a[1]);
//   bodyBox1.body.z_a[2] = der(bodyBox1.body.w_a[2]);
//   bodyBox1.body.z_a[3] = der(bodyBox1.body.w_a[3]);
//   bodyBox1.body.frame_a.f = bodyBox1.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox1.body.frame_a.R,{bodyBox1.body.a_0[1] - bodyBox1.body.g_0[1],bodyBox1.body.a_0[2] - bodyBox1.body.g_0[2],bodyBox1.body.a_0[3] - bodyBox1.body.g_0[3]}) + {bodyBox1.body.z_a[2] * bodyBox1.body.r_CM[3] - bodyBox1.body.z_a[3] * bodyBox1.body.r_CM[2],bodyBox1.body.z_a[3] * bodyBox1.body.r_CM[1] - bodyBox1.body.z_a[1] * bodyBox1.body.r_CM[3],bodyBox1.body.z_a[1] * bodyBox1.body.r_CM[2] - bodyBox1.body.z_a[2] * bodyBox1.body.r_CM[1]} + {bodyBox1.body.w_a[2] * (bodyBox1.body.w_a[1] * bodyBox1.body.r_CM[2] - bodyBox1.body.w_a[2] * bodyBox1.body.r_CM[1]) - bodyBox1.body.w_a[3] * (bodyBox1.body.w_a[3] * bodyBox1.body.r_CM[1] - bodyBox1.body.w_a[1] * bodyBox1.body.r_CM[3]),bodyBox1.body.w_a[3] * (bodyBox1.body.w_a[2] * bodyBox1.body.r_CM[3] - bodyBox1.body.w_a[3] * bodyBox1.body.r_CM[2]) - bodyBox1.body.w_a[1] * (bodyBox1.body.w_a[1] * bodyBox1.body.r_CM[2] - bodyBox1.body.w_a[2] * bodyBox1.body.r_CM[1]),bodyBox1.body.w_a[1] * (bodyBox1.body.w_a[3] * bodyBox1.body.r_CM[1] - bodyBox1.body.w_a[1] * bodyBox1.body.r_CM[3]) - bodyBox1.body.w_a[2] * (bodyBox1.body.w_a[2] * bodyBox1.body.r_CM[3] - bodyBox1.body.w_a[3] * bodyBox1.body.r_CM[2])});
//   bodyBox1.body.frame_a.t[1] = bodyBox1.body.I[1,1] * bodyBox1.body.z_a[1] + (bodyBox1.body.I[1,2] * bodyBox1.body.z_a[2] + (bodyBox1.body.I[1,3] * bodyBox1.body.z_a[3] + (bodyBox1.body.w_a[2] * (bodyBox1.body.I[3,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[3,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[3,3] * bodyBox1.body.w_a[3])) + ((-bodyBox1.body.w_a[3] * (bodyBox1.body.I[2,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[2,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[2,3] * bodyBox1.body.w_a[3]))) + (bodyBox1.body.r_CM[2] * bodyBox1.body.frame_a.f[3] + (-bodyBox1.body.r_CM[3] * bodyBox1.body.frame_a.f[2]))))));
//   bodyBox1.body.frame_a.t[2] = bodyBox1.body.I[2,1] * bodyBox1.body.z_a[1] + (bodyBox1.body.I[2,2] * bodyBox1.body.z_a[2] + (bodyBox1.body.I[2,3] * bodyBox1.body.z_a[3] + (bodyBox1.body.w_a[3] * (bodyBox1.body.I[1,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[1,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[1,3] * bodyBox1.body.w_a[3])) + ((-bodyBox1.body.w_a[1] * (bodyBox1.body.I[3,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[3,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[3,3] * bodyBox1.body.w_a[3]))) + (bodyBox1.body.r_CM[3] * bodyBox1.body.frame_a.f[1] + (-bodyBox1.body.r_CM[1] * bodyBox1.body.frame_a.f[3]))))));
//   bodyBox1.body.frame_a.t[3] = bodyBox1.body.I[3,1] * bodyBox1.body.z_a[1] + (bodyBox1.body.I[3,2] * bodyBox1.body.z_a[2] + (bodyBox1.body.I[3,3] * bodyBox1.body.z_a[3] + (bodyBox1.body.w_a[1] * (bodyBox1.body.I[2,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[2,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[2,3] * bodyBox1.body.w_a[3])) + ((-bodyBox1.body.w_a[2] * (bodyBox1.body.I[1,1] * bodyBox1.body.w_a[1] + (bodyBox1.body.I[1,2] * bodyBox1.body.w_a[2] + bodyBox1.body.I[1,3] * bodyBox1.body.w_a[3]))) + (bodyBox1.body.r_CM[1] * bodyBox1.body.frame_a.f[2] + (-bodyBox1.body.r_CM[2] * bodyBox1.body.frame_a.f[1]))))));
//   bodyBox1.frameTranslation.shape.R.T[1,1] = bodyBox1.frameTranslation.frame_a.R.T[1,1];
//   bodyBox1.frameTranslation.shape.R.T[1,2] = bodyBox1.frameTranslation.frame_a.R.T[1,2];
//   bodyBox1.frameTranslation.shape.R.T[1,3] = bodyBox1.frameTranslation.frame_a.R.T[1,3];
//   bodyBox1.frameTranslation.shape.R.T[2,1] = bodyBox1.frameTranslation.frame_a.R.T[2,1];
//   bodyBox1.frameTranslation.shape.R.T[2,2] = bodyBox1.frameTranslation.frame_a.R.T[2,2];
//   bodyBox1.frameTranslation.shape.R.T[2,3] = bodyBox1.frameTranslation.frame_a.R.T[2,3];
//   bodyBox1.frameTranslation.shape.R.T[3,1] = bodyBox1.frameTranslation.frame_a.R.T[3,1];
//   bodyBox1.frameTranslation.shape.R.T[3,2] = bodyBox1.frameTranslation.frame_a.R.T[3,2];
//   bodyBox1.frameTranslation.shape.R.T[3,3] = bodyBox1.frameTranslation.frame_a.R.T[3,3];
//   bodyBox1.frameTranslation.shape.R.w[1] = bodyBox1.frameTranslation.frame_a.R.w[1];
//   bodyBox1.frameTranslation.shape.R.w[2] = bodyBox1.frameTranslation.frame_a.R.w[2];
//   bodyBox1.frameTranslation.shape.R.w[3] = bodyBox1.frameTranslation.frame_a.R.w[3];
//   bodyBox1.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyBox1.frameTranslation.shape.shapeType);
//   bodyBox1.frameTranslation.shape.rxvisobj[1] = bodyBox1.frameTranslation.shape.R.T[1,1] * bodyBox1.frameTranslation.shape.e_x[1] + (bodyBox1.frameTranslation.shape.R.T[2,1] * bodyBox1.frameTranslation.shape.e_x[2] + bodyBox1.frameTranslation.shape.R.T[3,1] * bodyBox1.frameTranslation.shape.e_x[3]);
//   bodyBox1.frameTranslation.shape.rxvisobj[2] = bodyBox1.frameTranslation.shape.R.T[1,2] * bodyBox1.frameTranslation.shape.e_x[1] + (bodyBox1.frameTranslation.shape.R.T[2,2] * bodyBox1.frameTranslation.shape.e_x[2] + bodyBox1.frameTranslation.shape.R.T[3,2] * bodyBox1.frameTranslation.shape.e_x[3]);
//   bodyBox1.frameTranslation.shape.rxvisobj[3] = bodyBox1.frameTranslation.shape.R.T[1,3] * bodyBox1.frameTranslation.shape.e_x[1] + (bodyBox1.frameTranslation.shape.R.T[2,3] * bodyBox1.frameTranslation.shape.e_x[2] + bodyBox1.frameTranslation.shape.R.T[3,3] * bodyBox1.frameTranslation.shape.e_x[3]);
//   bodyBox1.frameTranslation.shape.ryvisobj[1] = bodyBox1.frameTranslation.shape.R.T[1,1] * bodyBox1.frameTranslation.shape.e_y[1] + (bodyBox1.frameTranslation.shape.R.T[2,1] * bodyBox1.frameTranslation.shape.e_y[2] + bodyBox1.frameTranslation.shape.R.T[3,1] * bodyBox1.frameTranslation.shape.e_y[3]);
//   bodyBox1.frameTranslation.shape.ryvisobj[2] = bodyBox1.frameTranslation.shape.R.T[1,2] * bodyBox1.frameTranslation.shape.e_y[1] + (bodyBox1.frameTranslation.shape.R.T[2,2] * bodyBox1.frameTranslation.shape.e_y[2] + bodyBox1.frameTranslation.shape.R.T[3,2] * bodyBox1.frameTranslation.shape.e_y[3]);
//   bodyBox1.frameTranslation.shape.ryvisobj[3] = bodyBox1.frameTranslation.shape.R.T[1,3] * bodyBox1.frameTranslation.shape.e_y[1] + (bodyBox1.frameTranslation.shape.R.T[2,3] * bodyBox1.frameTranslation.shape.e_y[2] + bodyBox1.frameTranslation.shape.R.T[3,3] * bodyBox1.frameTranslation.shape.e_y[3]);
//   bodyBox1.frameTranslation.shape.rvisobj = bodyBox1.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyBox1.frameTranslation.shape.R.T[1,1],bodyBox1.frameTranslation.shape.R.T[1,2],bodyBox1.frameTranslation.shape.R.T[1,3]},{bodyBox1.frameTranslation.shape.R.T[2,1],bodyBox1.frameTranslation.shape.R.T[2,2],bodyBox1.frameTranslation.shape.R.T[2,3]},{bodyBox1.frameTranslation.shape.R.T[3,1],bodyBox1.frameTranslation.shape.R.T[3,2],bodyBox1.frameTranslation.shape.R.T[3,3]}},{bodyBox1.frameTranslation.shape.r_shape[1],bodyBox1.frameTranslation.shape.r_shape[2],bodyBox1.frameTranslation.shape.r_shape[3]});
//   bodyBox1.frameTranslation.shape.size[1] = bodyBox1.frameTranslation.shape.length;
//   bodyBox1.frameTranslation.shape.size[2] = bodyBox1.frameTranslation.shape.width;
//   bodyBox1.frameTranslation.shape.size[3] = bodyBox1.frameTranslation.shape.height;
//   bodyBox1.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyBox1.frameTranslation.shape.color[1] / 255.0,bodyBox1.frameTranslation.shape.color[2] / 255.0,bodyBox1.frameTranslation.shape.color[3] / 255.0,bodyBox1.frameTranslation.shape.specularCoefficient);
//   bodyBox1.frameTranslation.shape.Extra = bodyBox1.frameTranslation.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   bodyBox1.frameTranslation.frame_b.r_0 = bodyBox1.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(bodyBox1.frameTranslation.frame_a.R,{bodyBox1.frameTranslation.r[1],bodyBox1.frameTranslation.r[2],bodyBox1.frameTranslation.r[3]});
//   bodyBox1.frameTranslation.frame_b.R.T[1,1] = bodyBox1.frameTranslation.frame_a.R.T[1,1];
//   bodyBox1.frameTranslation.frame_b.R.T[1,2] = bodyBox1.frameTranslation.frame_a.R.T[1,2];
//   bodyBox1.frameTranslation.frame_b.R.T[1,3] = bodyBox1.frameTranslation.frame_a.R.T[1,3];
//   bodyBox1.frameTranslation.frame_b.R.T[2,1] = bodyBox1.frameTranslation.frame_a.R.T[2,1];
//   bodyBox1.frameTranslation.frame_b.R.T[2,2] = bodyBox1.frameTranslation.frame_a.R.T[2,2];
//   bodyBox1.frameTranslation.frame_b.R.T[2,3] = bodyBox1.frameTranslation.frame_a.R.T[2,3];
//   bodyBox1.frameTranslation.frame_b.R.T[3,1] = bodyBox1.frameTranslation.frame_a.R.T[3,1];
//   bodyBox1.frameTranslation.frame_b.R.T[3,2] = bodyBox1.frameTranslation.frame_a.R.T[3,2];
//   bodyBox1.frameTranslation.frame_b.R.T[3,3] = bodyBox1.frameTranslation.frame_a.R.T[3,3];
//   bodyBox1.frameTranslation.frame_b.R.w[1] = bodyBox1.frameTranslation.frame_a.R.w[1];
//   bodyBox1.frameTranslation.frame_b.R.w[2] = bodyBox1.frameTranslation.frame_a.R.w[2];
//   bodyBox1.frameTranslation.frame_b.R.w[3] = bodyBox1.frameTranslation.frame_a.R.w[3];
//   0.0 = bodyBox1.frameTranslation.frame_a.f[1] + bodyBox1.frameTranslation.frame_b.f[1];
//   0.0 = bodyBox1.frameTranslation.frame_a.f[2] + bodyBox1.frameTranslation.frame_b.f[2];
//   0.0 = bodyBox1.frameTranslation.frame_a.f[3] + bodyBox1.frameTranslation.frame_b.f[3];
//   0.0 = bodyBox1.frameTranslation.frame_a.t[1] + (bodyBox1.frameTranslation.frame_b.t[1] + (bodyBox1.frameTranslation.r[2] * bodyBox1.frameTranslation.frame_b.f[3] + (-bodyBox1.frameTranslation.r[3] * bodyBox1.frameTranslation.frame_b.f[2])));
//   0.0 = bodyBox1.frameTranslation.frame_a.t[2] + (bodyBox1.frameTranslation.frame_b.t[2] + (bodyBox1.frameTranslation.r[3] * bodyBox1.frameTranslation.frame_b.f[1] + (-bodyBox1.frameTranslation.r[1] * bodyBox1.frameTranslation.frame_b.f[3])));
//   0.0 = bodyBox1.frameTranslation.frame_a.t[3] + (bodyBox1.frameTranslation.frame_b.t[3] + (bodyBox1.frameTranslation.r[1] * bodyBox1.frameTranslation.frame_b.f[2] + (-bodyBox1.frameTranslation.r[2] * bodyBox1.frameTranslation.frame_b.f[1])));
//   bodyBox1.r_0[1] = bodyBox1.frame_a.r_0[1];
//   bodyBox1.r_0[2] = bodyBox1.frame_a.r_0[2];
//   bodyBox1.r_0[3] = bodyBox1.frame_a.r_0[3];
//   bodyBox1.v_0[1] = der(bodyBox1.r_0[1]);
//   bodyBox1.v_0[2] = der(bodyBox1.r_0[2]);
//   bodyBox1.v_0[3] = der(bodyBox1.r_0[3]);
//   bodyBox1.a_0[1] = der(bodyBox1.v_0[1]);
//   bodyBox1.a_0[2] = der(bodyBox1.v_0[2]);
//   bodyBox1.a_0[3] = der(bodyBox1.v_0[3]);
//   assert(bodyBox1.innerWidth <= bodyBox1.width,"parameter innerWidth is greater as parameter width");
//   assert(bodyBox1.innerHeight <= bodyBox1.height,"parameter innerHeight is greater as paraemter height");
//   bodyBox1.frameTranslation.frame_a.t[1] + ((-bodyBox1.frame_a.t[1]) + bodyBox1.body.frame_a.t[1]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.t[2] + ((-bodyBox1.frame_a.t[2]) + bodyBox1.body.frame_a.t[2]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.t[3] + ((-bodyBox1.frame_a.t[3]) + bodyBox1.body.frame_a.t[3]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.f[1] + ((-bodyBox1.frame_a.f[1]) + bodyBox1.body.frame_a.f[1]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.f[2] + ((-bodyBox1.frame_a.f[2]) + bodyBox1.body.frame_a.f[2]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.f[3] + ((-bodyBox1.frame_a.f[3]) + bodyBox1.body.frame_a.f[3]) = 0.0;
//   bodyBox1.frameTranslation.frame_a.R.w[1] = bodyBox1.frame_a.R.w[1];
//   bodyBox1.frame_a.R.w[1] = bodyBox1.body.frame_a.R.w[1];
//   bodyBox1.frameTranslation.frame_a.R.w[2] = bodyBox1.frame_a.R.w[2];
//   bodyBox1.frame_a.R.w[2] = bodyBox1.body.frame_a.R.w[2];
//   bodyBox1.frameTranslation.frame_a.R.w[3] = bodyBox1.frame_a.R.w[3];
//   bodyBox1.frame_a.R.w[3] = bodyBox1.body.frame_a.R.w[3];
//   bodyBox1.frameTranslation.frame_a.R.T[1,1] = bodyBox1.frame_a.R.T[1,1];
//   bodyBox1.frame_a.R.T[1,1] = bodyBox1.body.frame_a.R.T[1,1];
//   bodyBox1.frameTranslation.frame_a.R.T[1,2] = bodyBox1.frame_a.R.T[1,2];
//   bodyBox1.frame_a.R.T[1,2] = bodyBox1.body.frame_a.R.T[1,2];
//   bodyBox1.frameTranslation.frame_a.R.T[1,3] = bodyBox1.frame_a.R.T[1,3];
//   bodyBox1.frame_a.R.T[1,3] = bodyBox1.body.frame_a.R.T[1,3];
//   bodyBox1.frameTranslation.frame_a.R.T[2,1] = bodyBox1.frame_a.R.T[2,1];
//   bodyBox1.frame_a.R.T[2,1] = bodyBox1.body.frame_a.R.T[2,1];
//   bodyBox1.frameTranslation.frame_a.R.T[2,2] = bodyBox1.frame_a.R.T[2,2];
//   bodyBox1.frame_a.R.T[2,2] = bodyBox1.body.frame_a.R.T[2,2];
//   bodyBox1.frameTranslation.frame_a.R.T[2,3] = bodyBox1.frame_a.R.T[2,3];
//   bodyBox1.frame_a.R.T[2,3] = bodyBox1.body.frame_a.R.T[2,3];
//   bodyBox1.frameTranslation.frame_a.R.T[3,1] = bodyBox1.frame_a.R.T[3,1];
//   bodyBox1.frame_a.R.T[3,1] = bodyBox1.body.frame_a.R.T[3,1];
//   bodyBox1.frameTranslation.frame_a.R.T[3,2] = bodyBox1.frame_a.R.T[3,2];
//   bodyBox1.frame_a.R.T[3,2] = bodyBox1.body.frame_a.R.T[3,2];
//   bodyBox1.frameTranslation.frame_a.R.T[3,3] = bodyBox1.frame_a.R.T[3,3];
//   bodyBox1.frame_a.R.T[3,3] = bodyBox1.body.frame_a.R.T[3,3];
//   bodyBox1.frameTranslation.frame_a.r_0[1] = bodyBox1.frame_a.r_0[1];
//   bodyBox1.frame_a.r_0[1] = bodyBox1.body.frame_a.r_0[1];
//   bodyBox1.frameTranslation.frame_a.r_0[2] = bodyBox1.frame_a.r_0[2];
//   bodyBox1.frame_a.r_0[2] = bodyBox1.body.frame_a.r_0[2];
//   bodyBox1.frameTranslation.frame_a.r_0[3] = bodyBox1.frame_a.r_0[3];
//   bodyBox1.frame_a.r_0[3] = bodyBox1.body.frame_a.r_0[3];
//   bodyBox1.frameTranslation.frame_b.t[1] + (-bodyBox1.frame_b.t[1]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.t[2] + (-bodyBox1.frame_b.t[2]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.t[3] + (-bodyBox1.frame_b.t[3]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.f[1] + (-bodyBox1.frame_b.f[1]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.f[2] + (-bodyBox1.frame_b.f[2]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.f[3] + (-bodyBox1.frame_b.f[3]) = 0.0;
//   bodyBox1.frameTranslation.frame_b.R.w[1] = bodyBox1.frame_b.R.w[1];
//   bodyBox1.frameTranslation.frame_b.R.w[2] = bodyBox1.frame_b.R.w[2];
//   bodyBox1.frameTranslation.frame_b.R.w[3] = bodyBox1.frame_b.R.w[3];
//   bodyBox1.frameTranslation.frame_b.R.T[1,1] = bodyBox1.frame_b.R.T[1,1];
//   bodyBox1.frameTranslation.frame_b.R.T[1,2] = bodyBox1.frame_b.R.T[1,2];
//   bodyBox1.frameTranslation.frame_b.R.T[1,3] = bodyBox1.frame_b.R.T[1,3];
//   bodyBox1.frameTranslation.frame_b.R.T[2,1] = bodyBox1.frame_b.R.T[2,1];
//   bodyBox1.frameTranslation.frame_b.R.T[2,2] = bodyBox1.frame_b.R.T[2,2];
//   bodyBox1.frameTranslation.frame_b.R.T[2,3] = bodyBox1.frame_b.R.T[2,3];
//   bodyBox1.frameTranslation.frame_b.R.T[3,1] = bodyBox1.frame_b.R.T[3,1];
//   bodyBox1.frameTranslation.frame_b.R.T[3,2] = bodyBox1.frame_b.R.T[3,2];
//   bodyBox1.frameTranslation.frame_b.R.T[3,3] = bodyBox1.frame_b.R.T[3,3];
//   bodyBox1.frameTranslation.frame_b.r_0[1] = bodyBox1.frame_b.r_0[1];
//   bodyBox1.frameTranslation.frame_b.r_0[2] = bodyBox1.frame_b.r_0[2];
//   bodyBox1.frameTranslation.frame_b.r_0[3] = bodyBox1.frame_b.r_0[3];
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   rod1.frame_b.r_0 = rod1.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod1.frame_a.R,{rod1.r[1],rod1.r[2],rod1.r[3]});
//   rod1.frame_b.R.T[1,1] = rod1.frame_a.R.T[1,1];
//   rod1.frame_b.R.T[1,2] = rod1.frame_a.R.T[1,2];
//   rod1.frame_b.R.T[1,3] = rod1.frame_a.R.T[1,3];
//   rod1.frame_b.R.T[2,1] = rod1.frame_a.R.T[2,1];
//   rod1.frame_b.R.T[2,2] = rod1.frame_a.R.T[2,2];
//   rod1.frame_b.R.T[2,3] = rod1.frame_a.R.T[2,3];
//   rod1.frame_b.R.T[3,1] = rod1.frame_a.R.T[3,1];
//   rod1.frame_b.R.T[3,2] = rod1.frame_a.R.T[3,2];
//   rod1.frame_b.R.T[3,3] = rod1.frame_a.R.T[3,3];
//   rod1.frame_b.R.w[1] = rod1.frame_a.R.w[1];
//   rod1.frame_b.R.w[2] = rod1.frame_a.R.w[2];
//   rod1.frame_b.R.w[3] = rod1.frame_a.R.w[3];
//   0.0 = rod1.frame_a.f[1] + rod1.frame_b.f[1];
//   0.0 = rod1.frame_a.f[2] + rod1.frame_b.f[2];
//   0.0 = rod1.frame_a.f[3] + rod1.frame_b.f[3];
//   0.0 = rod1.frame_a.t[1] + (rod1.frame_b.t[1] + (rod1.r[2] * rod1.frame_b.f[3] + (-rod1.r[3] * rod1.frame_b.f[2])));
//   0.0 = rod1.frame_a.t[2] + (rod1.frame_b.t[2] + (rod1.r[3] * rod1.frame_b.f[1] + (-rod1.r[1] * rod1.frame_b.f[3])));
//   0.0 = rod1.frame_a.t[3] + (rod1.frame_b.t[3] + (rod1.r[1] * rod1.frame_b.f[2] + (-rod1.r[2] * rod1.frame_b.f[1])));
//   jointUPS.axisCylinder.R.T[1,1] = jointUPS.frame_ia.R.T[1,1];
//   jointUPS.axisCylinder.R.T[1,2] = jointUPS.frame_ia.R.T[1,2];
//   jointUPS.axisCylinder.R.T[1,3] = jointUPS.frame_ia.R.T[1,3];
//   jointUPS.axisCylinder.R.T[2,1] = jointUPS.frame_ia.R.T[2,1];
//   jointUPS.axisCylinder.R.T[2,2] = jointUPS.frame_ia.R.T[2,2];
//   jointUPS.axisCylinder.R.T[2,3] = jointUPS.frame_ia.R.T[2,3];
//   jointUPS.axisCylinder.R.T[3,1] = jointUPS.frame_ia.R.T[3,1];
//   jointUPS.axisCylinder.R.T[3,2] = jointUPS.frame_ia.R.T[3,2];
//   jointUPS.axisCylinder.R.T[3,3] = jointUPS.frame_ia.R.T[3,3];
//   jointUPS.axisCylinder.R.w[1] = jointUPS.frame_ia.R.w[1];
//   jointUPS.axisCylinder.R.w[2] = jointUPS.frame_ia.R.w[2];
//   jointUPS.axisCylinder.R.w[3] = jointUPS.frame_ia.R.w[3];
//   jointUPS.axisCylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointUPS.axisCylinder.shapeType);
//   jointUPS.axisCylinder.rxvisobj[1] = jointUPS.axisCylinder.R.T[1,1] * jointUPS.axisCylinder.e_x[1] + (jointUPS.axisCylinder.R.T[2,1] * jointUPS.axisCylinder.e_x[2] + jointUPS.axisCylinder.R.T[3,1] * jointUPS.axisCylinder.e_x[3]);
//   jointUPS.axisCylinder.rxvisobj[2] = jointUPS.axisCylinder.R.T[1,2] * jointUPS.axisCylinder.e_x[1] + (jointUPS.axisCylinder.R.T[2,2] * jointUPS.axisCylinder.e_x[2] + jointUPS.axisCylinder.R.T[3,2] * jointUPS.axisCylinder.e_x[3]);
//   jointUPS.axisCylinder.rxvisobj[3] = jointUPS.axisCylinder.R.T[1,3] * jointUPS.axisCylinder.e_x[1] + (jointUPS.axisCylinder.R.T[2,3] * jointUPS.axisCylinder.e_x[2] + jointUPS.axisCylinder.R.T[3,3] * jointUPS.axisCylinder.e_x[3]);
//   jointUPS.axisCylinder.ryvisobj[1] = jointUPS.axisCylinder.R.T[1,1] * jointUPS.axisCylinder.e_y[1] + (jointUPS.axisCylinder.R.T[2,1] * jointUPS.axisCylinder.e_y[2] + jointUPS.axisCylinder.R.T[3,1] * jointUPS.axisCylinder.e_y[3]);
//   jointUPS.axisCylinder.ryvisobj[2] = jointUPS.axisCylinder.R.T[1,2] * jointUPS.axisCylinder.e_y[1] + (jointUPS.axisCylinder.R.T[2,2] * jointUPS.axisCylinder.e_y[2] + jointUPS.axisCylinder.R.T[3,2] * jointUPS.axisCylinder.e_y[3]);
//   jointUPS.axisCylinder.ryvisobj[3] = jointUPS.axisCylinder.R.T[1,3] * jointUPS.axisCylinder.e_y[1] + (jointUPS.axisCylinder.R.T[2,3] * jointUPS.axisCylinder.e_y[2] + jointUPS.axisCylinder.R.T[3,3] * jointUPS.axisCylinder.e_y[3]);
//   jointUPS.axisCylinder.rvisobj = jointUPS.axisCylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointUPS.axisCylinder.R.T[1,1],jointUPS.axisCylinder.R.T[1,2],jointUPS.axisCylinder.R.T[1,3]},{jointUPS.axisCylinder.R.T[2,1],jointUPS.axisCylinder.R.T[2,2],jointUPS.axisCylinder.R.T[2,3]},{jointUPS.axisCylinder.R.T[3,1],jointUPS.axisCylinder.R.T[3,2],jointUPS.axisCylinder.R.T[3,3]}},{jointUPS.axisCylinder.r_shape[1],jointUPS.axisCylinder.r_shape[2],jointUPS.axisCylinder.r_shape[3]});
//   jointUPS.axisCylinder.size[1] = jointUPS.axisCylinder.length;
//   jointUPS.axisCylinder.size[2] = jointUPS.axisCylinder.width;
//   jointUPS.axisCylinder.size[3] = jointUPS.axisCylinder.height;
//   jointUPS.axisCylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointUPS.axisCylinder.color[1] / 255.0,jointUPS.axisCylinder.color[2] / 255.0,jointUPS.axisCylinder.color[3] / 255.0,jointUPS.axisCylinder.specularCoefficient);
//   jointUPS.axisCylinder.Extra = jointUPS.axisCylinder.extra;
//   jointUPS.sphericalShape_b.R.T[1,1] = jointUPS.frame_b.R.T[1,1];
//   jointUPS.sphericalShape_b.R.T[1,2] = jointUPS.frame_b.R.T[1,2];
//   jointUPS.sphericalShape_b.R.T[1,3] = jointUPS.frame_b.R.T[1,3];
//   jointUPS.sphericalShape_b.R.T[2,1] = jointUPS.frame_b.R.T[2,1];
//   jointUPS.sphericalShape_b.R.T[2,2] = jointUPS.frame_b.R.T[2,2];
//   jointUPS.sphericalShape_b.R.T[2,3] = jointUPS.frame_b.R.T[2,3];
//   jointUPS.sphericalShape_b.R.T[3,1] = jointUPS.frame_b.R.T[3,1];
//   jointUPS.sphericalShape_b.R.T[3,2] = jointUPS.frame_b.R.T[3,2];
//   jointUPS.sphericalShape_b.R.T[3,3] = jointUPS.frame_b.R.T[3,3];
//   jointUPS.sphericalShape_b.R.w[1] = jointUPS.frame_b.R.w[1];
//   jointUPS.sphericalShape_b.R.w[2] = jointUPS.frame_b.R.w[2];
//   jointUPS.sphericalShape_b.R.w[3] = jointUPS.frame_b.R.w[3];
//   jointUPS.sphericalShape_b.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointUPS.sphericalShape_b.shapeType);
//   jointUPS.sphericalShape_b.rxvisobj[1] = jointUPS.sphericalShape_b.R.T[1,1] * jointUPS.sphericalShape_b.e_x[1] + (jointUPS.sphericalShape_b.R.T[2,1] * jointUPS.sphericalShape_b.e_x[2] + jointUPS.sphericalShape_b.R.T[3,1] * jointUPS.sphericalShape_b.e_x[3]);
//   jointUPS.sphericalShape_b.rxvisobj[2] = jointUPS.sphericalShape_b.R.T[1,2] * jointUPS.sphericalShape_b.e_x[1] + (jointUPS.sphericalShape_b.R.T[2,2] * jointUPS.sphericalShape_b.e_x[2] + jointUPS.sphericalShape_b.R.T[3,2] * jointUPS.sphericalShape_b.e_x[3]);
//   jointUPS.sphericalShape_b.rxvisobj[3] = jointUPS.sphericalShape_b.R.T[1,3] * jointUPS.sphericalShape_b.e_x[1] + (jointUPS.sphericalShape_b.R.T[2,3] * jointUPS.sphericalShape_b.e_x[2] + jointUPS.sphericalShape_b.R.T[3,3] * jointUPS.sphericalShape_b.e_x[3]);
//   jointUPS.sphericalShape_b.ryvisobj[1] = jointUPS.sphericalShape_b.R.T[1,1] * jointUPS.sphericalShape_b.e_y[1] + (jointUPS.sphericalShape_b.R.T[2,1] * jointUPS.sphericalShape_b.e_y[2] + jointUPS.sphericalShape_b.R.T[3,1] * jointUPS.sphericalShape_b.e_y[3]);
//   jointUPS.sphericalShape_b.ryvisobj[2] = jointUPS.sphericalShape_b.R.T[1,2] * jointUPS.sphericalShape_b.e_y[1] + (jointUPS.sphericalShape_b.R.T[2,2] * jointUPS.sphericalShape_b.e_y[2] + jointUPS.sphericalShape_b.R.T[3,2] * jointUPS.sphericalShape_b.e_y[3]);
//   jointUPS.sphericalShape_b.ryvisobj[3] = jointUPS.sphericalShape_b.R.T[1,3] * jointUPS.sphericalShape_b.e_y[1] + (jointUPS.sphericalShape_b.R.T[2,3] * jointUPS.sphericalShape_b.e_y[2] + jointUPS.sphericalShape_b.R.T[3,3] * jointUPS.sphericalShape_b.e_y[3]);
//   jointUPS.sphericalShape_b.rvisobj = jointUPS.sphericalShape_b.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointUPS.sphericalShape_b.R.T[1,1],jointUPS.sphericalShape_b.R.T[1,2],jointUPS.sphericalShape_b.R.T[1,3]},{jointUPS.sphericalShape_b.R.T[2,1],jointUPS.sphericalShape_b.R.T[2,2],jointUPS.sphericalShape_b.R.T[2,3]},{jointUPS.sphericalShape_b.R.T[3,1],jointUPS.sphericalShape_b.R.T[3,2],jointUPS.sphericalShape_b.R.T[3,3]}},{jointUPS.sphericalShape_b.r_shape[1],jointUPS.sphericalShape_b.r_shape[2],jointUPS.sphericalShape_b.r_shape[3]});
//   jointUPS.sphericalShape_b.size[1] = jointUPS.sphericalShape_b.length;
//   jointUPS.sphericalShape_b.size[2] = jointUPS.sphericalShape_b.width;
//   jointUPS.sphericalShape_b.size[3] = jointUPS.sphericalShape_b.height;
//   jointUPS.sphericalShape_b.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointUPS.sphericalShape_b.color[1] / 255.0,jointUPS.sphericalShape_b.color[2] / 255.0,jointUPS.sphericalShape_b.color[3] / 255.0,jointUPS.sphericalShape_b.specularCoefficient);
//   jointUPS.sphericalShape_b.Extra = jointUPS.sphericalShape_b.extra;
//   jointUPS.sphericalShape_a.R.T[1,1] = jointUPS.frame_a.R.T[1,1];
//   jointUPS.sphericalShape_a.R.T[1,2] = jointUPS.frame_a.R.T[1,2];
//   jointUPS.sphericalShape_a.R.T[1,3] = jointUPS.frame_a.R.T[1,3];
//   jointUPS.sphericalShape_a.R.T[2,1] = jointUPS.frame_a.R.T[2,1];
//   jointUPS.sphericalShape_a.R.T[2,2] = jointUPS.frame_a.R.T[2,2];
//   jointUPS.sphericalShape_a.R.T[2,3] = jointUPS.frame_a.R.T[2,3];
//   jointUPS.sphericalShape_a.R.T[3,1] = jointUPS.frame_a.R.T[3,1];
//   jointUPS.sphericalShape_a.R.T[3,2] = jointUPS.frame_a.R.T[3,2];
//   jointUPS.sphericalShape_a.R.T[3,3] = jointUPS.frame_a.R.T[3,3];
//   jointUPS.sphericalShape_a.R.w[1] = jointUPS.frame_a.R.w[1];
//   jointUPS.sphericalShape_a.R.w[2] = jointUPS.frame_a.R.w[2];
//   jointUPS.sphericalShape_a.R.w[3] = jointUPS.frame_a.R.w[3];
//   jointUPS.sphericalShape_a.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointUPS.sphericalShape_a.shapeType);
//   jointUPS.sphericalShape_a.rxvisobj[1] = jointUPS.sphericalShape_a.R.T[1,1] * jointUPS.sphericalShape_a.e_x[1] + (jointUPS.sphericalShape_a.R.T[2,1] * jointUPS.sphericalShape_a.e_x[2] + jointUPS.sphericalShape_a.R.T[3,1] * jointUPS.sphericalShape_a.e_x[3]);
//   jointUPS.sphericalShape_a.rxvisobj[2] = jointUPS.sphericalShape_a.R.T[1,2] * jointUPS.sphericalShape_a.e_x[1] + (jointUPS.sphericalShape_a.R.T[2,2] * jointUPS.sphericalShape_a.e_x[2] + jointUPS.sphericalShape_a.R.T[3,2] * jointUPS.sphericalShape_a.e_x[3]);
//   jointUPS.sphericalShape_a.rxvisobj[3] = jointUPS.sphericalShape_a.R.T[1,3] * jointUPS.sphericalShape_a.e_x[1] + (jointUPS.sphericalShape_a.R.T[2,3] * jointUPS.sphericalShape_a.e_x[2] + jointUPS.sphericalShape_a.R.T[3,3] * jointUPS.sphericalShape_a.e_x[3]);
//   jointUPS.sphericalShape_a.ryvisobj[1] = jointUPS.sphericalShape_a.R.T[1,1] * jointUPS.sphericalShape_a.e_y[1] + (jointUPS.sphericalShape_a.R.T[2,1] * jointUPS.sphericalShape_a.e_y[2] + jointUPS.sphericalShape_a.R.T[3,1] * jointUPS.sphericalShape_a.e_y[3]);
//   jointUPS.sphericalShape_a.ryvisobj[2] = jointUPS.sphericalShape_a.R.T[1,2] * jointUPS.sphericalShape_a.e_y[1] + (jointUPS.sphericalShape_a.R.T[2,2] * jointUPS.sphericalShape_a.e_y[2] + jointUPS.sphericalShape_a.R.T[3,2] * jointUPS.sphericalShape_a.e_y[3]);
//   jointUPS.sphericalShape_a.ryvisobj[3] = jointUPS.sphericalShape_a.R.T[1,3] * jointUPS.sphericalShape_a.e_y[1] + (jointUPS.sphericalShape_a.R.T[2,3] * jointUPS.sphericalShape_a.e_y[2] + jointUPS.sphericalShape_a.R.T[3,3] * jointUPS.sphericalShape_a.e_y[3]);
//   jointUPS.sphericalShape_a.rvisobj = jointUPS.sphericalShape_a.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointUPS.sphericalShape_a.R.T[1,1],jointUPS.sphericalShape_a.R.T[1,2],jointUPS.sphericalShape_a.R.T[1,3]},{jointUPS.sphericalShape_a.R.T[2,1],jointUPS.sphericalShape_a.R.T[2,2],jointUPS.sphericalShape_a.R.T[2,3]},{jointUPS.sphericalShape_a.R.T[3,1],jointUPS.sphericalShape_a.R.T[3,2],jointUPS.sphericalShape_a.R.T[3,3]}},{jointUPS.sphericalShape_a.r_shape[1],jointUPS.sphericalShape_a.r_shape[2],jointUPS.sphericalShape_a.r_shape[3]});
//   jointUPS.sphericalShape_a.size[1] = jointUPS.sphericalShape_a.length;
//   jointUPS.sphericalShape_a.size[2] = jointUPS.sphericalShape_a.width;
//   jointUPS.sphericalShape_a.size[3] = jointUPS.sphericalShape_a.height;
//   jointUPS.sphericalShape_a.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointUPS.sphericalShape_a.color[1] / 255.0,jointUPS.sphericalShape_a.color[2] / 255.0,jointUPS.sphericalShape_a.color[3] / 255.0,jointUPS.sphericalShape_a.specularCoefficient);
//   jointUPS.sphericalShape_a.Extra = jointUPS.sphericalShape_a.extra;
//   jointUPS.universalShape1.R.T[1,1] = jointUPS.frame_a.R.T[1,1];
//   jointUPS.universalShape1.R.T[1,2] = jointUPS.frame_a.R.T[1,2];
//   jointUPS.universalShape1.R.T[1,3] = jointUPS.frame_a.R.T[1,3];
//   jointUPS.universalShape1.R.T[2,1] = jointUPS.frame_a.R.T[2,1];
//   jointUPS.universalShape1.R.T[2,2] = jointUPS.frame_a.R.T[2,2];
//   jointUPS.universalShape1.R.T[2,3] = jointUPS.frame_a.R.T[2,3];
//   jointUPS.universalShape1.R.T[3,1] = jointUPS.frame_a.R.T[3,1];
//   jointUPS.universalShape1.R.T[3,2] = jointUPS.frame_a.R.T[3,2];
//   jointUPS.universalShape1.R.T[3,3] = jointUPS.frame_a.R.T[3,3];
//   jointUPS.universalShape1.R.w[1] = jointUPS.frame_a.R.w[1];
//   jointUPS.universalShape1.R.w[2] = jointUPS.frame_a.R.w[2];
//   jointUPS.universalShape1.R.w[3] = jointUPS.frame_a.R.w[3];
//   jointUPS.universalShape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointUPS.universalShape1.shapeType);
//   jointUPS.universalShape1.rxvisobj[1] = jointUPS.universalShape1.R.T[1,1] * jointUPS.universalShape1.e_x[1] + (jointUPS.universalShape1.R.T[2,1] * jointUPS.universalShape1.e_x[2] + jointUPS.universalShape1.R.T[3,1] * jointUPS.universalShape1.e_x[3]);
//   jointUPS.universalShape1.rxvisobj[2] = jointUPS.universalShape1.R.T[1,2] * jointUPS.universalShape1.e_x[1] + (jointUPS.universalShape1.R.T[2,2] * jointUPS.universalShape1.e_x[2] + jointUPS.universalShape1.R.T[3,2] * jointUPS.universalShape1.e_x[3]);
//   jointUPS.universalShape1.rxvisobj[3] = jointUPS.universalShape1.R.T[1,3] * jointUPS.universalShape1.e_x[1] + (jointUPS.universalShape1.R.T[2,3] * jointUPS.universalShape1.e_x[2] + jointUPS.universalShape1.R.T[3,3] * jointUPS.universalShape1.e_x[3]);
//   jointUPS.universalShape1.ryvisobj[1] = jointUPS.universalShape1.R.T[1,1] * jointUPS.universalShape1.e_y[1] + (jointUPS.universalShape1.R.T[2,1] * jointUPS.universalShape1.e_y[2] + jointUPS.universalShape1.R.T[3,1] * jointUPS.universalShape1.e_y[3]);
//   jointUPS.universalShape1.ryvisobj[2] = jointUPS.universalShape1.R.T[1,2] * jointUPS.universalShape1.e_y[1] + (jointUPS.universalShape1.R.T[2,2] * jointUPS.universalShape1.e_y[2] + jointUPS.universalShape1.R.T[3,2] * jointUPS.universalShape1.e_y[3]);
//   jointUPS.universalShape1.ryvisobj[3] = jointUPS.universalShape1.R.T[1,3] * jointUPS.universalShape1.e_y[1] + (jointUPS.universalShape1.R.T[2,3] * jointUPS.universalShape1.e_y[2] + jointUPS.universalShape1.R.T[3,3] * jointUPS.universalShape1.e_y[3]);
//   jointUPS.universalShape1.rvisobj = jointUPS.universalShape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointUPS.universalShape1.R.T[1,1],jointUPS.universalShape1.R.T[1,2],jointUPS.universalShape1.R.T[1,3]},{jointUPS.universalShape1.R.T[2,1],jointUPS.universalShape1.R.T[2,2],jointUPS.universalShape1.R.T[2,3]},{jointUPS.universalShape1.R.T[3,1],jointUPS.universalShape1.R.T[3,2],jointUPS.universalShape1.R.T[3,3]}},{jointUPS.universalShape1.r_shape[1],jointUPS.universalShape1.r_shape[2],jointUPS.universalShape1.r_shape[3]});
//   jointUPS.universalShape1.size[1] = jointUPS.universalShape1.length;
//   jointUPS.universalShape1.size[2] = jointUPS.universalShape1.width;
//   jointUPS.universalShape1.size[3] = jointUPS.universalShape1.height;
//   jointUPS.universalShape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointUPS.universalShape1.color[1] / 255.0,jointUPS.universalShape1.color[2] / 255.0,jointUPS.universalShape1.color[3] / 255.0,jointUPS.universalShape1.specularCoefficient);
//   jointUPS.universalShape1.Extra = jointUPS.universalShape1.extra;
//   jointUPS.universalShape2.R.T[1,1] = jointUPS.frame_ia.R.T[1,1];
//   jointUPS.universalShape2.R.T[1,2] = jointUPS.frame_ia.R.T[1,2];
//   jointUPS.universalShape2.R.T[1,3] = jointUPS.frame_ia.R.T[1,3];
//   jointUPS.universalShape2.R.T[2,1] = jointUPS.frame_ia.R.T[2,1];
//   jointUPS.universalShape2.R.T[2,2] = jointUPS.frame_ia.R.T[2,2];
//   jointUPS.universalShape2.R.T[2,3] = jointUPS.frame_ia.R.T[2,3];
//   jointUPS.universalShape2.R.T[3,1] = jointUPS.frame_ia.R.T[3,1];
//   jointUPS.universalShape2.R.T[3,2] = jointUPS.frame_ia.R.T[3,2];
//   jointUPS.universalShape2.R.T[3,3] = jointUPS.frame_ia.R.T[3,3];
//   jointUPS.universalShape2.R.w[1] = jointUPS.frame_ia.R.w[1];
//   jointUPS.universalShape2.R.w[2] = jointUPS.frame_ia.R.w[2];
//   jointUPS.universalShape2.R.w[3] = jointUPS.frame_ia.R.w[3];
//   jointUPS.universalShape2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointUPS.universalShape2.shapeType);
//   jointUPS.universalShape2.rxvisobj[1] = jointUPS.universalShape2.R.T[1,1] * jointUPS.universalShape2.e_x[1] + (jointUPS.universalShape2.R.T[2,1] * jointUPS.universalShape2.e_x[2] + jointUPS.universalShape2.R.T[3,1] * jointUPS.universalShape2.e_x[3]);
//   jointUPS.universalShape2.rxvisobj[2] = jointUPS.universalShape2.R.T[1,2] * jointUPS.universalShape2.e_x[1] + (jointUPS.universalShape2.R.T[2,2] * jointUPS.universalShape2.e_x[2] + jointUPS.universalShape2.R.T[3,2] * jointUPS.universalShape2.e_x[3]);
//   jointUPS.universalShape2.rxvisobj[3] = jointUPS.universalShape2.R.T[1,3] * jointUPS.universalShape2.e_x[1] + (jointUPS.universalShape2.R.T[2,3] * jointUPS.universalShape2.e_x[2] + jointUPS.universalShape2.R.T[3,3] * jointUPS.universalShape2.e_x[3]);
//   jointUPS.universalShape2.ryvisobj[1] = jointUPS.universalShape2.R.T[1,1] * jointUPS.universalShape2.e_y[1] + (jointUPS.universalShape2.R.T[2,1] * jointUPS.universalShape2.e_y[2] + jointUPS.universalShape2.R.T[3,1] * jointUPS.universalShape2.e_y[3]);
//   jointUPS.universalShape2.ryvisobj[2] = jointUPS.universalShape2.R.T[1,2] * jointUPS.universalShape2.e_y[1] + (jointUPS.universalShape2.R.T[2,2] * jointUPS.universalShape2.e_y[2] + jointUPS.universalShape2.R.T[3,2] * jointUPS.universalShape2.e_y[3]);
//   jointUPS.universalShape2.ryvisobj[3] = jointUPS.universalShape2.R.T[1,3] * jointUPS.universalShape2.e_y[1] + (jointUPS.universalShape2.R.T[2,3] * jointUPS.universalShape2.e_y[2] + jointUPS.universalShape2.R.T[3,3] * jointUPS.universalShape2.e_y[3]);
//   jointUPS.universalShape2.rvisobj = jointUPS.universalShape2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointUPS.universalShape2.R.T[1,1],jointUPS.universalShape2.R.T[1,2],jointUPS.universalShape2.R.T[1,3]},{jointUPS.universalShape2.R.T[2,1],jointUPS.universalShape2.R.T[2,2],jointUPS.universalShape2.R.T[2,3]},{jointUPS.universalShape2.R.T[3,1],jointUPS.universalShape2.R.T[3,2],jointUPS.universalShape2.R.T[3,3]}},{jointUPS.universalShape2.r_shape[1],jointUPS.universalShape2.r_shape[2],jointUPS.universalShape2.r_shape[3]});
//   jointUPS.universalShape2.size[1] = jointUPS.universalShape2.length;
//   jointUPS.universalShape2.size[2] = jointUPS.universalShape2.width;
//   jointUPS.universalShape2.size[3] = jointUPS.universalShape2.height;
//   jointUPS.universalShape2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointUPS.universalShape2.color[1] / 255.0,jointUPS.universalShape2.color[2] / 255.0,jointUPS.universalShape2.color[3] / 255.0,jointUPS.universalShape2.specularCoefficient);
//   jointUPS.universalShape2.Extra = jointUPS.universalShape2.extra;
//   jointUPS.axisLength = jointUPS.s + jointUPS.s_offset;
//   jointUPS.bearing.s = 0.0;
//   jointUPS.axis.s = jointUPS.s;
//   jointUPS.axis.f = jointUPS.f;
//   jointUPS.rAxis_0[1] = jointUPS.frame_b.r_0[1] - jointUPS.frame_a.r_0[1];
//   jointUPS.rAxis_0[2] = jointUPS.frame_b.r_0[2] - jointUPS.frame_a.r_0[2];
//   jointUPS.rAxis_0[3] = jointUPS.frame_b.r_0[3] - jointUPS.frame_a.r_0[3];
//   jointUPS.rAxis_a = Modelica.Mechanics.MultiBody.Frames.resolve2(jointUPS.frame_a.R,{jointUPS.rAxis_0[1],jointUPS.rAxis_0[2],jointUPS.rAxis_0[3]});
//   jointUPS.axisLength = sqrt(jointUPS.rAxis_0[1] ^ 2.0 + (jointUPS.rAxis_0[2] ^ 2.0 + jointUPS.rAxis_0[3] ^ 2.0));
//   assert(jointUPS.axisLength > 1e-15,"
// Distance between frame_a and frame_b of a JointUPS joint
// became zero. This is not allowed. If this occurs during
// initialization, the initial conditions are probably wrong.");
//   jointUPS.eAxis_a[1] = jointUPS.rAxis_a[1] / jointUPS.axisLength;
//   jointUPS.eAxis_a[2] = jointUPS.rAxis_a[2] / jointUPS.axisLength;
//   jointUPS.eAxis_a[3] = jointUPS.rAxis_a[3] / jointUPS.axisLength;
//   jointUPS.n2_a[1] = jointUPS.n1_a[2] * jointUPS.eAxis_a[3] - jointUPS.n1_a[3] * jointUPS.eAxis_a[2];
//   jointUPS.n2_a[2] = jointUPS.n1_a[3] * jointUPS.eAxis_a[1] - jointUPS.n1_a[1] * jointUPS.eAxis_a[3];
//   jointUPS.n2_a[3] = jointUPS.n1_a[1] * jointUPS.eAxis_a[2] - jointUPS.n1_a[2] * jointUPS.eAxis_a[1];
//   jointUPS.length2_n2_a = jointUPS.n2_a[1] ^ 2.0 + (jointUPS.n2_a[2] ^ 2.0 + jointUPS.n2_a[3] ^ 2.0);
//   assert(noEvent(jointUPS.length2_n2_a > 1e-10),"
// A Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS joint (consisting of
// a universal, prismatic and spherical joint) is in the singular
// configuration of the universal joint. This means that axis 1 of
// the universal joint defined via parameter \"n1_a\" is parallel to vector
// \"eAxis_ia\" that is directed from the origin of frame_a to the
// origin of frame_b. You may try to use another \"n1_a\" vector.
// ");
//   jointUPS.length_n2_a = sqrt(jointUPS.length2_n2_a);
//   jointUPS.e2_a[1] = jointUPS.n2_a[1] / jointUPS.length_n2_a;
//   jointUPS.e2_a[2] = jointUPS.n2_a[2] / jointUPS.length_n2_a;
//   jointUPS.e2_a[3] = jointUPS.n2_a[3] / jointUPS.length_n2_a;
//   jointUPS.e3_a[1] = jointUPS.eAxis_a[2] * jointUPS.e2_a[3] - jointUPS.eAxis_a[3] * jointUPS.e2_a[2];
//   jointUPS.e3_a[2] = jointUPS.eAxis_a[3] * jointUPS.e2_a[1] - jointUPS.eAxis_a[1] * jointUPS.e2_a[3];
//   jointUPS.e3_a[3] = jointUPS.eAxis_a[1] * jointUPS.e2_a[2] - jointUPS.eAxis_a[2] * jointUPS.e2_a[1];
//   jointUPS.der_rAxis_a_L = (Modelica.Mechanics.MultiBody.Frames.resolve2(jointUPS.frame_a.R,{der(jointUPS.rAxis_0[1]),der(jointUPS.rAxis_0[2]),der(jointUPS.rAxis_0[3])}) - {jointUPS.frame_a.R.w[2] * jointUPS.rAxis_a[3] - jointUPS.frame_a.R.w[3] * jointUPS.rAxis_a[2],jointUPS.frame_a.R.w[3] * jointUPS.rAxis_a[1] - jointUPS.frame_a.R.w[1] * jointUPS.rAxis_a[3],jointUPS.frame_a.R.w[1] * jointUPS.rAxis_a[2] - jointUPS.frame_a.R.w[2] * jointUPS.rAxis_a[1]}) / jointUPS.axisLength;
//   jointUPS.w_rel_ia1[1] = (jointUPS.e3_a[1] * (jointUPS.n1_a[2] * jointUPS.der_rAxis_a_L[3] - jointUPS.n1_a[3] * jointUPS.der_rAxis_a_L[2]) + (jointUPS.e3_a[2] * (jointUPS.n1_a[3] * jointUPS.der_rAxis_a_L[1] - jointUPS.n1_a[1] * jointUPS.der_rAxis_a_L[3]) + jointUPS.e3_a[3] * (jointUPS.n1_a[1] * jointUPS.der_rAxis_a_L[2] - jointUPS.n1_a[2] * jointUPS.der_rAxis_a_L[1]))) / jointUPS.length_n2_a;
//   jointUPS.w_rel_ia1[2] = (-jointUPS.e3_a[1]) * jointUPS.der_rAxis_a_L[1] + ((-jointUPS.e3_a[2]) * jointUPS.der_rAxis_a_L[2] + (-jointUPS.e3_a[3]) * jointUPS.der_rAxis_a_L[3]);
//   jointUPS.w_rel_ia1[3] = jointUPS.e2_a[1] * jointUPS.der_rAxis_a_L[1] + (jointUPS.e2_a[2] * jointUPS.der_rAxis_a_L[2] + jointUPS.e2_a[3] * jointUPS.der_rAxis_a_L[3]);
//   jointUPS.R_ia1_a = Modelica.Mechanics.MultiBody.Frames.from_T({{jointUPS.eAxis_a[1],jointUPS.eAxis_a[2],jointUPS.eAxis_a[3]},{jointUPS.e2_a[1],jointUPS.e2_a[2],jointUPS.e2_a[3]},{jointUPS.e3_a[1],jointUPS.e3_a[2],jointUPS.e3_a[3]}},{jointUPS.w_rel_ia1[1],jointUPS.w_rel_ia1[2],jointUPS.w_rel_ia1[3]});
//   jointUPS.R_ia2_a = Modelica.Mechanics.MultiBody.Frames.from_T({{jointUPS.eAxis_ia[1],jointUPS.e2_ia[1],jointUPS.e3_ia[1]},{jointUPS.eAxis_ia[2],jointUPS.e2_ia[2],jointUPS.e3_ia[2]},{jointUPS.eAxis_ia[3],jointUPS.e2_ia[3],jointUPS.e3_ia[3]}},{0.0,0.0,0.0});
//   jointUPS.R_ia_a = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointUPS.R_ia1_a,jointUPS.R_ia2_a);
//   jointUPS.frame_ia.r_0[1] = jointUPS.frame_a.r_0[1];
//   jointUPS.frame_ia.r_0[2] = jointUPS.frame_a.r_0[2];
//   jointUPS.frame_ia.r_0[3] = jointUPS.frame_a.r_0[3];
//   jointUPS.frame_ib.r_0[1] = jointUPS.frame_b.r_0[1];
//   jointUPS.frame_ib.r_0[2] = jointUPS.frame_b.r_0[2];
//   jointUPS.frame_ib.r_0[3] = jointUPS.frame_b.r_0[3];
//   jointUPS.frame_ia.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointUPS.frame_a.R,jointUPS.R_ia_a);
//   jointUPS.frame_ib.R.T[1,1] = jointUPS.frame_ia.R.T[1,1];
//   jointUPS.frame_ib.R.T[1,2] = jointUPS.frame_ia.R.T[1,2];
//   jointUPS.frame_ib.R.T[1,3] = jointUPS.frame_ia.R.T[1,3];
//   jointUPS.frame_ib.R.T[2,1] = jointUPS.frame_ia.R.T[2,1];
//   jointUPS.frame_ib.R.T[2,2] = jointUPS.frame_ia.R.T[2,2];
//   jointUPS.frame_ib.R.T[2,3] = jointUPS.frame_ia.R.T[2,3];
//   jointUPS.frame_ib.R.T[3,1] = jointUPS.frame_ia.R.T[3,1];
//   jointUPS.frame_ib.R.T[3,2] = jointUPS.frame_ia.R.T[3,2];
//   jointUPS.frame_ib.R.T[3,3] = jointUPS.frame_ia.R.T[3,3];
//   jointUPS.frame_ib.R.w[1] = jointUPS.frame_ia.R.w[1];
//   jointUPS.frame_ib.R.w[2] = jointUPS.frame_ia.R.w[2];
//   jointUPS.frame_ib.R.w[3] = jointUPS.frame_ia.R.w[3];
//   jointUPS.f_c_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointUPS.R_ia_a,{jointUPS.frame_ia.f[1],jointUPS.frame_ia.f[2],jointUPS.frame_ia.f[3]});
//   jointUPS.t_cd_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointUPS.R_ia_a,{jointUPS.frame_ia.t[1] + jointUPS.frame_ib.t[1],jointUPS.frame_ia.t[2] + jointUPS.frame_ib.t[2],jointUPS.frame_ia.t[3] + jointUPS.frame_ib.t[3]});
//   jointUPS.f_bd_a[1] = (-jointUPS.f) * jointUPS.eAxis_a[1] + ((-(jointUPS.n1_a[1] * jointUPS.t_cd_a[1] + (jointUPS.n1_a[2] * jointUPS.t_cd_a[2] + jointUPS.n1_a[3] * jointUPS.t_cd_a[3])) * (jointUPS.e2_a[1] * 1.0 / jointUPS.axisLength / (jointUPS.n1_a[1] * jointUPS.e3_a[1] + (jointUPS.n1_a[2] * jointUPS.e3_a[2] + jointUPS.n1_a[3] * jointUPS.e3_a[3])))) + (jointUPS.e2_a[1] * jointUPS.t_cd_a[1] + (jointUPS.e2_a[2] * jointUPS.t_cd_a[2] + jointUPS.e2_a[3] * jointUPS.t_cd_a[3])) * jointUPS.e3_a[1] / jointUPS.axisLength);
//   jointUPS.f_bd_a[2] = (-jointUPS.f) * jointUPS.eAxis_a[2] + ((-(jointUPS.n1_a[1] * jointUPS.t_cd_a[1] + (jointUPS.n1_a[2] * jointUPS.t_cd_a[2] + jointUPS.n1_a[3] * jointUPS.t_cd_a[3])) * (jointUPS.e2_a[2] * 1.0 / jointUPS.axisLength / (jointUPS.n1_a[1] * jointUPS.e3_a[1] + (jointUPS.n1_a[2] * jointUPS.e3_a[2] + jointUPS.n1_a[3] * jointUPS.e3_a[3])))) + (jointUPS.e2_a[1] * jointUPS.t_cd_a[1] + (jointUPS.e2_a[2] * jointUPS.t_cd_a[2] + jointUPS.e2_a[3] * jointUPS.t_cd_a[3])) * jointUPS.e3_a[2] / jointUPS.axisLength);
//   jointUPS.f_bd_a[3] = (-jointUPS.f) * jointUPS.eAxis_a[3] + ((-(jointUPS.n1_a[1] * jointUPS.t_cd_a[1] + (jointUPS.n1_a[2] * jointUPS.t_cd_a[2] + jointUPS.n1_a[3] * jointUPS.t_cd_a[3])) * (jointUPS.e2_a[3] * 1.0 / jointUPS.axisLength / (jointUPS.n1_a[1] * jointUPS.e3_a[1] + (jointUPS.n1_a[2] * jointUPS.e3_a[2] + jointUPS.n1_a[3] * jointUPS.e3_a[3])))) + (jointUPS.e2_a[1] * jointUPS.t_cd_a[1] + (jointUPS.e2_a[2] * jointUPS.t_cd_a[2] + jointUPS.e2_a[3] * jointUPS.t_cd_a[3])) * jointUPS.e3_a[3] / jointUPS.axisLength);
//   {0.0,0.0,0.0} = jointUPS.frame_b.f + Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointUPS.frame_ib.f[1],jointUPS.frame_ib.f[2],jointUPS.frame_ib.f[3]},jointUPS.frame_ib.R,jointUPS.frame_b.R) - Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointUPS.f_bd_a[1],jointUPS.f_bd_a[2],jointUPS.f_bd_a[3]},jointUPS.frame_a.R,jointUPS.frame_b.R);
//   0.0 = jointUPS.frame_b.t[1];
//   0.0 = jointUPS.frame_b.t[2];
//   0.0 = jointUPS.frame_b.t[3];
//   0.0 = jointUPS.frame_a.f[1] + (jointUPS.f_c_a[1] + jointUPS.f_bd_a[1]);
//   0.0 = jointUPS.frame_a.f[2] + (jointUPS.f_c_a[2] + jointUPS.f_bd_a[2]);
//   0.0 = jointUPS.frame_a.f[3] + (jointUPS.f_c_a[3] + jointUPS.f_bd_a[3]);
//   0.0 = jointUPS.frame_a.t[1] + (jointUPS.t_cd_a[1] + (jointUPS.rAxis_a[2] * jointUPS.f_bd_a[3] + (-jointUPS.rAxis_a[3] * jointUPS.f_bd_a[2])));
//   0.0 = jointUPS.frame_a.t[2] + (jointUPS.t_cd_a[2] + (jointUPS.rAxis_a[3] * jointUPS.f_bd_a[1] + (-jointUPS.rAxis_a[1] * jointUPS.f_bd_a[3])));
//   0.0 = jointUPS.frame_a.t[3] + (jointUPS.t_cd_a[3] + (jointUPS.rAxis_a[1] * jointUPS.f_bd_a[2] + (-jointUPS.rAxis_a[2] * jointUPS.f_bd_a[1])));
//   jointUPS.totalPower = 0.0;
//   assert(true,"Connector frame_a of component is not connected");
//   assert(true,"Connector frame_b of component is not connected");
//   body1.cylinder.R.T[1,1] = body1.frame_a.R.T[1,1];
//   body1.cylinder.R.T[1,2] = body1.frame_a.R.T[1,2];
//   body1.cylinder.R.T[1,3] = body1.frame_a.R.T[1,3];
//   body1.cylinder.R.T[2,1] = body1.frame_a.R.T[2,1];
//   body1.cylinder.R.T[2,2] = body1.frame_a.R.T[2,2];
//   body1.cylinder.R.T[2,3] = body1.frame_a.R.T[2,3];
//   body1.cylinder.R.T[3,1] = body1.frame_a.R.T[3,1];
//   body1.cylinder.R.T[3,2] = body1.frame_a.R.T[3,2];
//   body1.cylinder.R.T[3,3] = body1.frame_a.R.T[3,3];
//   body1.cylinder.R.w[1] = body1.frame_a.R.w[1];
//   body1.cylinder.R.w[2] = body1.frame_a.R.w[2];
//   body1.cylinder.R.w[3] = body1.frame_a.R.w[3];
//   body1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.cylinder.shapeType);
//   body1.cylinder.rxvisobj[1] = body1.cylinder.R.T[1,1] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,1] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,1] * body1.cylinder.e_x[3]);
//   body1.cylinder.rxvisobj[2] = body1.cylinder.R.T[1,2] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,2] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,2] * body1.cylinder.e_x[3]);
//   body1.cylinder.rxvisobj[3] = body1.cylinder.R.T[1,3] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,3] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,3] * body1.cylinder.e_x[3]);
//   body1.cylinder.ryvisobj[1] = body1.cylinder.R.T[1,1] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,1] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,1] * body1.cylinder.e_y[3]);
//   body1.cylinder.ryvisobj[2] = body1.cylinder.R.T[1,2] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,2] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,2] * body1.cylinder.e_y[3]);
//   body1.cylinder.ryvisobj[3] = body1.cylinder.R.T[1,3] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,3] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,3] * body1.cylinder.e_y[3]);
//   body1.cylinder.rvisobj = body1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.cylinder.R.T[1,1],body1.cylinder.R.T[1,2],body1.cylinder.R.T[1,3]},{body1.cylinder.R.T[2,1],body1.cylinder.R.T[2,2],body1.cylinder.R.T[2,3]},{body1.cylinder.R.T[3,1],body1.cylinder.R.T[3,2],body1.cylinder.R.T[3,3]}},{body1.cylinder.r_shape[1],body1.cylinder.r_shape[2],body1.cylinder.r_shape[3]});
//   body1.cylinder.size[1] = body1.cylinder.length;
//   body1.cylinder.size[2] = body1.cylinder.width;
//   body1.cylinder.size[3] = body1.cylinder.height;
//   body1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.cylinder.color[1] / 255.0,body1.cylinder.color[2] / 255.0,body1.cylinder.color[3] / 255.0,body1.cylinder.specularCoefficient);
//   body1.cylinder.Extra = body1.cylinder.extra;
//   body1.sphere.R.T[1,1] = body1.frame_a.R.T[1,1];
//   body1.sphere.R.T[1,2] = body1.frame_a.R.T[1,2];
//   body1.sphere.R.T[1,3] = body1.frame_a.R.T[1,3];
//   body1.sphere.R.T[2,1] = body1.frame_a.R.T[2,1];
//   body1.sphere.R.T[2,2] = body1.frame_a.R.T[2,2];
//   body1.sphere.R.T[2,3] = body1.frame_a.R.T[2,3];
//   body1.sphere.R.T[3,1] = body1.frame_a.R.T[3,1];
//   body1.sphere.R.T[3,2] = body1.frame_a.R.T[3,2];
//   body1.sphere.R.T[3,3] = body1.frame_a.R.T[3,3];
//   body1.sphere.R.w[1] = body1.frame_a.R.w[1];
//   body1.sphere.R.w[2] = body1.frame_a.R.w[2];
//   body1.sphere.R.w[3] = body1.frame_a.R.w[3];
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3]);
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3]);
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3]);
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3]);
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3]);
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3]);
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r_0[1] = body1.frame_a.r_0[1];
//   body1.r_0[2] = body1.frame_a.r_0[2];
//   body1.r_0[3] = body1.frame_a.r_0[3];
//   if true then
//   body1.Q[1] = 0.0;
//   body1.Q[2] = 0.0;
//   body1.Q[3] = 0.0;
//   body1.Q[4] = 1.0;
//   body1.phi[1] = 0.0;
//   body1.phi[2] = 0.0;
//   body1.phi[3] = 0.0;
//   body1.phi_d[1] = 0.0;
//   body1.phi_d[2] = 0.0;
//   body1.phi_d[3] = 0.0;
//   body1.phi_dd[1] = 0.0;
//   body1.phi_dd[2] = 0.0;
//   body1.phi_dd[3] = 0.0;
//   elseif body1.useQuaternions then
//   body1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]},{der(body1.Q[1]),der(body1.Q[2]),der(body1.Q[3]),der(body1.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]});
//   body1.phi[1] = 0.0;
//   body1.phi[2] = 0.0;
//   body1.phi[3] = 0.0;
//   body1.phi_d[1] = 0.0;
//   body1.phi_d[2] = 0.0;
//   body1.phi_d[3] = 0.0;
//   body1.phi_dd[1] = 0.0;
//   body1.phi_dd[2] = 0.0;
//   body1.phi_dd[3] = 0.0;
//   else
//   body1.phi_d[1] = der(body1.phi[1]);
//   body1.phi_d[2] = der(body1.phi[2]);
//   body1.phi_d[3] = der(body1.phi[3]);
//   body1.phi_dd[1] = der(body1.phi_d[1]);
//   body1.phi_dd[2] = der(body1.phi_d[2]);
//   body1.phi_dd[3] = der(body1.phi_d[3]);
//   body1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},{body1.phi[1],body1.phi[2],body1.phi[3]},{body1.phi_d[1],body1.phi_d[2],body1.phi_d[3]});
//   body1.Q[1] = 0.0;
//   body1.Q[2] = 0.0;
//   body1.Q[3] = 0.0;
//   body1.Q[4] = 1.0;
//   end if;
//   body1.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({body1.frame_a.r_0[1],body1.frame_a.r_0[2],body1.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body1.frame_a.R,{body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   body1.v_0[1] = der(body1.frame_a.r_0[1]);
//   body1.v_0[2] = der(body1.frame_a.r_0[2]);
//   body1.v_0[3] = der(body1.frame_a.r_0[3]);
//   body1.a_0[1] = der(body1.v_0[1]);
//   body1.a_0[2] = der(body1.v_0[2]);
//   body1.a_0[3] = der(body1.v_0[3]);
//   body1.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body1.frame_a.R);
//   body1.z_a[1] = der(body1.w_a[1]);
//   body1.z_a[2] = der(body1.w_a[2]);
//   body1.z_a[3] = der(body1.w_a[3]);
//   body1.frame_a.f = body1.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(body1.frame_a.R,{body1.a_0[1] - body1.g_0[1],body1.a_0[2] - body1.g_0[2],body1.a_0[3] - body1.g_0[3]}) + {body1.z_a[2] * body1.r_CM[3] - body1.z_a[3] * body1.r_CM[2],body1.z_a[3] * body1.r_CM[1] - body1.z_a[1] * body1.r_CM[3],body1.z_a[1] * body1.r_CM[2] - body1.z_a[2] * body1.r_CM[1]} + {body1.w_a[2] * (body1.w_a[1] * body1.r_CM[2] - body1.w_a[2] * body1.r_CM[1]) - body1.w_a[3] * (body1.w_a[3] * body1.r_CM[1] - body1.w_a[1] * body1.r_CM[3]),body1.w_a[3] * (body1.w_a[2] * body1.r_CM[3] - body1.w_a[3] * body1.r_CM[2]) - body1.w_a[1] * (body1.w_a[1] * body1.r_CM[2] - body1.w_a[2] * body1.r_CM[1]),body1.w_a[1] * (body1.w_a[3] * body1.r_CM[1] - body1.w_a[1] * body1.r_CM[3]) - body1.w_a[2] * (body1.w_a[2] * body1.r_CM[3] - body1.w_a[3] * body1.r_CM[2])});
//   body1.frame_a.t[1] = body1.I[1,1] * body1.z_a[1] + (body1.I[1,2] * body1.z_a[2] + (body1.I[1,3] * body1.z_a[3] + (body1.w_a[2] * (body1.I[3,1] * body1.w_a[1] + (body1.I[3,2] * body1.w_a[2] + body1.I[3,3] * body1.w_a[3])) + ((-body1.w_a[3] * (body1.I[2,1] * body1.w_a[1] + (body1.I[2,2] * body1.w_a[2] + body1.I[2,3] * body1.w_a[3]))) + (body1.r_CM[2] * body1.frame_a.f[3] + (-body1.r_CM[3] * body1.frame_a.f[2]))))));
//   body1.frame_a.t[2] = body1.I[2,1] * body1.z_a[1] + (body1.I[2,2] * body1.z_a[2] + (body1.I[2,3] * body1.z_a[3] + (body1.w_a[3] * (body1.I[1,1] * body1.w_a[1] + (body1.I[1,2] * body1.w_a[2] + body1.I[1,3] * body1.w_a[3])) + ((-body1.w_a[1] * (body1.I[3,1] * body1.w_a[1] + (body1.I[3,2] * body1.w_a[2] + body1.I[3,3] * body1.w_a[3]))) + (body1.r_CM[3] * body1.frame_a.f[1] + (-body1.r_CM[1] * body1.frame_a.f[3]))))));
//   body1.frame_a.t[3] = body1.I[3,1] * body1.z_a[1] + (body1.I[3,2] * body1.z_a[2] + (body1.I[3,3] * body1.z_a[3] + (body1.w_a[1] * (body1.I[2,1] * body1.w_a[1] + (body1.I[2,2] * body1.w_a[2] + body1.I[2,3] * body1.w_a[3])) + ((-body1.w_a[2] * (body1.I[1,1] * body1.w_a[1] + (body1.I[1,2] * body1.w_a[2] + body1.I[1,3] * body1.w_a[3]))) + (body1.r_CM[1] * body1.frame_a.f[2] + (-body1.r_CM[2] * body1.frame_a.f[1]))))));
//   body2.cylinder.R.T[1,1] = body2.frame_a.R.T[1,1];
//   body2.cylinder.R.T[1,2] = body2.frame_a.R.T[1,2];
//   body2.cylinder.R.T[1,3] = body2.frame_a.R.T[1,3];
//   body2.cylinder.R.T[2,1] = body2.frame_a.R.T[2,1];
//   body2.cylinder.R.T[2,2] = body2.frame_a.R.T[2,2];
//   body2.cylinder.R.T[2,3] = body2.frame_a.R.T[2,3];
//   body2.cylinder.R.T[3,1] = body2.frame_a.R.T[3,1];
//   body2.cylinder.R.T[3,2] = body2.frame_a.R.T[3,2];
//   body2.cylinder.R.T[3,3] = body2.frame_a.R.T[3,3];
//   body2.cylinder.R.w[1] = body2.frame_a.R.w[1];
//   body2.cylinder.R.w[2] = body2.frame_a.R.w[2];
//   body2.cylinder.R.w[3] = body2.frame_a.R.w[3];
//   body2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.cylinder.shapeType);
//   body2.cylinder.rxvisobj[1] = body2.cylinder.R.T[1,1] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,1] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,1] * body2.cylinder.e_x[3]);
//   body2.cylinder.rxvisobj[2] = body2.cylinder.R.T[1,2] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,2] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,2] * body2.cylinder.e_x[3]);
//   body2.cylinder.rxvisobj[3] = body2.cylinder.R.T[1,3] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,3] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,3] * body2.cylinder.e_x[3]);
//   body2.cylinder.ryvisobj[1] = body2.cylinder.R.T[1,1] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,1] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,1] * body2.cylinder.e_y[3]);
//   body2.cylinder.ryvisobj[2] = body2.cylinder.R.T[1,2] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,2] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,2] * body2.cylinder.e_y[3]);
//   body2.cylinder.ryvisobj[3] = body2.cylinder.R.T[1,3] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,3] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,3] * body2.cylinder.e_y[3]);
//   body2.cylinder.rvisobj = body2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.cylinder.R.T[1,1],body2.cylinder.R.T[1,2],body2.cylinder.R.T[1,3]},{body2.cylinder.R.T[2,1],body2.cylinder.R.T[2,2],body2.cylinder.R.T[2,3]},{body2.cylinder.R.T[3,1],body2.cylinder.R.T[3,2],body2.cylinder.R.T[3,3]}},{body2.cylinder.r_shape[1],body2.cylinder.r_shape[2],body2.cylinder.r_shape[3]});
//   body2.cylinder.size[1] = body2.cylinder.length;
//   body2.cylinder.size[2] = body2.cylinder.width;
//   body2.cylinder.size[3] = body2.cylinder.height;
//   body2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.cylinder.color[1] / 255.0,body2.cylinder.color[2] / 255.0,body2.cylinder.color[3] / 255.0,body2.cylinder.specularCoefficient);
//   body2.cylinder.Extra = body2.cylinder.extra;
//   body2.sphere.R.T[1,1] = body2.frame_a.R.T[1,1];
//   body2.sphere.R.T[1,2] = body2.frame_a.R.T[1,2];
//   body2.sphere.R.T[1,3] = body2.frame_a.R.T[1,3];
//   body2.sphere.R.T[2,1] = body2.frame_a.R.T[2,1];
//   body2.sphere.R.T[2,2] = body2.frame_a.R.T[2,2];
//   body2.sphere.R.T[2,3] = body2.frame_a.R.T[2,3];
//   body2.sphere.R.T[3,1] = body2.frame_a.R.T[3,1];
//   body2.sphere.R.T[3,2] = body2.frame_a.R.T[3,2];
//   body2.sphere.R.T[3,3] = body2.frame_a.R.T[3,3];
//   body2.sphere.R.w[1] = body2.frame_a.R.w[1];
//   body2.sphere.R.w[2] = body2.frame_a.R.w[2];
//   body2.sphere.R.w[3] = body2.frame_a.R.w[3];
//   body2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.sphere.shapeType);
//   body2.sphere.rxvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,1] * body2.sphere.e_x[2] + body2.sphere.R.T[3,1] * body2.sphere.e_x[3]);
//   body2.sphere.rxvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,2] * body2.sphere.e_x[2] + body2.sphere.R.T[3,2] * body2.sphere.e_x[3]);
//   body2.sphere.rxvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,3] * body2.sphere.e_x[2] + body2.sphere.R.T[3,3] * body2.sphere.e_x[3]);
//   body2.sphere.ryvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,1] * body2.sphere.e_y[2] + body2.sphere.R.T[3,1] * body2.sphere.e_y[3]);
//   body2.sphere.ryvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,2] * body2.sphere.e_y[2] + body2.sphere.R.T[3,2] * body2.sphere.e_y[3]);
//   body2.sphere.ryvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,3] * body2.sphere.e_y[2] + body2.sphere.R.T[3,3] * body2.sphere.e_y[3]);
//   body2.sphere.rvisobj = body2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.sphere.R.T[1,1],body2.sphere.R.T[1,2],body2.sphere.R.T[1,3]},{body2.sphere.R.T[2,1],body2.sphere.R.T[2,2],body2.sphere.R.T[2,3]},{body2.sphere.R.T[3,1],body2.sphere.R.T[3,2],body2.sphere.R.T[3,3]}},{body2.sphere.r_shape[1],body2.sphere.r_shape[2],body2.sphere.r_shape[3]});
//   body2.sphere.size[1] = body2.sphere.length;
//   body2.sphere.size[2] = body2.sphere.width;
//   body2.sphere.size[3] = body2.sphere.height;
//   body2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.sphere.color[1] / 255.0,body2.sphere.color[2] / 255.0,body2.sphere.color[3] / 255.0,body2.sphere.specularCoefficient);
//   body2.sphere.Extra = body2.sphere.extra;
//   body2.r_0[1] = body2.frame_a.r_0[1];
//   body2.r_0[2] = body2.frame_a.r_0[2];
//   body2.r_0[3] = body2.frame_a.r_0[3];
//   if true then
//   body2.Q[1] = 0.0;
//   body2.Q[2] = 0.0;
//   body2.Q[3] = 0.0;
//   body2.Q[4] = 1.0;
//   body2.phi[1] = 0.0;
//   body2.phi[2] = 0.0;
//   body2.phi[3] = 0.0;
//   body2.phi_d[1] = 0.0;
//   body2.phi_d[2] = 0.0;
//   body2.phi_d[3] = 0.0;
//   body2.phi_dd[1] = 0.0;
//   body2.phi_dd[2] = 0.0;
//   body2.phi_dd[3] = 0.0;
//   elseif body2.useQuaternions then
//   body2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]},{der(body2.Q[1]),der(body2.Q[2]),der(body2.Q[3]),der(body2.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]});
//   body2.phi[1] = 0.0;
//   body2.phi[2] = 0.0;
//   body2.phi[3] = 0.0;
//   body2.phi_d[1] = 0.0;
//   body2.phi_d[2] = 0.0;
//   body2.phi_d[3] = 0.0;
//   body2.phi_dd[1] = 0.0;
//   body2.phi_dd[2] = 0.0;
//   body2.phi_dd[3] = 0.0;
//   else
//   body2.phi_d[1] = der(body2.phi[1]);
//   body2.phi_d[2] = der(body2.phi[2]);
//   body2.phi_d[3] = der(body2.phi[3]);
//   body2.phi_dd[1] = der(body2.phi_d[1]);
//   body2.phi_dd[2] = der(body2.phi_d[2]);
//   body2.phi_dd[3] = der(body2.phi_d[3]);
//   body2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},{body2.phi[1],body2.phi[2],body2.phi[3]},{body2.phi_d[1],body2.phi_d[2],body2.phi_d[3]});
//   body2.Q[1] = 0.0;
//   body2.Q[2] = 0.0;
//   body2.Q[3] = 0.0;
//   body2.Q[4] = 1.0;
//   end if;
//   body2.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({body2.frame_a.r_0[1],body2.frame_a.r_0[2],body2.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body2.frame_a.R,{body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   body2.v_0[1] = der(body2.frame_a.r_0[1]);
//   body2.v_0[2] = der(body2.frame_a.r_0[2]);
//   body2.v_0[3] = der(body2.frame_a.r_0[3]);
//   body2.a_0[1] = der(body2.v_0[1]);
//   body2.a_0[2] = der(body2.v_0[2]);
//   body2.a_0[3] = der(body2.v_0[3]);
//   body2.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body2.frame_a.R);
//   body2.z_a[1] = der(body2.w_a[1]);
//   body2.z_a[2] = der(body2.w_a[2]);
//   body2.z_a[3] = der(body2.w_a[3]);
//   body2.frame_a.f = body2.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(body2.frame_a.R,{body2.a_0[1] - body2.g_0[1],body2.a_0[2] - body2.g_0[2],body2.a_0[3] - body2.g_0[3]}) + {body2.z_a[2] * body2.r_CM[3] - body2.z_a[3] * body2.r_CM[2],body2.z_a[3] * body2.r_CM[1] - body2.z_a[1] * body2.r_CM[3],body2.z_a[1] * body2.r_CM[2] - body2.z_a[2] * body2.r_CM[1]} + {body2.w_a[2] * (body2.w_a[1] * body2.r_CM[2] - body2.w_a[2] * body2.r_CM[1]) - body2.w_a[3] * (body2.w_a[3] * body2.r_CM[1] - body2.w_a[1] * body2.r_CM[3]),body2.w_a[3] * (body2.w_a[2] * body2.r_CM[3] - body2.w_a[3] * body2.r_CM[2]) - body2.w_a[1] * (body2.w_a[1] * body2.r_CM[2] - body2.w_a[2] * body2.r_CM[1]),body2.w_a[1] * (body2.w_a[3] * body2.r_CM[1] - body2.w_a[1] * body2.r_CM[3]) - body2.w_a[2] * (body2.w_a[2] * body2.r_CM[3] - body2.w_a[3] * body2.r_CM[2])});
//   body2.frame_a.t[1] = body2.I[1,1] * body2.z_a[1] + (body2.I[1,2] * body2.z_a[2] + (body2.I[1,3] * body2.z_a[3] + (body2.w_a[2] * (body2.I[3,1] * body2.w_a[1] + (body2.I[3,2] * body2.w_a[2] + body2.I[3,3] * body2.w_a[3])) + ((-body2.w_a[3] * (body2.I[2,1] * body2.w_a[1] + (body2.I[2,2] * body2.w_a[2] + body2.I[2,3] * body2.w_a[3]))) + (body2.r_CM[2] * body2.frame_a.f[3] + (-body2.r_CM[3] * body2.frame_a.f[2]))))));
//   body2.frame_a.t[2] = body2.I[2,1] * body2.z_a[1] + (body2.I[2,2] * body2.z_a[2] + (body2.I[2,3] * body2.z_a[3] + (body2.w_a[3] * (body2.I[1,1] * body2.w_a[1] + (body2.I[1,2] * body2.w_a[2] + body2.I[1,3] * body2.w_a[3])) + ((-body2.w_a[1] * (body2.I[3,1] * body2.w_a[1] + (body2.I[3,2] * body2.w_a[2] + body2.I[3,3] * body2.w_a[3]))) + (body2.r_CM[3] * body2.frame_a.f[1] + (-body2.r_CM[1] * body2.frame_a.f[3]))))));
//   body2.frame_a.t[3] = body2.I[3,1] * body2.z_a[1] + (body2.I[3,2] * body2.z_a[2] + (body2.I[3,3] * body2.z_a[3] + (body2.w_a[1] * (body2.I[2,1] * body2.w_a[1] + (body2.I[2,2] * body2.w_a[2] + body2.I[2,3] * body2.w_a[3])) + ((-body2.w_a[2] * (body2.I[1,1] * body2.w_a[1] + (body2.I[1,2] * body2.w_a[2] + body2.I[1,3] * body2.w_a[3]))) + (body2.r_CM[1] * body2.frame_a.f[2] + (-body2.r_CM[2] * body2.frame_a.f[1]))))));
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   rod2.frame_b.r_0 = rod2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod2.frame_a.R,{rod2.r[1],rod2.r[2],rod2.r[3]});
//   rod2.frame_b.R.T[1,1] = rod2.frame_a.R.T[1,1];
//   rod2.frame_b.R.T[1,2] = rod2.frame_a.R.T[1,2];
//   rod2.frame_b.R.T[1,3] = rod2.frame_a.R.T[1,3];
//   rod2.frame_b.R.T[2,1] = rod2.frame_a.R.T[2,1];
//   rod2.frame_b.R.T[2,2] = rod2.frame_a.R.T[2,2];
//   rod2.frame_b.R.T[2,3] = rod2.frame_a.R.T[2,3];
//   rod2.frame_b.R.T[3,1] = rod2.frame_a.R.T[3,1];
//   rod2.frame_b.R.T[3,2] = rod2.frame_a.R.T[3,2];
//   rod2.frame_b.R.T[3,3] = rod2.frame_a.R.T[3,3];
//   rod2.frame_b.R.w[1] = rod2.frame_a.R.w[1];
//   rod2.frame_b.R.w[2] = rod2.frame_a.R.w[2];
//   rod2.frame_b.R.w[3] = rod2.frame_a.R.w[3];
//   0.0 = rod2.frame_a.f[1] + rod2.frame_b.f[1];
//   0.0 = rod2.frame_a.f[2] + rod2.frame_b.f[2];
//   0.0 = rod2.frame_a.f[3] + rod2.frame_b.f[3];
//   0.0 = rod2.frame_a.t[1] + (rod2.frame_b.t[1] + (rod2.r[2] * rod2.frame_b.f[3] + (-rod2.r[3] * rod2.frame_b.f[2])));
//   0.0 = rod2.frame_a.t[2] + (rod2.frame_b.t[2] + (rod2.r[3] * rod2.frame_b.f[1] + (-rod2.r[1] * rod2.frame_b.f[3])));
//   0.0 = rod2.frame_a.t[3] + (rod2.frame_b.t[3] + (rod2.r[1] * rod2.frame_b.f[2] + (-rod2.r[2] * rod2.frame_b.f[1])));
//   damper1.f = damper1.d * damper1.v_rel;
//   damper1.s_rel = damper1.flange_b.s - damper1.flange_a.s;
//   damper1.v_rel = der(damper1.s_rel);
//   damper1.flange_b.f = damper1.f;
//   damper1.flange_a.f = -damper1.f;
//   revolute2.cylinder.R.T[1,1] = revolute2.frame_a.R.T[1,1];
//   revolute2.cylinder.R.T[1,2] = revolute2.frame_a.R.T[1,2];
//   revolute2.cylinder.R.T[1,3] = revolute2.frame_a.R.T[1,3];
//   revolute2.cylinder.R.T[2,1] = revolute2.frame_a.R.T[2,1];
//   revolute2.cylinder.R.T[2,2] = revolute2.frame_a.R.T[2,2];
//   revolute2.cylinder.R.T[2,3] = revolute2.frame_a.R.T[2,3];
//   revolute2.cylinder.R.T[3,1] = revolute2.frame_a.R.T[3,1];
//   revolute2.cylinder.R.T[3,2] = revolute2.frame_a.R.T[3,2];
//   revolute2.cylinder.R.T[3,3] = revolute2.frame_a.R.T[3,3];
//   revolute2.cylinder.R.w[1] = revolute2.frame_a.R.w[1];
//   revolute2.cylinder.R.w[2] = revolute2.frame_a.R.w[2];
//   revolute2.cylinder.R.w[3] = revolute2.frame_a.R.w[3];
//   revolute2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(revolute2.cylinder.shapeType);
//   revolute2.cylinder.rxvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_x[1] + (revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_x[3]);
//   revolute2.cylinder.rxvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_x[1] + (revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_x[3]);
//   revolute2.cylinder.rxvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_x[1] + (revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_x[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_x[3]);
//   revolute2.cylinder.ryvisobj[1] = revolute2.cylinder.R.T[1,1] * revolute2.cylinder.e_y[1] + (revolute2.cylinder.R.T[2,1] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,1] * revolute2.cylinder.e_y[3]);
//   revolute2.cylinder.ryvisobj[2] = revolute2.cylinder.R.T[1,2] * revolute2.cylinder.e_y[1] + (revolute2.cylinder.R.T[2,2] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,2] * revolute2.cylinder.e_y[3]);
//   revolute2.cylinder.ryvisobj[3] = revolute2.cylinder.R.T[1,3] * revolute2.cylinder.e_y[1] + (revolute2.cylinder.R.T[2,3] * revolute2.cylinder.e_y[2] + revolute2.cylinder.R.T[3,3] * revolute2.cylinder.e_y[3]);
//   revolute2.cylinder.rvisobj = revolute2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{revolute2.cylinder.R.T[1,1],revolute2.cylinder.R.T[1,2],revolute2.cylinder.R.T[1,3]},{revolute2.cylinder.R.T[2,1],revolute2.cylinder.R.T[2,2],revolute2.cylinder.R.T[2,3]},{revolute2.cylinder.R.T[3,1],revolute2.cylinder.R.T[3,2],revolute2.cylinder.R.T[3,3]}},{revolute2.cylinder.r_shape[1],revolute2.cylinder.r_shape[2],revolute2.cylinder.r_shape[3]});
//   revolute2.cylinder.size[1] = revolute2.cylinder.length;
//   revolute2.cylinder.size[2] = revolute2.cylinder.width;
//   revolute2.cylinder.size[3] = revolute2.cylinder.height;
//   revolute2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(revolute2.cylinder.color[1] / 255.0,revolute2.cylinder.color[2] / 255.0,revolute2.cylinder.color[3] / 255.0,revolute2.cylinder.specularCoefficient);
//   revolute2.cylinder.Extra = revolute2.cylinder.extra;
//   revolute2.fixed.flange.phi = revolute2.fixed.phi0;
//   revolute2.internalAxis.flange.tau = revolute2.internalAxis.tau;
//   revolute2.internalAxis.flange.phi = revolute2.internalAxis.phi;
//   revolute2.constantTorque.tau = -revolute2.constantTorque.flange.tau;
//   revolute2.constantTorque.tau = revolute2.constantTorque.tau_constant;
//   revolute2.constantTorque.phi = revolute2.constantTorque.flange.phi - revolute2.constantTorque.phi_support;
//   revolute2.constantTorque.phi_support = 0.0;
//   assert(true,"Connector frame_a of revolute joint is not connected");
//   assert(true,"Connector frame_b of revolute joint is not connected");
//   revolute2.angle = revolute2.phi;
//   revolute2.w = der(revolute2.phi);
//   revolute2.a = der(revolute2.w);
//   revolute2.frame_b.r_0[1] = revolute2.frame_a.r_0[1];
//   revolute2.frame_b.r_0[2] = revolute2.frame_a.r_0[2];
//   revolute2.frame_b.r_0[3] = revolute2.frame_a.r_0[3];
//   revolute2.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({revolute2.e[1],revolute2.e[2],revolute2.e[3]},revolute2.phi,revolute2.w);
//   revolute2.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(revolute2.frame_a.R,revolute2.R_rel);
//   revolute2.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel,{revolute2.frame_b.f[1],revolute2.frame_b.f[2],revolute2.frame_b.f[3]});
//   revolute2.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(revolute2.R_rel,{revolute2.frame_b.t[1],revolute2.frame_b.t[2],revolute2.frame_b.t[3]});
//   revolute2.tau = (-revolute2.frame_b.t[1]) * revolute2.e[1] + ((-revolute2.frame_b.t[2]) * revolute2.e[2] + (-revolute2.frame_b.t[3]) * revolute2.e[3]);
//   revolute2.phi = revolute2.internalAxis.phi;
//   revolute2.constantTorque.flange.tau + revolute2.internalAxis.flange.tau = 0.0;
//   revolute2.constantTorque.flange.phi = revolute2.internalAxis.flange.phi;
//   revolute2.fixed.flange.tau = 0.0;
//   bodyBox2.body.r_0[1] = bodyBox2.body.frame_a.r_0[1];
//   bodyBox2.body.r_0[2] = bodyBox2.body.frame_a.r_0[2];
//   bodyBox2.body.r_0[3] = bodyBox2.body.frame_a.r_0[3];
//   if true then
//   bodyBox2.body.Q[1] = 0.0;
//   bodyBox2.body.Q[2] = 0.0;
//   bodyBox2.body.Q[3] = 0.0;
//   bodyBox2.body.Q[4] = 1.0;
//   bodyBox2.body.phi[1] = 0.0;
//   bodyBox2.body.phi[2] = 0.0;
//   bodyBox2.body.phi[3] = 0.0;
//   bodyBox2.body.phi_d[1] = 0.0;
//   bodyBox2.body.phi_d[2] = 0.0;
//   bodyBox2.body.phi_d[3] = 0.0;
//   bodyBox2.body.phi_dd[1] = 0.0;
//   bodyBox2.body.phi_dd[2] = 0.0;
//   bodyBox2.body.phi_dd[3] = 0.0;
//   elseif bodyBox2.body.useQuaternions then
//   bodyBox2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({bodyBox2.body.Q[1],bodyBox2.body.Q[2],bodyBox2.body.Q[3],bodyBox2.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({bodyBox2.body.Q[1],bodyBox2.body.Q[2],bodyBox2.body.Q[3],bodyBox2.body.Q[4]},{der(bodyBox2.body.Q[1]),der(bodyBox2.body.Q[2]),der(bodyBox2.body.Q[3]),der(bodyBox2.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({bodyBox2.body.Q[1],bodyBox2.body.Q[2],bodyBox2.body.Q[3],bodyBox2.body.Q[4]});
//   bodyBox2.body.phi[1] = 0.0;
//   bodyBox2.body.phi[2] = 0.0;
//   bodyBox2.body.phi[3] = 0.0;
//   bodyBox2.body.phi_d[1] = 0.0;
//   bodyBox2.body.phi_d[2] = 0.0;
//   bodyBox2.body.phi_d[3] = 0.0;
//   bodyBox2.body.phi_dd[1] = 0.0;
//   bodyBox2.body.phi_dd[2] = 0.0;
//   bodyBox2.body.phi_dd[3] = 0.0;
//   else
//   bodyBox2.body.phi_d[1] = der(bodyBox2.body.phi[1]);
//   bodyBox2.body.phi_d[2] = der(bodyBox2.body.phi[2]);
//   bodyBox2.body.phi_d[3] = der(bodyBox2.body.phi[3]);
//   bodyBox2.body.phi_dd[1] = der(bodyBox2.body.phi_d[1]);
//   bodyBox2.body.phi_dd[2] = der(bodyBox2.body.phi_d[2]);
//   bodyBox2.body.phi_dd[3] = der(bodyBox2.body.phi_d[3]);
//   bodyBox2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({bodyBox2.body.sequence_angleStates[1],bodyBox2.body.sequence_angleStates[2],bodyBox2.body.sequence_angleStates[3]},{bodyBox2.body.phi[1],bodyBox2.body.phi[2],bodyBox2.body.phi[3]},{bodyBox2.body.phi_d[1],bodyBox2.body.phi_d[2],bodyBox2.body.phi_d[3]});
//   bodyBox2.body.Q[1] = 0.0;
//   bodyBox2.body.Q[2] = 0.0;
//   bodyBox2.body.Q[3] = 0.0;
//   bodyBox2.body.Q[4] = 1.0;
//   end if;
//   bodyBox2.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world.gravityAcceleration({bodyBox2.body.frame_a.r_0[1],bodyBox2.body.frame_a.r_0[2],bodyBox2.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(bodyBox2.body.frame_a.R,{bodyBox2.body.r_CM[1],bodyBox2.body.r_CM[2],bodyBox2.body.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   bodyBox2.body.v_0[1] = der(bodyBox2.body.frame_a.r_0[1]);
//   bodyBox2.body.v_0[2] = der(bodyBox2.body.frame_a.r_0[2]);
//   bodyBox2.body.v_0[3] = der(bodyBox2.body.frame_a.r_0[3]);
//   bodyBox2.body.a_0[1] = der(bodyBox2.body.v_0[1]);
//   bodyBox2.body.a_0[2] = der(bodyBox2.body.v_0[2]);
//   bodyBox2.body.a_0[3] = der(bodyBox2.body.v_0[3]);
//   bodyBox2.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(bodyBox2.body.frame_a.R);
//   bodyBox2.body.z_a[1] = der(bodyBox2.body.w_a[1]);
//   bodyBox2.body.z_a[2] = der(bodyBox2.body.w_a[2]);
//   bodyBox2.body.z_a[3] = der(bodyBox2.body.w_a[3]);
//   bodyBox2.body.frame_a.f = bodyBox2.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(bodyBox2.body.frame_a.R,{bodyBox2.body.a_0[1] - bodyBox2.body.g_0[1],bodyBox2.body.a_0[2] - bodyBox2.body.g_0[2],bodyBox2.body.a_0[3] - bodyBox2.body.g_0[3]}) + {bodyBox2.body.z_a[2] * bodyBox2.body.r_CM[3] - bodyBox2.body.z_a[3] * bodyBox2.body.r_CM[2],bodyBox2.body.z_a[3] * bodyBox2.body.r_CM[1] - bodyBox2.body.z_a[1] * bodyBox2.body.r_CM[3],bodyBox2.body.z_a[1] * bodyBox2.body.r_CM[2] - bodyBox2.body.z_a[2] * bodyBox2.body.r_CM[1]} + {bodyBox2.body.w_a[2] * (bodyBox2.body.w_a[1] * bodyBox2.body.r_CM[2] - bodyBox2.body.w_a[2] * bodyBox2.body.r_CM[1]) - bodyBox2.body.w_a[3] * (bodyBox2.body.w_a[3] * bodyBox2.body.r_CM[1] - bodyBox2.body.w_a[1] * bodyBox2.body.r_CM[3]),bodyBox2.body.w_a[3] * (bodyBox2.body.w_a[2] * bodyBox2.body.r_CM[3] - bodyBox2.body.w_a[3] * bodyBox2.body.r_CM[2]) - bodyBox2.body.w_a[1] * (bodyBox2.body.w_a[1] * bodyBox2.body.r_CM[2] - bodyBox2.body.w_a[2] * bodyBox2.body.r_CM[1]),bodyBox2.body.w_a[1] * (bodyBox2.body.w_a[3] * bodyBox2.body.r_CM[1] - bodyBox2.body.w_a[1] * bodyBox2.body.r_CM[3]) - bodyBox2.body.w_a[2] * (bodyBox2.body.w_a[2] * bodyBox2.body.r_CM[3] - bodyBox2.body.w_a[3] * bodyBox2.body.r_CM[2])});
//   bodyBox2.body.frame_a.t[1] = bodyBox2.body.I[1,1] * bodyBox2.body.z_a[1] + (bodyBox2.body.I[1,2] * bodyBox2.body.z_a[2] + (bodyBox2.body.I[1,3] * bodyBox2.body.z_a[3] + (bodyBox2.body.w_a[2] * (bodyBox2.body.I[3,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[3,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[3,3] * bodyBox2.body.w_a[3])) + ((-bodyBox2.body.w_a[3] * (bodyBox2.body.I[2,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[2,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[2,3] * bodyBox2.body.w_a[3]))) + (bodyBox2.body.r_CM[2] * bodyBox2.body.frame_a.f[3] + (-bodyBox2.body.r_CM[3] * bodyBox2.body.frame_a.f[2]))))));
//   bodyBox2.body.frame_a.t[2] = bodyBox2.body.I[2,1] * bodyBox2.body.z_a[1] + (bodyBox2.body.I[2,2] * bodyBox2.body.z_a[2] + (bodyBox2.body.I[2,3] * bodyBox2.body.z_a[3] + (bodyBox2.body.w_a[3] * (bodyBox2.body.I[1,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[1,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[1,3] * bodyBox2.body.w_a[3])) + ((-bodyBox2.body.w_a[1] * (bodyBox2.body.I[3,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[3,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[3,3] * bodyBox2.body.w_a[3]))) + (bodyBox2.body.r_CM[3] * bodyBox2.body.frame_a.f[1] + (-bodyBox2.body.r_CM[1] * bodyBox2.body.frame_a.f[3]))))));
//   bodyBox2.body.frame_a.t[3] = bodyBox2.body.I[3,1] * bodyBox2.body.z_a[1] + (bodyBox2.body.I[3,2] * bodyBox2.body.z_a[2] + (bodyBox2.body.I[3,3] * bodyBox2.body.z_a[3] + (bodyBox2.body.w_a[1] * (bodyBox2.body.I[2,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[2,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[2,3] * bodyBox2.body.w_a[3])) + ((-bodyBox2.body.w_a[2] * (bodyBox2.body.I[1,1] * bodyBox2.body.w_a[1] + (bodyBox2.body.I[1,2] * bodyBox2.body.w_a[2] + bodyBox2.body.I[1,3] * bodyBox2.body.w_a[3]))) + (bodyBox2.body.r_CM[1] * bodyBox2.body.frame_a.f[2] + (-bodyBox2.body.r_CM[2] * bodyBox2.body.frame_a.f[1]))))));
//   bodyBox2.frameTranslation.shape.R.T[1,1] = bodyBox2.frameTranslation.frame_a.R.T[1,1];
//   bodyBox2.frameTranslation.shape.R.T[1,2] = bodyBox2.frameTranslation.frame_a.R.T[1,2];
//   bodyBox2.frameTranslation.shape.R.T[1,3] = bodyBox2.frameTranslation.frame_a.R.T[1,3];
//   bodyBox2.frameTranslation.shape.R.T[2,1] = bodyBox2.frameTranslation.frame_a.R.T[2,1];
//   bodyBox2.frameTranslation.shape.R.T[2,2] = bodyBox2.frameTranslation.frame_a.R.T[2,2];
//   bodyBox2.frameTranslation.shape.R.T[2,3] = bodyBox2.frameTranslation.frame_a.R.T[2,3];
//   bodyBox2.frameTranslation.shape.R.T[3,1] = bodyBox2.frameTranslation.frame_a.R.T[3,1];
//   bodyBox2.frameTranslation.shape.R.T[3,2] = bodyBox2.frameTranslation.frame_a.R.T[3,2];
//   bodyBox2.frameTranslation.shape.R.T[3,3] = bodyBox2.frameTranslation.frame_a.R.T[3,3];
//   bodyBox2.frameTranslation.shape.R.w[1] = bodyBox2.frameTranslation.frame_a.R.w[1];
//   bodyBox2.frameTranslation.shape.R.w[2] = bodyBox2.frameTranslation.frame_a.R.w[2];
//   bodyBox2.frameTranslation.shape.R.w[3] = bodyBox2.frameTranslation.frame_a.R.w[3];
//   bodyBox2.frameTranslation.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(bodyBox2.frameTranslation.shape.shapeType);
//   bodyBox2.frameTranslation.shape.rxvisobj[1] = bodyBox2.frameTranslation.shape.R.T[1,1] * bodyBox2.frameTranslation.shape.e_x[1] + (bodyBox2.frameTranslation.shape.R.T[2,1] * bodyBox2.frameTranslation.shape.e_x[2] + bodyBox2.frameTranslation.shape.R.T[3,1] * bodyBox2.frameTranslation.shape.e_x[3]);
//   bodyBox2.frameTranslation.shape.rxvisobj[2] = bodyBox2.frameTranslation.shape.R.T[1,2] * bodyBox2.frameTranslation.shape.e_x[1] + (bodyBox2.frameTranslation.shape.R.T[2,2] * bodyBox2.frameTranslation.shape.e_x[2] + bodyBox2.frameTranslation.shape.R.T[3,2] * bodyBox2.frameTranslation.shape.e_x[3]);
//   bodyBox2.frameTranslation.shape.rxvisobj[3] = bodyBox2.frameTranslation.shape.R.T[1,3] * bodyBox2.frameTranslation.shape.e_x[1] + (bodyBox2.frameTranslation.shape.R.T[2,3] * bodyBox2.frameTranslation.shape.e_x[2] + bodyBox2.frameTranslation.shape.R.T[3,3] * bodyBox2.frameTranslation.shape.e_x[3]);
//   bodyBox2.frameTranslation.shape.ryvisobj[1] = bodyBox2.frameTranslation.shape.R.T[1,1] * bodyBox2.frameTranslation.shape.e_y[1] + (bodyBox2.frameTranslation.shape.R.T[2,1] * bodyBox2.frameTranslation.shape.e_y[2] + bodyBox2.frameTranslation.shape.R.T[3,1] * bodyBox2.frameTranslation.shape.e_y[3]);
//   bodyBox2.frameTranslation.shape.ryvisobj[2] = bodyBox2.frameTranslation.shape.R.T[1,2] * bodyBox2.frameTranslation.shape.e_y[1] + (bodyBox2.frameTranslation.shape.R.T[2,2] * bodyBox2.frameTranslation.shape.e_y[2] + bodyBox2.frameTranslation.shape.R.T[3,2] * bodyBox2.frameTranslation.shape.e_y[3]);
//   bodyBox2.frameTranslation.shape.ryvisobj[3] = bodyBox2.frameTranslation.shape.R.T[1,3] * bodyBox2.frameTranslation.shape.e_y[1] + (bodyBox2.frameTranslation.shape.R.T[2,3] * bodyBox2.frameTranslation.shape.e_y[2] + bodyBox2.frameTranslation.shape.R.T[3,3] * bodyBox2.frameTranslation.shape.e_y[3]);
//   bodyBox2.frameTranslation.shape.rvisobj = bodyBox2.frameTranslation.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{bodyBox2.frameTranslation.shape.R.T[1,1],bodyBox2.frameTranslation.shape.R.T[1,2],bodyBox2.frameTranslation.shape.R.T[1,3]},{bodyBox2.frameTranslation.shape.R.T[2,1],bodyBox2.frameTranslation.shape.R.T[2,2],bodyBox2.frameTranslation.shape.R.T[2,3]},{bodyBox2.frameTranslation.shape.R.T[3,1],bodyBox2.frameTranslation.shape.R.T[3,2],bodyBox2.frameTranslation.shape.R.T[3,3]}},{bodyBox2.frameTranslation.shape.r_shape[1],bodyBox2.frameTranslation.shape.r_shape[2],bodyBox2.frameTranslation.shape.r_shape[3]});
//   bodyBox2.frameTranslation.shape.size[1] = bodyBox2.frameTranslation.shape.length;
//   bodyBox2.frameTranslation.shape.size[2] = bodyBox2.frameTranslation.shape.width;
//   bodyBox2.frameTranslation.shape.size[3] = bodyBox2.frameTranslation.shape.height;
//   bodyBox2.frameTranslation.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(bodyBox2.frameTranslation.shape.color[1] / 255.0,bodyBox2.frameTranslation.shape.color[2] / 255.0,bodyBox2.frameTranslation.shape.color[3] / 255.0,bodyBox2.frameTranslation.shape.specularCoefficient);
//   bodyBox2.frameTranslation.shape.Extra = bodyBox2.frameTranslation.shape.extra;
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   bodyBox2.frameTranslation.frame_b.r_0 = bodyBox2.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(bodyBox2.frameTranslation.frame_a.R,{bodyBox2.frameTranslation.r[1],bodyBox2.frameTranslation.r[2],bodyBox2.frameTranslation.r[3]});
//   bodyBox2.frameTranslation.frame_b.R.T[1,1] = bodyBox2.frameTranslation.frame_a.R.T[1,1];
//   bodyBox2.frameTranslation.frame_b.R.T[1,2] = bodyBox2.frameTranslation.frame_a.R.T[1,2];
//   bodyBox2.frameTranslation.frame_b.R.T[1,3] = bodyBox2.frameTranslation.frame_a.R.T[1,3];
//   bodyBox2.frameTranslation.frame_b.R.T[2,1] = bodyBox2.frameTranslation.frame_a.R.T[2,1];
//   bodyBox2.frameTranslation.frame_b.R.T[2,2] = bodyBox2.frameTranslation.frame_a.R.T[2,2];
//   bodyBox2.frameTranslation.frame_b.R.T[2,3] = bodyBox2.frameTranslation.frame_a.R.T[2,3];
//   bodyBox2.frameTranslation.frame_b.R.T[3,1] = bodyBox2.frameTranslation.frame_a.R.T[3,1];
//   bodyBox2.frameTranslation.frame_b.R.T[3,2] = bodyBox2.frameTranslation.frame_a.R.T[3,2];
//   bodyBox2.frameTranslation.frame_b.R.T[3,3] = bodyBox2.frameTranslation.frame_a.R.T[3,3];
//   bodyBox2.frameTranslation.frame_b.R.w[1] = bodyBox2.frameTranslation.frame_a.R.w[1];
//   bodyBox2.frameTranslation.frame_b.R.w[2] = bodyBox2.frameTranslation.frame_a.R.w[2];
//   bodyBox2.frameTranslation.frame_b.R.w[3] = bodyBox2.frameTranslation.frame_a.R.w[3];
//   0.0 = bodyBox2.frameTranslation.frame_a.f[1] + bodyBox2.frameTranslation.frame_b.f[1];
//   0.0 = bodyBox2.frameTranslation.frame_a.f[2] + bodyBox2.frameTranslation.frame_b.f[2];
//   0.0 = bodyBox2.frameTranslation.frame_a.f[3] + bodyBox2.frameTranslation.frame_b.f[3];
//   0.0 = bodyBox2.frameTranslation.frame_a.t[1] + (bodyBox2.frameTranslation.frame_b.t[1] + (bodyBox2.frameTranslation.r[2] * bodyBox2.frameTranslation.frame_b.f[3] + (-bodyBox2.frameTranslation.r[3] * bodyBox2.frameTranslation.frame_b.f[2])));
//   0.0 = bodyBox2.frameTranslation.frame_a.t[2] + (bodyBox2.frameTranslation.frame_b.t[2] + (bodyBox2.frameTranslation.r[3] * bodyBox2.frameTranslation.frame_b.f[1] + (-bodyBox2.frameTranslation.r[1] * bodyBox2.frameTranslation.frame_b.f[3])));
//   0.0 = bodyBox2.frameTranslation.frame_a.t[3] + (bodyBox2.frameTranslation.frame_b.t[3] + (bodyBox2.frameTranslation.r[1] * bodyBox2.frameTranslation.frame_b.f[2] + (-bodyBox2.frameTranslation.r[2] * bodyBox2.frameTranslation.frame_b.f[1])));
//   bodyBox2.r_0[1] = bodyBox2.frame_a.r_0[1];
//   bodyBox2.r_0[2] = bodyBox2.frame_a.r_0[2];
//   bodyBox2.r_0[3] = bodyBox2.frame_a.r_0[3];
//   bodyBox2.v_0[1] = der(bodyBox2.r_0[1]);
//   bodyBox2.v_0[2] = der(bodyBox2.r_0[2]);
//   bodyBox2.v_0[3] = der(bodyBox2.r_0[3]);
//   bodyBox2.a_0[1] = der(bodyBox2.v_0[1]);
//   bodyBox2.a_0[2] = der(bodyBox2.v_0[2]);
//   bodyBox2.a_0[3] = der(bodyBox2.v_0[3]);
//   assert(bodyBox2.innerWidth <= bodyBox2.width,"parameter innerWidth is greater as parameter width");
//   assert(bodyBox2.innerHeight <= bodyBox2.height,"parameter innerHeight is greater as paraemter height");
//   bodyBox2.frameTranslation.frame_a.t[1] + ((-bodyBox2.frame_a.t[1]) + bodyBox2.body.frame_a.t[1]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.t[2] + ((-bodyBox2.frame_a.t[2]) + bodyBox2.body.frame_a.t[2]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.t[3] + ((-bodyBox2.frame_a.t[3]) + bodyBox2.body.frame_a.t[3]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.f[1] + ((-bodyBox2.frame_a.f[1]) + bodyBox2.body.frame_a.f[1]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.f[2] + ((-bodyBox2.frame_a.f[2]) + bodyBox2.body.frame_a.f[2]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.f[3] + ((-bodyBox2.frame_a.f[3]) + bodyBox2.body.frame_a.f[3]) = 0.0;
//   bodyBox2.frameTranslation.frame_a.R.w[1] = bodyBox2.frame_a.R.w[1];
//   bodyBox2.frame_a.R.w[1] = bodyBox2.body.frame_a.R.w[1];
//   bodyBox2.frameTranslation.frame_a.R.w[2] = bodyBox2.frame_a.R.w[2];
//   bodyBox2.frame_a.R.w[2] = bodyBox2.body.frame_a.R.w[2];
//   bodyBox2.frameTranslation.frame_a.R.w[3] = bodyBox2.frame_a.R.w[3];
//   bodyBox2.frame_a.R.w[3] = bodyBox2.body.frame_a.R.w[3];
//   bodyBox2.frameTranslation.frame_a.R.T[1,1] = bodyBox2.frame_a.R.T[1,1];
//   bodyBox2.frame_a.R.T[1,1] = bodyBox2.body.frame_a.R.T[1,1];
//   bodyBox2.frameTranslation.frame_a.R.T[1,2] = bodyBox2.frame_a.R.T[1,2];
//   bodyBox2.frame_a.R.T[1,2] = bodyBox2.body.frame_a.R.T[1,2];
//   bodyBox2.frameTranslation.frame_a.R.T[1,3] = bodyBox2.frame_a.R.T[1,3];
//   bodyBox2.frame_a.R.T[1,3] = bodyBox2.body.frame_a.R.T[1,3];
//   bodyBox2.frameTranslation.frame_a.R.T[2,1] = bodyBox2.frame_a.R.T[2,1];
//   bodyBox2.frame_a.R.T[2,1] = bodyBox2.body.frame_a.R.T[2,1];
//   bodyBox2.frameTranslation.frame_a.R.T[2,2] = bodyBox2.frame_a.R.T[2,2];
//   bodyBox2.frame_a.R.T[2,2] = bodyBox2.body.frame_a.R.T[2,2];
//   bodyBox2.frameTranslation.frame_a.R.T[2,3] = bodyBox2.frame_a.R.T[2,3];
//   bodyBox2.frame_a.R.T[2,3] = bodyBox2.body.frame_a.R.T[2,3];
//   bodyBox2.frameTranslation.frame_a.R.T[3,1] = bodyBox2.frame_a.R.T[3,1];
//   bodyBox2.frame_a.R.T[3,1] = bodyBox2.body.frame_a.R.T[3,1];
//   bodyBox2.frameTranslation.frame_a.R.T[3,2] = bodyBox2.frame_a.R.T[3,2];
//   bodyBox2.frame_a.R.T[3,2] = bodyBox2.body.frame_a.R.T[3,2];
//   bodyBox2.frameTranslation.frame_a.R.T[3,3] = bodyBox2.frame_a.R.T[3,3];
//   bodyBox2.frame_a.R.T[3,3] = bodyBox2.body.frame_a.R.T[3,3];
//   bodyBox2.frameTranslation.frame_a.r_0[1] = bodyBox2.frame_a.r_0[1];
//   bodyBox2.frame_a.r_0[1] = bodyBox2.body.frame_a.r_0[1];
//   bodyBox2.frameTranslation.frame_a.r_0[2] = bodyBox2.frame_a.r_0[2];
//   bodyBox2.frame_a.r_0[2] = bodyBox2.body.frame_a.r_0[2];
//   bodyBox2.frameTranslation.frame_a.r_0[3] = bodyBox2.frame_a.r_0[3];
//   bodyBox2.frame_a.r_0[3] = bodyBox2.body.frame_a.r_0[3];
//   bodyBox2.frameTranslation.frame_b.t[1] + (-bodyBox2.frame_b.t[1]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.t[2] + (-bodyBox2.frame_b.t[2]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.t[3] + (-bodyBox2.frame_b.t[3]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.f[1] + (-bodyBox2.frame_b.f[1]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.f[2] + (-bodyBox2.frame_b.f[2]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.f[3] + (-bodyBox2.frame_b.f[3]) = 0.0;
//   bodyBox2.frameTranslation.frame_b.R.w[1] = bodyBox2.frame_b.R.w[1];
//   bodyBox2.frameTranslation.frame_b.R.w[2] = bodyBox2.frame_b.R.w[2];
//   bodyBox2.frameTranslation.frame_b.R.w[3] = bodyBox2.frame_b.R.w[3];
//   bodyBox2.frameTranslation.frame_b.R.T[1,1] = bodyBox2.frame_b.R.T[1,1];
//   bodyBox2.frameTranslation.frame_b.R.T[1,2] = bodyBox2.frame_b.R.T[1,2];
//   bodyBox2.frameTranslation.frame_b.R.T[1,3] = bodyBox2.frame_b.R.T[1,3];
//   bodyBox2.frameTranslation.frame_b.R.T[2,1] = bodyBox2.frame_b.R.T[2,1];
//   bodyBox2.frameTranslation.frame_b.R.T[2,2] = bodyBox2.frame_b.R.T[2,2];
//   bodyBox2.frameTranslation.frame_b.R.T[2,3] = bodyBox2.frame_b.R.T[2,3];
//   bodyBox2.frameTranslation.frame_b.R.T[3,1] = bodyBox2.frame_b.R.T[3,1];
//   bodyBox2.frameTranslation.frame_b.R.T[3,2] = bodyBox2.frame_b.R.T[3,2];
//   bodyBox2.frameTranslation.frame_b.R.T[3,3] = bodyBox2.frame_b.R.T[3,3];
//   bodyBox2.frameTranslation.frame_b.r_0[1] = bodyBox2.frame_b.r_0[1];
//   bodyBox2.frameTranslation.frame_b.r_0[2] = bodyBox2.frame_b.r_0[2];
//   bodyBox2.frameTranslation.frame_b.r_0[3] = bodyBox2.frame_b.r_0[3];
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   rod3.frame_b.r_0 = rod3.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod3.frame_a.R,{rod3.r[1],rod3.r[2],rod3.r[3]});
//   rod3.frame_b.R.T[1,1] = rod3.frame_a.R.T[1,1];
//   rod3.frame_b.R.T[1,2] = rod3.frame_a.R.T[1,2];
//   rod3.frame_b.R.T[1,3] = rod3.frame_a.R.T[1,3];
//   rod3.frame_b.R.T[2,1] = rod3.frame_a.R.T[2,1];
//   rod3.frame_b.R.T[2,2] = rod3.frame_a.R.T[2,2];
//   rod3.frame_b.R.T[2,3] = rod3.frame_a.R.T[2,3];
//   rod3.frame_b.R.T[3,1] = rod3.frame_a.R.T[3,1];
//   rod3.frame_b.R.T[3,2] = rod3.frame_a.R.T[3,2];
//   rod3.frame_b.R.T[3,3] = rod3.frame_a.R.T[3,3];
//   rod3.frame_b.R.w[1] = rod3.frame_a.R.w[1];
//   rod3.frame_b.R.w[2] = rod3.frame_a.R.w[2];
//   rod3.frame_b.R.w[3] = rod3.frame_a.R.w[3];
//   0.0 = rod3.frame_a.f[1] + rod3.frame_b.f[1];
//   0.0 = rod3.frame_a.f[2] + rod3.frame_b.f[2];
//   0.0 = rod3.frame_a.f[3] + rod3.frame_b.f[3];
//   0.0 = rod3.frame_a.t[1] + (rod3.frame_b.t[1] + (rod3.r[2] * rod3.frame_b.f[3] + (-rod3.r[3] * rod3.frame_b.f[2])));
//   0.0 = rod3.frame_a.t[2] + (rod3.frame_b.t[2] + (rod3.r[3] * rod3.frame_b.f[1] + (-rod3.r[1] * rod3.frame_b.f[3])));
//   0.0 = rod3.frame_a.t[3] + (rod3.frame_b.t[3] + (rod3.r[1] * rod3.frame_b.f[2] + (-rod3.r[2] * rod3.frame_b.f[1])));
//   assert(true,"Neither connector frame_a nor frame_b of FixedTranslation object is connected");
//   rod4.frame_b.r_0 = rod4.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod4.frame_a.R,{rod4.r[1],rod4.r[2],rod4.r[3]});
//   rod4.frame_b.R.T[1,1] = rod4.frame_a.R.T[1,1];
//   rod4.frame_b.R.T[1,2] = rod4.frame_a.R.T[1,2];
//   rod4.frame_b.R.T[1,3] = rod4.frame_a.R.T[1,3];
//   rod4.frame_b.R.T[2,1] = rod4.frame_a.R.T[2,1];
//   rod4.frame_b.R.T[2,2] = rod4.frame_a.R.T[2,2];
//   rod4.frame_b.R.T[2,3] = rod4.frame_a.R.T[2,3];
//   rod4.frame_b.R.T[3,1] = rod4.frame_a.R.T[3,1];
//   rod4.frame_b.R.T[3,2] = rod4.frame_a.R.T[3,2];
//   rod4.frame_b.R.T[3,3] = rod4.frame_a.R.T[3,3];
//   rod4.frame_b.R.w[1] = rod4.frame_a.R.w[1];
//   rod4.frame_b.R.w[2] = rod4.frame_a.R.w[2];
//   rod4.frame_b.R.w[3] = rod4.frame_a.R.w[3];
//   0.0 = rod4.frame_a.f[1] + rod4.frame_b.f[1];
//   0.0 = rod4.frame_a.f[2] + rod4.frame_b.f[2];
//   0.0 = rod4.frame_a.f[3] + rod4.frame_b.f[3];
//   0.0 = rod4.frame_a.t[1] + (rod4.frame_b.t[1] + (rod4.r[2] * rod4.frame_b.f[3] + (-rod4.r[3] * rod4.frame_b.f[2])));
//   0.0 = rod4.frame_a.t[2] + (rod4.frame_b.t[2] + (rod4.r[3] * rod4.frame_b.f[1] + (-rod4.r[1] * rod4.frame_b.f[3])));
//   0.0 = rod4.frame_a.t[3] + (rod4.frame_b.t[3] + (rod4.r[1] * rod4.frame_b.f[2] + (-rod4.r[2] * rod4.frame_b.f[1])));
//   damper2.f = damper2.d * damper2.v_rel;
//   damper2.s_rel = damper2.flange_b.s - damper2.flange_a.s;
//   damper2.v_rel = der(damper2.s_rel);
//   damper2.flange_b.f = damper2.f;
//   damper2.flange_a.f = -damper2.f;
//   lineForceWithTwoMasses.cylinder_a.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(lineForceWithTwoMasses.cylinder_a.shapeType);
//   lineForceWithTwoMasses.cylinder_a.rxvisobj[1] = lineForceWithTwoMasses.cylinder_a.R.T[1,1] * lineForceWithTwoMasses.cylinder_a.e_x[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,1] * lineForceWithTwoMasses.cylinder_a.e_x[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,1] * lineForceWithTwoMasses.cylinder_a.e_x[3]);
//   lineForceWithTwoMasses.cylinder_a.rxvisobj[2] = lineForceWithTwoMasses.cylinder_a.R.T[1,2] * lineForceWithTwoMasses.cylinder_a.e_x[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,2] * lineForceWithTwoMasses.cylinder_a.e_x[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,2] * lineForceWithTwoMasses.cylinder_a.e_x[3]);
//   lineForceWithTwoMasses.cylinder_a.rxvisobj[3] = lineForceWithTwoMasses.cylinder_a.R.T[1,3] * lineForceWithTwoMasses.cylinder_a.e_x[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,3] * lineForceWithTwoMasses.cylinder_a.e_x[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,3] * lineForceWithTwoMasses.cylinder_a.e_x[3]);
//   lineForceWithTwoMasses.cylinder_a.ryvisobj[1] = lineForceWithTwoMasses.cylinder_a.R.T[1,1] * lineForceWithTwoMasses.cylinder_a.e_y[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,1] * lineForceWithTwoMasses.cylinder_a.e_y[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,1] * lineForceWithTwoMasses.cylinder_a.e_y[3]);
//   lineForceWithTwoMasses.cylinder_a.ryvisobj[2] = lineForceWithTwoMasses.cylinder_a.R.T[1,2] * lineForceWithTwoMasses.cylinder_a.e_y[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,2] * lineForceWithTwoMasses.cylinder_a.e_y[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,2] * lineForceWithTwoMasses.cylinder_a.e_y[3]);
//   lineForceWithTwoMasses.cylinder_a.ryvisobj[3] = lineForceWithTwoMasses.cylinder_a.R.T[1,3] * lineForceWithTwoMasses.cylinder_a.e_y[1] + (lineForceWithTwoMasses.cylinder_a.R.T[2,3] * lineForceWithTwoMasses.cylinder_a.e_y[2] + lineForceWithTwoMasses.cylinder_a.R.T[3,3] * lineForceWithTwoMasses.cylinder_a.e_y[3]);
//   lineForceWithTwoMasses.cylinder_a.rvisobj = lineForceWithTwoMasses.cylinder_a.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{lineForceWithTwoMasses.cylinder_a.R.T[1,1],lineForceWithTwoMasses.cylinder_a.R.T[1,2],lineForceWithTwoMasses.cylinder_a.R.T[1,3]},{lineForceWithTwoMasses.cylinder_a.R.T[2,1],lineForceWithTwoMasses.cylinder_a.R.T[2,2],lineForceWithTwoMasses.cylinder_a.R.T[2,3]},{lineForceWithTwoMasses.cylinder_a.R.T[3,1],lineForceWithTwoMasses.cylinder_a.R.T[3,2],lineForceWithTwoMasses.cylinder_a.R.T[3,3]}},{lineForceWithTwoMasses.cylinder_a.r_shape[1],lineForceWithTwoMasses.cylinder_a.r_shape[2],lineForceWithTwoMasses.cylinder_a.r_shape[3]});
//   lineForceWithTwoMasses.cylinder_a.size[1] = lineForceWithTwoMasses.cylinder_a.length;
//   lineForceWithTwoMasses.cylinder_a.size[2] = lineForceWithTwoMasses.cylinder_a.width;
//   lineForceWithTwoMasses.cylinder_a.size[3] = lineForceWithTwoMasses.cylinder_a.height;
//   lineForceWithTwoMasses.cylinder_a.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(lineForceWithTwoMasses.cylinder_a.color[1] / 255.0,lineForceWithTwoMasses.cylinder_a.color[2] / 255.0,lineForceWithTwoMasses.cylinder_a.color[3] / 255.0,lineForceWithTwoMasses.cylinder_a.specularCoefficient);
//   lineForceWithTwoMasses.cylinder_a.Extra = lineForceWithTwoMasses.cylinder_a.extra;
//   lineForceWithTwoMasses.cylinder_b.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(lineForceWithTwoMasses.cylinder_b.shapeType);
//   lineForceWithTwoMasses.cylinder_b.rxvisobj[1] = lineForceWithTwoMasses.cylinder_b.R.T[1,1] * lineForceWithTwoMasses.cylinder_b.e_x[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,1] * lineForceWithTwoMasses.cylinder_b.e_x[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,1] * lineForceWithTwoMasses.cylinder_b.e_x[3]);
//   lineForceWithTwoMasses.cylinder_b.rxvisobj[2] = lineForceWithTwoMasses.cylinder_b.R.T[1,2] * lineForceWithTwoMasses.cylinder_b.e_x[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,2] * lineForceWithTwoMasses.cylinder_b.e_x[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,2] * lineForceWithTwoMasses.cylinder_b.e_x[3]);
//   lineForceWithTwoMasses.cylinder_b.rxvisobj[3] = lineForceWithTwoMasses.cylinder_b.R.T[1,3] * lineForceWithTwoMasses.cylinder_b.e_x[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,3] * lineForceWithTwoMasses.cylinder_b.e_x[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,3] * lineForceWithTwoMasses.cylinder_b.e_x[3]);
//   lineForceWithTwoMasses.cylinder_b.ryvisobj[1] = lineForceWithTwoMasses.cylinder_b.R.T[1,1] * lineForceWithTwoMasses.cylinder_b.e_y[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,1] * lineForceWithTwoMasses.cylinder_b.e_y[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,1] * lineForceWithTwoMasses.cylinder_b.e_y[3]);
//   lineForceWithTwoMasses.cylinder_b.ryvisobj[2] = lineForceWithTwoMasses.cylinder_b.R.T[1,2] * lineForceWithTwoMasses.cylinder_b.e_y[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,2] * lineForceWithTwoMasses.cylinder_b.e_y[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,2] * lineForceWithTwoMasses.cylinder_b.e_y[3]);
//   lineForceWithTwoMasses.cylinder_b.ryvisobj[3] = lineForceWithTwoMasses.cylinder_b.R.T[1,3] * lineForceWithTwoMasses.cylinder_b.e_y[1] + (lineForceWithTwoMasses.cylinder_b.R.T[2,3] * lineForceWithTwoMasses.cylinder_b.e_y[2] + lineForceWithTwoMasses.cylinder_b.R.T[3,3] * lineForceWithTwoMasses.cylinder_b.e_y[3]);
//   lineForceWithTwoMasses.cylinder_b.rvisobj = lineForceWithTwoMasses.cylinder_b.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{lineForceWithTwoMasses.cylinder_b.R.T[1,1],lineForceWithTwoMasses.cylinder_b.R.T[1,2],lineForceWithTwoMasses.cylinder_b.R.T[1,3]},{lineForceWithTwoMasses.cylinder_b.R.T[2,1],lineForceWithTwoMasses.cylinder_b.R.T[2,2],lineForceWithTwoMasses.cylinder_b.R.T[2,3]},{lineForceWithTwoMasses.cylinder_b.R.T[3,1],lineForceWithTwoMasses.cylinder_b.R.T[3,2],lineForceWithTwoMasses.cylinder_b.R.T[3,3]}},{lineForceWithTwoMasses.cylinder_b.r_shape[1],lineForceWithTwoMasses.cylinder_b.r_shape[2],lineForceWithTwoMasses.cylinder_b.r_shape[3]});
//   lineForceWithTwoMasses.cylinder_b.size[1] = lineForceWithTwoMasses.cylinder_b.length;
//   lineForceWithTwoMasses.cylinder_b.size[2] = lineForceWithTwoMasses.cylinder_b.width;
//   lineForceWithTwoMasses.cylinder_b.size[3] = lineForceWithTwoMasses.cylinder_b.height;
//   lineForceWithTwoMasses.cylinder_b.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(lineForceWithTwoMasses.cylinder_b.color[1] / 255.0,lineForceWithTwoMasses.cylinder_b.color[2] / 255.0,lineForceWithTwoMasses.cylinder_b.color[3] / 255.0,lineForceWithTwoMasses.cylinder_b.specularCoefficient);
//   lineForceWithTwoMasses.cylinder_b.Extra = lineForceWithTwoMasses.cylinder_b.extra;
//   lineForceWithTwoMasses.sphere_a.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(lineForceWithTwoMasses.sphere_a.shapeType);
//   lineForceWithTwoMasses.sphere_a.rxvisobj[1] = lineForceWithTwoMasses.sphere_a.R.T[1,1] * lineForceWithTwoMasses.sphere_a.e_x[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,1] * lineForceWithTwoMasses.sphere_a.e_x[2] + lineForceWithTwoMasses.sphere_a.R.T[3,1] * lineForceWithTwoMasses.sphere_a.e_x[3]);
//   lineForceWithTwoMasses.sphere_a.rxvisobj[2] = lineForceWithTwoMasses.sphere_a.R.T[1,2] * lineForceWithTwoMasses.sphere_a.e_x[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,2] * lineForceWithTwoMasses.sphere_a.e_x[2] + lineForceWithTwoMasses.sphere_a.R.T[3,2] * lineForceWithTwoMasses.sphere_a.e_x[3]);
//   lineForceWithTwoMasses.sphere_a.rxvisobj[3] = lineForceWithTwoMasses.sphere_a.R.T[1,3] * lineForceWithTwoMasses.sphere_a.e_x[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,3] * lineForceWithTwoMasses.sphere_a.e_x[2] + lineForceWithTwoMasses.sphere_a.R.T[3,3] * lineForceWithTwoMasses.sphere_a.e_x[3]);
//   lineForceWithTwoMasses.sphere_a.ryvisobj[1] = lineForceWithTwoMasses.sphere_a.R.T[1,1] * lineForceWithTwoMasses.sphere_a.e_y[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,1] * lineForceWithTwoMasses.sphere_a.e_y[2] + lineForceWithTwoMasses.sphere_a.R.T[3,1] * lineForceWithTwoMasses.sphere_a.e_y[3]);
//   lineForceWithTwoMasses.sphere_a.ryvisobj[2] = lineForceWithTwoMasses.sphere_a.R.T[1,2] * lineForceWithTwoMasses.sphere_a.e_y[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,2] * lineForceWithTwoMasses.sphere_a.e_y[2] + lineForceWithTwoMasses.sphere_a.R.T[3,2] * lineForceWithTwoMasses.sphere_a.e_y[3]);
//   lineForceWithTwoMasses.sphere_a.ryvisobj[3] = lineForceWithTwoMasses.sphere_a.R.T[1,3] * lineForceWithTwoMasses.sphere_a.e_y[1] + (lineForceWithTwoMasses.sphere_a.R.T[2,3] * lineForceWithTwoMasses.sphere_a.e_y[2] + lineForceWithTwoMasses.sphere_a.R.T[3,3] * lineForceWithTwoMasses.sphere_a.e_y[3]);
//   lineForceWithTwoMasses.sphere_a.rvisobj = lineForceWithTwoMasses.sphere_a.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{lineForceWithTwoMasses.sphere_a.R.T[1,1],lineForceWithTwoMasses.sphere_a.R.T[1,2],lineForceWithTwoMasses.sphere_a.R.T[1,3]},{lineForceWithTwoMasses.sphere_a.R.T[2,1],lineForceWithTwoMasses.sphere_a.R.T[2,2],lineForceWithTwoMasses.sphere_a.R.T[2,3]},{lineForceWithTwoMasses.sphere_a.R.T[3,1],lineForceWithTwoMasses.sphere_a.R.T[3,2],lineForceWithTwoMasses.sphere_a.R.T[3,3]}},{lineForceWithTwoMasses.sphere_a.r_shape[1],lineForceWithTwoMasses.sphere_a.r_shape[2],lineForceWithTwoMasses.sphere_a.r_shape[3]});
//   lineForceWithTwoMasses.sphere_a.size[1] = lineForceWithTwoMasses.sphere_a.length;
//   lineForceWithTwoMasses.sphere_a.size[2] = lineForceWithTwoMasses.sphere_a.width;
//   lineForceWithTwoMasses.sphere_a.size[3] = lineForceWithTwoMasses.sphere_a.height;
//   lineForceWithTwoMasses.sphere_a.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(lineForceWithTwoMasses.sphere_a.color[1] / 255.0,lineForceWithTwoMasses.sphere_a.color[2] / 255.0,lineForceWithTwoMasses.sphere_a.color[3] / 255.0,lineForceWithTwoMasses.sphere_a.specularCoefficient);
//   lineForceWithTwoMasses.sphere_a.Extra = lineForceWithTwoMasses.sphere_a.extra;
//   lineForceWithTwoMasses.sphere_b.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(lineForceWithTwoMasses.sphere_b.shapeType);
//   lineForceWithTwoMasses.sphere_b.rxvisobj[1] = lineForceWithTwoMasses.sphere_b.R.T[1,1] * lineForceWithTwoMasses.sphere_b.e_x[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,1] * lineForceWithTwoMasses.sphere_b.e_x[2] + lineForceWithTwoMasses.sphere_b.R.T[3,1] * lineForceWithTwoMasses.sphere_b.e_x[3]);
//   lineForceWithTwoMasses.sphere_b.rxvisobj[2] = lineForceWithTwoMasses.sphere_b.R.T[1,2] * lineForceWithTwoMasses.sphere_b.e_x[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,2] * lineForceWithTwoMasses.sphere_b.e_x[2] + lineForceWithTwoMasses.sphere_b.R.T[3,2] * lineForceWithTwoMasses.sphere_b.e_x[3]);
//   lineForceWithTwoMasses.sphere_b.rxvisobj[3] = lineForceWithTwoMasses.sphere_b.R.T[1,3] * lineForceWithTwoMasses.sphere_b.e_x[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,3] * lineForceWithTwoMasses.sphere_b.e_x[2] + lineForceWithTwoMasses.sphere_b.R.T[3,3] * lineForceWithTwoMasses.sphere_b.e_x[3]);
//   lineForceWithTwoMasses.sphere_b.ryvisobj[1] = lineForceWithTwoMasses.sphere_b.R.T[1,1] * lineForceWithTwoMasses.sphere_b.e_y[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,1] * lineForceWithTwoMasses.sphere_b.e_y[2] + lineForceWithTwoMasses.sphere_b.R.T[3,1] * lineForceWithTwoMasses.sphere_b.e_y[3]);
//   lineForceWithTwoMasses.sphere_b.ryvisobj[2] = lineForceWithTwoMasses.sphere_b.R.T[1,2] * lineForceWithTwoMasses.sphere_b.e_y[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,2] * lineForceWithTwoMasses.sphere_b.e_y[2] + lineForceWithTwoMasses.sphere_b.R.T[3,2] * lineForceWithTwoMasses.sphere_b.e_y[3]);
//   lineForceWithTwoMasses.sphere_b.ryvisobj[3] = lineForceWithTwoMasses.sphere_b.R.T[1,3] * lineForceWithTwoMasses.sphere_b.e_y[1] + (lineForceWithTwoMasses.sphere_b.R.T[2,3] * lineForceWithTwoMasses.sphere_b.e_y[2] + lineForceWithTwoMasses.sphere_b.R.T[3,3] * lineForceWithTwoMasses.sphere_b.e_y[3]);
//   lineForceWithTwoMasses.sphere_b.rvisobj = lineForceWithTwoMasses.sphere_b.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{lineForceWithTwoMasses.sphere_b.R.T[1,1],lineForceWithTwoMasses.sphere_b.R.T[1,2],lineForceWithTwoMasses.sphere_b.R.T[1,3]},{lineForceWithTwoMasses.sphere_b.R.T[2,1],lineForceWithTwoMasses.sphere_b.R.T[2,2],lineForceWithTwoMasses.sphere_b.R.T[2,3]},{lineForceWithTwoMasses.sphere_b.R.T[3,1],lineForceWithTwoMasses.sphere_b.R.T[3,2],lineForceWithTwoMasses.sphere_b.R.T[3,3]}},{lineForceWithTwoMasses.sphere_b.r_shape[1],lineForceWithTwoMasses.sphere_b.r_shape[2],lineForceWithTwoMasses.sphere_b.r_shape[3]});
//   lineForceWithTwoMasses.sphere_b.size[1] = lineForceWithTwoMasses.sphere_b.length;
//   lineForceWithTwoMasses.sphere_b.size[2] = lineForceWithTwoMasses.sphere_b.width;
//   lineForceWithTwoMasses.sphere_b.size[3] = lineForceWithTwoMasses.sphere_b.height;
//   lineForceWithTwoMasses.sphere_b.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(lineForceWithTwoMasses.sphere_b.color[1] / 255.0,lineForceWithTwoMasses.sphere_b.color[2] / 255.0,lineForceWithTwoMasses.sphere_b.color[3] / 255.0,lineForceWithTwoMasses.sphere_b.specularCoefficient);
//   lineForceWithTwoMasses.sphere_b.Extra = lineForceWithTwoMasses.sphere_b.extra;
//   assert(noEvent(lineForceWithTwoMasses.length > lineForceWithTwoMasses.s_small),"
// The distance between the origin of frame_a and the origin of frame_b
// of a LineForceWithTwoMasses component became smaller as parameter s_small
// (= a small number, defined in the \"Advanced\" menu). The distance is
// set to s_small, although it is smaller, to avoid a division by zero
// when computing the direction of the line force. Possible reasons
// for this situation:
// - At initial time the distance may already be zero: Change the initial
//   positions of the bodies connected by this element.
// - Hardware stops are not modeled or are modeled not stiff enough.
//   Include stops, e.g., stiff springs, or increase the stiffness
//   if already present.
// - Another error in your model may lead to unrealistically large forces
//   and torques that would in reality destroy the stops.
// - The flange_b connector might be defined by a pre-defined motion,
//   e.g., with Modelica.Mechanics.Translational.Position and the
//   predefined flange_b.s is zero or negative.
// ");
//   lineForceWithTwoMasses.r_rel_0[1] = lineForceWithTwoMasses.frame_b.r_0[1] - lineForceWithTwoMasses.frame_a.r_0[1];
//   lineForceWithTwoMasses.r_rel_0[2] = lineForceWithTwoMasses.frame_b.r_0[2] - lineForceWithTwoMasses.frame_a.r_0[2];
//   lineForceWithTwoMasses.r_rel_0[3] = lineForceWithTwoMasses.frame_b.r_0[3] - lineForceWithTwoMasses.frame_a.r_0[3];
//   lineForceWithTwoMasses.length = Modelica.Math.Vectors.length({lineForceWithTwoMasses.r_rel_0[1],lineForceWithTwoMasses.r_rel_0[2],lineForceWithTwoMasses.r_rel_0[3]});
//   lineForceWithTwoMasses.flange_a.s = 0.0;
//   lineForceWithTwoMasses.flange_b.s = lineForceWithTwoMasses.length;
//   lineForceWithTwoMasses.e_rel_0[1] = lineForceWithTwoMasses.r_rel_0[1] / Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(lineForceWithTwoMasses.length,lineForceWithTwoMasses.s_small);
//   lineForceWithTwoMasses.e_rel_0[2] = lineForceWithTwoMasses.r_rel_0[2] / Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(lineForceWithTwoMasses.length,lineForceWithTwoMasses.s_small);
//   lineForceWithTwoMasses.e_rel_0[3] = lineForceWithTwoMasses.r_rel_0[3] / Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(lineForceWithTwoMasses.length,lineForceWithTwoMasses.s_small);
//   lineForceWithTwoMasses.fa = lineForceWithTwoMasses.flange_a.f;
//   lineForceWithTwoMasses.fb = lineForceWithTwoMasses.flange_b.f;
//   lineForceWithTwoMasses.r_CM1_0[1] = lineForceWithTwoMasses.frame_a.r_0[1] + lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.e_rel_0[1];
//   lineForceWithTwoMasses.r_CM1_0[2] = lineForceWithTwoMasses.frame_a.r_0[2] + lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.e_rel_0[2];
//   lineForceWithTwoMasses.r_CM1_0[3] = lineForceWithTwoMasses.frame_a.r_0[3] + lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.e_rel_0[3];
//   lineForceWithTwoMasses.r_CM2_0[1] = lineForceWithTwoMasses.frame_b.r_0[1] - lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.e_rel_0[1];
//   lineForceWithTwoMasses.r_CM2_0[2] = lineForceWithTwoMasses.frame_b.r_0[2] - lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.e_rel_0[2];
//   lineForceWithTwoMasses.r_CM2_0[3] = lineForceWithTwoMasses.frame_b.r_0[3] - lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.e_rel_0[3];
//   lineForceWithTwoMasses.v_CM1_0[1] = der(lineForceWithTwoMasses.r_CM1_0[1]);
//   lineForceWithTwoMasses.v_CM1_0[2] = der(lineForceWithTwoMasses.r_CM1_0[2]);
//   lineForceWithTwoMasses.v_CM1_0[3] = der(lineForceWithTwoMasses.r_CM1_0[3]);
//   lineForceWithTwoMasses.v_CM2_0[1] = der(lineForceWithTwoMasses.r_CM2_0[1]);
//   lineForceWithTwoMasses.v_CM2_0[2] = der(lineForceWithTwoMasses.r_CM2_0[2]);
//   lineForceWithTwoMasses.v_CM2_0[3] = der(lineForceWithTwoMasses.r_CM2_0[3]);
//   lineForceWithTwoMasses.ag_CM1_0 = {der(lineForceWithTwoMasses.v_CM1_0[1]),der(lineForceWithTwoMasses.v_CM1_0[2]),der(lineForceWithTwoMasses.v_CM1_0[3])} - Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses.world.gravityAcceleration({lineForceWithTwoMasses.r_CM1_0[1],lineForceWithTwoMasses.r_CM1_0[2],lineForceWithTwoMasses.r_CM1_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   lineForceWithTwoMasses.ag_CM2_0 = {der(lineForceWithTwoMasses.v_CM2_0[1]),der(lineForceWithTwoMasses.v_CM2_0[2]),der(lineForceWithTwoMasses.v_CM2_0[3])} - Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses.world.gravityAcceleration({lineForceWithTwoMasses.r_CM2_0[1],lineForceWithTwoMasses.r_CM2_0[2],lineForceWithTwoMasses.r_CM2_0[3]},world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   lineForceWithTwoMasses.aux1_0[1] = lineForceWithTwoMasses.m_a * (lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.ag_CM1_0[1] / lineForceWithTwoMasses.length) - lineForceWithTwoMasses.m_b * (lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.ag_CM2_0[1] / lineForceWithTwoMasses.length);
//   lineForceWithTwoMasses.aux1_0[2] = lineForceWithTwoMasses.m_a * (lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.ag_CM1_0[2] / lineForceWithTwoMasses.length) - lineForceWithTwoMasses.m_b * (lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.ag_CM2_0[2] / lineForceWithTwoMasses.length);
//   lineForceWithTwoMasses.aux1_0[3] = lineForceWithTwoMasses.m_a * (lineForceWithTwoMasses.L_a * lineForceWithTwoMasses.ag_CM1_0[3] / lineForceWithTwoMasses.length) - lineForceWithTwoMasses.m_b * (lineForceWithTwoMasses.L_b * lineForceWithTwoMasses.ag_CM2_0[3] / lineForceWithTwoMasses.length);
//   lineForceWithTwoMasses.aux2_0[1] = lineForceWithTwoMasses.aux1_0[1] - (lineForceWithTwoMasses.aux1_0[1] * lineForceWithTwoMasses.e_rel_0[1] + (lineForceWithTwoMasses.aux1_0[2] * lineForceWithTwoMasses.e_rel_0[2] + lineForceWithTwoMasses.aux1_0[3] * lineForceWithTwoMasses.e_rel_0[3])) * lineForceWithTwoMasses.e_rel_0[1];
//   lineForceWithTwoMasses.aux2_0[2] = lineForceWithTwoMasses.aux1_0[2] - (lineForceWithTwoMasses.aux1_0[1] * lineForceWithTwoMasses.e_rel_0[1] + (lineForceWithTwoMasses.aux1_0[2] * lineForceWithTwoMasses.e_rel_0[2] + lineForceWithTwoMasses.aux1_0[3] * lineForceWithTwoMasses.e_rel_0[3])) * lineForceWithTwoMasses.e_rel_0[2];
//   lineForceWithTwoMasses.aux2_0[3] = lineForceWithTwoMasses.aux1_0[3] - (lineForceWithTwoMasses.aux1_0[1] * lineForceWithTwoMasses.e_rel_0[1] + (lineForceWithTwoMasses.aux1_0[2] * lineForceWithTwoMasses.e_rel_0[2] + lineForceWithTwoMasses.aux1_0[3] * lineForceWithTwoMasses.e_rel_0[3])) * lineForceWithTwoMasses.e_rel_0[3];
//   lineForceWithTwoMasses.frame_a.f = Modelica.Mechanics.MultiBody.Frames.resolve2(lineForceWithTwoMasses.frame_a.R,{lineForceWithTwoMasses.m_a * lineForceWithTwoMasses.ag_CM1_0[1] - lineForceWithTwoMasses.aux2_0[1] - lineForceWithTwoMasses.fa * lineForceWithTwoMasses.e_rel_0[1],lineForceWithTwoMasses.m_a * lineForceWithTwoMasses.ag_CM1_0[2] - lineForceWithTwoMasses.aux2_0[2] - lineForceWithTwoMasses.fa * lineForceWithTwoMasses.e_rel_0[2],lineForceWithTwoMasses.m_a * lineForceWithTwoMasses.ag_CM1_0[3] - lineForceWithTwoMasses.aux2_0[3] - lineForceWithTwoMasses.fa * lineForceWithTwoMasses.e_rel_0[3]});
//   lineForceWithTwoMasses.frame_b.f = Modelica.Mechanics.MultiBody.Frames.resolve2(lineForceWithTwoMasses.frame_b.R,{lineForceWithTwoMasses.m_b * lineForceWithTwoMasses.ag_CM2_0[1] + lineForceWithTwoMasses.aux2_0[1] - lineForceWithTwoMasses.fb * lineForceWithTwoMasses.e_rel_0[1],lineForceWithTwoMasses.m_b * lineForceWithTwoMasses.ag_CM2_0[2] + lineForceWithTwoMasses.aux2_0[2] - lineForceWithTwoMasses.fb * lineForceWithTwoMasses.e_rel_0[2],lineForceWithTwoMasses.m_b * lineForceWithTwoMasses.ag_CM2_0[3] + lineForceWithTwoMasses.aux2_0[3] - lineForceWithTwoMasses.fb * lineForceWithTwoMasses.e_rel_0[3]});
//   if false then
//   lineForceWithTwoMasses.frame_a.R.w[3] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.w[2] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.w[1] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[3,3] = 1.0;
//   lineForceWithTwoMasses.frame_a.R.T[3,2] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[3,1] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[2,3] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[2,2] = 1.0;
//   lineForceWithTwoMasses.frame_a.R.T[2,1] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[1,3] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[1,2] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.T[1,1] = 1.0;
//   else
//   lineForceWithTwoMasses.frame_a.t[1] = 0.0;
//   lineForceWithTwoMasses.frame_a.t[2] = 0.0;
//   lineForceWithTwoMasses.frame_a.t[3] = 0.0;
//   end if;
//   if false then
//   lineForceWithTwoMasses.frame_b.R.w[3] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.w[2] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.w[1] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[3,3] = 1.0;
//   lineForceWithTwoMasses.frame_b.R.T[3,2] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[3,1] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[2,3] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[2,2] = 1.0;
//   lineForceWithTwoMasses.frame_b.R.T[2,1] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[1,3] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[1,2] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.T[1,1] = 1.0;
//   else
//   lineForceWithTwoMasses.frame_b.t[1] = 0.0;
//   lineForceWithTwoMasses.frame_b.t[2] = 0.0;
//   lineForceWithTwoMasses.frame_b.t[3] = 0.0;
//   end if;
//   assert(true,"Connector frame_a of component is not connected");
//   assert(true,"Connector frame_b of component is not connected");
//   lineForceWithTwoMasses.flange_a.f + damper2.flange_a.f = 0.0;
//   lineForceWithTwoMasses.flange_a.s = damper2.flange_a.s;
//   lineForceWithTwoMasses.flange_b.f + damper2.flange_b.f = 0.0;
//   lineForceWithTwoMasses.flange_b.s = damper2.flange_b.s;
//   lineForceWithTwoMasses.frame_b.t[1] + bodyBox2.frame_b.t[1] = 0.0;
//   lineForceWithTwoMasses.frame_b.t[2] + bodyBox2.frame_b.t[2] = 0.0;
//   lineForceWithTwoMasses.frame_b.t[3] + bodyBox2.frame_b.t[3] = 0.0;
//   lineForceWithTwoMasses.frame_b.f[1] + bodyBox2.frame_b.f[1] = 0.0;
//   lineForceWithTwoMasses.frame_b.f[2] + bodyBox2.frame_b.f[2] = 0.0;
//   lineForceWithTwoMasses.frame_b.f[3] + bodyBox2.frame_b.f[3] = 0.0;
//   lineForceWithTwoMasses.frame_b.R.w[1] = bodyBox2.frame_b.R.w[1];
//   lineForceWithTwoMasses.frame_b.R.w[2] = bodyBox2.frame_b.R.w[2];
//   lineForceWithTwoMasses.frame_b.R.w[3] = bodyBox2.frame_b.R.w[3];
//   lineForceWithTwoMasses.frame_b.R.T[1,1] = bodyBox2.frame_b.R.T[1,1];
//   lineForceWithTwoMasses.frame_b.R.T[1,2] = bodyBox2.frame_b.R.T[1,2];
//   lineForceWithTwoMasses.frame_b.R.T[1,3] = bodyBox2.frame_b.R.T[1,3];
//   lineForceWithTwoMasses.frame_b.R.T[2,1] = bodyBox2.frame_b.R.T[2,1];
//   lineForceWithTwoMasses.frame_b.R.T[2,2] = bodyBox2.frame_b.R.T[2,2];
//   lineForceWithTwoMasses.frame_b.R.T[2,3] = bodyBox2.frame_b.R.T[2,3];
//   lineForceWithTwoMasses.frame_b.R.T[3,1] = bodyBox2.frame_b.R.T[3,1];
//   lineForceWithTwoMasses.frame_b.R.T[3,2] = bodyBox2.frame_b.R.T[3,2];
//   lineForceWithTwoMasses.frame_b.R.T[3,3] = bodyBox2.frame_b.R.T[3,3];
//   lineForceWithTwoMasses.frame_b.r_0[1] = bodyBox2.frame_b.r_0[1];
//   lineForceWithTwoMasses.frame_b.r_0[2] = bodyBox2.frame_b.r_0[2];
//   lineForceWithTwoMasses.frame_b.r_0[3] = bodyBox2.frame_b.r_0[3];
//   lineForceWithTwoMasses.frame_a.t[1] + rod3.frame_b.t[1] = 0.0;
//   lineForceWithTwoMasses.frame_a.t[2] + rod3.frame_b.t[2] = 0.0;
//   lineForceWithTwoMasses.frame_a.t[3] + rod3.frame_b.t[3] = 0.0;
//   lineForceWithTwoMasses.frame_a.f[1] + rod3.frame_b.f[1] = 0.0;
//   lineForceWithTwoMasses.frame_a.f[2] + rod3.frame_b.f[2] = 0.0;
//   lineForceWithTwoMasses.frame_a.f[3] + rod3.frame_b.f[3] = 0.0;
//   lineForceWithTwoMasses.frame_a.R.w[1] = rod3.frame_b.R.w[1];
//   lineForceWithTwoMasses.frame_a.R.w[2] = rod3.frame_b.R.w[2];
//   lineForceWithTwoMasses.frame_a.R.w[3] = rod3.frame_b.R.w[3];
//   lineForceWithTwoMasses.frame_a.R.T[1,1] = rod3.frame_b.R.T[1,1];
//   lineForceWithTwoMasses.frame_a.R.T[1,2] = rod3.frame_b.R.T[1,2];
//   lineForceWithTwoMasses.frame_a.R.T[1,3] = rod3.frame_b.R.T[1,3];
//   lineForceWithTwoMasses.frame_a.R.T[2,1] = rod3.frame_b.R.T[2,1];
//   lineForceWithTwoMasses.frame_a.R.T[2,2] = rod3.frame_b.R.T[2,2];
//   lineForceWithTwoMasses.frame_a.R.T[2,3] = rod3.frame_b.R.T[2,3];
//   lineForceWithTwoMasses.frame_a.R.T[3,1] = rod3.frame_b.R.T[3,1];
//   lineForceWithTwoMasses.frame_a.R.T[3,2] = rod3.frame_b.R.T[3,2];
//   lineForceWithTwoMasses.frame_a.R.T[3,3] = rod3.frame_b.R.T[3,3];
//   lineForceWithTwoMasses.frame_a.r_0[1] = rod3.frame_b.r_0[1];
//   lineForceWithTwoMasses.frame_a.r_0[2] = rod3.frame_b.r_0[2];
//   lineForceWithTwoMasses.frame_a.r_0[3] = rod3.frame_b.r_0[3];
//   rod3.frame_a.t[1] + (world.frame_b.t[1] + (rod2.frame_a.t[1] + (rod1.frame_a.t[1] + rod4.frame_a.t[1]))) = 0.0;
//   rod3.frame_a.t[2] + (world.frame_b.t[2] + (rod2.frame_a.t[2] + (rod1.frame_a.t[2] + rod4.frame_a.t[2]))) = 0.0;
//   rod3.frame_a.t[3] + (world.frame_b.t[3] + (rod2.frame_a.t[3] + (rod1.frame_a.t[3] + rod4.frame_a.t[3]))) = 0.0;
//   rod3.frame_a.f[1] + (world.frame_b.f[1] + (rod2.frame_a.f[1] + (rod1.frame_a.f[1] + rod4.frame_a.f[1]))) = 0.0;
//   rod3.frame_a.f[2] + (world.frame_b.f[2] + (rod2.frame_a.f[2] + (rod1.frame_a.f[2] + rod4.frame_a.f[2]))) = 0.0;
//   rod3.frame_a.f[3] + (world.frame_b.f[3] + (rod2.frame_a.f[3] + (rod1.frame_a.f[3] + rod4.frame_a.f[3]))) = 0.0;
//   rod3.frame_a.R.w[1] = world.frame_b.R.w[1];
//   world.frame_b.R.w[1] = rod2.frame_a.R.w[1];
//   rod2.frame_a.R.w[1] = rod1.frame_a.R.w[1];
//   rod1.frame_a.R.w[1] = rod4.frame_a.R.w[1];
//   rod3.frame_a.R.w[2] = world.frame_b.R.w[2];
//   world.frame_b.R.w[2] = rod2.frame_a.R.w[2];
//   rod2.frame_a.R.w[2] = rod1.frame_a.R.w[2];
//   rod1.frame_a.R.w[2] = rod4.frame_a.R.w[2];
//   rod3.frame_a.R.w[3] = world.frame_b.R.w[3];
//   world.frame_b.R.w[3] = rod2.frame_a.R.w[3];
//   rod2.frame_a.R.w[3] = rod1.frame_a.R.w[3];
//   rod1.frame_a.R.w[3] = rod4.frame_a.R.w[3];
//   rod3.frame_a.R.T[1,1] = world.frame_b.R.T[1,1];
//   world.frame_b.R.T[1,1] = rod2.frame_a.R.T[1,1];
//   rod2.frame_a.R.T[1,1] = rod1.frame_a.R.T[1,1];
//   rod1.frame_a.R.T[1,1] = rod4.frame_a.R.T[1,1];
//   rod3.frame_a.R.T[1,2] = world.frame_b.R.T[1,2];
//   world.frame_b.R.T[1,2] = rod2.frame_a.R.T[1,2];
//   rod2.frame_a.R.T[1,2] = rod1.frame_a.R.T[1,2];
//   rod1.frame_a.R.T[1,2] = rod4.frame_a.R.T[1,2];
//   rod3.frame_a.R.T[1,3] = world.frame_b.R.T[1,3];
//   world.frame_b.R.T[1,3] = rod2.frame_a.R.T[1,3];
//   rod2.frame_a.R.T[1,3] = rod1.frame_a.R.T[1,3];
//   rod1.frame_a.R.T[1,3] = rod4.frame_a.R.T[1,3];
//   rod3.frame_a.R.T[2,1] = world.frame_b.R.T[2,1];
//   world.frame_b.R.T[2,1] = rod2.frame_a.R.T[2,1];
//   rod2.frame_a.R.T[2,1] = rod1.frame_a.R.T[2,1];
//   rod1.frame_a.R.T[2,1] = rod4.frame_a.R.T[2,1];
//   rod3.frame_a.R.T[2,2] = world.frame_b.R.T[2,2];
//   world.frame_b.R.T[2,2] = rod2.frame_a.R.T[2,2];
//   rod2.frame_a.R.T[2,2] = rod1.frame_a.R.T[2,2];
//   rod1.frame_a.R.T[2,2] = rod4.frame_a.R.T[2,2];
//   rod3.frame_a.R.T[2,3] = world.frame_b.R.T[2,3];
//   world.frame_b.R.T[2,3] = rod2.frame_a.R.T[2,3];
//   rod2.frame_a.R.T[2,3] = rod1.frame_a.R.T[2,3];
//   rod1.frame_a.R.T[2,3] = rod4.frame_a.R.T[2,3];
//   rod3.frame_a.R.T[3,1] = world.frame_b.R.T[3,1];
//   world.frame_b.R.T[3,1] = rod2.frame_a.R.T[3,1];
//   rod2.frame_a.R.T[3,1] = rod1.frame_a.R.T[3,1];
//   rod1.frame_a.R.T[3,1] = rod4.frame_a.R.T[3,1];
//   rod3.frame_a.R.T[3,2] = world.frame_b.R.T[3,2];
//   world.frame_b.R.T[3,2] = rod2.frame_a.R.T[3,2];
//   rod2.frame_a.R.T[3,2] = rod1.frame_a.R.T[3,2];
//   rod1.frame_a.R.T[3,2] = rod4.frame_a.R.T[3,2];
//   rod3.frame_a.R.T[3,3] = world.frame_b.R.T[3,3];
//   world.frame_b.R.T[3,3] = rod2.frame_a.R.T[3,3];
//   rod2.frame_a.R.T[3,3] = rod1.frame_a.R.T[3,3];
//   rod1.frame_a.R.T[3,3] = rod4.frame_a.R.T[3,3];
//   rod3.frame_a.r_0[1] = world.frame_b.r_0[1];
//   world.frame_b.r_0[1] = rod2.frame_a.r_0[1];
//   rod2.frame_a.r_0[1] = rod1.frame_a.r_0[1];
//   rod1.frame_a.r_0[1] = rod4.frame_a.r_0[1];
//   rod3.frame_a.r_0[2] = world.frame_b.r_0[2];
//   world.frame_b.r_0[2] = rod2.frame_a.r_0[2];
//   rod2.frame_a.r_0[2] = rod1.frame_a.r_0[2];
//   rod1.frame_a.r_0[2] = rod4.frame_a.r_0[2];
//   rod3.frame_a.r_0[3] = world.frame_b.r_0[3];
//   world.frame_b.r_0[3] = rod2.frame_a.r_0[3];
//   rod2.frame_a.r_0[3] = rod1.frame_a.r_0[3];
//   rod1.frame_a.r_0[3] = rod4.frame_a.r_0[3];
//   revolute2.frame_b.t[1] + bodyBox2.frame_a.t[1] = 0.0;
//   revolute2.frame_b.t[2] + bodyBox2.frame_a.t[2] = 0.0;
//   revolute2.frame_b.t[3] + bodyBox2.frame_a.t[3] = 0.0;
//   revolute2.frame_b.f[1] + bodyBox2.frame_a.f[1] = 0.0;
//   revolute2.frame_b.f[2] + bodyBox2.frame_a.f[2] = 0.0;
//   revolute2.frame_b.f[3] + bodyBox2.frame_a.f[3] = 0.0;
//   revolute2.frame_b.R.w[1] = bodyBox2.frame_a.R.w[1];
//   revolute2.frame_b.R.w[2] = bodyBox2.frame_a.R.w[2];
//   revolute2.frame_b.R.w[3] = bodyBox2.frame_a.R.w[3];
//   revolute2.frame_b.R.T[1,1] = bodyBox2.frame_a.R.T[1,1];
//   revolute2.frame_b.R.T[1,2] = bodyBox2.frame_a.R.T[1,2];
//   revolute2.frame_b.R.T[1,3] = bodyBox2.frame_a.R.T[1,3];
//   revolute2.frame_b.R.T[2,1] = bodyBox2.frame_a.R.T[2,1];
//   revolute2.frame_b.R.T[2,2] = bodyBox2.frame_a.R.T[2,2];
//   revolute2.frame_b.R.T[2,3] = bodyBox2.frame_a.R.T[2,3];
//   revolute2.frame_b.R.T[3,1] = bodyBox2.frame_a.R.T[3,1];
//   revolute2.frame_b.R.T[3,2] = bodyBox2.frame_a.R.T[3,2];
//   revolute2.frame_b.R.T[3,3] = bodyBox2.frame_a.R.T[3,3];
//   revolute2.frame_b.r_0[1] = bodyBox2.frame_a.r_0[1];
//   revolute2.frame_b.r_0[2] = bodyBox2.frame_a.r_0[2];
//   revolute2.frame_b.r_0[3] = bodyBox2.frame_a.r_0[3];
//   rod4.frame_b.t[1] + revolute2.frame_a.t[1] = 0.0;
//   rod4.frame_b.t[2] + revolute2.frame_a.t[2] = 0.0;
//   rod4.frame_b.t[3] + revolute2.frame_a.t[3] = 0.0;
//   rod4.frame_b.f[1] + revolute2.frame_a.f[1] = 0.0;
//   rod4.frame_b.f[2] + revolute2.frame_a.f[2] = 0.0;
//   rod4.frame_b.f[3] + revolute2.frame_a.f[3] = 0.0;
//   rod4.frame_b.R.w[1] = revolute2.frame_a.R.w[1];
//   rod4.frame_b.R.w[2] = revolute2.frame_a.R.w[2];
//   rod4.frame_b.R.w[3] = revolute2.frame_a.R.w[3];
//   rod4.frame_b.R.T[1,1] = revolute2.frame_a.R.T[1,1];
//   rod4.frame_b.R.T[1,2] = revolute2.frame_a.R.T[1,2];
//   rod4.frame_b.R.T[1,3] = revolute2.frame_a.R.T[1,3];
//   rod4.frame_b.R.T[2,1] = revolute2.frame_a.R.T[2,1];
//   rod4.frame_b.R.T[2,2] = revolute2.frame_a.R.T[2,2];
//   rod4.frame_b.R.T[2,3] = revolute2.frame_a.R.T[2,3];
//   rod4.frame_b.R.T[3,1] = revolute2.frame_a.R.T[3,1];
//   rod4.frame_b.R.T[3,2] = revolute2.frame_a.R.T[3,2];
//   rod4.frame_b.R.T[3,3] = revolute2.frame_a.R.T[3,3];
//   rod4.frame_b.r_0[1] = revolute2.frame_a.r_0[1];
//   rod4.frame_b.r_0[2] = revolute2.frame_a.r_0[2];
//   rod4.frame_b.r_0[3] = revolute2.frame_a.r_0[3];
//   rod1.frame_b.t[1] + jointUPS.frame_a.t[1] = 0.0;
//   rod1.frame_b.t[2] + jointUPS.frame_a.t[2] = 0.0;
//   rod1.frame_b.t[3] + jointUPS.frame_a.t[3] = 0.0;
//   rod1.frame_b.f[1] + jointUPS.frame_a.f[1] = 0.0;
//   rod1.frame_b.f[2] + jointUPS.frame_a.f[2] = 0.0;
//   rod1.frame_b.f[3] + jointUPS.frame_a.f[3] = 0.0;
//   rod1.frame_b.R.w[1] = jointUPS.frame_a.R.w[1];
//   rod1.frame_b.R.w[2] = jointUPS.frame_a.R.w[2];
//   rod1.frame_b.R.w[3] = jointUPS.frame_a.R.w[3];
//   rod1.frame_b.R.T[1,1] = jointUPS.frame_a.R.T[1,1];
//   rod1.frame_b.R.T[1,2] = jointUPS.frame_a.R.T[1,2];
//   rod1.frame_b.R.T[1,3] = jointUPS.frame_a.R.T[1,3];
//   rod1.frame_b.R.T[2,1] = jointUPS.frame_a.R.T[2,1];
//   rod1.frame_b.R.T[2,2] = jointUPS.frame_a.R.T[2,2];
//   rod1.frame_b.R.T[2,3] = jointUPS.frame_a.R.T[2,3];
//   rod1.frame_b.R.T[3,1] = jointUPS.frame_a.R.T[3,1];
//   rod1.frame_b.R.T[3,2] = jointUPS.frame_a.R.T[3,2];
//   rod1.frame_b.R.T[3,3] = jointUPS.frame_a.R.T[3,3];
//   rod1.frame_b.r_0[1] = jointUPS.frame_a.r_0[1];
//   rod1.frame_b.r_0[2] = jointUPS.frame_a.r_0[2];
//   rod1.frame_b.r_0[3] = jointUPS.frame_a.r_0[3];
//   body1.frame_a.t[1] + jointUPS.frame_ia.t[1] = 0.0;
//   body1.frame_a.t[2] + jointUPS.frame_ia.t[2] = 0.0;
//   body1.frame_a.t[3] + jointUPS.frame_ia.t[3] = 0.0;
//   body1.frame_a.f[1] + jointUPS.frame_ia.f[1] = 0.0;
//   body1.frame_a.f[2] + jointUPS.frame_ia.f[2] = 0.0;
//   body1.frame_a.f[3] + jointUPS.frame_ia.f[3] = 0.0;
//   body1.frame_a.R.w[1] = jointUPS.frame_ia.R.w[1];
//   body1.frame_a.R.w[2] = jointUPS.frame_ia.R.w[2];
//   body1.frame_a.R.w[3] = jointUPS.frame_ia.R.w[3];
//   body1.frame_a.R.T[1,1] = jointUPS.frame_ia.R.T[1,1];
//   body1.frame_a.R.T[1,2] = jointUPS.frame_ia.R.T[1,2];
//   body1.frame_a.R.T[1,3] = jointUPS.frame_ia.R.T[1,3];
//   body1.frame_a.R.T[2,1] = jointUPS.frame_ia.R.T[2,1];
//   body1.frame_a.R.T[2,2] = jointUPS.frame_ia.R.T[2,2];
//   body1.frame_a.R.T[2,3] = jointUPS.frame_ia.R.T[2,3];
//   body1.frame_a.R.T[3,1] = jointUPS.frame_ia.R.T[3,1];
//   body1.frame_a.R.T[3,2] = jointUPS.frame_ia.R.T[3,2];
//   body1.frame_a.R.T[3,3] = jointUPS.frame_ia.R.T[3,3];
//   body1.frame_a.r_0[1] = jointUPS.frame_ia.r_0[1];
//   body1.frame_a.r_0[2] = jointUPS.frame_ia.r_0[2];
//   body1.frame_a.r_0[3] = jointUPS.frame_ia.r_0[3];
//   bodyBox1.frame_b.t[1] + jointUPS.frame_b.t[1] = 0.0;
//   bodyBox1.frame_b.t[2] + jointUPS.frame_b.t[2] = 0.0;
//   bodyBox1.frame_b.t[3] + jointUPS.frame_b.t[3] = 0.0;
//   bodyBox1.frame_b.f[1] + jointUPS.frame_b.f[1] = 0.0;
//   bodyBox1.frame_b.f[2] + jointUPS.frame_b.f[2] = 0.0;
//   bodyBox1.frame_b.f[3] + jointUPS.frame_b.f[3] = 0.0;
//   bodyBox1.frame_b.R.w[1] = jointUPS.frame_b.R.w[1];
//   bodyBox1.frame_b.R.w[2] = jointUPS.frame_b.R.w[2];
//   bodyBox1.frame_b.R.w[3] = jointUPS.frame_b.R.w[3];
//   bodyBox1.frame_b.R.T[1,1] = jointUPS.frame_b.R.T[1,1];
//   bodyBox1.frame_b.R.T[1,2] = jointUPS.frame_b.R.T[1,2];
//   bodyBox1.frame_b.R.T[1,3] = jointUPS.frame_b.R.T[1,3];
//   bodyBox1.frame_b.R.T[2,1] = jointUPS.frame_b.R.T[2,1];
//   bodyBox1.frame_b.R.T[2,2] = jointUPS.frame_b.R.T[2,2];
//   bodyBox1.frame_b.R.T[2,3] = jointUPS.frame_b.R.T[2,3];
//   bodyBox1.frame_b.R.T[3,1] = jointUPS.frame_b.R.T[3,1];
//   bodyBox1.frame_b.R.T[3,2] = jointUPS.frame_b.R.T[3,2];
//   bodyBox1.frame_b.R.T[3,3] = jointUPS.frame_b.R.T[3,3];
//   bodyBox1.frame_b.r_0[1] = jointUPS.frame_b.r_0[1];
//   bodyBox1.frame_b.r_0[2] = jointUPS.frame_b.r_0[2];
//   bodyBox1.frame_b.r_0[3] = jointUPS.frame_b.r_0[3];
//   revolute1.frame_b.t[1] + bodyBox1.frame_a.t[1] = 0.0;
//   revolute1.frame_b.t[2] + bodyBox1.frame_a.t[2] = 0.0;
//   revolute1.frame_b.t[3] + bodyBox1.frame_a.t[3] = 0.0;
//   revolute1.frame_b.f[1] + bodyBox1.frame_a.f[1] = 0.0;
//   revolute1.frame_b.f[2] + bodyBox1.frame_a.f[2] = 0.0;
//   revolute1.frame_b.f[3] + bodyBox1.frame_a.f[3] = 0.0;
//   revolute1.frame_b.R.w[1] = bodyBox1.frame_a.R.w[1];
//   revolute1.frame_b.R.w[2] = bodyBox1.frame_a.R.w[2];
//   revolute1.frame_b.R.w[3] = bodyBox1.frame_a.R.w[3];
//   revolute1.frame_b.R.T[1,1] = bodyBox1.frame_a.R.T[1,1];
//   revolute1.frame_b.R.T[1,2] = bodyBox1.frame_a.R.T[1,2];
//   revolute1.frame_b.R.T[1,3] = bodyBox1.frame_a.R.T[1,3];
//   revolute1.frame_b.R.T[2,1] = bodyBox1.frame_a.R.T[2,1];
//   revolute1.frame_b.R.T[2,2] = bodyBox1.frame_a.R.T[2,2];
//   revolute1.frame_b.R.T[2,3] = bodyBox1.frame_a.R.T[2,3];
//   revolute1.frame_b.R.T[3,1] = bodyBox1.frame_a.R.T[3,1];
//   revolute1.frame_b.R.T[3,2] = bodyBox1.frame_a.R.T[3,2];
//   revolute1.frame_b.R.T[3,3] = bodyBox1.frame_a.R.T[3,3];
//   revolute1.frame_b.r_0[1] = bodyBox1.frame_a.r_0[1];
//   revolute1.frame_b.r_0[2] = bodyBox1.frame_a.r_0[2];
//   revolute1.frame_b.r_0[3] = bodyBox1.frame_a.r_0[3];
//   rod2.frame_b.t[1] + revolute1.frame_a.t[1] = 0.0;
//   rod2.frame_b.t[2] + revolute1.frame_a.t[2] = 0.0;
//   rod2.frame_b.t[3] + revolute1.frame_a.t[3] = 0.0;
//   rod2.frame_b.f[1] + revolute1.frame_a.f[1] = 0.0;
//   rod2.frame_b.f[2] + revolute1.frame_a.f[2] = 0.0;
//   rod2.frame_b.f[3] + revolute1.frame_a.f[3] = 0.0;
//   rod2.frame_b.R.w[1] = revolute1.frame_a.R.w[1];
//   rod2.frame_b.R.w[2] = revolute1.frame_a.R.w[2];
//   rod2.frame_b.R.w[3] = revolute1.frame_a.R.w[3];
//   rod2.frame_b.R.T[1,1] = revolute1.frame_a.R.T[1,1];
//   rod2.frame_b.R.T[1,2] = revolute1.frame_a.R.T[1,2];
//   rod2.frame_b.R.T[1,3] = revolute1.frame_a.R.T[1,3];
//   rod2.frame_b.R.T[2,1] = revolute1.frame_a.R.T[2,1];
//   rod2.frame_b.R.T[2,2] = revolute1.frame_a.R.T[2,2];
//   rod2.frame_b.R.T[2,3] = revolute1.frame_a.R.T[2,3];
//   rod2.frame_b.R.T[3,1] = revolute1.frame_a.R.T[3,1];
//   rod2.frame_b.R.T[3,2] = revolute1.frame_a.R.T[3,2];
//   rod2.frame_b.R.T[3,3] = revolute1.frame_a.R.T[3,3];
//   rod2.frame_b.r_0[1] = revolute1.frame_a.r_0[1];
//   rod2.frame_b.r_0[2] = revolute1.frame_a.r_0[2];
//   rod2.frame_b.r_0[3] = revolute1.frame_a.r_0[3];
//   jointUPS.frame_ib.t[1] + body2.frame_a.t[1] = 0.0;
//   jointUPS.frame_ib.t[2] + body2.frame_a.t[2] = 0.0;
//   jointUPS.frame_ib.t[3] + body2.frame_a.t[3] = 0.0;
//   jointUPS.frame_ib.f[1] + body2.frame_a.f[1] = 0.0;
//   jointUPS.frame_ib.f[2] + body2.frame_a.f[2] = 0.0;
//   jointUPS.frame_ib.f[3] + body2.frame_a.f[3] = 0.0;
//   jointUPS.frame_ib.R.w[1] = body2.frame_a.R.w[1];
//   jointUPS.frame_ib.R.w[2] = body2.frame_a.R.w[2];
//   jointUPS.frame_ib.R.w[3] = body2.frame_a.R.w[3];
//   jointUPS.frame_ib.R.T[1,1] = body2.frame_a.R.T[1,1];
//   jointUPS.frame_ib.R.T[1,2] = body2.frame_a.R.T[1,2];
//   jointUPS.frame_ib.R.T[1,3] = body2.frame_a.R.T[1,3];
//   jointUPS.frame_ib.R.T[2,1] = body2.frame_a.R.T[2,1];
//   jointUPS.frame_ib.R.T[2,2] = body2.frame_a.R.T[2,2];
//   jointUPS.frame_ib.R.T[2,3] = body2.frame_a.R.T[2,3];
//   jointUPS.frame_ib.R.T[3,1] = body2.frame_a.R.T[3,1];
//   jointUPS.frame_ib.R.T[3,2] = body2.frame_a.R.T[3,2];
//   jointUPS.frame_ib.R.T[3,3] = body2.frame_a.R.T[3,3];
//   jointUPS.frame_ib.r_0[1] = body2.frame_a.r_0[1];
//   jointUPS.frame_ib.r_0[2] = body2.frame_a.r_0[2];
//   jointUPS.frame_ib.r_0[3] = body2.frame_a.r_0[3];
//   jointUPS.axis.f + damper1.flange_b.f = 0.0;
//   jointUPS.axis.s = damper1.flange_b.s;
//   jointUPS.bearing.f + damper1.flange_a.f = 0.0;
//   jointUPS.bearing.s = damper1.flange_a.s;
// end Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses has 3095 equation(s) and 3095 variable(s).
// 1886 of these are trivial equation(s).
// "
// ""
// 0
// endResult
