//name:        Modelica.Fluid.Examples.HeatingSystem [version 3.1]
//keyword:     fluid
//status:      correct
//
// instantiate/check model example
//

loadModel(Modelica, {"3.1"}); getErrorString();
setDebugFlags("nogen");

instantiateModel(Modelica.Fluid.Examples.HeatingSystem); getErrorString();
checkModel(Modelica.Fluid.Examples.HeatingSystem); getErrorString();

// Result:
// true
// ""
// true
// "function Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState\"
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort.Medium.setState_pTX(p,T,X));
// end Modelica.Fluid.Interfaces.FluidPort.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState(1,Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Interfaces.FluidPort_a.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort_a.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort_a.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Interfaces.FluidPort_a.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState(1,Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Interfaces.FluidPort_b.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Interfaces.FluidPort_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy(Modelica.Fluid.Interfaces.FluidPort_b.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Interfaces.FluidPort_b.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.density_pT;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState(1,Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.setState_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy(Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.temperature;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.SaturationProperties \"Automatically generated record constructor for Modelica.Fluid.Machines.ControlledPump.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end Modelica.Fluid.Machines.ControlledPump.Medium.SaturationProperties;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input Modelica.Fluid.Machines.ControlledPump.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end Modelica.Fluid.Machines.ControlledPump.Medium.bubbleEnthalpy;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.density \"return density of ideal gas\"
//   input Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end Modelica.Fluid.Machines.ControlledPump.Medium.density;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Machines.ControlledPump.Medium.density_pT;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Machines.ControlledPump.Medium.density(Modelica.Fluid.Machines.ControlledPump.Medium.setState_pTX(p,T,X,0));
// end Modelica.Fluid.Machines.ControlledPump.Medium.density_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p,h,phase,0);
// end Modelica.Fluid.Machines.ControlledPump.Medium.density_ph;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input Modelica.Fluid.Machines.ControlledPump.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end Modelica.Fluid.Machines.ControlledPump.Medium.dewEnthalpy;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end Modelica.Fluid.Machines.ControlledPump.Medium.saturationTemperature;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState(1,Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Machines.ControlledPump.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Machines.ControlledPump.Medium.setState_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.setState_phX \"Return thermodynamic state as function of p, h and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Machines.ControlledPump.Medium.setState_phX;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy(Modelica.Fluid.Machines.ControlledPump.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Machines.ControlledPump.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// end Modelica.Fluid.Machines.ControlledPump.Medium.temperature;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p,h,phase,0);
// end Modelica.Fluid.Machines.ControlledPump.Medium.temperature_ph;
// 
// function Modelica.Fluid.Machines.ControlledPump.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Fluid.Machines.ControlledPump.Medium.temperature(Modelica.Fluid.Machines.ControlledPump.Medium.setState_phX(p,h,X));
// end Modelica.Fluid.Machines.ControlledPump.Medium.temperature_phX;
// 
// function Modelica.Fluid.Machines.ControlledPump.efficiencyCharacteristic \"Constant efficiency characteristic\"
//   input Real V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") \"Volumetric flow rate\";
//   output Real eta \"Efficiency\";
//   input Real eta_nominal = 0.8 \"Nominal efficiency\";
// algorithm
//   eta := eta_nominal;
// end Modelica.Fluid.Machines.ControlledPump.efficiencyCharacteristic;
// 
// function Modelica.Fluid.Machines.ControlledPump.flowCharacteristic \"Quadratic flow characteristic\"
//   input Real V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") \"Volumetric flow rate\";
//   output Real head(quantity = \"Length\", unit = \"m\", min = 0.0) \"Pump head\";
//   input Real[3] V_flow_nominal(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = {0.0,V_flow_op,1.5 * V_flow_op} \"Volume flow rate for three operating points (single pump)\";
//   input Real[3] head_nominal(quantity = \"Length\", unit = \"m\", min = 0.0) = {2.0 * head_op,head_op,0.0} \"Pump head for three operating points\";
//   protected Real[3] V_flow_nominal2 = {V_flow_nominal[1] ^ 2.0,V_flow_nominal[2] ^ 2.0,V_flow_nominal[3] ^ 2.0} \"Squared nominal flow rates\";
//   protected Real[3] c = Modelica.Math.Matrices.solve({{1.0,V_flow_nominal[1],V_flow_nominal2[1]},{1.0,V_flow_nominal[2],V_flow_nominal2[2]},{1.0,V_flow_nominal[3],V_flow_nominal2[3]}},{head_nominal[1],head_nominal[2],head_nominal[3]}) \"Coefficients of quadratic head curve\";
// algorithm
//   head := c[1] + V_flow * c[2] + V_flow ^ 2.0 * c[3];
// end Modelica.Fluid.Machines.ControlledPump.flowCharacteristic;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density \"return density of ideal gas\"
//   input Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX(p,T,X,0));
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity \"Dynamic viscosity of water\"
//   input Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := Modelica.Media.Water.IF97_Utilities.dynamicViscosity(state.d,state.T,state.p,state.phase);
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure \"return pressure of ideal gas\"
//   input Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
// algorithm
//   p := state.p;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState(1,Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy(Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric \"Calculate mass flow rate as function of pressure drop due to friction\"
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   output Real dm_flow_ddp_fric \"Derivative of mass flow rate with dp_fric\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dRe_ddp \"dRe/ddp\";
//   protected Real aux1;
//   protected Real aux2;
// algorithm
//   if dp_fric >= 0.0 then
//     rho := rho_a;
//     mu := mu_a;
//   else
//     rho := rho_b;
//     mu := mu_b;
//   end if;
//   lambda2 := (2.0 * abs(dp_fric) * diameter ^ 3.0 * rho * mu ^ -2.0) / length;
//   aux1 := (2.0 * diameter ^ 3.0 * rho * mu ^ -2.0) / length;
//   Re := lambda2 / 64.0;
//   dRe_ddp := aux1 / 64.0;
//   if Re > Re1 then
//     Re := -2.0 * sqrt(lambda2) * log10(2.51 / sqrt(lambda2) + 0.27 * Delta);
//     aux2 := sqrt(aux1 * abs(dp_fric));
//     dRe_ddp := 0.434294481903252 * ((-2.0 * log(2.51 / aux2 + 0.27 * Delta) * aux1) / (aux2 * 2.0) + 5.02 / ((2.51 / aux2 + 0.27 * Delta) * abs(dp_fric) * 2.0));
//     if Re < Re2 then
//       (Re, dRe_ddp) := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2,Re1,Re2,Delta,dp_fric);
//     end if;
//   end if;
//   m_flow := 0.785398163397448 * diameter * mu * if dp_fric >= 0.0 then Re else -Re;
//   dm_flow_ddp_fric := 0.785398163397448 * diameter * mu * dRe_ddp;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative \"Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)\"
//   input Real lambda2 \"Known independent variable\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   output Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Unknown return variable\";
//   output Real dRe_ddp \"Derivative of return value\";
//   protected Real x1 = log10(64.0 * Re1);
//   protected Real y1 = log10(Re1);
//   protected Real y1d = 1.0;
//   protected Real aux2 = Delta / 3.7 + 5.74 * Re2 ^ -0.9;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real aux5 = -2.0 * (sqrt(L2) * log10(aux4));
//   protected Real x2 = log10(L2);
//   protected Real y2 = log10(aux5);
//   protected Real y2d = 0.5 + 1.09007914957716 / (aux5 * aux4);
//   protected Real x = log10(lambda2);
//   protected Real y;
//   protected Real dy_dx \"Derivative in transformed space\";
// algorithm
//   (y, dy_dx) := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x,x1,x2,y1,y2,y1d,y2d);
//   Re := 10.0 ^ y;
//   dRe_ddp := (dy_dx * Re) / abs(dp_fric);
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.massFlowRate_dp_staticHead \"Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head\"
//   input Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real g_times_height_ab \"Gravity times (Height(port_b) - Height(port_a))\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-005 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1.0 \"Turbulent flow if |dp| >= dp_small (dummy if use_dp_small = false)\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = (745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta)) ^ 0.97 \"Boundary between laminar regime and transition\";
//   protected constant Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Boundary between transition and turbulent regime\";
//   protected Real dp_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Upper end of regularization domain of the m_flow(dp) relation\";
//   protected Real dp_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Lower end of regularization domain of the m_flow(dp) relation\";
//   protected Real m_flow_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at upper end of regularization domain\";
//   protected Real m_flow_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at lower end of regularization domain\";
//   protected Real dm_flow_ddp_fric_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at upper end of regularization domain\";
//   protected Real dm_flow_ddp_fric_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at lower end of regularization domain\";
//   protected Real dp_grav_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_a \"Static head if mass flows in design direction (a to b)\";
//   protected Real dp_grav_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_b \"Static head if mass flows against design direction (b to a)\";
//   protected Real m_flow_zero(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0;
//   protected Real dp_zero(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = dp_grav_a / 2.0 + dp_grav_b / 2.0;
//   protected Real dm_flow_ddp_fric_zero;
// algorithm
//   dp_a := max(dp_grav_a,dp_grav_b) + dp_small;
//   dp_b := min(dp_grav_a,dp_grav_b) - dp_small;
//   if dp >= dp_a then
//     (m_flow, _) := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_a,rho_a,rho_b,mu_a,mu_b,length,diameter,Re1,4000.0,Delta);
//   elseif dp <= dp_b then
//     (m_flow, _) := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_b,rho_a,rho_b,mu_a,mu_b,length,diameter,Re1,4000.0,Delta);
//   else
//     (m_flow_a, dm_flow_ddp_fric_a) := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_a - dp_grav_a,rho_a,rho_b,mu_a,mu_b,length,diameter,Re1,4000.0,Delta);
//     (m_flow_b, dm_flow_ddp_fric_b) := Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_b - dp_grav_b,rho_a,rho_b,mu_a,mu_b,length,diameter,Re1,4000.0,Delta);
//     (m_flow, dm_flow_ddp_fric_zero) := Modelica.Fluid.Utilities.regFun3(dp_zero,dp_b,dp_a,m_flow_b,m_flow_a,dm_flow_ddp_fric_b,dm_flow_ddp_fric_a);
//     if dp > dp_zero then
//       (m_flow, _) := Modelica.Fluid.Utilities.regFun3(dp,dp_zero,dp_a,m_flow_zero,m_flow_a,dm_flow_ddp_fric_zero,dm_flow_ddp_fric_a);
//     else
//       (m_flow, _) := Modelica.Fluid.Utilities.regFun3(dp,dp_b,dp_zero,m_flow_b,m_flow_zero,dm_flow_ddp_fric_b,dm_flow_ddp_fric_zero);
//     end if;
//   end if;
// end Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.massFlowRate_dp_staticHead;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.density_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState(1,Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.setState_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy(Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.SaturationProperties \"Automatically generated record constructor for Modelica.Fluid.Pipes.DynamicPipe.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.SaturationProperties;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input Modelica.Fluid.Pipes.DynamicPipe.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.density \"return density of ideal gas\"
//   input Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.density;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.density_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p,h,phase,0);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input Modelica.Fluid.Pipes.DynamicPipe.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState(1,Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Pipes.DynamicPipe.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX \"Return thermodynamic state as function of p, h and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy(Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Pipes.DynamicPipe.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p,h,phase,0);
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph;
// 
// function Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature(Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(p,h,X));
// end Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_phX;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Sensors.Temperature.Medium.density_pT;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p,h,phase,0);
// end Modelica.Fluid.Sensors.Temperature.Medium.density_ph;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState(1,Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Sensors.Temperature.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Sensors.Temperature.Medium.setState_pTX;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.setState_phX \"Return thermodynamic state of water as function of p and h\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState(0,h,Modelica.Fluid.Sensors.Temperature.Medium.density_ph(p,h,0),Modelica.Fluid.Sensors.Temperature.Medium.temperature_ph(p,h,0),p);
// end Modelica.Fluid.Sensors.Temperature.Medium.setState_phX;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy(Modelica.Fluid.Sensors.Temperature.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Sensors.Temperature.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Sensors.Temperature.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Sensors.Temperature.Medium.temperature;
// 
// function Modelica.Fluid.Sensors.Temperature.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p,h,phase,0);
// end Modelica.Fluid.Sensors.Temperature.Medium.temperature_ph;
// 
// function Modelica.Fluid.Utilities.cubicHermite_withDerivative \"Evaluate a cubic Hermite spline, return value and derivative\"
//   input Real x \"Abscissa value\";
//   input Real x1 \"Lower abscissa value\";
//   input Real x2 \"Upper abscissa value\";
//   input Real y1 \"Lower ordinate value\";
//   input Real y2 \"Upper ordinate value\";
//   input Real y1d \"Lower gradient\";
//   input Real y2d \"Upper gradient\";
//   output Real y \"Interpolated ordinate value\";
//   output Real dy_dx \"Derivative dy/dx at abscissa value x\";
//   protected Real h \"Distance between x1 and x2\";
//   protected Real t \"abscissa scaled with h, i.e. t=[0..1] within x=[x1..x2]\";
//   protected Real h00 \"Basis function 00 of cubic Hermite spline\";
//   protected Real h10 \"Basis function 10 of cubic Hermite spline\";
//   protected Real h01 \"Basis function 01 of cubic Hermite spline\";
//   protected Real h11 \"Basis function 11 of cubic Hermite spline\";
//   protected Real h00d \"d/dt h00\";
//   protected Real h10d \"d/dt h10\";
//   protected Real h01d \"d/dt h01\";
//   protected Real h11d \"d/dt h11\";
//   protected Real aux3 \"t cube\";
//   protected Real aux2 \"t square\";
// algorithm
//   h := x2 - x1;
//   if abs(h) > 0.0 then
//     t := (x - x1) / h;
//     aux3 := t ^ 3.0;
//     aux2 := t ^ 2.0;
//     h00 := 1.0 + 2.0 * aux3 + -3.0 * aux2;
//     h10 := aux3 + -2.0 * aux2 + t;
//     h01 := -2.0 * aux3 + 3.0 * aux2;
//     h11 := aux3 - aux2;
//     h00d := 6.0 * (aux2 - t);
//     h10d := 1.0 + 3.0 * aux2 + -4.0 * t;
//     h01d := 6.0 * (t - aux2);
//     h11d := 3.0 * aux2 + -2.0 * t;
//     y := y1 * h00 + h * y1d * h10 + y2 * h01 + h * y2d * h11;
//     dy_dx := (y1 * h00d) / h + y1d * h10d + (y2 * h01d) / h + y2d * h11d;
//   else
//     y := y1 / 2.0 + y2 / 2.0;
//     dy_dx := 1e+060 * /*REAL*/(sign(y2 - y1));
//   end if;
// end Modelica.Fluid.Utilities.cubicHermite_withDerivative;
// 
// function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero \"Evaluate polynomial of order 3 that passes the origin with a predefined derivative\"
//   input Real x \"Value for which polynomial shall be evaluated\";
//   input Real x1 \"Abscissa value\";
//   input Real y1 \"y1=f(x1)\";
//   input Real y1d \"First derivative at y1\";
//   input Real y0d \"First derivative at f(x=0)\";
//   output Real y;
//   protected Real a1;
//   protected Real a2;
//   protected Real a3;
//   protected Real xx;
// algorithm
//   a1 := x1 * y0d;
//   a2 := 3.0 * y1 + -2.0 * a1 - x1 * y1d;
//   a3 := y1 + -a2 - a1;
//   xx := x / x1;
//   y := xx * (a1 + xx * (a2 + xx * a3));
// end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
// 
// function Modelica.Fluid.Utilities.regFun3 \"Co-monotonic and C1 smooth regularization function\"
//   input Real x \"Abscissa value\";
//   input Real x0 \"Lower abscissa value\";
//   input Real x1 \"Upper abscissa value\";
//   input Real y0 \"Ordinate value at lower ordinate value\";
//   input Real y1 \"Ordinate value at upper ordinate value\";
//   input Real y0d \"Derivative at lower abscissa value\";
//   input Real y1d \"Derivative at upper abscissa value\";
//   output Real y \"Ordinate value\";
//   output Real c \"Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used\";
//   protected Real h0 \"Width of interval i=0\";
//   protected Real Delta0 \"Slope of secant on interval i=0\";
//   protected Real xstar \"Inflection point of cubic polynomial S0\";
//   protected Real mu \"Distance of inflection point and left limit x0\";
//   protected Real eta \"Distance of right limit x1 and inflection point\";
//   protected Real omega \"Slope of subic polynomial S0 at inflection point\";
//   protected Real rho \"Weighting factor of eta and eta_tilde, mu and mu_tilde\";
//   protected Real theta0 \"Slope metric\";
//   protected Real mu_tilde \"Distance of start of linear section and left limit x0\";
//   protected Real eta_tilde \"Distance of right limit x1 and end of linear section\";
//   protected Real xi1 \"Start of linear section \";
//   protected Real xi2 \"End of linear section \";
//   protected Real a1 \"Leading coefficient of cubic on the left\";
//   protected Real a2 \"Leading coefficient of cubic on the right\";
//   protected Real const12 \"Integration constant of left cubic, linear section\";
//   protected Real const3 \"Integration constant of right cubic\";
//   protected Real aux01;
//   protected Real aux02;
//   protected Boolean useSingleCubicPolynomial = false \"Indicate to override further logic and use single cubic\";
// algorithm
//   assert( x0 < x1, \"regFun3(): Data points not sorted appropriately (x0 = \" + String(x0,0,true,6) + \" > x1 = \" + String(x1,0,true,6) + \"). Please flip arguments.\");
//   h0 := x1 - x0;
//   Delta0 := (y1 - y0) / h0;
//   if abs(Delta0) <= 0.0 then
//     y := y0;
//   else
//     if abs(y1d + y0d + -2.0 * Delta0) < 1e-013 then
//       xstar := 1e+060 * (x1 - x0) * (2.0 * y0d + y1d + -3.0 * Delta0) * if y0d + y1d + -2.0 * Delta0 >= 0.0 then 1.0 else -1.0;
//     else
//       xstar := (0.333333333333333 * (-3.0 * x0 * (y0d + y1d) + 6.0 * x0 * Delta0 + -2.0 * h0 * y0d + 3.0 * h0 * Delta0 - h0 * y1d)) / (2.0 * Delta0 + -y1d - y0d);
//     end if;
//     mu := xstar - x0;
//     eta := x1 - xstar;
//     omega := 3.0 * (y0d + y1d + -2.0 * Delta0) * (xstar - x0) ^ 2.0 * h0 ^ -2.0 + (2.0 * (-2.0 * y0d + 3.0 * Delta0 - y1d) * (xstar - x0)) / h0 + y0d;
//     aux01 := 0.25 * /*REAL*/(sign(Delta0)) * min(abs(omega),abs(Delta0));
//     if abs(y0d - y1d) <= 1e-013 then
//       aux02 := y0d;
//       if y1 > y0 + y0d * (x1 - x0) then
//         useSingleCubicPolynomial := true;
//       end if;
//     elseif abs(y1d + y0d + -2.0 * Delta0) < 1e-013 then
//       aux02 := 1e+060 * (6.0 * Delta0 * (y1d + y0d + -1.5 * Delta0) + -y1d * y0d + -y1d ^ 2.0 - y0d ^ 2.0) * if y1d + y0d + -2.0 * Delta0 >= 0.0 then 1.0 else -1.0;
//     else
//       aux02 := (6.0 * Delta0 * (y1d + y0d + -1.5 * Delta0) + -y1d * y0d + -y1d ^ 2.0 - y0d ^ 2.0) / (y1d + y0d + -2.0 * Delta0 * 3.0);
//     end if;
//     if mu > 0.0 and eta < h0 and Delta0 * omega <= 0.0 or abs(aux01) < abs(aux02) and aux02 * Delta0 >= 0.0 or abs(aux01) < abs(0.1 * Delta0) and not useSingleCubicPolynomial then
//       c := aux01;
//       if abs(c) < abs(aux02) and aux02 * Delta0 >= 0.0 then
//         c := aux02;
//       end if;
//       if abs(c) < abs(0.1 * Delta0) then
//         c := 0.1 * Delta0;
//       end if;
//       theta0 := (y0d * mu + y1d * eta) / h0;
//       if abs(theta0 - c) < 1e-006 then
//         c := 0.999999 * theta0;
//       end if;
//       rho := (3.0 * (Delta0 - c)) / (theta0 - c);
//       mu_tilde := rho * mu;
//       eta_tilde := rho * eta;
//       xi1 := x0 + mu_tilde;
//       xi2 := x1 - eta_tilde;
//       a1 := (y0d - c) / max(mu_tilde ^ 2.0,1e-013);
//       a2 := (y1d - c) / max(eta_tilde ^ 2.0,1e-013);
//       const12 := y0 + (-(x0 - xi1) ^ 3.0 * a1) / 3.0 - c * x0;
//       const3 := y1 + (-(x1 - xi2) ^ 3.0 * a2) / 3.0 - c * x1;
//       if x < xi1 then
//         y := ((x - xi1) ^ 3.0 * a1) / 3.0 + c * x + const12;
//       elseif x < xi2 then
//         y := c * x + const12;
//       else
//         y := ((x - xi2) ^ 3.0 * a2) / 3.0 + c * x + const3;
//       end if;
//     else
//       y := (y0d + y1d + -2.0 * Delta0) * (x - x0) ^ 3.0 * h0 ^ -2.0 + (-2.0 * y0d + 3.0 * Delta0 - y1d * (x - x0) ^ 2.0) / h0 + y0d * (x - x0) + y0;
//       aux01 := x0 / 2.0 + x1 / 2.0;
//       c := 3.0 * (y0d + y1d + -2.0 * Delta0) * (aux01 - x0) ^ 2.0 * h0 ^ -2.0 + (2.0 * (-2.0 * y0d + 3.0 * Delta0 - y1d) * (aux01 - x0)) / h0 + y0d;
//     end if;
//   end if;
// end Modelica.Fluid.Utilities.regFun3;
// 
// function Modelica.Fluid.Utilities.regRoot \"Anti-symmetric square root approximation with finite derivative in the origin\"
//   input Real x;
//   input Real delta = 0.01 \"Range of significant deviation from sqrt(abs(x))*sgn(x)\";
//   output Real y;
// algorithm
//   y := x * (x ^ 2.0 + delta ^ 2.0) ^ -0.25;
// end Modelica.Fluid.Utilities.regRoot;
// 
// function Modelica.Fluid.Utilities.regRoot_der \"Derivative of regRoot\"
//   input Real x;
//   input Real delta = 0.01 \"Range of significant deviation from sqrt(x)\";
//   input Real dx \"Derivative of x\";
//   output Real dy;
// algorithm
//   dy := 0.5 * dx * (x ^ 2.0 + 2.0 * delta ^ 2.0) * (x ^ 2.0 + delta ^ 2.0) ^ -1.25;
// end Modelica.Fluid.Utilities.regRoot_der;
// 
// function Modelica.Fluid.Utilities.regSquare2 \"Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous\"
//   input Real x \"abscissa value\";
//   input Real x_small(min = 0.0) = 0.01 \"approximation of function for |x| <= x_small\";
//   input Real k1(min = 0.0) = 1.0 \"y = (if x>=0 then k1 else k2)*x*|x|\";
//   input Real k2(min = 0.0) = 1.0 \"y = (if x>=0 then k1 else k2)*x*|x|\";
//   input Boolean use_yd0 = false \"= true, if yd0 shall be used\";
//   input Real yd0(min = 0.0) = 1.0 \"Desired derivative at x=0: dy/dx = yd0\";
//   output Real y \"ordinate value\";
// algorithm
//   y := smooth(2,if x >= x_small then k1 * x ^ 2.0 else if x <= -x_small then -k2 * x ^ 2.0 else if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x,x_small,k1,k2,use_yd0,yd0) else -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(-x,x_small,k2,k1,use_yd0,yd0));
// end Modelica.Fluid.Utilities.regSquare2;
// 
// function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility \"Interpolating with two 3-order polynomials with a prescribed derivative at x=0\"
//   input Real x;
//   input Real x1 \"approximation of function abs(x) < x1\";
//   input Real k1 \"y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2\";
//   input Real k2 \"y = (if x>=0 then k1 else -k2)*x*|x|\";
//   input Boolean use_yd0 = false \"= true, if yd0 shall be used\";
//   input Real yd0(min = 0.0) = 1.0 \"Desired derivative at x=0: dy/dx = yd0\";
//   output Real y;
//   protected Real x2;
//   protected Real y1;
//   protected Real y2;
//   protected Real y1d;
//   protected Real y2d;
//   protected Real w;
//   protected Real w1;
//   protected Real w2;
//   protected Real y0d;
// algorithm
//   x2 := -x1;
//   if x <= x2 then
//     y := -k2 * x ^ 2.0;
//   else
//     y1 := k1 * x1 ^ 2.0;
//     y2 := -k2 * x2 ^ 2.0;
//     y1d := 2.0 * k1 * x1;
//     y2d := -2.0 * k2 * x2;
//     if use_yd0 then
//       y0d := yd0;
//     else
//       w := x2 / x1;
//       y0d := ((3.0 * y2 - x2 * y2d) / w - (3.0 * y1 - x1 * y1d) * w) / ((1.0 - w) * x1 * 2.0);
//     end if;
//     w1 := 2.23606797749979 * k1 * x1;
//     w2 := 2.23606797749979 * k2 * abs(x2);
//     y0d := min(y0d,0.9 * min(w1,w2));
//     y := if x >= 0.0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x,x1,y1,y1d,y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x,x2,y2,y2d,y0d);
//   end if;
// end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;
// 
// function Modelica.Fluid.Utilities.regStep \"Approximation of a general step, such that the characteristic is continuous and differentiable\"
//   input Real x \"Abscissa value\";
//   input Real y1 \"Ordinate value for x > 0\";
//   input Real y2 \"Ordinate value for x < 0\";
//   input Real x_small(min = 0.0) = 1e-005 \"Approximation of step for -x_small <= x <= x_small; x_small > 0 required\";
//   output Real y \"Ordinate value to approximate y = if x > 0 then y1 else y2\";
// algorithm
//   y := smooth(1,if x > x_small then y1 else if x < -x_small then y2 else if abs(x_small) > 0.0 then (y2 - y1 * (-3.0 + (x / x_small) ^ 2.0) * x) / (x_small * 4.0) + y1 / 2.0 + y2 / 2.0 else y1 / 2.0 + y2 / 2.0);
// end Modelica.Fluid.Utilities.regStep;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.density \"return density of ideal gas\"
//   input Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.density;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pT;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Valves.ValveIncompressible.Medium.density(Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_pTX(p,T,X,0));
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pTX;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p,h,phase,0);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.density_ph;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState(1,Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_pTX;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX \"Return thermodynamic state of water as function of p and h\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState(0,h,Modelica.Fluid.Valves.ValveIncompressible.Medium.density_ph(p,h,0),Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature_ph(p,h,0),p);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy(Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Valves.ValveIncompressible.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p,h,phase,0);
// end Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature_ph;
// 
// function Modelica.Fluid.Valves.ValveIncompressible.valveCharacteristic \"Linear characteristic\"
//   input Real pos \"Opening position (per unit)\";
//   output Real rc \"Relative flow coefficient (per unit)\";
// algorithm
//   rc := pos;
// end Modelica.Fluid.Valves.ValveIncompressible.valveCharacteristic;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.density_pT;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState(1,Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.setState_pTX;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy(Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Vessels.BaseClasses.VesselPortsData \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselPortsData\"
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") diameter;
//   input Real(min=0.0, quantity=\"Length\", unit=\"m\") height = 0.0;
//   input Real(min=0.0) zeta_out = 0.5;
//   input Real(min=0.0) zeta_in = 1.04;
//   output VesselPortsData res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselPortsData;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.density_pT;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState(1,Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.setState_pTX;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy(Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.temperature;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.SaturationProperties \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank.Medium.SaturationProperties\"
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") psat;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") Tsat;
//   output SaturationProperties res;
// end Modelica.Fluid.Vessels.OpenTank.Medium.SaturationProperties;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   input Real(min=-100000000.0, max=100000000.0, nominal=1000000.0, quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(min=0.0, max=100000.0, nominal=1.0, start=1.0, quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\") d;
//   input Real(min=1.0, max=10000.0, nominal=300.0, start=300.0, quantity=\"ThermodynamicTemperature\", unit=\"K\", displayUnit=\"degC\") T;
//   input Real(min=0.0, max=100000000.0, nominal=100000.0, start=100000.0, quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.bubbleEnthalpy \"boiling curve specific enthalpy of water\"
//   input Modelica.Fluid.Vessels.OpenTank.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"boiling curve specific enthalpy\";
// algorithm
//   hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(sat.psat);
// end Modelica.Fluid.Vessels.OpenTank.Medium.bubbleEnthalpy;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.density \"return density of ideal gas\"
//   input Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := state.d;
// end Modelica.Fluid.Vessels.OpenTank.Medium.density;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.density_pT \"Computes density as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_pT(p,T,0);
// end Modelica.Fluid.Vessels.OpenTank.Medium.density_pT;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.density_ph \"Computes density as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Media.Water.IF97_Utilities.rho_ph(p,h,phase,0);
// end Modelica.Fluid.Vessels.OpenTank.Medium.density_ph;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.dewEnthalpy \"dew curve specific enthalpy of water\"
//   input Modelica.Fluid.Vessels.OpenTank.Medium.SaturationProperties sat \"saturation property record\";
//   output Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"dew curve specific enthalpy\";
// algorithm
//   hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(sat.psat);
// end Modelica.Fluid.Vessels.OpenTank.Medium.dewEnthalpy;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.saturationTemperature \"saturation temperature of water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
// end Modelica.Fluid.Vessels.OpenTank.Medium.saturationTemperature;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.setState_pTX \"Return thermodynamic state of water as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState(1,Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pT(p,T,0),Modelica.Fluid.Vessels.OpenTank.Medium.density_pT(p,T,0),T,p);
// end Modelica.Fluid.Vessels.OpenTank.Medium.setState_pTX;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.setState_phX \"Return thermodynamic state of water as function of p and h\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState(0,h,Modelica.Fluid.Vessels.OpenTank.Medium.density_ph(p,h,0),Modelica.Fluid.Vessels.OpenTank.Medium.temperature_ph(p,h,0),p);
// end Modelica.Fluid.Vessels.OpenTank.Medium.setState_phX;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := state.h;
// end Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pT \"Computes specific enthalpy as a function of pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_pT(p,T,0);
// end Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pT;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pTX \"Return specific enthalpy from pressure, temperature and mass fraction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy at p, T, X\";
// algorithm
//   h := Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy(Modelica.Fluid.Vessels.OpenTank.Medium.setState_pTX(p,T,{X[1]},phase));
// end Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pTX;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.temperature \"return temperature of ideal gas\"
//   input Modelica.Fluid.Vessels.OpenTank.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Vessels.OpenTank.Medium.temperature;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.temperature_ph \"Computes temperature as a function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_ph(p,h,phase,0);
// end Modelica.Fluid.Vessels.OpenTank.Medium.temperature_ph;
// 
// function Modelica.Fluid.Vessels.OpenTank.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := Modelica.Fluid.Vessels.OpenTank.Medium.temperature(Modelica.Fluid.Vessels.OpenTank.Medium.setState_phX(p,h,{X[1]},phase));
// end Modelica.Fluid.Vessels.OpenTank.Medium.temperature_phX;
// 
// function Modelica.Math.Matrices.LAPACK.dgesv_vec
//   input Real[:, :] A;
//   input Real[size(A,1)] b;
//   output Real[size(A,1)] x = b;
//   output Integer info;
//   protected Integer[size(A,1)] ipiv;
//   protected Real[size(A,1), size(A,1)] Awork = A;
// 
//   external \"FORTRAN 77\" dgesv(size(A, 1), 1, Awork, size(A, 1), ipiv, x, size(A, 1), info);
// end Modelica.Math.Matrices.LAPACK.dgesv_vec;
// 
// function Modelica.Math.Matrices.solve \"Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)\"
//   input Real[:, :] A \"Matrix A of A*x = b\";
//   input Real[size(A,1)] b \"Vector b of A*x = b\";
//   output Real[size(b,1)] x \"Vector x such that A*x = b\";
//   protected Integer info;
// algorithm
//   (x, info) := Modelica.Math.Matrices.LAPACK.dgesv_vec(A,b);
//   assert( info == 0, \"Solving a linear system of equations with function
// \\\"Matrices.solve\\\" is not possible, because the system has either
// no or infinitely many solutions (A is singular).\");
// end Modelica.Math.Matrices.solve;
// 
// function Modelica.Math.acos
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = acos(u);
// end Modelica.Math.acos;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.exp
//   input Real u;
//   output Real y;
// 
//   external \"C\" y = exp(u);
// end Modelica.Math.exp;
// 
// function Modelica.Math.log
//   input Real u;
//   output Real y;
// 
//   external \"C\" y = log(u);
// end Modelica.Math.log;
// 
// function Modelica.Math.log10
//   input Real u;
//   output Real y;
// 
//   external \"C\" y = log10(u);
// end Modelica.Math.log10;
// 
// function Modelica.Media.Common.GibbsDerivs \"Automatically generated record constructor for Modelica.Media.Common.GibbsDerivs\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=0.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(unit=\"1\") pi;
//   input Real(unit=\"1\") tau;
//   input Real(unit=\"1\") g;
//   input Real(unit=\"1\") gpi;
//   input Real(unit=\"1\") gpipi;
//   input Real(unit=\"1\") gtau;
//   input Real(unit=\"1\") gtautau;
//   input Real(unit=\"1\") gtaupi;
//   output GibbsDerivs res;
// end Modelica.Media.Common.GibbsDerivs;
// 
// function Modelica.Media.Common.HelmholtzDerivs \"Automatically generated record constructor for Modelica.Media.Common.HelmholtzDerivs\"
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.0) d;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=0.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(unit=\"1\") delta;
//   input Real(unit=\"1\") tau;
//   input Real(unit=\"1\") f;
//   input Real(unit=\"1\") fdelta;
//   input Real(unit=\"1\") fdeltadelta;
//   input Real(unit=\"1\") ftau;
//   input Real(unit=\"1\") ftautau;
//   input Real(unit=\"1\") fdeltatau;
//   output HelmholtzDerivs res;
// end Modelica.Media.Common.HelmholtzDerivs;
// 
// function Modelica.Media.Common.Helmholtz_pT \"function to calculate analytic derivatives for computing d and t given p and t\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.NewtonDerivatives_pT nderivs \"derivatives for Newton iteration to compute d and t from p and t\";
// algorithm
//   nderivs.p := f.d * f.R * f.T * f.delta * f.fdelta;
//   nderivs.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
// end Modelica.Media.Common.Helmholtz_pT;
// 
// function Modelica.Media.Common.Helmholtz_ph \"function to calculate analytic derivatives for computing d and t given p and h\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.NewtonDerivatives_ph nderivs \"derivatives for Newton iteration to calculate d and t from p and h\";
//   protected Real cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"isochoric heat capacity\";
// algorithm
//   cv := -f.R * f.tau ^ 2.0 * f.ftautau;
//   nderivs.p := f.d * f.R * f.T * f.delta * f.fdelta;
//   nderivs.h := f.R * f.T * (f.tau * f.ftau + f.delta * f.fdelta);
//   nderivs.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   nderivs.pt := f.R * f.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//   nderivs.ht := cv + nderivs.pt / f.d;
//   nderivs.hd := (nderivs.pd + (-f.T * nderivs.pt) / f.d) / f.d;
// end Modelica.Media.Common.Helmholtz_ph;
// 
// function Modelica.Media.Common.IF97BaseTwoPhase \"Automatically generated record constructor for Modelica.Media.Common.IF97BaseTwoPhase\"
//   input Integer phase = 0;
//   input Integer(min=1, max=5) region;
//   input Real(quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=0.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.0) rho;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\") s;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real vt;
//   input Real vp;
//   input Real x;
//   input Real dpT;
//   output IF97BaseTwoPhase res;
// end Modelica.Media.Common.IF97BaseTwoPhase;
// 
// function Modelica.Media.Common.IF97PhaseBoundaryProperties \"Automatically generated record constructor for Modelica.Media.Common.IF97PhaseBoundaryProperties\"
//   input Boolean region3boundary;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") R;
//   input Real(quantity=\"ThermodynamicTemperature\", unit=\"K\", min=0.0, displayUnit=\"degC\") T;
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.0) d;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\") s;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") dpT;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real(unit=\"m3/(kg.K)\") vt;
//   input Real(unit=\"m3/(kg.Pa)\") vp;
//   output IF97PhaseBoundaryProperties res;
// end Modelica.Media.Common.IF97PhaseBoundaryProperties;
// 
// function Modelica.Media.Common.NewtonDerivatives_pT \"Automatically generated record constructor for Modelica.Media.Common.NewtonDerivatives_pT\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   output NewtonDerivatives_pT res;
// end Modelica.Media.Common.NewtonDerivatives_pT;
// 
// function Modelica.Media.Common.NewtonDerivatives_ph \"Automatically generated record constructor for Modelica.Media.Common.NewtonDerivatives_ph\"
//   input Real(quantity=\"Pressure\", unit=\"Pa\", displayUnit=\"bar\") p;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real hd;
//   input Real ht;
//   output NewtonDerivatives_ph res;
// end Modelica.Media.Common.NewtonDerivatives_ph;
// 
// function Modelica.Media.Common.PhaseBoundaryProperties \"Automatically generated record constructor for Modelica.Media.Common.PhaseBoundaryProperties\"
//   input Real(quantity=\"Density\", unit=\"kg/m3\", displayUnit=\"g/cm3\", min=0.0) d;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\") h;
//   input Real(quantity=\"SpecificEnergy\", unit=\"J/kg\") u;
//   input Real(quantity=\"SpecificEntropy\", unit=\"J/(kg.K)\") s;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cp;
//   input Real(quantity=\"SpecificHeatCapacity\", unit=\"J/(kg.K)\") cv;
//   input Real(quantity=\"DerPressureByTemperature\", unit=\"Pa/K\") pt;
//   input Real(quantity=\"DerPressureByDensity\", unit=\"Pa.m3/kg\") pd;
//   output PhaseBoundaryProperties res;
// end Modelica.Media.Common.PhaseBoundaryProperties;
// 
// function Modelica.Media.Common.cv2Phase \"compute isochoric specific heat capacity inside the two-phase region\"
//   input Modelica.Media.Common.PhaseBoundaryProperties liq \"properties on the boiling curve\";
//   input Modelica.Media.Common.PhaseBoundaryProperties vap \"properties on the condensation curve\";
//   input Real x(quantity = \"MassFraction\", unit = \"1\") \"vapour mass fraction\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"preoperties\";
//   output Real cv(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\") \"isochoric specific heat capacity\";
//   protected Real dpT \"derivative of pressure w.r.t. temperature\";
//   protected Real dxv \"derivative of vapour mass fraction w.r.t. specific volume\";
//   protected Real dvTl \"derivative of liquid specific volume w.r.t. temperature\";
//   protected Real dvTv \"derivative of vapour specific volume w.r.t. temperature\";
//   protected Real duTl \"derivative of liquid specific inner energy w.r.t. temperature\";
//   protected Real duTv \"derivative of vapour specific inner energy w.r.t. temperature\";
//   protected Real dxt \"derivative of vapour mass fraction w.r.t. temperature\";
// algorithm
//   dxv := if liq.d <> vap.d then (liq.d * vap.d) / (liq.d - vap.d) else 0.0;
//   dpT := (vap.s - liq.s) * dxv;
//   dvTl := (liq.pt - dpT * liq.d ^ -2.0) / liq.pd;
//   dvTv := (vap.pt - dpT * vap.d ^ -2.0) / vap.pd;
//   dxt := -dxv * (dvTl + x * (dvTv - dvTl));
//   duTl := liq.cv + (T * liq.pt - p) * dvTl;
//   duTv := vap.cv + (T * vap.pt - p) * dvTv;
//   cv := duTl + x * (duTv - duTl) + dxt * (vap.u - liq.u);
// end Modelica.Media.Common.cv2Phase;
// 
// function Modelica.Media.Common.gibbsToBoundaryProps \"calulate phase boundary property record from dimensionless Gibbs function\"
//   input Modelica.Media.Common.GibbsDerivs g \"dimensionless derivatives of Gibbs function\";
//   output Modelica.Media.Common.PhaseBoundaryProperties sat \"phase boundary properties\";
//   protected Real vt \"derivative of specific volume w.r.t. temperature\";
//   protected Real vp \"derivative of specific volume w.r.t. pressure\";
// algorithm
//   sat.d := g.p / (g.gpi * g.pi * g.T * g.R);
//   sat.h := g.R * g.T * g.tau * g.gtau;
//   sat.u := g.T * g.R * (g.tau * g.gtau - g.pi * g.gpi);
//   sat.s := g.R * (g.tau * g.gtau - g.g);
//   sat.cp := -g.R * g.tau ^ 2.0 * g.gtautau;
//   sat.cv := g.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//   vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * g.R) / g.p;
//   vp := g.R * g.T * g.p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//   sat.pt := (g.tau * g.gtaupi - g.gpi * g.p) / (g.pi * g.gpipi * g.T);
//   sat.pd := (-g.R * g.T * g.gpi ^ 2.0) / g.gpipi;
// end Modelica.Media.Common.gibbsToBoundaryProps;
// 
// function Modelica.Media.Common.helmholtzToBoundaryProps \"calulate phase boundary property record from dimensionless Helmholtz function\"
//   input Modelica.Media.Common.HelmholtzDerivs f \"dimensionless derivatives of Helmholtz function\";
//   output Modelica.Media.Common.PhaseBoundaryProperties sat \"phase boundary property record\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
// algorithm
//   p := f.R * f.d * f.T * f.delta * f.fdelta;
//   sat.d := f.d;
//   sat.h := f.R * f.T * (f.tau * f.ftau + f.delta * f.fdelta);
//   sat.s := f.R * (f.tau * f.ftau - f.f);
//   sat.u := f.R * f.T * f.tau * f.ftau;
//   sat.cp := f.R * (-f.tau ^ 2.0 * f.ftautau + (f.delta * (f.fdelta - f.tau * f.fdeltatau)) ^ 2.0 / (2.0 * f.delta * f.fdelta + f.delta ^ 2.0 * f.fdeltadelta));
//   sat.cv := f.R * -f.tau ^ 2.0 * f.ftautau;
//   sat.pt := f.R * f.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//   sat.pd := f.R * f.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
// end Modelica.Media.Common.helmholtzToBoundaryProps;
// 
// function Modelica.Media.Interfaces.PartialMedium.ThermodynamicState \"Automatically generated record constructor for Modelica.Media.Interfaces.PartialMedium.ThermodynamicState\"
//   output ThermodynamicState res;
// end Modelica.Media.Interfaces.PartialMedium.ThermodynamicState;
// 
// function Modelica.Media.Interfaces.PartialMedium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Media.Interfaces.PartialMedium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Media.Interfaces.PartialMedium.setState_pTX;
// 
// function Modelica.Media.Interfaces.PartialMedium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Media.Interfaces.PartialMedium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Media.Interfaces.PartialMedium.specificEnthalpy;
// 
// function Modelica.Media.Interfaces.PartialMedium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Media.Interfaces.PartialMedium.specificEnthalpy(Modelica.Media.Interfaces.PartialMedium.setState_pTX(p,T,X));
// end Modelica.Media.Interfaces.PartialMedium.specificEnthalpy_pTX;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState \"Automatically generated record constructor for Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState\"
//   input Integer(min=0, max=2) phase;
//   output ThermodynamicState res;
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState state \"thermodynamic state record\";
//   input Integer phase(min = 0, max = 2) = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy \"Return specific enthalpy\"
//   input Modelica.Media.Interfaces.PartialTwoPhaseMedium.ThermodynamicState state \"thermodynamic state record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy;
// 
// function Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy(Modelica.Media.Interfaces.PartialTwoPhaseMedium.setState_pTX(p,T,X,0));
// end Modelica.Media.Interfaces.PartialTwoPhaseMedium.specificEnthalpy_pTX;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph \"Region 3 a: inverse function T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature\";
//   protected constant Real[31] n = {-1.33645667811215e-007,4.55912656802978e-006,-1.46294640700979e-005,0.0063934131297008,372.783927268847,-7186.54377460447,573494.7521034,-2675693.29111439,-3.34066283302614e-005,-0.0245479214069597,47.8087847764996,7.64664131818904e-006,0.00128350627676972,0.0171219081377331,-8.51007304583213,-0.0136513461629781,-3.84460997596657e-006,0.00337423807911655,-0.551624873066791,0.72920227710747,-0.00992522757376041,-0.119308831407288,0.793929190615421,0.454270731799386,0.20999859125991,-0.00642109823904738,-0.023515586860454,0.00252233108341612,-0.00764885133368119,0.0136176427574291,-0.0133027883575669};
//   protected constant Real[31] I = {-12.0,-12.0,-12.0,-12.0,-12.0,-12.0,-12.0,-12.0,-10.0,-10.0,-10.0,-8.0,-8.0,-8.0,-8.0,-5.0,-3.0,-2.0,-2.0,-2.0,-1.0,-1.0,0.0,0.0,1.0,3.0,3.0,4.0,4.0,10.0,12.0};
//   protected constant Real[31] J = {0.0,1.0,2.0,6.0,14.0,16.0,20.0,22.0,1.0,5.0,12.0,0.0,2.0,4.0,10.0,2.0,0.0,1.0,3.0,4.0,0.0,2.0,0.0,1.0,1.0,0.0,1.0,0.0,3.0,4.0,5.0};
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\") = 2300000.0 \"normalization enthalpy\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 100000000.0 \"normalization pressure\";
//   protected constant Real Tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 760.0 \"normalization temperature\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2300000.0 \"normalized specific enthalpy\";
// algorithm
//   T := 760.0 * (n[1] * (0.24 + pi) ^ I[1] * (-0.615 + eta) ^ J[1] + n[2] * (0.24 + pi) ^ I[2] * (-0.615 + eta) ^ J[2] + n[3] * (0.24 + pi) ^ I[3] * (-0.615 + eta) ^ J[3] + n[4] * (0.24 + pi) ^ I[4] * (-0.615 + eta) ^ J[4] + n[5] * (0.24 + pi) ^ I[5] * (-0.615 + eta) ^ J[5] + n[6] * (0.24 + pi) ^ I[6] * (-0.615 + eta) ^ J[6] + n[7] * (0.24 + pi) ^ I[7] * (-0.615 + eta) ^ J[7] + n[8] * (0.24 + pi) ^ I[8] * (-0.615 + eta) ^ J[8] + n[9] * (0.24 + pi) ^ I[9] * (-0.615 + eta) ^ J[9] + n[10] * (0.24 + pi) ^ I[10] * (-0.615 + eta) ^ J[10] + n[11] * (0.24 + pi) ^ I[11] * (-0.615 + eta) ^ J[11] + n[12] * (0.24 + pi) ^ I[12] * (-0.615 + eta) ^ J[12] + n[13] * (0.24 + pi) ^ I[13] * (-0.615 + eta) ^ J[13] + n[14] * (0.24 + pi) ^ I[14] * (-0.615 + eta) ^ J[14] + n[15] * (0.24 + pi) ^ I[15] * (-0.615 + eta) ^ J[15] + n[16] * (0.24 + pi) ^ I[16] * (-0.615 + eta) ^ J[16] + n[17] * (0.24 + pi) ^ I[17] * (-0.615 + eta) ^ J[17] + n[18] * (0.24 + pi) ^ I[18] * (-0.615 + eta) ^ J[18] + n[19] * (0.24 + pi) ^ I[19] * (-0.615 + eta) ^ J[19] + n[20] * (0.24 + pi) ^ I[20] * (-0.615 + eta) ^ J[20] + n[21] * (0.24 + pi) ^ I[21] * (-0.615 + eta) ^ J[21] + n[22] * (0.24 + pi) ^ I[22] * (-0.615 + eta) ^ J[22] + n[23] * (0.24 + pi) ^ I[23] * (-0.615 + eta) ^ J[23] + n[24] * (0.24 + pi) ^ I[24] * (-0.615 + eta) ^ J[24] + n[25] * (0.24 + pi) ^ I[25] * (-0.615 + eta) ^ J[25] + n[26] * (0.24 + pi) ^ I[26] * (-0.615 + eta) ^ J[26] + n[27] * (0.24 + pi) ^ I[27] * (-0.615 + eta) ^ J[27] + n[28] * (0.24 + pi) ^ I[28] * (-0.615 + eta) ^ J[28] + n[29] * (0.24 + pi) ^ I[29] * (-0.615 + eta) ^ J[29] + n[30] * (0.24 + pi) ^ I[30] * (-0.615 + eta) ^ J[30] + n[31] * (0.24 + pi) ^ I[31] * (-0.615 + eta) ^ J[31]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph \"Region 3 b: inverse function T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature\";
//   protected constant Real[33] n = {3.2325457364492e-005,-0.000127575556587181,-0.000475851877356068,0.00156183014181602,0.105724860113781,-85.8514221132534,724.140095480911,0.00296475810273257,-0.00592721983365988,-0.0126305422818666,-0.115716196364853,84.9000969739595,-0.0108602260086615,0.0154304475328851,0.0750455441524466,0.0252520973612982,-0.0602507901232996,-3.07622221350501,-0.0574011959864879,5.03471360939849,-0.925081888584834,3.91733882917546,-77.314600713019,9493.08762098587,-1410437.19679409,8491662.30819026,0.861095729446704,0.32334644281172,0.873281936020439,-0.436653048526683,0.286596714529479,-0.131778331276228,0.00676682064330275};
//   protected constant Real[33] I = {-12.0,-12.0,-10.0,-10.0,-10.0,-10.0,-10.0,-8.0,-8.0,-8.0,-8.0,-8.0,-6.0,-6.0,-6.0,-4.0,-4.0,-3.0,-2.0,-2.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,0.0,0.0,1.0,3.0,5.0,6.0,8.0};
//   protected constant Real[33] J = {0.0,1.0,0.0,1.0,5.0,10.0,12.0,0.0,1.0,2.0,4.0,10.0,0.0,1.0,2.0,0.0,1.0,5.0,0.0,4.0,2.0,4.0,6.0,10.0,14.0,16.0,0.0,2.0,1.0,1.0,1.0,1.0,1.0};
//   protected constant Real Tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 860.0 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\") = 2800000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2800000.0 \"normalized specific enthalpy\";
// algorithm
//   T := 860.0 * (n[1] * (0.298 + pi) ^ I[1] * (-0.72 + eta) ^ J[1] + n[2] * (0.298 + pi) ^ I[2] * (-0.72 + eta) ^ J[2] + n[3] * (0.298 + pi) ^ I[3] * (-0.72 + eta) ^ J[3] + n[4] * (0.298 + pi) ^ I[4] * (-0.72 + eta) ^ J[4] + n[5] * (0.298 + pi) ^ I[5] * (-0.72 + eta) ^ J[5] + n[6] * (0.298 + pi) ^ I[6] * (-0.72 + eta) ^ J[6] + n[7] * (0.298 + pi) ^ I[7] * (-0.72 + eta) ^ J[7] + n[8] * (0.298 + pi) ^ I[8] * (-0.72 + eta) ^ J[8] + n[9] * (0.298 + pi) ^ I[9] * (-0.72 + eta) ^ J[9] + n[10] * (0.298 + pi) ^ I[10] * (-0.72 + eta) ^ J[10] + n[11] * (0.298 + pi) ^ I[11] * (-0.72 + eta) ^ J[11] + n[12] * (0.298 + pi) ^ I[12] * (-0.72 + eta) ^ J[12] + n[13] * (0.298 + pi) ^ I[13] * (-0.72 + eta) ^ J[13] + n[14] * (0.298 + pi) ^ I[14] * (-0.72 + eta) ^ J[14] + n[15] * (0.298 + pi) ^ I[15] * (-0.72 + eta) ^ J[15] + n[16] * (0.298 + pi) ^ I[16] * (-0.72 + eta) ^ J[16] + n[17] * (0.298 + pi) ^ I[17] * (-0.72 + eta) ^ J[17] + n[18] * (0.298 + pi) ^ I[18] * (-0.72 + eta) ^ J[18] + n[19] * (0.298 + pi) ^ I[19] * (-0.72 + eta) ^ J[19] + n[20] * (0.298 + pi) ^ I[20] * (-0.72 + eta) ^ J[20] + n[21] * (0.298 + pi) ^ I[21] * (-0.72 + eta) ^ J[21] + n[22] * (0.298 + pi) ^ I[22] * (-0.72 + eta) ^ J[22] + n[23] * (0.298 + pi) ^ I[23] * (-0.72 + eta) ^ J[23] + n[24] * (0.298 + pi) ^ I[24] * (-0.72 + eta) ^ J[24] + n[25] * (0.298 + pi) ^ I[25] * (-0.72 + eta) ^ J[25] + n[26] * (0.298 + pi) ^ I[26] * (-0.72 + eta) ^ J[26] + n[27] * (0.298 + pi) ^ I[27] * (-0.72 + eta) ^ J[27] + n[28] * (0.298 + pi) ^ I[28] * (-0.72 + eta) ^ J[28] + n[29] * (0.298 + pi) ^ I[29] * (-0.72 + eta) ^ J[29] + n[30] * (0.298 + pi) ^ I[30] * (-0.72 + eta) ^ J[30] + n[31] * (0.298 + pi) ^ I[31] * (-0.72 + eta) ^ J[31] + n[32] * (0.298 + pi) ^ I[32] * (-0.72 + eta) ^ J[32] + n[33] * (0.298 + pi) ^ I[33] * (-0.72 + eta) ^ J[33]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT \"derivative of pressure wrt temperature along the saturation pressure curve\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real dpt(unit = \"Pa/K\") \"temperature derivative of pressure\";
//   protected Real[31] o \"vector of auxiliary variables\";
//   protected Real Tlim \"temeprature limited to TCRIT\";
// algorithm
//   Tlim := min(T,647.096);
//   o[1] := -650.17534844798 + Tlim;
//   o[2] := 1.0 / o[1];
//   o[3] := -0.23855557567849 * o[2];
//   o[4] := o[3] + Tlim;
//   o[5] := -4823.2657361591 * o[4];
//   o[6] := o[4] ^ 2.0;
//   o[7] := 14.91510861353 * o[6];
//   o[8] := 405113.40542057 + o[5] + o[7];
//   o[9] := o[8] ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[1] ^ 2.0;
//   o[12] := 1.0 / o[11];
//   o[13] := 0.23855557567849 * o[12];
//   o[14] := 1.0 + o[13];
//   o[15] := 12020.82470247 * o[4];
//   o[16] := -17.073846940092 * o[6];
//   o[17] := -3232555.0322333 + o[15] + o[16];
//   o[18] := -4823.2657361591 * o[14];
//   o[19] := 29.83021722706 * o[14] * o[4];
//   o[20] := o[18] + o[19];
//   o[21] := 1167.0521452767 * o[4];
//   o[22] := -724213.16703206 + o[21] + o[6];
//   o[23] := o[17] ^ 2.0;
//   o[24] := -4.0 * o[22] * o[8];
//   o[25] := o[23] + o[24];
//   o[26] := sqrt(o[25]);
//   o[27] := -12020.82470247 * o[4];
//   o[28] := 17.073846940092 * o[6];
//   o[29] := 3232555.0322333 + o[26] + o[27] + o[28];
//   o[30] := o[29] ^ 2.0;
//   o[31] := o[30] ^ 2.0;
//   dpt := 1000000.0 * ((-64.0 * o[10] * (-12020.82470247 * o[14] + 34.147693880184 * o[14] * o[4] + (0.5 * (-4.0 * o[20] * o[22] + 2.0 * o[17] * (12020.82470247 * o[14] + -34.147693880184 * o[14] * o[4]) + -4.0 * (1167.0521452767 * o[14] + 2.0 * o[14] * o[4]) * o[8])) / o[26])) / (o[31] * o[29]) + (64.0 * o[20] * o[8] * o[9]) / o[31]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp \"derivative of saturation temperature w.r.t. pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real dtsat(unit = \"K/Pa\") \"derivative of T w.r.t. p\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[49] o \"vector of auxiliary variables\";
// algorithm
//   pi := max(1e-060,1e-006 * p);
//   o[1] := pi ^ 0.75;
//   o[2] := 1.0 / o[1];
//   o[3] := -4.268461735023 * o[2];
//   o[4] := sqrt(pi);
//   o[5] := 1.0 / o[4];
//   o[6] := 0.5 * o[5];
//   o[7] := o[3] + o[6];
//   o[8] := pi ^ 0.25;
//   o[9] := -3232555.0322333 * o[8];
//   o[10] := -724213.16703206 * o[4];
//   o[11] := 405113.40542057 + o[10] + o[9];
//   o[12] := -4.0 * o[11] * o[7];
//   o[13] := -808138.758058325 * o[2];
//   o[14] := -362106.58351603 * o[5];
//   o[15] := o[13] + o[14];
//   o[16] := -17.073846940092 * o[8];
//   o[17] := 14.91510861353 + o[16] + o[4];
//   o[18] := -4.0 * o[15] * o[17];
//   o[19] := 3005.2061756175 * o[2];
//   o[20] := 583.52607263835 * o[5];
//   o[21] := o[19] + o[20];
//   o[22] := 12020.82470247 * o[8];
//   o[23] := 1167.0521452767 * o[4];
//   o[24] := -4823.2657361591 + o[22] + o[23];
//   o[25] := 2.0 * o[21] * o[24];
//   o[26] := o[12] + o[18] + o[25];
//   o[27] := -4.0 * o[11] * o[17];
//   o[28] := o[24] ^ 2.0;
//   o[29] := o[27] + o[28];
//   o[30] := sqrt(o[29]);
//   o[31] := 1.0 / o[30];
//   o[32] := -o[30];
//   o[33] := -12020.82470247 * o[8];
//   o[34] := -1167.0521452767 * o[4];
//   o[35] := 4823.2657361591 + o[32] + o[33] + o[34];
//   o[36] := o[30];
//   o[37] := -4823.2657361591 + o[22] + o[23] + o[36];
//   o[38] := o[37] ^ 2.0;
//   o[39] := 1.0 / o[38];
//   o[40] := -1.72207339365771 * o[30];
//   o[41] := 21592.2055343628 * o[8];
//   o[42] := o[30] * o[8];
//   o[43] := -8192.87114842946 * o[4];
//   o[44] := -0.510632954559659 * o[30] * o[4];
//   o[45] := -3100.02526152368 * o[1];
//   o[46] := pi;
//   o[47] := 1295.95640782102 * o[46];
//   o[48] := 2862.09212505088 + o[40] + o[41] + o[42] + o[43] + o[44] + o[45] + o[47];
//   o[49] := o[35] ^ -2.0;
//   dtsat := 5e-007 * ((2.0 * o[15]) / o[35] + -2.0 * o[11] * (-3005.2061756175 * o[2] + -0.5 * o[26] * o[31] + -583.52607263835 * o[5]) * o[49] + (-20953.4635664399 * (o[39] * (1295.95640782102 + 5398.05138359071 * o[2] + 0.25 * o[2] * o[30] + -0.861036696828853 * o[26] * o[31] + -0.255316477279829 * o[26] * o[31] * o[4] + -4096.43557421473 * o[5] + -0.255316477279829 * o[30] * o[5] + -2325.01894614276 / o[8] + 0.5 * o[26] * o[31] * o[8]) + -2.0 * (o[19] + o[20] + 0.5 * o[26] * o[31]) * o[48] * o[37] ^ -3.0)) / sqrt(o[39] * o[48]));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3 \"Helmholtz function for region 3: f(d,T)\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives wrt delta and tau\";
//   protected Real[40] o \"vector of auxiliary variables\";
// algorithm
//   f.T := T;
//   f.d := d;
//   f.R := 461.526;
//   f.tau := 647.096 / T;
//   f.delta := if d == 322.0 and T == 647.096 then 0.999999999999999 else abs(d / 322.0);
//   o[1] := f.tau ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] * f.tau;
//   o[4] := o[1] * f.tau;
//   o[5] := o[2] ^ 2.0;
//   o[6] := o[1] * o[5] * f.tau;
//   o[7] := o[5] * f.tau;
//   o[8] := -0.64207765181607 * o[1];
//   o[9] := 0.88521043984318 + o[8];
//   o[10] := o[7] * o[9];
//   o[11] := -1.1524407806681 + o[10];
//   o[12] := o[11] * o[2];
//   o[13] := -1.2654315477714 + o[12];
//   o[14] := o[1] * o[13];
//   o[15] := o[1] * o[2] * o[5] * f.tau;
//   o[16] := o[2] * o[5];
//   o[17] := o[1] * o[5];
//   o[18] := o[5] ^ 2.0;
//   o[19] := o[1] * o[18] * o[2];
//   o[20] := o[1] * o[18] * o[2] * f.tau;
//   o[21] := o[18] * o[5];
//   o[22] := o[1] * o[18] * o[5];
//   o[23] := 0.25116816848616 * o[2];
//   o[24] := 0.078841073758308 + o[23];
//   o[25] := o[15] * o[24];
//   o[26] := -6.100523451393 + o[25];
//   o[27] := o[26] * f.tau;
//   o[28] := 9.7944563083754 + o[27];
//   o[29] := o[2] * o[28];
//   o[30] := -1.70429417648412 + o[29];
//   o[31] := o[1] * o[30];
//   o[32] := f.delta ^ 2.0;
//   o[33] := -10.9153200808732 * o[1];
//   o[34] := 13.2781565976477 + o[33];
//   o[35] := o[34] * o[7];
//   o[36] := -6.9146446840086 + o[35];
//   o[37] := o[2] * o[36];
//   o[38] := -2.5308630955428 + o[37];
//   o[39] := o[38] * f.tau;
//   o[40] := o[18] * o[5] * f.tau;
//   f.f := -15.732845290239 + f.tau * (20.944396974307 + (-7.6867707878716 + o[3] * (2.6185947787954 + o[4] * (-2.808078114862 + o[1] * (1.2053369696517 + -0.0084566812812502 * o[6])))) * f.tau) + f.delta * (o[14] + f.delta * (0.38493460186671 + o[1] * (-0.85214708824206 + o[2] * (4.8972281541877 + (-3.0502617256965 + o[15] * (0.039420536879154 + 0.12558408424308 * o[2])) * f.tau)) + f.delta * (-0.2799932969871 + o[1] * (1.389979956946 + o[1] * (-2.018991502357 + o[16] * (-0.0082147637173963 + -0.47596035734923 * o[17]))) + f.delta * (0.0439840744735 + o[1] * (-0.44476435428739 + o[1] * (0.90572070719733 + 0.70522450087967 * o[19])) + f.delta * (f.delta * (-0.022175400873096 + o[1] * (0.094260751665092 + 0.16436278447961 * o[21]) + f.delta * (-0.013503372241348 * o[1] + f.delta * (-0.014834345352472 * o[22] + f.delta * (o[1] * (0.00057922953628084 + 0.0032308904703711 * o[21]) + f.delta * (8.0964802996215e-005 + -4.4923899061815e-005 * f.delta * o[22] + -0.00016557679795037 * f.tau))))) + (0.10770512626332 + o[1] * (-0.32913623258954 + -0.50871062041158 * o[20])) * f.tau))))) + 1.0658070028513 * log(f.delta);
//   f.fdelta := (1.0658070028513 + f.delta * (o[14] + f.delta * (0.76986920373342 + o[31] + f.delta * (-0.8399798909613 + o[1] * (4.169939870838 + o[1] * (-6.056974507071 + o[16] * (-0.0246442911521889 + -1.42788107204769 * o[17]))) + f.delta * (0.175936297894 + o[1] * (-1.77905741714956 + o[1] * (3.6228828287893 + 2.82089800351868 * o[19])) + f.delta * (f.delta * (-0.133052405238576 + o[1] * (0.56556450999055 + 0.98617670687766 * o[21]) + f.delta * (-0.094523605689436 * o[1] + f.delta * (-0.118674762819776 * o[22] + f.delta * (o[1] * (0.0052130658265276 + 0.0290780142333399 * o[21]) + f.delta * (0.00080964802996215 + -0.00049416288967996 * f.delta * o[22] + -0.0016557679795037 * f.tau))))) + (0.5385256313166 + o[1] * (-1.6456811629477 + -2.5435531020579 * o[20])) * f.tau)))))) / f.delta;
//   f.fdeltadelta := (-1.0658070028513 + o[32] * (0.76986920373342 + o[31] + f.delta * (-1.6799597819226 + o[1] * (8.339879741676 + o[1] * (-12.113949014142 + o[16] * (-0.049288582304378 + -2.85576214409538 * o[17]))) + f.delta * (0.527808893682 + o[1] * (-5.3371722514487 + o[1] * (10.868648486368 + 8.462694010556 * o[19])) + f.delta * (f.delta * (-0.66526202619288 + o[1] * (2.82782254995276 + 4.9308835343883 * o[21]) + f.delta * (-0.56714163413662 * o[1] + f.delta * (-0.83072333973843 * o[22] + f.delta * (o[1] * (0.04170452661222 + 0.232624113866719 * o[21]) + f.delta * (0.0072868322696594 + -0.0049416288967996 * f.delta * o[22] + -0.0149019118155333 * f.tau))))) + (2.1541025252664 + o[1] * (-6.5827246517908 + -10.1742124082316 * o[20])) * f.tau))))) / o[32];
//   f.ftau := 20.944396974307 + (-15.3735415757432 + o[3] * (18.3301634515678 + o[4] * (-28.08078114862 + o[1] * (14.4640436358204 + -0.194503669468755 * o[6])))) * f.tau + f.delta * (o[39] + f.delta * (f.tau * (-1.70429417648412 + o[2] * (29.3833689251262 + (-21.3518320798755 + o[15] * (0.86725181134139 + 3.2651861903201 * o[2])) * f.tau)) + f.delta * ((2.779959913892 + o[1] * (-8.075966009428 + o[16] * (-0.131436219478341 + -12.37496929108 * o[17]))) * f.tau + f.delta * ((-0.88952870857478 + o[1] * (3.6228828287893 + 18.3358370228714 * o[19])) * f.tau + f.delta * (0.10770512626332 + o[1] * (-0.98740869776862 + -13.2264761307011 * o[20]) + f.delta * ((0.188521503330184 + 4.2734323964699 * o[21]) * f.tau + f.delta * (-0.027006744482696 * f.tau + f.delta * (-0.38569297916427 * o[40] + f.delta * (f.delta * (-0.00016557679795037 + -0.00116802137560719 * f.delta * o[40]) + (0.00115845907256168 + 0.084003152229649 * o[21]) * f.tau)))))))));
//   f.ftautau := -15.3735415757432 + o[3] * (109.980980709407 + o[4] * (-252.72703033758 + o[1] * (159.104479994024 + -4.2790807283126 * o[6]))) + f.delta * (-2.5308630955428 + o[2] * (-34.573223420043 + (185.894192367068 + -174.645121293971 * o[1]) * o[7]) + f.delta * (-1.70429417648412 + o[2] * (146.916844625631 + (-128.110992479253 + o[15] * (18.2122880381691 + 81.629654758002 * o[2])) * f.tau) + f.delta * (2.779959913892 + o[1] * (-24.227898028284 + o[16] * (-1.97154329217511 + -309.374232277 * o[17])) + f.delta * (-0.88952870857478 + o[1] * (10.868648486368 + 458.39592557179 * o[19]) + f.delta * (f.delta * (0.188521503330184 + 106.835809911747 * o[21] + f.delta * (-0.027006744482696 + f.delta * (-9.6423244791068 * o[21] + f.delta * (0.00115845907256168 + 2.10007880574121 * o[21] + -0.0292005343901797 * o[21] * o[32])))) + (-1.97481739553724 + -330.66190326753 * o[20]) * f.tau)))));
//   f.fdeltatau := o[39] + f.delta * (f.tau * (-3.4085883529682 + o[2] * (58.766737850252 + (-42.703664159751 + o[15] * (1.73450362268278 + 6.5303723806402 * o[2])) * f.tau)) + f.delta * ((8.339879741676 + o[1] * (-24.227898028284 + o[16] * (-0.39430865843502 + -37.12490787324 * o[17]))) * f.tau + f.delta * ((-3.5581148342991 + o[1] * (14.4915313151573 + 73.343348091486 * o[19])) * f.tau + f.delta * (0.5385256313166 + o[1] * (-4.9370434888431 + -66.132380653505 * o[20]) + f.delta * ((1.1311290199811 + 25.6405943788192 * o[21]) * f.tau + f.delta * (-0.189047211378872 * f.tau + f.delta * (-3.08554383331418 * o[40] + f.delta * (f.delta * (-0.0016557679795037 + -0.0128482351316791 * f.delta * o[40]) + (0.0104261316530551 + 0.75602837006684 * o[21]) * f.tau))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1 \"Gibbs function for region 1: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau1 \"dimensionless temperature\";
//   protected Real[45] o \"vector of auxiliary variables\";
//   protected Real pl \"auxiliary variable\";
// algorithm
//   pl := min(p,22063999.0);
//   assert( p > 611.657, \"IF97 medium function g1 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   assert( p <= 100000000.0, \"IF97 medium function g1: the input pressure (= \" + String(p,0,true,6) + \" Pa) is higher than 100 Mpa\");
//   assert( T >= 273.15, \"IF97 medium function g1: the temperature (= \" + String(T,0,true,6) + \" K)  is lower than 273.15 K!\");
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   g.pi := p / 16530000.0;
//   g.tau := 1386.0 / T;
//   pi1 := 7.1 - g.pi;
//   tau1 := -1.222 + g.tau;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := o[3] * tau1;
//   o[5] := 1.0 / o[4];
//   o[6] := o[1] * o[2];
//   o[7] := o[1] * tau1;
//   o[8] := 1.0 / o[7];
//   o[9] := o[1] * o[2] * o[3];
//   o[10] := 1.0 / o[2];
//   o[11] := o[2] * tau1;
//   o[12] := 1.0 / o[11];
//   o[13] := o[2] * o[3];
//   o[14] := 1.0 / o[3];
//   o[15] := pi1 ^ 2.0;
//   o[16] := o[15] * pi1;
//   o[17] := o[15] ^ 2.0;
//   o[18] := o[17] ^ 2.0;
//   o[19] := o[17] * o[18] * pi1;
//   o[20] := o[15] * o[17];
//   o[21] := o[3] ^ 2.0;
//   o[22] := o[21] ^ 2.0;
//   o[23] := o[22] * o[3] * tau1;
//   o[24] := 1.0 / o[23];
//   o[25] := o[22] * o[3];
//   o[26] := 1.0 / o[25];
//   o[27] := o[1] * o[2] * o[22] * tau1;
//   o[28] := 1.0 / o[27];
//   o[29] := o[1] * o[2] * o[22];
//   o[30] := 1.0 / o[29];
//   o[31] := o[1] * o[2] * o[21] * o[3] * tau1;
//   o[32] := 1.0 / o[31];
//   o[33] := o[2] * o[21] * o[3] * tau1;
//   o[34] := 1.0 / o[33];
//   o[35] := o[1] * o[3] * tau1;
//   o[36] := 1.0 / o[35];
//   o[37] := o[1] * o[3];
//   o[38] := 1.0 / o[37];
//   o[39] := 1.0 / o[6];
//   o[40] := o[1] * o[22] * o[3];
//   o[41] := 1.0 / o[40];
//   o[42] := 1.0 / o[22];
//   o[43] := o[1] * o[2] * o[21] * o[3];
//   o[44] := 1.0 / o[43];
//   o[45] := 1.0 / o[13];
//   g.g := pi1 * (pi1 * (pi1 * (o[10] * (-3.1679644845054e-005 + o[2] * (-2.8270797985312e-006 + -8.5205128120103e-010 * o[6])) + pi1 * (o[12] * (-2.2425281908e-006 + (-6.5171222895601e-007 + -1.4341729937924e-013 * o[13]) * o[7]) + pi1 * (-4.0516996860117e-007 * o[14] + o[16] * ((-1.2734301741641e-009 + -1.7424871230634e-010 * o[11]) * o[36] + o[19] * (-6.8762131295531e-019 * o[34] + o[15] * (1.4478307828521e-020 * o[32] + o[20] * (2.6335781662795e-023 * o[30] + pi1 * (-1.1947622640071e-023 * o[28] + pi1 * (1.8228094581404e-024 * o[26] + -9.3537087292458e-026 * o[24] * pi1))))))))) + o[8] * (-0.00047184321073267 + o[7] * (-0.00030001780793026 + (4.7661393906987e-005 + o[1] * (-4.4141845330846e-006 + -7.2694996297594e-016 * o[9])) * tau1))) + o[5] * (0.00028319080123804 + o[1] * (-0.00060706301565874 + o[6] * (-0.018990068218419 + tau1 * (-0.032529748770505 + (-0.021841717175414 + -5.283835796993e-005 * o[1]) * tau1))))) + (0.14632971213167 + tau1 * (-0.84548187169114 + tau1 * (-3.756360367204 + tau1 * (3.3855169168385 + tau1 * (-0.95791963387872 + tau1 * (0.15772038513228 + (-0.016616417199501 + 0.00081214629983568 * tau1) * tau1)))))) / o[1];
//   g.gpi := pi1 * (pi1 * (o[10] * (9.5038934535162e-005 + o[2] * (8.4812393955936e-006 + 2.55615384360309e-009 * o[6])) + pi1 * (o[12] * (8.9701127632e-006 + (2.60684891582404e-006 + 5.7366919751696e-013 * o[13]) * o[7]) + pi1 * (2.02584984300585e-006 * o[14] + o[16] * ((1.01874413933128e-008 + 1.39398969845072e-009 * o[11]) * o[36] + o[19] * (1.44400475720615e-017 * o[34] + o[15] * (-3.3300108005598e-019 * o[32] + o[20] * (-7.6373766822106e-022 * o[30] + pi1 * (3.5842867920213e-022 * o[28] + pi1 * (-5.6507093202352e-023 * o[26] + 2.99318679335866e-024 * o[24] * pi1))))))))) + o[8] * (0.00094368642146534 + o[7] * (0.00060003561586052 + (-9.5322787813974e-005 + o[1] * (8.8283690661692e-006 + 1.45389992595188e-015 * o[9])) * tau1))) + o[5] * (-0.00028319080123804 + o[1] * (0.00060706301565874 + o[6] * (0.018990068218419 + tau1 * (0.032529748770505 + (0.021841717175414 + 5.283835796993e-005 * o[1]) * tau1))));
//   g.gpipi := pi1 * (o[10] * (-0.000190077869070324 + o[2] * (-1.69624787911872e-005 + -5.1123076872062e-009 * o[6])) + pi1 * (o[12] * (-2.69103382896e-005 + (-7.8205467474721e-006 + -1.72100759255088e-012 * o[13]) * o[7]) + pi1 * (-8.1033993720234e-006 * o[14] + o[16] * ((-7.131208975319e-008 + -9.757927889155e-009 * o[11]) * o[36] + o[19] * (-2.8880095144123e-016 * o[34] + o[15] * (7.3260237612316e-018 * o[32] + o[20] * (2.13846547101895e-020 * o[30] + pi1 * (-1.03944316968618e-020 * o[28] + pi1 * (1.69521279607057e-021 * o[26] + -9.2788790594118e-023 * o[24] * pi1))))))))) + o[8] * (-0.00094368642146534 + o[7] * (-0.00060003561586052 + (9.5322787813974e-005 + o[1] * (-8.8283690661692e-006 + -1.45389992595188e-015 * o[9])) * tau1));
//   g.gtau := pi1 * (o[38] * (-0.00254871721114236 + o[1] * (0.0042494411096112 + (0.018990068218419 + (-0.021841717175414 + -0.00015851507390979 * o[1]) * o[1]) * o[6])) + pi1 * (o[10] * (0.00141552963219801 + o[2] * (4.7661393906987e-005 + o[1] * (-1.32425535992538e-005 + -1.2358149370591e-014 * o[9]))) + pi1 * (o[12] * (0.000126718579380216 + -5.1123076872062e-009 * o[37]) + pi1 * (o[39] * (1.1212640954e-005 + (1.30342445791202e-006 + -1.4341729937924e-012 * o[13]) * o[7]) + pi1 * (3.2413597488094e-006 * o[5] + o[16] * ((1.40077319158051e-008 + 1.04549227383804e-009 * o[11]) * o[45] + o[19] * (1.9941018075704e-017 * o[44] + o[15] * (-4.4882754268415e-019 * o[42] + o[20] * (-1.00075970318621e-021 * o[28] + pi1 * (4.6595728296277e-022 * o[26] + pi1 * (-7.2912378325616e-023 * o[24] + 3.8350205789908e-024 * o[41] * pi1))))))))))) + o[8] * (-0.29265942426334 + tau1 * (0.84548187169114 + o[1] * (3.3855169168385 + tau1 * (-1.91583926775744 + tau1 * (0.47316115539684 + (-0.066465668798004 + 0.0040607314991784 * tau1) * tau1)))));
//   g.gtautau := pi1 * (o[36] * (0.0254871721114236 + o[1] * (-0.033995528876889 + (-0.037980136436838 + -0.00031703014781958 * o[2]) * o[6])) + pi1 * (o[12] * (-0.005662118528792 + o[6] * (-2.64851071985076e-005 + -1.97730389929456e-013 * o[9])) + pi1 * ((-0.00063359289690108 + -2.55615384360309e-008 * o[37]) * o[39] + pi1 * (pi1 * (-2.91722377392842e-005 * o[38] + o[16] * (o[19] * (-5.9823054227112e-016 * o[32] + o[15] * (o[20] * (3.9029628424262e-020 * o[26] + pi1 * (-1.86382913185108e-020 * o[24] + pi1 * (2.98940751135026e-021 * o[41] + (-1.61070864317613e-022 * pi1) / (o[1] * o[22] * o[3] * tau1)))) + 1.43624813658928e-017 / (o[22] * tau1))) + (-1.68092782989661e-007 + -7.3184459168663e-009 * o[11]) / (o[2] * o[3] * tau1))) + (-6.7275845724e-005 + (-3.9102733737361e-006 + -1.29075569441316e-011 * o[13]) * o[7]) / (o[1] * o[2] * tau1))))) + o[10] * (0.87797827279002 + tau1 * (-1.69096374338228 + o[7] * (-1.91583926775744 + tau1 * (0.94632231079368 + (-0.199397006394012 + 0.0162429259967136 * tau1) * tau1))));
//   g.gtaupi := o[38] * (0.00254871721114236 + o[1] * (-0.0042494411096112 + (-0.018990068218419 + (0.021841717175414 + 0.00015851507390979 * o[1]) * o[1]) * o[6])) + pi1 * (o[10] * (-0.00283105926439602 + o[2] * (-9.5322787813974e-005 + o[1] * (2.64851071985076e-005 + 2.4716298741182e-014 * o[9]))) + pi1 * (o[12] * (-0.00038015573814065 + 1.53369230616185e-008 * o[37]) + pi1 * (o[39] * (-4.4850563816e-005 + (-5.2136978316481e-006 + 5.7366919751696e-012 * o[13]) * o[7]) + pi1 * (-1.62067987440468e-005 * o[5] + o[16] * ((-1.12061855326441e-007 + -8.3639381907043e-009 * o[11]) * o[45] + o[19] * (-4.1876137958978e-016 * o[44] + o[15] * (1.03230334817355e-017 * o[42] + o[20] * (2.90220313924001e-020 * o[28] + pi1 * (-1.39787184888831e-020 * o[26] + pi1 * (2.2602837280941e-021 * o[24] + -1.22720658527705e-022 * o[41] * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2 \"Gibbs function for region 2: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Real tau2 \"dimensionless temperature\";
//   protected Real[55] o \"vector of auxiliary variables\";
// algorithm
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   assert( p > 0.0, \"IF97 medium function g2 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   assert( p <= 100000000.0, \"IF97 medium function g2: the input pressure (= \" + String(p,0,true,6) + \" Pa) is higher than 100 Mpa\");
//   assert( T >= 273.15, \"IF97 medium function g2: the temperature (= \" + String(T,0,true,6) + \" K) is lower than 273.15 K!\");
//   assert( T <= 1073.15, \"IF97 medium function g2: the input temperature (= \" + String(T,0,true,6) + \" K) is higher than the limit of 1073.15 K\");
//   g.pi := p / 1000000.0;
//   g.tau := 540.0 / T;
//   tau2 := -0.5 + g.tau;
//   o[1] := tau2 ^ 2.0;
//   o[2] := o[1] * tau2;
//   o[3] := -0.05032527872793 * o[2];
//   o[4] := -0.057581259083432 + o[3];
//   o[5] := o[4] * tau2;
//   o[6] := -0.045996013696365 + o[5];
//   o[7] := o[6] * tau2;
//   o[8] := -0.017834862292358 + o[7];
//   o[9] := o[8] * tau2;
//   o[10] := o[1] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[11] ^ 2.0;
//   o[13] := o[10] * o[11] * o[12] * tau2;
//   o[14] := o[1] * o[10] * tau2;
//   o[15] := o[10] * o[11] * tau2;
//   o[16] := o[1] * o[12] * tau2;
//   o[17] := o[1] * o[11] * tau2;
//   o[18] := o[1] * o[10] * o[11];
//   o[19] := o[10] * o[11] * o[12];
//   o[20] := o[1] * o[10];
//   o[21] := g.pi ^ 2.0;
//   o[22] := o[21] ^ 2.0;
//   o[23] := o[21] * o[22];
//   o[24] := o[10] * o[12] * tau2;
//   o[25] := o[12] ^ 2.0;
//   o[26] := o[11] * o[12] * o[25] * tau2;
//   o[27] := o[10] * o[12];
//   o[28] := o[1] * o[10] * o[11] * tau2;
//   o[29] := o[10] * o[12] * o[25] * tau2;
//   o[30] := o[1] * o[10] * o[25] * tau2;
//   o[31] := o[1] * o[11] * o[12];
//   o[32] := o[1] * o[12];
//   o[33] := g.tau ^ 2.0;
//   o[34] := o[33] ^ 2.0;
//   o[35] := -5.3349095828174e-005 * o[13];
//   o[36] := -0.087594591301146 + o[35];
//   o[37] := o[2] * o[36];
//   o[38] := -0.007878555448671 + o[37];
//   o[39] := o[1] * o[38];
//   o[40] := -0.0003789797503263 + o[39];
//   o[41] := o[40] * tau2;
//   o[42] := -6.6065283340406e-005 + o[41];
//   o[43] := o[42] * tau2;
//   o[44] := 5.7870447262208e-006 * tau2;
//   o[45] := -0.30195167236758 * o[2];
//   o[46] := -0.172743777250296 + o[45];
//   o[47] := o[46] * tau2;
//   o[48] := -0.09199202739273 + o[47];
//   o[49] := o[48] * tau2;
//   o[50] := o[1] * o[11];
//   o[51] := o[10] * o[11];
//   o[52] := o[11] * o[12] * o[25];
//   o[53] := o[10] * o[12] * o[25];
//   o[54] := o[1] * o[10] * o[25];
//   o[55] := o[11] * o[12] * tau2;
//   g.g := g.pi * (-0.0017731742473213 + o[9] + g.pi * (tau2 * (-3.3032641670203e-005 + (-0.00018948987516315 + o[1] * (-0.0039392777243355 + (-0.043797295650573 + -2.6674547914087e-005 * o[13]) * o[2])) * tau2) + g.pi * (2.0481737692309e-008 + (4.3870667284435e-007 + o[1] * (-3.227767723857e-005 + (-0.0015033924542148 + -0.040668253562649 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (2.2922076337661e-006 * o[14] + g.pi * ((-1.6714766451061e-011 + o[15] * (-0.0021171472321355 + -23.895741934104 * o[16])) * o[2] + g.pi * (-5.905956432427e-018 + o[17] * (-1.2621808899101e-006 + -0.038946842435739 * o[18]) + g.pi * (o[11] * (1.1256211360459e-011 + -8.2311340897998 * o[19]) + g.pi * (1.9809712802088e-008 * o[15] + g.pi * (o[10] * (1.0406965210174e-019 + (-1.0234747095929e-013 + -1.0018179379511e-009 * o[10]) * o[20]) + o[23] * (o[13] * (-8.0882908646985e-011 + 0.10693031879409 * o[24]) + o[21] * (-0.33662250574171 * o[26] + o[21] * (o[27] * (8.9185845355421e-025 + (3.0629316876232e-013 + -4.2002467698208e-006 * o[15]) * o[28]) + g.pi * (-5.9056029685639e-026 * o[24] + g.pi * (3.7826947613457e-006 * o[29] + g.pi * (-1.2768608934681e-015 * o[30] + o[31] * (7.3087610595061e-029 + o[18] * (5.5414715350778e-017 + -9.436970724121e-007 * o[32])) * g.pi)))))))))))) + tau2 * (-7.8847309559367e-010 + (1.2790717852285e-008 + 4.8225372718507e-007 * tau2) * tau2))))) + (-0.00560879118302 + g.tau * (0.07145273881455 + g.tau * (-0.4071049823928 + g.tau * (1.424081971444 + g.tau * (-4.38395111945 + g.tau * (-9.692768600217 + g.tau * (10.08665568018 + (-0.2840863260772 + 0.02126846353307 * g.tau) * g.tau) + log(g.pi))))))) / (o[34] * g.tau);
//   g.gpi := (1.0 + g.pi * (-0.0017731742473213 + o[9] + g.pi * (o[43] + g.pi * (6.1445213076927e-008 + (1.31612001853305e-006 + o[1] * (-9.683303171571e-005 + (-0.0045101773626444 + -0.122004760687947 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (1.14610381688305e-005 * o[14] + g.pi * ((-1.00288598706366e-010 + o[15] * (-0.012702883392813 + -143.374451604624 * o[16])) * o[2] + g.pi * (-4.1341695026989e-017 + o[17] * (-8.8352662293707e-006 + -0.272627897050173 * o[18]) + g.pi * (o[11] * (9.0049690883672e-011 + -65.849072718398 * o[19]) + g.pi * (1.78287415218792e-007 * o[15] + g.pi * (o[10] * (1.0406965210174e-018 + (-1.0234747095929e-012 + -1.0018179379511e-008 * o[10]) * o[20]) + o[23] * (o[13] * (-1.29412653835176e-009 + 1.71088510070544 * o[24]) + o[21] * (-6.0592051033508 * o[26] + o[21] * (o[27] * (1.78371690710842e-023 + (6.1258633752464e-012 + -8.4004935396416e-005 * o[15]) * o[28]) + g.pi * (-1.24017662339842e-024 * o[24] + g.pi * (8.3219284749605e-005 * o[29] + g.pi * (-2.93678005497663e-014 * o[30] + o[31] * (1.75410265428146e-027 + o[18] * (1.32995316841867e-015 + -2.26487297378904e-005 * o[32])) * g.pi)))))))))))) + tau2 * (-3.15389238237468e-009 + (5.116287140914e-008 + 1.92901490874028e-006 * tau2) * tau2)))))) / g.pi;
//   g.gpipi := (-1.0 + o[21] * (o[43] + g.pi * (1.22890426153854e-007 + (2.6322400370661e-006 + o[1] * (-0.00019366606343142 + (-0.0090203547252888 + -0.244009521375894 * o[13]) * o[2])) * tau2 + g.pi * (g.pi * (4.5844152675322e-005 * o[14] + g.pi * ((-5.0144299353183e-010 + o[15] * (-0.063514416964065 + -716.87225802312 * o[16])) * o[2] + g.pi * (-2.48050170161934e-016 + o[17] * (-5.3011597376224e-005 + -1.63576738230104 * o[18]) + g.pi * (o[11] * (6.303478361857e-010 + -460.94350902879 * o[19]) + g.pi * (1.42629932175034e-006 * o[15] + g.pi * (o[10] * (9.3662686891566e-018 + (-9.2112723863361e-012 + -9.0163614415599e-008 * o[10]) * o[20]) + o[23] * (o[13] * (-1.94118980752764e-008 + 25.6632765105816 * o[24]) + o[21] * (-103.006486756963 * o[26] + o[21] * (o[27] * (3.389062123506e-022 + (1.16391404129682e-010 + -0.0015960937725319 * o[15]) * o[28]) + g.pi * (-2.48035324679684e-023 * o[24] + g.pi * (0.00174760497974171 * o[29] + g.pi * (-6.4609161209486e-013 * o[30] + o[31] * (4.0344361048474e-026 + o[18] * (3.05889228736295e-014 + -0.00052092078397148 * o[32])) * g.pi)))))))))))) + tau2 * (-9.461677147124e-009 + (1.5348861422742e-007 + o[44]) * tau2))))) / o[21];
//   g.gtau := (0.0280439559151 + g.tau * (-0.2858109552582 + g.tau * (1.2213149471784 + g.tau * (-2.848163942888 + g.tau * (4.38395111945 + o[33] * (10.08665568018 + (-0.5681726521544 + 0.06380539059921 * g.tau) * g.tau)))))) / (o[33] * o[34]) + g.pi * (-0.017834862292358 + o[49] + g.pi * (-3.3032641670203e-005 + (-0.0003789797503263 + o[1] * (-0.015757110897342 + (-0.306581069554011 + -0.00096028372490713 * o[13]) * o[2])) * tau2 + g.pi * (4.3870667284435e-007 + o[1] * (-9.683303171571e-005 + (-0.0090203547252888 + -1.42338887469272 * o[13]) * o[2]) + g.pi * (-7.8847309559367e-010 + g.pi * (1.60454534363627e-005 * o[20] + g.pi * (o[1] * (-5.0144299353183e-011 + o[15] * (-0.033874355714168 + -836.35096769364 * o[16])) + g.pi * ((-1.38839897890111e-005 + -0.97367106089347 * o[18]) * o[50] + g.pi * (o[14] * (9.0049690883672e-011 + -296.320827232793 * o[19]) + g.pi * (2.57526266427144e-007 * o[51] + g.pi * (o[2] * (4.1627860840696e-019 + (-1.0234747095929e-012 + -1.40254511313154e-008 * o[10]) * o[20]) + o[23] * (o[19] * (-2.34560435076256e-009 + 5.3465159397045 * o[24]) + o[21] * (-19.1874828272775 * o[52] + o[21] * (o[16] * (1.78371690710842e-023 + (1.07202609066812e-011 + -0.000201611844951398 * o[15]) * o[28]) + g.pi * (-1.24017662339842e-024 * o[27] + g.pi * (0.000200482822351322 * o[53] + g.pi * (-4.9797574845256e-014 * o[54] + (1.90027787547159e-027 + o[18] * (2.21658861403112e-015 + -5.4734430199902e-005 * o[32])) * o[55] * g.pi)))))))))))) + (2.558143570457e-008 + 1.44676118155521e-006 * tau2) * tau2))));
//   g.gtautau := (-0.1682637354906 + g.tau * (1.429054776291 + g.tau * (-4.8852597887136 + g.tau * (8.544491828664 + g.tau * (-8.7679022389 + o[33] * (-0.5681726521544 + 0.12761078119842 * g.tau) * g.tau))))) / (o[33] * o[34] * g.tau) + g.pi * (-0.09199202739273 + (-0.34548755450059 + -1.5097583618379 * o[2]) * tau2 + g.pi * (-0.0003789797503263 + o[1] * (-0.047271332692026 + (-1.83948641732407 + -0.03360993037175 * o[13]) * o[2]) + g.pi * ((-0.00019366606343142 + (-0.045101773626444 + -48.395221739552 * o[13]) * o[2]) * tau2 + g.pi * (2.558143570457e-008 + 2.89352236311042e-006 * tau2 + g.pi * (9.6272720618176e-005 * o[10] * tau2 + g.pi * ((-1.00288598706366e-010 + o[15] * (-0.50811533571252 + -28435.9329015838 * o[16])) * tau2 + g.pi * (o[11] * (-0.000138839897890111 + -23.3681054614434 * o[18]) * tau2 + g.pi * ((6.303478361857e-010 + -10371.2289531477 * o[19]) * o[20] + g.pi * (3.09031519712573e-006 * o[17] + g.pi * (o[1] * (1.24883582522088e-018 + (-9.2112723863361e-012 + -1.823308647071e-007 * o[10]) * o[20]) + o[23] * (o[1] * o[11] * o[12] * (-6.5676921821352e-008 + 261.979281045521 * o[24]) * tau2 + o[21] * (-1074.49903832754 * o[1] * o[10] * o[12] * o[25] * tau2 + o[21] * ((3.389062123506e-022 + (3.6448887082716e-010 + -0.0094757567127157 * o[15]) * o[28]) * o[32] + g.pi * (-2.48035324679684e-023 * o[16] + g.pi * (0.0104251067622687 * o[1] * o[12] * o[25] * tau2 + g.pi * (o[11] * o[12] * (4.750694688679e-026 + o[18] * (8.6446955947214e-014 + -0.0031198625213944 * o[32])) * g.pi + -1.89230784411972e-012 * o[10] * o[25] * tau2))))))))))))))));
//   g.gtaupi := -0.017834862292358 + o[49] + g.pi * (-6.6065283340406e-005 + (-0.0007579595006526 + o[1] * (-0.031514221794684 + (-0.61316213910802 + -0.00192056744981426 * o[13]) * o[2])) * tau2 + g.pi * (1.31612001853305e-006 + o[1] * (-0.00029049909514713 + (-0.0270610641758664 + -4.2701666240781 * o[13]) * o[2]) + g.pi * (-3.15389238237468e-009 + g.pi * (8.0227267181813e-005 * o[20] + g.pi * (o[1] * (-3.00865796119098e-010 + o[15] * (-0.203246134285008 + -5018.1058061618 * o[16])) + g.pi * ((-9.7187928523078e-005 + -6.8156974262543 * o[18]) * o[50] + g.pi * (o[14] * (7.2039752706938e-010 + -2370.56661786234 * o[19]) + g.pi * (2.3177363978443e-006 * o[51] + g.pi * (o[2] * (4.1627860840696e-018 + (-1.0234747095929e-011 + -1.40254511313154e-007 * o[10]) * o[20]) + o[23] * (o[19] * (-3.7529669612201e-008 + 85.544255035272 * o[24]) + o[21] * (-345.37469089099 * o[52] + o[21] * (o[16] * (3.5674338142168e-022 + (2.14405218133624e-010 + -0.004032236899028 * o[15]) * o[28]) + g.pi * (-2.60437090913668e-023 * o[27] + g.pi * (0.0044106220917291 * o[53] + g.pi * (-1.14534422144089e-012 * o[54] + (4.5606669011318e-026 + o[18] * (5.3198126736747e-014 + -0.00131362632479764 * o[32])) * o[55] * g.pi)))))))))))) + (1.0232574281828e-007 + o[44]) * tau2)));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5 \"base function for region 5: g(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Real[11] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 0.0, \"IF97 medium function g5 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   assert( p <= 10000000.0, \"IF97 medium function g5: input pressure (= \" + String(p,0,true,6) + \" Pa) is higher than 10 Mpa in region 5\");
//   assert( T <= 2273.15, \"IF97 medium function g5: input temperature (= \" + String(T,0,true,6) + \" K) is higher than limit of 2273.15K in region 5\");
//   g.p := p;
//   g.T := T;
//   g.R := 461.526;
//   g.pi := p / 1000000.0;
//   g.tau := 1000.0 / T;
//   o[1] := g.tau ^ 2.0;
//   o[2] := -0.004594282089991 * o[1];
//   o[3] := 0.0021774678714571 + o[2];
//   o[4] := o[3] * g.tau;
//   o[5] := o[1] * g.tau;
//   o[6] := o[1] ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[7] * g.tau;
//   o[9] := -7.9449656719138e-006 * o[8];
//   o[10] := g.pi ^ 2.0;
//   o[11] := -0.013782846269973 * o[1];
//   g.g := g.pi * (-0.00012563183589592 + o[4] + g.pi * (-3.9724828359569e-006 * o[8] + 1.2919228289784e-007 * o[5] * g.pi)) + (-0.024805148933466 + g.tau * (0.36901534980333 + g.tau * (-3.1161318213925 + g.tau * (-13.179983674201 + (6.8540841634434 + -0.32961626538917 * g.tau) * g.tau + log(g.pi))))) / o[5];
//   g.gpi := (1.0 + g.pi * (-0.00012563183589592 + o[4] + g.pi * (o[9] + 3.8757684869352e-007 * o[5] * g.pi))) / g.pi;
//   g.gpipi := (-1.0 + o[10] * (o[9] + 7.7515369738704e-007 * o[5] * g.pi)) / o[10];
//   g.gtau := g.pi * (0.0021774678714571 + o[11] + g.pi * (-3.5752345523612e-005 * o[7] + 3.8757684869352e-007 * o[1] * g.pi)) + (0.074415446800398 + g.tau * (-0.73803069960666 + (3.1161318213925 + o[1] * (6.8540841634434 + -0.65923253077834 * g.tau)) * g.tau)) / o[6];
//   g.gtautau := (-0.297661787201592 + g.tau * (2.21409209881998 + (-6.232263642785 + -0.65923253077834 * o[5]) * g.tau)) / (o[6] * g.tau) + g.pi * (-0.027565692539946 * g.tau + g.pi * (-0.000286018764188897 * o[1] * o[6] * g.tau + 7.7515369738704e-007 * g.pi * g.tau));
//   g.gtaupi := 0.0021774678714571 + o[11] + g.pi * (-7.1504691047224e-005 * o[7] + 1.16273054608056e-006 * o[1] * g.pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p \"ergion 3 a b boundary for pressure/enthalpy\"
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"Enthalpy\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure\";
//   protected constant Real[4] n = {2014.64004206875,3.74696550136983,-0.0219921901054187,8.7513168600995e-005};
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\") = 1000.0 \"normalization enthalpy\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 1000000.0 \"normalization pressure\";
//   protected Real pi = p / 1000000.0 \"normalized specific pressure\";
// algorithm
//   h := 2014640.04206875 + 1000.0 * (3.74696550136983 * pi + -0.0219921901054187 * pi ^ 2.0 + 8.7513168600995e-005 * pi ^ 3.0);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat \"region 4 saturation pressure as a functionx of temperature\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real p_sat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   protected Real[8] o \"vector of auxiliary variables\";
//   protected Real Tlim = min(T,647.096);
// algorithm
//   assert( T >= 273.16, \"IF97 medium function psat: input temperature (= 611.657 K).
// lower than the triple point temperature 273.16 K\");
//   o[1] := -650.17534844798 + Tlim;
//   o[2] := 1.0 / o[1];
//   o[3] := -0.23855557567849 * o[2];
//   o[4] := o[3] + Tlim;
//   o[5] := -4823.2657361591 * o[4];
//   o[6] := o[4] ^ 2.0;
//   o[7] := 14.91510861353 * o[6];
//   o[8] := 405113.40542057 + o[5] + o[7];
//   p_sat := 16000000.0 * o[8] ^ 4.0 * (3232555.0322333 + -12020.82470247 * o[4] + 17.073846940092 * o[6] + ((2896852.66812824 + -4.0 * (1167.0521452767 * o[4] + o[6])) * o[8] + (-3232555.0322333 + 12020.82470247 * o[4] + -17.073846940092 * o[6]) ^ 2.0) ^ 0.5) ^ -4.0;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat_der \"derivative function for psat\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   input Real der_T(unit = \"K/s\") \"temperature derivative\";
//   output Real der_psat(unit = \"Pa/s\") \"pressure\";
//   protected Real dpt;
// algorithm
//   dpt := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(T);
//   der_psat := dpt * der_T;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1 \"inverse function for region 1: T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real eta1 \"dimensionless specific enthalpy\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function tph1 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   pi := p / 1000000.0;
//   eta1 := 1.0 + h / 2500000.0;
//   o[1] := eta1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   T := -238.72489924521 + -13.391744872602 * pi + eta1 * (404.21188637945 + 43.211039183559 * pi + eta1 * (113.49746881718 + -54.010067170506 * pi + eta1 * (30.535892203916 * pi + eta1 * (-6.5964749423638 * pi + o[1] * (-5.8457616048039 + o[2] * (pi * (0.0093965400878363 + (-2.5858641282073e-005 + 6.6456186191635e-008 * pi) * pi) + o[2] * o[3] * (-0.0001528548241314 + o[1] * o[3] * (-1.0866707695377e-006 + pi * (1.157364750534e-007 + pi * (-4.0644363084799e-009 + pi * (8.0670734103027e-011 + pi * (-9.3477771213947e-013 + (5.8265442020601e-015 + -1.5020185953503e-017 * pi) * pi))))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2 \"reverse function for region 2: T(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real pi2b \"dimensionless pressure\";
//   protected Real pi2c \"dimensionless pressure\";
//   protected Real eta \"dimensionless specific enthalpy\";
//   protected Real etabc \"dimensionless specific enthalpy\";
//   protected Real eta2a \"dimensionless specific enthalpy\";
//   protected Real eta2b \"dimensionless specific enthalpy\";
//   protected Real eta2c \"dimensionless specific enthalpy\";
//   protected Real[8] o \"vector of auxiliary variables\";
// algorithm
//   pi := 1e-006 * p;
//   eta := 5e-007 * h;
//   etabc := 0.001 * h;
//   if pi < 4.0 then
//     eta2a := eta + -2.1;
//     o[1] := eta2a ^ 2.0;
//     o[2] := o[1] ^ 2.0;
//     o[3] := pi ^ 2.0;
//     o[4] := o[3] ^ 2.0;
//     o[5] := o[3] * pi;
//     T := 1089.8952318288 + (1.844574935579 + -0.0061707422868339 * pi) * pi + eta2a * (849.51654495535 + -4.1792700549624 * pi + eta2a * (-107.81748091826 + (6.2478196935812 + -0.31078046629583 * pi) * pi + eta2a * (33.153654801263 + -17.344563108114 * pi + o[2] * (-7.4232016790248 + pi * (-200.58176862096 + 11.670873077107 * pi) + o[1] * (271.96065473796 * pi + o[1] * (-455.11318285818 * pi + eta2a * (1.3865724283226 * o[4] + o[1] * o[2] * (3091.9688604755 * pi + o[1] * (11.765048724356 + o[2] * (-13551.334240775 * o[5] + o[2] * (-62.459855192507 * o[3] * o[4] * pi + o[2] * (o[4] * (235988.32556514 + 7399.9835474766 * pi) + o[1] * (19127.72923966 * o[3] * o[4] + o[1] * (o[3] * (128127984.04046 + -551966.9703006 * o[5]) + o[1] * (-985549096.23276 * o[3] + o[1] * (2822454697.3002 * o[3] + o[1] * (o[3] * (-3594897141.0703 + 3715408.5996233 * o[5]) + o[1] * pi * (252266.40357872 + pi * (1722734991.3197 + pi * (12848734.66465 + (-13105236.545054 + -415351.64835634 * o[3]) * pi))))))))))))))))))));
//   elseif pi < 905.84278514723 + (-0.67955786399241 + 0.00012809002730136 * etabc) * etabc then
//     eta2b := eta + -2.6;
//     pi2b := pi + -2.0;
//     o[1] := pi2b ^ 2.0;
//     o[2] := o[1] * pi2b;
//     o[3] := o[1] ^ 2.0;
//     o[4] := eta2b ^ 2.0;
//     o[5] := o[4] ^ 2.0;
//     o[6] := o[4] * o[5];
//     o[7] := o[5] ^ 2.0;
//     T := 1489.5041079516 + 0.93747147377932 * pi2b + eta2b * (743.07798314034 + o[2] * (0.00011032831789999 + -1.7565233969407e-018 * o[1] * o[3]) + eta2b * (-97.708318797837 + pi2b * (3.3593118604916 + pi2b * (-0.021810755324761 + pi2b * (0.00018955248387902 + (2.8640237477456e-007 + -8.1456365207833e-014 * o[2]) * pi2b))) + o[5] * (3.3809355601454 * pi2b + o[4] * (-0.10829784403677 * o[1] + o[5] * (2.4742464705674 + (0.16844539671904 + o[1] * (0.0030891541160537 + -1.0779857357512e-005 * pi2b)) * pi2b + o[6] * (-0.63281320016026 + pi2b * (0.73875745236695 + (-0.046333324635812 + o[1] * (-7.6462712454814e-005 + 2.821728163504e-007 * pi2b)) * pi2b) + o[6] * (1.1385952129658 + pi2b * (-0.47128737436186 + o[1] * (0.0013555504554949 + (1.4052392818316e-005 + 1.2704902271945e-006 * pi2b) * pi2b)) + o[5] * (-0.47811863648625 + (0.15020273139707 + o[2] * (-3.1083814331434e-005 + o[1] * (-1.1030139238909e-008 + -2.5180545682962e-011 * pi2b))) * pi2b + o[5] * o[7] * (0.0085208123431544 + pi2b * (-0.002176411421975 + pi2b * (7.1280351959551e-005 + o[1] * (-1.0302738212103e-006 + (7.3803353468292e-008 + 8.6934156344163e-015 * o[3]) * pi2b))))))))))));
//   else
//     eta2c := eta + -1.8;
//     pi2c := 25.0 + pi;
//     o[1] := pi2c ^ 2.0;
//     o[2] := o[1] ^ 2.0;
//     o[3] := o[1] * o[2] * pi2c;
//     o[4] := 1.0 / o[3];
//     o[5] := o[1] * o[2];
//     o[6] := eta2c ^ 2.0;
//     o[7] := o[2] ^ 2.0;
//     o[8] := o[6] ^ 2.0;
//     T := eta2c * ((859777.2253558 + o[1] * (482.19755109255 + 1.126159740723e-012 * o[5])) / o[1] + eta2c * ((-583401318515.9 + (20825544563.171 + 31081.088422714 * o[2]) * pi2c) / o[5] + o[6] * (o[8] * (o[6] * (1.2324579690832e-007 * o[5] + o[6] * (-1.1606921130984e-006 * o[5] + o[8] * (2.7846367088554e-005 * o[5] + (-0.00059270038474176 * o[5] + 0.0012918582991878 * o[5] * o[6]) * o[8]))) + -10.842984880077 * pi2c) + o[4] * (7326335090218.1 + o[7] * (3.7966001272486 + (-0.04536417267666 + -1.7804982240686e-011 * o[2]) * pi2c))))) + o[4] * (-3236839855524.2 + pi2c * (358250899454.47 + pi2c * (-10783068217.47 + o[1] * pi2c * (610747.83564516 + pi2c * (-25745.72360417 + (1208.2315865936 + 1.4559115658698e-013 * o[5]) * pi2c)))));
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat \"region 4 saturation temperature as a function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real t_sat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[20] o \"vector of auxiliary variables\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function tsat called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   pi := 1e-006 * min(p,22064000.0);
//   o[1] := pi ^ 0.25;
//   o[2] := -3232555.0322333 * o[1];
//   o[3] := pi ^ 0.5;
//   o[4] := -724213.16703206 * o[3];
//   o[5] := 405113.40542057 + o[2] + o[4];
//   o[6] := -17.073846940092 * o[1];
//   o[7] := 14.91510861353 + o[3] + o[6];
//   o[8] := -4.0 * o[5] * o[7];
//   o[9] := 12020.82470247 * o[1];
//   o[10] := 1167.0521452767 * o[3];
//   o[11] := -4823.2657361591 + o[10] + o[9];
//   o[12] := o[11] ^ 2.0;
//   o[13] := o[12] + o[8];
//   o[14] := o[13] ^ 0.5;
//   o[15] := -o[14];
//   o[16] := -12020.82470247 * o[1];
//   o[17] := -1167.0521452767 * o[3];
//   o[18] := 4823.2657361591 + o[15] + o[16] + o[17];
//   o[19] := 1.0 / o[18];
//   o[20] := 2.0 * o[19] * o[5];
//   t_sat := 325.08767422399 + 0.5 * (o[20] - (0.95422230271396 + -5201.40278758384 * o[19] * o[5] + (650.17534844798 + o[20]) ^ 2.0) ^ 0.5);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat_der \"derivative function for tsat\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real der_p(unit = \"Pa/s\") \"pressure derivatrive\";
//   output Real der_tsat(unit = \"K/s\") \"temperature derivative\";
//   protected Real dtp;
// algorithm
//   dtp := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dtsatofp(p);
//   der_tsat := dtp * der_p;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph \"Region 3 a: inverse function v(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real v(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.0) \"specific volume\";
//   protected constant Real[32] n = {0.00529944062966028,-0.170099690234461,11.1323814312927,-2178.98123145125,-0.000506061827980875,0.556495239685324,-9.43672726094016,-0.297856807561527,93.9353943717186,0.0192944939465981,0.421740664704763,-3689141.2628233,-0.00737566847600639,-0.354753242424366,-1.99768169338727,1.15456297059049,5683.6687581596,0.00808169540124668,0.172416341519307,1.04270175292927,-0.297691372792847,0.560394465163593,0.275234661176914,-0.148347894866012,-0.0651142513478515,-2.92468715386302,0.0664876096952665,3.52335014263844,-0.0146340792313332,-2.24503486668184,1.10533464706142,-0.0408757344495612};
//   protected constant Real[32] I = {-12.0,-12.0,-12.0,-12.0,-10.0,-10.0,-10.0,-8.0,-8.0,-6.0,-6.0,-6.0,-4.0,-4.0,-3.0,-2.0,-2.0,-1.0,-1.0,-1.0,-1.0,0.0,0.0,1.0,1.0,1.0,2.0,2.0,3.0,4.0,5.0,8.0};
//   protected constant Real[32] J = {6.0,8.0,12.0,18.0,4.0,7.0,10.0,5.0,12.0,3.0,4.0,22.0,2.0,3.0,7.0,3.0,16.0,0.0,1.0,2.0,3.0,0.0,1.0,0.0,1.0,2.0,0.0,2.0,0.0,2.0,2.0,2.0};
//   protected constant Real vstar(quantity = \"Volume\", unit = \"m3\") = 0.0028 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\") = 2100000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2100000.0 \"normalized specific enthalpy\";
// algorithm
//   v := 0.0028 * (n[1] * (0.128 + pi) ^ I[1] * (-0.727 + eta) ^ J[1] + n[2] * (0.128 + pi) ^ I[2] * (-0.727 + eta) ^ J[2] + n[3] * (0.128 + pi) ^ I[3] * (-0.727 + eta) ^ J[3] + n[4] * (0.128 + pi) ^ I[4] * (-0.727 + eta) ^ J[4] + n[5] * (0.128 + pi) ^ I[5] * (-0.727 + eta) ^ J[5] + n[6] * (0.128 + pi) ^ I[6] * (-0.727 + eta) ^ J[6] + n[7] * (0.128 + pi) ^ I[7] * (-0.727 + eta) ^ J[7] + n[8] * (0.128 + pi) ^ I[8] * (-0.727 + eta) ^ J[8] + n[9] * (0.128 + pi) ^ I[9] * (-0.727 + eta) ^ J[9] + n[10] * (0.128 + pi) ^ I[10] * (-0.727 + eta) ^ J[10] + n[11] * (0.128 + pi) ^ I[11] * (-0.727 + eta) ^ J[11] + n[12] * (0.128 + pi) ^ I[12] * (-0.727 + eta) ^ J[12] + n[13] * (0.128 + pi) ^ I[13] * (-0.727 + eta) ^ J[13] + n[14] * (0.128 + pi) ^ I[14] * (-0.727 + eta) ^ J[14] + n[15] * (0.128 + pi) ^ I[15] * (-0.727 + eta) ^ J[15] + n[16] * (0.128 + pi) ^ I[16] * (-0.727 + eta) ^ J[16] + n[17] * (0.128 + pi) ^ I[17] * (-0.727 + eta) ^ J[17] + n[18] * (0.128 + pi) ^ I[18] * (-0.727 + eta) ^ J[18] + n[19] * (0.128 + pi) ^ I[19] * (-0.727 + eta) ^ J[19] + n[20] * (0.128 + pi) ^ I[20] * (-0.727 + eta) ^ J[20] + n[21] * (0.128 + pi) ^ I[21] * (-0.727 + eta) ^ J[21] + n[22] * (0.128 + pi) ^ I[22] * (-0.727 + eta) ^ J[22] + n[23] * (0.128 + pi) ^ I[23] * (-0.727 + eta) ^ J[23] + n[24] * (0.128 + pi) ^ I[24] * (-0.727 + eta) ^ J[24] + n[25] * (0.128 + pi) ^ I[25] * (-0.727 + eta) ^ J[25] + n[26] * (0.128 + pi) ^ I[26] * (-0.727 + eta) ^ J[26] + n[27] * (0.128 + pi) ^ I[27] * (-0.727 + eta) ^ J[27] + n[28] * (0.128 + pi) ^ I[28] * (-0.727 + eta) ^ J[28] + n[29] * (0.128 + pi) ^ I[29] * (-0.727 + eta) ^ J[29] + n[30] * (0.128 + pi) ^ I[30] * (-0.727 + eta) ^ J[30] + n[31] * (0.128 + pi) ^ I[31] * (-0.727 + eta) ^ J[31] + n[32] * (0.128 + pi) ^ I[32] * (-0.727 + eta) ^ J[32]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph \"Region 3 b: inverse function v(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   output Real v(quantity = \"SpecificVolume\", unit = \"m3/kg\", min = 0.0) \"specific volume\";
//   protected constant Real[30] n = {-2.25196934336318e-009,1.40674363313486e-008,2.3378408528056e-006,-3.31833715229001e-005,0.00107956778514318,-0.271382067378863,1.07202262490333,-0.853821329075382,-2.15214194340526e-005,0.00076965608822273,-0.00431136580433864,0.453342167309331,-0.507749535873652,-100.475154528389,-0.219201924648793,-3.21087965668917,607.567815637771,0.000557686450685932,0.18749904002955,0.00905368030448107,0.285417173048685,0.0329924030996098,0.239897419685483,4.82754995951394,-11.8035753702231,0.169490044091791,-0.0179967222507787,0.0371810116332674,-0.0536288335065096,1.6069710109252};
//   protected constant Real[30] I = {-12.0,-12.0,-8.0,-8.0,-8.0,-8.0,-8.0,-8.0,-6.0,-6.0,-6.0,-6.0,-6.0,-6.0,-4.0,-4.0,-4.0,-3.0,-3.0,-2.0,-2.0,-1.0,-1.0,-1.0,-1.0,0.0,1.0,1.0,2.0,2.0};
//   protected constant Real[30] J = {0.0,1.0,0.0,1.0,3.0,6.0,7.0,8.0,0.0,1.0,2.0,5.0,6.0,10.0,3.0,6.0,10.0,0.0,2.0,1.0,2.0,0.0,1.0,4.0,5.0,0.0,0.0,1.0,2.0,6.0};
//   protected constant Real vstar(quantity = \"Volume\", unit = \"m3\") = 0.0088 \"normalization temperature\";
//   protected constant Real pstar(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 100000000.0 \"normalization pressure\";
//   protected constant Real hstar(quantity = \"SpecificEnergy\", unit = \"J/kg\") = 2800000.0 \"normalization enthalpy\";
//   protected Real pi = p / 100000000.0 \"normalized specific pressure\";
//   protected Real eta = h / 2800000.0 \"normalized specific enthalpy\";
// algorithm
//   v := 0.0088 * (n[1] * (0.0661 + pi) ^ I[1] * (-0.72 + eta) ^ J[1] + n[2] * (0.0661 + pi) ^ I[2] * (-0.72 + eta) ^ J[2] + n[3] * (0.0661 + pi) ^ I[3] * (-0.72 + eta) ^ J[3] + n[4] * (0.0661 + pi) ^ I[4] * (-0.72 + eta) ^ J[4] + n[5] * (0.0661 + pi) ^ I[5] * (-0.72 + eta) ^ J[5] + n[6] * (0.0661 + pi) ^ I[6] * (-0.72 + eta) ^ J[6] + n[7] * (0.0661 + pi) ^ I[7] * (-0.72 + eta) ^ J[7] + n[8] * (0.0661 + pi) ^ I[8] * (-0.72 + eta) ^ J[8] + n[9] * (0.0661 + pi) ^ I[9] * (-0.72 + eta) ^ J[9] + n[10] * (0.0661 + pi) ^ I[10] * (-0.72 + eta) ^ J[10] + n[11] * (0.0661 + pi) ^ I[11] * (-0.72 + eta) ^ J[11] + n[12] * (0.0661 + pi) ^ I[12] * (-0.72 + eta) ^ J[12] + n[13] * (0.0661 + pi) ^ I[13] * (-0.72 + eta) ^ J[13] + n[14] * (0.0661 + pi) ^ I[14] * (-0.72 + eta) ^ J[14] + n[15] * (0.0661 + pi) ^ I[15] * (-0.72 + eta) ^ J[15] + n[16] * (0.0661 + pi) ^ I[16] * (-0.72 + eta) ^ J[16] + n[17] * (0.0661 + pi) ^ I[17] * (-0.72 + eta) ^ J[17] + n[18] * (0.0661 + pi) ^ I[18] * (-0.72 + eta) ^ J[18] + n[19] * (0.0661 + pi) ^ I[19] * (-0.72 + eta) ^ J[19] + n[20] * (0.0661 + pi) ^ I[20] * (-0.72 + eta) ^ J[20] + n[21] * (0.0661 + pi) ^ I[21] * (-0.72 + eta) ^ J[21] + n[22] * (0.0661 + pi) ^ I[22] * (-0.72 + eta) ^ J[22] + n[23] * (0.0661 + pi) ^ I[23] * (-0.72 + eta) ^ J[23] + n[24] * (0.0661 + pi) ^ I[24] * (-0.72 + eta) ^ J[24] + n[25] * (0.0661 + pi) ^ I[25] * (-0.72 + eta) ^ J[25] + n[26] * (0.0661 + pi) ^ I[26] * (-0.72 + eta) ^ J[26] + n[27] * (0.0661 + pi) ^ I[27] * (-0.72 + eta) ^ J[27] + n[28] * (0.0661 + pi) ^ I[28] * (-0.72 + eta) ^ J[28] + n[29] * (0.0661 + pi) ^ I[29] * (-0.72 + eta) ^ J[29] + n[30] * (0.0661 + pi) ^ I[30] * (-0.72 + eta) ^ J[30]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13 \"density at the boundary between regions 1 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   protected Real p2 \"auxiliary variable\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   p2 := 7.1 + -6.04960677555959e-008 * p;
//   o[1] := p2 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   d := 57.4756752485113 / (0.0737412153522555 + p2 * (0.00145092247736023 + p2 * (0.000102697173772229 + p2 * (1.14683182476084e-005 + p2 * (1.99080616601101e-006 + o[1] * p2 * (1.13217858826367e-008 + o[2] * o[3] * p2 * (1.35549330686006e-017 + o[1] * (-3.11228834832975e-019 + o[1] * o[2] * (-7.02987180039442e-022 + p2 * (3.29199117056433e-022 + (-5.17859076694812e-023 + 2.73712834080283e-024 * p2) * p2))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23 \"density at the boundary between regions 2 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   protected Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0);
//   protected Real[13] o \"vector of auxiliary variables\";
//   protected Real taug \"auxiliary variable\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real gpi23 \"derivative of g w.r.t. pi on the boundary between regions 2 and 3\";
// algorithm
//   pi := p / 1000000.0;
//   T := 572.54459862746 + 31.3220101646784 * (-13.91883977887 + pi) ^ 0.5;
//   o[1] := (-13.91883977887 + pi) ^ 0.5;
//   taug := -0.5 + 540.0 / (572.54459862746 + 31.3220101646784 * o[1]);
//   o[2] := taug ^ 2.0;
//   o[3] := o[2] * taug;
//   o[4] := o[2] ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := o[5] ^ 2.0;
//   o[7] := o[4] * o[5] * o[6] * taug;
//   o[8] := o[4] * o[5] * taug;
//   o[9] := o[2] * o[4] * o[5];
//   o[10] := pi ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[4] * o[6] * taug;
//   o[13] := o[6] ^ 2.0;
//   gpi23 := (1.0 + pi * (-0.0017731742473213 + taug * (-0.017834862292358 + taug * (-0.045996013696365 + (-0.057581259083432 + -0.05032527872793 * o[3]) * taug)) + pi * (taug * (-6.6065283340406e-005 + (-0.0003789797503263 + o[2] * (-0.007878555448671 + o[3] * (-0.087594591301146 + -5.3349095828174e-005 * o[7]))) * taug) + pi * (6.1445213076927e-008 + (1.31612001853305e-006 + o[2] * (-9.683303171571e-005 + o[3] * (-0.0045101773626444 + -0.122004760687947 * o[7]))) * taug + pi * (taug * (-3.15389238237468e-009 + (5.116287140914e-008 + 1.92901490874028e-006 * taug) * taug) + pi * (1.14610381688305e-005 * o[2] * o[4] * taug + pi * (o[3] * (-1.00288598706366e-010 + o[8] * (-0.012702883392813 + -143.374451604624 * o[2] * o[6] * taug)) + pi * (-4.1341695026989e-017 + o[2] * o[5] * (-8.8352662293707e-006 + -0.272627897050173 * o[9]) * taug + pi * (o[5] * (9.0049690883672e-011 + -65.8490727183984 * o[4] * o[5] * o[6]) + pi * (1.78287415218792e-007 * o[8] + pi * (o[4] * (1.0406965210174e-018 + o[2] * (-1.0234747095929e-012 + -1.0018179379511e-008 * o[4]) * o[4]) + o[10] * o[11] * ((-1.29412653835176e-009 + 1.71088510070544 * o[12]) * o[7] + o[10] * (-6.05920510335078 * o[13] * o[5] * o[6] * taug + o[10] * (o[4] * o[6] * (1.78371690710842e-023 + o[2] * o[4] * o[5] * (6.1258633752464e-012 + -8.4004935396416e-005 * o[8]) * taug) + pi * (-1.24017662339842e-024 * o[12] + pi * (8.32192847496054e-005 * o[13] * o[4] * o[6] * taug + pi * (o[2] * o[5] * o[6] * (1.75410265428146e-027 + (1.32995316841867e-015 + -2.26487297378904e-005 * o[2] * o[6]) * o[9]) * pi + -2.93678005497663e-014 * o[13] * o[2] * o[4] * taug))))))))))))))))) / pi;
//   d := p / (gpi23 * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3 \"inverse iteration in region 3: (d) = f(p,T)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   input Real delp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"iteration converged if (p-pre(p) < delp)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   output Integer error = 0 \"error flag: iteration failed if different from 0\";
//   protected Real dguess(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"guess density\";
//   protected Integer i = 0 \"loop counter\";
//   protected Real dp \"pressure difference\";
//   protected Real deld(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density step\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives wrt delta and tau\";
//   protected Modelica.Media.Common.NewtonDerivatives_pT nDerivs \"derivatives needed in Newton iteration\";
//   protected Boolean found = false \"flag for iteration success\";
//   protected Boolean supercritical \"flag, true for supercritical states\";
//   protected Boolean liquid \"flag, true for liquid states\";
//   protected Real dmin(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"lower density limit\";
//   protected Real dmax(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"upper density limit\";
//   protected Real Tmax(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"maximum temperature\";
// algorithm
//   assert( p >= 16529200.0, \"BaseIF97.dofpt3: function called outside of region 3! p too low
// p = \" + String(p,0,true,6) + \" Pa < \" + String(16529200.0,0,true,6) + \" Pa\");
//   assert( T >= 623.15, \"BaseIF97.dofpt3: function called outside of region 3! T too low
// T = \" + String(T,0,true,6) + \" K < \" + String(623.15,0,true,6) + \" K\");
//   assert( p >= Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT(T), \"BaseIF97.dofpt3: function called outside of region 3! T too high
// p = \" + String(p,0,true,6) + \" Pa, T = \" + String(T,0,true,6) + \" K\");
//   supercritical := p > 22064000.0;
//   dmax := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp13(p);
//   dmin := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofp23(p);
//   Tmax := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp(p);
//   if supercritical then
//     dguess := dmin + (dmax - dmin * (-623.15 + T)) / (623.15 - Tmax);
//   else
//     liquid := T < Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p);
//     if liquid then
//       dguess := 0.5 * (Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(p) + dmax);
//     else
//       dguess := 0.5 * (Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(p) + dmin);
//     end if;
//   end if;
//   while i < 50 and not found loop
//     d := dguess;
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d,T);
//     nDerivs := Modelica.Media.Common.Helmholtz_pT(f);
//     dp := nDerivs.p - p;
//     if abs(dp / p) <= delp then
//       found := true;
//     end if;
//     deld := dp / nDerivs.pd;
//     d := d - deld;
//     if d > dmin and d < dmax then
//       dguess := d;
//     else
//       if d > dmax then
//         dguess := dmax + -3.16227766016838e-008;
//       else
//         dguess := 3.16227766016838e-008 + dmin;
//       end if;
//     end if;
//     i := 1 + i;
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function dofpt3: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3 \"inverse iteration in region 3: (d,T) = f(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Real delp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"iteration accuracy\";
//   input Real delh(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"iteration accuracy\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Integer error \"error flag: iteration failed if different from 0\";
//   protected Real Tguess(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"initial temperature\";
//   protected Real dguess(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"initial density\";
//   protected Integer i \"iteration counter\";
//   protected Real dh \"Newton-error in h-direction\";
//   protected Real dp \"Newton-error in p-direction\";
//   protected Real det \"determinant of directional derivatives\";
//   protected Real deld \"Newton-step in d-direction\";
//   protected Real delt \"Newton-step in T-direction\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives wrt delta and tau\";
//   protected Modelica.Media.Common.NewtonDerivatives_ph nDerivs \"derivatives needed in Newton iteration\";
//   protected Boolean found \"flag for iteration success\";
//   protected Integer subregion \"1 for subregion 3a, 2 for subregion 3b\";
// algorithm
//   if p < 22064000.0 then
//     subregion := if h < 10.0 + Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(p) then 1 else if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(p) + -10.0 then 2 else 0;
//     assert( subregion <> 0, \"inverse iteration of dt from ph called in 2 phase region: this can not work\");
//   else
//     subregion := if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.h3ab_p(p) then 1 else 2;
//   end if;
//   T := if subregion == 1 then Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3a_ph(p,h) else Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.T3b_ph(p,h);
//   d := if subregion == 1 then 1.0 / Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3a_ph(p,h) else 1.0 / Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.v3b_ph(p,h);
//   i := 0;
//   error := 0;
//   while i < 50 and not found loop
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d,T);
//     nDerivs := Modelica.Media.Common.Helmholtz_ph(f);
//     dh := nDerivs.h - h;
//     dp := nDerivs.p - p;
//     if abs(dh / h) <= delh and abs(dp / p) <= delp then
//       found := true;
//     end if;
//     det := nDerivs.ht * nDerivs.pd - nDerivs.pt * nDerivs.hd;
//     delt := (nDerivs.pd * dh - nDerivs.hd * dp) / det;
//     deld := (nDerivs.ht * dp - nDerivs.pt * dh) / det;
//     T := T - delt;
//     d := d - deld;
//     dguess := d;
//     Tguess := T;
//     i := 1 + i;
//     (d, T) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT(dguess,Tguess);
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function dtofph3: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT \"region limits for inverse iteration in region 3\"
//   input Real din(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   input Real Tin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   output Real dout(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   output Real Tout(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   protected Real Tmin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"approximation of minimum temperature\";
//   protected Real Tmax(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"approximation of maximum temperature\";
// algorithm
//   if din > 765.0 then
//     dout := 765.0;
//   elseif din < 110.0 then
//     dout := 110.0;
//   else
//     dout := din;
//   end if;
//   if dout < 390.0 then
//     Tmax := 554.3557377 + 0.809344262 * dout;
//   else
//     Tmax := 1116.85 + -0.632948717 * dout;
//   end if;
//   if dout < 322.0 then
//     Tmin := 647.096 + -0.000647096 * (-322.0 + dout) ^ 2.0;
//   else
//     Tmin := 647.096 + -0.000449372222222222 * (-322.0 + dout) ^ 2.0;
//   end if;
//   if Tin < Tmin then
//     Tout := Tmin;
//   elseif Tin > Tmax then
//     Tout := Tmax;
//   else
//     Tout := Tin;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.fixdT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5 \"inverse iteration in region 5: (p,T) = f(p,h)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Real reldh(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"iteration accuracy\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Integer error \"error flag: iteration failed if different from 0\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Real proh(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"h for current guess in T\";
//   protected constant Real Tguess(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 1500.0 \"initial temperature\";
//   protected Integer i \"iteration counter\";
//   protected Real relerr \"relative error in h\";
//   protected Real dh \"Newton-error in h-direction\";
//   protected Real dT \"Newton-step in T-direction\";
//   protected Boolean found \"flag for iteration success\";
// algorithm
//   i := 0;
//   error := 0;
//   T := 1500.0;
//   found := false;
//   while i < 50 and not found loop
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(p,T);
//     proh := 461.526 * T * g.tau * g.gtau;
//     dh := proh - h;
//     relerr := dh / h;
//     if abs(relerr) < reldh then
//       found := true;
//     end if;
//     dT := (dh * g.tau ^ -2.0) / (g.gtautau * -461.526);
//     T := T - dT;
//     i := 1 + i;
//   end while;
//   if not found then
//     error := 1;
//   end if;
//   assert( error <> 1, \"error in inverse function tofph5: iteration failed\");
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1 \"intermediate function for isentropic specific enthalpy in region 1\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real[13] o \"vector of auxiliary variables\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau1 \"dimensionless temperature\";
// algorithm
//   tau := 1386.0 / T;
//   pi1 := 7.1 + -p / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hofpT1  called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   tau1 := -1.222 + tau;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] * tau1;
//   o[3] := o[1] ^ 2.0;
//   o[4] := o[3] ^ 2.0;
//   o[5] := o[1] * o[4];
//   o[6] := o[1] * o[3];
//   o[7] := o[3] * tau1;
//   o[8] := o[3] * o[4];
//   o[9] := pi1 ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   o[12] := o[4] ^ 2.0;
//   o[13] := o[12] ^ 2.0;
//   h := 461.526 * T * tau * (pi1 * ((-0.00254871721114236 + o[1] * (0.00424944110961118 + (0.018990068218419 + (-0.021841717175414 + -0.00015851507390979 * o[1]) * o[1]) * o[6])) / o[5] + pi1 * ((0.00141552963219801 + o[3] * (4.7661393906987e-005 + o[1] * (-1.32425535992538e-005 + -1.2358149370591e-014 * o[1] * o[3] * o[4]))) / o[3] + pi1 * ((0.000126718579380216 + -5.11230768720618e-009 * o[5]) / o[7] + pi1 * ((1.1212640954e-005 + o[2] * (1.30342445791202e-006 + -1.4341729937924e-012 * o[8])) / o[6] + pi1 * (o[9] * pi1 * ((1.40077319158051e-008 + 1.04549227383804e-009 * o[7]) / o[8] + o[10] * o[11] * pi1 * (1.9941018075704e-017 / (o[4] * o[3] * o[12] * o[1]) + o[9] * (-4.48827542684151e-019 / o[13] + o[10] * o[9] * (pi1 * (4.65957282962769e-022 / (o[4] * o[13]) + pi1 * ((3.83502057899078e-024 * pi1) / (o[4] * o[13] * o[1]) + -7.2912378325616e-023 / (tau1 * o[4] * o[13]))) + -1.00075970318621e-021 / (tau1 * o[3] * o[13] * o[1]))))) + 3.24135974880936e-006 / (tau1 * o[4])))))) + (-0.29265942426334 + tau1 * (0.84548187169114 + o[1] * (3.3855169168385 + tau1 * (-1.91583926775744 + tau1 * (0.47316115539684 + (-0.066465668798004 + 0.0040607314991784 * tau1) * tau1))))) / o[2]);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2 \"intermediate function for isentropic specific enthalpy in region 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real[16] o \"vector of auxiliary variables\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau2 \"dimensionless temperature\";
// algorithm
//   assert( p > 611.657, \"IF97 medium function hofpT2 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   pi := p / 1000000.0;
//   tau := 540.0 / T;
//   tau2 := -0.5 + tau;
//   o[1] := tau ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := tau2 ^ 2.0;
//   o[4] := o[3] * tau2;
//   o[5] := o[3] ^ 2.0;
//   o[6] := o[5] ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[5] * o[6] * o[7] * tau2;
//   o[9] := o[3] * o[5];
//   o[10] := o[5] * o[6] * tau2;
//   o[11] := o[3] * o[7] * tau2;
//   o[12] := o[3] * o[5] * o[6];
//   o[13] := o[5] * o[6] * o[7];
//   o[14] := pi ^ 2.0;
//   o[15] := o[14] ^ 2.0;
//   o[16] := o[7] ^ 2.0;
//   h := 461.526 * T * tau * ((0.0280439559151 + tau * (-0.2858109552582 + tau * (1.2213149471784 + tau * (-2.848163942888 + tau * (4.38395111945 + o[1] * (10.08665568018 + (-0.5681726521544 + 0.06380539059921 * tau) * tau)))))) / (o[2] * o[1]) + pi * (-0.017834862292358 + tau2 * (-0.09199202739273 + (-0.172743777250296 + -0.30195167236758 * o[4]) * tau2) + pi * (-3.3032641670203e-005 + (-0.0003789797503263 + o[3] * (-0.015757110897342 + o[4] * (-0.306581069554011 + -0.000960283724907132 * o[8]))) * tau2 + pi * (4.3870667284435e-007 + o[3] * (-9.683303171571e-005 + o[4] * (-0.0090203547252888 + -1.42338887469272 * o[8])) + pi * (-7.8847309559367e-010 + (2.558143570457e-008 + 1.44676118155521e-006 * tau2) * tau2 + pi * (1.60454534363627e-005 * o[9] + pi * ((-5.0144299353183e-011 + o[10] * (-0.033874355714168 + -836.35096769364 * o[11])) * o[3] + pi * ((-1.38839897890111e-005 + -0.973671060893475 * o[12]) * o[3] * o[6] + pi * ((9.0049690883672e-011 + -296.320827232793 * o[13]) * o[3] * o[5] * tau2 + pi * (2.57526266427144e-007 * o[5] * o[6] + pi * (o[4] * (4.1627860840696e-019 + (-1.0234747095929e-012 + -1.40254511313154e-008 * o[5]) * o[9]) + o[14] * o[15] * (o[13] * (-2.34560435076256e-009 + 5.3465159397045 * o[5] * o[7] * tau2) + o[14] * (-19.1874828272775 * o[16] * o[6] * o[7] + o[14] * (o[11] * (1.78371690710842e-023 + (1.07202609066812e-011 + -0.000201611844951398 * o[10]) * o[3] * o[5] * o[6] * tau2) + pi * (-1.24017662339842e-024 * o[5] * o[7] + pi * (0.000200482822351322 * o[16] * o[5] * o[7] + pi * (-4.97975748452559e-014 * o[16] * o[3] * o[5] + o[6] * o[7] * (1.90027787547159e-027 + o[12] * (2.21658861403112e-015 + -5.47344301999018e-005 * o[3] * o[7])) * pi * tau2)))))))))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p \"properties on the boiling curve\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives\";
//   protected Real plim(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = min(p,22063999.9999999) \"pressure limited to critical pressure - epsilon\";
// algorithm
//   bpro.R := 461.526;
//   bpro.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(plim);
//   bpro.dpT := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(bpro.T);
//   bpro.region3boundary := bpro.T > 623.15;
//   if not bpro.region3boundary then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p,bpro.T);
//     bpro.d := p / (g.gpi * g.pi * bpro.T * bpro.R);
//     bpro.h := if p > plim then 2087546.84511715 else bpro.R * bpro.T * g.tau * g.gtau;
//     bpro.s := g.R * (g.tau * g.gtau - g.g);
//     bpro.cp := -bpro.R * g.tau ^ 2.0 * g.gtautau;
//     bpro.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * bpro.R) / p;
//     bpro.vp := bpro.R * bpro.T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     bpro.pt := (g.tau * g.gtaupi - g.gpi * p) / (g.pi * g.gpipi * bpro.T);
//     bpro.pd := (-bpro.R * bpro.T * g.gpi ^ 2.0) / g.gpipi;
//   else
//     bpro.d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(plim);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(bpro.d,bpro.T);
//     bpro.h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b(plim);
//     bpro.s := f.R * (f.tau * f.ftau - f.f);
//     bpro.cv := bpro.R * -f.tau ^ 2.0 * f.ftautau;
//     bpro.pt := bpro.R * bpro.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     bpro.pd := bpro.R * bpro.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT \"boundary function for region boundary between regions 2 and 3 (input temperature)\"
//   input Real t(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   protected constant Real[5] n = {348.05185628969,-1.1671859879975,0.0010192970039326,572.54459862746,13.91883977887};
// algorithm
//   p := 348051856.28969 + 1000000.0 * t * (-1.1671859879975 + 0.0010192970039326 * t);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp \"boundary function for region boundary between regions 2 and 3 (input pressure)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real t(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   protected constant Real[5] n = {348.05185628969,-1.1671859879975,0.0010192970039326,572.54459862746,13.91883977887};
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function boundary23ofp called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   t := 572.54459862746 + (-13655.3327687308 + pi / 0.0010192970039326) ^ 0.5;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n \"density in region 1 as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau1 \"dimensionless temperature\";
//   protected Real gpi \"dimensionless Gibbs-derivative w.r.t. pi\";
//   protected Real[11] o \"auxiliary variables\";
// algorithm
//   pi := p / 16530000.0;
//   tau := 1386.0 / T;
//   pi1 := 7.1 - pi;
//   tau1 := tau + -1.222;
//   o[1] := tau1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := o[1] * o[2];
//   o[5] := o[1] * tau1;
//   o[6] := o[2] * tau1;
//   o[7] := pi1 ^ 2.0;
//   o[8] := o[7] ^ 2.0;
//   o[9] := o[8] ^ 2.0;
//   o[10] := o[3] ^ 2.0;
//   o[11] := o[10] ^ 2.0;
//   gpi := pi1 * (pi1 * ((9.5038934535162e-005 + o[2] * (8.4812393955936e-006 + 2.55615384360309e-009 * o[4])) / o[2] + pi1 * ((8.9701127632e-006 + (2.60684891582404e-006 + 5.7366919751696e-013 * o[2] * o[3]) * o[5]) / o[6] + pi1 * (2.02584984300585e-006 / o[3] + o[7] * pi1 * (o[8] * o[9] * pi1 * (o[7] * (o[7] * o[8] * (-7.63737668221055e-022 / (o[1] * o[11] * o[2]) + pi1 * (pi1 * (-5.65070932023524e-023 / (o[11] * o[3]) + (2.99318679335866e-024 * pi1) / (o[11] * o[3] * tau1)) + 3.5842867920213e-022 / (o[1] * o[11] * o[2] * tau1))) + -3.33001080055983e-019 / (o[1] * o[10] * o[2] * o[3] * tau1)) + 1.44400475720615e-017 / (o[10] * o[2] * o[3] * tau1)) + (1.01874413933128e-008 + 1.39398969845072e-009 * o[6]) / (o[1] * o[3] * tau1))))) + (0.00094368642146534 + o[5] * (0.00060003561586052 + (-9.5322787813974e-005 + o[1] * (8.8283690661692e-006 + 1.45389992595188e-015 * o[1] * o[2] * o[3])) * tau1)) / o[5]) + (-0.00028319080123804 + o[1] * (0.00060706301565874 + o[4] * (0.018990068218419 + tau1 * (0.032529748770505 + (0.021841717175414 + 5.283835796993e-005 * o[1]) * tau1)))) / (o[3] * tau1);
//   d := p / (gpi * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n \"density in region 2  as function of p and T\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real tau2 \"dimensionless temperature\";
//   protected Real gpi \"dimensionless Gibbs-derivative w.r.t. pi\";
//   protected Real[12] o \"auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   tau := 540.0 / T;
//   tau2 := tau + -0.5;
//   o[1] := tau2 ^ 2.0;
//   o[2] := o[1] * tau2;
//   o[3] := o[1] ^ 2.0;
//   o[4] := o[3] ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := o[3] * o[4] * o[5] * tau2;
//   o[7] := o[3] * o[4] * tau2;
//   o[8] := o[1] * o[3] * o[4];
//   o[9] := pi ^ 2.0;
//   o[10] := o[9] ^ 2.0;
//   o[11] := o[3] * o[5] * tau2;
//   o[12] := o[5] ^ 2.0;
//   gpi := (1.0 + pi * (-0.0017731742473213 + tau2 * (-0.017834862292358 + tau2 * (-0.045996013696365 + (-0.057581259083432 + -0.05032527872793 * o[2]) * tau2)) + pi * (tau2 * (-6.6065283340406e-005 + (-0.0003789797503263 + o[1] * (-0.007878555448671 + o[2] * (-0.087594591301146 + -5.3349095828174e-005 * o[6]))) * tau2) + pi * (6.1445213076927e-008 + (1.31612001853305e-006 + o[1] * (-9.683303171571e-005 + o[2] * (-0.0045101773626444 + -0.122004760687947 * o[6]))) * tau2 + pi * (tau2 * (-3.15389238237468e-009 + (5.116287140914e-008 + 1.92901490874028e-006 * tau2) * tau2) + pi * (1.14610381688305e-005 * o[1] * o[3] * tau2 + pi * (o[2] * (-1.00288598706366e-010 + o[7] * (-0.012702883392813 + -143.374451604624 * o[1] * o[5] * tau2)) + pi * (-4.1341695026989e-017 + o[1] * o[4] * (-8.8352662293707e-006 + -0.272627897050173 * o[8]) * tau2 + pi * (o[4] * (9.0049690883672e-011 + -65.8490727183984 * o[3] * o[4] * o[5]) + pi * (1.78287415218792e-007 * o[7] + pi * (o[3] * (1.0406965210174e-018 + o[1] * (-1.0234747095929e-012 + -1.0018179379511e-008 * o[3]) * o[3]) + o[10] * o[9] * ((-1.29412653835176e-009 + 1.71088510070544 * o[11]) * o[6] + o[9] * (-6.05920510335078 * o[12] * o[4] * o[5] * tau2 + o[9] * (o[3] * o[5] * (1.78371690710842e-023 + o[1] * o[3] * o[4] * (6.1258633752464e-012 + -8.4004935396416e-005 * o[7]) * tau2) + pi * (-1.24017662339842e-024 * o[11] + pi * (8.32192847496054e-005 * o[12] * o[3] * o[5] * tau2 + pi * (o[1] * o[4] * o[5] * (1.75410265428146e-027 + (1.32995316841867e-015 + -2.26487297378904e-005 * o[1] * o[5]) * o[8]) * pi + -2.93678005497663e-014 * o[1] * o[12] * o[3] * tau2))))))))))))))))) / pi;
//   d := p / (gpi * pi * T * 461.526);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p \"properties on the dew curve\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz function and dervatives\";
//   protected Real plim(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = min(p,22063999.9999999) \"pressure limited to critical pressure - epsilon\";
// algorithm
//   bpro.R := 461.526;
//   bpro.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(plim);
//   bpro.dpT := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(bpro.T);
//   bpro.region3boundary := bpro.T > 623.15;
//   if not bpro.region3boundary then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p,bpro.T);
//     bpro.d := p / (g.gpi * g.pi * bpro.T * bpro.R);
//     bpro.h := if p > plim then 2087546.84511715 else bpro.R * bpro.T * g.tau * g.gtau;
//     bpro.s := g.R * (g.tau * g.gtau - g.g);
//     bpro.cp := -bpro.R * g.tau ^ 2.0 * g.gtautau;
//     bpro.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * bpro.R) / p;
//     bpro.vp := bpro.R * bpro.T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     bpro.pt := (g.tau * g.gtaupi - g.gpi * p) / (g.pi * g.gpipi * bpro.T);
//     bpro.pd := (-bpro.R * bpro.T * g.gpi ^ 2.0) / g.gpipi;
//   else
//     bpro.d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(plim);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(bpro.d,bpro.T);
//     bpro.h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b(plim);
//     bpro.s := f.R * (f.tau * f.ftau - f.f);
//     bpro.cv := bpro.R * -f.tau ^ 2.0 * f.ftautau;
//     bpro.pt := bpro.R * bpro.d * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     bpro.pd := bpro.R * bpro.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p \"liquid specific enthalpy on the boundary between regions 4 and 3 or 1\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b \"explicit approximation of liquid specific enthalpy on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   x := acos(p / 22064000.0);
//   h := 2087546.84511715 + 2087546.84511715 * x * (-0.494558695817518 + x * (1.3468000165649 + x * (-3.88938815320975 + x * (6.67938547288793 + x * (-6.75820241066552 + x * (3.5589197446565 + (-0.717981855497894 + -0.000115203294561782 * x) * x))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1 \"explicit lower specific enthalpy limit of region 1 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   pi1 := 7.1 + -p / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp1 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   o[1] := pi1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   h := 110906.487302526 + 639675.036 * pi1 * (-0.022914084306349 + pi1 * (-0.00017146768241932 + pi1 * (-4.18695814670391e-006 + pi1 * (-2.41630417490008e-007 + pi1 * (1.73545618580828e-011 + o[1] * pi1 * (8.43755552264362e-014 + o[2] * o[3] * pi1 * (5.35429206228374e-035 + o[1] * (-8.12140581014818e-038 + o[1] * o[2] * (-1.43870236842915e-044 + pi1 * (1.73894459122923e-045 + (-7.06381628462585e-047 + 9.64504638626269e-049 * pi1) * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2 \"explicit lower specific enthalpy limit of region 2 as function of pressure (meets region 4 saturation pressure curve at 623.15 K)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real q1 \"auxiliary variable\";
//   protected Real q2 \"auxiliary variable\";
//   protected Real[18] o \"vector of auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp2 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   q1 := 572.54459862746 + 31.3220101646784 * (-13.91883977887 + pi) ^ 0.5;
//   q2 := -0.5 + 540.0 / q1;
//   o[1] := q1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   o[4] := pi ^ 2.0;
//   o[5] := o[4] ^ 2.0;
//   o[6] := q2 ^ 2.0;
//   o[7] := o[6] ^ 2.0;
//   o[8] := o[6] * o[7];
//   o[9] := o[5] ^ 2.0;
//   o[10] := o[7] ^ 2.0;
//   o[11] := o[9] ^ 2.0;
//   o[12] := o[10] ^ 2.0;
//   o[13] := o[12] ^ 2.0;
//   o[14] := o[7] * q2;
//   o[15] := o[6] * q2;
//   o[16] := o[10] * o[6];
//   o[17] := o[13] * o[6];
//   o[18] := o[13] * o[6] * q2;
//   h := (4636975733.03507 + 3.74686560065793 * o[2] + 3.57966647812489e-006 * o[1] * o[2] + 2.81881548488163e-013 * o[3] + -76465233.2452145 * q1 + -0.00450789338787835 * o[2] * q1 + -1.55131504410292e-009 * o[1] * o[2] * q1 + o[1] * (2513837.07870341 + -4781981.98764471 * o[10] * o[11] * o[12] * o[13] * o[4] + 49.9651389369988 * o[11] * o[12] * o[13] * o[4] * o[5] * o[7] + o[15] * o[4] * (1.03746636552761e-013 + -0.00349547959376899 * o[16] + -2.55074501962569e-007 * o[8]) * o[9] + (-242662.235426958 * o[10] * o[12] + -3.46022402653609 * o[16]) * o[4] * o[5] * pi + o[4] * (0.109336249381227 + -2248.08924686956 * o[14] + -354742.725841972 * o[17] + -24.1331193696374 * o[6]) * pi + -3.09081828396912e-019 * o[11] * o[12] * o[5] * o[7] * pi + -1.24107527851371e-008 * o[11] * o[13] * o[4] * o[5] * o[6] * o[7] * pi + 3.99891272904219 * o[5] * o[8] * pi + 0.0641817365250892 * o[10] * o[7] * o[9] * pi + pi * (-4444.87643334512 + -75253.6156722047 * o[14] + -43051.9020511789 * o[6] + -22926.6247146068 * q2) + o[4] * (-8.23252840892034 + -3927.0508365636 * o[15] + -239.325789467604 * o[18] + -76407.3727417716 * o[8] + -94.4508644545118 * q2) + 0.360567666582363 * o[5] * (-0.0161221195808321 + q2) * (0.0338039844460968 + q2) + o[11] * (-0.000584580992538624 * o[10] * o[12] * o[7] + 1332480.30241755 * o[12] * o[13] * q2) + o[9] * (-73850273.6990986 * o[18] + 2.24425477627799e-005 * o[6] * o[7] * q2) + o[4] * o[5] * (-208438767.026518 * o[17] + -1.24971648677697e-005 * o[6] + -8442.30378348203 * o[10] * o[6] * o[7] * q2) + o[11] * (o[9] * (4.73594929247646e-022 * o[10] * o[12] * q2 + -13.6411358215175 * o[10] * o[12] * o[13] * q2 + 5.52427169406836e-010 * o[13] * o[6] * o[7] * q2) + o[5] * (2.67174673301715e-006 * o[17] + 4.44545133805865e-018 * o[12] * o[6] * q2 + -50.2465185106411 * o[10] * o[13] * o[6] * o[7] * q2)))) / o[1];
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5 \"explicit lower specific enthalpy limit of region 5 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hlowerofp5 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   h := 4160681.29030826 + 461526.0 * pi * (-0.00979043490246092 + (-2.03245575263501e-005 + 3.36540214679088e-007 * pi) * pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1 \"explicit upper specific enthalpy limit of region 1 as function of pressure (meets region 4 saturation pressure curve at 623.15 K)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi1 \"dimensionless pressure\";
//   protected Real[3] o \"vector of auxiliary variables\";
// algorithm
//   pi1 := 7.1 + -p / 16530000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp1 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   o[1] := pi1 ^ 2.0;
//   o[2] := o[1] ^ 2.0;
//   o[3] := o[2] ^ 2.0;
//   h := 1553751.00989561 + 639675.036 * pi1 * (-0.00141131225285294 + pi1 * (0.00143759406818289 + pi1 * (0.000125338925082983 + pi1 * (1.23617764767172e-005 + pi1 * (3.17834967400818e-006 + o[1] * pi1 * (1.46754947271665e-008 + o[2] * o[3] * pi1 * (1.86779322717506e-017 + o[1] * (-4.18568363667416e-019 + o[1] * o[2] * (-9.19148577641497e-022 + pi1 * (4.27026404402408e-022 + (-6.66749357417962e-023 + 3.49930466305574e-024 * pi1) * pi1))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2 \"explicit upper specific enthalpy limit of region 2 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
//   protected Real[2] o \"vector of auxiliary variables\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp2 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   o[1] := pi ^ 2.0;
//   o[2] := o[1] ^ 3.0;
//   h := 4160663.37647071 + pi * (-4518.48617188327 + pi * (-8.53409968320258 + pi * (0.109090430596056 + pi * (-0.000172486052272327 + pi * (4.2261295097284e-015 + pi * (-1.27295130636232e-010 + pi * (-3.79407294691742e-025 + pi * (7.56960433802525e-023 + pi * (7.16825117265975e-032 + pi * (3.37267475986401e-021 + (-7.5656940729795e-074 + o[1] * (-8.00969737237617e-134 + (1.6746290980312e-065 + pi * (-3.71600586812966e-069 + pi * (8.06630589170884e-129 + (-1.76117969553159e-103 + 1.88543121025106e-084 * pi) * pi))) * o[1])) * o[2]))))))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5 \"explicit upper specific enthalpy limit of region 5 as function of pressure\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real pi \"dimensionless pressure\";
// algorithm
//   pi := p / 1000000.0;
//   assert( p > 611.657, \"IF97 medium function hupperofp5 called with too low pressure
// p = \" + String(p,0,true,6) + \" Pa <= \" + String(611.657,0,true,6) + \" Pa (triple point pressure)\");
//   h := 7376980.41924296 + 461526.0 * pi * (-0.000489898813722568 + (-5.01510211858761e-008 + 7.5006972718273e-008 * pi) * pi);
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p \"vapour specific enthalpy on the boundary between regions 4 and 3 or 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b \"explicit approximation of vapour specific enthalpy on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   x := acos(p / 22064000.0);
//   h := 2087546.84511715 + 2087546.84511715 * x * (0.488015371865569 + x * (0.207967074625069 + x * (-6.08412269842162 + x * (25.0888760229353 + x * (-48.3821518026952 + x * (45.6648916483321 + (-16.9855544296155 + 0.000661693646005769 * x) * x))))));
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p \"Inline after index reduction\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := bpro.h;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p_der \"derivative function for the specific enthalpy along the phase boundary\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Modelica.Media.Common.IF97PhaseBoundaryProperties bpro \"property record\";
//   input Real p_der \"derivative of pressure\";
//   output Real h_der \"time derivative of specific enthalpy along the phase boundary\";
// algorithm
//   if bpro.region3boundary then
//     h_der := ((bpro.d * bpro.pd - bpro.T * bpro.pt) * p_der + (p_der * (bpro.T * bpro.pt ^ 2.0 + bpro.d ^ 2.0 * bpro.pd * bpro.cv)) / bpro.dpT * bpro.d ^ -2.0) / bpro.pd;
//   else
//     h_der := (1.0 / bpro.d - bpro.T * bpro.vt) * p_der + (p_der * bpro.cp) / bpro.dpT;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p_der;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT \"return the current region (valid values: 1,2,3,5) in IF97, given pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   input Integer mode = 0 \"mode: 0 means check, otherwise assume region=mode\";
//   output Integer region \"region (valid values: 1,2,3,5) in IF97, region 4 is impossible!\";
// algorithm
//   if mode <> 0 then
//     region := mode;
//   else
//     if p < 16529200.0 then
//       if T > 1073.15 then
//         region := 5;
//       elseif T > Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p) then
//         region := 2;
//       else
//         region := 1;
//       end if;
//     else
//       if T < 623.15 then
//         region := 1;
//       elseif T < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boundary23ofp(p) then
//         region := 3;
//       else
//         region := 2;
//       end if;
//     end if;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph \"return the current region (valid values: 1,2,3,4,5) in IF97 for given pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if not known\";
//   input Integer mode = 0 \"mode: 0 means check, otherwise assume region=mode\";
//   output Integer region \"region (valid values: 1,2,3,4,5) in IF97\";
//   protected Boolean hsubcrit;
//   protected Real Ttest(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0);
//   protected Real hl(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"bubble enthalpy\";
//   protected Real hv(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"dew enthalpy\";
// algorithm
//   if mode <> 0 then
//     region := mode;
//   else
//     hl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hl_p(p);
//     hv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hv_p(p);
//     if phase == 2 then
//       region := 4;
//     else
//       if p < 611.657 or p > 100000000.0 or h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp1(p) or p < 10000000.0 and h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5(p) or p >= 10000000.0 and h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp2(p) then
//         region := -1;
//       else
//         hsubcrit := h < 2087546.84511715;
//         if p < 16529200.0 then
//           if hsubcrit then
//             if phase == 1 then
//               region := 1;
//             else
//               if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT1(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p)) then
//                 region := 1;
//               else
//                 region := 4;
//               end if;
//             end if;
//           else
//             if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp5(p) then
//               if p < 10000000.0 and h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp5(p) then
//                 region := 5;
//               else
//                 region := -2;
//               end if;
//             else
//               if phase == 1 then
//                 region := 2;
//               else
//                 if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Isentropic.hofpT2(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(p)) then
//                   region := 2;
//                 else
//                   region := 4;
//                 end if;
//               end if;
//             end if;
//           end if;
//         else
//           if hsubcrit then
//             if h < Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hupperofp1(p) then
//               region := 1;
//             else
//               if h < hl or p > 22064000.0 then
//                 region := 3;
//               else
//                 region := 4;
//               end if;
//             end if;
//           else
//             if h > Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hlowerofp2(p) then
//               region := 2;
//             else
//               if h > hv or p > 22064000.0 then
//                 region := 3;
//               else
//                 region := 4;
//               end if;
//             end if;
//           end if;
//         end if;
//       end if;
//     end if;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b \"explicit approximation of liquid density on the boundary between regions 4 and 3\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real dl(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"liquid density\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   if p < 22064000.0 then
//     x := acos(p / 22064000.0);
//     dl := 322.0 + 322.0 * x * (1.90322407909482 + x * (-2.53148618024011 + x * (-8.19144932384355 + x * (94.3419611677839 + x * (-369.367683362338 + x * (796.662791059829 + x * (-994.53853836007 + x * (673.25811770216 + (-191.430773364052 + 0.00052536560808895 * x) * x))))))));
//   else
//     dl := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b \"explicit approximation of vapour density on the boundary between regions 4 and 2\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real dv(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"vapour density\";
//   protected Real x \"auxiliary variable\";
// algorithm
//   if p < 22064000.0 then
//     x := acos(p / 22064000.0);
//     dv := 322.0 + 322.0 * x * (-1.84638508033626 + x * (-1.14478727188785 + x * (59.1870220307656 + x * (-403.539143181161 + x * (1437.20072453324 + x * (-3015.85354030752 + x * (3740.57903486701 + x * (-2537.3758172539 + (725.876197580378 + -0.00111511116583323 * x) * x))))))));
//   else
//     dv := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b;
// 
// function Modelica.Media.Water.IF97_Utilities.T_ph \"temperature as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature\";
// algorithm
//   T := Modelica.Media.Water.IF97_Utilities.T_props_ph(p,h,Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph(p,h,phase,region));
// end Modelica.Media.Water.IF97_Utilities.T_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.T_ph_der \"derivative function of T_ph\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real h_der \"derivative of specific enthalpy\";
//   output Real T_der \"derivative of temperature\";
// algorithm
//   if aux.region == 4 then
//     T_der := p_der / aux.dpT;
//   elseif aux.region == 3 then
//     T_der := (p_der * (-aux.rho * aux.pd + aux.T * aux.pt)) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) + (h_der * aux.rho ^ 2.0 * aux.pd) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0);
//   else
//     T_der := (p_der * (-1.0 / aux.rho + aux.T * aux.vt)) / aux.cp + h_der / aux.cp;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.T_ph_der;
// 
// function Modelica.Media.Water.IF97_Utilities.T_props_ph \"Inline after index reduction\" \"temperature as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase properties \"auxiliary record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
// algorithm
//   T := properties.T;
// end Modelica.Media.Water.IF97_Utilities.T_props_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.dynamicViscosity \"compute eta(d,T) in the one-phase region\"
//   input Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature (K)\";
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure (only needed for region of validity)\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"dynamic viscosity\";
//   protected constant Real n0 = 1.0 \"viscosity coefficient\";
//   protected constant Real n1 = 0.978197 \"viscosity coefficient\";
//   protected constant Real n2 = 0.579829 \"viscosity coefficient\";
//   protected constant Real n3 = -0.202354 \"viscosity coefficient\";
//   protected constant Real[42] nn = {0.5132047,0.3205656,0.0,0.0,-0.7782567,0.1885447,0.2151778,0.7317883,1.241044,1.476783,0.0,0.0,-0.2818107,-1.070786,-1.263184,0.0,0.0,0.0,0.1778064,0.460504,0.2340379,-0.4924179,0.0,0.0,-0.0417661,0.0,0.0,0.1600435,0.0,0.0,0.0,-0.01578386,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.003629481,0.0,0.0} \"viscosity coefficients\";
//   protected constant Real rhostar(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 317.763 \"scaling density\";
//   protected constant Real etastar(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 5.5071e-005 \"scaling viscosity\";
//   protected constant Real tstar(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 647.226 \"scaling temperature\";
//   protected Integer i \"auxiliary variable\";
//   protected Integer j \"auxiliary variable\";
//   protected Real delta \"dimensionless density\";
//   protected Real deltam1 \"dimensionless density\";
//   protected Real tau \"dimensionless temperature\";
//   protected Real taum1 \"dimensionless temperature\";
//   protected Real Psi0 \"auxiliary variable\";
//   protected Real Psi1 \"auxiliary variable\";
//   protected Real tfun \"auxiliary variable\";
//   protected Real rhofun \"auxiliary variable\";
//   protected Real Tc = T + -273.15 \"Celsius temperature for region check\";
// algorithm
//   delta := d / 317.763;
//   assert( d > 0.00485457572477861, \"IF97 medium function visc_dTp for viscosity called with too low density
// d = \" + String(d,0,true,6) + \" <= \" + String(0.00485457572477861,0,true,6) + \" (triple point density)\");
//   assert( p <= 500000000.0 and Tc >= 0.0 and Tc <= 150.0 or p <= 350000000.0 and Tc > 150.0 and Tc <= 600.0 or p <= 300000000.0 and Tc > 600.0 and Tc <= 900.0, \"IF97 medium function visc_dTp: viscosity computed outside the range
// of validity of the IF97 formulation: p = \" + String(p,0,true,6) + \" Pa, Tc = \" + String(Tc,0,true,6) + \" K\");
//   deltam1 := delta + -1.0;
//   tau := 647.226 / T;
//   taum1 := tau + -1.0;
//   Psi0 := tau ^ -0.5 / (1.0 + (0.978197 + (0.579829 + -0.202354 * tau) * tau) * tau);
//   Psi1 := 0.0;
//   tfun := 1.0;
//   for i in 1:6 loop
//     if i <> 1 then
//       tfun := tfun * taum1;
//     end if;
//     rhofun := 1.0;
//     for j in 0:6 loop
//       if j <> 0 then
//         rhofun := rhofun * deltam1;
//       end if;
//       Psi1 := Psi1 + {0.5132047,0.3205656,0.0,0.0,-0.7782567,0.1885447,0.2151778,0.7317883,1.241044,1.476783,0.0,0.0,-0.2818107,-1.070786,-1.263184,0.0,0.0,0.0,0.1778064,0.460504,0.2340379,-0.4924179,0.0,0.0,-0.0417661,0.0,0.0,0.1600435,0.0,0.0,0.0,-0.01578386,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-0.003629481,0.0,0.0}[i + 6 * j] * tfun * rhofun;
//     end for;
//   end for;
//   eta := 5.5071e-005 * Psi0 * exp(delta * Psi1);
// end Modelica.Media.Water.IF97_Utilities.dynamicViscosity;
// 
// function Modelica.Media.Water.IF97_Utilities.h_pT \"specific enthalpy as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.h_props_pT(p,T,Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT(p,T,region));
// end Modelica.Media.Water.IF97_Utilities.h_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.h_pT_der \"derivative function of h_pT\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real T_der \"derivative of temperature\";
//   output Real h_der \"derivative of specific enthalpy\";
// algorithm
//   if aux.region == 3 then
//     h_der := (p_der * (-aux.rho * aux.pd + T * aux.pt) * aux.rho ^ -2.0) / aux.pd + (T_der * (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) * aux.rho ^ -2.0) / aux.pd;
//   else
//     h_der := (1.0 / aux.rho - aux.T * aux.vt) * p_der + aux.cp * T_der;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.h_pT_der;
// 
// function Modelica.Media.Water.IF97_Utilities.h_props_pT \"Inline after index reduction\" \"specific enthalpy as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := aux.h;
// end Modelica.Media.Water.IF97_Utilities.h_props_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.hl_p \"compute the saturated liquid specific h(p)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.boilingcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.hl_p;
// 
// function Modelica.Media.Water.IF97_Utilities.hv_p \"compute the saturated vapour specific h(p)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
// algorithm
//   h := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.hvl_p(p,Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.dewcurve_p(p));
// end Modelica.Media.Water.IF97_Utilities.hv_p;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_pT \"density as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
// algorithm
//   rho := Modelica.Media.Water.IF97_Utilities.rho_props_pT(p,T,Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT(p,T,region));
// end Modelica.Media.Water.IF97_Utilities.rho_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_pT_der \"derivative function of rho_pT\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real T_der \"derivative of temperature\";
//   output Real rho_der \"derivative of density\";
// algorithm
//   if aux.region == 3 then
//     rho_der := p_der / aux.pd + (-T_der * aux.pt) / aux.pd;
//   else
//     rho_der := -aux.rho ^ 2.0 * (aux.vp * p_der + aux.vt * T_der);
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rho_pT_der;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_ph \"density as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Integer phase = 0 \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Integer region = 0 \"if 0, region is unknown, otherwise known and this input\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
// algorithm
//   rho := Modelica.Media.Water.IF97_Utilities.rho_props_ph(p,h,Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph(p,h,phase,region));
// end Modelica.Media.Water.IF97_Utilities.rho_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_ph_der \"derivative function of rho_ph\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   input Real p_der \"derivative of pressure\";
//   input Real h_der \"derivative of specific enthalpy\";
//   output Real rho_der \"derivative of density\";
// algorithm
//   if aux.region == 4 then
//     rho_der := (p_der * aux.rho * (1.0 + (aux.rho * aux.cv) / aux.dpT)) / (aux.T * aux.dpT) + (-h_der * aux.rho ^ 2.0) / (aux.T * aux.dpT);
//   elseif aux.region == 3 then
//     rho_der := (p_der * aux.rho * (aux.cv * aux.rho + aux.pt)) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0) + (h_der * -aux.rho ^ 2.0 * aux.pt) / (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0);
//   else
//     rho_der := (p_der * -aux.rho ^ 2.0 * (aux.vp * aux.cp + -aux.vt / aux.rho + aux.T * aux.vt ^ 2.0)) / aux.cp + (h_der * -aux.rho ^ 2.0 * aux.vt) / aux.cp;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rho_ph_der;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_props_pT \"Inline after index reduction\" \"density as function or pressure and temperature\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
// algorithm
//   rho := aux.rho;
// end Modelica.Media.Water.IF97_Utilities.rho_props_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.rho_props_ph \"Inline after index reduction\" \"density as function of pressure and specific enthalpy\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Modelica.Media.Common.IF97BaseTwoPhase properties \"auxiliary record\";
//   output Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density\";
// algorithm
//   rho := properties.rho;
// end Modelica.Media.Water.IF97_Utilities.rho_props_ph;
// 
// function Modelica.Media.Water.IF97_Utilities.rhol_T \"compute the saturated liquid d(T)\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density of water at the boiling point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d1n(p,T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhol_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rhol_T;
// 
// function Modelica.Media.Water.IF97_Utilities.rhov_T \"compute the saturated vapour d(T)\"
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"density of steam at the condensation point\";
//   protected Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"saturation pressure\";
// algorithm
//   p := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.psat(T);
//   if T < 623.15 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.d2n(p,T);
//   elseif T < 647.096 then
//     d := Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.rhov_p_R4b(p);
//   else
//     d := 322.0;
//   end if;
// end Modelica.Media.Water.IF97_Utilities.rhov_T;
// 
// function Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT \"intermediate property record for water (p and T prefered states)\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature\";
//   input Integer region = 0 \"if 0, do region computation, otherwise assume the region is this input\";
//   output Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz funcion and dervatives wrt delta and tau\";
//   protected Integer error \"error flag for inverse iterations\";
// algorithm
//   aux.phase := 1;
//   aux.region := if region == 0 then Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_pT(p,T,0) else region;
//   aux.R := 461.526;
//   aux.p := p;
//   aux.T := T;
//   if aux.region == 1 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p,T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 0.0;
//   elseif aux.region == 2 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p,T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 1.0;
//   elseif aux.region == 3 then
//     (aux.rho, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dofpt3(p,T,1e-007);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(aux.rho,T);
//     aux.h := aux.R * T * (f.tau * f.ftau + f.delta * f.fdelta);
//     aux.s := aux.R * (f.tau * f.ftau - f.f);
//     aux.pd := aux.R * T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//     aux.pt := aux.R * aux.rho * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     aux.cv := aux.R * -f.tau ^ 2.0 * f.ftautau;
//     aux.x := 0.0;
//   elseif aux.region == 5 then
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(p,T);
//     aux.h := aux.R * aux.T * g.tau * g.gtau;
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//   else
//     assert( false, \"error in region computation of IF97 steam tables(p = \" + String(p,0,true,6) + \", T = \" + String(T,0,true,6) + \")\");
//   end if;
// end Modelica.Media.Water.IF97_Utilities.waterBaseProp_pT;
// 
// function Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph \"intermediate property record for water\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"specific enthalpy\";
//   input Integer phase = 0 \"phase: 2 for two-phase, 1 for one phase, 0 if unknown\";
//   input Integer region = 0 \"if 0, do region computation, otherwise assume the region is this input\";
//   output Modelica.Media.Common.IF97BaseTwoPhase aux \"auxiliary record\";
//   protected Modelica.Media.Common.GibbsDerivs g \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs f \"dimensionless Helmholtz funcion and dervatives wrt delta and tau\";
//   protected Integer error \"error flag for inverse iterations\";
//   protected Real h_liq(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"liquid specific enthalpy\";
//   protected Real d_liq(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"liquid density\";
//   protected Real h_vap(quantity = \"SpecificEnergy\", unit = \"J/kg\") \"vapour specific enthalpy\";
//   protected Real d_vap(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"vapour density\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties liq \"phase boundary property record\";
//   protected Modelica.Media.Common.PhaseBoundaryProperties vap \"phase boundary property record\";
//   protected Modelica.Media.Common.GibbsDerivs gl \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Modelica.Media.Common.GibbsDerivs gv \"dimensionless Gibbs funcion and dervatives wrt pi and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fl \"dimensionless Helmholtz function and dervatives wrt delta and tau\";
//   protected Modelica.Media.Common.HelmholtzDerivs fv \"dimensionless Helmholtz function and dervatives wrt delta and tau\";
//   protected Real t1(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature at phase boundary, using inverse from region 1\";
//   protected Real t2(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"temperature at phase boundary, using inverse from region 2\";
// algorithm
//   aux.region := if region == 0 then if phase == 2 then 4 else Modelica.Media.Water.IF97_Utilities.BaseIF97.Regions.region_ph(p,h,phase,0) else region;
//   aux.phase := if phase <> 0 then phase else if aux.region == 4 then 2 else 1;
//   aux.p := max(p,611.657);
//   aux.h := max(h,1000.0);
//   aux.R := 461.526;
//   if aux.region == 1 then
//     aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1(aux.p,aux.h);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(p,aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * aux.T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 0.0;
//     aux.dpT := -aux.vt / aux.vp;
//   elseif aux.region == 2 then
//     aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2(aux.p,aux.h);
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(p,aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * aux.T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.x := 1.0;
//     aux.dpT := -aux.vt / aux.vp;
//   elseif aux.region == 3 then
//     (aux.rho, aux.T, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.dtofph3(aux.p,aux.h,1e-007,1e-006);
//     f := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(aux.rho,aux.T);
//     aux.h := aux.R * aux.T * (f.tau * f.ftau + f.delta * f.fdelta);
//     aux.s := aux.R * (f.tau * f.ftau - f.f);
//     aux.pd := aux.R * aux.T * f.delta * (2.0 * f.fdelta + f.delta * f.fdeltadelta);
//     aux.pt := aux.R * aux.rho * f.delta * (f.fdelta - f.tau * f.fdeltatau);
//     aux.cv := abs(aux.R * -f.tau ^ 2.0 * f.ftautau);
//     aux.cp := (aux.rho ^ 2.0 * aux.pd * aux.cv + aux.T * aux.pt ^ 2.0 * aux.rho ^ -2.0) / aux.pd;
//     aux.x := 0.0;
//     aux.dpT := aux.pt;
//   elseif aux.region == 4 then
//     h_liq := Modelica.Media.Water.IF97_Utilities.hl_p(p);
//     h_vap := Modelica.Media.Water.IF97_Utilities.hv_p(p);
//     aux.x := if h_vap <> h_liq then (h - h_liq) / (h_vap - h_liq) else 1.0;
//     if p < 16529200.0 then
//       t1 := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph1(aux.p,h_liq);
//       t2 := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tph2(aux.p,h_vap);
//       gl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g1(aux.p,t1);
//       gv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g2(aux.p,t2);
//       liq := Modelica.Media.Common.gibbsToBoundaryProps(gl);
//       vap := Modelica.Media.Common.gibbsToBoundaryProps(gv);
//       aux.T := t1 + aux.x * (t2 - t1);
//     else
//       aux.T := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.tsat(aux.p);
//       d_liq := Modelica.Media.Water.IF97_Utilities.rhol_T(aux.T);
//       d_vap := Modelica.Media.Water.IF97_Utilities.rhov_T(aux.T);
//       fl := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_liq,aux.T);
//       fv := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.f3(d_vap,aux.T);
//       liq := Modelica.Media.Common.helmholtzToBoundaryProps(fl);
//       vap := Modelica.Media.Common.helmholtzToBoundaryProps(fv);
//     end if;
//     aux.dpT := if liq.d <> vap.d then (vap.s - liq.s * liq.d * vap.d) / (liq.d - vap.d) else Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.dptofT(aux.T);
//     aux.s := liq.s + aux.x * (vap.s - liq.s);
//     aux.rho := (liq.d * vap.d) / (vap.d + aux.x * (liq.d - vap.d));
//     aux.cv := Modelica.Media.Common.cv2Phase(liq,vap,aux.x,aux.T,p);
//     aux.cp := liq.cp + aux.x * (vap.cp - liq.cp);
//     aux.pt := liq.pt + aux.x * (vap.pt - liq.pt);
//     aux.pd := liq.pd + aux.x * (vap.pd - liq.pd);
//   elseif aux.region == 5 then
//     (aux.T, error) := Modelica.Media.Water.IF97_Utilities.BaseIF97.Inverses.tofph5(aux.p,aux.h,1e-007);
//     assert( error == 0, \"error in inverse iteration of steam tables\");
//     g := Modelica.Media.Water.IF97_Utilities.BaseIF97.Basic.g5(aux.p,aux.T);
//     aux.s := aux.R * (g.tau * g.gtau - g.g);
//     aux.rho := p / (g.gpi * g.pi * aux.T * aux.R);
//     aux.vt := (g.pi * g.gpi - g.tau * g.pi * g.gtaupi * aux.R) / p;
//     aux.vp := aux.R * aux.T * p ^ -2.0 * g.pi ^ 2.0 * g.gpipi;
//     aux.cp := -aux.R * g.tau ^ 2.0 * g.gtautau;
//     aux.cv := aux.R * (-g.tau ^ 2.0 * g.gtautau + (g.gpi - g.tau * g.gtaupi) ^ 2.0 / g.gpipi);
//     aux.dpT := -aux.vt / aux.vp;
//   else
//     assert( false, \"error in region computation of IF97 steam tables(p = \" + String(p,0,true,6) + \", h = \" + String(h,0,true,6) + \")\");
//   end if;
// end Modelica.Media.Water.IF97_Utilities.waterBaseProp_ph;
// 
// function Modelica.SIunits.Conversions.from_degC \"Convert from Celsius to Kelvin\"
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Kelvin value\";
// algorithm
//   Kelvin := Celsius + 273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// function Modelica.SIunits.Conversions.to_bar \"Convert from Pascal to bar\"
//   input Real Pa(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pascal value\";
//   output Real bar(quantity = \"Pressure\", unit = \"bar\") \"bar value\";
// algorithm
//   bar := Pa / 100000.0;
// end Modelica.SIunits.Conversions.to_bar;
// 
// function Modelica.SIunits.Conversions.to_degC \"Convert from Kelvin to Celsius\"
//   input Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Kelvin value\";
//   output Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
// algorithm
//   Celsius := -273.15 + Kelvin;
// end Modelica.SIunits.Conversions.to_degC;
// 
// function linspace
//   input Real x1 \"start\";
//   input Real x2 \"end\";
//   input Integer n \"number\";
//   output Real[n] v;
// algorithm
//   assert( n >= 2, \"linspace requires n>=2 but got \" + String(n,0,true));
//   v := <reduction>array(x1 + ((x2 - x1) * Real(i + -1)) / Real(n + -1) for i in 1:n);
// end linspace;
// 
// class Modelica.Fluid.Examples.HeatingSystem
//   parameter Real system.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 101325.0 \"Default ambient pressure\";
//   parameter Real system.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Default ambient temperature\";
//   parameter Real system.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.80665 \"Constant gravity acceleration\";
//   parameter Boolean system.allowFlowReversal = true \"= false to restrict to design flow direction (port_a -> port_b)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.energyDynamics = Modelica.Fluid.Types.Dynamics.SteadyStateInitial \"Default formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Default formulation of momentum balances, if options available\";
//   parameter Real system.m_flow_start(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0 \"Default start value for mass flow rates\";
//   parameter Real system.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = 0.0001 \"Default small laminar mass flow rate for regularization of zero flow\";
//   parameter Real system.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1.0 \"Default small pressure drop for regularization of laminar and zero flow\";
//   parameter Real system.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.p_ambient \"Default start value for pressures\";
//   parameter Real system.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Default start value for temperatures\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.massDynamics = system.energyDynamics \"Default formulation of mass balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.substanceDynamics = system.massDynamics \"Default formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.traceDynamics = system.massDynamics \"Default formulation of trace substance balances\";
//   input Real tank.fluidVolume(quantity = \"Volume\", unit = \"m3\") = tank.V \"Volume\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank.energyDynamics = system.energyDynamics \"Formulation of energy balance\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank.massDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial \"Formulation of mass balance\";
//   parameter Boolean tank.use_T_start = true \"= true, use T_start, otherwise h_start\";
//   parameter Real tank.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if tank.use_T_start then system.T_start else Modelica.Fluid.Vessels.OpenTank.Medium.temperature_phX(tank.p_start,tank.h_start,{tank.X_start[1]},0) \"Start value of temperature\";
//   parameter Real tank.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) = if tank.use_T_start then Modelica.Fluid.Vessels.OpenTank.Medium.specificEnthalpy_pTX(tank.p_start,tank.T_start,{tank.X_start[1]},0) else 0.0 \"Start value of specific enthalpy\";
//   parameter Real tank.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   Real tank.U(quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real tank.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Mass of fluid\";
//   Real tank.mb_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flows across boundaries\";
//   Real tank.Hb_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow across boundaries or energy source/sink\";
//   Real tank.Qb_flow(quantity = \"Power\", unit = \"W\") \"Heat flow across boundaries or energy source/sink\";
//   Real tank.Wb_flow(quantity = \"Power\", unit = \"W\") \"Work flow across boundaries or source term\";
//   protected parameter Boolean tank.initialize_p = false \"= true to set up initial equations for pressure\";
//   parameter Integer tank.nPorts = 2 \"Number of ports\";
//   parameter Boolean tank.use_portsData = true \"= false to neglect pressure loss and kinetic energy\";
//   parameter Real tank.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = system.m_flow_small \"Regularization range at zero mass flow rate\";
//   parameter Boolean tank.use_HeatTransfer = true \"= true to use the HeatTransfer model\";
//   protected input Real tank.fluidLevel(quantity = \"Length\", unit = \"m\", min = 0.0) = tank.level \"level of fluid in the vessel for treating heights of ports\";
//   Real tank.V(quantity = \"Volume\", unit = \"m3\", StateSelect = StateSelect.never) \"Actual tank volume\";
//   parameter Real tank.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 \"Height of tank\";
//   parameter Real tank.crossArea(quantity = \"Area\", unit = \"m2\") = 0.01 \"Area of tank\";
//   parameter Real tank.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_ambient \"Tank surface pressure\";
//   parameter Real tank.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = system.T_ambient \"Tank surface Temperature\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank.substanceDynamics = tank.massDynamics \"Formulation of substance balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank.traceDynamics = tank.massDynamics \"Formulation of trace substance balance\";
//   Real tank.ports[1].m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real tank.ports[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real tank.ports[1].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real tank.ports[2].m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real tank.ports[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real tank.ports[2].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real tank.ports_H_flow[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0);
//   Real tank.ports_H_flow[2](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0);
//   Real tank.portDensities[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"densites of the fluid at the device boudary\";
//   Real tank.portDensities[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"densites of the fluid at the device boudary\";
//   Real tank.portVelocities[1](quantity = \"Velocity\", unit = \"m/s\") \"velocities of fluid flow at device boundary\";
//   Real tank.portVelocities[2](quantity = \"Velocity\", unit = \"m/s\") \"velocities of fluid flow at device boundary\";
//   Real tank.ports_E_flow[1](quantity = \"Power\", unit = \"W\") \"flow of kinetic and potential energy at device boundary\";
//   Real tank.ports_E_flow[2](quantity = \"Power\", unit = \"W\") \"flow of kinetic and potential energy at device boundary\";
//   Real tank.ports_penetration[1] \"penetration of port with fluid, depending on fluid level and port diameter\";
//   Real tank.ports_penetration[2] \"penetration of port with fluid, depending on fluid level and port diameter\";
//   Real tank.portAreas[1](quantity = \"Area\", unit = \"m2\") = 0.785398163397448 * tank.portsData_diameter[1] ^ 2.0;
//   Real tank.portAreas[2](quantity = \"Area\", unit = \"m2\") = 0.785398163397448 * tank.portsData_diameter[2] ^ 2.0;
//   Real tank.vessel_ps_static[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"static pressures inside the vessel at the height of the corresponding ports, zero flow velocity\";
//   Real tank.vessel_ps_static[2](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"static pressures inside the vessel at the height of the corresponding ports, zero flow velocity\";
//   protected input Real tank.portsData_diameter[1];
//   protected input Real tank.portsData_diameter[2];
//   protected input Real tank.portsData_height[1];
//   protected input Real tank.portsData_height[2];
//   protected input Real tank.portsData_zeta_in[1];
//   protected input Real tank.portsData_zeta_in[2];
//   protected input Real tank.portsData_zeta_out[1];
//   protected input Real tank.portsData_zeta_out[2];
//   parameter Real tank.portsData[1].diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.01 \"Inner (hydraulic) diameter of inlet/outlet port\";
//   parameter Real tank.portsData[1].height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0 \"Height over the bottom of the vessel\";
//   parameter Real tank.portsData[1].zeta_out(min = 0.0) = 0.5 \"Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall\";
//   parameter Real tank.portsData[1].zeta_in(min = 0.0) = 1.04 \"Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall\";
//   parameter Real tank.portsData[2].diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.01 \"Inner (hydraulic) diameter of inlet/outlet port\";
//   parameter Real tank.portsData[2].height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0 \"Height over the bottom of the vessel\";
//   parameter Real tank.portsData[2].zeta_out(min = 0.0) = 0.5 \"Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall\";
//   parameter Real tank.portsData[2].zeta_in(min = 0.0) = 1.04 \"Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall\";
//   Real tank.heatPort.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real tank.heatPort.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected parameter Real tank.fluidLevel_max(quantity = \"Length\", unit = \"m\", min = 0.0) = tank.height \"maximum level of fluid in the vessel\";
//   parameter Real tank.level_start(quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0 \"Start value of tank level\";
//   protected parameter Real tank.vesselArea(quantity = \"Area\", unit = \"m2\") = tank.crossArea \"Area of the vessel used to relate to cross flow area of ports\";
//   parameter Real tank.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank.p_ambient \"Start value of pressure\";
//   Real tank.s[1](start = tank.fluidLevel_max) \"curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices\";
//   Real tank.s[2](start = tank.fluidLevel_max) \"curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices\";
//   Real tank.level(quantity = \"Length\", unit = \"m\", min = 0.0, start = max(tank.level_start,1e-015), StateSelect = StateSelect.prefer) \"Level height of tank\";
//   input Real tank.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = tank.p_start, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real tank.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = tank.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real tank.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real tank.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = tank.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real tank.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real tank.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real tank.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real tank.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer tank.medium.state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real tank.medium.state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real tank.medium.state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real tank.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real tank.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean tank.medium.preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean tank.medium.standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real tank.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(tank.medium.T) \"Temperature of medium in [degC]\";
//   Real tank.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(tank.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real tank.medium.sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real tank.medium.sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer tank.medium.phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   parameter Integer tank.heatTransfer.n = 1 \"Number of heat transfer segments\";
//   parameter Boolean tank.heatTransfer.use_k = tank.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real tank.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 10.0 \"Heat transfer coefficient to ambient\";
//   parameter Real tank.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Ambient temperature\";
//   input Integer tank.heatTransfer.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real tank.heatTransfer.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real tank.heatTransfer.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real tank.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real tank.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real tank.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") = tank.crossArea + 2.0 * (sqrt(3.14159265358979 * tank.crossArea) * tank.level) \"Heat transfer areas\";
//   output Real tank.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   Real tank.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real tank.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real tank.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Vessels.OpenTank.HeatTransfer.Medium.temperature(tank.heatTransfer.states[1]) \"Temperatures defined by fluid states\";
//   protected input Real tank.portsData_diameter_internal[1] = tank.portsData[1].diameter;
//   protected input Real tank.portsData_diameter_internal[2] = tank.portsData[2].diameter;
//   protected input Real tank.portsData_height_internal[1] = tank.portsData[1].height;
//   protected input Real tank.portsData_height_internal[2] = tank.portsData[2].height;
//   protected input Real tank.portsData_zeta_in_internal[1] = tank.portsData[1].zeta_in;
//   protected input Real tank.portsData_zeta_in_internal[2] = tank.portsData[2].zeta_in;
//   protected input Real tank.portsData_zeta_out_internal[1] = tank.portsData[1].zeta_out;
//   protected input Real tank.portsData_zeta_out_internal[2] = tank.portsData[2].zeta_out;
//   parameter Boolean pump.allowFlowReversal = false \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real pump.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pump.allowFlowReversal and not pump.checkValve then -1e+060 else 0.0, max = 100000.0, start = pump.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real pump.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = pump.p_a_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pump.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real pump.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if pump.allowFlowReversal and not pump.checkValve then 1e+060 else 0.0, start = -pump.m_flow_start) \"Mass flow rate from the connection point into the component\";
//   Real pump.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = pump.p_b_start, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pump.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean pump.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean pump.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real pump.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 110000.0 \"Guess value for inlet pressure\";
//   parameter Real pump.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = 0.01 \"Guess value of m_flow = port_a.m_flow\";
//   parameter Integer pump.nParallel(min = 1) = 1 \"Number of pumps in parallel\";
//   parameter Real pump.N_nominal(quantity = \"AngularVelocity\", unit = \"1/min\") = 1500.0 \"Nominal rotational speed for flow characteristic\";
//   parameter Real pump.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = Modelica.Fluid.Machines.ControlledPump.Medium.density_pTX(101325.0,293.15,{1.0}) \"Nominal fluid density for characteristic\";
//   parameter Boolean pump.use_powerCharacteristic = false \"Use powerCharacteristic (vs. efficiencyCharacteristic)\";
//   parameter Boolean pump.checkValve = false \"= true to prevent reverse flow\";
//   parameter Real pump.V(quantity = \"Volume\", unit = \"m3\") = 0.0 \"Volume inside the pump\";
//   input Real pump.fluidVolume(quantity = \"Volume\", unit = \"m3\") = pump.V \"Volume\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pump.energyDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Formulation of energy balance\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pump.massDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Formulation of mass balance\";
//   parameter Boolean pump.use_T_start = true \"= true, use T_start, otherwise h_start\";
//   parameter Real pump.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = 313.15 \"Start value of temperature\";
//   parameter Real pump.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) = if pump.use_T_start then Modelica.Fluid.Machines.ControlledPump.Medium.specificEnthalpy_pTX(pump.p_start,pump.T_start,{pump.X_start[1]},0) else 0.0 \"Start value of specific enthalpy\";
//   parameter Real pump.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   Real pump.U(quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real pump.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Mass of fluid\";
//   Real pump.mb_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flows across boundaries\";
//   Real pump.Hb_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow across boundaries or energy source/sink\";
//   Real pump.Qb_flow(quantity = \"Power\", unit = \"W\") \"Heat flow across boundaries or energy source/sink\";
//   Real pump.Wb_flow(quantity = \"Power\", unit = \"W\") \"Work flow across boundaries or source term\";
//   protected parameter Boolean pump.initialize_p = true \"= true to set up initial equations for pressure\";
//   parameter Boolean pump.use_HeatTransfer = false \"= true to use a HeatTransfer model, e.g. for a housing\";
//   final parameter Real pump.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g;
//   Real pump.rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = pump.medium.d;
//   Real pump.dp_pump(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = pump.port_b.p - pump.port_a.p \"Pressure increase\";
//   Real pump.head(quantity = \"Length\", unit = \"m\", min = 0.0) = pump.dp_pump / (pump.g * pump.rho) \"Pump head\";
//   Real pump.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") = pump.port_a.m_flow \"Mass flow rate (total)\";
//   Real pump.m_flow_single(quantity = \"MassFlowRate\", unit = \"kg/s\") = pump.m_flow / Real(pump.nParallel) \"Mass flow rate (single pump)\";
//   Real pump.V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = pump.m_flow / pump.rho \"Volume flow rate (total)\";
//   Real pump.W_single(quantity = \"Power\", unit = \"W\") \"Power Consumption (single pump)\";
//   Real pump.W_total(quantity = \"Power\", unit = \"W\") = pump.W_single * Real(pump.nParallel) \"Power Consumption (total)\";
//   Real pump.eta \"Global Efficiency\";
//   parameter Boolean pump.show_NPSHa = false \"= true to compute Net Positive Suction Head available\";
//   protected constant Real pump.unitHead(quantity = \"Length\", unit = \"m\", min = 0.0) = 1.0;
//   protected constant Real pump.unitMassFlowRate(quantity = \"MassFlowRate\", unit = \"kg/s\") = 1.0;
//   parameter Real pump.p_a_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 110000.0 \"Nominal inlet pressure for predefined pump characteristics\";
//   parameter Real pump.p_b_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 130000.0 \"Nominal outlet pressure, fixed if not control_m_flow and not use_p_set\";
//   parameter Real pump.m_flow_nominal(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = 0.01 \"Nominal mass flow rate, fixed if control_m_flow and not use_m_flow_set\";
//   parameter Boolean pump.control_m_flow = false \"= false to control outlet pressure port_b.p instead of m_flow\";
//   parameter Boolean pump.use_m_flow_set = false \"= true to use input signal m_flow_set instead of m_flow_nominal\";
//   parameter Boolean pump.use_p_set = false \"= true to use input signal p_set instead of p_b_nominal\";
//   protected input Real pump.m_flow_set_internal \"Needed to connect to conditional connector\";
//   protected input Real pump.p_set_internal \"Needed to connect to conditional connector\";
//   parameter Real pump.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 130000.0 \"Guess value for outlet pressure\";
//   Real pump.s(start = pump.m_flow_start) \"Curvilinear abscissa for the flow curve in parametric form (either mass flow rate or head)\";
//   Real pump.V_flow_single(quantity = \"VolumeFlowRate\", unit = \"m3/s\", start = pump.m_flow_start / (Real(pump.nParallel) * pump.rho_nominal)) = pump.V_flow / Real(pump.nParallel) \"Volume flow rate (single pump)\";
//   protected parameter Boolean pump.port_b_exposesState = pump.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or pump.massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true if port_b.p exposes the state of a fluid volume\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pump.substanceDynamics = pump.massDynamics \"Formulation of substance balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pump.traceDynamics = pump.massDynamics \"Formulation of trace substance balance\";
//   parameter Integer pump.heatTransfer.n = 1 \"Number of heat transfer segments\";
//   parameter Boolean pump.heatTransfer.use_k = pump.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real pump.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real pump.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Ambient temperature\";
//   input Integer pump.heatTransfer.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real pump.heatTransfer.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real pump.heatTransfer.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real pump.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real pump.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real pump.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") = 12.5663706143592 * (0.238732414637843 * pump.V) ^ 0.666666666666667 \"Heat transfer areas\";
//   output Real pump.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   Real pump.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real pump.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real pump.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Machines.ControlledPump.HeatTransfer.Medium.temperature(pump.heatTransfer.states[1]) \"Temperatures defined by fluid states\";
//   final parameter Real pump.head_op(quantity = \"Length\", unit = \"m\", min = 0.0) = (pump.p_b_nominal - pump.p_a_nominal) / (pump.g * pump.rho_nominal) \"operational pump head according to nominal values\";
//   final parameter Real pump.V_flow_op(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = pump.m_flow_nominal / pump.rho_nominal \"operational volume flow rate according to nominal values\";
//   parameter Real pump.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pump.p_b_start \"Start value of pressure\";
//   input Real pump.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = pump.p_start, StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real pump.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = pump.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real pump.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real pump.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = pump.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real pump.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real pump.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real pump.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real pump.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer pump.medium.state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pump.medium.state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pump.medium.state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pump.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pump.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean pump.medium.preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean pump.medium.standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real pump.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(pump.medium.T) \"Temperature of medium in [degC]\";
//   Real pump.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(pump.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real pump.medium.sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real pump.medium.sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer pump.medium.phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   Real pump.N(quantity = \"AngularVelocity\", unit = \"1/min\", start = pump.N_nominal) \"Shaft rotational speed\";
//   parameter Boolean valve.allowFlowReversal = false \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real valve.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if valve.allowFlowReversal then -1e+060 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real valve.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real valve.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real valve.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if valve.allowFlowReversal then 1e+060 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real valve.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real valve.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean valve.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean valve.port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean valve.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real valve.m_flow_small(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_small \"Small mass flow rate for regularization of zero flow\";
//   parameter Boolean valve.show_T = true \"= true, if temperatures at port_a and port_b are computed\";
//   parameter Boolean valve.show_V_flow = true \"= true, if volume flow rate at inflowing port is computed\";
//   Integer valve.state_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real valve.state_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real valve.state_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real valve.state_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real valve.state_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer valve.state_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real valve.state_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real valve.state_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real valve.state_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real valve.state_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter enumeration(Av, Kv, Cv, OpPoint) valve.CvData = Modelica.Fluid.Types.CvTypes.OpPoint \"Selection of flow coefficient\";
//   parameter Real valve.Kv = 0.0 \"Kv (metric) flow coefficient [m3/h]\";
//   parameter Real valve.Cv = 0.0 \"Cv (US) flow coefficient [USG/min]\";
//   parameter Real valve.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 10000.0 \"Nominal pressure drop\";
//   parameter Real valve.m_flow_nominal(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = 0.01 \"Nominal mass flowrate\";
//   parameter Real valve.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) = Modelica.Fluid.Valves.ValveIncompressible.Medium.density_pTX(101325.0,293.15,{1.0}) \"Nominal inlet density\";
//   parameter Real valve.opening_nominal = 1.0 \"Nominal opening\";
//   parameter Boolean valve.checkValve = false \"Reverse flow stopped\";
//   parameter Real valve.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = system.dp_small \"Regularisation of zero flow\";
//   constant Real valve.Kv2Av(quantity = \"Area\", unit = \"m2\") = 2.77e-005 \"Conversion factor\";
//   constant Real valve.Cv2Av(quantity = \"Area\", unit = \"m2\") = 2.4e-005 \"Conversion factor\";
//   input Real valve.opening(min = 0.0, max = 1.0) \"Valve position in the range 0-1\";
//   Real valve.port_a_T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = Modelica.Fluid.Utilities.regStep(valve.port_a.m_flow,Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature(valve.state_a),Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature(Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX(valve.port_a.p,valve.port_a.h_outflow,{},0)),valve.m_flow_small) \"Temperature close to port_a, if show_T = true\";
//   Real valve.port_b_T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = Modelica.Fluid.Utilities.regStep(valve.port_b.m_flow,Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature(valve.state_b),Modelica.Fluid.Valves.ValveIncompressible.Medium.temperature(Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX(valve.port_b.p,valve.port_b.h_outflow,{},0)),valve.m_flow_small) \"Temperature close to port_b, if show_T = true\";
//   Real valve.V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = valve.m_flow / Modelica.Fluid.Utilities.regStep(valve.m_flow,Modelica.Fluid.Valves.ValveIncompressible.Medium.density(valve.state_a),Modelica.Fluid.Valves.ValveIncompressible.Medium.density(valve.state_b),valve.m_flow_small) \"Volume flow rate at inflowing port (positive when flow from port_a to port_b)\";
//   parameter Real valve.dp_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = valve.dp_nominal \"Guess value of dp = port_a.p - port_b.p\";
//   parameter Real valve.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = valve.m_flow_nominal \"Guess value of m_flow = port_a.m_flow\";
//   parameter Real valve.Av(quantity = \"Area\", unit = \"m2\", start = (Modelica.Fluid.Valves.ValveIncompressible.valveCharacteristic(valve.opening_nominal) * valve.m_flow_nominal) / sqrt(valve.rho_nominal * valve.dp_nominal), fixed = valve.CvData == Modelica.Fluid.Types.CvTypes.Av) = 0.0 \"Av (metric) flow coefficient\";
//   Real valve.dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = valve.dp_start) \"Pressure difference between port_a and port_b (= port_a.p - port_b.p)\";
//   Real valve.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if valve.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = valve.m_flow_start) \"Mass flow rate in design flow direction\";
//   protected output Real m_flow;
//   parameter Boolean sensor_m_flow.allowFlowReversal = system.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real sensor_m_flow.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if sensor_m_flow.allowFlowReversal then -1e+060 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real sensor_m_flow.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real sensor_m_flow.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real sensor_m_flow.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if sensor_m_flow.allowFlowReversal then 1e+060 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real sensor_m_flow.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real sensor_m_flow.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean sensor_m_flow.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean sensor_m_flow.port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean sensor_m_flow.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   output Real sensor_m_flow.m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   parameter Real T_ambient.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Fixed temperature at port\";
//   Real T_ambient.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real T_ambient.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real wall.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate from port_a -> port_b\";
//   Real wall.dT(quantity = \"ThermodynamicTemperature\", unit = \"K\") \"port_a.T - port_b.T\";
//   Real wall.port_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real wall.port_a.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real wall.port_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real wall.port_b.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Real wall.G(quantity = \"ThermalConductance\", unit = \"W/K\") = 80.0 \"Constant thermal conductance of material\";
//   parameter Real burner.Q_flow(quantity = \"Power\", unit = \"W\") = 1600.0 \"Fixed heat flow rate at port\";
//   parameter Real burner.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 343.15 \"Reference temperature\";
//   parameter Real burner.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = -0.5 \"Temperature coefficient of heat flow rate\";
//   Real burner.port.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real burner.port.Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   parameter Boolean heater.allowFlowReversal = system.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real heater.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if heater.allowFlowReversal then -1e+060 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real heater.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real heater.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real heater.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if heater.allowFlowReversal then 1e+060 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real heater.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real heater.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean heater.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real heater.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real heater.length(quantity = \"Length\", unit = \"m\") = 2.0 \"Length\";
//   parameter Boolean heater.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real heater.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.01 \"Diameter of circular pipe\";
//   parameter Real heater.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-005 \"Average height of surface asperities (default: smooth steel pipe)\";
//   parameter Real heater.height_ab(quantity = \"Length\", unit = \"m\") = 0.0 \"Height(port_b) - Height(port_a)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.energyDynamics = system.energyDynamics \"Formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.massDynamics = system.massDynamics \"Formulation of mass balances\";
//   parameter Real heater.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Boolean heater.use_T_start = true \"Use T_start if true, otherwise h_start\";
//   parameter Real heater.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = 353.15 \"Start value of temperature\";
//   parameter Real heater.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) = if heater.use_T_start then Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pTX(heater.p_a_start / 2.0 + heater.p_b_start / 2.0,heater.T_start,{heater.X_start[1]},0) else 0.0 \"Start value of specific enthalpy\";
//   parameter Real heater.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   protected parameter Boolean heater.initialize_p = true \"= true to set up initial equations for pressure\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.momentumDynamics = system.momentumDynamics \"Formulation of momentum balances\";
//   parameter Real heater.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Integer heater.nNodes(min = 1) = 1 \"Number of discrete flow volumes\";
//   parameter enumeration(av_vb, a_v_b, av_b, a_vb) heater.modelStructure = Modelica.Fluid.Types.ModelStructure.a_vb \"Determines whether flow or volume models are present at the ports\";
//   parameter Boolean heater.useLumpedPressure = false \"=true to lump pressure states together\";
//   final parameter Integer heater.nFM = if heater.useLumpedPressure then heater.nFMLumped else heater.nFMDistributed \"number of flow models in flowModel\";
//   final parameter Integer heater.nFMDistributed = if heater.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 1 + heater.n else if heater.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or heater.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then heater.n else heater.n + -1;
//   final parameter Integer heater.nFMLumped = if heater.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 2 else 1;
//   parameter Boolean heater.useInnerPortProperties = false \"=true to take port properties for flow models from internal control volumes\";
//   Integer heater.state_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real heater.state_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real heater.state_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real heater.state_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real heater.state_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer heater.state_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real heater.state_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real heater.state_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real heater.state_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real heater.state_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean heater.use_HeatTransfer = true \"= true to use the HeatTransfer model\";
//   parameter Real heater.crossArea(quantity = \"Area\", unit = \"m2\") = 0.785398163397448 * heater.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real heater.perimeter(quantity = \"Length\", unit = \"m\") = 3.14159265358979 * heater.diameter \"Inner perimeter\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.substanceDynamics = heater.massDynamics \"Formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.traceDynamics = heater.massDynamics \"Formulation of trace substance balances\";
//   parameter Real heater.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = heater.p_a_start \"Start value of pressure at port b\";
//   parameter Integer heater.n = heater.nNodes \"Number of discrete volumes\";
//   protected parameter Boolean heater.port_a_exposesState = heater.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b or heater.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean heater.port_b_exposesState = heater.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or heater.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_b.p exposes the state of a fluid volume\";
//   Integer heater.statesFM[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real heater.statesFM[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real heater.statesFM[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real heater.statesFM[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real heater.statesFM[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer heater.statesFM[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real heater.statesFM[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real heater.statesFM[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real heater.statesFM[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real heater.statesFM[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   protected Real heater.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   protected Real heater.dheightsFM[1](quantity = \"Length\", unit = \"m\") \"Differences in heights between flow segments\";
//   protected Real heater.crossAreasFM[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real heater.crossAreasFM[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real heater.vsFM[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real heater.vsFM[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real heater.dimensionsFM[1](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real heater.dimensionsFM[2](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real heater.roughnessesFM[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   protected Real heater.roughnessesFM[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   Real heater.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real heater.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   final parameter Real heater.V(quantity = \"Volume\", unit = \"m3\") = heater.crossArea * (heater.length * heater.nParallel) \"volume size\";
//   input Real heater.fluidVolumes[1](quantity = \"Volume\", unit = \"m3\") = heater.nParallel * (heater.crossAreas[1] * heater.lengths[1]) \"Discretized volume, determine in inheriting class\";
//   final parameter Real heater.ps_start[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = if heater.n > 1 then linspace(heater.p_a_start,heater.p_b_start,heater.n)[1] else heater.p_a_start / 2.0 + heater.p_b_start / 2.0 \"Start value of pressure\";
//   Real heater.Us[1](quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real heater.ms[1](quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Fluid mass\";
//   Real heater.mb_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate, source or sink\";
//   Real heater.Hb_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow rate, source or sink\";
//   Real heater.Qb_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rate, source or sink\";
//   Real heater.Wb_flows[1](quantity = \"Power\", unit = \"W\") \"Mechanical power, p*der(V) etc.\";
//   parameter Real heater.lengths[1](quantity = \"Length\", unit = \"m\") = if heater.n == 1 then heater.length else if heater.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then heater.length / (Real(heater.n) * 2.0) else if heater.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb then heater.length / (Real(heater.n) * 2.0) else heater.length / Real(heater.n) \"lengths of flow segments\";
//   final parameter Integer heater.iLumped = 1 + integer(Real(heater.n) / 2.0) \"Index of control volume with representative state if useLumpedPressure\";
//   Real heater.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if heater.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = heater.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real heater.m_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if heater.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = heater.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real heater.H_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real heater.H_flows[2](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real heater.vs[1](quantity = \"Velocity\", unit = \"m/s\") = (0.5 * (heater.m_flows[1] + heater.m_flows[2])) / (heater.crossAreas[1] * heater.mediums[1].d * heater.nParallel) \"mean velocities in flow segments\";
//   parameter Integer heater.flowModel.n = 1 + heater.nFM \"Number of discrete flow volumes\";
//   parameter Real heater.flowModel.nParallel = heater.nParallel \"number of identical parallel flow devices\";
//   parameter Real heater.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean heater.flowModel.allowFlowReversal = heater.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) heater.flowModel.momentumDynamics = heater.momentumDynamics \"Formulation of momentum balance\";
//   parameter Real heater.flowModel.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = heater.m_flow_start \"Start value of mass flow rates\";
//   parameter Real heater.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = heater.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real heater.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = heater.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Boolean heater.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Real heater.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean heater.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean heater.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real heater.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pTX(101325.0,293.15,{1.0}) \"Nominal density (e.g. rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean heater.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real heater.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX(101325.0,293.15,{1.0},0)) \"Nominal dynamic viscosity (e.g. mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   parameter Real heater.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.dp_small \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   parameter Real heater.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   input Integer heater.flowModel.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real heater.flowModel.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real heater.flowModel.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real heater.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real heater.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Integer heater.flowModel.states[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real heater.flowModel.states[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real heater.flowModel.states[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real heater.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real heater.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real heater.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") = heater.vsFM[1] \"Mean velocities of fluid flow\";
//   input Real heater.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") = heater.vsFM[2] \"Mean velocities of fluid flow\";
//   input Real heater.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") = heater.crossAreasFM[1] \"Cross flow areas at segment boundaries\";
//   input Real heater.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") = heater.crossAreasFM[2] \"Cross flow areas at segment boundaries\";
//   input Real heater.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") = heater.dimensionsFM[1] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real heater.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") = heater.dimensionsFM[2] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real heater.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = heater.roughnessesFM[1] \"Average height of surface asperities\";
//   input Real heater.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) = heater.roughnessesFM[2] \"Average height of surface asperities\";
//   input Real heater.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") = heater.dheightsFM[1] \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Integer heater.flowModel.m = heater.flowModel.n + -1 \"Number of flow segments\";
//   Real heater.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if heater.flowModel.use_rho_nominal then heater.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(heater.flowModel.states[1]);
//   Real heater.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if heater.flowModel.use_rho_nominal then heater.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(heater.flowModel.states[2]);
//   Real heater.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Actual density per segment\";
//   Real heater.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if heater.flowModel.use_mu_nominal then heater.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(heater.flowModel.states[1]);
//   Real heater.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if heater.flowModel.use_mu_nominal then heater.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(heater.flowModel.states[2]);
//   Real heater.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Actual viscosity per segment\";
//   input Real heater.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") = heater.flowModel.pathLengths[1] \"pathLengths used internally; to be defined by extending class\";
//   Real heater.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") = 0.5 * (heater.flowModel.dimensions[1] + heater.flowModel.dimensions[2]) \"mean diameters between segments\";
//   parameter Boolean heater.flowModel.use_Ib_flows = heater.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   parameter Boolean heater.flowModel.from_dp = heater.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \" = true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   final parameter Boolean heater.flowModel.constantPressureLossCoefficient = heater.flowModel.use_rho_nominal and heater.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   parameter Real heater.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1000.0 * heater.flowModel.dp_small \"Nominal pressure loss (for nominal models)\";
//   parameter Real heater.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = 100.0 * heater.flowModel.m_flow_small \"Mass flow rate for dp_nominal (for nominal models)\";
//   input Real heater.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") = heater.pathLengths[1] \"Lengths along flow path\";
//   Real heater.flowModel.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if heater.flowModel.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = heater.flowModel.m_flow_start, StateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real heater.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momentums of flow segments\";
//   Real heater.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boudaries\";
//   Real heater.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real heater.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   final parameter Boolean heater.flowModel.continuousFlowReversal = not heater.flowModel.useUpstreamScheme or heater.flowModel.constantPressureLossCoefficient or not heater.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   Real heater.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (heater.flowModel.p_a_start - heater.flowModel.p_b_start) / Real(heater.flowModel.n + -1)) \"pressure drop between states\";
//   input Real heater.mediums[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = heater.ps_start[1], StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real heater.mediums[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = heater.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real heater.mediums[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real heater.mediums[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = heater.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real heater.mediums[1].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real heater.mediums[1].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real heater.mediums[1].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real heater.mediums[1].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer heater.mediums[1].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real heater.mediums[1].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real heater.mediums[1].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real heater.mediums[1].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real heater.mediums[1].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean heater.mediums[1].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean heater.mediums[1].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real heater.mediums[1].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(heater.mediums[1].T) \"Temperature of medium in [degC]\";
//   Real heater.mediums[1].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(heater.mediums[1].p) \"Absolute pressure of medium in [bar]\";
//   Real heater.mediums[1].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real heater.mediums[1].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer heater.mediums[1].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   final parameter Real heater.dxs[1] = 1.0;
//   parameter Real heater.crossAreas[1](quantity = \"Area\", unit = \"m2\") = heater.crossArea \"cross flow areas of flow segments\";
//   parameter Real heater.dimensions[1](quantity = \"Length\", unit = \"m\") = (4.0 * heater.crossArea) / heater.perimeter \"hydraulic diameters of flow segments\";
//   parameter Real heater.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = heater.roughness \"Average heights of surface asperities\";
//   parameter Real heater.dheights[1](quantity = \"Length\", unit = \"m\") = heater.height_ab * heater.dxs[1] \"Differences in heigths of flow segments\";
//   parameter Integer heater.heatTransfer.n = heater.n \"Number of heat transfer segments\";
//   parameter Boolean heater.heatTransfer.use_k = heater.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real heater.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real heater.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Ambient temperature\";
//   parameter Real heater.heatTransfer.nParallel = heater.nParallel \"number of identical parallel flow devices\";
//   input Integer heater.heatTransfer.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real heater.heatTransfer.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real heater.heatTransfer.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real heater.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real heater.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real heater.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") = heater.perimeter * heater.lengths[1] \"Heat transfer areas\";
//   output Real heater.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   Real heater.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real heater.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real heater.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature(heater.heatTransfer.states[1]) \"Temperatures defined by fluid states\";
//   input Real heater.heatTransfer.vs[1](quantity = \"Velocity\", unit = \"m/s\") = heater.vs[1] \"Mean velocities of fluid flow in segments\";
//   input Real heater.heatTransfer.lengths[1](quantity = \"Length\", unit = \"m\") = heater.lengths[1] \"Lengths along flow path\";
//   input Real heater.heatTransfer.dimensions[1](quantity = \"Length\", unit = \"m\") = heater.dimensions[1] \"Characteristic dimensions for fluid flow (diameter for pipe flow)\";
//   input Real heater.heatTransfer.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = heater.roughnesses[1] \"Average heights of surface asperities\";
//   parameter Boolean radiator.allowFlowReversal = system.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real radiator.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if radiator.allowFlowReversal then -1e+060 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real radiator.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real radiator.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real radiator.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if radiator.allowFlowReversal then 1e+060 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real radiator.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real radiator.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean radiator.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real radiator.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real radiator.length(quantity = \"Length\", unit = \"m\") = 10.0 \"Length\";
//   parameter Boolean radiator.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real radiator.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.01 \"Diameter of circular pipe\";
//   parameter Real radiator.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-005 \"Average height of surface asperities (default: smooth steel pipe)\";
//   parameter Real radiator.height_ab(quantity = \"Length\", unit = \"m\") = 0.0 \"Height(port_b) - Height(port_a)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.energyDynamics = system.energyDynamics \"Formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.massDynamics = system.massDynamics \"Formulation of mass balances\";
//   parameter Real radiator.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Boolean radiator.use_T_start = true \"Use T_start if true, otherwise h_start\";
//   parameter Real radiator.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = 313.15 \"Start value of temperature\";
//   parameter Real radiator.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) = if radiator.use_T_start then Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pTX(radiator.p_a_start / 2.0 + radiator.p_b_start / 2.0,radiator.T_start,{radiator.X_start[1]},0) else 0.0 \"Start value of specific enthalpy\";
//   parameter Real radiator.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   protected parameter Boolean radiator.initialize_p = true \"= true to set up initial equations for pressure\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.momentumDynamics = system.momentumDynamics \"Formulation of momentum balances\";
//   parameter Real radiator.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Integer radiator.nNodes(min = 1) = 1 \"Number of discrete flow volumes\";
//   parameter enumeration(av_vb, a_v_b, av_b, a_vb) radiator.modelStructure = Modelica.Fluid.Types.ModelStructure.av_b \"Determines whether flow or volume models are present at the ports\";
//   parameter Boolean radiator.useLumpedPressure = false \"=true to lump pressure states together\";
//   final parameter Integer radiator.nFM = if radiator.useLumpedPressure then radiator.nFMLumped else radiator.nFMDistributed \"number of flow models in flowModel\";
//   final parameter Integer radiator.nFMDistributed = if radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 1 + radiator.n else if radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then radiator.n else radiator.n + -1;
//   final parameter Integer radiator.nFMLumped = if radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 2 else 1;
//   parameter Boolean radiator.useInnerPortProperties = false \"=true to take port properties for flow models from internal control volumes\";
//   Integer radiator.state_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real radiator.state_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real radiator.state_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real radiator.state_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real radiator.state_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer radiator.state_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real radiator.state_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real radiator.state_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real radiator.state_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real radiator.state_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean radiator.use_HeatTransfer = true \"= true to use the HeatTransfer model\";
//   parameter Real radiator.crossArea(quantity = \"Area\", unit = \"m2\") = 0.785398163397448 * radiator.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real radiator.perimeter(quantity = \"Length\", unit = \"m\") = 3.14159265358979 * radiator.diameter \"Inner perimeter\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.substanceDynamics = radiator.massDynamics \"Formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.traceDynamics = radiator.massDynamics \"Formulation of trace substance balances\";
//   parameter Real radiator.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = radiator.p_a_start \"Start value of pressure at port b\";
//   parameter Integer radiator.n = radiator.nNodes \"Number of discrete volumes\";
//   protected parameter Boolean radiator.port_a_exposesState = radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b or radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean radiator.port_b_exposesState = radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_b.p exposes the state of a fluid volume\";
//   Integer radiator.statesFM[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real radiator.statesFM[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real radiator.statesFM[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real radiator.statesFM[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real radiator.statesFM[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer radiator.statesFM[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real radiator.statesFM[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real radiator.statesFM[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real radiator.statesFM[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real radiator.statesFM[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   protected Real radiator.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   protected Real radiator.dheightsFM[1](quantity = \"Length\", unit = \"m\") \"Differences in heights between flow segments\";
//   protected Real radiator.crossAreasFM[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real radiator.crossAreasFM[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real radiator.vsFM[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real radiator.vsFM[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real radiator.dimensionsFM[1](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real radiator.dimensionsFM[2](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real radiator.roughnessesFM[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   protected Real radiator.roughnessesFM[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   Real radiator.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real radiator.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   final parameter Real radiator.V(quantity = \"Volume\", unit = \"m3\") = radiator.crossArea * (radiator.length * radiator.nParallel) \"volume size\";
//   input Real radiator.fluidVolumes[1](quantity = \"Volume\", unit = \"m3\") = radiator.nParallel * (radiator.crossAreas[1] * radiator.lengths[1]) \"Discretized volume, determine in inheriting class\";
//   final parameter Real radiator.ps_start[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = if radiator.n > 1 then linspace(radiator.p_a_start,radiator.p_b_start,radiator.n)[1] else radiator.p_a_start / 2.0 + radiator.p_b_start / 2.0 \"Start value of pressure\";
//   Real radiator.Us[1](quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real radiator.ms[1](quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Fluid mass\";
//   Real radiator.mb_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate, source or sink\";
//   Real radiator.Hb_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow rate, source or sink\";
//   Real radiator.Qb_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rate, source or sink\";
//   Real radiator.Wb_flows[1](quantity = \"Power\", unit = \"W\") \"Mechanical power, p*der(V) etc.\";
//   parameter Real radiator.lengths[1](quantity = \"Length\", unit = \"m\") = if radiator.n == 1 then radiator.length else if radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then radiator.length / (Real(radiator.n) * 2.0) else if radiator.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb then radiator.length / (Real(radiator.n) * 2.0) else radiator.length / Real(radiator.n) \"lengths of flow segments\";
//   final parameter Integer radiator.iLumped = 1 + integer(Real(radiator.n) / 2.0) \"Index of control volume with representative state if useLumpedPressure\";
//   Real radiator.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if radiator.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = radiator.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real radiator.m_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if radiator.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = radiator.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real radiator.H_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real radiator.H_flows[2](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real radiator.vs[1](quantity = \"Velocity\", unit = \"m/s\") = (0.5 * (radiator.m_flows[1] + radiator.m_flows[2])) / (radiator.crossAreas[1] * radiator.mediums[1].d * radiator.nParallel) \"mean velocities in flow segments\";
//   parameter Integer radiator.flowModel.n = 1 + radiator.nFM \"Number of discrete flow volumes\";
//   parameter Real radiator.flowModel.nParallel = radiator.nParallel \"number of identical parallel flow devices\";
//   parameter Real radiator.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean radiator.flowModel.allowFlowReversal = radiator.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) radiator.flowModel.momentumDynamics = radiator.momentumDynamics \"Formulation of momentum balance\";
//   parameter Real radiator.flowModel.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = radiator.m_flow_start \"Start value of mass flow rates\";
//   parameter Real radiator.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = radiator.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real radiator.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = radiator.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Boolean radiator.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Real radiator.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean radiator.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean radiator.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real radiator.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pTX(101325.0,293.15,{1.0}) \"Nominal density (e.g. rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean radiator.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real radiator.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX(101325.0,293.15,{1.0},0)) \"Nominal dynamic viscosity (e.g. mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   parameter Real radiator.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.dp_small \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   parameter Real radiator.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   input Integer radiator.flowModel.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real radiator.flowModel.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real radiator.flowModel.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real radiator.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real radiator.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Integer radiator.flowModel.states[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real radiator.flowModel.states[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real radiator.flowModel.states[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real radiator.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real radiator.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real radiator.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") = radiator.vsFM[1] \"Mean velocities of fluid flow\";
//   input Real radiator.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") = radiator.vsFM[2] \"Mean velocities of fluid flow\";
//   input Real radiator.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") = radiator.crossAreasFM[1] \"Cross flow areas at segment boundaries\";
//   input Real radiator.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") = radiator.crossAreasFM[2] \"Cross flow areas at segment boundaries\";
//   input Real radiator.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") = radiator.dimensionsFM[1] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real radiator.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") = radiator.dimensionsFM[2] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real radiator.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = radiator.roughnessesFM[1] \"Average height of surface asperities\";
//   input Real radiator.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) = radiator.roughnessesFM[2] \"Average height of surface asperities\";
//   input Real radiator.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") = radiator.dheightsFM[1] \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Integer radiator.flowModel.m = radiator.flowModel.n + -1 \"Number of flow segments\";
//   Real radiator.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if radiator.flowModel.use_rho_nominal then radiator.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(radiator.flowModel.states[1]);
//   Real radiator.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if radiator.flowModel.use_rho_nominal then radiator.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(radiator.flowModel.states[2]);
//   Real radiator.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Actual density per segment\";
//   Real radiator.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if radiator.flowModel.use_mu_nominal then radiator.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(radiator.flowModel.states[1]);
//   Real radiator.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if radiator.flowModel.use_mu_nominal then radiator.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(radiator.flowModel.states[2]);
//   Real radiator.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Actual viscosity per segment\";
//   input Real radiator.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") = radiator.flowModel.pathLengths[1] \"pathLengths used internally; to be defined by extending class\";
//   Real radiator.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") = 0.5 * (radiator.flowModel.dimensions[1] + radiator.flowModel.dimensions[2]) \"mean diameters between segments\";
//   parameter Boolean radiator.flowModel.use_Ib_flows = radiator.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   parameter Boolean radiator.flowModel.from_dp = radiator.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \" = true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   final parameter Boolean radiator.flowModel.constantPressureLossCoefficient = radiator.flowModel.use_rho_nominal and radiator.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   parameter Real radiator.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1000.0 * radiator.flowModel.dp_small \"Nominal pressure loss (for nominal models)\";
//   parameter Real radiator.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = 100.0 * radiator.flowModel.m_flow_small \"Mass flow rate for dp_nominal (for nominal models)\";
//   input Real radiator.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") = radiator.pathLengths[1] \"Lengths along flow path\";
//   Real radiator.flowModel.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if radiator.flowModel.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = radiator.flowModel.m_flow_start, StateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real radiator.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momentums of flow segments\";
//   Real radiator.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boudaries\";
//   Real radiator.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real radiator.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   final parameter Boolean radiator.flowModel.continuousFlowReversal = not radiator.flowModel.useUpstreamScheme or radiator.flowModel.constantPressureLossCoefficient or not radiator.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   Real radiator.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (radiator.flowModel.p_a_start - radiator.flowModel.p_b_start) / Real(radiator.flowModel.n + -1)) \"pressure drop between states\";
//   input Real radiator.mediums[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = radiator.ps_start[1], StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real radiator.mediums[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = radiator.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real radiator.mediums[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real radiator.mediums[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = radiator.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real radiator.mediums[1].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real radiator.mediums[1].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real radiator.mediums[1].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real radiator.mediums[1].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer radiator.mediums[1].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real radiator.mediums[1].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real radiator.mediums[1].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real radiator.mediums[1].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real radiator.mediums[1].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean radiator.mediums[1].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean radiator.mediums[1].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real radiator.mediums[1].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(radiator.mediums[1].T) \"Temperature of medium in [degC]\";
//   Real radiator.mediums[1].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(radiator.mediums[1].p) \"Absolute pressure of medium in [bar]\";
//   Real radiator.mediums[1].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real radiator.mediums[1].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer radiator.mediums[1].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   final parameter Real radiator.dxs[1] = 1.0;
//   parameter Real radiator.crossAreas[1](quantity = \"Area\", unit = \"m2\") = radiator.crossArea \"cross flow areas of flow segments\";
//   parameter Real radiator.dimensions[1](quantity = \"Length\", unit = \"m\") = (4.0 * radiator.crossArea) / radiator.perimeter \"hydraulic diameters of flow segments\";
//   parameter Real radiator.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = radiator.roughness \"Average heights of surface asperities\";
//   parameter Real radiator.dheights[1](quantity = \"Length\", unit = \"m\") = radiator.height_ab * radiator.dxs[1] \"Differences in heigths of flow segments\";
//   parameter Integer radiator.heatTransfer.n = radiator.n \"Number of heat transfer segments\";
//   parameter Boolean radiator.heatTransfer.use_k = radiator.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real radiator.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real radiator.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Ambient temperature\";
//   parameter Real radiator.heatTransfer.nParallel = radiator.nParallel \"number of identical parallel flow devices\";
//   input Integer radiator.heatTransfer.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real radiator.heatTransfer.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real radiator.heatTransfer.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real radiator.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real radiator.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real radiator.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") = radiator.perimeter * radiator.lengths[1] \"Heat transfer areas\";
//   output Real radiator.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   Real radiator.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real radiator.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real radiator.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature(radiator.heatTransfer.states[1]) \"Temperatures defined by fluid states\";
//   input Real radiator.heatTransfer.vs[1](quantity = \"Velocity\", unit = \"m/s\") = radiator.vs[1] \"Mean velocities of fluid flow in segments\";
//   input Real radiator.heatTransfer.lengths[1](quantity = \"Length\", unit = \"m\") = radiator.lengths[1] \"Lengths along flow path\";
//   input Real radiator.heatTransfer.dimensions[1](quantity = \"Length\", unit = \"m\") = radiator.dimensions[1] \"Characteristic dimensions for fluid flow (diameter for pipe flow)\";
//   input Real radiator.heatTransfer.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = radiator.roughnesses[1] \"Average heights of surface asperities\";
//   protected output Real T_forward;
//   protected output Real T_return;
//   Real sensor_T_forward.port.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real sensor_T_forward.port.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real sensor_T_forward.port.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   output Real sensor_T_forward.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature in port medium\";
//   Real sensor_T_return.port.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real sensor_T_return.port.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real sensor_T_return.port.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   output Real sensor_T_return.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature in port medium\";
//   protected output Real tankLevel;
//   output Real handle.y \"Connector of Real output signal\";
//   parameter Real handle.offset = 0.1 \"Offset of output signal y\";
//   parameter Real handle.startTime(quantity = \"Time\", unit = \"s\") = 2000.0 \"Output y = offset for time < startTime\";
//   parameter Real handle.height = 0.9 \"Height of step\";
//   parameter Boolean pipe.allowFlowReversal = system.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real pipe.port_a.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pipe.allowFlowReversal then -1e+060 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real pipe.port_b.m_flow(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = if pipe.allowFlowReversal then 1e+060 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean pipe.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real pipe.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real pipe.length(quantity = \"Length\", unit = \"m\") = 10.0 \"Length\";
//   parameter Boolean pipe.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real pipe.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.01 \"Diameter of circular pipe\";
//   parameter Real pipe.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-005 \"Average height of surface asperities (default: smooth steel pipe)\";
//   parameter Real pipe.height_ab(quantity = \"Length\", unit = \"m\") = 0.0 \"Height(port_b) - Height(port_a)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.energyDynamics = system.energyDynamics \"Formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.massDynamics = system.massDynamics \"Formulation of mass balances\";
//   parameter Real pipe.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Boolean pipe.use_T_start = true \"Use T_start if true, otherwise h_start\";
//   parameter Real pipe.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = 353.15 \"Start value of temperature\";
//   parameter Real pipe.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) = if pipe.use_T_start then Modelica.Fluid.Pipes.DynamicPipe.Medium.specificEnthalpy_pTX(pipe.p_a_start / 2.0 + pipe.p_b_start / 2.0,pipe.T_start,{pipe.X_start[1]},0) else 0.0 \"Start value of specific enthalpy\";
//   parameter Real pipe.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   protected parameter Boolean pipe.initialize_p = true \"= true to set up initial equations for pressure\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.momentumDynamics = system.momentumDynamics \"Formulation of momentum balances\";
//   parameter Real pipe.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Integer pipe.nNodes(min = 1) = 2 \"Number of discrete flow volumes\";
//   parameter enumeration(av_vb, a_v_b, av_b, a_vb) pipe.modelStructure = Modelica.Fluid.Types.ModelStructure.av_vb \"Determines whether flow or volume models are present at the ports\";
//   parameter Boolean pipe.useLumpedPressure = false \"=true to lump pressure states together\";
//   final parameter Integer pipe.nFM = if pipe.useLumpedPressure then pipe.nFMLumped else pipe.nFMDistributed \"number of flow models in flowModel\";
//   final parameter Integer pipe.nFMDistributed = if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 1 + pipe.n else if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then pipe.n else pipe.n + -1;
//   final parameter Integer pipe.nFMLumped = if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_v_b then 2 else 1;
//   parameter Boolean pipe.useInnerPortProperties = false \"=true to take port properties for flow models from internal control volumes\";
//   Integer pipe.state_a.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.state_a.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.state_a.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.state_a.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.state_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer pipe.state_b.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.state_b.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.state_b.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.state_b.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.state_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean pipe.use_HeatTransfer = false \"= true to use the HeatTransfer model\";
//   parameter Real pipe.crossArea(quantity = \"Area\", unit = \"m2\") = 0.785398163397448 * pipe.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real pipe.perimeter(quantity = \"Length\", unit = \"m\") = 3.14159265358979 * pipe.diameter \"Inner perimeter\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.substanceDynamics = pipe.massDynamics \"Formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.traceDynamics = pipe.massDynamics \"Formulation of trace substance balances\";
//   parameter Real pipe.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe.p_a_start \"Start value of pressure at port b\";
//   parameter Integer pipe.n = pipe.nNodes \"Number of discrete volumes\";
//   protected parameter Boolean pipe.port_a_exposesState = pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b or pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean pipe.port_b_exposesState = pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb or pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb \"= true if port_b.p exposes the state of a fluid volume\";
//   Integer pipe.statesFM[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.statesFM[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.statesFM[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.statesFM[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.statesFM[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   Integer pipe.statesFM[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.statesFM[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.statesFM[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.statesFM[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.statesFM[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   protected Real pipe.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   protected Real pipe.dheightsFM[1](quantity = \"Length\", unit = \"m\") \"Differences in heights between flow segments\";
//   protected Real pipe.crossAreasFM[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real pipe.crossAreasFM[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas of flow segments\";
//   protected Real pipe.vsFM[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real pipe.vsFM[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities in flow segments\";
//   protected Real pipe.dimensionsFM[1](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real pipe.dimensionsFM[2](quantity = \"Length\", unit = \"m\") \"Hydraulic diameters of flow segments\";
//   protected Real pipe.roughnessesFM[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   protected Real pipe.roughnessesFM[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average heights of surface asperities\";
//   final parameter Real pipe.V(quantity = \"Volume\", unit = \"m3\") = pipe.crossArea * (pipe.length * pipe.nParallel) \"volume size\";
//   input Real pipe.fluidVolumes[1](quantity = \"Volume\", unit = \"m3\") = pipe.nParallel * (pipe.crossAreas[1] * pipe.lengths[1]) \"Discretized volume, determine in inheriting class\";
//   input Real pipe.fluidVolumes[2](quantity = \"Volume\", unit = \"m3\") = pipe.nParallel * (pipe.crossAreas[2] * pipe.lengths[2]) \"Discretized volume, determine in inheriting class\";
//   final parameter Real pipe.ps_start[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = if pipe.n > 1 then linspace(pipe.p_a_start,pipe.p_b_start,pipe.n)[1] else pipe.p_a_start / 2.0 + pipe.p_b_start / 2.0 \"Start value of pressure\";
//   final parameter Real pipe.ps_start[2](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = if pipe.n > 1 then linspace(pipe.p_a_start,pipe.p_b_start,pipe.n)[2] else {pipe.p_a_start / 2.0 + pipe.p_b_start / 2.0}[2] \"Start value of pressure\";
//   Real pipe.Us[1](quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real pipe.Us[2](quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real pipe.ms[1](quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Fluid mass\";
//   Real pipe.ms[2](quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Fluid mass\";
//   Real pipe.mb_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate, source or sink\";
//   Real pipe.mb_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate, source or sink\";
//   Real pipe.Hb_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow rate, source or sink\";
//   Real pipe.Hb_flows[2](quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow rate, source or sink\";
//   Real pipe.Qb_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rate, source or sink\";
//   Real pipe.Qb_flows[2](quantity = \"Power\", unit = \"W\") \"Heat flow rate, source or sink\";
//   Real pipe.Wb_flows[1](quantity = \"Power\", unit = \"W\") \"Mechanical power, p*der(V) etc.\";
//   Real pipe.Wb_flows[2](quantity = \"Power\", unit = \"W\") \"Mechanical power, p*der(V) etc.\";
//   parameter Real pipe.lengths[1](quantity = \"Length\", unit = \"m\") = if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb then pipe.length / (Real(pipe.n + -1) * 2.0) else if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then pipe.length / (Real(pipe.n) * 2.0) else if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb then (pipe.length * (1.0 + -1.0 / (Real(pipe.n) * 2.0))) / Real(pipe.n + -1) else pipe.length / Real(pipe.n) \"lengths of flow segments\";
//   parameter Real pipe.lengths[2](quantity = \"Length\", unit = \"m\") = if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_vb then pipe.length / (Real(pipe.n + -1) * 2.0) else if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.av_b then (pipe.length * (1.0 + -1.0 / (Real(pipe.n) * 2.0))) / Real(pipe.n + -1) else if pipe.modelStructure == Modelica.Fluid.Types.ModelStructure.a_vb then pipe.length / (Real(pipe.n) * 2.0) else pipe.length / Real(pipe.n) \"lengths of flow segments\";
//   final parameter Integer pipe.iLumped = 1 + integer(Real(pipe.n) / 2.0) \"Index of control volume with representative state if useLumpedPressure\";
//   Real pipe.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pipe.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = pipe.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real pipe.m_flows[2](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pipe.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = pipe.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real pipe.m_flows[3](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pipe.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = pipe.m_flow_start) \"Mass flow rates of fluid across segment boundaries\";
//   Real pipe.H_flows[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real pipe.H_flows[2](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real pipe.H_flows[3](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0) \"Enthalpy flow rates of fluid across segment boundaries\";
//   Real pipe.vs[1](quantity = \"Velocity\", unit = \"m/s\") = (0.5 * (pipe.m_flows[1] + pipe.m_flows[2])) / (pipe.crossAreas[1] * pipe.mediums[1].d * pipe.nParallel) \"mean velocities in flow segments\";
//   Real pipe.vs[2](quantity = \"Velocity\", unit = \"m/s\") = (0.5 * (pipe.m_flows[2] + pipe.m_flows[3])) / (pipe.crossAreas[2] * pipe.mediums[2].d * pipe.nParallel) \"mean velocities in flow segments\";
//   parameter Integer pipe.flowModel.n = 1 + pipe.nFM \"Number of discrete flow volumes\";
//   parameter Real pipe.flowModel.nParallel = pipe.nParallel \"number of identical parallel flow devices\";
//   parameter Real pipe.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean pipe.flowModel.allowFlowReversal = pipe.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe.flowModel.momentumDynamics = pipe.momentumDynamics \"Formulation of momentum balance\";
//   parameter Real pipe.flowModel.m_flow_start(quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = pipe.m_flow_start \"Start value of mass flow rates\";
//   parameter Real pipe.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real pipe.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Boolean pipe.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Real pipe.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean pipe.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean pipe.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density_pTX(101325.0,293.15,{1.0}) \"Nominal density (e.g. rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean pipe.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.setState_pTX(101325.0,293.15,{1.0},0)) \"Nominal dynamic viscosity (e.g. mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   parameter Real pipe.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.dp_small \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   parameter Real pipe.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   input Integer pipe.flowModel.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real pipe.flowModel.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real pipe.flowModel.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real pipe.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real pipe.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Integer pipe.flowModel.states[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real pipe.flowModel.states[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real pipe.flowModel.states[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real pipe.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real pipe.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real pipe.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") = pipe.vsFM[1] \"Mean velocities of fluid flow\";
//   input Real pipe.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") = pipe.vsFM[2] \"Mean velocities of fluid flow\";
//   input Real pipe.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") = pipe.crossAreasFM[1] \"Cross flow areas at segment boundaries\";
//   input Real pipe.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") = pipe.crossAreasFM[2] \"Cross flow areas at segment boundaries\";
//   input Real pipe.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") = pipe.dimensionsFM[1] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real pipe.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") = pipe.dimensionsFM[2] \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   input Real pipe.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughnessesFM[1] \"Average height of surface asperities\";
//   input Real pipe.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughnessesFM[2] \"Average height of surface asperities\";
//   input Real pipe.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") = pipe.dheightsFM[1] \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Integer pipe.flowModel.m = pipe.flowModel.n + -1 \"Number of flow segments\";
//   Real pipe.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if pipe.flowModel.use_rho_nominal then pipe.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(pipe.flowModel.states[1]);
//   Real pipe.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if pipe.flowModel.use_rho_nominal then pipe.flowModel.rho_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.density(pipe.flowModel.states[2]);
//   Real pipe.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Actual density per segment\";
//   Real pipe.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if pipe.flowModel.use_mu_nominal then pipe.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(pipe.flowModel.states[1]);
//   Real pipe.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = if pipe.flowModel.use_mu_nominal then pipe.flowModel.mu_nominal else Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.dynamicViscosity(pipe.flowModel.states[2]);
//   Real pipe.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Actual viscosity per segment\";
//   input Real pipe.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") = pipe.flowModel.pathLengths[1] \"pathLengths used internally; to be defined by extending class\";
//   Real pipe.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") = 0.5 * (pipe.flowModel.dimensions[1] + pipe.flowModel.dimensions[2]) \"mean diameters between segments\";
//   parameter Boolean pipe.flowModel.use_Ib_flows = pipe.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   parameter Boolean pipe.flowModel.from_dp = pipe.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \" = true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   final parameter Boolean pipe.flowModel.constantPressureLossCoefficient = pipe.flowModel.use_rho_nominal and pipe.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   parameter Real pipe.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1000.0 * pipe.flowModel.dp_small \"Nominal pressure loss (for nominal models)\";
//   parameter Real pipe.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = 100.0 * pipe.flowModel.m_flow_small \"Mass flow rate for dp_nominal (for nominal models)\";
//   input Real pipe.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") = pipe.pathLengths[1] \"Lengths along flow path\";
//   Real pipe.flowModel.m_flows[1](quantity = \"MassFlowRate.WaterIF97\", unit = \"kg/s\", min = if pipe.flowModel.allowFlowReversal then -1e+060 else 0.0, max = 100000.0, start = pipe.flowModel.m_flow_start, StateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real pipe.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momentums of flow segments\";
//   Real pipe.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boudaries\";
//   Real pipe.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real pipe.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   final parameter Boolean pipe.flowModel.continuousFlowReversal = not pipe.flowModel.useUpstreamScheme or pipe.flowModel.constantPressureLossCoefficient or not pipe.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   Real pipe.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (pipe.flowModel.p_a_start - pipe.flowModel.p_b_start) / Real(pipe.flowModel.n + -1)) \"pressure drop between states\";
//   input Real pipe.mediums[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = pipe.ps_start[1], StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real pipe.mediums[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = pipe.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real pipe.mediums[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real pipe.mediums[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = pipe.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real pipe.mediums[1].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real pipe.mediums[1].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real pipe.mediums[1].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real pipe.mediums[1].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer pipe.mediums[1].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.mediums[1].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.mediums[1].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.mediums[1].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.mediums[1].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean pipe.mediums[1].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean pipe.mediums[1].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real pipe.mediums[1].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(pipe.mediums[1].T) \"Temperature of medium in [degC]\";
//   Real pipe.mediums[1].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(pipe.mediums[1].p) \"Absolute pressure of medium in [bar]\";
//   Real pipe.mediums[1].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real pipe.mediums[1].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer pipe.mediums[1].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   input Real pipe.mediums[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = pipe.ps_start[2], StateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   input Real pipe.mediums[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = pipe.h_start, StateSelect = StateSelect.prefer) \"Specific enthalpy of medium\";
//   Real pipe.mediums[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0, StateSelect = StateSelect.default) \"Density of medium\";
//   Real pipe.mediums[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = pipe.T_start, nominal = 300.0, StateSelect = StateSelect.default) \"Temperature of medium\";
//   Real pipe.mediums[2].X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real pipe.mediums[2].u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real pipe.mediums[2].R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 1000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real pipe.mediums[2].MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Integer pipe.mediums[2].state.phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   Real pipe.mediums[2].state.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   Real pipe.mediums[2].state.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   Real pipe.mediums[2].state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   Real pipe.mediums[2].state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   parameter Boolean pipe.mediums[2].preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean pipe.mediums[2].standardOrderComponents = true \"if true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real pipe.mediums[2].T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(pipe.mediums[2].T) \"Temperature of medium in [degC]\";
//   Real pipe.mediums[2].p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(pipe.mediums[2].p) \"Absolute pressure of medium in [bar]\";
//   Real pipe.mediums[2].sat.psat(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"saturation pressure\";
//   Real pipe.mediums[2].sat.Tsat(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"saturation temperature\";
//   Integer pipe.mediums[2].phase(min = 0, max = 2, start = 1, fixed = false) \"2 for two-phase, 1 for one-phase, 0 if not known\";
//   final parameter Real pipe.dxs[1] = pipe.lengths[1] / (pipe.lengths[1] + pipe.lengths[2]);
//   final parameter Real pipe.dxs[2] = pipe.lengths[2] / (pipe.lengths[1] + pipe.lengths[2]);
//   parameter Real pipe.crossAreas[1](quantity = \"Area\", unit = \"m2\") = pipe.crossArea \"cross flow areas of flow segments\";
//   parameter Real pipe.crossAreas[2](quantity = \"Area\", unit = \"m2\") = pipe.crossArea \"cross flow areas of flow segments\";
//   parameter Real pipe.dimensions[1](quantity = \"Length\", unit = \"m\") = (4.0 * pipe.crossArea) / pipe.perimeter \"hydraulic diameters of flow segments\";
//   parameter Real pipe.dimensions[2](quantity = \"Length\", unit = \"m\") = (4.0 * pipe.crossArea) / pipe.perimeter \"hydraulic diameters of flow segments\";
//   parameter Real pipe.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughness \"Average heights of surface asperities\";
//   parameter Real pipe.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughness \"Average heights of surface asperities\";
//   parameter Real pipe.dheights[1](quantity = \"Length\", unit = \"m\") = pipe.height_ab * pipe.dxs[1] \"Differences in heigths of flow segments\";
//   parameter Real pipe.dheights[2](quantity = \"Length\", unit = \"m\") = pipe.height_ab * pipe.dxs[2] \"Differences in heigths of flow segments\";
//   parameter Integer pipe.heatTransfer.n = pipe.n \"Number of heat transfer segments\";
//   parameter Boolean pipe.heatTransfer.use_k = pipe.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real pipe.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real pipe.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Ambient temperature\";
//   parameter Real pipe.heatTransfer.nParallel = pipe.nParallel \"number of identical parallel flow devices\";
//   input Integer pipe.heatTransfer.states[1].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real pipe.heatTransfer.states[1].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real pipe.heatTransfer.states[1].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real pipe.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real pipe.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Integer pipe.heatTransfer.states[2].phase(min = 0, max = 2) \"phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g. interactive use\";
//   input Real pipe.heatTransfer.states[2].h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"specific enthalpy\";
//   input Real pipe.heatTransfer.states[2].d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"density\";
//   input Real pipe.heatTransfer.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"temperature\";
//   input Real pipe.heatTransfer.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"pressure\";
//   input Real pipe.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") = pipe.perimeter * pipe.lengths[1] \"Heat transfer areas\";
//   input Real pipe.heatTransfer.surfaceAreas[2](quantity = \"Area\", unit = \"m2\") = pipe.perimeter * pipe.lengths[2] \"Heat transfer areas\";
//   output Real pipe.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   output Real pipe.heatTransfer.Q_flows[2](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   Real pipe.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real pipe.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real pipe.heatTransfer.heatPorts[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Port temperature\";
//   Real pipe.heatTransfer.heatPorts[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real pipe.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature(pipe.heatTransfer.states[1]) \"Temperatures defined by fluid states\";
//   Real pipe.heatTransfer.Ts[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = Modelica.Fluid.Pipes.DynamicPipe.HeatTransfer.Medium.temperature(pipe.heatTransfer.states[2]) \"Temperatures defined by fluid states\";
//   input Real pipe.heatTransfer.vs[1](quantity = \"Velocity\", unit = \"m/s\") = pipe.vs[1] \"Mean velocities of fluid flow in segments\";
//   input Real pipe.heatTransfer.vs[2](quantity = \"Velocity\", unit = \"m/s\") = pipe.vs[2] \"Mean velocities of fluid flow in segments\";
//   input Real pipe.heatTransfer.lengths[1](quantity = \"Length\", unit = \"m\") = pipe.lengths[1] \"Lengths along flow path\";
//   input Real pipe.heatTransfer.lengths[2](quantity = \"Length\", unit = \"m\") = pipe.lengths[2] \"Lengths along flow path\";
//   input Real pipe.heatTransfer.dimensions[1](quantity = \"Length\", unit = \"m\") = pipe.dimensions[1] \"Characteristic dimensions for fluid flow (diameter for pipe flow)\";
//   input Real pipe.heatTransfer.dimensions[2](quantity = \"Length\", unit = \"m\") = pipe.dimensions[2] \"Characteristic dimensions for fluid flow (diameter for pipe flow)\";
//   input Real pipe.heatTransfer.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughnesses[1] \"Average heights of surface asperities\";
//   input Real pipe.heatTransfer.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) = pipe.roughnesses[2] \"Average heights of surface asperities\";
// initial equation
//   tank.level = tank.level_start;
//   der(tank.medium.T) = 0.0;
//   valve.m_flow_nominal = Modelica.Fluid.Valves.ValveIncompressible.valveCharacteristic(valve.opening_nominal) * (valve.Av * (sqrt(valve.rho_nominal) * Modelica.Fluid.Utilities.regRoot(valve.dp_nominal,valve.dp_small)));
//   der(heater.mediums[1].T) = 0.0;
//   der(heater.mediums[1].p) = 0.0;
//   der(radiator.mediums[1].T) = 0.0;
//   der(radiator.mediums[1].p) = 0.0;
//   der(pipe.mediums[1].T) = 0.0;
//   der(pipe.mediums[2].T) = 0.0;
//   der(pipe.mediums[1].p) = 0.0;
//   der(pipe.mediums[2].p) = 0.0;
// equation
//   tank.medium.MM = 0.018015268;
//   tank.medium.phase = if tank.medium.h < Modelica.Fluid.Vessels.OpenTank.Medium.bubbleEnthalpy(tank.medium.sat) or tank.medium.h > Modelica.Fluid.Vessels.OpenTank.Medium.dewEnthalpy(tank.medium.sat) or tank.medium.p > 22064000.0 then 1 else 2;
//   tank.medium.d = Modelica.Fluid.Vessels.OpenTank.Medium.density_ph(tank.medium.p,tank.medium.h,tank.medium.phase);
//   tank.medium.T = Modelica.Fluid.Vessels.OpenTank.Medium.temperature_ph(tank.medium.p,tank.medium.h,tank.medium.phase);
//   tank.medium.sat.Tsat = Modelica.Fluid.Vessels.OpenTank.Medium.saturationTemperature(tank.medium.p);
//   tank.medium.sat.psat = tank.medium.p;
//   tank.medium.u = tank.medium.h + (-tank.medium.p) / tank.medium.d;
//   tank.medium.R = 461.523636506545;
//   tank.medium.h = tank.medium.state.h;
//   tank.medium.p = tank.medium.state.p;
//   tank.medium.T = tank.medium.state.T;
//   tank.medium.d = tank.medium.state.d;
//   tank.medium.phase = tank.medium.state.phase;
//   tank.medium.X[1] = 1.0;
//   assert(tank.medium.X[1] >= -1e-005 and tank.medium.X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(tank.medium.X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(tank.medium.p >= 0.0,\"Pressure (= \" + String(tank.medium.p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(tank.medium.T,0,true,6) + \" K)\");
//   tank.heatTransfer.states[1].phase = tank.medium.state.phase;
//   tank.heatTransfer.states[1].h = tank.medium.state.h;
//   tank.heatTransfer.states[1].d = tank.medium.state.d;
//   tank.heatTransfer.states[1].T = tank.medium.state.T;
//   tank.heatTransfer.states[1].p = tank.medium.state.p;
//   tank.heatTransfer.Ts[1] = tank.heatTransfer.heatPorts[1].T;
//   tank.heatTransfer.Q_flows[1] = tank.heatTransfer.heatPorts[1].Q_flow + tank.heatTransfer.k * (tank.heatTransfer.surfaceAreas[1] * (tank.heatTransfer.T_ambient - tank.heatTransfer.heatPorts[1].T));
//   tank.V = tank.crossArea * tank.level;
//   tank.medium.p = tank.p_ambient;
//   tank.Wb_flow = (-tank.p_ambient) * der(tank.V);
//   tank.vessel_ps_static[1] = max(0.0,tank.level - tank.portsData_height[1]) * (tank.system.g * tank.medium.d) + tank.p_ambient;
//   tank.vessel_ps_static[2] = max(0.0,tank.level - tank.portsData_height[2]) * (tank.system.g * tank.medium.d) + tank.p_ambient;
//   tank.mb_flow = tank.ports[1].m_flow + tank.ports[2].m_flow;
//   tank.Hb_flow = tank.ports_H_flow[1] + (tank.ports_H_flow[2] + (tank.ports_E_flow[1] + tank.ports_E_flow[2]));
//   tank.Qb_flow = tank.heatTransfer.Q_flows[1];
//   assert(cardinality({}[1]) <= 1,\"
// each ports[i] of volume can at most be connected to one component.
// If two or more connections are present, ideal mixing takes
// place with these connections, which is usually not the intention
// of the modeller. Increase nPorts to add an additional port.
// \");
//   assert(cardinality({}[2]) <= 1,\"
// each ports[i] of volume can at most be connected to one component.
// If two or more connections are present, ideal mixing takes
// place with these connections, which is usually not the intention
// of the modeller. Increase nPorts to add an additional port.
// \");
//   assert(tank.fluidLevel <= tank.fluidLevel_max,\"Vessel is overflowing (fluidLevel > fluidLevel_max = \" + String(tank.fluidLevel,0,true,6) + \")\");
//   assert(tank.fluidLevel > -1e-006 * tank.fluidLevel_max,\"Fluid level (= \" + String(tank.fluidLevel,0,true,6) + \") is below zero meaning that the solution failed.\");
//   tank.portDensities[1] = Modelica.Fluid.Vessels.OpenTank.Medium.density(Modelica.Fluid.Vessels.OpenTank.Medium.setState_phX(tank.vessel_ps_static[1],if tank.ports[1].m_flow > 0.0 then (max(-radiator.port_b.m_flow,1e-015) * radiator.port_b.h_outflow + max(-sensor_T_return.port.m_flow,1e-015) * sensor_T_return.port.h_outflow) / (max(-radiator.port_b.m_flow,1e-015) + max(-sensor_T_return.port.m_flow,1e-015)) else tank.ports[1].h_outflow,{},0));
//   tank.portVelocities[1] = tank.ports[1].m_flow / (tank.portDensities[1] * tank.portAreas[1]);
//   tank.ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank.fluidLevel + (-0.1 * tank.portsData_diameter[1] - tank.portsData_height[1]),1.0,0.001,0.1 * tank.portsData_diameter[1]);
//   if tank.fluidLevel >= tank.portsData_height[1] then
//   tank.ports[1].p = tank.vessel_ps_static[1] + 0.5 * (tank.portAreas[1] ^ -2.0 * Modelica.Fluid.Utilities.regSquare2(tank.ports[1].m_flow,tank.m_flow_small,(tank.ports_penetration[1] * (-1.0 + (tank.portsData_zeta_in[1] + tank.portAreas[1] ^ 2.0 * tank.vesselArea ^ -2.0))) / tank.portDensities[1],(1.0 + (tank.portsData_zeta_out[1] - tank.portAreas[1] ^ 2.0 * tank.vesselArea ^ -2.0)) / (tank.ports_penetration[1] * tank.medium.d),false,1));
//   tank.s[1] = tank.fluidLevel - tank.portsData_height[1];
//   elseif tank.s[1] > 0.0 or tank.portsData_height[1] >= tank.fluidLevel_max then
//   tank.ports[1].p = tank.vessel_ps_static[1];
//   tank.s[1] = tank.ports[1].m_flow;
//   else
//   tank.ports[1].m_flow = 0.0;
//   tank.s[1] = (tank.ports[1].p / 101325.0 + (-tank.vessel_ps_static[1]) / 101325.0) * (tank.portsData_height[1] - tank.fluidLevel);
//   end if;
//   tank.ports[1].h_outflow = tank.medium.h;
//   tank.ports_H_flow[1] = tank.ports[1].m_flow * (if tank.ports[1].m_flow > 0.0 then (max(-radiator.port_b.m_flow,1e-015) * radiator.port_b.h_outflow + max(-sensor_T_return.port.m_flow,1e-015) * sensor_T_return.port.h_outflow) / (max(-radiator.port_b.m_flow,1e-015) + max(-sensor_T_return.port.m_flow,1e-015)) else tank.ports[1].h_outflow);
//   tank.ports_E_flow[1] = tank.ports[1].m_flow * (0.5 * tank.portVelocities[1] ^ 2.0 + tank.system.g * tank.portsData_height[1]);
//   tank.portDensities[2] = Modelica.Fluid.Vessels.OpenTank.Medium.density(Modelica.Fluid.Vessels.OpenTank.Medium.setState_phX(tank.vessel_ps_static[2],if tank.ports[2].m_flow > 0.0 then pump.port_a.h_outflow else tank.ports[2].h_outflow,{},0));
//   tank.portVelocities[2] = tank.ports[2].m_flow / (tank.portDensities[2] * tank.portAreas[2]);
//   tank.ports_penetration[2] = Modelica.Fluid.Utilities.regStep(tank.fluidLevel + (-0.1 * tank.portsData_diameter[2] - tank.portsData_height[2]),1.0,0.001,0.1 * tank.portsData_diameter[2]);
//   if tank.fluidLevel >= tank.portsData_height[2] then
//   tank.ports[2].p = tank.vessel_ps_static[2] + 0.5 * (tank.portAreas[2] ^ -2.0 * Modelica.Fluid.Utilities.regSquare2(tank.ports[2].m_flow,tank.m_flow_small,(tank.ports_penetration[2] * (-1.0 + (tank.portsData_zeta_in[2] + tank.portAreas[2] ^ 2.0 * tank.vesselArea ^ -2.0))) / tank.portDensities[2],(1.0 + (tank.portsData_zeta_out[2] - tank.portAreas[2] ^ 2.0 * tank.vesselArea ^ -2.0)) / (tank.ports_penetration[2] * tank.medium.d),false,1));
//   tank.s[2] = tank.fluidLevel - tank.portsData_height[2];
//   elseif tank.s[2] > 0.0 or tank.portsData_height[2] >= tank.fluidLevel_max then
//   tank.ports[2].p = tank.vessel_ps_static[2];
//   tank.s[2] = tank.ports[2].m_flow;
//   else
//   tank.ports[2].m_flow = 0.0;
//   tank.s[2] = (tank.ports[2].p / 101325.0 + (-tank.vessel_ps_static[2]) / 101325.0) * (tank.portsData_height[2] - tank.fluidLevel);
//   end if;
//   tank.ports[2].h_outflow = tank.medium.h;
//   tank.ports_H_flow[2] = tank.ports[2].m_flow * (if tank.ports[2].m_flow > 0.0 then pump.port_a.h_outflow else tank.ports[2].h_outflow);
//   tank.ports_E_flow[2] = tank.ports[2].m_flow * (0.5 * tank.portVelocities[2] ^ 2.0 + tank.system.g * tank.portsData_height[2]);
//   assert(not (tank.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState and tank.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),\"Bad combination of dynamics options and Medium not conserving mass if fluidVolume is fixed.\");
//   tank.m = tank.fluidVolume * tank.medium.d;
//   tank.U = tank.m * tank.medium.u;
//   der(tank.U) = tank.Hb_flow + (tank.Qb_flow + tank.Wb_flow);
//   der(tank.m) = tank.mb_flow;
//   pump.heatTransfer.states[1].phase = pump.medium.state.phase;
//   pump.heatTransfer.states[1].h = pump.medium.state.h;
//   pump.heatTransfer.states[1].d = pump.medium.state.d;
//   pump.heatTransfer.states[1].T = pump.medium.state.T;
//   pump.heatTransfer.states[1].p = pump.medium.state.p;
//   pump.heatTransfer.Ts[1] = pump.heatTransfer.heatPorts[1].T;
//   pump.heatTransfer.Q_flows[1] = pump.heatTransfer.heatPorts[1].Q_flow;
//   pump.medium.MM = 0.018015268;
//   pump.medium.phase = if pump.medium.h < Modelica.Fluid.Machines.ControlledPump.Medium.bubbleEnthalpy(pump.medium.sat) or pump.medium.h > Modelica.Fluid.Machines.ControlledPump.Medium.dewEnthalpy(pump.medium.sat) or pump.medium.p > 22064000.0 then 1 else 2;
//   pump.medium.d = Modelica.Fluid.Machines.ControlledPump.Medium.density_ph(pump.medium.p,pump.medium.h,pump.medium.phase);
//   pump.medium.T = Modelica.Fluid.Machines.ControlledPump.Medium.temperature_ph(pump.medium.p,pump.medium.h,pump.medium.phase);
//   pump.medium.sat.Tsat = Modelica.Fluid.Machines.ControlledPump.Medium.saturationTemperature(pump.medium.p);
//   pump.medium.sat.psat = pump.medium.p;
//   pump.medium.u = pump.medium.h + (-pump.medium.p) / pump.medium.d;
//   pump.medium.R = 461.523636506545;
//   pump.medium.h = pump.medium.state.h;
//   pump.medium.p = pump.medium.state.p;
//   pump.medium.T = pump.medium.state.T;
//   pump.medium.d = pump.medium.state.d;
//   pump.medium.phase = pump.medium.state.phase;
//   pump.medium.X[1] = 1.0;
//   assert(pump.medium.X[1] >= -1e-005 and pump.medium.X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(pump.medium.X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(pump.medium.p >= 0.0,\"Pressure (= \" + String(pump.medium.p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(pump.medium.T,0,true,6) + \" K)\");
//   pump.dp_pump = pump.p_set_internal - pump.port_a.p;
//   pump.m_flow_set_internal = pump.m_flow_nominal;
//   pump.p_set_internal = pump.p_b_nominal;
//   if not pump.checkValve then
//   pump.head = (pump.N / pump.N_nominal) ^ 2.0 * Modelica.Fluid.Machines.ControlledPump.flowCharacteristic((pump.V_flow_single * pump.N_nominal) / pump.N,{0.0,pump.V_flow_op,1.5 * pump.V_flow_op},{2.0 * pump.head_op,pump.head_op,0.0});
//   pump.s = 0.0;
//   elseif pump.s > 0.0 then
//   pump.head = (pump.N / pump.N_nominal) ^ 2.0 * Modelica.Fluid.Machines.ControlledPump.flowCharacteristic((pump.V_flow_single * pump.N_nominal) / pump.N,{0.0,pump.V_flow_op,1.5 * pump.V_flow_op},{2.0 * pump.head_op,pump.head_op,0.0});
//   pump.V_flow_single = pump.s / pump.rho;
//   else
//   pump.head = (pump.N / pump.N_nominal) ^ 2.0 * Modelica.Fluid.Machines.ControlledPump.flowCharacteristic(0.0,{0.0,pump.V_flow_op,1.5 * pump.V_flow_op},{2.0 * pump.head_op,pump.head_op,0.0}) - pump.s;
//   pump.V_flow_single = 0.0;
//   end if;
//   pump.eta = Modelica.Fluid.Machines.ControlledPump.efficiencyCharacteristic((pump.V_flow_single * pump.N_nominal) / pump.N,0.8);
//   pump.W_single = (pump.dp_pump * pump.V_flow_single) / pump.eta;
//   pump.Wb_flow = pump.W_total;
//   pump.Qb_flow = pump.heatTransfer.Q_flows[1];
//   pump.Hb_flow = pump.port_a.m_flow * (if pump.port_a.m_flow > 0.0 then tank.ports[2].h_outflow else pump.port_a.h_outflow) + pump.port_b.m_flow * (if pump.port_b.m_flow > 0.0 then sensor_m_flow.port_a.h_outflow else pump.port_b.h_outflow);
//   pump.port_a.h_outflow = pump.medium.h;
//   pump.port_b.h_outflow = pump.medium.h;
//   pump.port_b.p = pump.medium.p;
//   pump.mb_flow = pump.port_a.m_flow + pump.port_b.m_flow;
//   assert(not (pump.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState and pump.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),\"Bad combination of dynamics options and Medium not conserving mass if fluidVolume is fixed.\");
//   pump.m = pump.fluidVolume * pump.medium.d;
//   pump.U = pump.m * pump.medium.u;
//   0.0 = pump.Hb_flow + (pump.Qb_flow + pump.Wb_flow);
//   0.0 = pump.mb_flow;
//   valve.m_flow = Modelica.Fluid.Valves.ValveIncompressible.valveCharacteristic(valve.opening) * (valve.Av * (sqrt(Modelica.Fluid.Valves.ValveIncompressible.Medium.density(valve.state_a)) * Modelica.Fluid.Utilities.regRoot(valve.dp,valve.dp_small)));
//   valve.port_a.h_outflow = radiator.port_a.h_outflow;
//   valve.port_b.h_outflow = pipe.port_b.h_outflow;
//   valve.state_a = Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX(valve.port_a.p,pipe.port_b.h_outflow,{},0);
//   valve.state_b = Modelica.Fluid.Valves.ValveIncompressible.Medium.setState_phX(valve.port_b.p,radiator.port_a.h_outflow,{},0);
//   valve.dp = valve.port_a.p - valve.port_b.p;
//   valve.m_flow = valve.port_a.m_flow;
//   assert(valve.m_flow > -valve.m_flow_small or valve.allowFlowReversal,\"Reverting flow occurs even though allowFlowReversal is false\");
//   valve.port_a.m_flow + valve.port_b.m_flow = 0.0;
//   sensor_m_flow.m_flow = sensor_m_flow.port_a.m_flow;
//   0.0 = sensor_m_flow.port_a.m_flow + sensor_m_flow.port_b.m_flow;
//   sensor_m_flow.port_a.p = sensor_m_flow.port_b.p;
//   sensor_m_flow.port_a.h_outflow = heater.port_a.h_outflow;
//   sensor_m_flow.port_b.h_outflow = pump.port_b.h_outflow;
//   T_ambient.port.T = T_ambient.T;
//   wall.Q_flow = wall.G * wall.dT;
//   wall.dT = wall.port_a.T - wall.port_b.T;
//   wall.port_a.Q_flow = wall.Q_flow;
//   wall.port_b.Q_flow = -wall.Q_flow;
//   burner.port.Q_flow = (-burner.Q_flow) * (1.0 + burner.alpha * (burner.port.T - burner.T_ref));
//   heater.flowModel.states[1].phase = heater.statesFM[1].phase;
//   heater.flowModel.states[1].h = heater.statesFM[1].h;
//   heater.flowModel.states[1].d = heater.statesFM[1].d;
//   heater.flowModel.states[1].T = heater.statesFM[1].T;
//   heater.flowModel.states[1].p = heater.statesFM[1].p;
//   heater.flowModel.states[2].phase = heater.statesFM[2].phase;
//   heater.flowModel.states[2].h = heater.statesFM[2].h;
//   heater.flowModel.states[2].d = heater.statesFM[2].d;
//   heater.flowModel.states[2].T = heater.statesFM[2].T;
//   heater.flowModel.states[2].p = heater.statesFM[2].p;
//   assert(heater.flowModel.m_flows[1] > -heater.flowModel.m_flow_small or heater.flowModel.allowFlowReversal,\"Reverting flow occurs even though allowFlowReversal is false\");
//   heater.flowModel.m_flows[1] = heater.flowModel.nParallel * Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.massFlowRate_dp_staticHead(heater.flowModel.dps_fg[1],heater.flowModel.rhos[1],heater.flowModel.rhos[2],heater.flowModel.mus[1],heater.flowModel.mus[2],heater.flowModel.pathLengths_internal[1],heater.flowModel.diameters[1],heater.flowModel.g * heater.flowModel.dheights[1],heater.flowModel.roughnesses[1] / 2.0 + heater.flowModel.roughnesses[2] / 2.0,heater.flowModel.dp_small / Real(heater.flowModel.n));
//   heater.flowModel.rhos_act[1] = if noEvent(heater.flowModel.m_flows[1] > 0.0) then heater.flowModel.rhos[1] else heater.flowModel.rhos[2];
//   heater.flowModel.mus_act[1] = if noEvent(heater.flowModel.m_flows[1] > 0.0) then heater.flowModel.mus[1] else heater.flowModel.mus[2];
//   heater.flowModel.Ib_flows[1] = 0.0;
//   heater.flowModel.Fs_p[1] = heater.flowModel.nParallel * (0.5 * ((heater.flowModel.crossAreas[1] + heater.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(heater.flowModel.states[2]) - Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(heater.flowModel.states[1]))));
//   heater.flowModel.dps_fg[1] = (2.0 * heater.flowModel.Fs_fg[1]) / ((heater.flowModel.crossAreas[1] + heater.flowModel.crossAreas[2]) * heater.flowModel.nParallel);
//   heater.flowModel.Is[1] = heater.flowModel.m_flows[1] * heater.flowModel.pathLengths[1];
//   0.0 = heater.flowModel.Ib_flows[1] - heater.flowModel.Fs_p[1] - heater.flowModel.Fs_fg[1];
//   heater.mediums[1].MM = 0.018015268;
//   heater.mediums[1].phase = if heater.mediums[1].h < Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy(heater.mediums[1].sat) or heater.mediums[1].h > Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy(heater.mediums[1].sat) or heater.mediums[1].p > 22064000.0 then 1 else 2;
//   heater.mediums[1].d = Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph(heater.mediums[1].p,heater.mediums[1].h,heater.mediums[1].phase);
//   heater.mediums[1].T = Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph(heater.mediums[1].p,heater.mediums[1].h,heater.mediums[1].phase);
//   heater.mediums[1].sat.Tsat = Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature(heater.mediums[1].p);
//   heater.mediums[1].sat.psat = heater.mediums[1].p;
//   heater.mediums[1].u = heater.mediums[1].h + (-heater.mediums[1].p) / heater.mediums[1].d;
//   heater.mediums[1].R = 461.523636506545;
//   heater.mediums[1].h = heater.mediums[1].state.h;
//   heater.mediums[1].p = heater.mediums[1].state.p;
//   heater.mediums[1].T = heater.mediums[1].state.T;
//   heater.mediums[1].d = heater.mediums[1].state.d;
//   heater.mediums[1].phase = heater.mediums[1].state.phase;
//   heater.mediums[1].X[1] = 1.0;
//   assert(heater.mediums[1].X[1] >= -1e-005 and heater.mediums[1].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(heater.mediums[1].X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(heater.mediums[1].p >= 0.0,\"Pressure (= \" + String(heater.mediums[1].p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(heater.mediums[1].T,0,true,6) + \" K)\");
//   heater.heatTransfer.states[1].phase = heater.mediums[1].state.phase;
//   heater.heatTransfer.states[1].h = heater.mediums[1].state.h;
//   heater.heatTransfer.states[1].d = heater.mediums[1].state.d;
//   heater.heatTransfer.states[1].T = heater.mediums[1].state.T;
//   heater.heatTransfer.states[1].p = heater.mediums[1].state.p;
//   heater.heatTransfer.Ts[1] = heater.heatTransfer.heatPorts[1].T;
//   heater.heatTransfer.Q_flows[1] = heater.heatTransfer.heatPorts[1].Q_flow + heater.heatTransfer.k * (heater.heatTransfer.surfaceAreas[1] * (heater.heatTransfer.T_ambient - heater.heatTransfer.heatPorts[1].T));
//   heater.Qb_flows[1] = heater.heatTransfer.Q_flows[1];
//   heater.Wb_flows[1] = heater.nParallel * (heater.vs[1] * (heater.dxs[1] ^ 2.0 * (heater.crossAreas[1] * (heater.port_b.p + (heater.flowModel.dps_fg[1] + ((-heater.port_a.p) - system.g * (heater.dheights[1] * heater.mediums[1].d)))))) * heater.dxs[1]);
//   assert(heater.length >= heater.height_ab,\"Parameter length must be greater or equal height_ab.\");
//   assert(heater.nNodes > 1 or heater.modelStructure <> Modelica.Fluid.Types.ModelStructure.av_vb,\"nNodes needs to be at least 2 for modelStructure av_vb, as flow model disappears otherwise!\");
//   heater.pathLengths[1] = heater.lengths[1];
//   heater.dheightsFM[1] = heater.dheights[1];
//   heater.crossAreasFM[1] = heater.crossAreas[1];
//   heater.crossAreasFM[2] = heater.crossAreas[1];
//   heater.dimensionsFM[1] = heater.dimensions[1];
//   heater.dimensionsFM[2] = heater.dimensions[1];
//   heater.roughnessesFM[1] = heater.roughnesses[1];
//   heater.roughnessesFM[2] = heater.roughnesses[1];
//   heater.mb_flows[1] = heater.m_flows[1] - heater.m_flows[2];
//   heater.Hb_flows[1] = heater.H_flows[1] - heater.H_flows[2];
//   heater.H_flows[1] = semiLinear(heater.port_a.m_flow,sensor_m_flow.port_b.h_outflow,heater.mediums[1].h);
//   heater.H_flows[2] = -semiLinear(heater.port_b.m_flow,(max(-sensor_T_forward.port.m_flow,1e-015) * sensor_T_forward.port.h_outflow + max(-pipe.port_a.m_flow,1e-015) * pipe.port_a.h_outflow) / (max(-sensor_T_forward.port.m_flow,1e-015) + max(-pipe.port_a.m_flow,1e-015)),heater.mediums[1].h);
//   heater.port_a.m_flow = heater.m_flows[1];
//   heater.port_b.m_flow = -heater.m_flows[2];
//   heater.port_a.h_outflow = heater.mediums[1].h;
//   heater.port_b.h_outflow = heater.mediums[1].h;
//   heater.state_a = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(heater.port_a.p,sensor_m_flow.port_b.h_outflow,{},0);
//   heater.state_b = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(heater.port_b.p,(max(-sensor_T_forward.port.m_flow,1e-015) * sensor_T_forward.port.h_outflow + max(-pipe.port_a.m_flow,1e-015) * pipe.port_a.h_outflow) / (max(-sensor_T_forward.port.m_flow,1e-015) + max(-pipe.port_a.m_flow,1e-015)),{},0);
//   heater.statesFM[1].phase = heater.state_a.phase;
//   heater.statesFM[1].h = heater.state_a.h;
//   heater.statesFM[1].d = heater.state_a.d;
//   heater.statesFM[1].T = heater.state_a.T;
//   heater.statesFM[1].p = heater.state_a.p;
//   heater.statesFM[2].phase = heater.mediums[1].state.phase;
//   heater.statesFM[2].h = heater.mediums[1].state.h;
//   heater.statesFM[2].d = heater.mediums[1].state.d;
//   heater.statesFM[2].T = heater.mediums[1].state.T;
//   heater.statesFM[2].p = heater.mediums[1].state.p;
//   heater.m_flows[1] = heater.flowModel.m_flows[1];
//   heater.vsFM[1] = heater.m_flows[1] / (heater.nParallel * Modelica.Fluid.Pipes.DynamicPipe.Medium.density(heater.state_a) * heater.crossAreas[1]);
//   heater.vsFM[2] = heater.vs[1];
//   heater.port_b.p = heater.mediums[1].p;
//   assert(not (heater.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState and heater.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),\"Bad combination of dynamics options and Medium not conserving mass if fluidVolumes are fixed.\");
//   heater.ms[1] = heater.fluidVolumes[1] * heater.mediums[1].d;
//   heater.Us[1] = heater.ms[1] * heater.mediums[1].u;
//   der(heater.Us[1]) = heater.Hb_flows[1] + (heater.Wb_flows[1] + heater.Qb_flows[1]);
//   der(heater.ms[1]) = heater.mb_flows[1];
//   radiator.flowModel.states[1].phase = radiator.statesFM[1].phase;
//   radiator.flowModel.states[1].h = radiator.statesFM[1].h;
//   radiator.flowModel.states[1].d = radiator.statesFM[1].d;
//   radiator.flowModel.states[1].T = radiator.statesFM[1].T;
//   radiator.flowModel.states[1].p = radiator.statesFM[1].p;
//   radiator.flowModel.states[2].phase = radiator.statesFM[2].phase;
//   radiator.flowModel.states[2].h = radiator.statesFM[2].h;
//   radiator.flowModel.states[2].d = radiator.statesFM[2].d;
//   radiator.flowModel.states[2].T = radiator.statesFM[2].T;
//   radiator.flowModel.states[2].p = radiator.statesFM[2].p;
//   assert(radiator.flowModel.m_flows[1] > -radiator.flowModel.m_flow_small or radiator.flowModel.allowFlowReversal,\"Reverting flow occurs even though allowFlowReversal is false\");
//   radiator.flowModel.m_flows[1] = radiator.flowModel.nParallel * Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.massFlowRate_dp_staticHead(radiator.flowModel.dps_fg[1],radiator.flowModel.rhos[1],radiator.flowModel.rhos[2],radiator.flowModel.mus[1],radiator.flowModel.mus[2],radiator.flowModel.pathLengths_internal[1],radiator.flowModel.diameters[1],radiator.flowModel.g * radiator.flowModel.dheights[1],radiator.flowModel.roughnesses[1] / 2.0 + radiator.flowModel.roughnesses[2] / 2.0,radiator.flowModel.dp_small / Real(radiator.flowModel.n));
//   radiator.flowModel.rhos_act[1] = if noEvent(radiator.flowModel.m_flows[1] > 0.0) then radiator.flowModel.rhos[1] else radiator.flowModel.rhos[2];
//   radiator.flowModel.mus_act[1] = if noEvent(radiator.flowModel.m_flows[1] > 0.0) then radiator.flowModel.mus[1] else radiator.flowModel.mus[2];
//   radiator.flowModel.Ib_flows[1] = 0.0;
//   radiator.flowModel.Fs_p[1] = radiator.flowModel.nParallel * (0.5 * ((radiator.flowModel.crossAreas[1] + radiator.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(radiator.flowModel.states[2]) - Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(radiator.flowModel.states[1]))));
//   radiator.flowModel.dps_fg[1] = (2.0 * radiator.flowModel.Fs_fg[1]) / ((radiator.flowModel.crossAreas[1] + radiator.flowModel.crossAreas[2]) * radiator.flowModel.nParallel);
//   radiator.flowModel.Is[1] = radiator.flowModel.m_flows[1] * radiator.flowModel.pathLengths[1];
//   0.0 = radiator.flowModel.Ib_flows[1] - radiator.flowModel.Fs_p[1] - radiator.flowModel.Fs_fg[1];
//   radiator.mediums[1].MM = 0.018015268;
//   radiator.mediums[1].phase = if radiator.mediums[1].h < Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy(radiator.mediums[1].sat) or radiator.mediums[1].h > Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy(radiator.mediums[1].sat) or radiator.mediums[1].p > 22064000.0 then 1 else 2;
//   radiator.mediums[1].d = Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph(radiator.mediums[1].p,radiator.mediums[1].h,radiator.mediums[1].phase);
//   radiator.mediums[1].T = Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph(radiator.mediums[1].p,radiator.mediums[1].h,radiator.mediums[1].phase);
//   radiator.mediums[1].sat.Tsat = Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature(radiator.mediums[1].p);
//   radiator.mediums[1].sat.psat = radiator.mediums[1].p;
//   radiator.mediums[1].u = radiator.mediums[1].h + (-radiator.mediums[1].p) / radiator.mediums[1].d;
//   radiator.mediums[1].R = 461.523636506545;
//   radiator.mediums[1].h = radiator.mediums[1].state.h;
//   radiator.mediums[1].p = radiator.mediums[1].state.p;
//   radiator.mediums[1].T = radiator.mediums[1].state.T;
//   radiator.mediums[1].d = radiator.mediums[1].state.d;
//   radiator.mediums[1].phase = radiator.mediums[1].state.phase;
//   radiator.mediums[1].X[1] = 1.0;
//   assert(radiator.mediums[1].X[1] >= -1e-005 and radiator.mediums[1].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(radiator.mediums[1].X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(radiator.mediums[1].p >= 0.0,\"Pressure (= \" + String(radiator.mediums[1].p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(radiator.mediums[1].T,0,true,6) + \" K)\");
//   radiator.heatTransfer.states[1].phase = radiator.mediums[1].state.phase;
//   radiator.heatTransfer.states[1].h = radiator.mediums[1].state.h;
//   radiator.heatTransfer.states[1].d = radiator.mediums[1].state.d;
//   radiator.heatTransfer.states[1].T = radiator.mediums[1].state.T;
//   radiator.heatTransfer.states[1].p = radiator.mediums[1].state.p;
//   radiator.heatTransfer.Ts[1] = radiator.heatTransfer.heatPorts[1].T;
//   radiator.heatTransfer.Q_flows[1] = radiator.heatTransfer.heatPorts[1].Q_flow + radiator.heatTransfer.k * (radiator.heatTransfer.surfaceAreas[1] * (radiator.heatTransfer.T_ambient - radiator.heatTransfer.heatPorts[1].T));
//   radiator.Qb_flows[1] = radiator.heatTransfer.Q_flows[1];
//   radiator.Wb_flows[1] = radiator.nParallel * (radiator.vs[1] * (radiator.dxs[1] ^ 2.0 * (radiator.crossAreas[1] * (radiator.port_b.p + (radiator.flowModel.dps_fg[1] + ((-radiator.port_a.p) - system.g * (radiator.dheights[1] * radiator.mediums[1].d)))))) * radiator.dxs[1]);
//   assert(radiator.length >= radiator.height_ab,\"Parameter length must be greater or equal height_ab.\");
//   assert(radiator.nNodes > 1 or radiator.modelStructure <> Modelica.Fluid.Types.ModelStructure.av_vb,\"nNodes needs to be at least 2 for modelStructure av_vb, as flow model disappears otherwise!\");
//   radiator.pathLengths[1] = radiator.lengths[1];
//   radiator.dheightsFM[1] = radiator.dheights[1];
//   radiator.crossAreasFM[1] = radiator.crossAreas[1];
//   radiator.crossAreasFM[2] = radiator.crossAreas[1];
//   radiator.dimensionsFM[1] = radiator.dimensions[1];
//   radiator.dimensionsFM[2] = radiator.dimensions[1];
//   radiator.roughnessesFM[1] = radiator.roughnesses[1];
//   radiator.roughnessesFM[2] = radiator.roughnesses[1];
//   radiator.mb_flows[1] = radiator.m_flows[1] - radiator.m_flows[2];
//   radiator.Hb_flows[1] = radiator.H_flows[1] - radiator.H_flows[2];
//   radiator.H_flows[1] = semiLinear(radiator.port_a.m_flow,valve.port_b.h_outflow,radiator.mediums[1].h);
//   radiator.H_flows[2] = -semiLinear(radiator.port_b.m_flow,(max(-tank.ports[1].m_flow,1e-015) * tank.ports[1].h_outflow + max(-sensor_T_return.port.m_flow,1e-015) * sensor_T_return.port.h_outflow) / (max(-tank.ports[1].m_flow,1e-015) + max(-sensor_T_return.port.m_flow,1e-015)),radiator.mediums[1].h);
//   radiator.port_a.m_flow = radiator.m_flows[1];
//   radiator.port_b.m_flow = -radiator.m_flows[2];
//   radiator.port_a.h_outflow = radiator.mediums[1].h;
//   radiator.port_b.h_outflow = radiator.mediums[1].h;
//   radiator.state_a = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(radiator.port_a.p,valve.port_b.h_outflow,{},0);
//   radiator.state_b = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(radiator.port_b.p,(max(-tank.ports[1].m_flow,1e-015) * tank.ports[1].h_outflow + max(-sensor_T_return.port.m_flow,1e-015) * sensor_T_return.port.h_outflow) / (max(-tank.ports[1].m_flow,1e-015) + max(-sensor_T_return.port.m_flow,1e-015)),{},0);
//   radiator.statesFM[1].phase = radiator.mediums[1].state.phase;
//   radiator.statesFM[1].h = radiator.mediums[1].state.h;
//   radiator.statesFM[1].d = radiator.mediums[1].state.d;
//   radiator.statesFM[1].T = radiator.mediums[1].state.T;
//   radiator.statesFM[1].p = radiator.mediums[1].state.p;
//   radiator.statesFM[2].phase = radiator.state_b.phase;
//   radiator.statesFM[2].h = radiator.state_b.h;
//   radiator.statesFM[2].d = radiator.state_b.d;
//   radiator.statesFM[2].T = radiator.state_b.T;
//   radiator.statesFM[2].p = radiator.state_b.p;
//   radiator.m_flows[2] = radiator.flowModel.m_flows[1];
//   radiator.vsFM[1] = radiator.vs[1];
//   radiator.vsFM[2] = radiator.m_flows[2] / (radiator.nParallel * Modelica.Fluid.Pipes.DynamicPipe.Medium.density(radiator.state_b) * radiator.crossAreas[1]);
//   radiator.port_a.p = radiator.mediums[1].p;
//   assert(not (radiator.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState and radiator.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),\"Bad combination of dynamics options and Medium not conserving mass if fluidVolumes are fixed.\");
//   radiator.ms[1] = radiator.fluidVolumes[1] * radiator.mediums[1].d;
//   radiator.Us[1] = radiator.ms[1] * radiator.mediums[1].u;
//   der(radiator.Us[1]) = radiator.Hb_flows[1] + (radiator.Wb_flows[1] + radiator.Qb_flows[1]);
//   der(radiator.ms[1]) = radiator.mb_flows[1];
//   sensor_T_forward.T = Modelica.Fluid.Sensors.Temperature.Medium.temperature(Modelica.Fluid.Sensors.Temperature.Medium.setState_phX(sensor_T_forward.port.p,(max(-heater.port_b.m_flow,1e-015) * heater.port_b.h_outflow + max(-pipe.port_a.m_flow,1e-015) * pipe.port_a.h_outflow) / (max(-heater.port_b.m_flow,1e-015) + max(-pipe.port_a.m_flow,1e-015)),{},0));
//   sensor_T_forward.port.m_flow = 0.0;
//   sensor_T_forward.port.h_outflow = 0.0;
//   sensor_T_return.T = Modelica.Fluid.Sensors.Temperature.Medium.temperature(Modelica.Fluid.Sensors.Temperature.Medium.setState_phX(sensor_T_return.port.p,(max(-tank.ports[1].m_flow,1e-015) * tank.ports[1].h_outflow + max(-radiator.port_b.m_flow,1e-015) * radiator.port_b.h_outflow) / (max(-tank.ports[1].m_flow,1e-015) + max(-radiator.port_b.m_flow,1e-015)),{},0));
//   sensor_T_return.port.m_flow = 0.0;
//   sensor_T_return.port.h_outflow = 0.0;
//   handle.y = handle.offset + (if time < handle.startTime then 0.0 else handle.height);
//   pipe.flowModel.states[1].phase = pipe.statesFM[1].phase;
//   pipe.flowModel.states[1].h = pipe.statesFM[1].h;
//   pipe.flowModel.states[1].d = pipe.statesFM[1].d;
//   pipe.flowModel.states[1].T = pipe.statesFM[1].T;
//   pipe.flowModel.states[1].p = pipe.statesFM[1].p;
//   pipe.flowModel.states[2].phase = pipe.statesFM[2].phase;
//   pipe.flowModel.states[2].h = pipe.statesFM[2].h;
//   pipe.flowModel.states[2].d = pipe.statesFM[2].d;
//   pipe.flowModel.states[2].T = pipe.statesFM[2].T;
//   pipe.flowModel.states[2].p = pipe.statesFM[2].p;
//   assert(pipe.flowModel.m_flows[1] > -pipe.flowModel.m_flow_small or pipe.flowModel.allowFlowReversal,\"Reverting flow occurs even though allowFlowReversal is false\");
//   pipe.flowModel.m_flows[1] = pipe.flowModel.nParallel * Modelica.Fluid.Pipes.DynamicPipe.FlowModel.WallFriction.massFlowRate_dp_staticHead(pipe.flowModel.dps_fg[1],pipe.flowModel.rhos[1],pipe.flowModel.rhos[2],pipe.flowModel.mus[1],pipe.flowModel.mus[2],pipe.flowModel.pathLengths_internal[1],pipe.flowModel.diameters[1],pipe.flowModel.g * pipe.flowModel.dheights[1],pipe.flowModel.roughnesses[1] / 2.0 + pipe.flowModel.roughnesses[2] / 2.0,pipe.flowModel.dp_small / Real(pipe.flowModel.n));
//   pipe.flowModel.rhos_act[1] = if noEvent(pipe.flowModel.m_flows[1] > 0.0) then pipe.flowModel.rhos[1] else pipe.flowModel.rhos[2];
//   pipe.flowModel.mus_act[1] = if noEvent(pipe.flowModel.m_flows[1] > 0.0) then pipe.flowModel.mus[1] else pipe.flowModel.mus[2];
//   pipe.flowModel.Ib_flows[1] = 0.0;
//   pipe.flowModel.Fs_p[1] = pipe.flowModel.nParallel * (0.5 * ((pipe.flowModel.crossAreas[1] + pipe.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(pipe.flowModel.states[2]) - Modelica.Fluid.Pipes.DynamicPipe.FlowModel.Medium.pressure(pipe.flowModel.states[1]))));
//   pipe.flowModel.dps_fg[1] = (2.0 * pipe.flowModel.Fs_fg[1]) / ((pipe.flowModel.crossAreas[1] + pipe.flowModel.crossAreas[2]) * pipe.flowModel.nParallel);
//   pipe.flowModel.Is[1] = pipe.flowModel.m_flows[1] * pipe.flowModel.pathLengths[1];
//   0.0 = pipe.flowModel.Ib_flows[1] - pipe.flowModel.Fs_p[1] - pipe.flowModel.Fs_fg[1];
//   pipe.mediums[1].MM = 0.018015268;
//   pipe.mediums[1].phase = if pipe.mediums[1].h < Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy(pipe.mediums[1].sat) or pipe.mediums[1].h > Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy(pipe.mediums[1].sat) or pipe.mediums[1].p > 22064000.0 then 1 else 2;
//   pipe.mediums[1].d = Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph(pipe.mediums[1].p,pipe.mediums[1].h,pipe.mediums[1].phase);
//   pipe.mediums[1].T = Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph(pipe.mediums[1].p,pipe.mediums[1].h,pipe.mediums[1].phase);
//   pipe.mediums[1].sat.Tsat = Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature(pipe.mediums[1].p);
//   pipe.mediums[1].sat.psat = pipe.mediums[1].p;
//   pipe.mediums[1].u = pipe.mediums[1].h + (-pipe.mediums[1].p) / pipe.mediums[1].d;
//   pipe.mediums[1].R = 461.523636506545;
//   pipe.mediums[1].h = pipe.mediums[1].state.h;
//   pipe.mediums[1].p = pipe.mediums[1].state.p;
//   pipe.mediums[1].T = pipe.mediums[1].state.T;
//   pipe.mediums[1].d = pipe.mediums[1].state.d;
//   pipe.mediums[1].phase = pipe.mediums[1].state.phase;
//   pipe.mediums[1].X[1] = 1.0;
//   assert(pipe.mediums[1].X[1] >= -1e-005 and pipe.mediums[1].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(pipe.mediums[1].X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(pipe.mediums[1].p >= 0.0,\"Pressure (= \" + String(pipe.mediums[1].p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(pipe.mediums[1].T,0,true,6) + \" K)\");
//   pipe.mediums[2].MM = 0.018015268;
//   pipe.mediums[2].phase = if pipe.mediums[2].h < Modelica.Fluid.Pipes.DynamicPipe.Medium.bubbleEnthalpy(pipe.mediums[2].sat) or pipe.mediums[2].h > Modelica.Fluid.Pipes.DynamicPipe.Medium.dewEnthalpy(pipe.mediums[2].sat) or pipe.mediums[2].p > 22064000.0 then 1 else 2;
//   pipe.mediums[2].d = Modelica.Fluid.Pipes.DynamicPipe.Medium.density_ph(pipe.mediums[2].p,pipe.mediums[2].h,pipe.mediums[2].phase);
//   pipe.mediums[2].T = Modelica.Fluid.Pipes.DynamicPipe.Medium.temperature_ph(pipe.mediums[2].p,pipe.mediums[2].h,pipe.mediums[2].phase);
//   pipe.mediums[2].sat.Tsat = Modelica.Fluid.Pipes.DynamicPipe.Medium.saturationTemperature(pipe.mediums[2].p);
//   pipe.mediums[2].sat.psat = pipe.mediums[2].p;
//   pipe.mediums[2].u = pipe.mediums[2].h + (-pipe.mediums[2].p) / pipe.mediums[2].d;
//   pipe.mediums[2].R = 461.523636506545;
//   pipe.mediums[2].h = pipe.mediums[2].state.h;
//   pipe.mediums[2].p = pipe.mediums[2].state.p;
//   pipe.mediums[2].T = pipe.mediums[2].state.T;
//   pipe.mediums[2].d = pipe.mediums[2].state.d;
//   pipe.mediums[2].phase = pipe.mediums[2].state.phase;
//   pipe.mediums[2].X[1] = 1.0;
//   assert(pipe.mediums[2].X[1] >= -1e-005 and pipe.mediums[2].X[1] <= 1.00001,\"Mass fraction X[1] = \" + String(pipe.mediums[2].X[1],0,true,6) + \"of substance \" + \"water\" + \"
// of medium \" + \"WaterIF97\" + \" is not in the range 0..1\");
//   assert(pipe.mediums[2].p >= 0.0,\"Pressure (= \" + String(pipe.mediums[2].p,0,true,6) + \" Pa) of medium \\\"\" + \"WaterIF97\" + \"\\\" is negative
// (Temperature = \" + String(pipe.mediums[2].T,0,true,6) + \" K)\");
//   pipe.heatTransfer.states[1].phase = pipe.mediums[1].state.phase;
//   pipe.heatTransfer.states[1].h = pipe.mediums[1].state.h;
//   pipe.heatTransfer.states[1].d = pipe.mediums[1].state.d;
//   pipe.heatTransfer.states[1].T = pipe.mediums[1].state.T;
//   pipe.heatTransfer.states[1].p = pipe.mediums[1].state.p;
//   pipe.heatTransfer.states[2].phase = pipe.mediums[2].state.phase;
//   pipe.heatTransfer.states[2].h = pipe.mediums[2].state.h;
//   pipe.heatTransfer.states[2].d = pipe.mediums[2].state.d;
//   pipe.heatTransfer.states[2].T = pipe.mediums[2].state.T;
//   pipe.heatTransfer.states[2].p = pipe.mediums[2].state.p;
//   pipe.heatTransfer.Ts[1] = pipe.heatTransfer.heatPorts[1].T;
//   pipe.heatTransfer.Ts[2] = pipe.heatTransfer.heatPorts[2].T;
//   pipe.heatTransfer.Q_flows[1] = pipe.heatTransfer.heatPorts[1].Q_flow;
//   pipe.heatTransfer.Q_flows[2] = pipe.heatTransfer.heatPorts[2].Q_flow;
//   pipe.Qb_flows[1] = pipe.heatTransfer.Q_flows[1];
//   pipe.Qb_flows[2] = pipe.heatTransfer.Q_flows[2];
//   pipe.Wb_flows[1] = pipe.vs[1] * (pipe.crossAreas[1] * ((pipe.mediums[2].p / 2.0 + ((-pipe.mediums[1].p) / 2.0 + (pipe.flowModel.dps_fg[1] / 2.0 - system.g * (pipe.dheights[1] * pipe.mediums[1].d)))) * pipe.nParallel));
//   pipe.Wb_flows[2] = pipe.vs[2] * (pipe.crossAreas[2] * ((pipe.mediums[2].p / 2.0 + ((-pipe.mediums[1].p) / 2.0 + (pipe.flowModel.dps_fg[1] / 2.0 - system.g * (pipe.dheights[2] * pipe.mediums[2].d)))) * pipe.nParallel));
//   assert(pipe.length >= pipe.height_ab,\"Parameter length must be greater or equal height_ab.\");
//   assert(pipe.nNodes > 1 or pipe.modelStructure <> Modelica.Fluid.Types.ModelStructure.av_vb,\"nNodes needs to be at least 2 for modelStructure av_vb, as flow model disappears otherwise!\");
//   pipe.pathLengths[1] = pipe.lengths[1] + pipe.lengths[2];
//   pipe.dheightsFM[1] = pipe.dheights[1] + pipe.dheights[2];
//   pipe.crossAreasFM[1] = pipe.crossAreas[1];
//   pipe.crossAreasFM[2] = pipe.crossAreas[2];
//   pipe.dimensionsFM[1] = pipe.dimensions[1];
//   pipe.dimensionsFM[2] = pipe.dimensions[2];
//   pipe.roughnessesFM[1] = pipe.roughnesses[1];
//   pipe.roughnessesFM[2] = pipe.roughnesses[2];
//   pipe.mb_flows[1] = pipe.m_flows[1] - pipe.m_flows[2];
//   pipe.Hb_flows[1] = pipe.H_flows[1] - pipe.H_flows[2];
//   pipe.mb_flows[2] = pipe.m_flows[2] - pipe.m_flows[3];
//   pipe.Hb_flows[2] = pipe.H_flows[2] - pipe.H_flows[3];
//   pipe.H_flows[2] = semiLinear(pipe.m_flows[2],pipe.mediums[1].h,pipe.mediums[2].h);
//   pipe.H_flows[1] = semiLinear(pipe.port_a.m_flow,(max(-heater.port_b.m_flow,1e-015) * heater.port_b.h_outflow + max(-sensor_T_forward.port.m_flow,1e-015) * sensor_T_forward.port.h_outflow) / (max(-heater.port_b.m_flow,1e-015) + max(-sensor_T_forward.port.m_flow,1e-015)),pipe.mediums[1].h);
//   pipe.H_flows[3] = -semiLinear(pipe.port_b.m_flow,valve.port_a.h_outflow,pipe.mediums[2].h);
//   pipe.port_a.m_flow = pipe.m_flows[1];
//   pipe.port_b.m_flow = -pipe.m_flows[3];
//   pipe.port_a.h_outflow = pipe.mediums[1].h;
//   pipe.port_b.h_outflow = pipe.mediums[2].h;
//   pipe.state_a = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(pipe.port_a.p,(max(-heater.port_b.m_flow,1e-015) * heater.port_b.h_outflow + max(-sensor_T_forward.port.m_flow,1e-015) * sensor_T_forward.port.h_outflow) / (max(-heater.port_b.m_flow,1e-015) + max(-sensor_T_forward.port.m_flow,1e-015)),{},0);
//   pipe.state_b = Modelica.Fluid.Pipes.DynamicPipe.Medium.setState_phX(pipe.port_b.p,valve.port_a.h_outflow,{},0);
//   pipe.statesFM[1].phase = pipe.mediums[1].state.phase;
//   pipe.statesFM[1].h = pipe.mediums[1].state.h;
//   pipe.statesFM[1].d = pipe.mediums[1].state.d;
//   pipe.statesFM[1].T = pipe.mediums[1].state.T;
//   pipe.statesFM[1].p = pipe.mediums[1].state.p;
//   pipe.statesFM[2].phase = pipe.mediums[2].state.phase;
//   pipe.statesFM[2].h = pipe.mediums[2].state.h;
//   pipe.statesFM[2].d = pipe.mediums[2].state.d;
//   pipe.statesFM[2].T = pipe.mediums[2].state.T;
//   pipe.statesFM[2].p = pipe.mediums[2].state.p;
//   pipe.m_flows[2] = pipe.flowModel.m_flows[1];
//   pipe.vsFM[1] = pipe.vs[1];
//   pipe.vsFM[2] = pipe.vs[2];
//   pipe.port_a.p = pipe.mediums[1].p;
//   pipe.port_b.p = pipe.mediums[2].p;
//   assert(not (pipe.energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState and pipe.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),\"Bad combination of dynamics options and Medium not conserving mass if fluidVolumes are fixed.\");
//   pipe.ms[1] = pipe.fluidVolumes[1] * pipe.mediums[1].d;
//   pipe.Us[1] = pipe.ms[1] * pipe.mediums[1].u;
//   pipe.ms[2] = pipe.fluidVolumes[2] * pipe.mediums[2].d;
//   pipe.Us[2] = pipe.ms[2] * pipe.mediums[2].u;
//   der(pipe.Us[1]) = pipe.Hb_flows[1] + (pipe.Wb_flows[1] + pipe.Qb_flows[1]);
//   der(pipe.Us[2]) = pipe.Hb_flows[2] + (pipe.Wb_flows[2] + pipe.Qb_flows[2]);
//   der(pipe.ms[1]) = pipe.mb_flows[1];
//   der(pipe.ms[2]) = pipe.mb_flows[2];
//   tankLevel = tank.level;
//   tank.ports[1].m_flow + radiator.port_b.m_flow + sensor_T_return.port.m_flow = 0.0;
//   tank.ports[2].m_flow + pump.port_a.m_flow = 0.0;
//   tank.heatPort.Q_flow = 0.0;
//   (-tank.heatPort.Q_flow) + tank.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   tank.portsData_diameter[2] = tank.portsData_diameter_internal[2];
//   tank.portsData_diameter[1] = tank.portsData_diameter_internal[1];
//   tank.portsData_height[2] = tank.portsData_height_internal[2];
//   tank.portsData_height[1] = tank.portsData_height_internal[1];
//   tank.portsData_zeta_in[2] = tank.portsData_zeta_in_internal[2];
//   tank.portsData_zeta_in[1] = tank.portsData_zeta_in_internal[1];
//   tank.portsData_zeta_out[2] = tank.portsData_zeta_out_internal[2];
//   tank.portsData_zeta_out[1] = tank.portsData_zeta_out_internal[1];
//   tank.heatPort.T = tank.heatTransfer.heatPorts[1].T;
//   pump.port_b.m_flow + sensor_m_flow.port_a.m_flow = 0.0;
//   pump.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   valve.port_a.m_flow + pipe.port_b.m_flow = 0.0;
//   valve.port_b.m_flow + radiator.port_a.m_flow = 0.0;
//   sensor_m_flow.port_b.m_flow + heater.port_a.m_flow = 0.0;
//   T_ambient.port.Q_flow + wall.port_a.Q_flow = 0.0;
//   wall.port_b.Q_flow + radiator.heatPorts[1].Q_flow = 0.0;
//   burner.port.Q_flow + heater.heatPorts[1].Q_flow = 0.0;
//   heater.port_a.m_flow = 0.0;
//   heater.port_b.m_flow = 0.0;
//   heater.port_b.m_flow + sensor_T_forward.port.m_flow + pipe.port_a.m_flow = 0.0;
//   (-heater.heatPorts[1].Q_flow) + heater.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   heater.heatPorts[1].T = heater.heatTransfer.heatPorts[1].T;
//   radiator.port_a.m_flow = 0.0;
//   radiator.port_b.m_flow = 0.0;
//   (-radiator.heatPorts[1].Q_flow) + radiator.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   radiator.heatPorts[1].T = radiator.heatTransfer.heatPorts[1].T;
//   pipe.port_a.m_flow = 0.0;
//   pipe.port_b.m_flow = 0.0;
//   pipe.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   pipe.heatTransfer.heatPorts[2].Q_flow = 0.0;
//   m_flow = sensor_m_flow.m_flow;
//   heater.port_a.p = sensor_m_flow.port_b.p;
//   T_ambient.port.T = wall.port_a.T;
//   T_forward = sensor_T_forward.T;
//   radiator.port_a.p = valve.port_b.p;
//   radiator.port_b.p = sensor_T_return.port.p;
//   radiator.port_b.p = tank.ports[1].p;
//   pump.port_a.p = tank.ports[2].p;
//   handle.y = valve.opening;
//   pump.port_b.p = sensor_m_flow.port_a.p;
//   T_return = sensor_T_return.T;
//   burner.port.T = heater.heatPorts[1].T;
//   radiator.heatPorts[1].T = wall.port_b.T;
//   heater.port_b.p = pipe.port_a.p;
//   heater.port_b.p = sensor_T_forward.port.p;
//   pipe.port_b.p = valve.port_a.p;
// end Modelica.Fluid.Examples.HeatingSystem;
// "
// ""
// "Check of Modelica.Fluid.Examples.HeatingSystem completed successfully.
// 
// Error: Internal error elab_builtin_fill_2 failed in component<NO COMPONENT>
// Error: Internal error elab_builtin_fill_2 failed in componentheater
// Error: Internal error elab_builtin_fill_2 failed in component<NO COMPONENT>
// Error: Internal error elab_builtin_fill_2 failed in componentradiator
// Error: Internal error elab_builtin_fill_2 failed in component<NO COMPONENT>
// 
// Class Modelica.Fluid.Examples.HeatingSystem has 579 equation(s) and 573 variable(s).
// 390 of these are trivial equation(s).
// "
// ""
// endResult
