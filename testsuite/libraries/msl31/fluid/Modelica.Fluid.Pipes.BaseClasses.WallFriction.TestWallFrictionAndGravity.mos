//name:        Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity [version 3.1]
//keyword:     fluid
//status:      correct
//
// instantiate/check model example
//

loadModel(Modelica, {"3.1"}); getErrorString();
setDebugFlags("nogen");

instantiateModel(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity); getErrorString();
checkModel(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity); getErrorString();

// Result:
// true
// ""
// true
// "function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState\"
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_pTX(p, T, X));
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density_pTX;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.dynamicViscosity;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_pTX \"Return thermodynamic state as function of p, T and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_pTX;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX \"Return thermodynamic state as function of p, h and composition X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState state \"thermodynamic state record\";
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.ThermodynamicState state \"thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature;
// 
// function Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.WallFriction.massFlowRate_dp_staticHead \"Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head\"
//   input Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real g_times_height_ab \"Gravity times (Height(port_b) - Height(port_a))\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.000025 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1.0 \"Turbulent flow if |dp| >= dp_small (dummy if use_dp_small = false)\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   protected constant Real pi = 3.141592653589793;
//   protected Real zeta = length / ((2.0 * log10(3.7 * diameter / roughness)) ^ 2.0 * diameter);
//   protected Real k_inv = (3.141592653589793 * diameter ^ 2.0) ^ 2.0 / (zeta * 8.0);
//   protected Real dp_grav_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_a \"Static head if mass flows in design direction (a to b)\";
//   protected Real dp_grav_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_b \"Static head if mass flows against design direction (b to a)\";
//   protected Real k1 = rho_a * k_inv \"Factor in m_flow =  sqrt(k1*(dp-dp_grav_a))\";
//   protected Real k2 = rho_b * k_inv \"Factor in m_flow = -sqrt(k2*|dp-dp_grav_b|)\";
//   protected Real dp_a = max(dp_grav_a, dp_grav_b) + dp_small \"Upper end of regularization domain of the m_flow(dp) relation\";
//   protected Real dp_b = min(dp_grav_a, dp_grav_b) - dp_small \"Lower end of regularization domain of the m_flow(dp) relation\";
//   protected Real m_flow_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at upper end of regularization domain\";
//   protected Real m_flow_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at lower end of regularization domain\";
//   protected Real dm_flow_ddp_fric_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at upper end of regularization domain\";
//   protected Real dm_flow_ddp_fric_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at lower end of regularization domain\";
//   protected Real m_flow_zero(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0;
//   protected Real dp_zero(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = dp_grav_a / 2.0 + dp_grav_b / 2.0;
//   protected Real dm_flow_ddp_fric_zero;
// algorithm
//   assert( roughness > 0.0000000001, \"roughness > 0 required for quadratic turbulent wall friction characteristic\");
//   if dp >= dp_a then
//     m_flow := sqrt(k1 * (dp - dp_grav_a));
//   elseif dp <= dp_b then
//     m_flow := -sqrt(k2 * abs(dp - dp_grav_b));
//   else
//     m_flow_a := sqrt(k1 * (dp_a - dp_grav_a));
//     m_flow_b := -sqrt(k2 * abs(dp_b - dp_grav_b));
//     dm_flow_ddp_fric_a := k1 / (sqrt(k1 * (dp_a - dp_grav_a)) * 2.0);
//     dm_flow_ddp_fric_b := k2 / (sqrt(k2 * abs(dp_b - dp_grav_b)) * 2.0);
//     (m_flow, dm_flow_ddp_fric_zero) := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
//     if dp > dp_zero then
//       (m_flow, _) := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
//     else
//       (m_flow, _) := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
//     end if;
//   end if;
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.WallFriction.massFlowRate_dp_staticHead;
// 
// function Modelica.Fluid.Utilities.regFun3 \"Co-monotonic and C1 smooth regularization function\"
//   input Real x \"Abscissa value\";
//   input Real x0 \"Lower abscissa value\";
//   input Real x1 \"Upper abscissa value\";
//   input Real y0 \"Ordinate value at lower ordinate value\";
//   input Real y1 \"Ordinate value at upper ordinate value\";
//   input Real y0d \"Derivative at lower abscissa value\";
//   input Real y1d \"Derivative at upper abscissa value\";
//   output Real y \"Ordinate value\";
//   output Real c \"Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used\";
//   protected Real h0 \"Width of interval i=0\";
//   protected Real Delta0 \"Slope of secant on interval i=0\";
//   protected Real xstar \"Inflection point of cubic polynomial S0\";
//   protected Real mu \"Distance of inflection point and left limit x0\";
//   protected Real eta \"Distance of right limit x1 and inflection point\";
//   protected Real omega \"Slope of subic polynomial S0 at inflection point\";
//   protected Real rho \"Weighting factor of eta and eta_tilde, mu and mu_tilde\";
//   protected Real theta0 \"Slope metric\";
//   protected Real mu_tilde \"Distance of start of linear section and left limit x0\";
//   protected Real eta_tilde \"Distance of right limit x1 and end of linear section\";
//   protected Real xi1 \"Start of linear section \";
//   protected Real xi2 \"End of linear section \";
//   protected Real a1 \"Leading coefficient of cubic on the left\";
//   protected Real a2 \"Leading coefficient of cubic on the right\";
//   protected Real const12 \"Integration constant of left cubic, linear section\";
//   protected Real const3 \"Integration constant of right cubic\";
//   protected Real aux01;
//   protected Real aux02;
//   protected Boolean useSingleCubicPolynomial = false \"Indicate to override further logic and use single cubic\";
// algorithm
//   assert( x0 < x1, \"regFun3(): Data points not sorted appropriately (x0 = \" + String(x0, 0, true, 6) + \" > x1 = \" + String(x1, 0, true, 6) + \"). Please flip arguments.\");
//   h0 := x1 - x0;
//   Delta0 := (y1 - y0) / h0;
//   if abs(Delta0) <= 0.0 then
//     y := y0;
//   else
//     if abs(y1d + y0d + -2.0 * Delta0) < 0.0000000000001 then
//       xstar := 1e+60 * (x1 - x0) * (2.0 * y0d + y1d + -3.0 * Delta0) * (if y0d + y1d + -2.0 * Delta0 >= 0.0 then 1.0 else -1.0);
//     else
//       xstar := 0.3333333333333333 * (-3.0 * x0 * (y0d + y1d) + 6.0 * x0 * Delta0 + -2.0 * h0 * y0d + 3.0 * h0 * Delta0 - h0 * y1d) / (2.0 * Delta0 + (-y1d) - y0d);
//     end if;
//     mu := xstar - x0;
//     eta := x1 - xstar;
//     omega := 3.0 * (y0d + y1d + -2.0 * Delta0) * (xstar - x0) ^ 2.0 / h0 ^ 2.0 + 2.0 * (-2.0 * y0d + 3.0 * Delta0 - y1d) * (xstar - x0) / h0 + y0d;
//     aux01 := 0.25 * Real(sign(Delta0)) * min(abs(omega), abs(Delta0));
//     if abs(y0d - y1d) <= 0.0000000000001 then
//       aux02 := y0d;
//       if y1 > y0 + y0d * (x1 - x0) then
//         useSingleCubicPolynomial := true;
//       end if;
//     elseif abs(y1d + y0d + -2.0 * Delta0) < 0.0000000000001 then
//       aux02 := 1e+60 * (6.0 * Delta0 * (y1d + y0d + -1.5 * Delta0) + (-y1d) * y0d + (-y1d ^ 2.0) - y0d ^ 2.0) * (if y1d + y0d + -2.0 * Delta0 >= 0.0 then 1.0 else -1.0);
//     else
//       aux02 := (6.0 * Delta0 * (y1d + y0d + -1.5 * Delta0) + (-y1d) * y0d + (-y1d ^ 2.0) - y0d ^ 2.0) / ((y1d + y0d + -2.0 * Delta0) * 3.0);
//     end if;
//     if (mu > 0.0 and eta < h0 and Delta0 * omega <= 0.0 or abs(aux01) < abs(aux02) and aux02 * Delta0 >= 0.0 or abs(aux01) < abs(0.1 * Delta0)) and not useSingleCubicPolynomial then
//       c := aux01;
//       if abs(c) < abs(aux02) and aux02 * Delta0 >= 0.0 then
//         c := aux02;
//       end if;
//       if abs(c) < abs(0.1 * Delta0) then
//         c := 0.1 * Delta0;
//       end if;
//       theta0 := (y0d * mu + y1d * eta) / h0;
//       if abs(theta0 - c) < 0.000001 then
//         c := 0.999999 * theta0;
//       end if;
//       rho := 3.0 * (Delta0 - c) / (theta0 - c);
//       mu_tilde := rho * mu;
//       eta_tilde := rho * eta;
//       xi1 := x0 + mu_tilde;
//       xi2 := x1 - eta_tilde;
//       a1 := (y0d - c) / max(mu_tilde ^ 2.0, 0.0000000000001);
//       a2 := (y1d - c) / max(eta_tilde ^ 2.0, 0.0000000000001);
//       const12 := y0 + (-(x0 - xi1) ^ 3.0) * a1 / 3.0 - c * x0;
//       const3 := y1 + (-(x1 - xi2) ^ 3.0) * a2 / 3.0 - c * x1;
//       if x < xi1 then
//         y := (x - xi1) ^ 3.0 * a1 / 3.0 + c * x + const12;
//       elseif x < xi2 then
//         y := c * x + const12;
//       else
//         y := (x - xi2) ^ 3.0 * a2 / 3.0 + c * x + const3;
//       end if;
//     else
//       y := (y0d + y1d + -2.0 * Delta0) * (x - x0) ^ 3.0 / h0 ^ 2.0 + (-2.0 * y0d + 3.0 * Delta0 - y1d) * (x - x0) ^ 2.0 / h0 + y0d * (x - x0) + y0;
//       aux01 := x0 / 2.0 + x1 / 2.0;
//       c := 3.0 * (y0d + y1d + -2.0 * Delta0) * (aux01 - x0) ^ 2.0 / h0 ^ 2.0 + 2.0 * (-2.0 * y0d + 3.0 * Delta0 - y1d) * (aux01 - x0) / h0 + y0d;
//     end if;
//   end if;
// end Modelica.Fluid.Utilities.regFun3;
// 
// function Modelica.Fluid.Utilities.regStep \"Approximation of a general step, such that the characteristic is continuous and differentiable\"
//   input Real x \"Abscissa value\";
//   input Real y1 \"Ordinate value for x > 0\";
//   input Real y2 \"Ordinate value for x < 0\";
//   input Real x_small(min = 0.0) = 0.00001 \"Approximation of step for -x_small <= x <= x_small; x_small > 0 required\";
//   output Real y \"Ordinate value to approximate y = if x > 0 then y1 else y2\";
// algorithm
//   y := smooth(1, if x > x_small then y1 else if x < (-x_small) then y2 else if abs(x_small) > 0.0 then (y2 - y1) * (-3.0 + (x / x_small) ^ 2.0) * x / (x_small * 4.0) + y1 / 2.0 + y2 / 2.0 else y1 / 2.0 + y2 / 2.0);
// end Modelica.Fluid.Utilities.regStep;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\" y = asin(u);
// end Modelica.Math.asin;
// 
// function Modelica.Math.log10
//   input Real u;
//   output Real y;
// 
//   external \"C\" y = log10(u);
// end Modelica.Math.log10;
// 
// function Modelica.SIunits.Conversions.from_degC \"Convert from Â°Celsius to Kelvin\"
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Kelvin value\";
// algorithm
//   Kelvin := Celsius + 273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// class Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity
//   parameter Real system.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 101325.0 \"Default ambient pressure\";
//   parameter Real system.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Default ambient temperature\";
//   parameter Real system.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.80665 \"Constant gravity acceleration\";
//   parameter Boolean system.allowFlowReversal = true \"= false to restrict to design flow direction (port_a -> port_b)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial \"Default formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Default formulation of momentum balances, if options available\";
//   parameter Real system.m_flow_start(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0 \"Default start value for mass flow rates\";
//   parameter Real system.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = 0.01 \"Default small laminar mass flow rate for regularization of zero flow\";
//   parameter Real system.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = 1.0 \"Default small pressure drop for regularization of laminar and zero flow\";
//   parameter Real system.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.p_ambient \"Default start value for pressures\";
//   parameter Real system.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = system.T_ambient \"Default start value for temperatures\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.massDynamics = system.energyDynamics \"Default formulation of mass balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.substanceDynamics = system.massDynamics \"Default formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.traceDynamics = system.massDynamics \"Default formulation of trace substance balances\";
//   parameter Boolean allowFlowReversal = system.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real port_a.m_flow(quantity = \"MassFlowRate.unusablePartialMedium\", unit = \"kg/s\", min = if allowFlowReversal then -1e+60 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real port_b.m_flow(quantity = \"MassFlowRate.unusablePartialMedium\", unit = \"kg/s\", min = -100000.0, max = if allowFlowReversal then 1e+60 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real dp_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = 0.01 * system.p_start \"Guess value of dp = port_a.p - port_b.p\";
//   parameter Real m_flow_start(quantity = \"MassFlowRate.unusablePartialMedium\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Guess value of m_flow = port_a.m_flow\";
//   parameter Real m_flow_small(quantity = \"MassFlowRate.unusablePartialMedium\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_small \"Small mass flow rate for regularization of zero flow\";
//   parameter Boolean show_T = true \"= true, if temperatures at port_a and port_b are computed\";
//   parameter Boolean show_V_flow = true \"= true, if volume flow rate at inflowing port is computed\";
//   parameter Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   parameter Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   parameter Real height_ab(quantity = \"Length\", unit = \"m\") = 0.0 \"Height(port_b) - Height(port_a)\";
//   parameter Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.000025 \"Absolute roughness of pipe (default = smooth steel pipe)\";
//   parameter Boolean use_nominal = false \"= true, if mu_nominal and rho_nominal are used, otherwise computed from medium\";
//   parameter Real mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.dynamicViscosity(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_pTX(101325.0, 293.15, {1.0})) \"Nominal dynamic viscosity (e.g. mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   parameter Real rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density_pTX(101325.0, 293.15, {1.0}) \"Nominal density (e.g. rho_liquidWater = 995, rho_air = 1.2)\";
//   parameter Boolean show_Re = false \"= true, if Reynolds number is included for plotting\";
//   parameter Boolean from_dp = true \" = true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   parameter Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = system.dp_small \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   protected Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.0000000001;
//   protected Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.0000000001;
//   protected Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if use_nominal then rho_nominal else Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density(state_a);
//   protected Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = if use_nominal then rho_nominal else Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density(state_b);
//   protected Real g_times_height_ab(unit = \"m2/s2\") = system.g * height_ab \"Gravitiy times height_ab = dp_grav/d\";
//   protected final parameter Boolean use_x_small_staticHead = false \"Use dp_/m_flow_small_staticHead only if static head actually exists\";
//   protected Real dp_small_staticHead(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0) = max(dp_small, 0.015 * abs(g_times_height_ab * (rho_a - rho_b))) \"Heuristic for large discontinuities in static head\";
//   protected Real m_flow_small_staticHead(quantity = \"MassFlowRate\", unit = \"kg/s\") = max(m_flow_small, (0.00055 + -0.0000002775 * (rho_a + rho_b)) * abs(g_times_height_ab * (rho_a - rho_b))) \"Heuristic for large discontinuities in static head\";
//   Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = dp_start) \"Pressure difference between port_a and port_b (= port_a.p - port_b.p)\";
//   Real m_flow(quantity = \"MassFlowRate.unusablePartialMedium\", unit = \"kg/s\", min = if allowFlowReversal then -1e+60 else 0.0, max = 100000.0, start = m_flow_start) \"Mass flow rate in design flow direction\";
//   Real port_a_T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = Modelica.Fluid.Utilities.regStep(port_a.m_flow, Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature(state_a), Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX(port_a.p, port_a.h_outflow, {})), m_flow_small) \"Temperature close to port_a, if show_T = true\";
//   Real port_b_T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = Modelica.Fluid.Utilities.regStep(port_b.m_flow, Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature(state_b), Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.temperature(Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX(port_b.p, port_b.h_outflow, {})), m_flow_small) \"Temperature close to port_b, if show_T = true\";
//   Real V_flow(quantity = \"VolumeFlowRate\", unit = \"m3/s\") = m_flow / Modelica.Fluid.Utilities.regStep(m_flow, Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density(state_a), Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.density(state_b), m_flow_small) \"Volume flow rate at inflowing port (positive when flow from port_a to port_b)\";
// equation
//   m_flow = Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.WallFriction.massFlowRate_dp_staticHead(dp, rho_a, rho_b, mu_a, mu_b, length, diameter, g_times_height_ab, roughness, if use_x_small_staticHead then dp_small_staticHead else dp_small);
//   port_a.h_outflow = port_b.h_outflow + system.g * height_ab;
//   port_b.h_outflow = port_a.h_outflow - system.g * height_ab;
//   state_a = Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX(port_a.p, port_a.h_outflow, {});
//   state_b = Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.Medium.setState_phX(port_b.p, port_b.h_outflow, {});
//   dp = port_a.p - port_b.p;
//   m_flow = port_a.m_flow;
//   assert(m_flow > (-m_flow_small) or allowFlowReversal,\"Reverting flow occurs even though allowFlowReversal is false\");
//   port_a.m_flow + port_b.m_flow = 0.0;
//   port_a.m_flow = 0.0;
//   port_b.m_flow = 0.0;
// end Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity;
// "
// "Warning: No corresponding 'inner' declaration found for component system declared as 'outer '.
//   The existing 'inner' components are: 
//     There are no 'inner' components defined in the model in any of the parent scopes of 'outer' component's scope: Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.
//   Check if you have not misspelled the 'outer' component name.
//   Please declare an 'inner' component with the same name in the top scope.
//   Continuing flattening by only considering the 'outer' component declaration.
// Warning: Parameter length has neither value nor start value, and is fixed during initialization (fixed=true)
// Warning: Parameter diameter has neither value nor start value, and is fixed during initialization (fixed=true)
// "
// "Check of Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity completed successfully.
// 
// Warning: No corresponding 'inner' declaration found for component system declared as 'outer '.
//   The existing 'inner' components are: 
//     There are no 'inner' components defined in the model in any of the parent scopes of 'outer' component's scope: Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity.
//   Check if you have not misspelled the 'outer' component name.
//   Please declare an 'inner' component with the same name in the top scope.
//   Continuing flattening by only considering the 'outer' component declaration.
// 
// Class Modelica.Fluid.Pipes.BaseClasses.WallFriction.TestWallFrictionAndGravity has 20 equation(s) and 18 variable(s).
// 9 of these are trivial equation(s).
// "
// ""
// endResult
