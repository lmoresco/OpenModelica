//name:        Modelica.Thermal [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Thermal
//status:      correct
//
// instantiate/check model example
//

loadFile("Modelica/package.mo"); getErrorString();

instantiateModel(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();
checkModel(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.log
//   input Real u;
//   output Real y;
// 
// external "C";
// end Modelica.Math.log;
// 
// function Modelica.Thermal.FluidHeatFlow.Media.Medium "Automatically generated record constructor for Modelica.Thermal.FluidHeatFlow.Media.Medium"
// input Real(quantity="Density", unit="kg/m3", displayUnit="g/cm3", min=0.0) rho = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cp = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cv = 1.0;
// input Real(quantity="ThermalConductivity", unit="W/(m.K)") lamda = 1.0;
// input Real(quantity="KinematicViscosity", unit="m2/s", min=0.0) nue = 1.0;
// output Medium res;
// end Modelica.Thermal.FluidHeatFlow.Media.Medium;
// 
// class Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve
//   parameter Real medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   parameter Real TAmb(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Ambient temperature";
//   output Real dTSource(quantity = "ThermodynamicTemperature", unit = "K") = prescribedHeatFlow.port.T - TAmb "Source over Ambient";
//   output Real dTtoPipe(quantity = "ThermodynamicTemperature", unit = "K") = prescribedHeatFlow.port.T - pipe.heatPort.T "Source over Coolant";
//   output Real dTCoolant(quantity = "ThermodynamicTemperature", unit = "K") = pipe.dT "Coolant's temperature increase";
//   parameter Real ambient1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real ambient1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real ambient1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real ambient1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real ambient1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   output Real ambient1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Outlet temperature of medium";
//   output Real ambient1.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = ambient1.flowPort.h / ambient1.medium.cp "Temperature at flowPort_a";
//   protected Real ambient1.h(quantity = "SpecificEnergy", unit = "J/kg") = ambient1.medium.cp * ambient1.T;
//   parameter Real ambient1.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real ambient1.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real ambient1.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real ambient1.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real ambient1.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real ambient1.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real ambient1.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real ambient1.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real ambient1.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Boolean ambient1.usePressureInput = false "enable / disable pressure input";
//   parameter Real ambient1.constantAmbientPressure(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 0.0) "Ambient pressure";
//   parameter Boolean ambient1.useTemperatureInput = false "enable / disable temperature input";
//   parameter Real ambient1.constantAmbientTemperature(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) = TAmb "Ambient temperature";
//   output Real ambient1.constPressure.y "Connector of Real output signal";
//   parameter Real ambient1.constPressure.k(start = 1.0) = ambient1.constantAmbientPressure "Constant output value";
//   protected input Real ambient1.pAmbient;
//   output Real ambient1.constTemperature.y "Connector of Real output signal";
//   parameter Real ambient1.constTemperature.k(start = 1.0) = ambient1.constantAmbientTemperature "Constant output value";
//   protected input Real ambient1.TAmbient;
//   parameter Real idealPump.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real idealPump.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real idealPump.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real idealPump.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real idealPump.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   parameter Real idealPump.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 0.0 "Mass of medium";
//   parameter Real idealPump.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) = TAmb "Initial temperature of medium";
//   parameter Real idealPump.tapT(min = 0.0, max = 1.0) = 1.0 "Defines temperature of heatPort between inlet and outlet temperature";
//   Real idealPump.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = idealPump.flowPort_a.p - idealPump.flowPort_b.p "Pressure drop a->b";
//   Real idealPump.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = idealPump.flowPort_a.m_flow / idealPump.medium.rho "Volume flow a->b";
//   Real idealPump.Q_flow(quantity = "Power", unit = "W") "Heat exchange with ambient";
//   output Real idealPump.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = idealPump.T0) "Outlet temperature of medium";
//   output Real idealPump.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = idealPump.flowPort_a.h / idealPump.medium.cp "Temperature at flowPort_a";
//   output Real idealPump.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = idealPump.flowPort_b.h / idealPump.medium.cp "Temperature at flowPort_b";
//   output Real idealPump.dT(quantity = "ThermodynamicTemperature", unit = "K") = if noEvent(idealPump.V_flow >= 0.0) then idealPump.T - idealPump.T_a else idealPump.T_b - idealPump.T "Temperature increase of coolant in flow direction";
//   protected Real idealPump.h(quantity = "SpecificEnergy", unit = "J/kg") = idealPump.medium.cp * idealPump.T "Medium's specific enthalpy";
//   protected Real idealPump.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = idealPump.T - sign(idealPump.V_flow) * ((1.0 - idealPump.tapT) * idealPump.dT) "Temperature relevant for heat exchange with ambient";
//   parameter Real idealPump.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real idealPump.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real idealPump.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real idealPump.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real idealPump.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real idealPump.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real idealPump.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real idealPump.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real idealPump.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Real idealPump.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real idealPump.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real idealPump.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real idealPump.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real idealPump.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real idealPump.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real idealPump.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real idealPump.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real idealPump.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Real idealPump.wNominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "1/min", start = 1.0) "Nominal speed";
//   parameter Real idealPump.dp0(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 2.0) "Max. pressure increase @ V_flow=0";
//   parameter Real idealPump.V_flow0(quantity = "VolumeFlowRate", unit = "m3/s", start = 2.0) "Max. volume flow rate @ dp=0";
//   Real idealPump.w(quantity = "AngularVelocity", unit = "rad/s") = der(idealPump.flange_a.phi) "Speed";
//   protected Real idealPump.dp1(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   protected Real idealPump.V_flow1(quantity = "VolumeFlowRate", unit = "m3/s");
//   Real idealPump.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real idealPump.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real valve.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real valve.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real valve.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real valve.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real valve.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   parameter Real valve.m(quantity = "Mass", unit = "kg", min = 0.0, start = 0.0) "Mass of medium";
//   parameter Real valve.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) = TAmb "Initial temperature of medium";
//   parameter Real valve.tapT(min = 0.0, max = 1.0) = 1.0 "Defines temperature of heatPort between inlet and outlet temperature";
//   Real valve.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = valve.flowPort_a.p - valve.flowPort_b.p "Pressure drop a->b";
//   Real valve.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = valve.flowPort_a.m_flow / valve.medium.rho "Volume flow a->b";
//   Real valve.Q_flow(quantity = "Power", unit = "W") "Heat exchange with ambient";
//   output Real valve.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = valve.T0) "Outlet temperature of medium";
//   output Real valve.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = valve.flowPort_a.h / valve.medium.cp "Temperature at flowPort_a";
//   output Real valve.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = valve.flowPort_b.h / valve.medium.cp "Temperature at flowPort_b";
//   output Real valve.dT(quantity = "ThermodynamicTemperature", unit = "K") = if noEvent(valve.V_flow >= 0.0) then valve.T - valve.T_a else valve.T_b - valve.T "Temperature increase of coolant in flow direction";
//   protected Real valve.h(quantity = "SpecificEnergy", unit = "J/kg") = valve.medium.cp * valve.T "Medium's specific enthalpy";
//   protected Real valve.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = valve.T - sign(valve.V_flow) * ((1.0 - valve.tapT) * valve.dT) "Temperature relevant for heat exchange with ambient";
//   parameter Real valve.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real valve.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real valve.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real valve.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real valve.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real valve.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real valve.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real valve.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real valve.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Real valve.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real valve.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real valve.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real valve.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real valve.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real valve.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real valve.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real valve.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real valve.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Boolean valve.LinearCharacteristic(start = true) = false "Type of characteristic";
//   parameter Real valve.y1(min = 1e-60, start = 1.0) "Max. valve opening";
//   parameter Real valve.Kv1(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60, start = 1.0) "Max. flow @ y = y1";
//   parameter Real valve.kv0(min = 1e-60, max = 1.0, start = 0.01) "Leakage flow / max.flow @ y = 0";
//   parameter Real valve.dp0(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 1.0) "Standard pressure drop";
//   parameter Real valve.rho0(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0, start = 10.0) "Standard medium's density";
//   parameter Real valve.frictionLoss(min = 0.0, max = 1.0, start = 0.0) "Part of friction losses fed to medium";
//   protected constant Real valve.unitVolumeFlowRate(quantity = "VolumeFlowRate", unit = "m3/s") = 1.0;
//   protected constant Real valve.small = 1e-60;
//   protected constant Real valve.smallVolumeFlowRate(quantity = "VolumeFlowRate", unit = "m3/s") = 1e-15;
//   protected constant Real valve.eps = 1e-15;
//   protected Real valve.yLim = max(min(valve.y,valve.y1),0.0) "Limited valve opening";
//   protected Real valve.Kv(quantity = "VolumeFlowRate", unit = "m3/s") "Standard flow rate";
//   input Real valve.y;
//   parameter Real pipe.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real pipe.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real pipe.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real pipe.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real pipe.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   parameter Real pipe.m(quantity = "Mass", unit = "kg", min = 0.0, start = 1.0) = 0.1 "Mass of medium";
//   parameter Real pipe.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) = TAmb "Initial temperature of medium";
//   parameter Real pipe.tapT(min = 0.0, max = 1.0) = 1.0 "Defines temperature of heatPort between inlet and outlet temperature";
//   Real pipe.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = pipe.flowPort_a.p - pipe.flowPort_b.p "Pressure drop a->b";
//   Real pipe.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = pipe.flowPort_a.m_flow / pipe.medium.rho "Volume flow a->b";
//   Real pipe.Q_flow(quantity = "Power", unit = "W") "Heat exchange with ambient";
//   output Real pipe.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = pipe.T0) "Outlet temperature of medium";
//   output Real pipe.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = pipe.flowPort_a.h / pipe.medium.cp "Temperature at flowPort_a";
//   output Real pipe.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = pipe.flowPort_b.h / pipe.medium.cp "Temperature at flowPort_b";
//   output Real pipe.dT(quantity = "ThermodynamicTemperature", unit = "K") = if noEvent(pipe.V_flow >= 0.0) then pipe.T - pipe.T_a else pipe.T_b - pipe.T "Temperature increase of coolant in flow direction";
//   protected Real pipe.h(quantity = "SpecificEnergy", unit = "J/kg") = pipe.medium.cp * pipe.T "Medium's specific enthalpy";
//   protected Real pipe.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = pipe.T - sign(pipe.V_flow) * ((1.0 - pipe.tapT) * pipe.dT) "Temperature relevant for heat exchange with ambient";
//   parameter Real pipe.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real pipe.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real pipe.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real pipe.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real pipe.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real pipe.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real pipe.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real pipe.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real pipe.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Real pipe.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real pipe.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real pipe.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real pipe.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real pipe.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real pipe.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real pipe.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real pipe.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real pipe.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Real pipe.V_flowLaminar(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60, start = 0.1) "Laminar volume flow";
//   parameter Real pipe.dpLaminar(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 0.1) "Laminar pressure drop";
//   parameter Real pipe.V_flowNominal(quantity = "VolumeFlowRate", unit = "m3/s", start = 1.0) "Nominal volume flow";
//   parameter Real pipe.dpNominal(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 1.0) "Nominal pressure drop";
//   parameter Real pipe.frictionLoss(min = 0.0, max = 1.0) = 0.0 "Part of friction losses fed to medium";
//   Real pipe.pressureDrop(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real pipe.volumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
//   Real pipe.Q_friction(quantity = "Power", unit = "W");
//   protected parameter Real pipe.dpNomMin(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = pipe.dpLaminar * pipe.V_flowNominal / pipe.V_flowLaminar;
//   protected parameter Real pipe.k(unit = "Pa.s2/m6", fixed = false);
//   parameter Real pipe.h_g(quantity = "Length", unit = "m", start = 0.0) "Geodetic height (heigth difference from flowPort_a to flowPort_b)";
//   Real pipe.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
//   Real pipe.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
//   parameter Real ambient2.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real ambient2.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real ambient2.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real ambient2.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real ambient2.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   output Real ambient2.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Outlet temperature of medium";
//   output Real ambient2.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = ambient2.flowPort.h / ambient2.medium.cp "Temperature at flowPort_a";
//   protected Real ambient2.h(quantity = "SpecificEnergy", unit = "J/kg") = ambient2.medium.cp * ambient2.T;
//   parameter Real ambient2.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "Density";
//   parameter Real ambient2.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant pressure";
//   parameter Real ambient2.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "Specific heat capacity at constant volume";
//   parameter Real ambient2.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "Thermal conductivity";
//   parameter Real ambient2.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
//   Real ambient2.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
//   Real ambient2.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
//   Real ambient2.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
//   Real ambient2.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
//   parameter Boolean ambient2.usePressureInput = false "enable / disable pressure input";
//   parameter Real ambient2.constantAmbientPressure(quantity = "Pressure", unit = "Pa", displayUnit = "bar", start = 0.0) "Ambient pressure";
//   parameter Boolean ambient2.useTemperatureInput = false "enable / disable temperature input";
//   parameter Real ambient2.constantAmbientTemperature(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) = TAmb "Ambient temperature";
//   output Real ambient2.constPressure.y "Connector of Real output signal";
//   parameter Real ambient2.constPressure.k(start = 1.0) = ambient2.constantAmbientPressure "Constant output value";
//   protected input Real ambient2.pAmbient;
//   output Real ambient2.constTemperature.y "Connector of Real output signal";
//   parameter Real ambient2.constTemperature.k(start = 1.0) = ambient2.constantAmbientTemperature "Constant output value";
//   protected input Real ambient2.TAmbient;
//   parameter Real heatCapacitor.C(quantity = "HeatCapacity", unit = "J/K") = 0.1 "Heat capacity of element (= cp*m)";
//   Real heatCapacitor.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = TAmb) "Temperature of element";
//   Real heatCapacitor.der_T(quantity = "TemperatureSlope", unit = "K/s", start = 0.0) "Time derivative of temperature (= der(T))";
//   Real heatCapacitor.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
//   Real heatCapacitor.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
//   parameter Real prescribedHeatFlow.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
//   parameter Real prescribedHeatFlow.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of heat flow rate";
//   input Real prescribedHeatFlow.Q_flow;
//   Real prescribedHeatFlow.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
//   Real prescribedHeatFlow.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
//   output Real heatFlow.y "Connector of Real output signal";
//   parameter Real heatFlow.k(start = 1.0) = 10.0 "Constant output value";
//   Real convection.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from solid -> fluid";
//   Real convection.dT(quantity = "ThermodynamicTemperature", unit = "K") "= solid.T - fluid.T";
//   input Real convection.Gc "Signal representing the convective thermal conductance in [W/K]";
//   Real convection.solid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
//   Real convection.solid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
//   Real convection.fluid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
//   Real convection.fluid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
//   output Real thermalConductance.y "Connector of Real output signal";
//   parameter Real thermalConductance.k(start = 1.0) = 1.0 "Constant output value";
//   parameter Boolean speed.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
//   Real speed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real speed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   protected Real speed.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
//   parameter Boolean speed.exact = true "true/false exact treatment/filtering the input signal";
//   parameter Real speed.f_crit(quantity = "Frequency", unit = "Hz") = 50.0 "if exact=false, critical frequency of filter to filter input signal";
//   Real speed.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) "Rotation angle of flange with respect to support";
//   Real speed.w(quantity = "AngularVelocity", unit = "rad/s", StateSelect = StateSelect.default) "Angular velocity of flange with respect to support";
//   Real speed.a(quantity = "AngularAcceleration", unit = "rad/s2") "If exact=false, angular acceleration of flange with respect to support else dummy";
//   input Real speed.w_ref "Reference angular velocity of flange with respect to support as input signal";
//   protected parameter Real speed.w_crit(quantity = "AngularFrequency", unit = "rad/s") = 6.28318530717959 * speed.f_crit "Critical frequency";
//   output Real speedRamp.y "Connector of Real output signal";
//   parameter Real speedRamp.height = 0.5 "Height of ramps";
//   parameter Real speedRamp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = 0.1 "Durations of ramp";
//   parameter Real speedRamp.offset = 0.5 "Offset of output signal";
//   parameter Real speedRamp.startTime(quantity = "Time", unit = "s") = 0.4 "Output = offset for time < startTime";
//   output Real valveRamp.y "Connector of Real output signal";
//   parameter Real valveRamp.height = 0.5 "Height of ramps";
//   parameter Real valveRamp.duration(quantity = "Time", unit = "s", min = 1e-60, start = 2.0) = 0.1 "Durations of ramp";
//   parameter Real valveRamp.offset = 0.5 "Offset of output signal";
//   parameter Real valveRamp.startTime(quantity = "Time", unit = "s") = 0.9 "Output = offset for time < startTime";
// initial algorithm
//   assert(valve.y1 > 1e-60, "Valve characteristic: y1 has to be > 0 !");
//   assert(valve.Kv1 > 1e-15, "Valve characteristic: Kv1 has to be > 0 !");
//   assert(valve.kv0 > 1e-60, "Valve characteristic: kv0 has to be > 0 !");
//   assert(valve.kv0 < 0.999999999999999, "Valve characteristic: kv0 has to be < 1 !");
//   assert(pipe.V_flowNominal > pipe.V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//   assert(pipe.dpNominal >= pipe.dpNomMin, "SimpleFriction: dpNominal has to be > dpLaminar/V_flowLaminar*V_flowNominal!");
//   pipe.k := (pipe.dpNominal - pipe.dpNomMin) * (pipe.V_flowNominal - pipe.V_flowLaminar) ^ -2.0;
// equation
//   ambient1.constPressure.y = ambient1.constPressure.k;
//   ambient1.constTemperature.y = ambient1.constTemperature.k;
//   ambient1.flowPort.p = ambient1.pAmbient;
//   ambient1.T = ambient1.TAmbient;
//   ambient1.flowPort.H_flow = semiLinear(ambient1.flowPort.m_flow,ambient1.flowPort.h,ambient1.h);
//   ambient1.constTemperature.y = ambient1.TAmbient;
//   ambient1.constPressure.y = ambient1.pAmbient;
//   idealPump.dp1 = idealPump.dp0 * (sign(idealPump.w / idealPump.wNominal) * (idealPump.w / idealPump.wNominal) ^ 2.0);
//   idealPump.V_flow1 = idealPump.V_flow0 * idealPump.w / idealPump.wNominal;
//   if noEvent(abs(idealPump.w) < 1e-60) then
//   idealPump.dp = 0.0;
//   idealPump.flange_a.tau = 0.0;
//   else
//   idealPump.dp = (-idealPump.dp1) * (1.0 - abs(idealPump.V_flow / idealPump.V_flow1));
//   idealPump.flange_a.tau * idealPump.w = (-idealPump.dp) * idealPump.V_flow;
//   end if;
//   idealPump.Q_flow = 0.0;
//   idealPump.flowPort_a.m_flow + idealPump.flowPort_b.m_flow = 0.0;
//   idealPump.flowPort_a.H_flow + (idealPump.flowPort_b.H_flow + idealPump.Q_flow) = 0.0;
//   idealPump.flowPort_a.H_flow = semiLinear(idealPump.flowPort_a.m_flow,idealPump.flowPort_a.h,idealPump.h);
//   idealPump.flowPort_b.H_flow = semiLinear(idealPump.flowPort_b.m_flow,idealPump.flowPort_b.h,idealPump.h);
//   valve.Kv / valve.Kv1 = if valve.LinearCharacteristic then valve.kv0 + (1.0 - valve.kv0) * valve.yLim / valve.y1 else valve.kv0 * exp((Modelica.Math.log(1.0 / valve.kv0) * valve.yLim) / valve.y1);
//   valve.dp / valve.dp0 = valve.medium.rho * (valve.V_flow * (abs(valve.V_flow / valve.Kv) * 1.0 / valve.Kv / valve.rho0));
//   valve.Q_flow = valve.frictionLoss * (valve.V_flow * valve.dp);
//   valve.flowPort_a.m_flow + valve.flowPort_b.m_flow = 0.0;
//   valve.flowPort_a.H_flow + (valve.flowPort_b.H_flow + valve.Q_flow) = 0.0;
//   valve.flowPort_a.H_flow = semiLinear(valve.flowPort_a.m_flow,valve.flowPort_a.h,valve.h);
//   valve.flowPort_b.H_flow = semiLinear(valve.flowPort_b.m_flow,valve.flowPort_b.h,valve.h);
//   pipe.volumeFlow = pipe.V_flow;
//   pipe.dp = pipe.pressureDrop + 9.80665 * (pipe.medium.rho * pipe.h_g);
//   pipe.Q_flow = pipe.heatPort.Q_flow + pipe.Q_friction;
//   pipe.heatPort.T = pipe.T_q;
//   pipe.flowPort_b.H_flow = semiLinear(pipe.flowPort_b.m_flow,pipe.flowPort_b.h,pipe.h);
//   pipe.flowPort_a.H_flow = semiLinear(pipe.flowPort_a.m_flow,pipe.flowPort_a.h,pipe.h);
//   pipe.flowPort_a.H_flow + (pipe.flowPort_b.H_flow + pipe.Q_flow) = pipe.m * (pipe.medium.cv * der(pipe.T));
//   pipe.flowPort_a.m_flow + pipe.flowPort_b.m_flow = 0.0;
//   if pipe.volumeFlow > pipe.V_flowLaminar then
//   pipe.pressureDrop = pipe.dpLaminar * pipe.volumeFlow / pipe.V_flowLaminar + pipe.k * (pipe.volumeFlow - pipe.V_flowLaminar) ^ 2.0;
//   elseif pipe.volumeFlow < -pipe.V_flowLaminar then
//   pipe.pressureDrop = pipe.dpLaminar * pipe.volumeFlow / pipe.V_flowLaminar - pipe.k * (pipe.volumeFlow + pipe.V_flowLaminar) ^ 2.0;
//   else
//   pipe.pressureDrop = pipe.dpLaminar * pipe.volumeFlow / pipe.V_flowLaminar;
//   end if;
//   pipe.Q_friction = pipe.frictionLoss * (pipe.volumeFlow * pipe.pressureDrop);
//   ambient2.constPressure.y = ambient2.constPressure.k;
//   ambient2.constTemperature.y = ambient2.constTemperature.k;
//   ambient2.flowPort.p = ambient2.pAmbient;
//   ambient2.T = ambient2.TAmbient;
//   ambient2.flowPort.H_flow = semiLinear(ambient2.flowPort.m_flow,ambient2.flowPort.h,ambient2.h);
//   ambient2.constTemperature.y = ambient2.TAmbient;
//   ambient2.constPressure.y = ambient2.pAmbient;
//   heatCapacitor.T = heatCapacitor.port.T;
//   heatCapacitor.der_T = der(heatCapacitor.T);
//   heatCapacitor.C * der(heatCapacitor.T) = heatCapacitor.port.Q_flow;
//   prescribedHeatFlow.port.Q_flow = (-prescribedHeatFlow.Q_flow) * (1.0 + prescribedHeatFlow.alpha * (prescribedHeatFlow.port.T - prescribedHeatFlow.T_ref));
//   heatFlow.y = heatFlow.k;
//   convection.dT = convection.solid.T - convection.fluid.T;
//   convection.solid.Q_flow = convection.Q_flow;
//   convection.fluid.Q_flow = -convection.Q_flow;
//   convection.Q_flow = convection.Gc * convection.dT;
//   thermalConductance.y = thermalConductance.k;
//   speed.phi = speed.flange.phi - speed.phi_support;
//   speed.w = der(speed.phi);
//   speed.w = speed.w_ref;
//   speed.a = 0.0;
//   speed.phi_support = 0.0;
//   speedRamp.y = speedRamp.offset + (if time < speedRamp.startTime then 0.0 else if time < speedRamp.startTime + speedRamp.duration then ((time - speedRamp.startTime) * speedRamp.height) / speedRamp.duration else speedRamp.height);
//   valveRamp.y = valveRamp.offset + (if time < valveRamp.startTime then 0.0 else if time < valveRamp.startTime + valveRamp.duration then ((time - valveRamp.startTime) * valveRamp.height) / valveRamp.duration else valveRamp.height);
//   assert(pipe.flowPort_b.medium.rho == ambient2.flowPort.medium.rho,"automatically generated from connect");
//   assert(pipe.flowPort_b.medium.cp == ambient2.flowPort.medium.cp,"automatically generated from connect");
//   assert(pipe.flowPort_b.medium.cv == ambient2.flowPort.medium.cv,"automatically generated from connect");
//   assert(pipe.flowPort_b.medium.lamda == ambient2.flowPort.medium.lamda,"automatically generated from connect");
//   assert(pipe.flowPort_b.medium.nue == ambient2.flowPort.medium.nue,"automatically generated from connect");
//   assert(ambient1.flowPort.medium.rho == idealPump.flowPort_a.medium.rho,"automatically generated from connect");
//   assert(ambient1.flowPort.medium.cp == idealPump.flowPort_a.medium.cp,"automatically generated from connect");
//   assert(ambient1.flowPort.medium.cv == idealPump.flowPort_a.medium.cv,"automatically generated from connect");
//   assert(ambient1.flowPort.medium.lamda == idealPump.flowPort_a.medium.lamda,"automatically generated from connect");
//   assert(ambient1.flowPort.medium.nue == idealPump.flowPort_a.medium.nue,"automatically generated from connect");
//   assert(idealPump.flowPort_b.medium.rho == valve.flowPort_a.medium.rho,"automatically generated from connect");
//   assert(idealPump.flowPort_b.medium.cp == valve.flowPort_a.medium.cp,"automatically generated from connect");
//   assert(idealPump.flowPort_b.medium.cv == valve.flowPort_a.medium.cv,"automatically generated from connect");
//   assert(idealPump.flowPort_b.medium.lamda == valve.flowPort_a.medium.lamda,"automatically generated from connect");
//   assert(idealPump.flowPort_b.medium.nue == valve.flowPort_a.medium.nue,"automatically generated from connect");
//   assert(valve.flowPort_b.medium.rho == pipe.flowPort_a.medium.rho,"automatically generated from connect");
//   assert(valve.flowPort_b.medium.cp == pipe.flowPort_a.medium.cp,"automatically generated from connect");
//   assert(valve.flowPort_b.medium.cv == pipe.flowPort_a.medium.cv,"automatically generated from connect");
//   assert(valve.flowPort_b.medium.lamda == pipe.flowPort_a.medium.lamda,"automatically generated from connect");
//   assert(valve.flowPort_b.medium.nue == pipe.flowPort_a.medium.nue,"automatically generated from connect");
//   speed.flange.tau + idealPump.flange_a.tau = 0.0;
//   speed.flange.phi = idealPump.flange_a.phi;
//   valveRamp.y = valve.y;
//   speedRamp.y = speed.w_ref;
//   valve.flowPort_b.H_flow + pipe.flowPort_a.H_flow = 0.0;
//   valve.flowPort_b.h = pipe.flowPort_a.h;
//   valve.flowPort_b.m_flow + pipe.flowPort_a.m_flow = 0.0;
//   valve.flowPort_b.p = pipe.flowPort_a.p;
//   idealPump.flowPort_b.H_flow + valve.flowPort_a.H_flow = 0.0;
//   idealPump.flowPort_b.h = valve.flowPort_a.h;
//   idealPump.flowPort_b.m_flow + valve.flowPort_a.m_flow = 0.0;
//   idealPump.flowPort_b.p = valve.flowPort_a.p;
//   ambient1.flowPort.H_flow + idealPump.flowPort_a.H_flow = 0.0;
//   ambient1.flowPort.h = idealPump.flowPort_a.h;
//   ambient1.flowPort.m_flow + idealPump.flowPort_a.m_flow = 0.0;
//   ambient1.flowPort.p = idealPump.flowPort_a.p;
//   thermalConductance.y = convection.Gc;
//   pipe.heatPort.Q_flow + convection.fluid.Q_flow = 0.0;
//   pipe.heatPort.T = convection.fluid.T;
//   convection.solid.Q_flow + (prescribedHeatFlow.port.Q_flow + heatCapacitor.port.Q_flow) = 0.0;
//   convection.solid.T = prescribedHeatFlow.port.T;
//   prescribedHeatFlow.port.T = heatCapacitor.port.T;
//   heatFlow.y = prescribedHeatFlow.Q_flow;
//   pipe.flowPort_b.H_flow + ambient2.flowPort.H_flow = 0.0;
//   pipe.flowPort_b.h = ambient2.flowPort.h;
//   pipe.flowPort_b.m_flow + ambient2.flowPort.m_flow = 0.0;
//   pipe.flowPort_b.p = ambient2.flowPort.p;
// end Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve;
// "
// ""
// "Check of Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve completed successfully.
// 
// Error: The language feature initial algorithm is not supported. Suggested workaround: rewrite initial algorithms to initial equations
// 
// Class Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve has 114 equation(s) and 114 variable(s).
// 53 of these are trivial equation(s).
// "
// ""
// endResult
