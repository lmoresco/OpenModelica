//name:        Modelica.Electrical.Digital [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Electrical.Digital
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate/check model example
//

loadModel(Modelica); getErrorString();
getErrorString(); 

instantiateModel(Modelica.Electrical.Digital.Examples.Multiplexer); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Multiplexer); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.FlipFlop); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.FlipFlop); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.HalfAdder); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.HalfAdder); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.FullAdder); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.FullAdder); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Adder4); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Adder4); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Counter3); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Counter3); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Counter); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Counter); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.MUX4); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.MUX4); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.RS); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.RS); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.RSFF); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.RSFF); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.DFF); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.DFF); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.JKFF); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.JKFF); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.HalfAdder); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.HalfAdder); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.FullAdder); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.FullAdder); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.Adder); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.Adder); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.Counter3); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.Counter3); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Examples.Utilities.Counter); getErrorString();
checkModel(Modelica.Electrical.Digital.Examples.Utilities.Counter); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Delay.TransportDelay); getErrorString();
checkModel(Modelica.Electrical.Digital.Delay.TransportDelay); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Delay.InertialDelay); getErrorString();
checkModel(Modelica.Electrical.Digital.Delay.InertialDelay); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Delay.InertialDelaySensitive); getErrorString();
checkModel(Modelica.Electrical.Digital.Delay.InertialDelaySensitive); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Not); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Not); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.And); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.And); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Nand); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Nand); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Or); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Or); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Nor); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Nor); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Xor); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Xor); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Basic.Xnor); getErrorString();
checkModel(Modelica.Electrical.Digital.Basic.Xnor); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.InvGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.InvGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.AndGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.AndGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.NandGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.NandGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.OrGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.OrGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.NorGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.NorGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.XorGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.XorGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.XnorGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.XnorGate); getErrorString();

instantiateModel(Modelica.Electrical.Digital.Gates.BufGate); getErrorString();
checkModel(Modelica.Electrical.Digital.Gates.BufGate); getErrorString();

// Result:
// true
// ""
// ""
// "class Modelica.Electrical.Digital.Examples.Multiplexer
//   parameter Real CLK.startTime(quantity = "Time", unit = "s", start = 0.0) "Output = offset for time < startTime";
//   parameter Real CLK.period(quantity = "Time", unit = "s", min = 1e-60, start = 1.0) = 20.0 "Time for one period";
//   parameter Real CLK.width(min = 1e-60, max = 100.0, start = 50.0) "Width of pulses in % of period";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') CLK.y "Connector of Digital output signal";
//   protected Real CLK.t_i(quantity = "Time", unit = "s", start = CLK.startTime) "Start time of current period";
//   protected Real CLK.t_width(quantity = "Time", unit = "s") = CLK.period * CLK.width / 100.0;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real D0.t[1] = 50.0 "vector of corresponding time points";
//   parameter Real D0.t[2] = 100.0 "vector of corresponding time points";
//   parameter Real D0.t[3] = 145.0 "vector of corresponding time points";
//   parameter Real D0.t[4] = 200.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer D0.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D0.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real D1.t[1] = 22.0 "vector of corresponding time points";
//   parameter Real D1.t[2] = 140.0 "vector of corresponding time points";
//   parameter Real D1.t[3] = 150.0 "vector of corresponding time points";
//   parameter Real D1.t[4] = 180.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer D1.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D1.y;
//   parameter Real MUX.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.d0;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.d1;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.d2;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.d3;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.a0;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.a1;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.d;
//   parameter Integer MUX.Or1.n(min = 2) = 4 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.x[3] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.x[4] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Or1.auxiliary[4](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer MUX.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer MUX.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer MUX.And3.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And3.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer MUX.And4.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.And4.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not2.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') MUX.Not2.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real D2.t[1] = 22.0 "vector of corresponding time points";
//   parameter Real D2.t[2] = 140.0 "vector of corresponding time points";
//   parameter Real D2.t[3] = 150.0 "vector of corresponding time points";
//   parameter Real D2.t[4] = 180.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer D2.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D2.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real D3.t[1] = 22.0 "vector of corresponding time points";
//   parameter Real D3.t[2] = 140.0 "vector of corresponding time points";
//   parameter Real D3.t[3] = 150.0 "vector of corresponding time points";
//   parameter Real D3.t[4] = 180.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer D3.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') D3.y;
//   parameter Real FF.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.k;
//   parameter Real FF.RS1.delayTime(quantity = "Time", unit = "s") = FF.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.q0 = FF.q0 "initial value of output";
//   parameter Integer FF.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.y0 = FF.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.x_delayed;
//   parameter Real FF.RS2.delayTime(quantity = "Time", unit = "s") = FF.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.q0 = FF.q0 "initial value of output";
//   parameter Integer FF.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.y0 = FF.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.x_delayed;
//   parameter Integer FF.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'1') "Logic value to be set";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.y;
// equation
//   MUX.Or1.auxiliary[1] = MUX.Or1.x[1];
//   MUX.Or1.auxiliary[2] = D.Tables.OrTable[MUX.Or1.auxiliary[1],MUX.Or1.x[2]];
//   MUX.Or1.auxiliary[3] = D.Tables.OrTable[MUX.Or1.auxiliary[2],MUX.Or1.x[3]];
//   MUX.Or1.auxiliary[4] = D.Tables.OrTable[MUX.Or1.auxiliary[3],MUX.Or1.x[4]];
//   MUX.Or1.y = pre(MUX.Or1.auxiliary[4]);
//   MUX.And1.auxiliary[1] = MUX.And1.x[1];
//   MUX.And1.auxiliary[2] = D.Tables.AndTable[MUX.And1.auxiliary[1],MUX.And1.x[2]];
//   MUX.And1.auxiliary[3] = D.Tables.AndTable[MUX.And1.auxiliary[2],MUX.And1.x[3]];
//   MUX.And1.y = pre(MUX.And1.auxiliary[3]);
//   MUX.And2.auxiliary[1] = MUX.And2.x[1];
//   MUX.And2.auxiliary[2] = D.Tables.AndTable[MUX.And2.auxiliary[1],MUX.And2.x[2]];
//   MUX.And2.auxiliary[3] = D.Tables.AndTable[MUX.And2.auxiliary[2],MUX.And2.x[3]];
//   MUX.And2.y = pre(MUX.And2.auxiliary[3]);
//   MUX.And3.auxiliary[1] = MUX.And3.x[1];
//   MUX.And3.auxiliary[2] = D.Tables.AndTable[MUX.And3.auxiliary[1],MUX.And3.x[2]];
//   MUX.And3.auxiliary[3] = D.Tables.AndTable[MUX.And3.auxiliary[2],MUX.And3.x[3]];
//   MUX.And3.y = pre(MUX.And3.auxiliary[3]);
//   MUX.And4.auxiliary[1] = MUX.And4.x[1];
//   MUX.And4.auxiliary[2] = D.Tables.AndTable[MUX.And4.auxiliary[1],MUX.And4.x[2]];
//   MUX.And4.auxiliary[3] = D.Tables.AndTable[MUX.And4.auxiliary[2],MUX.And4.x[3]];
//   MUX.And4.y = pre(MUX.And4.auxiliary[3]);
//   MUX.Not1.auxiliary = D.Tables.NotTable[MUX.Not1.x];
//   MUX.Not1.y = pre(MUX.Not1.auxiliary);
//   MUX.Not2.auxiliary = D.Tables.NotTable[MUX.Not2.x];
//   MUX.Not2.y = pre(MUX.Not2.auxiliary);
//   FF.RS1.Nor1.auxiliary[1] = FF.RS1.Nor1.x[1];
//   FF.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF.RS1.Nor1.auxiliary[1],FF.RS1.Nor1.x[2]];
//   FF.RS1.Nor1.y = pre(D.Tables.NotTable[FF.RS1.Nor1.auxiliary[2]]);
//   FF.RS1.Nor2.auxiliary[1] = FF.RS1.Nor2.x[1];
//   FF.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF.RS1.Nor2.auxiliary[1],FF.RS1.Nor2.x[2]];
//   FF.RS1.Nor2.y = pre(D.Tables.NotTable[FF.RS1.Nor2.auxiliary[2]]);
//   FF.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF.RS1.TD1.x),FF.RS1.TD1.delayTime,FF.RS1.TD1.delayTime)));
//   FF.RS1.TD1.y = if FF.RS1.TD1.delayTime > 0.0 then if time >= FF.RS1.TD1.delayTime then FF.RS1.TD1.x_delayed else FF.RS1.TD1.y0 else pre(FF.RS1.TD1.x);
//   FF.RS2.Nor1.auxiliary[1] = FF.RS2.Nor1.x[1];
//   FF.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF.RS2.Nor1.auxiliary[1],FF.RS2.Nor1.x[2]];
//   FF.RS2.Nor1.y = pre(D.Tables.NotTable[FF.RS2.Nor1.auxiliary[2]]);
//   FF.RS2.Nor2.auxiliary[1] = FF.RS2.Nor2.x[1];
//   FF.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF.RS2.Nor2.auxiliary[1],FF.RS2.Nor2.x[2]];
//   FF.RS2.Nor2.y = pre(D.Tables.NotTable[FF.RS2.Nor2.auxiliary[2]]);
//   FF.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF.RS2.TD1.x),FF.RS2.TD1.delayTime,FF.RS2.TD1.delayTime)));
//   FF.RS2.TD1.y = if FF.RS2.TD1.delayTime > 0.0 then if time >= FF.RS2.TD1.delayTime then FF.RS2.TD1.x_delayed else FF.RS2.TD1.y0 else pre(FF.RS2.TD1.x);
//   FF.And1.auxiliary[1] = FF.And1.x[1];
//   FF.And1.auxiliary[2] = D.Tables.AndTable[FF.And1.auxiliary[1],FF.And1.x[2]];
//   FF.And1.auxiliary[3] = D.Tables.AndTable[FF.And1.auxiliary[2],FF.And1.x[3]];
//   FF.And1.y = pre(FF.And1.auxiliary[3]);
//   FF.And2.auxiliary[1] = FF.And2.x[1];
//   FF.And2.auxiliary[2] = D.Tables.AndTable[FF.And2.auxiliary[1],FF.And2.x[2]];
//   FF.And2.auxiliary[3] = D.Tables.AndTable[FF.And2.auxiliary[2],FF.And2.x[3]];
//   FF.And2.y = pre(FF.And2.auxiliary[3]);
//   FF.And3.auxiliary[1] = FF.And3.x[1];
//   FF.And3.auxiliary[2] = D.Tables.AndTable[FF.And3.auxiliary[1],FF.And3.x[2]];
//   FF.And3.y = pre(FF.And3.auxiliary[2]);
//   FF.And4.auxiliary[1] = FF.And4.x[1];
//   FF.And4.auxiliary[2] = D.Tables.AndTable[FF.And4.auxiliary[1],FF.And4.x[2]];
//   FF.And4.y = pre(FF.And4.auxiliary[2]);
//   FF.Not1.auxiliary = D.Tables.NotTable[FF.Not1.x];
//   FF.Not1.y = pre(FF.Not1.auxiliary);
//   FF.And1.x[3] = FF.RS1.Nor1.y;
//   FF.And1.x[3] = FF.RS1.TD1.x;
//   FF.And1.x[3] = FF.RS1.qn;
//   FF.And1.x[3] = FF.q;
//   FF.And1.x[3] = MUX.And3.x[1];
//   FF.And1.x[3] = MUX.And4.x[1];
//   FF.And1.x[3] = MUX.Not2.x;
//   FF.And1.x[3] = MUX.a1;
//   D3.y = MUX.And4.x[2];
//   D3.y = MUX.d3;
//   D2.y = MUX.And3.x[2];
//   D2.y = MUX.d2;
//   D1.y = MUX.And2.x[2];
//   D1.y = MUX.d1;
//   D0.y = MUX.And1.x[2];
//   D0.y = MUX.d0;
//   CLK.y = FF.And1.x[1];
//   CLK.y = FF.And2.x[3];
//   CLK.y = FF.Not1.x;
//   CLK.y = FF.clk;
//   CLK.y = MUX.And2.x[3];
//   CLK.y = MUX.And4.x[3];
//   CLK.y = MUX.Not1.x;
//   CLK.y = MUX.a0;
//   Enable.y = FF.And1.x[2];
//   Enable.y = FF.And2.x[2];
//   Enable.y = FF.j;
//   Enable.y = FF.k;
//   FF.And2.x[1] = FF.RS1.Nor1.x[1];
//   FF.And2.x[1] = FF.RS1.Nor2.y;
//   FF.And2.x[1] = FF.RS1.q;
//   FF.And2.x[1] = FF.qn;
//   FF.And3.x[1] = FF.And4.x[1];
//   FF.And3.x[1] = FF.Not1.y;
//   FF.And3.x[2] = FF.RS2.Nor1.x[1];
//   FF.And3.x[2] = FF.RS2.Nor2.y;
//   FF.And3.x[2] = FF.RS2.q;
//   FF.And4.x[2] = FF.RS2.Nor1.y;
//   FF.And4.x[2] = FF.RS2.TD1.x;
//   FF.And4.x[2] = FF.RS2.qn;
//   FF.And3.y = FF.RS1.Nor1.x[2];
//   FF.And3.y = FF.RS1.s;
//   FF.And4.y = FF.RS1.Nor2.x[1];
//   FF.And4.y = FF.RS1.r;
//   FF.And1.y = FF.RS2.Nor1.x[2];
//   FF.And1.y = FF.RS2.s;
//   FF.And2.y = FF.RS2.Nor2.x[1];
//   FF.And2.y = FF.RS2.r;
//   FF.RS2.Nor2.x[2] = FF.RS2.TD1.y;
//   FF.RS1.Nor2.x[2] = FF.RS1.TD1.y;
//   MUX.And1.x[1] = MUX.And2.x[1];
//   MUX.And1.x[1] = MUX.Not2.y;
//   MUX.And1.x[3] = MUX.And3.x[3];
//   MUX.And1.x[3] = MUX.Not1.y;
//   MUX.Or1.y = MUX.d;
//   MUX.And1.y = MUX.Or1.x[4];
//   MUX.And2.y = MUX.Or1.x[3];
//   MUX.And3.y = MUX.Or1.x[2];
//   MUX.And4.y = MUX.Or1.x[1];
// algorithm
//   when sample(CLK.startTime,CLK.period) then
//     CLK.t_i := time;
//   end when;
//   CLK.y := if  NOT time >= CLK.startTime OR time >= CLK.t_i + CLK.t_width then Modelica.Electrical.Digital.Interfaces.Logic.'0' else Modelica.Electrical.Digital.Interfaces.Logic.'1';
//   if initial() then
//     assert(D0.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:D0.n loop
//     end for;
//   end if;
//   D0.y := D0.y0;
//   for i in 1:D0.n loop
//     if time >= D0.t[i] then
//       D0.y := D0.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(D1.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:D1.n loop
//     end for;
//   end if;
//   D1.y := D1.y0;
//   for i in 1:D1.n loop
//     if time >= D1.t[i] then
//       D1.y := D1.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(D2.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:D2.n loop
//     end for;
//   end if;
//   D2.y := D2.y0;
//   for i in 1:D2.n loop
//     if time >= D2.t[i] then
//       D2.y := D2.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(D3.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:D3.n loop
//     end for;
//   end if;
//   D3.y := D3.y0;
//   for i in 1:D3.n loop
//     if time >= D3.t[i] then
//       D3.y := D3.x[i];
//     end if;
//   end for;
//   Enable.y := Enable.x;
// end Modelica.Electrical.Digital.Examples.Multiplexer;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Multiplexer completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Multiplexer has 124 equation(s) and 124 variable(s).
// 116 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.FlipFlop
//   parameter Real FF.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.k;
//   parameter Real FF.RS1.delayTime(quantity = "Time", unit = "s") = FF.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.q0 = FF.q0 "initial value of output";
//   parameter Integer FF.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.y0 = FF.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS1.TD1.x_delayed;
//   parameter Real FF.RS2.delayTime(quantity = "Time", unit = "s") = FF.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.q0 = FF.q0 "initial value of output";
//   parameter Integer FF.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.y0 = FF.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.RS2.TD1.x_delayed;
//   parameter Integer FF.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real CLK.startTime(quantity = "Time", unit = "s", start = 0.0) "Output = offset for time < startTime";
//   parameter Real CLK.period(quantity = "Time", unit = "s", min = 1e-60, start = 1.0) = 10.0 "Time for one period";
//   parameter Real CLK.width(min = 1e-60, max = 100.0, start = 50.0) "Width of pulses in % of period";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') CLK.y "Connector of Digital output signal";
//   protected Real CLK.t_i(quantity = "Time", unit = "s", start = CLK.startTime) "Start time of current period";
//   protected Real CLK.t_width(quantity = "Time", unit = "s") = CLK.period * CLK.width / 100.0;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real J.t[1] = 50.0 "vector of corresponding time points";
//   parameter Real J.t[2] = 100.0 "vector of corresponding time points";
//   parameter Real J.t[3] = 145.0 "vector of corresponding time points";
//   parameter Real J.t[4] = 200.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer J.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') J.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real K.t[1] = 22.0 "vector of corresponding time points";
//   parameter Real K.t[2] = 140.0 "vector of corresponding time points";
//   parameter Real K.t[3] = 150.0 "vector of corresponding time points";
//   parameter Real K.t[4] = 180.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer K.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') K.y;
// equation
//   FF.RS1.Nor1.auxiliary[1] = FF.RS1.Nor1.x[1];
//   FF.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF.RS1.Nor1.auxiliary[1],FF.RS1.Nor1.x[2]];
//   FF.RS1.Nor1.y = pre(D.Tables.NotTable[FF.RS1.Nor1.auxiliary[2]]);
//   FF.RS1.Nor2.auxiliary[1] = FF.RS1.Nor2.x[1];
//   FF.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF.RS1.Nor2.auxiliary[1],FF.RS1.Nor2.x[2]];
//   FF.RS1.Nor2.y = pre(D.Tables.NotTable[FF.RS1.Nor2.auxiliary[2]]);
//   FF.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF.RS1.TD1.x),FF.RS1.TD1.delayTime,FF.RS1.TD1.delayTime)));
//   FF.RS1.TD1.y = if FF.RS1.TD1.delayTime > 0.0 then if time >= FF.RS1.TD1.delayTime then FF.RS1.TD1.x_delayed else FF.RS1.TD1.y0 else pre(FF.RS1.TD1.x);
//   FF.RS2.Nor1.auxiliary[1] = FF.RS2.Nor1.x[1];
//   FF.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF.RS2.Nor1.auxiliary[1],FF.RS2.Nor1.x[2]];
//   FF.RS2.Nor1.y = pre(D.Tables.NotTable[FF.RS2.Nor1.auxiliary[2]]);
//   FF.RS2.Nor2.auxiliary[1] = FF.RS2.Nor2.x[1];
//   FF.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF.RS2.Nor2.auxiliary[1],FF.RS2.Nor2.x[2]];
//   FF.RS2.Nor2.y = pre(D.Tables.NotTable[FF.RS2.Nor2.auxiliary[2]]);
//   FF.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF.RS2.TD1.x),FF.RS2.TD1.delayTime,FF.RS2.TD1.delayTime)));
//   FF.RS2.TD1.y = if FF.RS2.TD1.delayTime > 0.0 then if time >= FF.RS2.TD1.delayTime then FF.RS2.TD1.x_delayed else FF.RS2.TD1.y0 else pre(FF.RS2.TD1.x);
//   FF.And1.auxiliary[1] = FF.And1.x[1];
//   FF.And1.auxiliary[2] = D.Tables.AndTable[FF.And1.auxiliary[1],FF.And1.x[2]];
//   FF.And1.auxiliary[3] = D.Tables.AndTable[FF.And1.auxiliary[2],FF.And1.x[3]];
//   FF.And1.y = pre(FF.And1.auxiliary[3]);
//   FF.And2.auxiliary[1] = FF.And2.x[1];
//   FF.And2.auxiliary[2] = D.Tables.AndTable[FF.And2.auxiliary[1],FF.And2.x[2]];
//   FF.And2.auxiliary[3] = D.Tables.AndTable[FF.And2.auxiliary[2],FF.And2.x[3]];
//   FF.And2.y = pre(FF.And2.auxiliary[3]);
//   FF.And3.auxiliary[1] = FF.And3.x[1];
//   FF.And3.auxiliary[2] = D.Tables.AndTable[FF.And3.auxiliary[1],FF.And3.x[2]];
//   FF.And3.y = pre(FF.And3.auxiliary[2]);
//   FF.And4.auxiliary[1] = FF.And4.x[1];
//   FF.And4.auxiliary[2] = D.Tables.AndTable[FF.And4.auxiliary[1],FF.And4.x[2]];
//   FF.And4.y = pre(FF.And4.auxiliary[2]);
//   FF.Not1.auxiliary = D.Tables.NotTable[FF.Not1.x];
//   FF.Not1.y = pre(FF.Not1.auxiliary);
//   FF.And2.x[2] = FF.k;
//   FF.And2.x[2] = K.y;
//   CLK.y = FF.And1.x[1];
//   CLK.y = FF.And2.x[3];
//   CLK.y = FF.Not1.x;
//   CLK.y = FF.clk;
//   FF.And1.x[2] = FF.j;
//   FF.And1.x[2] = J.y;
//   FF.And2.x[1] = FF.RS1.Nor1.x[1];
//   FF.And2.x[1] = FF.RS1.Nor2.y;
//   FF.And2.x[1] = FF.RS1.q;
//   FF.And2.x[1] = FF.qn;
//   FF.And1.x[3] = FF.RS1.Nor1.y;
//   FF.And1.x[3] = FF.RS1.TD1.x;
//   FF.And1.x[3] = FF.RS1.qn;
//   FF.And1.x[3] = FF.q;
//   FF.And3.x[1] = FF.And4.x[1];
//   FF.And3.x[1] = FF.Not1.y;
//   FF.And3.x[2] = FF.RS2.Nor1.x[1];
//   FF.And3.x[2] = FF.RS2.Nor2.y;
//   FF.And3.x[2] = FF.RS2.q;
//   FF.And4.x[2] = FF.RS2.Nor1.y;
//   FF.And4.x[2] = FF.RS2.TD1.x;
//   FF.And4.x[2] = FF.RS2.qn;
//   FF.And3.y = FF.RS1.Nor1.x[2];
//   FF.And3.y = FF.RS1.s;
//   FF.And4.y = FF.RS1.Nor2.x[1];
//   FF.And4.y = FF.RS1.r;
//   FF.And1.y = FF.RS2.Nor1.x[2];
//   FF.And1.y = FF.RS2.s;
//   FF.And2.y = FF.RS2.Nor2.x[1];
//   FF.And2.y = FF.RS2.r;
//   FF.RS2.Nor2.x[2] = FF.RS2.TD1.y;
//   FF.RS1.Nor2.x[2] = FF.RS1.TD1.y;
// algorithm
//   when sample(CLK.startTime,CLK.period) then
//     CLK.t_i := time;
//   end when;
//   CLK.y := if  NOT time >= CLK.startTime OR time >= CLK.t_i + CLK.t_width then Modelica.Electrical.Digital.Interfaces.Logic.'0' else Modelica.Electrical.Digital.Interfaces.Logic.'1';
//   if initial() then
//     assert(J.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:J.n loop
//     end for;
//   end if;
//   J.y := J.y0;
//   for i in 1:J.n loop
//     if time >= J.t[i] then
//       J.y := J.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(K.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:K.n loop
//     end for;
//   end if;
//   K.y := K.y0;
//   for i in 1:K.n loop
//     if time >= K.t[i] then
//       K.y := K.x[i];
//     end if;
//   end for;
// end Modelica.Electrical.Digital.Examples.FlipFlop;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.FlipFlop completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.FlipFlop has 71 equation(s) and 71 variable(s).
// 66 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.HalfAdder
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.x[4] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real a.t[1] = 1.0 "vector of corresponding time points";
//   parameter Real a.t[2] = 2.0 "vector of corresponding time points";
//   parameter Real a.t[3] = 3.0 "vector of corresponding time points";
//   parameter Real a.t[4] = 4.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer a.n = 4 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real b.t[1] = 2.0 "vector of corresponding time points";
//   parameter Real b.t[2] = 4.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer b.n = 2 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b.y;
//   parameter Real Adder.delayTime = 0.3 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.c;
//   parameter Integer Adder.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.y "Connector of Digital output signal";
//   parameter Real Adder.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder.delayTime "rise inertial delay";
//   parameter Real Adder.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder.AND.G1.n(min = 2) = Adder.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder.AND.tLH "rise inertial delay";
//   parameter Real Adder.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G2.y0 = Adder.AND.y0 "initial value of output";
//   protected Integer Adder.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G2.y_auxiliary(start = Adder.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.AND.G2.x_old(start = Adder.AND.G2.y0, fixed = true);
//   protected Integer Adder.AND.G2.lh;
//   protected discrete Real Adder.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder.delayTime "rise inertial delay";
//   parameter Real Adder.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder.XOR.G1.n(min = 2) = Adder.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder.XOR.tLH "rise inertial delay";
//   parameter Real Adder.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G2.y0 = Adder.XOR.y0 "initial value of output";
//   protected Integer Adder.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G2.y_auxiliary(start = Adder.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder.XOR.G2.x_old(start = Adder.XOR.G2.y0, fixed = true);
//   protected Integer Adder.XOR.G2.lh;
//   protected discrete Real Adder.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s.x[1];
//   output Real s.y[1];
//   parameter Integer s.n(min = 1, start = 1) "signal width";
//   parameter Real s.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real s.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real s.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real s.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real s.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real s.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real s.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real s.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real s.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c.x[1];
//   output Real c.y[1];
//   parameter Integer c.n(min = 1, start = 1) "signal width";
//   parameter Real c.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real c.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real c.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real c.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real c.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real c.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real c.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real c.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real c.value_m(start = 0.5) "value for digital m (Don't care)";
// equation
//   Adder.AND.G1.auxiliary[1] = Adder.AND.G1.x[1];
//   Adder.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder.AND.G1.auxiliary[1],Adder.AND.G1.x[2]];
//   Adder.AND.G1.y = pre(Adder.AND.G1.auxiliary[2]);
//   Adder.XOR.G1.auxiliary[1] = Adder.XOR.G1.x[1];
//   Adder.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder.XOR.G1.auxiliary[1],Adder.XOR.G1.x[2]];
//   Adder.XOR.G1.y = pre(Adder.XOR.G1.auxiliary[2]);
//   s.y[1] = if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then s.value_U else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then s.value_X else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then s.value_0 else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then s.value_1 else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then s.value_Z else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then s.value_W else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then s.value_L else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then s.value_H else s.value_m;
//   c.y[1] = if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then c.value_U else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then c.value_X else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then c.value_0 else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then c.value_1 else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then c.value_Z else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then c.value_W else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then c.value_L else if c.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then c.value_H else c.value_m;
//   Adder.AND.G2.y = Adder.AND.y;
//   Adder.AND.G2.y = Adder.c;
//   Adder.AND.G2.y = c.x[1];
//   Adder.XOR.G2.y = Adder.XOR.y;
//   Adder.XOR.G2.y = Adder.s;
//   Adder.XOR.G2.y = s.x[1];
//   Adder.AND.G1.x[2] = Adder.AND.x[2];
//   Adder.AND.G1.x[2] = Adder.XOR.G1.x[2];
//   Adder.AND.G1.x[2] = Adder.XOR.x[2];
//   Adder.AND.G1.x[2] = Adder.a;
//   Adder.AND.G1.x[2] = a.y;
//   Adder.AND.G1.x[1] = Adder.AND.x[1];
//   Adder.AND.G1.x[1] = Adder.XOR.G1.x[1];
//   Adder.AND.G1.x[1] = Adder.XOR.x[1];
//   Adder.AND.G1.x[1] = Adder.b;
//   Adder.AND.G1.x[1] = b.y;
//   Adder.XOR.G1.y = Adder.XOR.G2.x;
//   Adder.AND.G1.y = Adder.AND.G2.x;
// algorithm
//   if initial() then
//     assert(a.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:a.n loop
//     end for;
//   end if;
//   a.y := a.y0;
//   for i in 1:a.n loop
//     if time >= a.t[i] then
//       a.y := a.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(b.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:b.n loop
//     end for;
//   end if;
//   b.y := b.y0;
//   for i in 1:b.n loop
//     if time >= b.t[i] then
//       b.y := b.x[i];
//     end if;
//   end for;
//   when {initial(),(Adder.AND.G2.tLH > 0.0 OR Adder.AND.G2.tHL > 0.0) AND change(Adder.AND.G2.x) AND  NOT initial()} then
//     Adder.AND.G2.x_old := if initial() OR pre(Adder.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder.AND.G2.y0 else pre(Adder.AND.G2.x);
//     Adder.AND.G2.lh := Adder.AND.G2.delayTable[Adder.AND.G2.x_old, Adder.AND.G2.x];
//     Adder.AND.G2.delayTime := if Adder.AND.G2.lh > 0 then Adder.AND.G2.tLH else if Adder.AND.G2.lh < 0 then Adder.AND.G2.tHL else 0.0;
//     Adder.AND.G2.t_next := time + Adder.AND.G2.delayTime;
//     if Adder.AND.G2.lh == 0 OR abs(Adder.AND.G2.delayTime) < 1e-60 then
//       Adder.AND.G2.y_auxiliary := Adder.AND.G2.x;
//     end if;
//   elsewhen time >= Adder.AND.G2.t_next then
//     Adder.AND.G2.y_auxiliary := Adder.AND.G2.x;
//   end when;
//   Adder.AND.G2.y := if Adder.AND.G2.tLH > 0.0 OR Adder.AND.G2.tHL > 0.0 then Adder.AND.G2.y_auxiliary else Adder.AND.G2.x;
//   when {initial(),(Adder.XOR.G2.tLH > 0.0 OR Adder.XOR.G2.tHL > 0.0) AND change(Adder.XOR.G2.x) AND  NOT initial()} then
//     Adder.XOR.G2.x_old := if initial() OR pre(Adder.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder.XOR.G2.y0 else pre(Adder.XOR.G2.x);
//     Adder.XOR.G2.lh := Adder.XOR.G2.delayTable[Adder.XOR.G2.x_old, Adder.XOR.G2.x];
//     Adder.XOR.G2.delayTime := if Adder.XOR.G2.lh > 0 then Adder.XOR.G2.tLH else if Adder.XOR.G2.lh < 0 then Adder.XOR.G2.tHL else 0.0;
//     Adder.XOR.G2.t_next := time + Adder.XOR.G2.delayTime;
//     if Adder.XOR.G2.lh == 0 OR abs(Adder.XOR.G2.delayTime) < 1e-60 then
//       Adder.XOR.G2.y_auxiliary := Adder.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder.XOR.G2.t_next then
//     Adder.XOR.G2.y_auxiliary := Adder.XOR.G2.x;
//   end when;
//   Adder.XOR.G2.y := if Adder.XOR.G2.tLH > 0.0 OR Adder.XOR.G2.tHL > 0.0 then Adder.XOR.G2.y_auxiliary else Adder.XOR.G2.x;
// end Modelica.Electrical.Digital.Examples.HalfAdder;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.HalfAdder completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.HalfAdder has 202 equation(s) and 202 variable(s).
// 186 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.FullAdder
//   parameter Real Adder1.Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.c;
//   parameter Integer Adder1.Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder2.AND.G1.n(min = 2) = Adder1.Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder1.Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y0 = Adder1.Adder2.AND.y0 "initial value of output";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y_auxiliary(start = Adder1.Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.x_old(start = Adder1.Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder1.Adder2.AND.G2.lh;
//   protected discrete Real Adder1.Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder1.Adder2.XOR.G1.n(min = 2) = Adder1.Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder1.Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y0 = Adder1.Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y_auxiliary(start = Adder1.Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.x_old(start = Adder1.Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder1.Adder2.XOR.G2.lh;
//   protected discrete Real Adder1.Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.c;
//   parameter Integer Adder1.Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder1.AND.G1.n(min = 2) = Adder1.Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder1.Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y0 = Adder1.Adder1.AND.y0 "initial value of output";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y_auxiliary(start = Adder1.Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.x_old(start = Adder1.Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder1.Adder1.AND.G2.lh;
//   protected discrete Real Adder1.Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder1.Adder1.XOR.G1.n(min = 2) = Adder1.Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder1.Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y0 = Adder1.Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y_auxiliary(start = Adder1.Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.x_old(start = Adder1.Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder1.Adder1.XOR.G2.lh;
//   protected discrete Real Adder1.Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.c_out;
//   parameter Integer Adder1.OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s.x[1];
//   output Real s.y[1];
//   parameter Integer s.n(min = 1, start = 1) "signal width";
//   parameter Real s.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real s.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real s.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real s.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real s.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real s.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real s.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real s.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real s.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c_out.x[1];
//   output Real c_out.y[1];
//   parameter Integer c_out.n(min = 1, start = 1) "signal width";
//   parameter Real c_out.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real c_out.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real c_out.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real c_out.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real c_out.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real c_out.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real c_out.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real c_out.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real c_out.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.enable;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q2;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.count;
//   parameter Real Counter.FF1.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.k;
//   parameter Real Counter.FF1.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.q0 = Counter.FF1.q0 "initial value of output";
//   parameter Integer Counter.FF1.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF1.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF1.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.y0 = Counter.FF1.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.x_delayed;
//   parameter Real Counter.FF1.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.q0 = Counter.FF1.q0 "initial value of output";
//   parameter Integer Counter.FF1.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF1.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF1.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.y0 = Counter.FF1.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF1.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF2.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.k;
//   parameter Real Counter.FF2.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.q0 = Counter.FF2.q0 "initial value of output";
//   parameter Integer Counter.FF2.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF2.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF2.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.y0 = Counter.FF2.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.x_delayed;
//   parameter Real Counter.FF2.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.q0 = Counter.FF2.q0 "initial value of output";
//   parameter Integer Counter.FF2.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF2.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF2.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.y0 = Counter.FF2.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF2.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF3.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.k;
//   parameter Real Counter.FF3.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.q0 = Counter.FF3.q0 "initial value of output";
//   parameter Integer Counter.FF3.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF3.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF3.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.y0 = Counter.FF3.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.x_delayed;
//   parameter Real Counter.FF3.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.q0 = Counter.FF3.q0 "initial value of output";
//   parameter Integer Counter.FF3.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF3.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF3.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.y0 = Counter.FF3.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF3.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q1;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q0;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'1') = Modelica.Electrical.Digital.Interfaces.Logic.'1' "Logic value to be set";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.y;
//   parameter Real CLK.startTime(quantity = "Time", unit = "s", start = 0.0) "Output = offset for time < startTime";
//   parameter Real CLK.period(quantity = "Time", unit = "s", min = 1e-60, start = 1.0) "Time for one period";
//   parameter Real CLK.width(min = 1e-60, max = 100.0, start = 50.0) "Width of pulses in % of period";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') CLK.y "Connector of Digital output signal";
//   protected Real CLK.t_i(quantity = "Time", unit = "s", start = CLK.startTime) "Start time of current period";
//   protected Real CLK.t_width(quantity = "Time", unit = "s") = CLK.period * CLK.width / 100.0;
// equation
//   Adder1.Adder2.AND.G1.auxiliary[1] = Adder1.Adder2.AND.G1.x[1];
//   Adder1.Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder1.Adder2.AND.G1.auxiliary[1],Adder1.Adder2.AND.G1.x[2]];
//   Adder1.Adder2.AND.G1.y = pre(Adder1.Adder2.AND.G1.auxiliary[2]);
//   Adder1.Adder2.XOR.G1.auxiliary[1] = Adder1.Adder2.XOR.G1.x[1];
//   Adder1.Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder1.Adder2.XOR.G1.auxiliary[1],Adder1.Adder2.XOR.G1.x[2]];
//   Adder1.Adder2.XOR.G1.y = pre(Adder1.Adder2.XOR.G1.auxiliary[2]);
//   Adder1.Adder1.AND.G1.auxiliary[1] = Adder1.Adder1.AND.G1.x[1];
//   Adder1.Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder1.Adder1.AND.G1.auxiliary[1],Adder1.Adder1.AND.G1.x[2]];
//   Adder1.Adder1.AND.G1.y = pre(Adder1.Adder1.AND.G1.auxiliary[2]);
//   Adder1.Adder1.XOR.G1.auxiliary[1] = Adder1.Adder1.XOR.G1.x[1];
//   Adder1.Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder1.Adder1.XOR.G1.auxiliary[1],Adder1.Adder1.XOR.G1.x[2]];
//   Adder1.Adder1.XOR.G1.y = pre(Adder1.Adder1.XOR.G1.auxiliary[2]);
//   Adder1.OR.auxiliary[1] = Adder1.OR.x[1];
//   Adder1.OR.auxiliary[2] = D.Tables.OrTable[Adder1.OR.auxiliary[1],Adder1.OR.x[2]];
//   Adder1.OR.y = pre(Adder1.OR.auxiliary[2]);
//   s.y[1] = if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then s.value_U else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then s.value_X else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then s.value_0 else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then s.value_1 else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then s.value_Z else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then s.value_W else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then s.value_L else if s.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then s.value_H else s.value_m;
//   c_out.y[1] = if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then c_out.value_U else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then c_out.value_X else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then c_out.value_0 else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then c_out.value_1 else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then c_out.value_Z else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then c_out.value_W else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then c_out.value_L else if c_out.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then c_out.value_H else c_out.value_m;
//   Counter.FF1.RS1.Nor1.auxiliary[1] = Counter.FF1.RS1.Nor1.x[1];
//   Counter.FF1.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS1.Nor1.auxiliary[1],Counter.FF1.RS1.Nor1.x[2]];
//   Counter.FF1.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF1.RS1.Nor1.auxiliary[2]]);
//   Counter.FF1.RS1.Nor2.auxiliary[1] = Counter.FF1.RS1.Nor2.x[1];
//   Counter.FF1.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS1.Nor2.auxiliary[1],Counter.FF1.RS1.Nor2.x[2]];
//   Counter.FF1.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF1.RS1.Nor2.auxiliary[2]]);
//   Counter.FF1.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF1.RS1.TD1.x),Counter.FF1.RS1.TD1.delayTime,Counter.FF1.RS1.TD1.delayTime)));
//   Counter.FF1.RS1.TD1.y = if Counter.FF1.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF1.RS1.TD1.delayTime then Counter.FF1.RS1.TD1.x_delayed else Counter.FF1.RS1.TD1.y0 else pre(Counter.FF1.RS1.TD1.x);
//   Counter.FF1.RS2.Nor1.auxiliary[1] = Counter.FF1.RS2.Nor1.x[1];
//   Counter.FF1.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS2.Nor1.auxiliary[1],Counter.FF1.RS2.Nor1.x[2]];
//   Counter.FF1.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF1.RS2.Nor1.auxiliary[2]]);
//   Counter.FF1.RS2.Nor2.auxiliary[1] = Counter.FF1.RS2.Nor2.x[1];
//   Counter.FF1.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS2.Nor2.auxiliary[1],Counter.FF1.RS2.Nor2.x[2]];
//   Counter.FF1.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF1.RS2.Nor2.auxiliary[2]]);
//   Counter.FF1.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF1.RS2.TD1.x),Counter.FF1.RS2.TD1.delayTime,Counter.FF1.RS2.TD1.delayTime)));
//   Counter.FF1.RS2.TD1.y = if Counter.FF1.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF1.RS2.TD1.delayTime then Counter.FF1.RS2.TD1.x_delayed else Counter.FF1.RS2.TD1.y0 else pre(Counter.FF1.RS2.TD1.x);
//   Counter.FF1.And1.auxiliary[1] = Counter.FF1.And1.x[1];
//   Counter.FF1.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And1.auxiliary[1],Counter.FF1.And1.x[2]];
//   Counter.FF1.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF1.And1.auxiliary[2],Counter.FF1.And1.x[3]];
//   Counter.FF1.And1.y = pre(Counter.FF1.And1.auxiliary[3]);
//   Counter.FF1.And2.auxiliary[1] = Counter.FF1.And2.x[1];
//   Counter.FF1.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And2.auxiliary[1],Counter.FF1.And2.x[2]];
//   Counter.FF1.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF1.And2.auxiliary[2],Counter.FF1.And2.x[3]];
//   Counter.FF1.And2.y = pre(Counter.FF1.And2.auxiliary[3]);
//   Counter.FF1.And3.auxiliary[1] = Counter.FF1.And3.x[1];
//   Counter.FF1.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And3.auxiliary[1],Counter.FF1.And3.x[2]];
//   Counter.FF1.And3.y = pre(Counter.FF1.And3.auxiliary[2]);
//   Counter.FF1.And4.auxiliary[1] = Counter.FF1.And4.x[1];
//   Counter.FF1.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And4.auxiliary[1],Counter.FF1.And4.x[2]];
//   Counter.FF1.And4.y = pre(Counter.FF1.And4.auxiliary[2]);
//   Counter.FF1.Not1.auxiliary = D.Tables.NotTable[Counter.FF1.Not1.x];
//   Counter.FF1.Not1.y = pre(Counter.FF1.Not1.auxiliary);
//   Counter.FF2.RS1.Nor1.auxiliary[1] = Counter.FF2.RS1.Nor1.x[1];
//   Counter.FF2.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS1.Nor1.auxiliary[1],Counter.FF2.RS1.Nor1.x[2]];
//   Counter.FF2.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF2.RS1.Nor1.auxiliary[2]]);
//   Counter.FF2.RS1.Nor2.auxiliary[1] = Counter.FF2.RS1.Nor2.x[1];
//   Counter.FF2.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS1.Nor2.auxiliary[1],Counter.FF2.RS1.Nor2.x[2]];
//   Counter.FF2.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF2.RS1.Nor2.auxiliary[2]]);
//   Counter.FF2.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF2.RS1.TD1.x),Counter.FF2.RS1.TD1.delayTime,Counter.FF2.RS1.TD1.delayTime)));
//   Counter.FF2.RS1.TD1.y = if Counter.FF2.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF2.RS1.TD1.delayTime then Counter.FF2.RS1.TD1.x_delayed else Counter.FF2.RS1.TD1.y0 else pre(Counter.FF2.RS1.TD1.x);
//   Counter.FF2.RS2.Nor1.auxiliary[1] = Counter.FF2.RS2.Nor1.x[1];
//   Counter.FF2.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS2.Nor1.auxiliary[1],Counter.FF2.RS2.Nor1.x[2]];
//   Counter.FF2.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF2.RS2.Nor1.auxiliary[2]]);
//   Counter.FF2.RS2.Nor2.auxiliary[1] = Counter.FF2.RS2.Nor2.x[1];
//   Counter.FF2.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS2.Nor2.auxiliary[1],Counter.FF2.RS2.Nor2.x[2]];
//   Counter.FF2.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF2.RS2.Nor2.auxiliary[2]]);
//   Counter.FF2.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF2.RS2.TD1.x),Counter.FF2.RS2.TD1.delayTime,Counter.FF2.RS2.TD1.delayTime)));
//   Counter.FF2.RS2.TD1.y = if Counter.FF2.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF2.RS2.TD1.delayTime then Counter.FF2.RS2.TD1.x_delayed else Counter.FF2.RS2.TD1.y0 else pre(Counter.FF2.RS2.TD1.x);
//   Counter.FF2.And1.auxiliary[1] = Counter.FF2.And1.x[1];
//   Counter.FF2.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And1.auxiliary[1],Counter.FF2.And1.x[2]];
//   Counter.FF2.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF2.And1.auxiliary[2],Counter.FF2.And1.x[3]];
//   Counter.FF2.And1.y = pre(Counter.FF2.And1.auxiliary[3]);
//   Counter.FF2.And2.auxiliary[1] = Counter.FF2.And2.x[1];
//   Counter.FF2.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And2.auxiliary[1],Counter.FF2.And2.x[2]];
//   Counter.FF2.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF2.And2.auxiliary[2],Counter.FF2.And2.x[3]];
//   Counter.FF2.And2.y = pre(Counter.FF2.And2.auxiliary[3]);
//   Counter.FF2.And3.auxiliary[1] = Counter.FF2.And3.x[1];
//   Counter.FF2.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And3.auxiliary[1],Counter.FF2.And3.x[2]];
//   Counter.FF2.And3.y = pre(Counter.FF2.And3.auxiliary[2]);
//   Counter.FF2.And4.auxiliary[1] = Counter.FF2.And4.x[1];
//   Counter.FF2.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And4.auxiliary[1],Counter.FF2.And4.x[2]];
//   Counter.FF2.And4.y = pre(Counter.FF2.And4.auxiliary[2]);
//   Counter.FF2.Not1.auxiliary = D.Tables.NotTable[Counter.FF2.Not1.x];
//   Counter.FF2.Not1.y = pre(Counter.FF2.Not1.auxiliary);
//   Counter.FF3.RS1.Nor1.auxiliary[1] = Counter.FF3.RS1.Nor1.x[1];
//   Counter.FF3.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS1.Nor1.auxiliary[1],Counter.FF3.RS1.Nor1.x[2]];
//   Counter.FF3.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF3.RS1.Nor1.auxiliary[2]]);
//   Counter.FF3.RS1.Nor2.auxiliary[1] = Counter.FF3.RS1.Nor2.x[1];
//   Counter.FF3.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS1.Nor2.auxiliary[1],Counter.FF3.RS1.Nor2.x[2]];
//   Counter.FF3.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF3.RS1.Nor2.auxiliary[2]]);
//   Counter.FF3.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF3.RS1.TD1.x),Counter.FF3.RS1.TD1.delayTime,Counter.FF3.RS1.TD1.delayTime)));
//   Counter.FF3.RS1.TD1.y = if Counter.FF3.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF3.RS1.TD1.delayTime then Counter.FF3.RS1.TD1.x_delayed else Counter.FF3.RS1.TD1.y0 else pre(Counter.FF3.RS1.TD1.x);
//   Counter.FF3.RS2.Nor1.auxiliary[1] = Counter.FF3.RS2.Nor1.x[1];
//   Counter.FF3.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS2.Nor1.auxiliary[1],Counter.FF3.RS2.Nor1.x[2]];
//   Counter.FF3.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF3.RS2.Nor1.auxiliary[2]]);
//   Counter.FF3.RS2.Nor2.auxiliary[1] = Counter.FF3.RS2.Nor2.x[1];
//   Counter.FF3.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS2.Nor2.auxiliary[1],Counter.FF3.RS2.Nor2.x[2]];
//   Counter.FF3.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF3.RS2.Nor2.auxiliary[2]]);
//   Counter.FF3.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF3.RS2.TD1.x),Counter.FF3.RS2.TD1.delayTime,Counter.FF3.RS2.TD1.delayTime)));
//   Counter.FF3.RS2.TD1.y = if Counter.FF3.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF3.RS2.TD1.delayTime then Counter.FF3.RS2.TD1.x_delayed else Counter.FF3.RS2.TD1.y0 else pre(Counter.FF3.RS2.TD1.x);
//   Counter.FF3.And1.auxiliary[1] = Counter.FF3.And1.x[1];
//   Counter.FF3.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And1.auxiliary[1],Counter.FF3.And1.x[2]];
//   Counter.FF3.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF3.And1.auxiliary[2],Counter.FF3.And1.x[3]];
//   Counter.FF3.And1.y = pre(Counter.FF3.And1.auxiliary[3]);
//   Counter.FF3.And2.auxiliary[1] = Counter.FF3.And2.x[1];
//   Counter.FF3.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And2.auxiliary[1],Counter.FF3.And2.x[2]];
//   Counter.FF3.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF3.And2.auxiliary[2],Counter.FF3.And2.x[3]];
//   Counter.FF3.And2.y = pre(Counter.FF3.And2.auxiliary[3]);
//   Counter.FF3.And3.auxiliary[1] = Counter.FF3.And3.x[1];
//   Counter.FF3.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And3.auxiliary[1],Counter.FF3.And3.x[2]];
//   Counter.FF3.And3.y = pre(Counter.FF3.And3.auxiliary[2]);
//   Counter.FF3.And4.auxiliary[1] = Counter.FF3.And4.x[1];
//   Counter.FF3.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And4.auxiliary[1],Counter.FF3.And4.x[2]];
//   Counter.FF3.And4.y = pre(Counter.FF3.And4.auxiliary[2]);
//   Counter.FF3.Not1.auxiliary = D.Tables.NotTable[Counter.FF3.Not1.x];
//   Counter.FF3.Not1.y = pre(Counter.FF3.Not1.auxiliary);
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.AND.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.XOR.G1.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.XOR.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.b;
//   Adder1.Adder2.AND.G1.x[1] = Adder1.c_in;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF1.And1.x[3];
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF1.RS1.Nor1.y;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF1.RS1.TD1.x;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF1.RS1.qn;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF1.q;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF2.And1.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF2.And2.x[3];
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF2.Not1.x;
//   Adder1.Adder2.AND.G1.x[1] = Counter.FF2.clk;
//   Adder1.Adder2.AND.G1.x[1] = Counter.q0;
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.AND.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.XOR.G1.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.XOR.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.b;
//   Adder1.Adder1.AND.G1.x[1] = Adder1.b;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF2.And1.x[3];
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF2.RS1.Nor1.y;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF2.RS1.TD1.x;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF2.RS1.qn;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF2.q;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF3.And1.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF3.And2.x[3];
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF3.Not1.x;
//   Adder1.Adder1.AND.G1.x[1] = Counter.FF3.clk;
//   Adder1.Adder1.AND.G1.x[1] = Counter.q1;
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.AND.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.XOR.G1.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.XOR.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.a;
//   Adder1.Adder1.AND.G1.x[2] = Adder1.a;
//   Adder1.Adder1.AND.G1.x[2] = Counter.FF3.And1.x[3];
//   Adder1.Adder1.AND.G1.x[2] = Counter.FF3.RS1.Nor1.y;
//   Adder1.Adder1.AND.G1.x[2] = Counter.FF3.RS1.TD1.x;
//   Adder1.Adder1.AND.G1.x[2] = Counter.FF3.RS1.qn;
//   Adder1.Adder1.AND.G1.x[2] = Counter.FF3.q;
//   Adder1.Adder1.AND.G1.x[2] = Counter.q2;
//   Counter.FF1.And1.x[2] = Counter.FF1.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF1.j;
//   Counter.FF1.And1.x[2] = Counter.FF1.k;
//   Counter.FF1.And1.x[2] = Counter.FF2.And1.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF2.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF2.j;
//   Counter.FF1.And1.x[2] = Counter.FF2.k;
//   Counter.FF1.And1.x[2] = Counter.FF3.And1.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF3.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF3.j;
//   Counter.FF1.And1.x[2] = Counter.FF3.k;
//   Counter.FF1.And1.x[2] = Counter.enable;
//   Counter.FF1.And1.x[2] = Enable.y;
//   CLK.y = Counter.FF1.And1.x[1];
//   CLK.y = Counter.FF1.And2.x[3];
//   CLK.y = Counter.FF1.Not1.x;
//   CLK.y = Counter.FF1.clk;
//   CLK.y = Counter.count;
//   Adder1.OR.y = Adder1.c_out;
//   Adder1.OR.y = c_out.x[1];
//   Adder1.Adder2.XOR.G2.y = Adder1.Adder2.XOR.y;
//   Adder1.Adder2.XOR.G2.y = Adder1.Adder2.s;
//   Adder1.Adder2.XOR.G2.y = Adder1.s;
//   Adder1.Adder2.XOR.G2.y = s.x[1];
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.Nor1.x[1];
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.Nor2.y;
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.q;
//   Counter.FF3.And2.x[1] = Counter.FF3.qn;
//   Counter.FF3.And3.x[1] = Counter.FF3.And4.x[1];
//   Counter.FF3.And3.x[1] = Counter.FF3.Not1.y;
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.Nor1.x[1];
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.Nor2.y;
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.q;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.Nor1.y;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.TD1.x;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.qn;
//   Counter.FF3.And3.y = Counter.FF3.RS1.Nor1.x[2];
//   Counter.FF3.And3.y = Counter.FF3.RS1.s;
//   Counter.FF3.And4.y = Counter.FF3.RS1.Nor2.x[1];
//   Counter.FF3.And4.y = Counter.FF3.RS1.r;
//   Counter.FF3.And1.y = Counter.FF3.RS2.Nor1.x[2];
//   Counter.FF3.And1.y = Counter.FF3.RS2.s;
//   Counter.FF3.And2.y = Counter.FF3.RS2.Nor2.x[1];
//   Counter.FF3.And2.y = Counter.FF3.RS2.r;
//   Counter.FF3.RS2.Nor2.x[2] = Counter.FF3.RS2.TD1.y;
//   Counter.FF3.RS1.Nor2.x[2] = Counter.FF3.RS1.TD1.y;
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.Nor1.x[1];
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.Nor2.y;
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.q;
//   Counter.FF2.And2.x[1] = Counter.FF2.qn;
//   Counter.FF2.And3.x[1] = Counter.FF2.And4.x[1];
//   Counter.FF2.And3.x[1] = Counter.FF2.Not1.y;
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.Nor1.x[1];
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.Nor2.y;
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.q;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.Nor1.y;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.TD1.x;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.qn;
//   Counter.FF2.And3.y = Counter.FF2.RS1.Nor1.x[2];
//   Counter.FF2.And3.y = Counter.FF2.RS1.s;
//   Counter.FF2.And4.y = Counter.FF2.RS1.Nor2.x[1];
//   Counter.FF2.And4.y = Counter.FF2.RS1.r;
//   Counter.FF2.And1.y = Counter.FF2.RS2.Nor1.x[2];
//   Counter.FF2.And1.y = Counter.FF2.RS2.s;
//   Counter.FF2.And2.y = Counter.FF2.RS2.Nor2.x[1];
//   Counter.FF2.And2.y = Counter.FF2.RS2.r;
//   Counter.FF2.RS2.Nor2.x[2] = Counter.FF2.RS2.TD1.y;
//   Counter.FF2.RS1.Nor2.x[2] = Counter.FF2.RS1.TD1.y;
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.Nor1.x[1];
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.Nor2.y;
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.q;
//   Counter.FF1.And2.x[1] = Counter.FF1.qn;
//   Counter.FF1.And3.x[1] = Counter.FF1.And4.x[1];
//   Counter.FF1.And3.x[1] = Counter.FF1.Not1.y;
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.Nor1.x[1];
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.Nor2.y;
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.q;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.Nor1.y;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.TD1.x;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.qn;
//   Counter.FF1.And3.y = Counter.FF1.RS1.Nor1.x[2];
//   Counter.FF1.And3.y = Counter.FF1.RS1.s;
//   Counter.FF1.And4.y = Counter.FF1.RS1.Nor2.x[1];
//   Counter.FF1.And4.y = Counter.FF1.RS1.r;
//   Counter.FF1.And1.y = Counter.FF1.RS2.Nor1.x[2];
//   Counter.FF1.And1.y = Counter.FF1.RS2.s;
//   Counter.FF1.And2.y = Counter.FF1.RS2.Nor2.x[1];
//   Counter.FF1.And2.y = Counter.FF1.RS2.r;
//   Counter.FF1.RS2.Nor2.x[2] = Counter.FF1.RS2.TD1.y;
//   Counter.FF1.RS1.Nor2.x[2] = Counter.FF1.RS1.TD1.y;
//   Adder1.Adder1.AND.G2.y = Adder1.Adder1.AND.y;
//   Adder1.Adder1.AND.G2.y = Adder1.Adder1.c;
//   Adder1.Adder1.AND.G2.y = Adder1.OR.x[1];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder1.XOR.y;
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder1.s;
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.AND.G1.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.AND.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.XOR.G1.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.XOR.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.a;
//   Adder1.Adder2.AND.G2.y = Adder1.Adder2.AND.y;
//   Adder1.Adder2.AND.G2.y = Adder1.Adder2.c;
//   Adder1.Adder2.AND.G2.y = Adder1.OR.x[2];
//   Adder1.Adder1.XOR.G1.y = Adder1.Adder1.XOR.G2.x;
//   Adder1.Adder1.AND.G1.y = Adder1.Adder1.AND.G2.x;
//   Adder1.Adder2.XOR.G1.y = Adder1.Adder2.XOR.G2.x;
//   Adder1.Adder2.AND.G1.y = Adder1.Adder2.AND.G2.x;
// algorithm
//   when {initial(),(Adder1.Adder2.AND.G2.tLH > 0.0 OR Adder1.Adder2.AND.G2.tHL > 0.0) AND change(Adder1.Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder1.Adder2.AND.G2.x_old := if initial() OR pre(Adder1.Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder2.AND.G2.y0 else pre(Adder1.Adder2.AND.G2.x);
//     Adder1.Adder2.AND.G2.lh := Adder1.Adder2.AND.G2.delayTable[Adder1.Adder2.AND.G2.x_old, Adder1.Adder2.AND.G2.x];
//     Adder1.Adder2.AND.G2.delayTime := if Adder1.Adder2.AND.G2.lh > 0 then Adder1.Adder2.AND.G2.tLH else if Adder1.Adder2.AND.G2.lh < 0 then Adder1.Adder2.AND.G2.tHL else 0.0;
//     Adder1.Adder2.AND.G2.t_next := time + Adder1.Adder2.AND.G2.delayTime;
//     if Adder1.Adder2.AND.G2.lh == 0 OR abs(Adder1.Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder1.Adder2.AND.G2.y_auxiliary := Adder1.Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder2.AND.G2.t_next then
//     Adder1.Adder2.AND.G2.y_auxiliary := Adder1.Adder2.AND.G2.x;
//   end when;
//   Adder1.Adder2.AND.G2.y := if Adder1.Adder2.AND.G2.tLH > 0.0 OR Adder1.Adder2.AND.G2.tHL > 0.0 then Adder1.Adder2.AND.G2.y_auxiliary else Adder1.Adder2.AND.G2.x;
//   when {initial(),(Adder1.Adder2.XOR.G2.tLH > 0.0 OR Adder1.Adder2.XOR.G2.tHL > 0.0) AND change(Adder1.Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder1.Adder2.XOR.G2.x_old := if initial() OR pre(Adder1.Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder2.XOR.G2.y0 else pre(Adder1.Adder2.XOR.G2.x);
//     Adder1.Adder2.XOR.G2.lh := Adder1.Adder2.XOR.G2.delayTable[Adder1.Adder2.XOR.G2.x_old, Adder1.Adder2.XOR.G2.x];
//     Adder1.Adder2.XOR.G2.delayTime := if Adder1.Adder2.XOR.G2.lh > 0 then Adder1.Adder2.XOR.G2.tLH else if Adder1.Adder2.XOR.G2.lh < 0 then Adder1.Adder2.XOR.G2.tHL else 0.0;
//     Adder1.Adder2.XOR.G2.t_next := time + Adder1.Adder2.XOR.G2.delayTime;
//     if Adder1.Adder2.XOR.G2.lh == 0 OR abs(Adder1.Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder1.Adder2.XOR.G2.y_auxiliary := Adder1.Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder2.XOR.G2.t_next then
//     Adder1.Adder2.XOR.G2.y_auxiliary := Adder1.Adder2.XOR.G2.x;
//   end when;
//   Adder1.Adder2.XOR.G2.y := if Adder1.Adder2.XOR.G2.tLH > 0.0 OR Adder1.Adder2.XOR.G2.tHL > 0.0 then Adder1.Adder2.XOR.G2.y_auxiliary else Adder1.Adder2.XOR.G2.x;
//   when {initial(),(Adder1.Adder1.AND.G2.tLH > 0.0 OR Adder1.Adder1.AND.G2.tHL > 0.0) AND change(Adder1.Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder1.Adder1.AND.G2.x_old := if initial() OR pre(Adder1.Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder1.AND.G2.y0 else pre(Adder1.Adder1.AND.G2.x);
//     Adder1.Adder1.AND.G2.lh := Adder1.Adder1.AND.G2.delayTable[Adder1.Adder1.AND.G2.x_old, Adder1.Adder1.AND.G2.x];
//     Adder1.Adder1.AND.G2.delayTime := if Adder1.Adder1.AND.G2.lh > 0 then Adder1.Adder1.AND.G2.tLH else if Adder1.Adder1.AND.G2.lh < 0 then Adder1.Adder1.AND.G2.tHL else 0.0;
//     Adder1.Adder1.AND.G2.t_next := time + Adder1.Adder1.AND.G2.delayTime;
//     if Adder1.Adder1.AND.G2.lh == 0 OR abs(Adder1.Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder1.Adder1.AND.G2.y_auxiliary := Adder1.Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder1.AND.G2.t_next then
//     Adder1.Adder1.AND.G2.y_auxiliary := Adder1.Adder1.AND.G2.x;
//   end when;
//   Adder1.Adder1.AND.G2.y := if Adder1.Adder1.AND.G2.tLH > 0.0 OR Adder1.Adder1.AND.G2.tHL > 0.0 then Adder1.Adder1.AND.G2.y_auxiliary else Adder1.Adder1.AND.G2.x;
//   when {initial(),(Adder1.Adder1.XOR.G2.tLH > 0.0 OR Adder1.Adder1.XOR.G2.tHL > 0.0) AND change(Adder1.Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder1.Adder1.XOR.G2.x_old := if initial() OR pre(Adder1.Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder1.XOR.G2.y0 else pre(Adder1.Adder1.XOR.G2.x);
//     Adder1.Adder1.XOR.G2.lh := Adder1.Adder1.XOR.G2.delayTable[Adder1.Adder1.XOR.G2.x_old, Adder1.Adder1.XOR.G2.x];
//     Adder1.Adder1.XOR.G2.delayTime := if Adder1.Adder1.XOR.G2.lh > 0 then Adder1.Adder1.XOR.G2.tLH else if Adder1.Adder1.XOR.G2.lh < 0 then Adder1.Adder1.XOR.G2.tHL else 0.0;
//     Adder1.Adder1.XOR.G2.t_next := time + Adder1.Adder1.XOR.G2.delayTime;
//     if Adder1.Adder1.XOR.G2.lh == 0 OR abs(Adder1.Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder1.Adder1.XOR.G2.y_auxiliary := Adder1.Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder1.XOR.G2.t_next then
//     Adder1.Adder1.XOR.G2.y_auxiliary := Adder1.Adder1.XOR.G2.x;
//   end when;
//   Adder1.Adder1.XOR.G2.y := if Adder1.Adder1.XOR.G2.tLH > 0.0 OR Adder1.Adder1.XOR.G2.tHL > 0.0 then Adder1.Adder1.XOR.G2.y_auxiliary else Adder1.Adder1.XOR.G2.x;
//   Enable.y := Enable.x;
//   when sample(CLK.startTime,CLK.period) then
//     CLK.t_i := time;
//   end when;
//   CLK.y := if  NOT time >= CLK.startTime OR time >= CLK.t_i + CLK.t_width then Modelica.Electrical.Digital.Interfaces.Logic.'0' else Modelica.Electrical.Digital.Interfaces.Logic.'1';
// end Modelica.Electrical.Digital.Examples.FullAdder;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.FullAdder completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.FullAdder has 613 equation(s) and 613 variable(s).
// 583 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Adder4
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b4.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b4.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real b4.t[1] = 1.0 "vector of corresponding time points";
//   parameter Real b4.t[2] = 3.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b4.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer b4.n = 2 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b4.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b1.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b1.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b1.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter Real b1.t[1] = 1.0 "vector of corresponding time points";
//   parameter Real b1.t[2] = 2.0 "vector of corresponding time points";
//   parameter Real b1.t[3] = 3.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b1.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer b1.n = 3 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b1.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b2.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter Real b2.t[1] = 4.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b2.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer b2.n = 1 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b2.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b3.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter Real b3.t[1] = 1.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b3.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer b3.n = 1 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b3.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1.x[3] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter Real a1.t[1] = 1.0 "vector of corresponding time points";
//   parameter Real a1.t[2] = 2.0 "vector of corresponding time points";
//   parameter Real a1.t[3] = 3.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer a1.n = 3 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a2.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter Real a2.t[1] = 1.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a2.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer a2.n = 1 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a2.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a3.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'1' "vector of values";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a3.x[2] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real a3.t[1] = 1.0 "vector of corresponding time points";
//   parameter Real a3.t[2] = 4.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a3.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer a3.n = 2 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a3.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a4.x[1] = Modelica.Electrical.Digital.Interfaces.Logic.'0' "vector of values";
//   parameter Real a4.t[1] = 1.0 "vector of corresponding time points";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a4.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial output value";
//   parameter Integer a4.n = 1 "table size";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a4.y;
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Set.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'1') = Modelica.Electrical.Digital.Interfaces.Logic.'0' "Logic value to be set";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Set.y;
//   parameter Real Adder1.Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.c;
//   parameter Integer Adder1.Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder2.AND.G1.n(min = 2) = Adder1.Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder1.Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y0 = Adder1.Adder2.AND.y0 "initial value of output";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.y_auxiliary(start = Adder1.Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.AND.G2.x_old(start = Adder1.Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder1.Adder2.AND.G2.lh;
//   protected discrete Real Adder1.Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder1.Adder2.XOR.G1.n(min = 2) = Adder1.Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder1.Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y0 = Adder1.Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.y_auxiliary(start = Adder1.Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder2.XOR.G2.x_old(start = Adder1.Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder1.Adder2.XOR.G2.lh;
//   protected discrete Real Adder1.Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.c;
//   parameter Integer Adder1.Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder1.AND.G1.n(min = 2) = Adder1.Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder1.Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y0 = Adder1.Adder1.AND.y0 "initial value of output";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.y_auxiliary(start = Adder1.Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.AND.G2.x_old(start = Adder1.Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder1.Adder1.AND.G2.lh;
//   protected discrete Real Adder1.Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder1.Adder1.XOR.G1.n(min = 2) = Adder1.Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder1.Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y0 = Adder1.Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.y_auxiliary(start = Adder1.Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.Adder1.XOR.G2.x_old(start = Adder1.Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder1.Adder1.XOR.G2.lh;
//   protected discrete Real Adder1.Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.c_out;
//   parameter Integer Adder1.OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Real Adder2.Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.c;
//   parameter Integer Adder2.Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder2.Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.Adder2.AND.G1.n(min = 2) = Adder2.Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder2.Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G2.y0 = Adder2.Adder2.AND.y0 "initial value of output";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G2.y_auxiliary(start = Adder2.Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.AND.G2.x_old(start = Adder2.Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder2.Adder2.AND.G2.lh;
//   protected discrete Real Adder2.Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder2.Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder2.Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder2.Adder2.XOR.G1.n(min = 2) = Adder2.Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder2.Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G2.y0 = Adder2.Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G2.y_auxiliary(start = Adder2.Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder2.XOR.G2.x_old(start = Adder2.Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder2.Adder2.XOR.G2.lh;
//   protected discrete Real Adder2.Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder2.Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.c;
//   parameter Integer Adder2.Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder2.Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.Adder1.AND.G1.n(min = 2) = Adder2.Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder2.Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G2.y0 = Adder2.Adder1.AND.y0 "initial value of output";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G2.y_auxiliary(start = Adder2.Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.AND.G2.x_old(start = Adder2.Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder2.Adder1.AND.G2.lh;
//   protected discrete Real Adder2.Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder2.Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder2.Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder2.Adder1.XOR.G1.n(min = 2) = Adder2.Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder2.Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G2.y0 = Adder2.Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G2.y_auxiliary(start = Adder2.Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.Adder1.XOR.G2.x_old(start = Adder2.Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder2.Adder1.XOR.G2.lh;
//   protected discrete Real Adder2.Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.c_out;
//   parameter Integer Adder2.OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Real Adder3.Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.c;
//   parameter Integer Adder3.Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder3.Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder3.Adder2.AND.G1.n(min = 2) = Adder3.Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder3.Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G2.y0 = Adder3.Adder2.AND.y0 "initial value of output";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder3.Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G2.y_auxiliary(start = Adder3.Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.AND.G2.x_old(start = Adder3.Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder3.Adder2.AND.G2.lh;
//   protected discrete Real Adder3.Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder3.Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder3.Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder3.Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder3.Adder2.XOR.G1.n(min = 2) = Adder3.Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder3.Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G2.y0 = Adder3.Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder3.Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G2.y_auxiliary(start = Adder3.Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder2.XOR.G2.x_old(start = Adder3.Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder3.Adder2.XOR.G2.lh;
//   protected discrete Real Adder3.Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder3.Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.c;
//   parameter Integer Adder3.Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder3.Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder3.Adder1.AND.G1.n(min = 2) = Adder3.Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder3.Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G2.y0 = Adder3.Adder1.AND.y0 "initial value of output";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder3.Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G2.y_auxiliary(start = Adder3.Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.AND.G2.x_old(start = Adder3.Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder3.Adder1.AND.G2.lh;
//   protected discrete Real Adder3.Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder3.Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder3.Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder3.Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder3.Adder1.XOR.G1.n(min = 2) = Adder3.Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder3.Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder3.Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder3.Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G2.y0 = Adder3.Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder3.Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder3.Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G2.y_auxiliary(start = Adder3.Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.Adder1.XOR.G2.x_old(start = Adder3.Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder3.Adder1.XOR.G2.lh;
//   protected discrete Real Adder3.Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.c_out;
//   parameter Integer Adder3.OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder3.OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Real Adder4.Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.c;
//   parameter Integer Adder4.Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder4.Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder4.Adder2.AND.G1.n(min = 2) = Adder4.Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder4.Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G2.y0 = Adder4.Adder2.AND.y0 "initial value of output";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder4.Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G2.y_auxiliary(start = Adder4.Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.AND.G2.x_old(start = Adder4.Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder4.Adder2.AND.G2.lh;
//   protected discrete Real Adder4.Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder4.Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.delayTime "rise inertial delay";
//   parameter Real Adder4.Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder4.Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder4.Adder2.XOR.G1.n(min = 2) = Adder4.Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder4.Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G2.y0 = Adder4.Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder4.Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G2.y_auxiliary(start = Adder4.Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder2.XOR.G2.x_old(start = Adder4.Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder4.Adder2.XOR.G2.lh;
//   protected discrete Real Adder4.Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder4.Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.c;
//   parameter Integer Adder4.Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder4.Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder4.Adder1.AND.G1.n(min = 2) = Adder4.Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder4.Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G2.y0 = Adder4.Adder1.AND.y0 "initial value of output";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder4.Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G2.y_auxiliary(start = Adder4.Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.AND.G2.x_old(start = Adder4.Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder4.Adder1.AND.G2.lh;
//   protected discrete Real Adder4.Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder4.Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.delayTime "rise inertial delay";
//   parameter Real Adder4.Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder4.Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder4.Adder1.XOR.G1.n(min = 2) = Adder4.Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder4.Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder4.Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder4.Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G2.y0 = Adder4.Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder4.Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder4.Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G2.y_auxiliary(start = Adder4.Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.Adder1.XOR.G2.x_old(start = Adder4.Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder4.Adder1.XOR.G2.lh;
//   protected discrete Real Adder4.Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.c_out;
//   parameter Integer Adder4.OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder4.OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   Adder1.Adder2.AND.G1.auxiliary[1] = Adder1.Adder2.AND.G1.x[1];
//   Adder1.Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder1.Adder2.AND.G1.auxiliary[1],Adder1.Adder2.AND.G1.x[2]];
//   Adder1.Adder2.AND.G1.y = pre(Adder1.Adder2.AND.G1.auxiliary[2]);
//   Adder1.Adder2.XOR.G1.auxiliary[1] = Adder1.Adder2.XOR.G1.x[1];
//   Adder1.Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder1.Adder2.XOR.G1.auxiliary[1],Adder1.Adder2.XOR.G1.x[2]];
//   Adder1.Adder2.XOR.G1.y = pre(Adder1.Adder2.XOR.G1.auxiliary[2]);
//   Adder1.Adder1.AND.G1.auxiliary[1] = Adder1.Adder1.AND.G1.x[1];
//   Adder1.Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder1.Adder1.AND.G1.auxiliary[1],Adder1.Adder1.AND.G1.x[2]];
//   Adder1.Adder1.AND.G1.y = pre(Adder1.Adder1.AND.G1.auxiliary[2]);
//   Adder1.Adder1.XOR.G1.auxiliary[1] = Adder1.Adder1.XOR.G1.x[1];
//   Adder1.Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder1.Adder1.XOR.G1.auxiliary[1],Adder1.Adder1.XOR.G1.x[2]];
//   Adder1.Adder1.XOR.G1.y = pre(Adder1.Adder1.XOR.G1.auxiliary[2]);
//   Adder1.OR.auxiliary[1] = Adder1.OR.x[1];
//   Adder1.OR.auxiliary[2] = D.Tables.OrTable[Adder1.OR.auxiliary[1],Adder1.OR.x[2]];
//   Adder1.OR.y = pre(Adder1.OR.auxiliary[2]);
//   Adder2.Adder2.AND.G1.auxiliary[1] = Adder2.Adder2.AND.G1.x[1];
//   Adder2.Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder2.Adder2.AND.G1.auxiliary[1],Adder2.Adder2.AND.G1.x[2]];
//   Adder2.Adder2.AND.G1.y = pre(Adder2.Adder2.AND.G1.auxiliary[2]);
//   Adder2.Adder2.XOR.G1.auxiliary[1] = Adder2.Adder2.XOR.G1.x[1];
//   Adder2.Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder2.Adder2.XOR.G1.auxiliary[1],Adder2.Adder2.XOR.G1.x[2]];
//   Adder2.Adder2.XOR.G1.y = pre(Adder2.Adder2.XOR.G1.auxiliary[2]);
//   Adder2.Adder1.AND.G1.auxiliary[1] = Adder2.Adder1.AND.G1.x[1];
//   Adder2.Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder2.Adder1.AND.G1.auxiliary[1],Adder2.Adder1.AND.G1.x[2]];
//   Adder2.Adder1.AND.G1.y = pre(Adder2.Adder1.AND.G1.auxiliary[2]);
//   Adder2.Adder1.XOR.G1.auxiliary[1] = Adder2.Adder1.XOR.G1.x[1];
//   Adder2.Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder2.Adder1.XOR.G1.auxiliary[1],Adder2.Adder1.XOR.G1.x[2]];
//   Adder2.Adder1.XOR.G1.y = pre(Adder2.Adder1.XOR.G1.auxiliary[2]);
//   Adder2.OR.auxiliary[1] = Adder2.OR.x[1];
//   Adder2.OR.auxiliary[2] = D.Tables.OrTable[Adder2.OR.auxiliary[1],Adder2.OR.x[2]];
//   Adder2.OR.y = pre(Adder2.OR.auxiliary[2]);
//   Adder3.Adder2.AND.G1.auxiliary[1] = Adder3.Adder2.AND.G1.x[1];
//   Adder3.Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder3.Adder2.AND.G1.auxiliary[1],Adder3.Adder2.AND.G1.x[2]];
//   Adder3.Adder2.AND.G1.y = pre(Adder3.Adder2.AND.G1.auxiliary[2]);
//   Adder3.Adder2.XOR.G1.auxiliary[1] = Adder3.Adder2.XOR.G1.x[1];
//   Adder3.Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder3.Adder2.XOR.G1.auxiliary[1],Adder3.Adder2.XOR.G1.x[2]];
//   Adder3.Adder2.XOR.G1.y = pre(Adder3.Adder2.XOR.G1.auxiliary[2]);
//   Adder3.Adder1.AND.G1.auxiliary[1] = Adder3.Adder1.AND.G1.x[1];
//   Adder3.Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder3.Adder1.AND.G1.auxiliary[1],Adder3.Adder1.AND.G1.x[2]];
//   Adder3.Adder1.AND.G1.y = pre(Adder3.Adder1.AND.G1.auxiliary[2]);
//   Adder3.Adder1.XOR.G1.auxiliary[1] = Adder3.Adder1.XOR.G1.x[1];
//   Adder3.Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder3.Adder1.XOR.G1.auxiliary[1],Adder3.Adder1.XOR.G1.x[2]];
//   Adder3.Adder1.XOR.G1.y = pre(Adder3.Adder1.XOR.G1.auxiliary[2]);
//   Adder3.OR.auxiliary[1] = Adder3.OR.x[1];
//   Adder3.OR.auxiliary[2] = D.Tables.OrTable[Adder3.OR.auxiliary[1],Adder3.OR.x[2]];
//   Adder3.OR.y = pre(Adder3.OR.auxiliary[2]);
//   Adder4.Adder2.AND.G1.auxiliary[1] = Adder4.Adder2.AND.G1.x[1];
//   Adder4.Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder4.Adder2.AND.G1.auxiliary[1],Adder4.Adder2.AND.G1.x[2]];
//   Adder4.Adder2.AND.G1.y = pre(Adder4.Adder2.AND.G1.auxiliary[2]);
//   Adder4.Adder2.XOR.G1.auxiliary[1] = Adder4.Adder2.XOR.G1.x[1];
//   Adder4.Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder4.Adder2.XOR.G1.auxiliary[1],Adder4.Adder2.XOR.G1.x[2]];
//   Adder4.Adder2.XOR.G1.y = pre(Adder4.Adder2.XOR.G1.auxiliary[2]);
//   Adder4.Adder1.AND.G1.auxiliary[1] = Adder4.Adder1.AND.G1.x[1];
//   Adder4.Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder4.Adder1.AND.G1.auxiliary[1],Adder4.Adder1.AND.G1.x[2]];
//   Adder4.Adder1.AND.G1.y = pre(Adder4.Adder1.AND.G1.auxiliary[2]);
//   Adder4.Adder1.XOR.G1.auxiliary[1] = Adder4.Adder1.XOR.G1.x[1];
//   Adder4.Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder4.Adder1.XOR.G1.auxiliary[1],Adder4.Adder1.XOR.G1.x[2]];
//   Adder4.Adder1.XOR.G1.y = pre(Adder4.Adder1.XOR.G1.auxiliary[2]);
//   Adder4.OR.auxiliary[1] = Adder4.OR.x[1];
//   Adder4.OR.auxiliary[2] = D.Tables.OrTable[Adder4.OR.auxiliary[1],Adder4.OR.x[2]];
//   Adder4.OR.y = pre(Adder4.OR.auxiliary[2]);
//   Adder4.Adder1.AND.G1.x[2] = Adder4.Adder1.AND.x[2];
//   Adder4.Adder1.AND.G1.x[2] = Adder4.Adder1.XOR.G1.x[2];
//   Adder4.Adder1.AND.G1.x[2] = Adder4.Adder1.XOR.x[2];
//   Adder4.Adder1.AND.G1.x[2] = Adder4.Adder1.a;
//   Adder4.Adder1.AND.G1.x[2] = Adder4.a;
//   Adder4.Adder1.AND.G1.x[2] = a4.y;
//   Adder4.Adder1.AND.G1.x[1] = Adder4.Adder1.AND.x[1];
//   Adder4.Adder1.AND.G1.x[1] = Adder4.Adder1.XOR.G1.x[1];
//   Adder4.Adder1.AND.G1.x[1] = Adder4.Adder1.XOR.x[1];
//   Adder4.Adder1.AND.G1.x[1] = Adder4.Adder1.b;
//   Adder4.Adder1.AND.G1.x[1] = Adder4.b;
//   Adder4.Adder1.AND.G1.x[1] = b4.y;
//   Adder3.Adder1.AND.G1.x[2] = Adder3.Adder1.AND.x[2];
//   Adder3.Adder1.AND.G1.x[2] = Adder3.Adder1.XOR.G1.x[2];
//   Adder3.Adder1.AND.G1.x[2] = Adder3.Adder1.XOR.x[2];
//   Adder3.Adder1.AND.G1.x[2] = Adder3.Adder1.a;
//   Adder3.Adder1.AND.G1.x[2] = Adder3.a;
//   Adder3.Adder1.AND.G1.x[2] = a3.y;
//   Adder3.Adder1.AND.G1.x[1] = Adder3.Adder1.AND.x[1];
//   Adder3.Adder1.AND.G1.x[1] = Adder3.Adder1.XOR.G1.x[1];
//   Adder3.Adder1.AND.G1.x[1] = Adder3.Adder1.XOR.x[1];
//   Adder3.Adder1.AND.G1.x[1] = Adder3.Adder1.b;
//   Adder3.Adder1.AND.G1.x[1] = Adder3.b;
//   Adder3.Adder1.AND.G1.x[1] = b3.y;
//   Adder2.Adder1.AND.G1.x[2] = Adder2.Adder1.AND.x[2];
//   Adder2.Adder1.AND.G1.x[2] = Adder2.Adder1.XOR.G1.x[2];
//   Adder2.Adder1.AND.G1.x[2] = Adder2.Adder1.XOR.x[2];
//   Adder2.Adder1.AND.G1.x[2] = Adder2.Adder1.a;
//   Adder2.Adder1.AND.G1.x[2] = Adder2.a;
//   Adder2.Adder1.AND.G1.x[2] = a2.y;
//   Adder2.Adder1.AND.G1.x[1] = Adder2.Adder1.AND.x[1];
//   Adder2.Adder1.AND.G1.x[1] = Adder2.Adder1.XOR.G1.x[1];
//   Adder2.Adder1.AND.G1.x[1] = Adder2.Adder1.XOR.x[1];
//   Adder2.Adder1.AND.G1.x[1] = Adder2.Adder1.b;
//   Adder2.Adder1.AND.G1.x[1] = Adder2.b;
//   Adder2.Adder1.AND.G1.x[1] = b2.y;
//   Adder3.OR.y = Adder3.c_out;
//   Adder3.OR.y = Adder4.Adder2.AND.G1.x[1];
//   Adder3.OR.y = Adder4.Adder2.AND.x[1];
//   Adder3.OR.y = Adder4.Adder2.XOR.G1.x[1];
//   Adder3.OR.y = Adder4.Adder2.XOR.x[1];
//   Adder3.OR.y = Adder4.Adder2.b;
//   Adder3.OR.y = Adder4.c_in;
//   Adder2.OR.y = Adder2.c_out;
//   Adder2.OR.y = Adder3.Adder2.AND.G1.x[1];
//   Adder2.OR.y = Adder3.Adder2.AND.x[1];
//   Adder2.OR.y = Adder3.Adder2.XOR.G1.x[1];
//   Adder2.OR.y = Adder3.Adder2.XOR.x[1];
//   Adder2.OR.y = Adder3.Adder2.b;
//   Adder2.OR.y = Adder3.c_in;
//   Adder1.OR.y = Adder1.c_out;
//   Adder1.OR.y = Adder2.Adder2.AND.G1.x[1];
//   Adder1.OR.y = Adder2.Adder2.AND.x[1];
//   Adder1.OR.y = Adder2.Adder2.XOR.G1.x[1];
//   Adder1.OR.y = Adder2.Adder2.XOR.x[1];
//   Adder1.OR.y = Adder2.Adder2.b;
//   Adder1.OR.y = Adder2.c_in;
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.AND.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.XOR.G1.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.XOR.x[1];
//   Adder1.Adder2.AND.G1.x[1] = Adder1.Adder2.b;
//   Adder1.Adder2.AND.G1.x[1] = Adder1.c_in;
//   Adder1.Adder2.AND.G1.x[1] = Set.y;
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.AND.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.XOR.G1.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.XOR.x[2];
//   Adder1.Adder1.AND.G1.x[2] = Adder1.Adder1.a;
//   Adder1.Adder1.AND.G1.x[2] = Adder1.a;
//   Adder1.Adder1.AND.G1.x[2] = a1.y;
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.AND.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.XOR.G1.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.XOR.x[1];
//   Adder1.Adder1.AND.G1.x[1] = Adder1.Adder1.b;
//   Adder1.Adder1.AND.G1.x[1] = Adder1.b;
//   Adder1.Adder1.AND.G1.x[1] = b1.y;
//   Adder4.Adder1.AND.G2.y = Adder4.Adder1.AND.y;
//   Adder4.Adder1.AND.G2.y = Adder4.Adder1.c;
//   Adder4.Adder1.AND.G2.y = Adder4.OR.x[1];
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder1.XOR.y;
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder1.s;
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder2.AND.G1.x[2];
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder2.AND.x[2];
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder2.XOR.G1.x[2];
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder2.XOR.x[2];
//   Adder4.Adder1.XOR.G2.y = Adder4.Adder2.a;
//   Adder4.Adder2.XOR.G2.y = Adder4.Adder2.XOR.y;
//   Adder4.Adder2.XOR.G2.y = Adder4.Adder2.s;
//   Adder4.Adder2.XOR.G2.y = Adder4.s;
//   Adder4.Adder2.AND.G2.y = Adder4.Adder2.AND.y;
//   Adder4.Adder2.AND.G2.y = Adder4.Adder2.c;
//   Adder4.Adder2.AND.G2.y = Adder4.OR.x[2];
//   Adder4.OR.y = Adder4.c_out;
//   Adder4.Adder1.XOR.G1.y = Adder4.Adder1.XOR.G2.x;
//   Adder4.Adder1.AND.G1.y = Adder4.Adder1.AND.G2.x;
//   Adder4.Adder2.XOR.G1.y = Adder4.Adder2.XOR.G2.x;
//   Adder4.Adder2.AND.G1.y = Adder4.Adder2.AND.G2.x;
//   Adder3.Adder1.AND.G2.y = Adder3.Adder1.AND.y;
//   Adder3.Adder1.AND.G2.y = Adder3.Adder1.c;
//   Adder3.Adder1.AND.G2.y = Adder3.OR.x[1];
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder1.XOR.y;
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder1.s;
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder2.AND.G1.x[2];
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder2.AND.x[2];
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder2.XOR.G1.x[2];
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder2.XOR.x[2];
//   Adder3.Adder1.XOR.G2.y = Adder3.Adder2.a;
//   Adder3.Adder2.XOR.G2.y = Adder3.Adder2.XOR.y;
//   Adder3.Adder2.XOR.G2.y = Adder3.Adder2.s;
//   Adder3.Adder2.XOR.G2.y = Adder3.s;
//   Adder3.Adder2.AND.G2.y = Adder3.Adder2.AND.y;
//   Adder3.Adder2.AND.G2.y = Adder3.Adder2.c;
//   Adder3.Adder2.AND.G2.y = Adder3.OR.x[2];
//   Adder3.Adder1.XOR.G1.y = Adder3.Adder1.XOR.G2.x;
//   Adder3.Adder1.AND.G1.y = Adder3.Adder1.AND.G2.x;
//   Adder3.Adder2.XOR.G1.y = Adder3.Adder2.XOR.G2.x;
//   Adder3.Adder2.AND.G1.y = Adder3.Adder2.AND.G2.x;
//   Adder2.Adder1.AND.G2.y = Adder2.Adder1.AND.y;
//   Adder2.Adder1.AND.G2.y = Adder2.Adder1.c;
//   Adder2.Adder1.AND.G2.y = Adder2.OR.x[1];
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder1.XOR.y;
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder1.s;
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder2.AND.G1.x[2];
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder2.AND.x[2];
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder2.XOR.G1.x[2];
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder2.XOR.x[2];
//   Adder2.Adder1.XOR.G2.y = Adder2.Adder2.a;
//   Adder2.Adder2.XOR.G2.y = Adder2.Adder2.XOR.y;
//   Adder2.Adder2.XOR.G2.y = Adder2.Adder2.s;
//   Adder2.Adder2.XOR.G2.y = Adder2.s;
//   Adder2.Adder2.AND.G2.y = Adder2.Adder2.AND.y;
//   Adder2.Adder2.AND.G2.y = Adder2.Adder2.c;
//   Adder2.Adder2.AND.G2.y = Adder2.OR.x[2];
//   Adder2.Adder1.XOR.G1.y = Adder2.Adder1.XOR.G2.x;
//   Adder2.Adder1.AND.G1.y = Adder2.Adder1.AND.G2.x;
//   Adder2.Adder2.XOR.G1.y = Adder2.Adder2.XOR.G2.x;
//   Adder2.Adder2.AND.G1.y = Adder2.Adder2.AND.G2.x;
//   Adder1.Adder1.AND.G2.y = Adder1.Adder1.AND.y;
//   Adder1.Adder1.AND.G2.y = Adder1.Adder1.c;
//   Adder1.Adder1.AND.G2.y = Adder1.OR.x[1];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder1.XOR.y;
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder1.s;
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.AND.G1.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.AND.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.XOR.G1.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.XOR.x[2];
//   Adder1.Adder1.XOR.G2.y = Adder1.Adder2.a;
//   Adder1.Adder2.XOR.G2.y = Adder1.Adder2.XOR.y;
//   Adder1.Adder2.XOR.G2.y = Adder1.Adder2.s;
//   Adder1.Adder2.XOR.G2.y = Adder1.s;
//   Adder1.Adder2.AND.G2.y = Adder1.Adder2.AND.y;
//   Adder1.Adder2.AND.G2.y = Adder1.Adder2.c;
//   Adder1.Adder2.AND.G2.y = Adder1.OR.x[2];
//   Adder1.Adder1.XOR.G1.y = Adder1.Adder1.XOR.G2.x;
//   Adder1.Adder1.AND.G1.y = Adder1.Adder1.AND.G2.x;
//   Adder1.Adder2.XOR.G1.y = Adder1.Adder2.XOR.G2.x;
//   Adder1.Adder2.AND.G1.y = Adder1.Adder2.AND.G2.x;
// algorithm
//   if initial() then
//     assert(b4.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:b4.n loop
//     end for;
//   end if;
//   b4.y := b4.y0;
//   for i in 1:b4.n loop
//     if time >= b4.t[i] then
//       b4.y := b4.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(b1.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:b1.n loop
//     end for;
//   end if;
//   b1.y := b1.y0;
//   for i in 1:b1.n loop
//     if time >= b1.t[i] then
//       b1.y := b1.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(b2.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:b2.n loop
//     end for;
//   end if;
//   b2.y := b2.y0;
//   for i in 1:b2.n loop
//     if time >= b2.t[i] then
//       b2.y := b2.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(b3.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:b3.n loop
//     end for;
//   end if;
//   b3.y := b3.y0;
//   for i in 1:b3.n loop
//     if time >= b3.t[i] then
//       b3.y := b3.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(a1.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:a1.n loop
//     end for;
//   end if;
//   a1.y := a1.y0;
//   for i in 1:a1.n loop
//     if time >= a1.t[i] then
//       a1.y := a1.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(a2.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:a2.n loop
//     end for;
//   end if;
//   a2.y := a2.y0;
//   for i in 1:a2.n loop
//     if time >= a2.t[i] then
//       a2.y := a2.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(a3.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:a3.n loop
//     end for;
//   end if;
//   a3.y := a3.y0;
//   for i in 1:a3.n loop
//     if time >= a3.t[i] then
//       a3.y := a3.x[i];
//     end if;
//   end for;
//   if initial() then
//     assert(a4.n > 0, "Invalid size of table (n < 1)");
//     for i in 1:a4.n loop
//     end for;
//   end if;
//   a4.y := a4.y0;
//   for i in 1:a4.n loop
//     if time >= a4.t[i] then
//       a4.y := a4.x[i];
//     end if;
//   end for;
//   Set.y := Set.x;
//   when {initial(),(Adder1.Adder2.AND.G2.tLH > 0.0 OR Adder1.Adder2.AND.G2.tHL > 0.0) AND change(Adder1.Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder1.Adder2.AND.G2.x_old := if initial() OR pre(Adder1.Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder2.AND.G2.y0 else pre(Adder1.Adder2.AND.G2.x);
//     Adder1.Adder2.AND.G2.lh := Adder1.Adder2.AND.G2.delayTable[Adder1.Adder2.AND.G2.x_old, Adder1.Adder2.AND.G2.x];
//     Adder1.Adder2.AND.G2.delayTime := if Adder1.Adder2.AND.G2.lh > 0 then Adder1.Adder2.AND.G2.tLH else if Adder1.Adder2.AND.G2.lh < 0 then Adder1.Adder2.AND.G2.tHL else 0.0;
//     Adder1.Adder2.AND.G2.t_next := time + Adder1.Adder2.AND.G2.delayTime;
//     if Adder1.Adder2.AND.G2.lh == 0 OR abs(Adder1.Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder1.Adder2.AND.G2.y_auxiliary := Adder1.Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder2.AND.G2.t_next then
//     Adder1.Adder2.AND.G2.y_auxiliary := Adder1.Adder2.AND.G2.x;
//   end when;
//   Adder1.Adder2.AND.G2.y := if Adder1.Adder2.AND.G2.tLH > 0.0 OR Adder1.Adder2.AND.G2.tHL > 0.0 then Adder1.Adder2.AND.G2.y_auxiliary else Adder1.Adder2.AND.G2.x;
//   when {initial(),(Adder1.Adder2.XOR.G2.tLH > 0.0 OR Adder1.Adder2.XOR.G2.tHL > 0.0) AND change(Adder1.Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder1.Adder2.XOR.G2.x_old := if initial() OR pre(Adder1.Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder2.XOR.G2.y0 else pre(Adder1.Adder2.XOR.G2.x);
//     Adder1.Adder2.XOR.G2.lh := Adder1.Adder2.XOR.G2.delayTable[Adder1.Adder2.XOR.G2.x_old, Adder1.Adder2.XOR.G2.x];
//     Adder1.Adder2.XOR.G2.delayTime := if Adder1.Adder2.XOR.G2.lh > 0 then Adder1.Adder2.XOR.G2.tLH else if Adder1.Adder2.XOR.G2.lh < 0 then Adder1.Adder2.XOR.G2.tHL else 0.0;
//     Adder1.Adder2.XOR.G2.t_next := time + Adder1.Adder2.XOR.G2.delayTime;
//     if Adder1.Adder2.XOR.G2.lh == 0 OR abs(Adder1.Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder1.Adder2.XOR.G2.y_auxiliary := Adder1.Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder2.XOR.G2.t_next then
//     Adder1.Adder2.XOR.G2.y_auxiliary := Adder1.Adder2.XOR.G2.x;
//   end when;
//   Adder1.Adder2.XOR.G2.y := if Adder1.Adder2.XOR.G2.tLH > 0.0 OR Adder1.Adder2.XOR.G2.tHL > 0.0 then Adder1.Adder2.XOR.G2.y_auxiliary else Adder1.Adder2.XOR.G2.x;
//   when {initial(),(Adder1.Adder1.AND.G2.tLH > 0.0 OR Adder1.Adder1.AND.G2.tHL > 0.0) AND change(Adder1.Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder1.Adder1.AND.G2.x_old := if initial() OR pre(Adder1.Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder1.AND.G2.y0 else pre(Adder1.Adder1.AND.G2.x);
//     Adder1.Adder1.AND.G2.lh := Adder1.Adder1.AND.G2.delayTable[Adder1.Adder1.AND.G2.x_old, Adder1.Adder1.AND.G2.x];
//     Adder1.Adder1.AND.G2.delayTime := if Adder1.Adder1.AND.G2.lh > 0 then Adder1.Adder1.AND.G2.tLH else if Adder1.Adder1.AND.G2.lh < 0 then Adder1.Adder1.AND.G2.tHL else 0.0;
//     Adder1.Adder1.AND.G2.t_next := time + Adder1.Adder1.AND.G2.delayTime;
//     if Adder1.Adder1.AND.G2.lh == 0 OR abs(Adder1.Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder1.Adder1.AND.G2.y_auxiliary := Adder1.Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder1.AND.G2.t_next then
//     Adder1.Adder1.AND.G2.y_auxiliary := Adder1.Adder1.AND.G2.x;
//   end when;
//   Adder1.Adder1.AND.G2.y := if Adder1.Adder1.AND.G2.tLH > 0.0 OR Adder1.Adder1.AND.G2.tHL > 0.0 then Adder1.Adder1.AND.G2.y_auxiliary else Adder1.Adder1.AND.G2.x;
//   when {initial(),(Adder1.Adder1.XOR.G2.tLH > 0.0 OR Adder1.Adder1.XOR.G2.tHL > 0.0) AND change(Adder1.Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder1.Adder1.XOR.G2.x_old := if initial() OR pre(Adder1.Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.Adder1.XOR.G2.y0 else pre(Adder1.Adder1.XOR.G2.x);
//     Adder1.Adder1.XOR.G2.lh := Adder1.Adder1.XOR.G2.delayTable[Adder1.Adder1.XOR.G2.x_old, Adder1.Adder1.XOR.G2.x];
//     Adder1.Adder1.XOR.G2.delayTime := if Adder1.Adder1.XOR.G2.lh > 0 then Adder1.Adder1.XOR.G2.tLH else if Adder1.Adder1.XOR.G2.lh < 0 then Adder1.Adder1.XOR.G2.tHL else 0.0;
//     Adder1.Adder1.XOR.G2.t_next := time + Adder1.Adder1.XOR.G2.delayTime;
//     if Adder1.Adder1.XOR.G2.lh == 0 OR abs(Adder1.Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder1.Adder1.XOR.G2.y_auxiliary := Adder1.Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder1.Adder1.XOR.G2.t_next then
//     Adder1.Adder1.XOR.G2.y_auxiliary := Adder1.Adder1.XOR.G2.x;
//   end when;
//   Adder1.Adder1.XOR.G2.y := if Adder1.Adder1.XOR.G2.tLH > 0.0 OR Adder1.Adder1.XOR.G2.tHL > 0.0 then Adder1.Adder1.XOR.G2.y_auxiliary else Adder1.Adder1.XOR.G2.x;
//   when {initial(),(Adder2.Adder2.AND.G2.tLH > 0.0 OR Adder2.Adder2.AND.G2.tHL > 0.0) AND change(Adder2.Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder2.Adder2.AND.G2.x_old := if initial() OR pre(Adder2.Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.Adder2.AND.G2.y0 else pre(Adder2.Adder2.AND.G2.x);
//     Adder2.Adder2.AND.G2.lh := Adder2.Adder2.AND.G2.delayTable[Adder2.Adder2.AND.G2.x_old, Adder2.Adder2.AND.G2.x];
//     Adder2.Adder2.AND.G2.delayTime := if Adder2.Adder2.AND.G2.lh > 0 then Adder2.Adder2.AND.G2.tLH else if Adder2.Adder2.AND.G2.lh < 0 then Adder2.Adder2.AND.G2.tHL else 0.0;
//     Adder2.Adder2.AND.G2.t_next := time + Adder2.Adder2.AND.G2.delayTime;
//     if Adder2.Adder2.AND.G2.lh == 0 OR abs(Adder2.Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder2.Adder2.AND.G2.y_auxiliary := Adder2.Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder2.Adder2.AND.G2.t_next then
//     Adder2.Adder2.AND.G2.y_auxiliary := Adder2.Adder2.AND.G2.x;
//   end when;
//   Adder2.Adder2.AND.G2.y := if Adder2.Adder2.AND.G2.tLH > 0.0 OR Adder2.Adder2.AND.G2.tHL > 0.0 then Adder2.Adder2.AND.G2.y_auxiliary else Adder2.Adder2.AND.G2.x;
//   when {initial(),(Adder2.Adder2.XOR.G2.tLH > 0.0 OR Adder2.Adder2.XOR.G2.tHL > 0.0) AND change(Adder2.Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder2.Adder2.XOR.G2.x_old := if initial() OR pre(Adder2.Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.Adder2.XOR.G2.y0 else pre(Adder2.Adder2.XOR.G2.x);
//     Adder2.Adder2.XOR.G2.lh := Adder2.Adder2.XOR.G2.delayTable[Adder2.Adder2.XOR.G2.x_old, Adder2.Adder2.XOR.G2.x];
//     Adder2.Adder2.XOR.G2.delayTime := if Adder2.Adder2.XOR.G2.lh > 0 then Adder2.Adder2.XOR.G2.tLH else if Adder2.Adder2.XOR.G2.lh < 0 then Adder2.Adder2.XOR.G2.tHL else 0.0;
//     Adder2.Adder2.XOR.G2.t_next := time + Adder2.Adder2.XOR.G2.delayTime;
//     if Adder2.Adder2.XOR.G2.lh == 0 OR abs(Adder2.Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder2.Adder2.XOR.G2.y_auxiliary := Adder2.Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder2.Adder2.XOR.G2.t_next then
//     Adder2.Adder2.XOR.G2.y_auxiliary := Adder2.Adder2.XOR.G2.x;
//   end when;
//   Adder2.Adder2.XOR.G2.y := if Adder2.Adder2.XOR.G2.tLH > 0.0 OR Adder2.Adder2.XOR.G2.tHL > 0.0 then Adder2.Adder2.XOR.G2.y_auxiliary else Adder2.Adder2.XOR.G2.x;
//   when {initial(),(Adder2.Adder1.AND.G2.tLH > 0.0 OR Adder2.Adder1.AND.G2.tHL > 0.0) AND change(Adder2.Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder2.Adder1.AND.G2.x_old := if initial() OR pre(Adder2.Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.Adder1.AND.G2.y0 else pre(Adder2.Adder1.AND.G2.x);
//     Adder2.Adder1.AND.G2.lh := Adder2.Adder1.AND.G2.delayTable[Adder2.Adder1.AND.G2.x_old, Adder2.Adder1.AND.G2.x];
//     Adder2.Adder1.AND.G2.delayTime := if Adder2.Adder1.AND.G2.lh > 0 then Adder2.Adder1.AND.G2.tLH else if Adder2.Adder1.AND.G2.lh < 0 then Adder2.Adder1.AND.G2.tHL else 0.0;
//     Adder2.Adder1.AND.G2.t_next := time + Adder2.Adder1.AND.G2.delayTime;
//     if Adder2.Adder1.AND.G2.lh == 0 OR abs(Adder2.Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder2.Adder1.AND.G2.y_auxiliary := Adder2.Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder2.Adder1.AND.G2.t_next then
//     Adder2.Adder1.AND.G2.y_auxiliary := Adder2.Adder1.AND.G2.x;
//   end when;
//   Adder2.Adder1.AND.G2.y := if Adder2.Adder1.AND.G2.tLH > 0.0 OR Adder2.Adder1.AND.G2.tHL > 0.0 then Adder2.Adder1.AND.G2.y_auxiliary else Adder2.Adder1.AND.G2.x;
//   when {initial(),(Adder2.Adder1.XOR.G2.tLH > 0.0 OR Adder2.Adder1.XOR.G2.tHL > 0.0) AND change(Adder2.Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder2.Adder1.XOR.G2.x_old := if initial() OR pre(Adder2.Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.Adder1.XOR.G2.y0 else pre(Adder2.Adder1.XOR.G2.x);
//     Adder2.Adder1.XOR.G2.lh := Adder2.Adder1.XOR.G2.delayTable[Adder2.Adder1.XOR.G2.x_old, Adder2.Adder1.XOR.G2.x];
//     Adder2.Adder1.XOR.G2.delayTime := if Adder2.Adder1.XOR.G2.lh > 0 then Adder2.Adder1.XOR.G2.tLH else if Adder2.Adder1.XOR.G2.lh < 0 then Adder2.Adder1.XOR.G2.tHL else 0.0;
//     Adder2.Adder1.XOR.G2.t_next := time + Adder2.Adder1.XOR.G2.delayTime;
//     if Adder2.Adder1.XOR.G2.lh == 0 OR abs(Adder2.Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder2.Adder1.XOR.G2.y_auxiliary := Adder2.Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder2.Adder1.XOR.G2.t_next then
//     Adder2.Adder1.XOR.G2.y_auxiliary := Adder2.Adder1.XOR.G2.x;
//   end when;
//   Adder2.Adder1.XOR.G2.y := if Adder2.Adder1.XOR.G2.tLH > 0.0 OR Adder2.Adder1.XOR.G2.tHL > 0.0 then Adder2.Adder1.XOR.G2.y_auxiliary else Adder2.Adder1.XOR.G2.x;
//   when {initial(),(Adder3.Adder2.AND.G2.tLH > 0.0 OR Adder3.Adder2.AND.G2.tHL > 0.0) AND change(Adder3.Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder3.Adder2.AND.G2.x_old := if initial() OR pre(Adder3.Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder3.Adder2.AND.G2.y0 else pre(Adder3.Adder2.AND.G2.x);
//     Adder3.Adder2.AND.G2.lh := Adder3.Adder2.AND.G2.delayTable[Adder3.Adder2.AND.G2.x_old, Adder3.Adder2.AND.G2.x];
//     Adder3.Adder2.AND.G2.delayTime := if Adder3.Adder2.AND.G2.lh > 0 then Adder3.Adder2.AND.G2.tLH else if Adder3.Adder2.AND.G2.lh < 0 then Adder3.Adder2.AND.G2.tHL else 0.0;
//     Adder3.Adder2.AND.G2.t_next := time + Adder3.Adder2.AND.G2.delayTime;
//     if Adder3.Adder2.AND.G2.lh == 0 OR abs(Adder3.Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder3.Adder2.AND.G2.y_auxiliary := Adder3.Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder3.Adder2.AND.G2.t_next then
//     Adder3.Adder2.AND.G2.y_auxiliary := Adder3.Adder2.AND.G2.x;
//   end when;
//   Adder3.Adder2.AND.G2.y := if Adder3.Adder2.AND.G2.tLH > 0.0 OR Adder3.Adder2.AND.G2.tHL > 0.0 then Adder3.Adder2.AND.G2.y_auxiliary else Adder3.Adder2.AND.G2.x;
//   when {initial(),(Adder3.Adder2.XOR.G2.tLH > 0.0 OR Adder3.Adder2.XOR.G2.tHL > 0.0) AND change(Adder3.Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder3.Adder2.XOR.G2.x_old := if initial() OR pre(Adder3.Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder3.Adder2.XOR.G2.y0 else pre(Adder3.Adder2.XOR.G2.x);
//     Adder3.Adder2.XOR.G2.lh := Adder3.Adder2.XOR.G2.delayTable[Adder3.Adder2.XOR.G2.x_old, Adder3.Adder2.XOR.G2.x];
//     Adder3.Adder2.XOR.G2.delayTime := if Adder3.Adder2.XOR.G2.lh > 0 then Adder3.Adder2.XOR.G2.tLH else if Adder3.Adder2.XOR.G2.lh < 0 then Adder3.Adder2.XOR.G2.tHL else 0.0;
//     Adder3.Adder2.XOR.G2.t_next := time + Adder3.Adder2.XOR.G2.delayTime;
//     if Adder3.Adder2.XOR.G2.lh == 0 OR abs(Adder3.Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder3.Adder2.XOR.G2.y_auxiliary := Adder3.Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder3.Adder2.XOR.G2.t_next then
//     Adder3.Adder2.XOR.G2.y_auxiliary := Adder3.Adder2.XOR.G2.x;
//   end when;
//   Adder3.Adder2.XOR.G2.y := if Adder3.Adder2.XOR.G2.tLH > 0.0 OR Adder3.Adder2.XOR.G2.tHL > 0.0 then Adder3.Adder2.XOR.G2.y_auxiliary else Adder3.Adder2.XOR.G2.x;
//   when {initial(),(Adder3.Adder1.AND.G2.tLH > 0.0 OR Adder3.Adder1.AND.G2.tHL > 0.0) AND change(Adder3.Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder3.Adder1.AND.G2.x_old := if initial() OR pre(Adder3.Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder3.Adder1.AND.G2.y0 else pre(Adder3.Adder1.AND.G2.x);
//     Adder3.Adder1.AND.G2.lh := Adder3.Adder1.AND.G2.delayTable[Adder3.Adder1.AND.G2.x_old, Adder3.Adder1.AND.G2.x];
//     Adder3.Adder1.AND.G2.delayTime := if Adder3.Adder1.AND.G2.lh > 0 then Adder3.Adder1.AND.G2.tLH else if Adder3.Adder1.AND.G2.lh < 0 then Adder3.Adder1.AND.G2.tHL else 0.0;
//     Adder3.Adder1.AND.G2.t_next := time + Adder3.Adder1.AND.G2.delayTime;
//     if Adder3.Adder1.AND.G2.lh == 0 OR abs(Adder3.Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder3.Adder1.AND.G2.y_auxiliary := Adder3.Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder3.Adder1.AND.G2.t_next then
//     Adder3.Adder1.AND.G2.y_auxiliary := Adder3.Adder1.AND.G2.x;
//   end when;
//   Adder3.Adder1.AND.G2.y := if Adder3.Adder1.AND.G2.tLH > 0.0 OR Adder3.Adder1.AND.G2.tHL > 0.0 then Adder3.Adder1.AND.G2.y_auxiliary else Adder3.Adder1.AND.G2.x;
//   when {initial(),(Adder3.Adder1.XOR.G2.tLH > 0.0 OR Adder3.Adder1.XOR.G2.tHL > 0.0) AND change(Adder3.Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder3.Adder1.XOR.G2.x_old := if initial() OR pre(Adder3.Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder3.Adder1.XOR.G2.y0 else pre(Adder3.Adder1.XOR.G2.x);
//     Adder3.Adder1.XOR.G2.lh := Adder3.Adder1.XOR.G2.delayTable[Adder3.Adder1.XOR.G2.x_old, Adder3.Adder1.XOR.G2.x];
//     Adder3.Adder1.XOR.G2.delayTime := if Adder3.Adder1.XOR.G2.lh > 0 then Adder3.Adder1.XOR.G2.tLH else if Adder3.Adder1.XOR.G2.lh < 0 then Adder3.Adder1.XOR.G2.tHL else 0.0;
//     Adder3.Adder1.XOR.G2.t_next := time + Adder3.Adder1.XOR.G2.delayTime;
//     if Adder3.Adder1.XOR.G2.lh == 0 OR abs(Adder3.Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder3.Adder1.XOR.G2.y_auxiliary := Adder3.Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder3.Adder1.XOR.G2.t_next then
//     Adder3.Adder1.XOR.G2.y_auxiliary := Adder3.Adder1.XOR.G2.x;
//   end when;
//   Adder3.Adder1.XOR.G2.y := if Adder3.Adder1.XOR.G2.tLH > 0.0 OR Adder3.Adder1.XOR.G2.tHL > 0.0 then Adder3.Adder1.XOR.G2.y_auxiliary else Adder3.Adder1.XOR.G2.x;
//   when {initial(),(Adder4.Adder2.AND.G2.tLH > 0.0 OR Adder4.Adder2.AND.G2.tHL > 0.0) AND change(Adder4.Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder4.Adder2.AND.G2.x_old := if initial() OR pre(Adder4.Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder4.Adder2.AND.G2.y0 else pre(Adder4.Adder2.AND.G2.x);
//     Adder4.Adder2.AND.G2.lh := Adder4.Adder2.AND.G2.delayTable[Adder4.Adder2.AND.G2.x_old, Adder4.Adder2.AND.G2.x];
//     Adder4.Adder2.AND.G2.delayTime := if Adder4.Adder2.AND.G2.lh > 0 then Adder4.Adder2.AND.G2.tLH else if Adder4.Adder2.AND.G2.lh < 0 then Adder4.Adder2.AND.G2.tHL else 0.0;
//     Adder4.Adder2.AND.G2.t_next := time + Adder4.Adder2.AND.G2.delayTime;
//     if Adder4.Adder2.AND.G2.lh == 0 OR abs(Adder4.Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder4.Adder2.AND.G2.y_auxiliary := Adder4.Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder4.Adder2.AND.G2.t_next then
//     Adder4.Adder2.AND.G2.y_auxiliary := Adder4.Adder2.AND.G2.x;
//   end when;
//   Adder4.Adder2.AND.G2.y := if Adder4.Adder2.AND.G2.tLH > 0.0 OR Adder4.Adder2.AND.G2.tHL > 0.0 then Adder4.Adder2.AND.G2.y_auxiliary else Adder4.Adder2.AND.G2.x;
//   when {initial(),(Adder4.Adder2.XOR.G2.tLH > 0.0 OR Adder4.Adder2.XOR.G2.tHL > 0.0) AND change(Adder4.Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder4.Adder2.XOR.G2.x_old := if initial() OR pre(Adder4.Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder4.Adder2.XOR.G2.y0 else pre(Adder4.Adder2.XOR.G2.x);
//     Adder4.Adder2.XOR.G2.lh := Adder4.Adder2.XOR.G2.delayTable[Adder4.Adder2.XOR.G2.x_old, Adder4.Adder2.XOR.G2.x];
//     Adder4.Adder2.XOR.G2.delayTime := if Adder4.Adder2.XOR.G2.lh > 0 then Adder4.Adder2.XOR.G2.tLH else if Adder4.Adder2.XOR.G2.lh < 0 then Adder4.Adder2.XOR.G2.tHL else 0.0;
//     Adder4.Adder2.XOR.G2.t_next := time + Adder4.Adder2.XOR.G2.delayTime;
//     if Adder4.Adder2.XOR.G2.lh == 0 OR abs(Adder4.Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder4.Adder2.XOR.G2.y_auxiliary := Adder4.Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder4.Adder2.XOR.G2.t_next then
//     Adder4.Adder2.XOR.G2.y_auxiliary := Adder4.Adder2.XOR.G2.x;
//   end when;
//   Adder4.Adder2.XOR.G2.y := if Adder4.Adder2.XOR.G2.tLH > 0.0 OR Adder4.Adder2.XOR.G2.tHL > 0.0 then Adder4.Adder2.XOR.G2.y_auxiliary else Adder4.Adder2.XOR.G2.x;
//   when {initial(),(Adder4.Adder1.AND.G2.tLH > 0.0 OR Adder4.Adder1.AND.G2.tHL > 0.0) AND change(Adder4.Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder4.Adder1.AND.G2.x_old := if initial() OR pre(Adder4.Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder4.Adder1.AND.G2.y0 else pre(Adder4.Adder1.AND.G2.x);
//     Adder4.Adder1.AND.G2.lh := Adder4.Adder1.AND.G2.delayTable[Adder4.Adder1.AND.G2.x_old, Adder4.Adder1.AND.G2.x];
//     Adder4.Adder1.AND.G2.delayTime := if Adder4.Adder1.AND.G2.lh > 0 then Adder4.Adder1.AND.G2.tLH else if Adder4.Adder1.AND.G2.lh < 0 then Adder4.Adder1.AND.G2.tHL else 0.0;
//     Adder4.Adder1.AND.G2.t_next := time + Adder4.Adder1.AND.G2.delayTime;
//     if Adder4.Adder1.AND.G2.lh == 0 OR abs(Adder4.Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder4.Adder1.AND.G2.y_auxiliary := Adder4.Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder4.Adder1.AND.G2.t_next then
//     Adder4.Adder1.AND.G2.y_auxiliary := Adder4.Adder1.AND.G2.x;
//   end when;
//   Adder4.Adder1.AND.G2.y := if Adder4.Adder1.AND.G2.tLH > 0.0 OR Adder4.Adder1.AND.G2.tHL > 0.0 then Adder4.Adder1.AND.G2.y_auxiliary else Adder4.Adder1.AND.G2.x;
//   when {initial(),(Adder4.Adder1.XOR.G2.tLH > 0.0 OR Adder4.Adder1.XOR.G2.tHL > 0.0) AND change(Adder4.Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder4.Adder1.XOR.G2.x_old := if initial() OR pre(Adder4.Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder4.Adder1.XOR.G2.y0 else pre(Adder4.Adder1.XOR.G2.x);
//     Adder4.Adder1.XOR.G2.lh := Adder4.Adder1.XOR.G2.delayTable[Adder4.Adder1.XOR.G2.x_old, Adder4.Adder1.XOR.G2.x];
//     Adder4.Adder1.XOR.G2.delayTime := if Adder4.Adder1.XOR.G2.lh > 0 then Adder4.Adder1.XOR.G2.tLH else if Adder4.Adder1.XOR.G2.lh < 0 then Adder4.Adder1.XOR.G2.tHL else 0.0;
//     Adder4.Adder1.XOR.G2.t_next := time + Adder4.Adder1.XOR.G2.delayTime;
//     if Adder4.Adder1.XOR.G2.lh == 0 OR abs(Adder4.Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder4.Adder1.XOR.G2.y_auxiliary := Adder4.Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder4.Adder1.XOR.G2.t_next then
//     Adder4.Adder1.XOR.G2.y_auxiliary := Adder4.Adder1.XOR.G2.x;
//   end when;
//   Adder4.Adder1.XOR.G2.y := if Adder4.Adder1.XOR.G2.tLH > 0.0 OR Adder4.Adder1.XOR.G2.tHL > 0.0 then Adder4.Adder1.XOR.G2.y_auxiliary else Adder4.Adder1.XOR.G2.x;
// end Modelica.Electrical.Digital.Examples.Adder4;
// "
// "[Digital.mo:499:7-503:28:writable] Warning: Component Set has the same name as its type Modelica.Electrical.Digital.Examples.Adder4.Sources.Set.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// "
// "Check of Modelica.Electrical.Digital.Examples.Adder4 completed successfully.
// 
// [Digital.mo:499:7-503:28:writable] Warning: Component Set has the same name as its type Modelica.Electrical.Digital.Examples.Adder4.Sources.Set.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// 
// Class Modelica.Electrical.Digital.Examples.Adder4 has 1617 equation(s) and 1617 variable(s).
// 1512 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Counter3
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.before(start = Modelica.Electrical.Digital.Interfaces.Logic.'0') "Logic value before step";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.after(start = Modelica.Electrical.Digital.Interfaces.Logic.'1') "Logic value after step";
//   parameter Real Enable.stepTime(start = 1.0) "step time";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.y;
//   parameter Real Clock.startTime(quantity = "Time", unit = "s", start = 0.0) "Output = offset for time < startTime";
//   parameter Real Clock.period(quantity = "Time", unit = "s", min = 1e-60, start = 1.0) "Time for one period";
//   parameter Real Clock.width(min = 1e-60, max = 100.0, start = 50.0) "Width of pulses in % of period";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Clock.y "Connector of Digital output signal";
//   protected Real Clock.t_i(quantity = "Time", unit = "s", start = Clock.startTime) "Start time of current period";
//   protected Real Clock.t_width(quantity = "Time", unit = "s") = Clock.period * Clock.width / 100.0;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.enable;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q2;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.count;
//   parameter Real Counter.FF1.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.k;
//   parameter Real Counter.FF1.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.q0 = Counter.FF1.q0 "initial value of output";
//   parameter Integer Counter.FF1.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF1.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF1.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.y0 = Counter.FF1.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS1.TD1.x_delayed;
//   parameter Real Counter.FF1.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.q0 = Counter.FF1.q0 "initial value of output";
//   parameter Integer Counter.FF1.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF1.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF1.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.y0 = Counter.FF1.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF1.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF1.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF1.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF2.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.k;
//   parameter Real Counter.FF2.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.q0 = Counter.FF2.q0 "initial value of output";
//   parameter Integer Counter.FF2.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF2.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF2.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.y0 = Counter.FF2.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS1.TD1.x_delayed;
//   parameter Real Counter.FF2.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.q0 = Counter.FF2.q0 "initial value of output";
//   parameter Integer Counter.FF2.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF2.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF2.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.y0 = Counter.FF2.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF2.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF2.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF2.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF3.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.k;
//   parameter Real Counter.FF3.RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.q0 = Counter.FF3.q0 "initial value of output";
//   parameter Integer Counter.FF3.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF3.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF3.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.y0 = Counter.FF3.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS1.TD1.x_delayed;
//   parameter Real Counter.FF3.RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.q0 = Counter.FF3.q0 "initial value of output";
//   parameter Integer Counter.FF3.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF3.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF3.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.y0 = Counter.FF3.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.RS2.TD1.x_delayed;
//   parameter Integer Counter.FF3.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF3.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF3.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q1;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q0;
// equation
//   Counter.FF1.RS1.Nor1.auxiliary[1] = Counter.FF1.RS1.Nor1.x[1];
//   Counter.FF1.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS1.Nor1.auxiliary[1],Counter.FF1.RS1.Nor1.x[2]];
//   Counter.FF1.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF1.RS1.Nor1.auxiliary[2]]);
//   Counter.FF1.RS1.Nor2.auxiliary[1] = Counter.FF1.RS1.Nor2.x[1];
//   Counter.FF1.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS1.Nor2.auxiliary[1],Counter.FF1.RS1.Nor2.x[2]];
//   Counter.FF1.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF1.RS1.Nor2.auxiliary[2]]);
//   Counter.FF1.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF1.RS1.TD1.x),Counter.FF1.RS1.TD1.delayTime,Counter.FF1.RS1.TD1.delayTime)));
//   Counter.FF1.RS1.TD1.y = if Counter.FF1.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF1.RS1.TD1.delayTime then Counter.FF1.RS1.TD1.x_delayed else Counter.FF1.RS1.TD1.y0 else pre(Counter.FF1.RS1.TD1.x);
//   Counter.FF1.RS2.Nor1.auxiliary[1] = Counter.FF1.RS2.Nor1.x[1];
//   Counter.FF1.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS2.Nor1.auxiliary[1],Counter.FF1.RS2.Nor1.x[2]];
//   Counter.FF1.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF1.RS2.Nor1.auxiliary[2]]);
//   Counter.FF1.RS2.Nor2.auxiliary[1] = Counter.FF1.RS2.Nor2.x[1];
//   Counter.FF1.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF1.RS2.Nor2.auxiliary[1],Counter.FF1.RS2.Nor2.x[2]];
//   Counter.FF1.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF1.RS2.Nor2.auxiliary[2]]);
//   Counter.FF1.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF1.RS2.TD1.x),Counter.FF1.RS2.TD1.delayTime,Counter.FF1.RS2.TD1.delayTime)));
//   Counter.FF1.RS2.TD1.y = if Counter.FF1.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF1.RS2.TD1.delayTime then Counter.FF1.RS2.TD1.x_delayed else Counter.FF1.RS2.TD1.y0 else pre(Counter.FF1.RS2.TD1.x);
//   Counter.FF1.And1.auxiliary[1] = Counter.FF1.And1.x[1];
//   Counter.FF1.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And1.auxiliary[1],Counter.FF1.And1.x[2]];
//   Counter.FF1.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF1.And1.auxiliary[2],Counter.FF1.And1.x[3]];
//   Counter.FF1.And1.y = pre(Counter.FF1.And1.auxiliary[3]);
//   Counter.FF1.And2.auxiliary[1] = Counter.FF1.And2.x[1];
//   Counter.FF1.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And2.auxiliary[1],Counter.FF1.And2.x[2]];
//   Counter.FF1.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF1.And2.auxiliary[2],Counter.FF1.And2.x[3]];
//   Counter.FF1.And2.y = pre(Counter.FF1.And2.auxiliary[3]);
//   Counter.FF1.And3.auxiliary[1] = Counter.FF1.And3.x[1];
//   Counter.FF1.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And3.auxiliary[1],Counter.FF1.And3.x[2]];
//   Counter.FF1.And3.y = pre(Counter.FF1.And3.auxiliary[2]);
//   Counter.FF1.And4.auxiliary[1] = Counter.FF1.And4.x[1];
//   Counter.FF1.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF1.And4.auxiliary[1],Counter.FF1.And4.x[2]];
//   Counter.FF1.And4.y = pre(Counter.FF1.And4.auxiliary[2]);
//   Counter.FF1.Not1.auxiliary = D.Tables.NotTable[Counter.FF1.Not1.x];
//   Counter.FF1.Not1.y = pre(Counter.FF1.Not1.auxiliary);
//   Counter.FF2.RS1.Nor1.auxiliary[1] = Counter.FF2.RS1.Nor1.x[1];
//   Counter.FF2.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS1.Nor1.auxiliary[1],Counter.FF2.RS1.Nor1.x[2]];
//   Counter.FF2.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF2.RS1.Nor1.auxiliary[2]]);
//   Counter.FF2.RS1.Nor2.auxiliary[1] = Counter.FF2.RS1.Nor2.x[1];
//   Counter.FF2.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS1.Nor2.auxiliary[1],Counter.FF2.RS1.Nor2.x[2]];
//   Counter.FF2.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF2.RS1.Nor2.auxiliary[2]]);
//   Counter.FF2.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF2.RS1.TD1.x),Counter.FF2.RS1.TD1.delayTime,Counter.FF2.RS1.TD1.delayTime)));
//   Counter.FF2.RS1.TD1.y = if Counter.FF2.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF2.RS1.TD1.delayTime then Counter.FF2.RS1.TD1.x_delayed else Counter.FF2.RS1.TD1.y0 else pre(Counter.FF2.RS1.TD1.x);
//   Counter.FF2.RS2.Nor1.auxiliary[1] = Counter.FF2.RS2.Nor1.x[1];
//   Counter.FF2.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS2.Nor1.auxiliary[1],Counter.FF2.RS2.Nor1.x[2]];
//   Counter.FF2.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF2.RS2.Nor1.auxiliary[2]]);
//   Counter.FF2.RS2.Nor2.auxiliary[1] = Counter.FF2.RS2.Nor2.x[1];
//   Counter.FF2.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF2.RS2.Nor2.auxiliary[1],Counter.FF2.RS2.Nor2.x[2]];
//   Counter.FF2.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF2.RS2.Nor2.auxiliary[2]]);
//   Counter.FF2.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF2.RS2.TD1.x),Counter.FF2.RS2.TD1.delayTime,Counter.FF2.RS2.TD1.delayTime)));
//   Counter.FF2.RS2.TD1.y = if Counter.FF2.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF2.RS2.TD1.delayTime then Counter.FF2.RS2.TD1.x_delayed else Counter.FF2.RS2.TD1.y0 else pre(Counter.FF2.RS2.TD1.x);
//   Counter.FF2.And1.auxiliary[1] = Counter.FF2.And1.x[1];
//   Counter.FF2.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And1.auxiliary[1],Counter.FF2.And1.x[2]];
//   Counter.FF2.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF2.And1.auxiliary[2],Counter.FF2.And1.x[3]];
//   Counter.FF2.And1.y = pre(Counter.FF2.And1.auxiliary[3]);
//   Counter.FF2.And2.auxiliary[1] = Counter.FF2.And2.x[1];
//   Counter.FF2.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And2.auxiliary[1],Counter.FF2.And2.x[2]];
//   Counter.FF2.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF2.And2.auxiliary[2],Counter.FF2.And2.x[3]];
//   Counter.FF2.And2.y = pre(Counter.FF2.And2.auxiliary[3]);
//   Counter.FF2.And3.auxiliary[1] = Counter.FF2.And3.x[1];
//   Counter.FF2.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And3.auxiliary[1],Counter.FF2.And3.x[2]];
//   Counter.FF2.And3.y = pre(Counter.FF2.And3.auxiliary[2]);
//   Counter.FF2.And4.auxiliary[1] = Counter.FF2.And4.x[1];
//   Counter.FF2.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF2.And4.auxiliary[1],Counter.FF2.And4.x[2]];
//   Counter.FF2.And4.y = pre(Counter.FF2.And4.auxiliary[2]);
//   Counter.FF2.Not1.auxiliary = D.Tables.NotTable[Counter.FF2.Not1.x];
//   Counter.FF2.Not1.y = pre(Counter.FF2.Not1.auxiliary);
//   Counter.FF3.RS1.Nor1.auxiliary[1] = Counter.FF3.RS1.Nor1.x[1];
//   Counter.FF3.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS1.Nor1.auxiliary[1],Counter.FF3.RS1.Nor1.x[2]];
//   Counter.FF3.RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF3.RS1.Nor1.auxiliary[2]]);
//   Counter.FF3.RS1.Nor2.auxiliary[1] = Counter.FF3.RS1.Nor2.x[1];
//   Counter.FF3.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS1.Nor2.auxiliary[1],Counter.FF3.RS1.Nor2.x[2]];
//   Counter.FF3.RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF3.RS1.Nor2.auxiliary[2]]);
//   Counter.FF3.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF3.RS1.TD1.x),Counter.FF3.RS1.TD1.delayTime,Counter.FF3.RS1.TD1.delayTime)));
//   Counter.FF3.RS1.TD1.y = if Counter.FF3.RS1.TD1.delayTime > 0.0 then if time >= Counter.FF3.RS1.TD1.delayTime then Counter.FF3.RS1.TD1.x_delayed else Counter.FF3.RS1.TD1.y0 else pre(Counter.FF3.RS1.TD1.x);
//   Counter.FF3.RS2.Nor1.auxiliary[1] = Counter.FF3.RS2.Nor1.x[1];
//   Counter.FF3.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS2.Nor1.auxiliary[1],Counter.FF3.RS2.Nor1.x[2]];
//   Counter.FF3.RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF3.RS2.Nor1.auxiliary[2]]);
//   Counter.FF3.RS2.Nor2.auxiliary[1] = Counter.FF3.RS2.Nor2.x[1];
//   Counter.FF3.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF3.RS2.Nor2.auxiliary[1],Counter.FF3.RS2.Nor2.x[2]];
//   Counter.FF3.RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF3.RS2.Nor2.auxiliary[2]]);
//   Counter.FF3.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF3.RS2.TD1.x),Counter.FF3.RS2.TD1.delayTime,Counter.FF3.RS2.TD1.delayTime)));
//   Counter.FF3.RS2.TD1.y = if Counter.FF3.RS2.TD1.delayTime > 0.0 then if time >= Counter.FF3.RS2.TD1.delayTime then Counter.FF3.RS2.TD1.x_delayed else Counter.FF3.RS2.TD1.y0 else pre(Counter.FF3.RS2.TD1.x);
//   Counter.FF3.And1.auxiliary[1] = Counter.FF3.And1.x[1];
//   Counter.FF3.And1.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And1.auxiliary[1],Counter.FF3.And1.x[2]];
//   Counter.FF3.And1.auxiliary[3] = D.Tables.AndTable[Counter.FF3.And1.auxiliary[2],Counter.FF3.And1.x[3]];
//   Counter.FF3.And1.y = pre(Counter.FF3.And1.auxiliary[3]);
//   Counter.FF3.And2.auxiliary[1] = Counter.FF3.And2.x[1];
//   Counter.FF3.And2.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And2.auxiliary[1],Counter.FF3.And2.x[2]];
//   Counter.FF3.And2.auxiliary[3] = D.Tables.AndTable[Counter.FF3.And2.auxiliary[2],Counter.FF3.And2.x[3]];
//   Counter.FF3.And2.y = pre(Counter.FF3.And2.auxiliary[3]);
//   Counter.FF3.And3.auxiliary[1] = Counter.FF3.And3.x[1];
//   Counter.FF3.And3.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And3.auxiliary[1],Counter.FF3.And3.x[2]];
//   Counter.FF3.And3.y = pre(Counter.FF3.And3.auxiliary[2]);
//   Counter.FF3.And4.auxiliary[1] = Counter.FF3.And4.x[1];
//   Counter.FF3.And4.auxiliary[2] = D.Tables.AndTable[Counter.FF3.And4.auxiliary[1],Counter.FF3.And4.x[2]];
//   Counter.FF3.And4.y = pre(Counter.FF3.And4.auxiliary[2]);
//   Counter.FF3.Not1.auxiliary = D.Tables.NotTable[Counter.FF3.Not1.x];
//   Counter.FF3.Not1.y = pre(Counter.FF3.Not1.auxiliary);
//   Clock.y = Counter.FF1.And1.x[1];
//   Clock.y = Counter.FF1.And2.x[3];
//   Clock.y = Counter.FF1.Not1.x;
//   Clock.y = Counter.FF1.clk;
//   Clock.y = Counter.count;
//   Counter.FF1.And1.x[2] = Counter.FF1.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF1.j;
//   Counter.FF1.And1.x[2] = Counter.FF1.k;
//   Counter.FF1.And1.x[2] = Counter.FF2.And1.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF2.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF2.j;
//   Counter.FF1.And1.x[2] = Counter.FF2.k;
//   Counter.FF1.And1.x[2] = Counter.FF3.And1.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF3.And2.x[2];
//   Counter.FF1.And1.x[2] = Counter.FF3.j;
//   Counter.FF1.And1.x[2] = Counter.FF3.k;
//   Counter.FF1.And1.x[2] = Counter.enable;
//   Counter.FF1.And1.x[2] = Enable.y;
//   Counter.FF2.And1.x[3] = Counter.FF2.RS1.Nor1.y;
//   Counter.FF2.And1.x[3] = Counter.FF2.RS1.TD1.x;
//   Counter.FF2.And1.x[3] = Counter.FF2.RS1.qn;
//   Counter.FF2.And1.x[3] = Counter.FF2.q;
//   Counter.FF2.And1.x[3] = Counter.FF3.And1.x[1];
//   Counter.FF2.And1.x[3] = Counter.FF3.And2.x[3];
//   Counter.FF2.And1.x[3] = Counter.FF3.Not1.x;
//   Counter.FF2.And1.x[3] = Counter.FF3.clk;
//   Counter.FF2.And1.x[3] = Counter.q1;
//   Counter.FF1.And1.x[3] = Counter.FF1.RS1.Nor1.y;
//   Counter.FF1.And1.x[3] = Counter.FF1.RS1.TD1.x;
//   Counter.FF1.And1.x[3] = Counter.FF1.RS1.qn;
//   Counter.FF1.And1.x[3] = Counter.FF1.q;
//   Counter.FF1.And1.x[3] = Counter.FF2.And1.x[1];
//   Counter.FF1.And1.x[3] = Counter.FF2.And2.x[3];
//   Counter.FF1.And1.x[3] = Counter.FF2.Not1.x;
//   Counter.FF1.And1.x[3] = Counter.FF2.clk;
//   Counter.FF1.And1.x[3] = Counter.q0;
//   Counter.FF3.And1.x[3] = Counter.FF3.RS1.Nor1.y;
//   Counter.FF3.And1.x[3] = Counter.FF3.RS1.TD1.x;
//   Counter.FF3.And1.x[3] = Counter.FF3.RS1.qn;
//   Counter.FF3.And1.x[3] = Counter.FF3.q;
//   Counter.FF3.And1.x[3] = Counter.q2;
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.Nor1.x[1];
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.Nor2.y;
//   Counter.FF3.And2.x[1] = Counter.FF3.RS1.q;
//   Counter.FF3.And2.x[1] = Counter.FF3.qn;
//   Counter.FF3.And3.x[1] = Counter.FF3.And4.x[1];
//   Counter.FF3.And3.x[1] = Counter.FF3.Not1.y;
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.Nor1.x[1];
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.Nor2.y;
//   Counter.FF3.And3.x[2] = Counter.FF3.RS2.q;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.Nor1.y;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.TD1.x;
//   Counter.FF3.And4.x[2] = Counter.FF3.RS2.qn;
//   Counter.FF3.And3.y = Counter.FF3.RS1.Nor1.x[2];
//   Counter.FF3.And3.y = Counter.FF3.RS1.s;
//   Counter.FF3.And4.y = Counter.FF3.RS1.Nor2.x[1];
//   Counter.FF3.And4.y = Counter.FF3.RS1.r;
//   Counter.FF3.And1.y = Counter.FF3.RS2.Nor1.x[2];
//   Counter.FF3.And1.y = Counter.FF3.RS2.s;
//   Counter.FF3.And2.y = Counter.FF3.RS2.Nor2.x[1];
//   Counter.FF3.And2.y = Counter.FF3.RS2.r;
//   Counter.FF3.RS2.Nor2.x[2] = Counter.FF3.RS2.TD1.y;
//   Counter.FF3.RS1.Nor2.x[2] = Counter.FF3.RS1.TD1.y;
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.Nor1.x[1];
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.Nor2.y;
//   Counter.FF2.And2.x[1] = Counter.FF2.RS1.q;
//   Counter.FF2.And2.x[1] = Counter.FF2.qn;
//   Counter.FF2.And3.x[1] = Counter.FF2.And4.x[1];
//   Counter.FF2.And3.x[1] = Counter.FF2.Not1.y;
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.Nor1.x[1];
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.Nor2.y;
//   Counter.FF2.And3.x[2] = Counter.FF2.RS2.q;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.Nor1.y;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.TD1.x;
//   Counter.FF2.And4.x[2] = Counter.FF2.RS2.qn;
//   Counter.FF2.And3.y = Counter.FF2.RS1.Nor1.x[2];
//   Counter.FF2.And3.y = Counter.FF2.RS1.s;
//   Counter.FF2.And4.y = Counter.FF2.RS1.Nor2.x[1];
//   Counter.FF2.And4.y = Counter.FF2.RS1.r;
//   Counter.FF2.And1.y = Counter.FF2.RS2.Nor1.x[2];
//   Counter.FF2.And1.y = Counter.FF2.RS2.s;
//   Counter.FF2.And2.y = Counter.FF2.RS2.Nor2.x[1];
//   Counter.FF2.And2.y = Counter.FF2.RS2.r;
//   Counter.FF2.RS2.Nor2.x[2] = Counter.FF2.RS2.TD1.y;
//   Counter.FF2.RS1.Nor2.x[2] = Counter.FF2.RS1.TD1.y;
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.Nor1.x[1];
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.Nor2.y;
//   Counter.FF1.And2.x[1] = Counter.FF1.RS1.q;
//   Counter.FF1.And2.x[1] = Counter.FF1.qn;
//   Counter.FF1.And3.x[1] = Counter.FF1.And4.x[1];
//   Counter.FF1.And3.x[1] = Counter.FF1.Not1.y;
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.Nor1.x[1];
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.Nor2.y;
//   Counter.FF1.And3.x[2] = Counter.FF1.RS2.q;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.Nor1.y;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.TD1.x;
//   Counter.FF1.And4.x[2] = Counter.FF1.RS2.qn;
//   Counter.FF1.And3.y = Counter.FF1.RS1.Nor1.x[2];
//   Counter.FF1.And3.y = Counter.FF1.RS1.s;
//   Counter.FF1.And4.y = Counter.FF1.RS1.Nor2.x[1];
//   Counter.FF1.And4.y = Counter.FF1.RS1.r;
//   Counter.FF1.And1.y = Counter.FF1.RS2.Nor1.x[2];
//   Counter.FF1.And1.y = Counter.FF1.RS2.s;
//   Counter.FF1.And2.y = Counter.FF1.RS2.Nor2.x[1];
//   Counter.FF1.And2.y = Counter.FF1.RS2.r;
//   Counter.FF1.RS2.Nor2.x[2] = Counter.FF1.RS2.TD1.y;
//   Counter.FF1.RS1.Nor2.x[2] = Counter.FF1.RS1.TD1.y;
// algorithm
//   when initial() then
//     Enable.y := Enable.before;
//   end when;
//   if time >= Enable.stepTime then
//     Enable.y := Enable.after;
//   else
//     Enable.y := Enable.before;
//   end if;
//   when sample(Clock.startTime,Clock.period) then
//     Clock.t_i := time;
//   end when;
//   Clock.y := if  NOT time >= Clock.startTime OR time >= Clock.t_i + Clock.t_width then Modelica.Electrical.Digital.Interfaces.Logic.'0' else Modelica.Electrical.Digital.Interfaces.Logic.'1';
// end Modelica.Electrical.Digital.Examples.Counter3;
// "
// "[Digital.mo:610:7-611:51:writable] Warning: Component Clock has the same name as its type Modelica.Electrical.Digital.Examples.Counter3.D.Sources.Clock.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// "
// "Check of Modelica.Electrical.Digital.Examples.Counter3 completed successfully.
// 
// [Digital.mo:610:7-611:51:writable] Warning: Component Clock has the same name as its type Modelica.Electrical.Digital.Examples.Counter3.D.Sources.Clock.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// 
// Class Modelica.Electrical.Digital.Examples.Counter3 has 207 equation(s) and 207 variable(s).
// 203 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Counter
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.before(start = Modelica.Electrical.Digital.Interfaces.Logic.'0') "Logic value before step";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.after(start = Modelica.Electrical.Digital.Interfaces.Logic.'1') "Logic value after step";
//   parameter Real Enable.stepTime(start = 1.0) "step time";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Enable.y;
//   parameter Real Clock.startTime(quantity = "Time", unit = "s", start = 0.0) "Output = offset for time < startTime";
//   parameter Real Clock.period(quantity = "Time", unit = "s", min = 1e-60, start = 1.0) "Time for one period";
//   parameter Real Clock.width(min = 1e-60, max = 100.0, start = 50.0) "Width of pulses in % of period";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Clock.y "Connector of Digital output signal";
//   protected Real Clock.t_i(quantity = "Time", unit = "s", start = Clock.startTime) "Start time of current period";
//   protected Real Clock.t_width(quantity = "Time", unit = "s") = Clock.period * Clock.width / 100.0;
//   parameter Integer Counter.n = 4 "number of bits";
//   parameter Real Counter.delayTime(quantity = "Time", unit = "s") = 0.001 "delay of each JKFF";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.enable;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.count;
//   parameter Real Counter.FF[1].delayTime(quantity = "Time", unit = "s") = Counter.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].q0 = Counter.q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].k;
//   parameter Real Counter.FF[1].RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF[1].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.q0 = Counter.FF[1].q0 "initial value of output";
//   parameter Integer Counter.FF[1].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[1].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[1].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[1].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.TD1.y0 = Counter.FF[1].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS1.TD1.x_delayed;
//   parameter Real Counter.FF[1].RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF[1].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.q0 = Counter.FF[1].q0 "initial value of output";
//   parameter Integer Counter.FF[1].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[1].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[1].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[1].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.TD1.y0 = Counter.FF[1].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].RS2.TD1.x_delayed;
//   parameter Integer Counter.FF[1].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[1].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[1].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[1].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[1].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF[2].delayTime(quantity = "Time", unit = "s") = Counter.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].q0 = Counter.q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].k;
//   parameter Real Counter.FF[2].RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF[2].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.q0 = Counter.FF[2].q0 "initial value of output";
//   parameter Integer Counter.FF[2].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[2].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[2].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[2].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.TD1.y0 = Counter.FF[2].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS1.TD1.x_delayed;
//   parameter Real Counter.FF[2].RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF[2].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.q0 = Counter.FF[2].q0 "initial value of output";
//   parameter Integer Counter.FF[2].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[2].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[2].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[2].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.TD1.y0 = Counter.FF[2].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].RS2.TD1.x_delayed;
//   parameter Integer Counter.FF[2].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[2].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[2].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[2].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[2].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF[3].delayTime(quantity = "Time", unit = "s") = Counter.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].q0 = Counter.q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].k;
//   parameter Real Counter.FF[3].RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF[3].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.q0 = Counter.FF[3].q0 "initial value of output";
//   parameter Integer Counter.FF[3].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[3].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[3].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[3].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.TD1.y0 = Counter.FF[3].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS1.TD1.x_delayed;
//   parameter Real Counter.FF[3].RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF[3].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.q0 = Counter.FF[3].q0 "initial value of output";
//   parameter Integer Counter.FF[3].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[3].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[3].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[3].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.TD1.y0 = Counter.FF[3].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].RS2.TD1.x_delayed;
//   parameter Integer Counter.FF[3].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[3].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[3].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[3].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[3].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real Counter.FF[4].delayTime(quantity = "Time", unit = "s") = Counter.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].q0 = Counter.q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].k;
//   parameter Real Counter.FF[4].RS1.delayTime(quantity = "Time", unit = "s") = Counter.FF[4].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.q0 = Counter.FF[4].q0 "initial value of output";
//   parameter Integer Counter.FF[4].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[4].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[4].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[4].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.TD1.y0 = Counter.FF[4].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS1.TD1.x_delayed;
//   parameter Real Counter.FF[4].RS2.delayTime(quantity = "Time", unit = "s") = Counter.FF[4].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.q0 = Counter.FF[4].q0 "initial value of output";
//   parameter Integer Counter.FF[4].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[4].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real Counter.FF[4].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = Counter.FF[4].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.TD1.y0 = Counter.FF[4].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].RS2.TD1.x_delayed;
//   parameter Integer Counter.FF[4].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[4].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[4].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Counter.FF[4].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.FF[4].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q[1];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q[2];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q[3];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Counter.q[4];
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Q0.x[1];
//   output Real Q0.y[1];
//   parameter Integer Q0.n(min = 1, start = 1) "signal width";
//   parameter Real Q0.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real Q0.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real Q0.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real Q0.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real Q0.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real Q0.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real Q0.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real Q0.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real Q0.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Q1.x[1];
//   output Real Q1.y[1];
//   parameter Integer Q1.n(min = 1, start = 1) "signal width";
//   parameter Real Q1.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real Q1.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real Q1.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real Q1.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real Q1.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real Q1.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real Q1.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real Q1.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real Q1.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Q2.x[1];
//   output Real Q2.y[1];
//   parameter Integer Q2.n(min = 1, start = 1) "signal width";
//   parameter Real Q2.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real Q2.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real Q2.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real Q2.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real Q2.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real Q2.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real Q2.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real Q2.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real Q2.value_m(start = 0.5) "value for digital m (Don't care)";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Q3.x[1];
//   output Real Q3.y[1];
//   parameter Integer Q3.n(min = 1, start = 1) "signal width";
//   parameter Real Q3.value_U(start = 0.5) "value for digital U (uninitialized)";
//   parameter Real Q3.value_X(start = 0.5) "value for digital X (Forcing Unknown)";
//   parameter Real Q3.value_0(start = 0.0) "value for digital 0   (Forcing 0)";
//   parameter Real Q3.value_1(start = 1.0) "value for digital 1 (Forcing 1)";
//   parameter Real Q3.value_Z(start = 0.5) "value for digital Z (High Impedance)";
//   parameter Real Q3.value_W(start = 0.5) "value for digital W (Weak    Unknown)";
//   parameter Real Q3.value_L(start = 0.0) "value for digital L (Weak    0)";
//   parameter Real Q3.value_H(start = 1.0) "value for digital H (Weak    1)";
//   parameter Real Q3.value_m(start = 0.5) "value for digital m (Don't care)";
// equation
//   Counter.FF[1].RS1.Nor1.auxiliary[1] = Counter.FF[1].RS1.Nor1.x[1];
//   Counter.FF[1].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[1].RS1.Nor1.auxiliary[1],Counter.FF[1].RS1.Nor1.x[2]];
//   Counter.FF[1].RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF[1].RS1.Nor1.auxiliary[2]]);
//   Counter.FF[1].RS1.Nor2.auxiliary[1] = Counter.FF[1].RS1.Nor2.x[1];
//   Counter.FF[1].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[1].RS1.Nor2.auxiliary[1],Counter.FF[1].RS1.Nor2.x[2]];
//   Counter.FF[1].RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF[1].RS1.Nor2.auxiliary[2]]);
//   Counter.FF[1].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[1].RS1.TD1.x),Counter.FF[1].RS1.TD1.delayTime,Counter.FF[1].RS1.TD1.delayTime)));
//   Counter.FF[1].RS1.TD1.y = if Counter.FF[1].RS1.TD1.delayTime > 0.0 then if time >= Counter.FF[1].RS1.TD1.delayTime then Counter.FF[1].RS1.TD1.x_delayed else Counter.FF[1].RS1.TD1.y0 else pre(Counter.FF[1].RS1.TD1.x);
//   Counter.FF[1].RS2.Nor1.auxiliary[1] = Counter.FF[1].RS2.Nor1.x[1];
//   Counter.FF[1].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[1].RS2.Nor1.auxiliary[1],Counter.FF[1].RS2.Nor1.x[2]];
//   Counter.FF[1].RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF[1].RS2.Nor1.auxiliary[2]]);
//   Counter.FF[1].RS2.Nor2.auxiliary[1] = Counter.FF[1].RS2.Nor2.x[1];
//   Counter.FF[1].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[1].RS2.Nor2.auxiliary[1],Counter.FF[1].RS2.Nor2.x[2]];
//   Counter.FF[1].RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF[1].RS2.Nor2.auxiliary[2]]);
//   Counter.FF[1].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[1].RS2.TD1.x),Counter.FF[1].RS2.TD1.delayTime,Counter.FF[1].RS2.TD1.delayTime)));
//   Counter.FF[1].RS2.TD1.y = if Counter.FF[1].RS2.TD1.delayTime > 0.0 then if time >= Counter.FF[1].RS2.TD1.delayTime then Counter.FF[1].RS2.TD1.x_delayed else Counter.FF[1].RS2.TD1.y0 else pre(Counter.FF[1].RS2.TD1.x);
//   Counter.FF[1].And1.auxiliary[1] = Counter.FF[1].And1.x[1];
//   Counter.FF[1].And1.auxiliary[2] = D.Tables.AndTable[Counter.FF[1].And1.auxiliary[1],Counter.FF[1].And1.x[2]];
//   Counter.FF[1].And1.auxiliary[3] = D.Tables.AndTable[Counter.FF[1].And1.auxiliary[2],Counter.FF[1].And1.x[3]];
//   Counter.FF[1].And1.y = pre(Counter.FF[1].And1.auxiliary[3]);
//   Counter.FF[1].And2.auxiliary[1] = Counter.FF[1].And2.x[1];
//   Counter.FF[1].And2.auxiliary[2] = D.Tables.AndTable[Counter.FF[1].And2.auxiliary[1],Counter.FF[1].And2.x[2]];
//   Counter.FF[1].And2.auxiliary[3] = D.Tables.AndTable[Counter.FF[1].And2.auxiliary[2],Counter.FF[1].And2.x[3]];
//   Counter.FF[1].And2.y = pre(Counter.FF[1].And2.auxiliary[3]);
//   Counter.FF[1].And3.auxiliary[1] = Counter.FF[1].And3.x[1];
//   Counter.FF[1].And3.auxiliary[2] = D.Tables.AndTable[Counter.FF[1].And3.auxiliary[1],Counter.FF[1].And3.x[2]];
//   Counter.FF[1].And3.y = pre(Counter.FF[1].And3.auxiliary[2]);
//   Counter.FF[1].And4.auxiliary[1] = Counter.FF[1].And4.x[1];
//   Counter.FF[1].And4.auxiliary[2] = D.Tables.AndTable[Counter.FF[1].And4.auxiliary[1],Counter.FF[1].And4.x[2]];
//   Counter.FF[1].And4.y = pre(Counter.FF[1].And4.auxiliary[2]);
//   Counter.FF[1].Not1.auxiliary = D.Tables.NotTable[Counter.FF[1].Not1.x];
//   Counter.FF[1].Not1.y = pre(Counter.FF[1].Not1.auxiliary);
//   Counter.FF[2].RS1.Nor1.auxiliary[1] = Counter.FF[2].RS1.Nor1.x[1];
//   Counter.FF[2].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[2].RS1.Nor1.auxiliary[1],Counter.FF[2].RS1.Nor1.x[2]];
//   Counter.FF[2].RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF[2].RS1.Nor1.auxiliary[2]]);
//   Counter.FF[2].RS1.Nor2.auxiliary[1] = Counter.FF[2].RS1.Nor2.x[1];
//   Counter.FF[2].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[2].RS1.Nor2.auxiliary[1],Counter.FF[2].RS1.Nor2.x[2]];
//   Counter.FF[2].RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF[2].RS1.Nor2.auxiliary[2]]);
//   Counter.FF[2].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[2].RS1.TD1.x),Counter.FF[2].RS1.TD1.delayTime,Counter.FF[2].RS1.TD1.delayTime)));
//   Counter.FF[2].RS1.TD1.y = if Counter.FF[2].RS1.TD1.delayTime > 0.0 then if time >= Counter.FF[2].RS1.TD1.delayTime then Counter.FF[2].RS1.TD1.x_delayed else Counter.FF[2].RS1.TD1.y0 else pre(Counter.FF[2].RS1.TD1.x);
//   Counter.FF[2].RS2.Nor1.auxiliary[1] = Counter.FF[2].RS2.Nor1.x[1];
//   Counter.FF[2].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[2].RS2.Nor1.auxiliary[1],Counter.FF[2].RS2.Nor1.x[2]];
//   Counter.FF[2].RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF[2].RS2.Nor1.auxiliary[2]]);
//   Counter.FF[2].RS2.Nor2.auxiliary[1] = Counter.FF[2].RS2.Nor2.x[1];
//   Counter.FF[2].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[2].RS2.Nor2.auxiliary[1],Counter.FF[2].RS2.Nor2.x[2]];
//   Counter.FF[2].RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF[2].RS2.Nor2.auxiliary[2]]);
//   Counter.FF[2].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[2].RS2.TD1.x),Counter.FF[2].RS2.TD1.delayTime,Counter.FF[2].RS2.TD1.delayTime)));
//   Counter.FF[2].RS2.TD1.y = if Counter.FF[2].RS2.TD1.delayTime > 0.0 then if time >= Counter.FF[2].RS2.TD1.delayTime then Counter.FF[2].RS2.TD1.x_delayed else Counter.FF[2].RS2.TD1.y0 else pre(Counter.FF[2].RS2.TD1.x);
//   Counter.FF[2].And1.auxiliary[1] = Counter.FF[2].And1.x[1];
//   Counter.FF[2].And1.auxiliary[2] = D.Tables.AndTable[Counter.FF[2].And1.auxiliary[1],Counter.FF[2].And1.x[2]];
//   Counter.FF[2].And1.auxiliary[3] = D.Tables.AndTable[Counter.FF[2].And1.auxiliary[2],Counter.FF[2].And1.x[3]];
//   Counter.FF[2].And1.y = pre(Counter.FF[2].And1.auxiliary[3]);
//   Counter.FF[2].And2.auxiliary[1] = Counter.FF[2].And2.x[1];
//   Counter.FF[2].And2.auxiliary[2] = D.Tables.AndTable[Counter.FF[2].And2.auxiliary[1],Counter.FF[2].And2.x[2]];
//   Counter.FF[2].And2.auxiliary[3] = D.Tables.AndTable[Counter.FF[2].And2.auxiliary[2],Counter.FF[2].And2.x[3]];
//   Counter.FF[2].And2.y = pre(Counter.FF[2].And2.auxiliary[3]);
//   Counter.FF[2].And3.auxiliary[1] = Counter.FF[2].And3.x[1];
//   Counter.FF[2].And3.auxiliary[2] = D.Tables.AndTable[Counter.FF[2].And3.auxiliary[1],Counter.FF[2].And3.x[2]];
//   Counter.FF[2].And3.y = pre(Counter.FF[2].And3.auxiliary[2]);
//   Counter.FF[2].And4.auxiliary[1] = Counter.FF[2].And4.x[1];
//   Counter.FF[2].And4.auxiliary[2] = D.Tables.AndTable[Counter.FF[2].And4.auxiliary[1],Counter.FF[2].And4.x[2]];
//   Counter.FF[2].And4.y = pre(Counter.FF[2].And4.auxiliary[2]);
//   Counter.FF[2].Not1.auxiliary = D.Tables.NotTable[Counter.FF[2].Not1.x];
//   Counter.FF[2].Not1.y = pre(Counter.FF[2].Not1.auxiliary);
//   Counter.FF[3].RS1.Nor1.auxiliary[1] = Counter.FF[3].RS1.Nor1.x[1];
//   Counter.FF[3].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[3].RS1.Nor1.auxiliary[1],Counter.FF[3].RS1.Nor1.x[2]];
//   Counter.FF[3].RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF[3].RS1.Nor1.auxiliary[2]]);
//   Counter.FF[3].RS1.Nor2.auxiliary[1] = Counter.FF[3].RS1.Nor2.x[1];
//   Counter.FF[3].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[3].RS1.Nor2.auxiliary[1],Counter.FF[3].RS1.Nor2.x[2]];
//   Counter.FF[3].RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF[3].RS1.Nor2.auxiliary[2]]);
//   Counter.FF[3].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[3].RS1.TD1.x),Counter.FF[3].RS1.TD1.delayTime,Counter.FF[3].RS1.TD1.delayTime)));
//   Counter.FF[3].RS1.TD1.y = if Counter.FF[3].RS1.TD1.delayTime > 0.0 then if time >= Counter.FF[3].RS1.TD1.delayTime then Counter.FF[3].RS1.TD1.x_delayed else Counter.FF[3].RS1.TD1.y0 else pre(Counter.FF[3].RS1.TD1.x);
//   Counter.FF[3].RS2.Nor1.auxiliary[1] = Counter.FF[3].RS2.Nor1.x[1];
//   Counter.FF[3].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[3].RS2.Nor1.auxiliary[1],Counter.FF[3].RS2.Nor1.x[2]];
//   Counter.FF[3].RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF[3].RS2.Nor1.auxiliary[2]]);
//   Counter.FF[3].RS2.Nor2.auxiliary[1] = Counter.FF[3].RS2.Nor2.x[1];
//   Counter.FF[3].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[3].RS2.Nor2.auxiliary[1],Counter.FF[3].RS2.Nor2.x[2]];
//   Counter.FF[3].RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF[3].RS2.Nor2.auxiliary[2]]);
//   Counter.FF[3].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[3].RS2.TD1.x),Counter.FF[3].RS2.TD1.delayTime,Counter.FF[3].RS2.TD1.delayTime)));
//   Counter.FF[3].RS2.TD1.y = if Counter.FF[3].RS2.TD1.delayTime > 0.0 then if time >= Counter.FF[3].RS2.TD1.delayTime then Counter.FF[3].RS2.TD1.x_delayed else Counter.FF[3].RS2.TD1.y0 else pre(Counter.FF[3].RS2.TD1.x);
//   Counter.FF[3].And1.auxiliary[1] = Counter.FF[3].And1.x[1];
//   Counter.FF[3].And1.auxiliary[2] = D.Tables.AndTable[Counter.FF[3].And1.auxiliary[1],Counter.FF[3].And1.x[2]];
//   Counter.FF[3].And1.auxiliary[3] = D.Tables.AndTable[Counter.FF[3].And1.auxiliary[2],Counter.FF[3].And1.x[3]];
//   Counter.FF[3].And1.y = pre(Counter.FF[3].And1.auxiliary[3]);
//   Counter.FF[3].And2.auxiliary[1] = Counter.FF[3].And2.x[1];
//   Counter.FF[3].And2.auxiliary[2] = D.Tables.AndTable[Counter.FF[3].And2.auxiliary[1],Counter.FF[3].And2.x[2]];
//   Counter.FF[3].And2.auxiliary[3] = D.Tables.AndTable[Counter.FF[3].And2.auxiliary[2],Counter.FF[3].And2.x[3]];
//   Counter.FF[3].And2.y = pre(Counter.FF[3].And2.auxiliary[3]);
//   Counter.FF[3].And3.auxiliary[1] = Counter.FF[3].And3.x[1];
//   Counter.FF[3].And3.auxiliary[2] = D.Tables.AndTable[Counter.FF[3].And3.auxiliary[1],Counter.FF[3].And3.x[2]];
//   Counter.FF[3].And3.y = pre(Counter.FF[3].And3.auxiliary[2]);
//   Counter.FF[3].And4.auxiliary[1] = Counter.FF[3].And4.x[1];
//   Counter.FF[3].And4.auxiliary[2] = D.Tables.AndTable[Counter.FF[3].And4.auxiliary[1],Counter.FF[3].And4.x[2]];
//   Counter.FF[3].And4.y = pre(Counter.FF[3].And4.auxiliary[2]);
//   Counter.FF[3].Not1.auxiliary = D.Tables.NotTable[Counter.FF[3].Not1.x];
//   Counter.FF[3].Not1.y = pre(Counter.FF[3].Not1.auxiliary);
//   Counter.FF[4].RS1.Nor1.auxiliary[1] = Counter.FF[4].RS1.Nor1.x[1];
//   Counter.FF[4].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[4].RS1.Nor1.auxiliary[1],Counter.FF[4].RS1.Nor1.x[2]];
//   Counter.FF[4].RS1.Nor1.y = pre(D.Tables.NotTable[Counter.FF[4].RS1.Nor1.auxiliary[2]]);
//   Counter.FF[4].RS1.Nor2.auxiliary[1] = Counter.FF[4].RS1.Nor2.x[1];
//   Counter.FF[4].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[4].RS1.Nor2.auxiliary[1],Counter.FF[4].RS1.Nor2.x[2]];
//   Counter.FF[4].RS1.Nor2.y = pre(D.Tables.NotTable[Counter.FF[4].RS1.Nor2.auxiliary[2]]);
//   Counter.FF[4].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[4].RS1.TD1.x),Counter.FF[4].RS1.TD1.delayTime,Counter.FF[4].RS1.TD1.delayTime)));
//   Counter.FF[4].RS1.TD1.y = if Counter.FF[4].RS1.TD1.delayTime > 0.0 then if time >= Counter.FF[4].RS1.TD1.delayTime then Counter.FF[4].RS1.TD1.x_delayed else Counter.FF[4].RS1.TD1.y0 else pre(Counter.FF[4].RS1.TD1.x);
//   Counter.FF[4].RS2.Nor1.auxiliary[1] = Counter.FF[4].RS2.Nor1.x[1];
//   Counter.FF[4].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[Counter.FF[4].RS2.Nor1.auxiliary[1],Counter.FF[4].RS2.Nor1.x[2]];
//   Counter.FF[4].RS2.Nor1.y = pre(D.Tables.NotTable[Counter.FF[4].RS2.Nor1.auxiliary[2]]);
//   Counter.FF[4].RS2.Nor2.auxiliary[1] = Counter.FF[4].RS2.Nor2.x[1];
//   Counter.FF[4].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[Counter.FF[4].RS2.Nor2.auxiliary[1],Counter.FF[4].RS2.Nor2.x[2]];
//   Counter.FF[4].RS2.Nor2.y = pre(D.Tables.NotTable[Counter.FF[4].RS2.Nor2.auxiliary[2]]);
//   Counter.FF[4].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(Counter.FF[4].RS2.TD1.x),Counter.FF[4].RS2.TD1.delayTime,Counter.FF[4].RS2.TD1.delayTime)));
//   Counter.FF[4].RS2.TD1.y = if Counter.FF[4].RS2.TD1.delayTime > 0.0 then if time >= Counter.FF[4].RS2.TD1.delayTime then Counter.FF[4].RS2.TD1.x_delayed else Counter.FF[4].RS2.TD1.y0 else pre(Counter.FF[4].RS2.TD1.x);
//   Counter.FF[4].And1.auxiliary[1] = Counter.FF[4].And1.x[1];
//   Counter.FF[4].And1.auxiliary[2] = D.Tables.AndTable[Counter.FF[4].And1.auxiliary[1],Counter.FF[4].And1.x[2]];
//   Counter.FF[4].And1.auxiliary[3] = D.Tables.AndTable[Counter.FF[4].And1.auxiliary[2],Counter.FF[4].And1.x[3]];
//   Counter.FF[4].And1.y = pre(Counter.FF[4].And1.auxiliary[3]);
//   Counter.FF[4].And2.auxiliary[1] = Counter.FF[4].And2.x[1];
//   Counter.FF[4].And2.auxiliary[2] = D.Tables.AndTable[Counter.FF[4].And2.auxiliary[1],Counter.FF[4].And2.x[2]];
//   Counter.FF[4].And2.auxiliary[3] = D.Tables.AndTable[Counter.FF[4].And2.auxiliary[2],Counter.FF[4].And2.x[3]];
//   Counter.FF[4].And2.y = pre(Counter.FF[4].And2.auxiliary[3]);
//   Counter.FF[4].And3.auxiliary[1] = Counter.FF[4].And3.x[1];
//   Counter.FF[4].And3.auxiliary[2] = D.Tables.AndTable[Counter.FF[4].And3.auxiliary[1],Counter.FF[4].And3.x[2]];
//   Counter.FF[4].And3.y = pre(Counter.FF[4].And3.auxiliary[2]);
//   Counter.FF[4].And4.auxiliary[1] = Counter.FF[4].And4.x[1];
//   Counter.FF[4].And4.auxiliary[2] = D.Tables.AndTable[Counter.FF[4].And4.auxiliary[1],Counter.FF[4].And4.x[2]];
//   Counter.FF[4].And4.y = pre(Counter.FF[4].And4.auxiliary[2]);
//   Counter.FF[4].Not1.auxiliary = D.Tables.NotTable[Counter.FF[4].Not1.x];
//   Counter.FF[4].Not1.y = pre(Counter.FF[4].Not1.auxiliary);
//   Q0.y[1] = if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then Q0.value_U else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then Q0.value_X else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then Q0.value_0 else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then Q0.value_1 else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then Q0.value_Z else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then Q0.value_W else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then Q0.value_L else if Q0.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then Q0.value_H else Q0.value_m;
//   Q1.y[1] = if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then Q1.value_U else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then Q1.value_X else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then Q1.value_0 else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then Q1.value_1 else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then Q1.value_Z else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then Q1.value_W else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then Q1.value_L else if Q1.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then Q1.value_H else Q1.value_m;
//   Q2.y[1] = if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then Q2.value_U else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then Q2.value_X else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then Q2.value_0 else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then Q2.value_1 else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then Q2.value_Z else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then Q2.value_W else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then Q2.value_L else if Q2.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then Q2.value_H else Q2.value_m;
//   Q3.y[1] = if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'U' then Q3.value_U else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'X' then Q3.value_X else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'0' then Q3.value_0 else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'1' then Q3.value_1 else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'Z' then Q3.value_Z else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'W' then Q3.value_W else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'L' then Q3.value_L else if Q3.x[1] == Modelica.Electrical.Digital.Interfaces.Logic.'H' then Q3.value_H else Q3.value_m;
//   Counter.FF[4].And1.x[3] = Counter.FF[4].RS1.Nor1.y;
//   Counter.FF[4].And1.x[3] = Counter.FF[4].RS1.TD1.x;
//   Counter.FF[4].And1.x[3] = Counter.FF[4].RS1.qn;
//   Counter.FF[4].And1.x[3] = Counter.FF[4].q;
//   Counter.FF[4].And1.x[3] = Counter.q[4];
//   Counter.FF[4].And1.x[3] = Q3.x[1];
//   Counter.FF[3].And1.x[3] = Counter.FF[3].RS1.Nor1.y;
//   Counter.FF[3].And1.x[3] = Counter.FF[3].RS1.TD1.x;
//   Counter.FF[3].And1.x[3] = Counter.FF[3].RS1.qn;
//   Counter.FF[3].And1.x[3] = Counter.FF[3].q;
//   Counter.FF[3].And1.x[3] = Counter.FF[4].And1.x[1];
//   Counter.FF[3].And1.x[3] = Counter.FF[4].And2.x[3];
//   Counter.FF[3].And1.x[3] = Counter.FF[4].Not1.x;
//   Counter.FF[3].And1.x[3] = Counter.FF[4].clk;
//   Counter.FF[3].And1.x[3] = Counter.q[3];
//   Counter.FF[3].And1.x[3] = Q2.x[1];
//   Counter.FF[2].And1.x[3] = Counter.FF[2].RS1.Nor1.y;
//   Counter.FF[2].And1.x[3] = Counter.FF[2].RS1.TD1.x;
//   Counter.FF[2].And1.x[3] = Counter.FF[2].RS1.qn;
//   Counter.FF[2].And1.x[3] = Counter.FF[2].q;
//   Counter.FF[2].And1.x[3] = Counter.FF[3].And1.x[1];
//   Counter.FF[2].And1.x[3] = Counter.FF[3].And2.x[3];
//   Counter.FF[2].And1.x[3] = Counter.FF[3].Not1.x;
//   Counter.FF[2].And1.x[3] = Counter.FF[3].clk;
//   Counter.FF[2].And1.x[3] = Counter.q[2];
//   Counter.FF[2].And1.x[3] = Q1.x[1];
//   Counter.FF[1].And1.x[3] = Counter.FF[1].RS1.Nor1.y;
//   Counter.FF[1].And1.x[3] = Counter.FF[1].RS1.TD1.x;
//   Counter.FF[1].And1.x[3] = Counter.FF[1].RS1.qn;
//   Counter.FF[1].And1.x[3] = Counter.FF[1].q;
//   Counter.FF[1].And1.x[3] = Counter.FF[2].And1.x[1];
//   Counter.FF[1].And1.x[3] = Counter.FF[2].And2.x[3];
//   Counter.FF[1].And1.x[3] = Counter.FF[2].Not1.x;
//   Counter.FF[1].And1.x[3] = Counter.FF[2].clk;
//   Counter.FF[1].And1.x[3] = Counter.q[1];
//   Counter.FF[1].And1.x[3] = Q0.x[1];
//   Clock.y = Counter.FF[1].And1.x[1];
//   Clock.y = Counter.FF[1].And2.x[3];
//   Clock.y = Counter.FF[1].Not1.x;
//   Clock.y = Counter.FF[1].clk;
//   Clock.y = Counter.count;
//   Counter.FF[1].And1.x[2] = Counter.FF[1].And2.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[1].j;
//   Counter.FF[1].And1.x[2] = Counter.FF[1].k;
//   Counter.FF[1].And1.x[2] = Counter.FF[2].And1.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[2].And2.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[2].j;
//   Counter.FF[1].And1.x[2] = Counter.FF[2].k;
//   Counter.FF[1].And1.x[2] = Counter.FF[3].And1.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[3].And2.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[3].j;
//   Counter.FF[1].And1.x[2] = Counter.FF[3].k;
//   Counter.FF[1].And1.x[2] = Counter.FF[4].And1.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[4].And2.x[2];
//   Counter.FF[1].And1.x[2] = Counter.FF[4].j;
//   Counter.FF[1].And1.x[2] = Counter.FF[4].k;
//   Counter.FF[1].And1.x[2] = Counter.enable;
//   Counter.FF[1].And1.x[2] = Enable.y;
//   Counter.FF[4].And2.x[1] = Counter.FF[4].RS1.Nor1.x[1];
//   Counter.FF[4].And2.x[1] = Counter.FF[4].RS1.Nor2.y;
//   Counter.FF[4].And2.x[1] = Counter.FF[4].RS1.q;
//   Counter.FF[4].And2.x[1] = Counter.FF[4].qn;
//   Counter.FF[4].And3.x[1] = Counter.FF[4].And4.x[1];
//   Counter.FF[4].And3.x[1] = Counter.FF[4].Not1.y;
//   Counter.FF[4].And3.x[2] = Counter.FF[4].RS2.Nor1.x[1];
//   Counter.FF[4].And3.x[2] = Counter.FF[4].RS2.Nor2.y;
//   Counter.FF[4].And3.x[2] = Counter.FF[4].RS2.q;
//   Counter.FF[4].And4.x[2] = Counter.FF[4].RS2.Nor1.y;
//   Counter.FF[4].And4.x[2] = Counter.FF[4].RS2.TD1.x;
//   Counter.FF[4].And4.x[2] = Counter.FF[4].RS2.qn;
//   Counter.FF[4].And3.y = Counter.FF[4].RS1.Nor1.x[2];
//   Counter.FF[4].And3.y = Counter.FF[4].RS1.s;
//   Counter.FF[4].And4.y = Counter.FF[4].RS1.Nor2.x[1];
//   Counter.FF[4].And4.y = Counter.FF[4].RS1.r;
//   Counter.FF[4].And1.y = Counter.FF[4].RS2.Nor1.x[2];
//   Counter.FF[4].And1.y = Counter.FF[4].RS2.s;
//   Counter.FF[4].And2.y = Counter.FF[4].RS2.Nor2.x[1];
//   Counter.FF[4].And2.y = Counter.FF[4].RS2.r;
//   Counter.FF[4].RS2.Nor2.x[2] = Counter.FF[4].RS2.TD1.y;
//   Counter.FF[4].RS1.Nor2.x[2] = Counter.FF[4].RS1.TD1.y;
//   Counter.FF[3].And2.x[1] = Counter.FF[3].RS1.Nor1.x[1];
//   Counter.FF[3].And2.x[1] = Counter.FF[3].RS1.Nor2.y;
//   Counter.FF[3].And2.x[1] = Counter.FF[3].RS1.q;
//   Counter.FF[3].And2.x[1] = Counter.FF[3].qn;
//   Counter.FF[3].And3.x[1] = Counter.FF[3].And4.x[1];
//   Counter.FF[3].And3.x[1] = Counter.FF[3].Not1.y;
//   Counter.FF[3].And3.x[2] = Counter.FF[3].RS2.Nor1.x[1];
//   Counter.FF[3].And3.x[2] = Counter.FF[3].RS2.Nor2.y;
//   Counter.FF[3].And3.x[2] = Counter.FF[3].RS2.q;
//   Counter.FF[3].And4.x[2] = Counter.FF[3].RS2.Nor1.y;
//   Counter.FF[3].And4.x[2] = Counter.FF[3].RS2.TD1.x;
//   Counter.FF[3].And4.x[2] = Counter.FF[3].RS2.qn;
//   Counter.FF[3].And3.y = Counter.FF[3].RS1.Nor1.x[2];
//   Counter.FF[3].And3.y = Counter.FF[3].RS1.s;
//   Counter.FF[3].And4.y = Counter.FF[3].RS1.Nor2.x[1];
//   Counter.FF[3].And4.y = Counter.FF[3].RS1.r;
//   Counter.FF[3].And1.y = Counter.FF[3].RS2.Nor1.x[2];
//   Counter.FF[3].And1.y = Counter.FF[3].RS2.s;
//   Counter.FF[3].And2.y = Counter.FF[3].RS2.Nor2.x[1];
//   Counter.FF[3].And2.y = Counter.FF[3].RS2.r;
//   Counter.FF[3].RS2.Nor2.x[2] = Counter.FF[3].RS2.TD1.y;
//   Counter.FF[3].RS1.Nor2.x[2] = Counter.FF[3].RS1.TD1.y;
//   Counter.FF[2].And2.x[1] = Counter.FF[2].RS1.Nor1.x[1];
//   Counter.FF[2].And2.x[1] = Counter.FF[2].RS1.Nor2.y;
//   Counter.FF[2].And2.x[1] = Counter.FF[2].RS1.q;
//   Counter.FF[2].And2.x[1] = Counter.FF[2].qn;
//   Counter.FF[2].And3.x[1] = Counter.FF[2].And4.x[1];
//   Counter.FF[2].And3.x[1] = Counter.FF[2].Not1.y;
//   Counter.FF[2].And3.x[2] = Counter.FF[2].RS2.Nor1.x[1];
//   Counter.FF[2].And3.x[2] = Counter.FF[2].RS2.Nor2.y;
//   Counter.FF[2].And3.x[2] = Counter.FF[2].RS2.q;
//   Counter.FF[2].And4.x[2] = Counter.FF[2].RS2.Nor1.y;
//   Counter.FF[2].And4.x[2] = Counter.FF[2].RS2.TD1.x;
//   Counter.FF[2].And4.x[2] = Counter.FF[2].RS2.qn;
//   Counter.FF[2].And3.y = Counter.FF[2].RS1.Nor1.x[2];
//   Counter.FF[2].And3.y = Counter.FF[2].RS1.s;
//   Counter.FF[2].And4.y = Counter.FF[2].RS1.Nor2.x[1];
//   Counter.FF[2].And4.y = Counter.FF[2].RS1.r;
//   Counter.FF[2].And1.y = Counter.FF[2].RS2.Nor1.x[2];
//   Counter.FF[2].And1.y = Counter.FF[2].RS2.s;
//   Counter.FF[2].And2.y = Counter.FF[2].RS2.Nor2.x[1];
//   Counter.FF[2].And2.y = Counter.FF[2].RS2.r;
//   Counter.FF[2].RS2.Nor2.x[2] = Counter.FF[2].RS2.TD1.y;
//   Counter.FF[2].RS1.Nor2.x[2] = Counter.FF[2].RS1.TD1.y;
//   Counter.FF[1].And2.x[1] = Counter.FF[1].RS1.Nor1.x[1];
//   Counter.FF[1].And2.x[1] = Counter.FF[1].RS1.Nor2.y;
//   Counter.FF[1].And2.x[1] = Counter.FF[1].RS1.q;
//   Counter.FF[1].And2.x[1] = Counter.FF[1].qn;
//   Counter.FF[1].And3.x[1] = Counter.FF[1].And4.x[1];
//   Counter.FF[1].And3.x[1] = Counter.FF[1].Not1.y;
//   Counter.FF[1].And3.x[2] = Counter.FF[1].RS2.Nor1.x[1];
//   Counter.FF[1].And3.x[2] = Counter.FF[1].RS2.Nor2.y;
//   Counter.FF[1].And3.x[2] = Counter.FF[1].RS2.q;
//   Counter.FF[1].And4.x[2] = Counter.FF[1].RS2.Nor1.y;
//   Counter.FF[1].And4.x[2] = Counter.FF[1].RS2.TD1.x;
//   Counter.FF[1].And4.x[2] = Counter.FF[1].RS2.qn;
//   Counter.FF[1].And3.y = Counter.FF[1].RS1.Nor1.x[2];
//   Counter.FF[1].And3.y = Counter.FF[1].RS1.s;
//   Counter.FF[1].And4.y = Counter.FF[1].RS1.Nor2.x[1];
//   Counter.FF[1].And4.y = Counter.FF[1].RS1.r;
//   Counter.FF[1].And1.y = Counter.FF[1].RS2.Nor1.x[2];
//   Counter.FF[1].And1.y = Counter.FF[1].RS2.s;
//   Counter.FF[1].And2.y = Counter.FF[1].RS2.Nor2.x[1];
//   Counter.FF[1].And2.y = Counter.FF[1].RS2.r;
//   Counter.FF[1].RS2.Nor2.x[2] = Counter.FF[1].RS2.TD1.y;
//   Counter.FF[1].RS1.Nor2.x[2] = Counter.FF[1].RS1.TD1.y;
// algorithm
//   when initial() then
//     Enable.y := Enable.before;
//   end when;
//   if time >= Enable.stepTime then
//     Enable.y := Enable.after;
//   else
//     Enable.y := Enable.before;
//   end if;
//   when sample(Clock.startTime,Clock.period) then
//     Clock.t_i := time;
//   end when;
//   Clock.y := if  NOT time >= Clock.startTime OR time >= Clock.t_i + Clock.t_width then Modelica.Electrical.Digital.Interfaces.Logic.'0' else Modelica.Electrical.Digital.Interfaces.Logic.'1';
// end Modelica.Electrical.Digital.Examples.Counter;
// "
// "[Digital.mo:646:7-647:51:writable] Warning: Component Clock has the same name as its type Modelica.Electrical.Digital.Examples.Counter.D.Sources.Clock.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// [Digital.mo:648:7-650:28:writable] Warning: Component Counter has the same name as its type Modelica.Electrical.Digital.Examples.Counter.D.Examples.Utilities.Counter.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// "
// "Check of Modelica.Electrical.Digital.Examples.Counter completed successfully.
// 
// [Digital.mo:646:7-647:51:writable] Warning: Component Clock has the same name as its type Modelica.Electrical.Digital.Examples.Counter.D.Sources.Clock.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// [Digital.mo:648:7-650:28:writable] Warning: Component Counter has the same name as its type Modelica.Electrical.Digital.Examples.Counter.D.Examples.Utilities.Counter.
// 	This is forbidden by Modelica specifications and may lead to lookup errors.
// 
// Class Modelica.Electrical.Digital.Examples.Counter has 282 equation(s) and 282 variable(s).
// 274 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.MUX4
//   parameter Real delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d0;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d1;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d2;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d3;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a0;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a1;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d;
//   parameter Integer Or1.n(min = 2) = 4 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.x[3] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.x[4] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Or1.auxiliary[4](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And3.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And4.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not2.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not2.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
// equation
//   Or1.auxiliary[1] = Or1.x[1];
//   Or1.auxiliary[2] = D.Tables.OrTable[Or1.auxiliary[1],Or1.x[2]];
//   Or1.auxiliary[3] = D.Tables.OrTable[Or1.auxiliary[2],Or1.x[3]];
//   Or1.auxiliary[4] = D.Tables.OrTable[Or1.auxiliary[3],Or1.x[4]];
//   Or1.y = pre(Or1.auxiliary[4]);
//   And1.auxiliary[1] = And1.x[1];
//   And1.auxiliary[2] = D.Tables.AndTable[And1.auxiliary[1],And1.x[2]];
//   And1.auxiliary[3] = D.Tables.AndTable[And1.auxiliary[2],And1.x[3]];
//   And1.y = pre(And1.auxiliary[3]);
//   And2.auxiliary[1] = And2.x[1];
//   And2.auxiliary[2] = D.Tables.AndTable[And2.auxiliary[1],And2.x[2]];
//   And2.auxiliary[3] = D.Tables.AndTable[And2.auxiliary[2],And2.x[3]];
//   And2.y = pre(And2.auxiliary[3]);
//   And3.auxiliary[1] = And3.x[1];
//   And3.auxiliary[2] = D.Tables.AndTable[And3.auxiliary[1],And3.x[2]];
//   And3.auxiliary[3] = D.Tables.AndTable[And3.auxiliary[2],And3.x[3]];
//   And3.y = pre(And3.auxiliary[3]);
//   And4.auxiliary[1] = And4.x[1];
//   And4.auxiliary[2] = D.Tables.AndTable[And4.auxiliary[1],And4.x[2]];
//   And4.auxiliary[3] = D.Tables.AndTable[And4.auxiliary[2],And4.x[3]];
//   And4.y = pre(And4.auxiliary[3]);
//   Not1.auxiliary = D.Tables.NotTable[Not1.x];
//   Not1.y = pre(Not1.auxiliary);
//   Not2.auxiliary = D.Tables.NotTable[Not2.x];
//   Not2.y = pre(Not2.auxiliary);
//   And3.x[1] = And4.x[1];
//   And3.x[1] = Not2.x;
//   And3.x[1] = a1;
//   And2.x[3] = And4.x[3];
//   And2.x[3] = Not1.x;
//   And2.x[3] = a0;
//   And1.x[1] = And2.x[1];
//   And1.x[1] = Not2.y;
//   And1.x[3] = And3.x[3];
//   And1.x[3] = Not1.y;
//   Or1.y = d;
//   And1.y = Or1.x[4];
//   And2.y = Or1.x[3];
//   And3.y = Or1.x[2];
//   And4.y = Or1.x[1];
//   And4.x[2] = d3;
//   And3.x[2] = d2;
//   And2.x[2] = d1;
//   And1.x[2] = d0;
// end Modelica.Electrical.Digital.Examples.Utilities.MUX4;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.MUX4 completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.MUX4 has 44 equation(s) and 44 variable(s).
// 44 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.RS
//   parameter Real delayTime(quantity = "Time", unit = "s") = 0.0 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') TD1.y "Connector of Digital output signal";
//   parameter Real TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') TD1.y0 = q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') TD1.x_delayed;
// equation
//   Nor1.auxiliary[1] = Nor1.x[1];
//   Nor1.auxiliary[2] = D.Tables.OrTable[Nor1.auxiliary[1],Nor1.x[2]];
//   Nor1.y = pre(D.Tables.NotTable[Nor1.auxiliary[2]]);
//   Nor2.auxiliary[1] = Nor2.x[1];
//   Nor2.auxiliary[2] = D.Tables.OrTable[Nor2.auxiliary[1],Nor2.x[2]];
//   Nor2.y = pre(D.Tables.NotTable[Nor2.auxiliary[2]]);
//   TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(TD1.x),TD1.delayTime,TD1.delayTime)));
//   TD1.y = if TD1.delayTime > 0.0 then if time >= TD1.delayTime then TD1.x_delayed else TD1.y0 else pre(TD1.x);
//   Nor1.y = TD1.x;
//   Nor1.y = qn;
//   Nor2.x[2] = TD1.y;
//   Nor1.x[1] = Nor2.y;
//   Nor1.x[1] = q;
//   Nor2.x[1] = r;
//   Nor1.x[2] = s;
// end Modelica.Electrical.Digital.Examples.Utilities.RS;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.RS completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.RS has 15 equation(s) and 15 variable(s).
// 15 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.RSFF
//   parameter Real delayTime(quantity = "Time", unit = "s") = 0.01 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') clk;
//   parameter Real RS1.delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.q0 = q0 "initial value of output";
//   parameter Integer RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.y "Connector of Digital output signal";
//   parameter Real RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.y0 = RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.x_delayed;
//   parameter Integer And1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   RS1.Nor1.auxiliary[1] = RS1.Nor1.x[1];
//   RS1.Nor1.auxiliary[2] = D.Tables.OrTable[RS1.Nor1.auxiliary[1],RS1.Nor1.x[2]];
//   RS1.Nor1.y = pre(D.Tables.NotTable[RS1.Nor1.auxiliary[2]]);
//   RS1.Nor2.auxiliary[1] = RS1.Nor2.x[1];
//   RS1.Nor2.auxiliary[2] = D.Tables.OrTable[RS1.Nor2.auxiliary[1],RS1.Nor2.x[2]];
//   RS1.Nor2.y = pre(D.Tables.NotTable[RS1.Nor2.auxiliary[2]]);
//   RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(RS1.TD1.x),RS1.TD1.delayTime,RS1.TD1.delayTime)));
//   RS1.TD1.y = if RS1.TD1.delayTime > 0.0 then if time >= RS1.TD1.delayTime then RS1.TD1.x_delayed else RS1.TD1.y0 else pre(RS1.TD1.x);
//   And1.auxiliary[1] = And1.x[1];
//   And1.auxiliary[2] = D.Tables.AndTable[And1.auxiliary[1],And1.x[2]];
//   And1.y = pre(And1.auxiliary[2]);
//   And2.auxiliary[1] = And2.x[1];
//   And2.auxiliary[2] = D.Tables.AndTable[And2.auxiliary[1],And2.x[2]];
//   And2.y = pre(And2.auxiliary[2]);
//   RS1.Nor1.y = RS1.TD1.x;
//   RS1.Nor1.y = RS1.qn;
//   RS1.Nor1.y = qn;
//   RS1.Nor1.x[1] = RS1.Nor2.y;
//   RS1.Nor1.x[1] = RS1.q;
//   RS1.Nor1.x[1] = q;
//   And2.x[1] = r;
//   And1.x[1] = And2.x[2];
//   And1.x[1] = clk;
//   And1.x[2] = s;
//   And1.y = RS1.Nor1.x[2];
//   And1.y = RS1.s;
//   And2.y = RS1.Nor2.x[1];
//   And2.y = RS1.r;
//   RS1.Nor2.x[2] = RS1.TD1.y;
// end Modelica.Electrical.Digital.Examples.Utilities.RSFF;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.RSFF completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.RSFF has 29 equation(s) and 29 variable(s).
// 29 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.DFF
//   parameter Real Tdel(quantity = "Time", unit = "s") = 0.01 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') QInit = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') d;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') clk;
//   parameter Real RSFF1.delayTime(quantity = "Time", unit = "s") = 0.01 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.clk;
//   parameter Real RSFF1.RS1.delayTime(quantity = "Time", unit = "s") = RSFF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.q0 = RSFF1.q0 "initial value of output";
//   parameter Integer RSFF1.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer RSFF1.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real RSFF1.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = RSFF1.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.TD1.y0 = RSFF1.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.RS1.TD1.x_delayed;
//   parameter Integer RSFF1.And1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer RSFF1.And2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RSFF1.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
// equation
//   RSFF1.RS1.Nor1.auxiliary[1] = RSFF1.RS1.Nor1.x[1];
//   RSFF1.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[RSFF1.RS1.Nor1.auxiliary[1],RSFF1.RS1.Nor1.x[2]];
//   RSFF1.RS1.Nor1.y = pre(D.Tables.NotTable[RSFF1.RS1.Nor1.auxiliary[2]]);
//   RSFF1.RS1.Nor2.auxiliary[1] = RSFF1.RS1.Nor2.x[1];
//   RSFF1.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[RSFF1.RS1.Nor2.auxiliary[1],RSFF1.RS1.Nor2.x[2]];
//   RSFF1.RS1.Nor2.y = pre(D.Tables.NotTable[RSFF1.RS1.Nor2.auxiliary[2]]);
//   RSFF1.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(RSFF1.RS1.TD1.x),RSFF1.RS1.TD1.delayTime,RSFF1.RS1.TD1.delayTime)));
//   RSFF1.RS1.TD1.y = if RSFF1.RS1.TD1.delayTime > 0.0 then if time >= RSFF1.RS1.TD1.delayTime then RSFF1.RS1.TD1.x_delayed else RSFF1.RS1.TD1.y0 else pre(RSFF1.RS1.TD1.x);
//   RSFF1.And1.auxiliary[1] = RSFF1.And1.x[1];
//   RSFF1.And1.auxiliary[2] = D.Tables.AndTable[RSFF1.And1.auxiliary[1],RSFF1.And1.x[2]];
//   RSFF1.And1.y = pre(RSFF1.And1.auxiliary[2]);
//   RSFF1.And2.auxiliary[1] = RSFF1.And2.x[1];
//   RSFF1.And2.auxiliary[2] = D.Tables.AndTable[RSFF1.And2.auxiliary[1],RSFF1.And2.x[2]];
//   RSFF1.And2.y = pre(RSFF1.And2.auxiliary[2]);
//   Not1.auxiliary = D.Tables.NotTable[Not1.x];
//   Not1.y = pre(Not1.auxiliary);
//   Not1.x = RSFF1.And1.x[2];
//   Not1.x = RSFF1.s;
//   Not1.x = d;
//   RSFF1.And1.x[1] = RSFF1.And2.x[2];
//   RSFF1.And1.x[1] = RSFF1.clk;
//   RSFF1.And1.x[1] = clk;
//   Not1.y = RSFF1.And2.x[1];
//   Not1.y = RSFF1.r;
//   RSFF1.RS1.Nor1.y = RSFF1.RS1.TD1.x;
//   RSFF1.RS1.Nor1.y = RSFF1.RS1.qn;
//   RSFF1.RS1.Nor1.y = RSFF1.qn;
//   RSFF1.RS1.Nor1.y = qn;
//   RSFF1.RS1.Nor1.x[1] = RSFF1.RS1.Nor2.y;
//   RSFF1.RS1.Nor1.x[1] = RSFF1.RS1.q;
//   RSFF1.RS1.Nor1.x[1] = RSFF1.q;
//   RSFF1.RS1.Nor1.x[1] = q;
//   RSFF1.And1.y = RSFF1.RS1.Nor1.x[2];
//   RSFF1.And1.y = RSFF1.RS1.s;
//   RSFF1.And2.y = RSFF1.RS1.Nor2.x[1];
//   RSFF1.And2.y = RSFF1.RS1.r;
//   RSFF1.RS1.Nor2.x[2] = RSFF1.RS1.TD1.y;
// end Modelica.Electrical.Digital.Examples.Utilities.DFF;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.DFF completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.DFF has 37 equation(s) and 37 variable(s).
// 37 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.JKFF
//   parameter Real delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') k;
//   parameter Real RS1.delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.q0 = q0 "initial value of output";
//   parameter Integer RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.y "Connector of Digital output signal";
//   parameter Real RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.y0 = RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS1.TD1.x_delayed;
//   parameter Real RS2.delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.q0 = q0 "initial value of output";
//   parameter Integer RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.TD1.y "Connector of Digital output signal";
//   parameter Real RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.TD1.y0 = RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') RS2.TD1.x_delayed;
//   parameter Integer And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
// equation
//   RS1.Nor1.auxiliary[1] = RS1.Nor1.x[1];
//   RS1.Nor1.auxiliary[2] = D.Tables.OrTable[RS1.Nor1.auxiliary[1],RS1.Nor1.x[2]];
//   RS1.Nor1.y = pre(D.Tables.NotTable[RS1.Nor1.auxiliary[2]]);
//   RS1.Nor2.auxiliary[1] = RS1.Nor2.x[1];
//   RS1.Nor2.auxiliary[2] = D.Tables.OrTable[RS1.Nor2.auxiliary[1],RS1.Nor2.x[2]];
//   RS1.Nor2.y = pre(D.Tables.NotTable[RS1.Nor2.auxiliary[2]]);
//   RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(RS1.TD1.x),RS1.TD1.delayTime,RS1.TD1.delayTime)));
//   RS1.TD1.y = if RS1.TD1.delayTime > 0.0 then if time >= RS1.TD1.delayTime then RS1.TD1.x_delayed else RS1.TD1.y0 else pre(RS1.TD1.x);
//   RS2.Nor1.auxiliary[1] = RS2.Nor1.x[1];
//   RS2.Nor1.auxiliary[2] = D.Tables.OrTable[RS2.Nor1.auxiliary[1],RS2.Nor1.x[2]];
//   RS2.Nor1.y = pre(D.Tables.NotTable[RS2.Nor1.auxiliary[2]]);
//   RS2.Nor2.auxiliary[1] = RS2.Nor2.x[1];
//   RS2.Nor2.auxiliary[2] = D.Tables.OrTable[RS2.Nor2.auxiliary[1],RS2.Nor2.x[2]];
//   RS2.Nor2.y = pre(D.Tables.NotTable[RS2.Nor2.auxiliary[2]]);
//   RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(RS2.TD1.x),RS2.TD1.delayTime,RS2.TD1.delayTime)));
//   RS2.TD1.y = if RS2.TD1.delayTime > 0.0 then if time >= RS2.TD1.delayTime then RS2.TD1.x_delayed else RS2.TD1.y0 else pre(RS2.TD1.x);
//   And1.auxiliary[1] = And1.x[1];
//   And1.auxiliary[2] = D.Tables.AndTable[And1.auxiliary[1],And1.x[2]];
//   And1.auxiliary[3] = D.Tables.AndTable[And1.auxiliary[2],And1.x[3]];
//   And1.y = pre(And1.auxiliary[3]);
//   And2.auxiliary[1] = And2.x[1];
//   And2.auxiliary[2] = D.Tables.AndTable[And2.auxiliary[1],And2.x[2]];
//   And2.auxiliary[3] = D.Tables.AndTable[And2.auxiliary[2],And2.x[3]];
//   And2.y = pre(And2.auxiliary[3]);
//   And3.auxiliary[1] = And3.x[1];
//   And3.auxiliary[2] = D.Tables.AndTable[And3.auxiliary[1],And3.x[2]];
//   And3.y = pre(And3.auxiliary[2]);
//   And4.auxiliary[1] = And4.x[1];
//   And4.auxiliary[2] = D.Tables.AndTable[And4.auxiliary[1],And4.x[2]];
//   And4.y = pre(And4.auxiliary[2]);
//   Not1.auxiliary = D.Tables.NotTable[Not1.x];
//   Not1.y = pre(Not1.auxiliary);
//   And2.x[1] = RS1.Nor1.x[1];
//   And2.x[1] = RS1.Nor2.y;
//   And2.x[1] = RS1.q;
//   And2.x[1] = qn;
//   And1.x[3] = RS1.Nor1.y;
//   And1.x[3] = RS1.TD1.x;
//   And1.x[3] = RS1.qn;
//   And1.x[3] = q;
//   And1.x[2] = j;
//   And3.x[1] = And4.x[1];
//   And3.x[1] = Not1.y;
//   And1.x[1] = And2.x[3];
//   And1.x[1] = Not1.x;
//   And1.x[1] = clk;
//   And3.x[2] = RS2.Nor1.x[1];
//   And3.x[2] = RS2.Nor2.y;
//   And3.x[2] = RS2.q;
//   And4.x[2] = RS2.Nor1.y;
//   And4.x[2] = RS2.TD1.x;
//   And4.x[2] = RS2.qn;
//   And3.y = RS1.Nor1.x[2];
//   And3.y = RS1.s;
//   And4.y = RS1.Nor2.x[1];
//   And4.y = RS1.r;
//   And2.x[2] = k;
//   And1.y = RS2.Nor1.x[2];
//   And1.y = RS2.s;
//   And2.y = RS2.Nor2.x[1];
//   And2.y = RS2.r;
//   RS2.Nor2.x[2] = RS2.TD1.y;
//   RS1.Nor2.x[2] = RS1.TD1.y;
// end Modelica.Electrical.Digital.Examples.Utilities.JKFF;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.JKFF completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.JKFF has 63 equation(s) and 63 variable(s).
// 63 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.HalfAdder
//   parameter Real delayTime = 0.0 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c;
//   parameter Integer AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.y "Connector of Digital output signal";
//   parameter Real AND.tLH(quantity = "Time", unit = "s", start = 0.0) = delayTime "rise inertial delay";
//   parameter Real AND.tHL(quantity = "Time", unit = "s", start = 0.0) = delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer AND.G1.n(min = 2) = AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G2.y "Connector of Digital output signal";
//   parameter Real AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = AND.tLH "rise inertial delay";
//   parameter Real AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G2.y0 = AND.y0 "initial value of output";
//   protected Integer AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G2.y_auxiliary(start = AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') AND.G2.x_old(start = AND.G2.y0, fixed = true);
//   protected Integer AND.G2.lh;
//   protected discrete Real AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = delayTime "rise inertial delay";
//   parameter Real XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.y "Connector of Digital output signal";
//   parameter Integer XOR.G1.n(min = 2) = XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G2.y "Connector of Digital output signal";
//   parameter Real XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = XOR.tLH "rise inertial delay";
//   parameter Real XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G2.y0 = XOR.y0 "initial value of output";
//   protected Integer XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G2.y_auxiliary(start = XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') XOR.G2.x_old(start = XOR.G2.y0, fixed = true);
//   protected Integer XOR.G2.lh;
//   protected discrete Real XOR.G2.t_next(quantity = "Time", unit = "s");
// equation
//   AND.G1.auxiliary[1] = AND.G1.x[1];
//   AND.G1.auxiliary[2] = D.Tables.AndTable[AND.G1.auxiliary[1],AND.G1.x[2]];
//   AND.G1.y = pre(AND.G1.auxiliary[2]);
//   XOR.G1.auxiliary[1] = XOR.G1.x[1];
//   XOR.G1.auxiliary[2] = D.Tables.XorTable[XOR.G1.auxiliary[1],XOR.G1.x[2]];
//   XOR.G1.y = pre(XOR.G1.auxiliary[2]);
//   AND.G1.x[2] = AND.x[2];
//   AND.G1.x[2] = XOR.G1.x[2];
//   AND.G1.x[2] = XOR.x[2];
//   AND.G1.x[2] = a;
//   AND.G1.x[1] = AND.x[1];
//   AND.G1.x[1] = XOR.G1.x[1];
//   AND.G1.x[1] = XOR.x[1];
//   AND.G1.x[1] = b;
//   XOR.G2.y = XOR.y;
//   XOR.G2.y = s;
//   AND.G2.y = AND.y;
//   AND.G2.y = c;
//   XOR.G1.y = XOR.G2.x;
//   AND.G1.y = AND.G2.x;
// algorithm
//   when {initial(),(AND.G2.tLH > 0.0 OR AND.G2.tHL > 0.0) AND change(AND.G2.x) AND  NOT initial()} then
//     AND.G2.x_old := if initial() OR pre(AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then AND.G2.y0 else pre(AND.G2.x);
//     AND.G2.lh := AND.G2.delayTable[AND.G2.x_old, AND.G2.x];
//     AND.G2.delayTime := if AND.G2.lh > 0 then AND.G2.tLH else if AND.G2.lh < 0 then AND.G2.tHL else 0.0;
//     AND.G2.t_next := time + AND.G2.delayTime;
//     if AND.G2.lh == 0 OR abs(AND.G2.delayTime) < 1e-60 then
//       AND.G2.y_auxiliary := AND.G2.x;
//     end if;
//   elsewhen time >= AND.G2.t_next then
//     AND.G2.y_auxiliary := AND.G2.x;
//   end when;
//   AND.G2.y := if AND.G2.tLH > 0.0 OR AND.G2.tHL > 0.0 then AND.G2.y_auxiliary else AND.G2.x;
//   when {initial(),(XOR.G2.tLH > 0.0 OR XOR.G2.tHL > 0.0) AND change(XOR.G2.x) AND  NOT initial()} then
//     XOR.G2.x_old := if initial() OR pre(XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then XOR.G2.y0 else pre(XOR.G2.x);
//     XOR.G2.lh := XOR.G2.delayTable[XOR.G2.x_old, XOR.G2.x];
//     XOR.G2.delayTime := if XOR.G2.lh > 0 then XOR.G2.tLH else if XOR.G2.lh < 0 then XOR.G2.tHL else 0.0;
//     XOR.G2.t_next := time + XOR.G2.delayTime;
//     if XOR.G2.lh == 0 OR abs(XOR.G2.delayTime) < 1e-60 then
//       XOR.G2.y_auxiliary := XOR.G2.x;
//     end if;
//   elsewhen time >= XOR.G2.t_next then
//     XOR.G2.y_auxiliary := XOR.G2.x;
//   end when;
//   XOR.G2.y := if XOR.G2.tLH > 0.0 OR XOR.G2.tHL > 0.0 then XOR.G2.y_auxiliary else XOR.G2.x;
// end Modelica.Electrical.Digital.Examples.Utilities.HalfAdder;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.HalfAdder completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.HalfAdder has 194 equation(s) and 194 variable(s).
// 182 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.FullAdder
//   parameter Real Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.c;
//   parameter Integer Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.delayTime "rise inertial delay";
//   parameter Real Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.AND.G1.n(min = 2) = Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G2.y0 = Adder2.AND.y0 "initial value of output";
//   protected Integer Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G2.y_auxiliary(start = Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.AND.G2.x_old(start = Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder2.AND.G2.lh;
//   protected discrete Real Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.delayTime "rise inertial delay";
//   parameter Real Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder2.XOR.G1.n(min = 2) = Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G2.y0 = Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G2.y_auxiliary(start = Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder2.XOR.G2.x_old(start = Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder2.XOR.G2.lh;
//   protected discrete Real Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.c;
//   parameter Integer Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.AND.G1.n(min = 2) = Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G2.y0 = Adder1.AND.y0 "initial value of output";
//   protected Integer Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G2.y_auxiliary(start = Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.AND.G2.x_old(start = Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder1.AND.G2.lh;
//   protected discrete Real Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.delayTime "rise inertial delay";
//   parameter Real Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder1.XOR.G1.n(min = 2) = Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G2.y0 = Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G2.y_auxiliary(start = Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder1.XOR.G2.x_old(start = Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder1.XOR.G2.lh;
//   protected discrete Real Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c_out;
//   parameter Integer OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   Adder2.AND.G1.auxiliary[1] = Adder2.AND.G1.x[1];
//   Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder2.AND.G1.auxiliary[1],Adder2.AND.G1.x[2]];
//   Adder2.AND.G1.y = pre(Adder2.AND.G1.auxiliary[2]);
//   Adder2.XOR.G1.auxiliary[1] = Adder2.XOR.G1.x[1];
//   Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder2.XOR.G1.auxiliary[1],Adder2.XOR.G1.x[2]];
//   Adder2.XOR.G1.y = pre(Adder2.XOR.G1.auxiliary[2]);
//   Adder1.AND.G1.auxiliary[1] = Adder1.AND.G1.x[1];
//   Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder1.AND.G1.auxiliary[1],Adder1.AND.G1.x[2]];
//   Adder1.AND.G1.y = pre(Adder1.AND.G1.auxiliary[2]);
//   Adder1.XOR.G1.auxiliary[1] = Adder1.XOR.G1.x[1];
//   Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder1.XOR.G1.auxiliary[1],Adder1.XOR.G1.x[2]];
//   Adder1.XOR.G1.y = pre(Adder1.XOR.G1.auxiliary[2]);
//   OR.auxiliary[1] = OR.x[1];
//   OR.auxiliary[2] = D.Tables.OrTable[OR.auxiliary[1],OR.x[2]];
//   OR.y = pre(OR.auxiliary[2]);
//   Adder2.AND.G1.x[1] = Adder2.AND.x[1];
//   Adder2.AND.G1.x[1] = Adder2.XOR.G1.x[1];
//   Adder2.AND.G1.x[1] = Adder2.XOR.x[1];
//   Adder2.AND.G1.x[1] = Adder2.b;
//   Adder2.AND.G1.x[1] = c_in;
//   Adder1.AND.G2.y = Adder1.AND.y;
//   Adder1.AND.G2.y = Adder1.c;
//   Adder1.AND.G2.y = OR.x[1];
//   Adder1.XOR.G2.y = Adder1.XOR.y;
//   Adder1.XOR.G2.y = Adder1.s;
//   Adder1.XOR.G2.y = Adder2.AND.G1.x[2];
//   Adder1.XOR.G2.y = Adder2.AND.x[2];
//   Adder1.XOR.G2.y = Adder2.XOR.G1.x[2];
//   Adder1.XOR.G2.y = Adder2.XOR.x[2];
//   Adder1.XOR.G2.y = Adder2.a;
//   Adder1.AND.G1.x[1] = Adder1.AND.x[1];
//   Adder1.AND.G1.x[1] = Adder1.XOR.G1.x[1];
//   Adder1.AND.G1.x[1] = Adder1.XOR.x[1];
//   Adder1.AND.G1.x[1] = Adder1.b;
//   Adder1.AND.G1.x[1] = b;
//   Adder1.AND.G1.x[2] = Adder1.AND.x[2];
//   Adder1.AND.G1.x[2] = Adder1.XOR.G1.x[2];
//   Adder1.AND.G1.x[2] = Adder1.XOR.x[2];
//   Adder1.AND.G1.x[2] = Adder1.a;
//   Adder1.AND.G1.x[2] = a;
//   Adder2.XOR.G2.y = Adder2.XOR.y;
//   Adder2.XOR.G2.y = Adder2.s;
//   Adder2.XOR.G2.y = s;
//   Adder2.AND.G2.y = Adder2.AND.y;
//   Adder2.AND.G2.y = Adder2.c;
//   Adder2.AND.G2.y = OR.x[2];
//   OR.y = c_out;
//   Adder1.XOR.G1.y = Adder1.XOR.G2.x;
//   Adder1.AND.G1.y = Adder1.AND.G2.x;
//   Adder2.XOR.G1.y = Adder2.XOR.G2.x;
//   Adder2.AND.G1.y = Adder2.AND.G2.x;
// algorithm
//   when {initial(),(Adder2.AND.G2.tLH > 0.0 OR Adder2.AND.G2.tHL > 0.0) AND change(Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder2.AND.G2.x_old := if initial() OR pre(Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.AND.G2.y0 else pre(Adder2.AND.G2.x);
//     Adder2.AND.G2.lh := Adder2.AND.G2.delayTable[Adder2.AND.G2.x_old, Adder2.AND.G2.x];
//     Adder2.AND.G2.delayTime := if Adder2.AND.G2.lh > 0 then Adder2.AND.G2.tLH else if Adder2.AND.G2.lh < 0 then Adder2.AND.G2.tHL else 0.0;
//     Adder2.AND.G2.t_next := time + Adder2.AND.G2.delayTime;
//     if Adder2.AND.G2.lh == 0 OR abs(Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder2.AND.G2.y_auxiliary := Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder2.AND.G2.t_next then
//     Adder2.AND.G2.y_auxiliary := Adder2.AND.G2.x;
//   end when;
//   Adder2.AND.G2.y := if Adder2.AND.G2.tLH > 0.0 OR Adder2.AND.G2.tHL > 0.0 then Adder2.AND.G2.y_auxiliary else Adder2.AND.G2.x;
//   when {initial(),(Adder2.XOR.G2.tLH > 0.0 OR Adder2.XOR.G2.tHL > 0.0) AND change(Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder2.XOR.G2.x_old := if initial() OR pre(Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder2.XOR.G2.y0 else pre(Adder2.XOR.G2.x);
//     Adder2.XOR.G2.lh := Adder2.XOR.G2.delayTable[Adder2.XOR.G2.x_old, Adder2.XOR.G2.x];
//     Adder2.XOR.G2.delayTime := if Adder2.XOR.G2.lh > 0 then Adder2.XOR.G2.tLH else if Adder2.XOR.G2.lh < 0 then Adder2.XOR.G2.tHL else 0.0;
//     Adder2.XOR.G2.t_next := time + Adder2.XOR.G2.delayTime;
//     if Adder2.XOR.G2.lh == 0 OR abs(Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder2.XOR.G2.y_auxiliary := Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder2.XOR.G2.t_next then
//     Adder2.XOR.G2.y_auxiliary := Adder2.XOR.G2.x;
//   end when;
//   Adder2.XOR.G2.y := if Adder2.XOR.G2.tLH > 0.0 OR Adder2.XOR.G2.tHL > 0.0 then Adder2.XOR.G2.y_auxiliary else Adder2.XOR.G2.x;
//   when {initial(),(Adder1.AND.G2.tLH > 0.0 OR Adder1.AND.G2.tHL > 0.0) AND change(Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder1.AND.G2.x_old := if initial() OR pre(Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.AND.G2.y0 else pre(Adder1.AND.G2.x);
//     Adder1.AND.G2.lh := Adder1.AND.G2.delayTable[Adder1.AND.G2.x_old, Adder1.AND.G2.x];
//     Adder1.AND.G2.delayTime := if Adder1.AND.G2.lh > 0 then Adder1.AND.G2.tLH else if Adder1.AND.G2.lh < 0 then Adder1.AND.G2.tHL else 0.0;
//     Adder1.AND.G2.t_next := time + Adder1.AND.G2.delayTime;
//     if Adder1.AND.G2.lh == 0 OR abs(Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder1.AND.G2.y_auxiliary := Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder1.AND.G2.t_next then
//     Adder1.AND.G2.y_auxiliary := Adder1.AND.G2.x;
//   end when;
//   Adder1.AND.G2.y := if Adder1.AND.G2.tLH > 0.0 OR Adder1.AND.G2.tHL > 0.0 then Adder1.AND.G2.y_auxiliary else Adder1.AND.G2.x;
//   when {initial(),(Adder1.XOR.G2.tLH > 0.0 OR Adder1.XOR.G2.tHL > 0.0) AND change(Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder1.XOR.G2.x_old := if initial() OR pre(Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder1.XOR.G2.y0 else pre(Adder1.XOR.G2.x);
//     Adder1.XOR.G2.lh := Adder1.XOR.G2.delayTable[Adder1.XOR.G2.x_old, Adder1.XOR.G2.x];
//     Adder1.XOR.G2.delayTime := if Adder1.XOR.G2.lh > 0 then Adder1.XOR.G2.tLH else if Adder1.XOR.G2.lh < 0 then Adder1.XOR.G2.tHL else 0.0;
//     Adder1.XOR.G2.t_next := time + Adder1.XOR.G2.delayTime;
//     if Adder1.XOR.G2.lh == 0 OR abs(Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder1.XOR.G2.y_auxiliary := Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder1.XOR.G2.t_next then
//     Adder1.XOR.G2.y_auxiliary := Adder1.XOR.G2.x;
//   end when;
//   Adder1.XOR.G2.y := if Adder1.XOR.G2.tLH > 0.0 OR Adder1.XOR.G2.tHL > 0.0 then Adder1.XOR.G2.y_auxiliary else Adder1.XOR.G2.x;
// end Modelica.Electrical.Digital.Examples.Utilities.FullAdder;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.FullAdder completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.FullAdder has 399 equation(s) and 399 variable(s).
// 375 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.Adder
//   parameter Integer n = 2 "number of single adders";
//   parameter Real Adder[1].Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.c;
//   parameter Integer Adder[1].Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.delayTime "rise inertial delay";
//   parameter Real Adder[1].Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[1].Adder2.AND.G1.n(min = 2) = Adder[1].Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder[1].Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G2.y0 = Adder[1].Adder2.AND.y0 "initial value of output";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[1].Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G2.y_auxiliary(start = Adder[1].Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.AND.G2.x_old(start = Adder[1].Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder[1].Adder2.AND.G2.lh;
//   protected discrete Real Adder[1].Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[1].Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.delayTime "rise inertial delay";
//   parameter Real Adder[1].Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[1].Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder[1].Adder2.XOR.G1.n(min = 2) = Adder[1].Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder[1].Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G2.y0 = Adder[1].Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[1].Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G2.y_auxiliary(start = Adder[1].Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder2.XOR.G2.x_old(start = Adder[1].Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder[1].Adder2.XOR.G2.lh;
//   protected discrete Real Adder[1].Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[1].Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.c;
//   parameter Integer Adder[1].Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.delayTime "rise inertial delay";
//   parameter Real Adder[1].Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[1].Adder1.AND.G1.n(min = 2) = Adder[1].Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder[1].Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G2.y0 = Adder[1].Adder1.AND.y0 "initial value of output";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[1].Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G2.y_auxiliary(start = Adder[1].Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.AND.G2.x_old(start = Adder[1].Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder[1].Adder1.AND.G2.lh;
//   protected discrete Real Adder[1].Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[1].Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.delayTime "rise inertial delay";
//   parameter Real Adder[1].Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[1].Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder[1].Adder1.XOR.G1.n(min = 2) = Adder[1].Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder[1].Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder[1].Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[1].Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G2.y0 = Adder[1].Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[1].Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[1].Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G2.y_auxiliary(start = Adder[1].Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].Adder1.XOR.G2.x_old(start = Adder[1].Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder[1].Adder1.XOR.G2.lh;
//   protected discrete Real Adder[1].Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].c_out;
//   parameter Integer Adder[1].OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[1].OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Real Adder[2].Adder2.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.c;
//   parameter Integer Adder[2].Adder2.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder2.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.delayTime "rise inertial delay";
//   parameter Real Adder[2].Adder2.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[2].Adder2.AND.G1.n(min = 2) = Adder[2].Adder2.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder2.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.AND.tLH "rise inertial delay";
//   parameter Real Adder[2].Adder2.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G2.y0 = Adder[2].Adder2.AND.y0 "initial value of output";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[2].Adder2.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G2.y_auxiliary(start = Adder[2].Adder2.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.AND.G2.x_old(start = Adder[2].Adder2.AND.G2.y0, fixed = true);
//   protected Integer Adder[2].Adder2.AND.G2.lh;
//   protected discrete Real Adder[2].Adder2.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[2].Adder2.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.delayTime "rise inertial delay";
//   parameter Real Adder[2].Adder2.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[2].Adder2.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder[2].Adder2.XOR.G1.n(min = 2) = Adder[2].Adder2.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder2.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.XOR.tLH "rise inertial delay";
//   parameter Real Adder[2].Adder2.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder2.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G2.y0 = Adder[2].Adder2.XOR.y0 "initial value of output";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder2.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[2].Adder2.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G2.y_auxiliary(start = Adder[2].Adder2.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder2.XOR.G2.x_old(start = Adder[2].Adder2.XOR.G2.y0, fixed = true);
//   protected Integer Adder[2].Adder2.XOR.G2.lh;
//   protected discrete Real Adder[2].Adder2.XOR.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[2].Adder1.delayTime = 0.001 "delay time";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.b;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.a;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.c;
//   parameter Integer Adder[2].Adder1.AND.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder1.AND.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.delayTime "rise inertial delay";
//   parameter Real Adder[2].Adder1.AND.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[2].Adder1.AND.G1.n(min = 2) = Adder[2].Adder1.AND.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G2.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder1.AND.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.AND.tLH "rise inertial delay";
//   parameter Real Adder[2].Adder1.AND.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.AND.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G2.y0 = Adder[2].Adder1.AND.y0 "initial value of output";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.AND.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[2].Adder1.AND.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G2.y_auxiliary(start = Adder[2].Adder1.AND.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.AND.G2.x_old(start = Adder[2].Adder1.AND.G2.y0, fixed = true);
//   protected Integer Adder[2].Adder1.AND.G2.lh;
//   protected discrete Real Adder[2].Adder1.AND.G2.t_next(quantity = "Time", unit = "s");
//   parameter Real Adder[2].Adder1.XOR.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.delayTime "rise inertial delay";
//   parameter Real Adder[2].Adder1.XOR.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.delayTime "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer Adder[2].Adder1.XOR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.y "Connector of Digital output signal";
//   parameter Integer Adder[2].Adder1.XOR.G1.n(min = 2) = Adder[2].Adder1.XOR.n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G2.y "Connector of Digital output signal";
//   parameter Real Adder[2].Adder1.XOR.G2.tLH(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.XOR.tLH "rise inertial delay";
//   parameter Real Adder[2].Adder1.XOR.G2.tHL(quantity = "Time", unit = "s", start = 0.0) = Adder[2].Adder1.XOR.tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G2.y0 = Adder[2].Adder1.XOR.y0 "initial value of output";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer Adder[2].Adder1.XOR.G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real Adder[2].Adder1.XOR.G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G2.y_auxiliary(start = Adder[2].Adder1.XOR.G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].Adder1.XOR.G2.x_old(start = Adder[2].Adder1.XOR.G2.y0, fixed = true);
//   protected Integer Adder[2].Adder1.XOR.G2.lh;
//   protected discrete Real Adder[2].Adder1.XOR.G2.t_next(quantity = "Time", unit = "s");
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].a;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].b;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].s;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].c_out;
//   parameter Integer Adder[2].OR.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].OR.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].OR.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].OR.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].OR.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') Adder[2].OR.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a[1];
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') a[2];
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b[1];
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') b[2];
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c_in;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s[1];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') s[2];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') c_out;
// equation
//   Adder[1].Adder2.AND.G1.auxiliary[1] = Adder[1].Adder2.AND.G1.x[1];
//   Adder[1].Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder[1].Adder2.AND.G1.auxiliary[1],Adder[1].Adder2.AND.G1.x[2]];
//   Adder[1].Adder2.AND.G1.y = pre(Adder[1].Adder2.AND.G1.auxiliary[2]);
//   Adder[1].Adder2.XOR.G1.auxiliary[1] = Adder[1].Adder2.XOR.G1.x[1];
//   Adder[1].Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder[1].Adder2.XOR.G1.auxiliary[1],Adder[1].Adder2.XOR.G1.x[2]];
//   Adder[1].Adder2.XOR.G1.y = pre(Adder[1].Adder2.XOR.G1.auxiliary[2]);
//   Adder[1].Adder1.AND.G1.auxiliary[1] = Adder[1].Adder1.AND.G1.x[1];
//   Adder[1].Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder[1].Adder1.AND.G1.auxiliary[1],Adder[1].Adder1.AND.G1.x[2]];
//   Adder[1].Adder1.AND.G1.y = pre(Adder[1].Adder1.AND.G1.auxiliary[2]);
//   Adder[1].Adder1.XOR.G1.auxiliary[1] = Adder[1].Adder1.XOR.G1.x[1];
//   Adder[1].Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder[1].Adder1.XOR.G1.auxiliary[1],Adder[1].Adder1.XOR.G1.x[2]];
//   Adder[1].Adder1.XOR.G1.y = pre(Adder[1].Adder1.XOR.G1.auxiliary[2]);
//   Adder[1].OR.auxiliary[1] = Adder[1].OR.x[1];
//   Adder[1].OR.auxiliary[2] = D.Tables.OrTable[Adder[1].OR.auxiliary[1],Adder[1].OR.x[2]];
//   Adder[1].OR.y = pre(Adder[1].OR.auxiliary[2]);
//   Adder[2].Adder2.AND.G1.auxiliary[1] = Adder[2].Adder2.AND.G1.x[1];
//   Adder[2].Adder2.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder[2].Adder2.AND.G1.auxiliary[1],Adder[2].Adder2.AND.G1.x[2]];
//   Adder[2].Adder2.AND.G1.y = pre(Adder[2].Adder2.AND.G1.auxiliary[2]);
//   Adder[2].Adder2.XOR.G1.auxiliary[1] = Adder[2].Adder2.XOR.G1.x[1];
//   Adder[2].Adder2.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder[2].Adder2.XOR.G1.auxiliary[1],Adder[2].Adder2.XOR.G1.x[2]];
//   Adder[2].Adder2.XOR.G1.y = pre(Adder[2].Adder2.XOR.G1.auxiliary[2]);
//   Adder[2].Adder1.AND.G1.auxiliary[1] = Adder[2].Adder1.AND.G1.x[1];
//   Adder[2].Adder1.AND.G1.auxiliary[2] = D.Tables.AndTable[Adder[2].Adder1.AND.G1.auxiliary[1],Adder[2].Adder1.AND.G1.x[2]];
//   Adder[2].Adder1.AND.G1.y = pre(Adder[2].Adder1.AND.G1.auxiliary[2]);
//   Adder[2].Adder1.XOR.G1.auxiliary[1] = Adder[2].Adder1.XOR.G1.x[1];
//   Adder[2].Adder1.XOR.G1.auxiliary[2] = D.Tables.XorTable[Adder[2].Adder1.XOR.G1.auxiliary[1],Adder[2].Adder1.XOR.G1.x[2]];
//   Adder[2].Adder1.XOR.G1.y = pre(Adder[2].Adder1.XOR.G1.auxiliary[2]);
//   Adder[2].OR.auxiliary[1] = Adder[2].OR.x[1];
//   Adder[2].OR.auxiliary[2] = D.Tables.OrTable[Adder[2].OR.auxiliary[1],Adder[2].OR.x[2]];
//   Adder[2].OR.y = pre(Adder[2].OR.auxiliary[2]);
//   Adder[2].OR.y = Adder[2].c_out;
//   Adder[2].OR.y = c_out;
//   Adder[1].OR.y = Adder[1].c_out;
//   Adder[1].OR.y = Adder[2].Adder2.AND.G1.x[1];
//   Adder[1].OR.y = Adder[2].Adder2.AND.x[1];
//   Adder[1].OR.y = Adder[2].Adder2.XOR.G1.x[1];
//   Adder[1].OR.y = Adder[2].Adder2.XOR.x[1];
//   Adder[1].OR.y = Adder[2].Adder2.b;
//   Adder[1].OR.y = Adder[2].c_in;
//   Adder[2].Adder1.AND.G1.x[2] = Adder[2].Adder1.AND.x[2];
//   Adder[2].Adder1.AND.G1.x[2] = Adder[2].Adder1.XOR.G1.x[2];
//   Adder[2].Adder1.AND.G1.x[2] = Adder[2].Adder1.XOR.x[2];
//   Adder[2].Adder1.AND.G1.x[2] = Adder[2].Adder1.a;
//   Adder[2].Adder1.AND.G1.x[2] = Adder[2].a;
//   Adder[2].Adder1.AND.G1.x[2] = a[2];
//   Adder[2].Adder1.AND.G1.x[2] = s[2];
//   Adder[2].Adder1.AND.G1.x[1] = Adder[2].Adder1.AND.x[1];
//   Adder[2].Adder1.AND.G1.x[1] = Adder[2].Adder1.XOR.G1.x[1];
//   Adder[2].Adder1.AND.G1.x[1] = Adder[2].Adder1.XOR.x[1];
//   Adder[2].Adder1.AND.G1.x[1] = Adder[2].Adder1.b;
//   Adder[2].Adder1.AND.G1.x[1] = Adder[2].b;
//   Adder[2].Adder1.AND.G1.x[1] = b[2];
//   Adder[1].Adder1.AND.G1.x[2] = Adder[1].Adder1.AND.x[2];
//   Adder[1].Adder1.AND.G1.x[2] = Adder[1].Adder1.XOR.G1.x[2];
//   Adder[1].Adder1.AND.G1.x[2] = Adder[1].Adder1.XOR.x[2];
//   Adder[1].Adder1.AND.G1.x[2] = Adder[1].Adder1.a;
//   Adder[1].Adder1.AND.G1.x[2] = Adder[1].a;
//   Adder[1].Adder1.AND.G1.x[2] = a[1];
//   Adder[1].Adder1.AND.G1.x[2] = s[1];
//   Adder[1].Adder1.AND.G1.x[1] = Adder[1].Adder1.AND.x[1];
//   Adder[1].Adder1.AND.G1.x[1] = Adder[1].Adder1.XOR.G1.x[1];
//   Adder[1].Adder1.AND.G1.x[1] = Adder[1].Adder1.XOR.x[1];
//   Adder[1].Adder1.AND.G1.x[1] = Adder[1].Adder1.b;
//   Adder[1].Adder1.AND.G1.x[1] = Adder[1].b;
//   Adder[1].Adder1.AND.G1.x[1] = b[1];
//   Adder[1].Adder2.AND.G1.x[1] = Adder[1].Adder2.AND.x[1];
//   Adder[1].Adder2.AND.G1.x[1] = Adder[1].Adder2.XOR.G1.x[1];
//   Adder[1].Adder2.AND.G1.x[1] = Adder[1].Adder2.XOR.x[1];
//   Adder[1].Adder2.AND.G1.x[1] = Adder[1].Adder2.b;
//   Adder[1].Adder2.AND.G1.x[1] = Adder[1].c_in;
//   Adder[1].Adder2.AND.G1.x[1] = c_in;
//   Adder[2].Adder1.AND.G2.y = Adder[2].Adder1.AND.y;
//   Adder[2].Adder1.AND.G2.y = Adder[2].Adder1.c;
//   Adder[2].Adder1.AND.G2.y = Adder[2].OR.x[1];
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder1.XOR.y;
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder1.s;
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder2.AND.G1.x[2];
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder2.AND.x[2];
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder2.XOR.G1.x[2];
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder2.XOR.x[2];
//   Adder[2].Adder1.XOR.G2.y = Adder[2].Adder2.a;
//   Adder[2].Adder2.XOR.G2.y = Adder[2].Adder2.XOR.y;
//   Adder[2].Adder2.XOR.G2.y = Adder[2].Adder2.s;
//   Adder[2].Adder2.XOR.G2.y = Adder[2].s;
//   Adder[2].Adder2.AND.G2.y = Adder[2].Adder2.AND.y;
//   Adder[2].Adder2.AND.G2.y = Adder[2].Adder2.c;
//   Adder[2].Adder2.AND.G2.y = Adder[2].OR.x[2];
//   Adder[2].Adder1.XOR.G1.y = Adder[2].Adder1.XOR.G2.x;
//   Adder[2].Adder1.AND.G1.y = Adder[2].Adder1.AND.G2.x;
//   Adder[2].Adder2.XOR.G1.y = Adder[2].Adder2.XOR.G2.x;
//   Adder[2].Adder2.AND.G1.y = Adder[2].Adder2.AND.G2.x;
//   Adder[1].Adder1.AND.G2.y = Adder[1].Adder1.AND.y;
//   Adder[1].Adder1.AND.G2.y = Adder[1].Adder1.c;
//   Adder[1].Adder1.AND.G2.y = Adder[1].OR.x[1];
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder1.XOR.y;
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder1.s;
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder2.AND.G1.x[2];
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder2.AND.x[2];
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder2.XOR.G1.x[2];
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder2.XOR.x[2];
//   Adder[1].Adder1.XOR.G2.y = Adder[1].Adder2.a;
//   Adder[1].Adder2.XOR.G2.y = Adder[1].Adder2.XOR.y;
//   Adder[1].Adder2.XOR.G2.y = Adder[1].Adder2.s;
//   Adder[1].Adder2.XOR.G2.y = Adder[1].s;
//   Adder[1].Adder2.AND.G2.y = Adder[1].Adder2.AND.y;
//   Adder[1].Adder2.AND.G2.y = Adder[1].Adder2.c;
//   Adder[1].Adder2.AND.G2.y = Adder[1].OR.x[2];
//   Adder[1].Adder1.XOR.G1.y = Adder[1].Adder1.XOR.G2.x;
//   Adder[1].Adder1.AND.G1.y = Adder[1].Adder1.AND.G2.x;
//   Adder[1].Adder2.XOR.G1.y = Adder[1].Adder2.XOR.G2.x;
//   Adder[1].Adder2.AND.G1.y = Adder[1].Adder2.AND.G2.x;
// algorithm
//   when {initial(),(Adder[1].Adder2.AND.G2.tLH > 0.0 OR Adder[1].Adder2.AND.G2.tHL > 0.0) AND change(Adder[1].Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder[1].Adder2.AND.G2.x_old := if initial() OR pre(Adder[1].Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[1].Adder2.AND.G2.y0 else pre(Adder[1].Adder2.AND.G2.x);
//     Adder[1].Adder2.AND.G2.lh := Adder[1].Adder2.AND.G2.delayTable[Adder[1].Adder2.AND.G2.x_old, Adder[1].Adder2.AND.G2.x];
//     Adder[1].Adder2.AND.G2.delayTime := if Adder[1].Adder2.AND.G2.lh > 0 then Adder[1].Adder2.AND.G2.tLH else if Adder[1].Adder2.AND.G2.lh < 0 then Adder[1].Adder2.AND.G2.tHL else 0.0;
//     Adder[1].Adder2.AND.G2.t_next := time + Adder[1].Adder2.AND.G2.delayTime;
//     if Adder[1].Adder2.AND.G2.lh == 0 OR abs(Adder[1].Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder[1].Adder2.AND.G2.y_auxiliary := Adder[1].Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder[1].Adder2.AND.G2.t_next then
//     Adder[1].Adder2.AND.G2.y_auxiliary := Adder[1].Adder2.AND.G2.x;
//   end when;
//   Adder[1].Adder2.AND.G2.y := if Adder[1].Adder2.AND.G2.tLH > 0.0 OR Adder[1].Adder2.AND.G2.tHL > 0.0 then Adder[1].Adder2.AND.G2.y_auxiliary else Adder[1].Adder2.AND.G2.x;
//   when {initial(),(Adder[1].Adder2.XOR.G2.tLH > 0.0 OR Adder[1].Adder2.XOR.G2.tHL > 0.0) AND change(Adder[1].Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder[1].Adder2.XOR.G2.x_old := if initial() OR pre(Adder[1].Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[1].Adder2.XOR.G2.y0 else pre(Adder[1].Adder2.XOR.G2.x);
//     Adder[1].Adder2.XOR.G2.lh := Adder[1].Adder2.XOR.G2.delayTable[Adder[1].Adder2.XOR.G2.x_old, Adder[1].Adder2.XOR.G2.x];
//     Adder[1].Adder2.XOR.G2.delayTime := if Adder[1].Adder2.XOR.G2.lh > 0 then Adder[1].Adder2.XOR.G2.tLH else if Adder[1].Adder2.XOR.G2.lh < 0 then Adder[1].Adder2.XOR.G2.tHL else 0.0;
//     Adder[1].Adder2.XOR.G2.t_next := time + Adder[1].Adder2.XOR.G2.delayTime;
//     if Adder[1].Adder2.XOR.G2.lh == 0 OR abs(Adder[1].Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder[1].Adder2.XOR.G2.y_auxiliary := Adder[1].Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder[1].Adder2.XOR.G2.t_next then
//     Adder[1].Adder2.XOR.G2.y_auxiliary := Adder[1].Adder2.XOR.G2.x;
//   end when;
//   Adder[1].Adder2.XOR.G2.y := if Adder[1].Adder2.XOR.G2.tLH > 0.0 OR Adder[1].Adder2.XOR.G2.tHL > 0.0 then Adder[1].Adder2.XOR.G2.y_auxiliary else Adder[1].Adder2.XOR.G2.x;
//   when {initial(),(Adder[1].Adder1.AND.G2.tLH > 0.0 OR Adder[1].Adder1.AND.G2.tHL > 0.0) AND change(Adder[1].Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder[1].Adder1.AND.G2.x_old := if initial() OR pre(Adder[1].Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[1].Adder1.AND.G2.y0 else pre(Adder[1].Adder1.AND.G2.x);
//     Adder[1].Adder1.AND.G2.lh := Adder[1].Adder1.AND.G2.delayTable[Adder[1].Adder1.AND.G2.x_old, Adder[1].Adder1.AND.G2.x];
//     Adder[1].Adder1.AND.G2.delayTime := if Adder[1].Adder1.AND.G2.lh > 0 then Adder[1].Adder1.AND.G2.tLH else if Adder[1].Adder1.AND.G2.lh < 0 then Adder[1].Adder1.AND.G2.tHL else 0.0;
//     Adder[1].Adder1.AND.G2.t_next := time + Adder[1].Adder1.AND.G2.delayTime;
//     if Adder[1].Adder1.AND.G2.lh == 0 OR abs(Adder[1].Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder[1].Adder1.AND.G2.y_auxiliary := Adder[1].Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder[1].Adder1.AND.G2.t_next then
//     Adder[1].Adder1.AND.G2.y_auxiliary := Adder[1].Adder1.AND.G2.x;
//   end when;
//   Adder[1].Adder1.AND.G2.y := if Adder[1].Adder1.AND.G2.tLH > 0.0 OR Adder[1].Adder1.AND.G2.tHL > 0.0 then Adder[1].Adder1.AND.G2.y_auxiliary else Adder[1].Adder1.AND.G2.x;
//   when {initial(),(Adder[1].Adder1.XOR.G2.tLH > 0.0 OR Adder[1].Adder1.XOR.G2.tHL > 0.0) AND change(Adder[1].Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder[1].Adder1.XOR.G2.x_old := if initial() OR pre(Adder[1].Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[1].Adder1.XOR.G2.y0 else pre(Adder[1].Adder1.XOR.G2.x);
//     Adder[1].Adder1.XOR.G2.lh := Adder[1].Adder1.XOR.G2.delayTable[Adder[1].Adder1.XOR.G2.x_old, Adder[1].Adder1.XOR.G2.x];
//     Adder[1].Adder1.XOR.G2.delayTime := if Adder[1].Adder1.XOR.G2.lh > 0 then Adder[1].Adder1.XOR.G2.tLH else if Adder[1].Adder1.XOR.G2.lh < 0 then Adder[1].Adder1.XOR.G2.tHL else 0.0;
//     Adder[1].Adder1.XOR.G2.t_next := time + Adder[1].Adder1.XOR.G2.delayTime;
//     if Adder[1].Adder1.XOR.G2.lh == 0 OR abs(Adder[1].Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder[1].Adder1.XOR.G2.y_auxiliary := Adder[1].Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder[1].Adder1.XOR.G2.t_next then
//     Adder[1].Adder1.XOR.G2.y_auxiliary := Adder[1].Adder1.XOR.G2.x;
//   end when;
//   Adder[1].Adder1.XOR.G2.y := if Adder[1].Adder1.XOR.G2.tLH > 0.0 OR Adder[1].Adder1.XOR.G2.tHL > 0.0 then Adder[1].Adder1.XOR.G2.y_auxiliary else Adder[1].Adder1.XOR.G2.x;
//   when {initial(),(Adder[2].Adder2.AND.G2.tLH > 0.0 OR Adder[2].Adder2.AND.G2.tHL > 0.0) AND change(Adder[2].Adder2.AND.G2.x) AND  NOT initial()} then
//     Adder[2].Adder2.AND.G2.x_old := if initial() OR pre(Adder[2].Adder2.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[2].Adder2.AND.G2.y0 else pre(Adder[2].Adder2.AND.G2.x);
//     Adder[2].Adder2.AND.G2.lh := Adder[2].Adder2.AND.G2.delayTable[Adder[2].Adder2.AND.G2.x_old, Adder[2].Adder2.AND.G2.x];
//     Adder[2].Adder2.AND.G2.delayTime := if Adder[2].Adder2.AND.G2.lh > 0 then Adder[2].Adder2.AND.G2.tLH else if Adder[2].Adder2.AND.G2.lh < 0 then Adder[2].Adder2.AND.G2.tHL else 0.0;
//     Adder[2].Adder2.AND.G2.t_next := time + Adder[2].Adder2.AND.G2.delayTime;
//     if Adder[2].Adder2.AND.G2.lh == 0 OR abs(Adder[2].Adder2.AND.G2.delayTime) < 1e-60 then
//       Adder[2].Adder2.AND.G2.y_auxiliary := Adder[2].Adder2.AND.G2.x;
//     end if;
//   elsewhen time >= Adder[2].Adder2.AND.G2.t_next then
//     Adder[2].Adder2.AND.G2.y_auxiliary := Adder[2].Adder2.AND.G2.x;
//   end when;
//   Adder[2].Adder2.AND.G2.y := if Adder[2].Adder2.AND.G2.tLH > 0.0 OR Adder[2].Adder2.AND.G2.tHL > 0.0 then Adder[2].Adder2.AND.G2.y_auxiliary else Adder[2].Adder2.AND.G2.x;
//   when {initial(),(Adder[2].Adder2.XOR.G2.tLH > 0.0 OR Adder[2].Adder2.XOR.G2.tHL > 0.0) AND change(Adder[2].Adder2.XOR.G2.x) AND  NOT initial()} then
//     Adder[2].Adder2.XOR.G2.x_old := if initial() OR pre(Adder[2].Adder2.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[2].Adder2.XOR.G2.y0 else pre(Adder[2].Adder2.XOR.G2.x);
//     Adder[2].Adder2.XOR.G2.lh := Adder[2].Adder2.XOR.G2.delayTable[Adder[2].Adder2.XOR.G2.x_old, Adder[2].Adder2.XOR.G2.x];
//     Adder[2].Adder2.XOR.G2.delayTime := if Adder[2].Adder2.XOR.G2.lh > 0 then Adder[2].Adder2.XOR.G2.tLH else if Adder[2].Adder2.XOR.G2.lh < 0 then Adder[2].Adder2.XOR.G2.tHL else 0.0;
//     Adder[2].Adder2.XOR.G2.t_next := time + Adder[2].Adder2.XOR.G2.delayTime;
//     if Adder[2].Adder2.XOR.G2.lh == 0 OR abs(Adder[2].Adder2.XOR.G2.delayTime) < 1e-60 then
//       Adder[2].Adder2.XOR.G2.y_auxiliary := Adder[2].Adder2.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder[2].Adder2.XOR.G2.t_next then
//     Adder[2].Adder2.XOR.G2.y_auxiliary := Adder[2].Adder2.XOR.G2.x;
//   end when;
//   Adder[2].Adder2.XOR.G2.y := if Adder[2].Adder2.XOR.G2.tLH > 0.0 OR Adder[2].Adder2.XOR.G2.tHL > 0.0 then Adder[2].Adder2.XOR.G2.y_auxiliary else Adder[2].Adder2.XOR.G2.x;
//   when {initial(),(Adder[2].Adder1.AND.G2.tLH > 0.0 OR Adder[2].Adder1.AND.G2.tHL > 0.0) AND change(Adder[2].Adder1.AND.G2.x) AND  NOT initial()} then
//     Adder[2].Adder1.AND.G2.x_old := if initial() OR pre(Adder[2].Adder1.AND.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[2].Adder1.AND.G2.y0 else pre(Adder[2].Adder1.AND.G2.x);
//     Adder[2].Adder1.AND.G2.lh := Adder[2].Adder1.AND.G2.delayTable[Adder[2].Adder1.AND.G2.x_old, Adder[2].Adder1.AND.G2.x];
//     Adder[2].Adder1.AND.G2.delayTime := if Adder[2].Adder1.AND.G2.lh > 0 then Adder[2].Adder1.AND.G2.tLH else if Adder[2].Adder1.AND.G2.lh < 0 then Adder[2].Adder1.AND.G2.tHL else 0.0;
//     Adder[2].Adder1.AND.G2.t_next := time + Adder[2].Adder1.AND.G2.delayTime;
//     if Adder[2].Adder1.AND.G2.lh == 0 OR abs(Adder[2].Adder1.AND.G2.delayTime) < 1e-60 then
//       Adder[2].Adder1.AND.G2.y_auxiliary := Adder[2].Adder1.AND.G2.x;
//     end if;
//   elsewhen time >= Adder[2].Adder1.AND.G2.t_next then
//     Adder[2].Adder1.AND.G2.y_auxiliary := Adder[2].Adder1.AND.G2.x;
//   end when;
//   Adder[2].Adder1.AND.G2.y := if Adder[2].Adder1.AND.G2.tLH > 0.0 OR Adder[2].Adder1.AND.G2.tHL > 0.0 then Adder[2].Adder1.AND.G2.y_auxiliary else Adder[2].Adder1.AND.G2.x;
//   when {initial(),(Adder[2].Adder1.XOR.G2.tLH > 0.0 OR Adder[2].Adder1.XOR.G2.tHL > 0.0) AND change(Adder[2].Adder1.XOR.G2.x) AND  NOT initial()} then
//     Adder[2].Adder1.XOR.G2.x_old := if initial() OR pre(Adder[2].Adder1.XOR.G2.x) == DAE.CAST(ENUM TYPE, 0) then Adder[2].Adder1.XOR.G2.y0 else pre(Adder[2].Adder1.XOR.G2.x);
//     Adder[2].Adder1.XOR.G2.lh := Adder[2].Adder1.XOR.G2.delayTable[Adder[2].Adder1.XOR.G2.x_old, Adder[2].Adder1.XOR.G2.x];
//     Adder[2].Adder1.XOR.G2.delayTime := if Adder[2].Adder1.XOR.G2.lh > 0 then Adder[2].Adder1.XOR.G2.tLH else if Adder[2].Adder1.XOR.G2.lh < 0 then Adder[2].Adder1.XOR.G2.tHL else 0.0;
//     Adder[2].Adder1.XOR.G2.t_next := time + Adder[2].Adder1.XOR.G2.delayTime;
//     if Adder[2].Adder1.XOR.G2.lh == 0 OR abs(Adder[2].Adder1.XOR.G2.delayTime) < 1e-60 then
//       Adder[2].Adder1.XOR.G2.y_auxiliary := Adder[2].Adder1.XOR.G2.x;
//     end if;
//   elsewhen time >= Adder[2].Adder1.XOR.G2.t_next then
//     Adder[2].Adder1.XOR.G2.y_auxiliary := Adder[2].Adder1.XOR.G2.x;
//   end when;
//   Adder[2].Adder1.XOR.G2.y := if Adder[2].Adder1.XOR.G2.tLH > 0.0 OR Adder[2].Adder1.XOR.G2.tHL > 0.0 then Adder[2].Adder1.XOR.G2.y_auxiliary else Adder[2].Adder1.XOR.G2.x;
// end Modelica.Electrical.Digital.Examples.Utilities.Adder;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.Adder completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.Adder has 807 equation(s) and 807 variable(s).
// 759 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.Counter3
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') enable;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q2;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') count;
//   parameter Real FF1.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.k;
//   parameter Real FF1.RS1.delayTime(quantity = "Time", unit = "s") = FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.q0 = FF1.q0 "initial value of output";
//   parameter Integer FF1.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF1.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF1.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF1.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.TD1.y0 = FF1.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS1.TD1.x_delayed;
//   parameter Real FF1.RS2.delayTime(quantity = "Time", unit = "s") = FF1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.q0 = FF1.q0 "initial value of output";
//   parameter Integer FF1.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF1.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF1.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF1.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.TD1.y0 = FF1.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.RS2.TD1.x_delayed;
//   parameter Integer FF1.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF1.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF1.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF1.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF1.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real FF2.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.k;
//   parameter Real FF2.RS1.delayTime(quantity = "Time", unit = "s") = FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.q0 = FF2.q0 "initial value of output";
//   parameter Integer FF2.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF2.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF2.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF2.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.TD1.y0 = FF2.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS1.TD1.x_delayed;
//   parameter Real FF2.RS2.delayTime(quantity = "Time", unit = "s") = FF2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.q0 = FF2.q0 "initial value of output";
//   parameter Integer FF2.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF2.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF2.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF2.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.TD1.y0 = FF2.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.RS2.TD1.x_delayed;
//   parameter Integer FF2.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF2.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF2.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF2.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF2.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real FF3.delayTime(quantity = "Time", unit = "s") = 0.001 "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.k;
//   parameter Real FF3.RS1.delayTime(quantity = "Time", unit = "s") = FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.q0 = FF3.q0 "initial value of output";
//   parameter Integer FF3.RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF3.RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF3.RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF3.RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.TD1.y0 = FF3.RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS1.TD1.x_delayed;
//   parameter Real FF3.RS2.delayTime(quantity = "Time", unit = "s") = FF3.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.q0 = FF3.q0 "initial value of output";
//   parameter Integer FF3.RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF3.RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF3.RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF3.RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.TD1.y0 = FF3.RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.RS2.TD1.x_delayed;
//   parameter Integer FF3.And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF3.And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF3.And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF3.And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF3.Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q1;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0;
// equation
//   FF1.RS1.Nor1.auxiliary[1] = FF1.RS1.Nor1.x[1];
//   FF1.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF1.RS1.Nor1.auxiliary[1],FF1.RS1.Nor1.x[2]];
//   FF1.RS1.Nor1.y = pre(D.Tables.NotTable[FF1.RS1.Nor1.auxiliary[2]]);
//   FF1.RS1.Nor2.auxiliary[1] = FF1.RS1.Nor2.x[1];
//   FF1.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF1.RS1.Nor2.auxiliary[1],FF1.RS1.Nor2.x[2]];
//   FF1.RS1.Nor2.y = pre(D.Tables.NotTable[FF1.RS1.Nor2.auxiliary[2]]);
//   FF1.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF1.RS1.TD1.x),FF1.RS1.TD1.delayTime,FF1.RS1.TD1.delayTime)));
//   FF1.RS1.TD1.y = if FF1.RS1.TD1.delayTime > 0.0 then if time >= FF1.RS1.TD1.delayTime then FF1.RS1.TD1.x_delayed else FF1.RS1.TD1.y0 else pre(FF1.RS1.TD1.x);
//   FF1.RS2.Nor1.auxiliary[1] = FF1.RS2.Nor1.x[1];
//   FF1.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF1.RS2.Nor1.auxiliary[1],FF1.RS2.Nor1.x[2]];
//   FF1.RS2.Nor1.y = pre(D.Tables.NotTable[FF1.RS2.Nor1.auxiliary[2]]);
//   FF1.RS2.Nor2.auxiliary[1] = FF1.RS2.Nor2.x[1];
//   FF1.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF1.RS2.Nor2.auxiliary[1],FF1.RS2.Nor2.x[2]];
//   FF1.RS2.Nor2.y = pre(D.Tables.NotTable[FF1.RS2.Nor2.auxiliary[2]]);
//   FF1.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF1.RS2.TD1.x),FF1.RS2.TD1.delayTime,FF1.RS2.TD1.delayTime)));
//   FF1.RS2.TD1.y = if FF1.RS2.TD1.delayTime > 0.0 then if time >= FF1.RS2.TD1.delayTime then FF1.RS2.TD1.x_delayed else FF1.RS2.TD1.y0 else pre(FF1.RS2.TD1.x);
//   FF1.And1.auxiliary[1] = FF1.And1.x[1];
//   FF1.And1.auxiliary[2] = D.Tables.AndTable[FF1.And1.auxiliary[1],FF1.And1.x[2]];
//   FF1.And1.auxiliary[3] = D.Tables.AndTable[FF1.And1.auxiliary[2],FF1.And1.x[3]];
//   FF1.And1.y = pre(FF1.And1.auxiliary[3]);
//   FF1.And2.auxiliary[1] = FF1.And2.x[1];
//   FF1.And2.auxiliary[2] = D.Tables.AndTable[FF1.And2.auxiliary[1],FF1.And2.x[2]];
//   FF1.And2.auxiliary[3] = D.Tables.AndTable[FF1.And2.auxiliary[2],FF1.And2.x[3]];
//   FF1.And2.y = pre(FF1.And2.auxiliary[3]);
//   FF1.And3.auxiliary[1] = FF1.And3.x[1];
//   FF1.And3.auxiliary[2] = D.Tables.AndTable[FF1.And3.auxiliary[1],FF1.And3.x[2]];
//   FF1.And3.y = pre(FF1.And3.auxiliary[2]);
//   FF1.And4.auxiliary[1] = FF1.And4.x[1];
//   FF1.And4.auxiliary[2] = D.Tables.AndTable[FF1.And4.auxiliary[1],FF1.And4.x[2]];
//   FF1.And4.y = pre(FF1.And4.auxiliary[2]);
//   FF1.Not1.auxiliary = D.Tables.NotTable[FF1.Not1.x];
//   FF1.Not1.y = pre(FF1.Not1.auxiliary);
//   FF2.RS1.Nor1.auxiliary[1] = FF2.RS1.Nor1.x[1];
//   FF2.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF2.RS1.Nor1.auxiliary[1],FF2.RS1.Nor1.x[2]];
//   FF2.RS1.Nor1.y = pre(D.Tables.NotTable[FF2.RS1.Nor1.auxiliary[2]]);
//   FF2.RS1.Nor2.auxiliary[1] = FF2.RS1.Nor2.x[1];
//   FF2.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF2.RS1.Nor2.auxiliary[1],FF2.RS1.Nor2.x[2]];
//   FF2.RS1.Nor2.y = pre(D.Tables.NotTable[FF2.RS1.Nor2.auxiliary[2]]);
//   FF2.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF2.RS1.TD1.x),FF2.RS1.TD1.delayTime,FF2.RS1.TD1.delayTime)));
//   FF2.RS1.TD1.y = if FF2.RS1.TD1.delayTime > 0.0 then if time >= FF2.RS1.TD1.delayTime then FF2.RS1.TD1.x_delayed else FF2.RS1.TD1.y0 else pre(FF2.RS1.TD1.x);
//   FF2.RS2.Nor1.auxiliary[1] = FF2.RS2.Nor1.x[1];
//   FF2.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF2.RS2.Nor1.auxiliary[1],FF2.RS2.Nor1.x[2]];
//   FF2.RS2.Nor1.y = pre(D.Tables.NotTable[FF2.RS2.Nor1.auxiliary[2]]);
//   FF2.RS2.Nor2.auxiliary[1] = FF2.RS2.Nor2.x[1];
//   FF2.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF2.RS2.Nor2.auxiliary[1],FF2.RS2.Nor2.x[2]];
//   FF2.RS2.Nor2.y = pre(D.Tables.NotTable[FF2.RS2.Nor2.auxiliary[2]]);
//   FF2.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF2.RS2.TD1.x),FF2.RS2.TD1.delayTime,FF2.RS2.TD1.delayTime)));
//   FF2.RS2.TD1.y = if FF2.RS2.TD1.delayTime > 0.0 then if time >= FF2.RS2.TD1.delayTime then FF2.RS2.TD1.x_delayed else FF2.RS2.TD1.y0 else pre(FF2.RS2.TD1.x);
//   FF2.And1.auxiliary[1] = FF2.And1.x[1];
//   FF2.And1.auxiliary[2] = D.Tables.AndTable[FF2.And1.auxiliary[1],FF2.And1.x[2]];
//   FF2.And1.auxiliary[3] = D.Tables.AndTable[FF2.And1.auxiliary[2],FF2.And1.x[3]];
//   FF2.And1.y = pre(FF2.And1.auxiliary[3]);
//   FF2.And2.auxiliary[1] = FF2.And2.x[1];
//   FF2.And2.auxiliary[2] = D.Tables.AndTable[FF2.And2.auxiliary[1],FF2.And2.x[2]];
//   FF2.And2.auxiliary[3] = D.Tables.AndTable[FF2.And2.auxiliary[2],FF2.And2.x[3]];
//   FF2.And2.y = pre(FF2.And2.auxiliary[3]);
//   FF2.And3.auxiliary[1] = FF2.And3.x[1];
//   FF2.And3.auxiliary[2] = D.Tables.AndTable[FF2.And3.auxiliary[1],FF2.And3.x[2]];
//   FF2.And3.y = pre(FF2.And3.auxiliary[2]);
//   FF2.And4.auxiliary[1] = FF2.And4.x[1];
//   FF2.And4.auxiliary[2] = D.Tables.AndTable[FF2.And4.auxiliary[1],FF2.And4.x[2]];
//   FF2.And4.y = pre(FF2.And4.auxiliary[2]);
//   FF2.Not1.auxiliary = D.Tables.NotTable[FF2.Not1.x];
//   FF2.Not1.y = pre(FF2.Not1.auxiliary);
//   FF3.RS1.Nor1.auxiliary[1] = FF3.RS1.Nor1.x[1];
//   FF3.RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF3.RS1.Nor1.auxiliary[1],FF3.RS1.Nor1.x[2]];
//   FF3.RS1.Nor1.y = pre(D.Tables.NotTable[FF3.RS1.Nor1.auxiliary[2]]);
//   FF3.RS1.Nor2.auxiliary[1] = FF3.RS1.Nor2.x[1];
//   FF3.RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF3.RS1.Nor2.auxiliary[1],FF3.RS1.Nor2.x[2]];
//   FF3.RS1.Nor2.y = pre(D.Tables.NotTable[FF3.RS1.Nor2.auxiliary[2]]);
//   FF3.RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF3.RS1.TD1.x),FF3.RS1.TD1.delayTime,FF3.RS1.TD1.delayTime)));
//   FF3.RS1.TD1.y = if FF3.RS1.TD1.delayTime > 0.0 then if time >= FF3.RS1.TD1.delayTime then FF3.RS1.TD1.x_delayed else FF3.RS1.TD1.y0 else pre(FF3.RS1.TD1.x);
//   FF3.RS2.Nor1.auxiliary[1] = FF3.RS2.Nor1.x[1];
//   FF3.RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF3.RS2.Nor1.auxiliary[1],FF3.RS2.Nor1.x[2]];
//   FF3.RS2.Nor1.y = pre(D.Tables.NotTable[FF3.RS2.Nor1.auxiliary[2]]);
//   FF3.RS2.Nor2.auxiliary[1] = FF3.RS2.Nor2.x[1];
//   FF3.RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF3.RS2.Nor2.auxiliary[1],FF3.RS2.Nor2.x[2]];
//   FF3.RS2.Nor2.y = pre(D.Tables.NotTable[FF3.RS2.Nor2.auxiliary[2]]);
//   FF3.RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF3.RS2.TD1.x),FF3.RS2.TD1.delayTime,FF3.RS2.TD1.delayTime)));
//   FF3.RS2.TD1.y = if FF3.RS2.TD1.delayTime > 0.0 then if time >= FF3.RS2.TD1.delayTime then FF3.RS2.TD1.x_delayed else FF3.RS2.TD1.y0 else pre(FF3.RS2.TD1.x);
//   FF3.And1.auxiliary[1] = FF3.And1.x[1];
//   FF3.And1.auxiliary[2] = D.Tables.AndTable[FF3.And1.auxiliary[1],FF3.And1.x[2]];
//   FF3.And1.auxiliary[3] = D.Tables.AndTable[FF3.And1.auxiliary[2],FF3.And1.x[3]];
//   FF3.And1.y = pre(FF3.And1.auxiliary[3]);
//   FF3.And2.auxiliary[1] = FF3.And2.x[1];
//   FF3.And2.auxiliary[2] = D.Tables.AndTable[FF3.And2.auxiliary[1],FF3.And2.x[2]];
//   FF3.And2.auxiliary[3] = D.Tables.AndTable[FF3.And2.auxiliary[2],FF3.And2.x[3]];
//   FF3.And2.y = pre(FF3.And2.auxiliary[3]);
//   FF3.And3.auxiliary[1] = FF3.And3.x[1];
//   FF3.And3.auxiliary[2] = D.Tables.AndTable[FF3.And3.auxiliary[1],FF3.And3.x[2]];
//   FF3.And3.y = pre(FF3.And3.auxiliary[2]);
//   FF3.And4.auxiliary[1] = FF3.And4.x[1];
//   FF3.And4.auxiliary[2] = D.Tables.AndTable[FF3.And4.auxiliary[1],FF3.And4.x[2]];
//   FF3.And4.y = pre(FF3.And4.auxiliary[2]);
//   FF3.Not1.auxiliary = D.Tables.NotTable[FF3.Not1.x];
//   FF3.Not1.y = pre(FF3.Not1.auxiliary);
//   FF2.And1.x[3] = FF2.RS1.Nor1.y;
//   FF2.And1.x[3] = FF2.RS1.TD1.x;
//   FF2.And1.x[3] = FF2.RS1.qn;
//   FF2.And1.x[3] = FF2.q;
//   FF2.And1.x[3] = FF3.And1.x[1];
//   FF2.And1.x[3] = FF3.And2.x[3];
//   FF2.And1.x[3] = FF3.Not1.x;
//   FF2.And1.x[3] = FF3.clk;
//   FF2.And1.x[3] = q1;
//   FF1.And1.x[3] = FF1.RS1.Nor1.y;
//   FF1.And1.x[3] = FF1.RS1.TD1.x;
//   FF1.And1.x[3] = FF1.RS1.qn;
//   FF1.And1.x[3] = FF1.q;
//   FF1.And1.x[3] = FF2.And1.x[1];
//   FF1.And1.x[3] = FF2.And2.x[3];
//   FF1.And1.x[3] = FF2.Not1.x;
//   FF1.And1.x[3] = FF2.clk;
//   FF1.And1.x[3] = q0;
//   FF3.And1.x[3] = FF3.RS1.Nor1.y;
//   FF3.And1.x[3] = FF3.RS1.TD1.x;
//   FF3.And1.x[3] = FF3.RS1.qn;
//   FF3.And1.x[3] = FF3.q;
//   FF3.And1.x[3] = q2;
//   FF1.And1.x[2] = FF1.And2.x[2];
//   FF1.And1.x[2] = FF1.j;
//   FF1.And1.x[2] = FF1.k;
//   FF1.And1.x[2] = FF2.And1.x[2];
//   FF1.And1.x[2] = FF2.And2.x[2];
//   FF1.And1.x[2] = FF2.j;
//   FF1.And1.x[2] = FF2.k;
//   FF1.And1.x[2] = FF3.And1.x[2];
//   FF1.And1.x[2] = FF3.And2.x[2];
//   FF1.And1.x[2] = FF3.j;
//   FF1.And1.x[2] = FF3.k;
//   FF1.And1.x[2] = enable;
//   FF1.And1.x[1] = FF1.And2.x[3];
//   FF1.And1.x[1] = FF1.Not1.x;
//   FF1.And1.x[1] = FF1.clk;
//   FF1.And1.x[1] = count;
//   FF3.And2.x[1] = FF3.RS1.Nor1.x[1];
//   FF3.And2.x[1] = FF3.RS1.Nor2.y;
//   FF3.And2.x[1] = FF3.RS1.q;
//   FF3.And2.x[1] = FF3.qn;
//   FF3.And3.x[1] = FF3.And4.x[1];
//   FF3.And3.x[1] = FF3.Not1.y;
//   FF3.And3.x[2] = FF3.RS2.Nor1.x[1];
//   FF3.And3.x[2] = FF3.RS2.Nor2.y;
//   FF3.And3.x[2] = FF3.RS2.q;
//   FF3.And4.x[2] = FF3.RS2.Nor1.y;
//   FF3.And4.x[2] = FF3.RS2.TD1.x;
//   FF3.And4.x[2] = FF3.RS2.qn;
//   FF3.And3.y = FF3.RS1.Nor1.x[2];
//   FF3.And3.y = FF3.RS1.s;
//   FF3.And4.y = FF3.RS1.Nor2.x[1];
//   FF3.And4.y = FF3.RS1.r;
//   FF3.And1.y = FF3.RS2.Nor1.x[2];
//   FF3.And1.y = FF3.RS2.s;
//   FF3.And2.y = FF3.RS2.Nor2.x[1];
//   FF3.And2.y = FF3.RS2.r;
//   FF3.RS2.Nor2.x[2] = FF3.RS2.TD1.y;
//   FF3.RS1.Nor2.x[2] = FF3.RS1.TD1.y;
//   FF2.And2.x[1] = FF2.RS1.Nor1.x[1];
//   FF2.And2.x[1] = FF2.RS1.Nor2.y;
//   FF2.And2.x[1] = FF2.RS1.q;
//   FF2.And2.x[1] = FF2.qn;
//   FF2.And3.x[1] = FF2.And4.x[1];
//   FF2.And3.x[1] = FF2.Not1.y;
//   FF2.And3.x[2] = FF2.RS2.Nor1.x[1];
//   FF2.And3.x[2] = FF2.RS2.Nor2.y;
//   FF2.And3.x[2] = FF2.RS2.q;
//   FF2.And4.x[2] = FF2.RS2.Nor1.y;
//   FF2.And4.x[2] = FF2.RS2.TD1.x;
//   FF2.And4.x[2] = FF2.RS2.qn;
//   FF2.And3.y = FF2.RS1.Nor1.x[2];
//   FF2.And3.y = FF2.RS1.s;
//   FF2.And4.y = FF2.RS1.Nor2.x[1];
//   FF2.And4.y = FF2.RS1.r;
//   FF2.And1.y = FF2.RS2.Nor1.x[2];
//   FF2.And1.y = FF2.RS2.s;
//   FF2.And2.y = FF2.RS2.Nor2.x[1];
//   FF2.And2.y = FF2.RS2.r;
//   FF2.RS2.Nor2.x[2] = FF2.RS2.TD1.y;
//   FF2.RS1.Nor2.x[2] = FF2.RS1.TD1.y;
//   FF1.And2.x[1] = FF1.RS1.Nor1.x[1];
//   FF1.And2.x[1] = FF1.RS1.Nor2.y;
//   FF1.And2.x[1] = FF1.RS1.q;
//   FF1.And2.x[1] = FF1.qn;
//   FF1.And3.x[1] = FF1.And4.x[1];
//   FF1.And3.x[1] = FF1.Not1.y;
//   FF1.And3.x[2] = FF1.RS2.Nor1.x[1];
//   FF1.And3.x[2] = FF1.RS2.Nor2.y;
//   FF1.And3.x[2] = FF1.RS2.q;
//   FF1.And4.x[2] = FF1.RS2.Nor1.y;
//   FF1.And4.x[2] = FF1.RS2.TD1.x;
//   FF1.And4.x[2] = FF1.RS2.qn;
//   FF1.And3.y = FF1.RS1.Nor1.x[2];
//   FF1.And3.y = FF1.RS1.s;
//   FF1.And4.y = FF1.RS1.Nor2.x[1];
//   FF1.And4.y = FF1.RS1.r;
//   FF1.And1.y = FF1.RS2.Nor1.x[2];
//   FF1.And1.y = FF1.RS2.s;
//   FF1.And2.y = FF1.RS2.Nor2.x[1];
//   FF1.And2.y = FF1.RS2.r;
//   FF1.RS2.Nor2.x[2] = FF1.RS2.TD1.y;
//   FF1.RS1.Nor2.x[2] = FF1.RS1.TD1.y;
// end Modelica.Electrical.Digital.Examples.Utilities.Counter3;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.Counter3 completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.Counter3 has 201 equation(s) and 201 variable(s).
// 201 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Examples.Utilities.Counter
//   parameter Integer n = 3 "number of bits";
//   parameter Real delayTime(quantity = "Time", unit = "s") = 0.001 "delay of each JKFF";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q0 = Modelica.Electrical.Digital.Interfaces.Logic.'0' "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') enable;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') count;
//   parameter Real FF[1].delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].q0 = q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].k;
//   parameter Real FF[1].RS1.delayTime(quantity = "Time", unit = "s") = FF[1].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.q0 = FF[1].q0 "initial value of output";
//   parameter Integer FF[1].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[1].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF[1].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[1].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.TD1.y0 = FF[1].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS1.TD1.x_delayed;
//   parameter Real FF[1].RS2.delayTime(quantity = "Time", unit = "s") = FF[1].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.q0 = FF[1].q0 "initial value of output";
//   parameter Integer FF[1].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[1].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF[1].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[1].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.TD1.y0 = FF[1].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].RS2.TD1.x_delayed;
//   parameter Integer FF[1].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[1].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[1].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[1].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[1].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real FF[2].delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].q0 = q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].k;
//   parameter Real FF[2].RS1.delayTime(quantity = "Time", unit = "s") = FF[2].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.q0 = FF[2].q0 "initial value of output";
//   parameter Integer FF[2].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[2].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF[2].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[2].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.TD1.y0 = FF[2].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS1.TD1.x_delayed;
//   parameter Real FF[2].RS2.delayTime(quantity = "Time", unit = "s") = FF[2].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.q0 = FF[2].q0 "initial value of output";
//   parameter Integer FF[2].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[2].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF[2].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[2].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.TD1.y0 = FF[2].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].RS2.TD1.x_delayed;
//   parameter Integer FF[2].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[2].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[2].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[2].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[2].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   parameter Real FF[3].delayTime(quantity = "Time", unit = "s") = delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].q0 = q0 "initial value";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].j;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].qn "not Q";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].clk;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].k;
//   parameter Real FF[3].RS1.delayTime(quantity = "Time", unit = "s") = FF[3].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.q0 = FF[3].q0 "initial value of output";
//   parameter Integer FF[3].RS1.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[3].RS1.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.TD1.y "Connector of Digital output signal";
//   parameter Real FF[3].RS1.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[3].RS1.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.TD1.y0 = FF[3].RS1.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS1.TD1.x_delayed;
//   parameter Real FF[3].RS2.delayTime(quantity = "Time", unit = "s") = FF[3].delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.q0 = FF[3].q0 "initial value of output";
//   parameter Integer FF[3].RS2.Nor1.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[3].RS2.Nor2.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor2.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.Nor2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.s;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.r;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.q;
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.qn;
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.TD1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.TD1.y "Connector of Digital output signal";
//   parameter Real FF[3].RS2.TD1.delayTime(quantity = "Time", unit = "s", start = 0.0) = FF[3].RS2.delayTime "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.TD1.y0 = FF[3].RS2.q0 "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].RS2.TD1.x_delayed;
//   parameter Integer FF[3].And1.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And1.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[3].And2.n(min = 2) = 3 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.x[2] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.x[3] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And2.auxiliary[3](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[3].And3.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And3.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And3.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And3.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And3.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And3.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   parameter Integer FF[3].And4.n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And4.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And4.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And4.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And4.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].And4.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].Not1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].Not1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') FF[3].Not1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q[1];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q[2];
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') q[3];
// equation
//   FF[1].RS1.Nor1.auxiliary[1] = FF[1].RS1.Nor1.x[1];
//   FF[1].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF[1].RS1.Nor1.auxiliary[1],FF[1].RS1.Nor1.x[2]];
//   FF[1].RS1.Nor1.y = pre(D.Tables.NotTable[FF[1].RS1.Nor1.auxiliary[2]]);
//   FF[1].RS1.Nor2.auxiliary[1] = FF[1].RS1.Nor2.x[1];
//   FF[1].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF[1].RS1.Nor2.auxiliary[1],FF[1].RS1.Nor2.x[2]];
//   FF[1].RS1.Nor2.y = pre(D.Tables.NotTable[FF[1].RS1.Nor2.auxiliary[2]]);
//   FF[1].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[1].RS1.TD1.x),FF[1].RS1.TD1.delayTime,FF[1].RS1.TD1.delayTime)));
//   FF[1].RS1.TD1.y = if FF[1].RS1.TD1.delayTime > 0.0 then if time >= FF[1].RS1.TD1.delayTime then FF[1].RS1.TD1.x_delayed else FF[1].RS1.TD1.y0 else pre(FF[1].RS1.TD1.x);
//   FF[1].RS2.Nor1.auxiliary[1] = FF[1].RS2.Nor1.x[1];
//   FF[1].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF[1].RS2.Nor1.auxiliary[1],FF[1].RS2.Nor1.x[2]];
//   FF[1].RS2.Nor1.y = pre(D.Tables.NotTable[FF[1].RS2.Nor1.auxiliary[2]]);
//   FF[1].RS2.Nor2.auxiliary[1] = FF[1].RS2.Nor2.x[1];
//   FF[1].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF[1].RS2.Nor2.auxiliary[1],FF[1].RS2.Nor2.x[2]];
//   FF[1].RS2.Nor2.y = pre(D.Tables.NotTable[FF[1].RS2.Nor2.auxiliary[2]]);
//   FF[1].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[1].RS2.TD1.x),FF[1].RS2.TD1.delayTime,FF[1].RS2.TD1.delayTime)));
//   FF[1].RS2.TD1.y = if FF[1].RS2.TD1.delayTime > 0.0 then if time >= FF[1].RS2.TD1.delayTime then FF[1].RS2.TD1.x_delayed else FF[1].RS2.TD1.y0 else pre(FF[1].RS2.TD1.x);
//   FF[1].And1.auxiliary[1] = FF[1].And1.x[1];
//   FF[1].And1.auxiliary[2] = D.Tables.AndTable[FF[1].And1.auxiliary[1],FF[1].And1.x[2]];
//   FF[1].And1.auxiliary[3] = D.Tables.AndTable[FF[1].And1.auxiliary[2],FF[1].And1.x[3]];
//   FF[1].And1.y = pre(FF[1].And1.auxiliary[3]);
//   FF[1].And2.auxiliary[1] = FF[1].And2.x[1];
//   FF[1].And2.auxiliary[2] = D.Tables.AndTable[FF[1].And2.auxiliary[1],FF[1].And2.x[2]];
//   FF[1].And2.auxiliary[3] = D.Tables.AndTable[FF[1].And2.auxiliary[2],FF[1].And2.x[3]];
//   FF[1].And2.y = pre(FF[1].And2.auxiliary[3]);
//   FF[1].And3.auxiliary[1] = FF[1].And3.x[1];
//   FF[1].And3.auxiliary[2] = D.Tables.AndTable[FF[1].And3.auxiliary[1],FF[1].And3.x[2]];
//   FF[1].And3.y = pre(FF[1].And3.auxiliary[2]);
//   FF[1].And4.auxiliary[1] = FF[1].And4.x[1];
//   FF[1].And4.auxiliary[2] = D.Tables.AndTable[FF[1].And4.auxiliary[1],FF[1].And4.x[2]];
//   FF[1].And4.y = pre(FF[1].And4.auxiliary[2]);
//   FF[1].Not1.auxiliary = D.Tables.NotTable[FF[1].Not1.x];
//   FF[1].Not1.y = pre(FF[1].Not1.auxiliary);
//   FF[2].RS1.Nor1.auxiliary[1] = FF[2].RS1.Nor1.x[1];
//   FF[2].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF[2].RS1.Nor1.auxiliary[1],FF[2].RS1.Nor1.x[2]];
//   FF[2].RS1.Nor1.y = pre(D.Tables.NotTable[FF[2].RS1.Nor1.auxiliary[2]]);
//   FF[2].RS1.Nor2.auxiliary[1] = FF[2].RS1.Nor2.x[1];
//   FF[2].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF[2].RS1.Nor2.auxiliary[1],FF[2].RS1.Nor2.x[2]];
//   FF[2].RS1.Nor2.y = pre(D.Tables.NotTable[FF[2].RS1.Nor2.auxiliary[2]]);
//   FF[2].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[2].RS1.TD1.x),FF[2].RS1.TD1.delayTime,FF[2].RS1.TD1.delayTime)));
//   FF[2].RS1.TD1.y = if FF[2].RS1.TD1.delayTime > 0.0 then if time >= FF[2].RS1.TD1.delayTime then FF[2].RS1.TD1.x_delayed else FF[2].RS1.TD1.y0 else pre(FF[2].RS1.TD1.x);
//   FF[2].RS2.Nor1.auxiliary[1] = FF[2].RS2.Nor1.x[1];
//   FF[2].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF[2].RS2.Nor1.auxiliary[1],FF[2].RS2.Nor1.x[2]];
//   FF[2].RS2.Nor1.y = pre(D.Tables.NotTable[FF[2].RS2.Nor1.auxiliary[2]]);
//   FF[2].RS2.Nor2.auxiliary[1] = FF[2].RS2.Nor2.x[1];
//   FF[2].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF[2].RS2.Nor2.auxiliary[1],FF[2].RS2.Nor2.x[2]];
//   FF[2].RS2.Nor2.y = pre(D.Tables.NotTable[FF[2].RS2.Nor2.auxiliary[2]]);
//   FF[2].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[2].RS2.TD1.x),FF[2].RS2.TD1.delayTime,FF[2].RS2.TD1.delayTime)));
//   FF[2].RS2.TD1.y = if FF[2].RS2.TD1.delayTime > 0.0 then if time >= FF[2].RS2.TD1.delayTime then FF[2].RS2.TD1.x_delayed else FF[2].RS2.TD1.y0 else pre(FF[2].RS2.TD1.x);
//   FF[2].And1.auxiliary[1] = FF[2].And1.x[1];
//   FF[2].And1.auxiliary[2] = D.Tables.AndTable[FF[2].And1.auxiliary[1],FF[2].And1.x[2]];
//   FF[2].And1.auxiliary[3] = D.Tables.AndTable[FF[2].And1.auxiliary[2],FF[2].And1.x[3]];
//   FF[2].And1.y = pre(FF[2].And1.auxiliary[3]);
//   FF[2].And2.auxiliary[1] = FF[2].And2.x[1];
//   FF[2].And2.auxiliary[2] = D.Tables.AndTable[FF[2].And2.auxiliary[1],FF[2].And2.x[2]];
//   FF[2].And2.auxiliary[3] = D.Tables.AndTable[FF[2].And2.auxiliary[2],FF[2].And2.x[3]];
//   FF[2].And2.y = pre(FF[2].And2.auxiliary[3]);
//   FF[2].And3.auxiliary[1] = FF[2].And3.x[1];
//   FF[2].And3.auxiliary[2] = D.Tables.AndTable[FF[2].And3.auxiliary[1],FF[2].And3.x[2]];
//   FF[2].And3.y = pre(FF[2].And3.auxiliary[2]);
//   FF[2].And4.auxiliary[1] = FF[2].And4.x[1];
//   FF[2].And4.auxiliary[2] = D.Tables.AndTable[FF[2].And4.auxiliary[1],FF[2].And4.x[2]];
//   FF[2].And4.y = pre(FF[2].And4.auxiliary[2]);
//   FF[2].Not1.auxiliary = D.Tables.NotTable[FF[2].Not1.x];
//   FF[2].Not1.y = pre(FF[2].Not1.auxiliary);
//   FF[3].RS1.Nor1.auxiliary[1] = FF[3].RS1.Nor1.x[1];
//   FF[3].RS1.Nor1.auxiliary[2] = D.Tables.OrTable[FF[3].RS1.Nor1.auxiliary[1],FF[3].RS1.Nor1.x[2]];
//   FF[3].RS1.Nor1.y = pre(D.Tables.NotTable[FF[3].RS1.Nor1.auxiliary[2]]);
//   FF[3].RS1.Nor2.auxiliary[1] = FF[3].RS1.Nor2.x[1];
//   FF[3].RS1.Nor2.auxiliary[2] = D.Tables.OrTable[FF[3].RS1.Nor2.auxiliary[1],FF[3].RS1.Nor2.x[2]];
//   FF[3].RS1.Nor2.y = pre(D.Tables.NotTable[FF[3].RS1.Nor2.auxiliary[2]]);
//   FF[3].RS1.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[3].RS1.TD1.x),FF[3].RS1.TD1.delayTime,FF[3].RS1.TD1.delayTime)));
//   FF[3].RS1.TD1.y = if FF[3].RS1.TD1.delayTime > 0.0 then if time >= FF[3].RS1.TD1.delayTime then FF[3].RS1.TD1.x_delayed else FF[3].RS1.TD1.y0 else pre(FF[3].RS1.TD1.x);
//   FF[3].RS2.Nor1.auxiliary[1] = FF[3].RS2.Nor1.x[1];
//   FF[3].RS2.Nor1.auxiliary[2] = D.Tables.OrTable[FF[3].RS2.Nor1.auxiliary[1],FF[3].RS2.Nor1.x[2]];
//   FF[3].RS2.Nor1.y = pre(D.Tables.NotTable[FF[3].RS2.Nor1.auxiliary[2]]);
//   FF[3].RS2.Nor2.auxiliary[1] = FF[3].RS2.Nor2.x[1];
//   FF[3].RS2.Nor2.auxiliary[2] = D.Tables.OrTable[FF[3].RS2.Nor2.auxiliary[1],FF[3].RS2.Nor2.x[2]];
//   FF[3].RS2.Nor2.y = pre(D.Tables.NotTable[FF[3].RS2.Nor2.auxiliary[2]]);
//   FF[3].RS2.TD1.x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(FF[3].RS2.TD1.x),FF[3].RS2.TD1.delayTime,FF[3].RS2.TD1.delayTime)));
//   FF[3].RS2.TD1.y = if FF[3].RS2.TD1.delayTime > 0.0 then if time >= FF[3].RS2.TD1.delayTime then FF[3].RS2.TD1.x_delayed else FF[3].RS2.TD1.y0 else pre(FF[3].RS2.TD1.x);
//   FF[3].And1.auxiliary[1] = FF[3].And1.x[1];
//   FF[3].And1.auxiliary[2] = D.Tables.AndTable[FF[3].And1.auxiliary[1],FF[3].And1.x[2]];
//   FF[3].And1.auxiliary[3] = D.Tables.AndTable[FF[3].And1.auxiliary[2],FF[3].And1.x[3]];
//   FF[3].And1.y = pre(FF[3].And1.auxiliary[3]);
//   FF[3].And2.auxiliary[1] = FF[3].And2.x[1];
//   FF[3].And2.auxiliary[2] = D.Tables.AndTable[FF[3].And2.auxiliary[1],FF[3].And2.x[2]];
//   FF[3].And2.auxiliary[3] = D.Tables.AndTable[FF[3].And2.auxiliary[2],FF[3].And2.x[3]];
//   FF[3].And2.y = pre(FF[3].And2.auxiliary[3]);
//   FF[3].And3.auxiliary[1] = FF[3].And3.x[1];
//   FF[3].And3.auxiliary[2] = D.Tables.AndTable[FF[3].And3.auxiliary[1],FF[3].And3.x[2]];
//   FF[3].And3.y = pre(FF[3].And3.auxiliary[2]);
//   FF[3].And4.auxiliary[1] = FF[3].And4.x[1];
//   FF[3].And4.auxiliary[2] = D.Tables.AndTable[FF[3].And4.auxiliary[1],FF[3].And4.x[2]];
//   FF[3].And4.y = pre(FF[3].And4.auxiliary[2]);
//   FF[3].Not1.auxiliary = D.Tables.NotTable[FF[3].Not1.x];
//   FF[3].Not1.y = pre(FF[3].Not1.auxiliary);
//   FF[3].And1.x[3] = FF[3].RS1.Nor1.y;
//   FF[3].And1.x[3] = FF[3].RS1.TD1.x;
//   FF[3].And1.x[3] = FF[3].RS1.qn;
//   FF[3].And1.x[3] = FF[3].q;
//   FF[3].And1.x[3] = q[3];
//   FF[2].And1.x[3] = FF[2].RS1.Nor1.y;
//   FF[2].And1.x[3] = FF[2].RS1.TD1.x;
//   FF[2].And1.x[3] = FF[2].RS1.qn;
//   FF[2].And1.x[3] = FF[2].q;
//   FF[2].And1.x[3] = FF[3].And1.x[1];
//   FF[2].And1.x[3] = FF[3].And2.x[3];
//   FF[2].And1.x[3] = FF[3].Not1.x;
//   FF[2].And1.x[3] = FF[3].clk;
//   FF[2].And1.x[3] = q[2];
//   FF[1].And1.x[2] = FF[1].And2.x[2];
//   FF[1].And1.x[2] = FF[1].j;
//   FF[1].And1.x[2] = FF[1].k;
//   FF[1].And1.x[2] = FF[2].And1.x[2];
//   FF[1].And1.x[2] = FF[2].And2.x[2];
//   FF[1].And1.x[2] = FF[2].j;
//   FF[1].And1.x[2] = FF[2].k;
//   FF[1].And1.x[2] = FF[3].And1.x[2];
//   FF[1].And1.x[2] = FF[3].And2.x[2];
//   FF[1].And1.x[2] = FF[3].j;
//   FF[1].And1.x[2] = FF[3].k;
//   FF[1].And1.x[2] = enable;
//   FF[1].And1.x[3] = FF[1].RS1.Nor1.y;
//   FF[1].And1.x[3] = FF[1].RS1.TD1.x;
//   FF[1].And1.x[3] = FF[1].RS1.qn;
//   FF[1].And1.x[3] = FF[1].q;
//   FF[1].And1.x[3] = FF[2].And1.x[1];
//   FF[1].And1.x[3] = FF[2].And2.x[3];
//   FF[1].And1.x[3] = FF[2].Not1.x;
//   FF[1].And1.x[3] = FF[2].clk;
//   FF[1].And1.x[3] = q[1];
//   FF[1].And1.x[1] = FF[1].And2.x[3];
//   FF[1].And1.x[1] = FF[1].Not1.x;
//   FF[1].And1.x[1] = FF[1].clk;
//   FF[1].And1.x[1] = count;
//   FF[3].And2.x[1] = FF[3].RS1.Nor1.x[1];
//   FF[3].And2.x[1] = FF[3].RS1.Nor2.y;
//   FF[3].And2.x[1] = FF[3].RS1.q;
//   FF[3].And2.x[1] = FF[3].qn;
//   FF[3].And3.x[1] = FF[3].And4.x[1];
//   FF[3].And3.x[1] = FF[3].Not1.y;
//   FF[3].And3.x[2] = FF[3].RS2.Nor1.x[1];
//   FF[3].And3.x[2] = FF[3].RS2.Nor2.y;
//   FF[3].And3.x[2] = FF[3].RS2.q;
//   FF[3].And4.x[2] = FF[3].RS2.Nor1.y;
//   FF[3].And4.x[2] = FF[3].RS2.TD1.x;
//   FF[3].And4.x[2] = FF[3].RS2.qn;
//   FF[3].And3.y = FF[3].RS1.Nor1.x[2];
//   FF[3].And3.y = FF[3].RS1.s;
//   FF[3].And4.y = FF[3].RS1.Nor2.x[1];
//   FF[3].And4.y = FF[3].RS1.r;
//   FF[3].And1.y = FF[3].RS2.Nor1.x[2];
//   FF[3].And1.y = FF[3].RS2.s;
//   FF[3].And2.y = FF[3].RS2.Nor2.x[1];
//   FF[3].And2.y = FF[3].RS2.r;
//   FF[3].RS2.Nor2.x[2] = FF[3].RS2.TD1.y;
//   FF[3].RS1.Nor2.x[2] = FF[3].RS1.TD1.y;
//   FF[2].And2.x[1] = FF[2].RS1.Nor1.x[1];
//   FF[2].And2.x[1] = FF[2].RS1.Nor2.y;
//   FF[2].And2.x[1] = FF[2].RS1.q;
//   FF[2].And2.x[1] = FF[2].qn;
//   FF[2].And3.x[1] = FF[2].And4.x[1];
//   FF[2].And3.x[1] = FF[2].Not1.y;
//   FF[2].And3.x[2] = FF[2].RS2.Nor1.x[1];
//   FF[2].And3.x[2] = FF[2].RS2.Nor2.y;
//   FF[2].And3.x[2] = FF[2].RS2.q;
//   FF[2].And4.x[2] = FF[2].RS2.Nor1.y;
//   FF[2].And4.x[2] = FF[2].RS2.TD1.x;
//   FF[2].And4.x[2] = FF[2].RS2.qn;
//   FF[2].And3.y = FF[2].RS1.Nor1.x[2];
//   FF[2].And3.y = FF[2].RS1.s;
//   FF[2].And4.y = FF[2].RS1.Nor2.x[1];
//   FF[2].And4.y = FF[2].RS1.r;
//   FF[2].And1.y = FF[2].RS2.Nor1.x[2];
//   FF[2].And1.y = FF[2].RS2.s;
//   FF[2].And2.y = FF[2].RS2.Nor2.x[1];
//   FF[2].And2.y = FF[2].RS2.r;
//   FF[2].RS2.Nor2.x[2] = FF[2].RS2.TD1.y;
//   FF[2].RS1.Nor2.x[2] = FF[2].RS1.TD1.y;
//   FF[1].And2.x[1] = FF[1].RS1.Nor1.x[1];
//   FF[1].And2.x[1] = FF[1].RS1.Nor2.y;
//   FF[1].And2.x[1] = FF[1].RS1.q;
//   FF[1].And2.x[1] = FF[1].qn;
//   FF[1].And3.x[1] = FF[1].And4.x[1];
//   FF[1].And3.x[1] = FF[1].Not1.y;
//   FF[1].And3.x[2] = FF[1].RS2.Nor1.x[1];
//   FF[1].And3.x[2] = FF[1].RS2.Nor2.y;
//   FF[1].And3.x[2] = FF[1].RS2.q;
//   FF[1].And4.x[2] = FF[1].RS2.Nor1.y;
//   FF[1].And4.x[2] = FF[1].RS2.TD1.x;
//   FF[1].And4.x[2] = FF[1].RS2.qn;
//   FF[1].And3.y = FF[1].RS1.Nor1.x[2];
//   FF[1].And3.y = FF[1].RS1.s;
//   FF[1].And4.y = FF[1].RS1.Nor2.x[1];
//   FF[1].And4.y = FF[1].RS1.r;
//   FF[1].And1.y = FF[1].RS2.Nor1.x[2];
//   FF[1].And1.y = FF[1].RS2.s;
//   FF[1].And2.y = FF[1].RS2.Nor2.x[1];
//   FF[1].And2.y = FF[1].RS2.r;
//   FF[1].RS2.Nor2.x[2] = FF[1].RS2.TD1.y;
//   FF[1].RS1.Nor2.x[2] = FF[1].RS1.TD1.y;
// end Modelica.Electrical.Digital.Examples.Utilities.Counter;
// "
// ""
// "Check of Modelica.Electrical.Digital.Examples.Utilities.Counter completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Examples.Utilities.Counter has 201 equation(s) and 201 variable(s).
// 201 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Delay.TransportDelay
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Real delayTime(quantity = "Time", unit = "s", start = 0.0) "delay time";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x_delayed;
// equation
//   x_delayed = DAE.CAST(ENUM TYPE, integer(delay(Real(x),delayTime,delayTime)));
//   y = if delayTime > 0.0 then if time >= delayTime then x_delayed else y0 else pre(x);
// end Modelica.Electrical.Digital.Delay.TransportDelay;
// "
// ""
// "Check of Modelica.Electrical.Digital.Delay.TransportDelay completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Delay.TransportDelay has 2 equation(s) and 2 variable(s).
// 2 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Delay.InertialDelay
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Real delayTime(quantity = "Time", unit = "s", start = 0.0) "Minimum time to hold value";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "Initial value of output y";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y_auxiliary(start = y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x_old(start = y0, fixed = true);
//   protected discrete Real t_next(quantity = "Time", unit = "s", start = delayTime, fixed = true);
// algorithm
//   when delayTime > 0.0 AND change(x) then
//     x_old := x;
//     t_next := time + delayTime;
//   elsewhen time >= t_next then
//     y_auxiliary := x;
//   end when;
//   y := if delayTime > 0.0 then y_auxiliary else x;
// end Modelica.Electrical.Digital.Delay.InertialDelay;
// "
// ""
// "Check of Modelica.Electrical.Digital.Delay.InertialDelay completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Delay.InertialDelay has 4 equation(s) and 4 variable(s).
// 0 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Delay.InertialDelaySensitive
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   protected Integer delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y_auxiliary(start = y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x_old(start = y0, fixed = true);
//   protected Integer lh;
//   protected discrete Real t_next(quantity = "Time", unit = "s");
// algorithm
//   when {initial(),(tLH > 0.0 OR tHL > 0.0) AND change(x) AND  NOT initial()} then
//     x_old := if initial() OR pre(x) == DAE.CAST(ENUM TYPE, 0) then y0 else pre(x);
//     lh := delayTable[x_old, x];
//     delayTime := if lh > 0 then tLH else if lh < 0 then tHL else 0.0;
//     t_next := time + delayTime;
//     if lh == 0 OR abs(delayTime) < 1e-60 then
//       y_auxiliary := x;
//     end if;
//   elsewhen time >= t_next then
//     y_auxiliary := x;
//   end when;
//   y := if tLH > 0.0 OR tHL > 0.0 then y_auxiliary else x;
// end Modelica.Electrical.Digital.Delay.InertialDelaySensitive;
// "
// ""
// "Check of Modelica.Electrical.Digital.Delay.InertialDelaySensitive completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Delay.InertialDelaySensitive has 87 equation(s) and 87 variable(s).
// 81 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Not
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
// equation
//   auxiliary = D.Tables.NotTable[x];
//   y = pre(auxiliary);
// end Modelica.Electrical.Digital.Basic.Not;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Not completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Not has 2 equation(s) and 2 variable(s).
// 2 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.And
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.AndTable[auxiliary[1],x[2]];
//   y = pre(auxiliary[2]);
// end Modelica.Electrical.Digital.Basic.And;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.And completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.And has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Nand
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.AndTable[auxiliary[1],x[2]];
//   y = pre(D.Tables.NotTable[auxiliary[2]]);
// end Modelica.Electrical.Digital.Basic.Nand;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Nand completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Nand has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Or
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.OrTable[auxiliary[1],x[2]];
//   y = pre(auxiliary[2]);
// end Modelica.Electrical.Digital.Basic.Or;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Or completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Or has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Nor
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.OrTable[auxiliary[1],x[2]];
//   y = pre(D.Tables.NotTable[auxiliary[2]]);
// end Modelica.Electrical.Digital.Basic.Nor;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Nor completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Nor has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Xor
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.XorTable[auxiliary[1],x[2]];
//   y = pre(auxiliary[2]);
// end Modelica.Electrical.Digital.Basic.Xor;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Xor completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Xor has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Basic.Xnor
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
// equation
//   auxiliary[1] = x[1];
//   auxiliary[2] = D.Tables.XorTable[auxiliary[1],x[2]];
//   y = pre(D.Tables.NotTable[auxiliary[2]]);
// end Modelica.Electrical.Digital.Basic.Xnor;
// "
// ""
// "Check of Modelica.Electrical.Digital.Basic.Xnor completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Basic.Xnor has 3 equation(s) and 3 variable(s).
// 3 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.InvGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary(start = Modelica.Electrical.Digital.Interfaces.Logic.'0', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary = D.Tables.NotTable[G1.x];
//   G1.y = pre(G1.auxiliary);
//   G1.y = G2.x;
//   G1.x = x;
//   G2.y = y;
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.InvGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.InvGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.InvGate has 92 equation(s) and 92 variable(s).
// 86 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.AndGate
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.AndTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(G1.auxiliary[2]);
//   G1.y = G2.x;
//   G2.y = y;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.AndGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.AndGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.AndGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.NandGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.AndTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(D.Tables.NotTable[G1.auxiliary[2]]);
//   G2.y = y;
//   G1.y = G2.x;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.NandGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.NandGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.NandGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.OrGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.OrTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(G1.auxiliary[2]);
//   G2.y = y;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
//   G1.y = G2.x;
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.OrGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.OrGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.OrGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.NorGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.OrTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(D.Tables.NotTable[G1.auxiliary[2]]);
//   G2.y = y;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
//   G1.y = G2.x;
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.NorGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.NorGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.NorGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.XorGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.XorTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(G1.auxiliary[2]);
//   G2.y = y;
//   G1.y = G2.x;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.XorGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.XorGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.XorGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.XnorGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   parameter Integer n(min = 2) = 2 "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   parameter Integer G1.n(min = 2) = n "Number of inputs";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[1] "Connector of Digital input signal vector";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x[2] "Connector of Digital input signal vector";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[1](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.auxiliary[2](start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true);
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y "Connector of Digital output signal";
//   parameter Real G2.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G2.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y0 = y0 "initial value of output";
//   protected Integer G2.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G2.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G2.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.y_auxiliary(start = G2.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G2.x_old(start = G2.y0, fixed = true);
//   protected Integer G2.lh;
//   protected discrete Real G2.t_next(quantity = "Time", unit = "s");
// equation
//   G1.auxiliary[1] = G1.x[1];
//   G1.auxiliary[2] = D.Tables.XorTable[G1.auxiliary[1],G1.x[2]];
//   G1.y = pre(D.Tables.NotTable[G1.auxiliary[2]]);
//   G1.y = G2.x;
//   G2.y = y;
//   G1.x[1] = x[1];
//   G1.x[2] = x[2];
// algorithm
//   when {initial(),(G2.tLH > 0.0 OR G2.tHL > 0.0) AND change(G2.x) AND  NOT initial()} then
//     G2.x_old := if initial() OR pre(G2.x) == DAE.CAST(ENUM TYPE, 0) then G2.y0 else pre(G2.x);
//     G2.lh := G2.delayTable[G2.x_old, G2.x];
//     G2.delayTime := if G2.lh > 0 then G2.tLH else if G2.lh < 0 then G2.tHL else 0.0;
//     G2.t_next := time + G2.delayTime;
//     if G2.lh == 0 OR abs(G2.delayTime) < 1e-60 then
//       G2.y_auxiliary := G2.x;
//     end if;
//   elsewhen time >= G2.t_next then
//     G2.y_auxiliary := G2.x;
//   end when;
//   G2.y := if G2.tLH > 0.0 OR G2.tHL > 0.0 then G2.y_auxiliary else G2.x;
// end Modelica.Electrical.Digital.Gates.XnorGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.XnorGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.XnorGate has 94 equation(s) and 94 variable(s).
// 88 of these are trivial equation(s).
// "
// ""
// "class Modelica.Electrical.Digital.Gates.BufGate
//   parameter Real tLH(quantity = "Time", unit = "s", start = 0.0) "rise inertial delay";
//   parameter Real tHL(quantity = "Time", unit = "s", start = 0.0) "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') x "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') y "Connector of Digital output signal";
//   input enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x(start = Modelica.Electrical.Digital.Interfaces.Logic.'U', fixed = true) "Connector of Digital input signal";
//   output enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y "Connector of Digital output signal";
//   parameter Real G1.tLH(quantity = "Time", unit = "s", start = 0.0) = tLH "rise inertial delay";
//   parameter Real G1.tHL(quantity = "Time", unit = "s", start = 0.0) = tHL "fall inertial delay";
//   parameter enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y0 = Modelica.Electrical.Digital.Interfaces.Logic.'U' "initial value of output";
//   protected Integer G1.delayTable[1,1] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,2] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,5] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,6] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[1,9] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,1] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,2] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,5] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,6] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[2,9] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,1] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,2] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,3] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,5] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,6] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,7] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[3,9] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,1] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,2] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,4] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,5] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,6] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,8] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[4,9] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,1] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,2] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,5] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,6] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[5,9] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,1] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,2] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,5] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,6] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[6,9] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,1] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,2] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,3] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,5] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,6] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,7] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[7,9] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,1] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,2] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,4] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,5] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,6] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,8] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[8,9] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,1] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,2] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,3] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,4] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,5] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,6] = 0 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,7] = -1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,8] = 1 "specification of delay according to signal change";
//   protected Integer G1.delayTable[9,9] = 0 "specification of delay according to signal change";
//   protected Real G1.delayTime(quantity = "Time", unit = "s");
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.y_auxiliary(start = G1.y0, fixed = true);
//   protected enumeration('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') G1.x_old(start = G1.y0, fixed = true);
//   protected Integer G1.lh;
//   protected discrete Real G1.t_next(quantity = "Time", unit = "s");
// equation
//   G1.x = x;
//   G1.y = y;
// algorithm
//   when {initial(),(G1.tLH > 0.0 OR G1.tHL > 0.0) AND change(G1.x) AND  NOT initial()} then
//     G1.x_old := if initial() OR pre(G1.x) == DAE.CAST(ENUM TYPE, 0) then G1.y0 else pre(G1.x);
//     G1.lh := G1.delayTable[G1.x_old, G1.x];
//     G1.delayTime := if G1.lh > 0 then G1.tLH else if G1.lh < 0 then G1.tHL else 0.0;
//     G1.t_next := time + G1.delayTime;
//     if G1.lh == 0 OR abs(G1.delayTime) < 1e-60 then
//       G1.y_auxiliary := G1.x;
//     end if;
//   elsewhen time >= G1.t_next then
//     G1.y_auxiliary := G1.x;
//   end when;
//   G1.y := if G1.tLH > 0.0 OR G1.tHL > 0.0 then G1.y_auxiliary else G1.x;
// end Modelica.Electrical.Digital.Gates.BufGate;
// "
// ""
// "Check of Modelica.Electrical.Digital.Gates.BufGate completed successfully.
// 
// 
// Class Modelica.Electrical.Digital.Gates.BufGate has 89 equation(s) and 89 variable(s).
// 83 of these are trivial equation(s).
// "
// ""
// endResult
