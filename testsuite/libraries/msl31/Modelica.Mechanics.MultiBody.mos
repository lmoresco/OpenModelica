//name:        Modelica.Mechanics.MultiBody [version 3.1]
//keyword:     instantiating MSL 3.1 Modelica.Mechanics.MultiBody
//status:      correct
//env: OPENMODELICALIBRARY=../../../libraries/msl31/
//
// instantiate/check model example
//

loadModel(Modelica); getErrorString();
loadModel(ModelicaServices); // Needed for PartialLineForce
getErrorString(); 

checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce); 
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Types.RotationSequence); 
getErrorString();

// more checks here:
instantiateModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();

// Result:
// true
// ""
// true
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2 completed successfully.
// 
// 
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce completed successfully.
// 
// Warning: Forcing full instantiation of partial class PartialLineForce during checkModel.
// Warning: No corresponding 'inner' declaration found for component world declared as 'outer '.
// 	Please declare an 'inner' component with the same name in the top scope.
// 	Continuing flattening by only considering the 'outer' component declaration.
// 
// Class Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce has 1112 equation(s) and 1119 variable(s).
// 635 of these are trivial equation(s).
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Types.RotationSequence completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Types.RotationSequence has 0 equation(s) and 0 variable(s).
// 0 of these are trivial equation(s).
// "
// ""
// "function Modelica.Math.Vectors.length "Inline before index reduction"
//   input Real[:] v "Vector";
//   output Real result "Length of vector v";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize "Inline before index reduction"
//   input Real[:] v "Vector";
//   input Real eps = 1e-13 "if |v| < eps then result = v/eps";
//   output Real[size(v,1)] result "Input vector v normalized to length=1";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation "Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation"
// input Real[3, 3] T;
// input Real(quantity="AngularVelocity", unit="rad/s")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 "Inline before index reduction"
//   input Real[3, 3] T "Orientation object to rotate frame 1 into frame 2";
//   input Real[3] v2 "Vector in frame 2";
//   output Real[3] v1 "Vector in frame 1";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation "Inline before index reduction"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R "Orientation object such that frame 1 and frame 2 are identical";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial "Inline before index reduction"
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape "Inline before index reduction"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
//   parameter String shapeType = "box" "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)";
//   input Real R.T[1,1] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[1,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[1,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[2,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[2,2] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[2,3] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[3,1] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[3,2] = 0.0 "Transformation matrix from world frame to local frame";
//   input Real R.T[3,3] = 1.0 "Transformation matrix from world frame to local frame";
//   input Real R.w[1](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real R.w[2](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real R.w[3](quantity = "AngularVelocity", unit = "rad/s") = 0.0 "Absolute angular velocity of local frame, resolved in local frame";
//   input Real r[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real r[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real r[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of world frame to origin of object frame, resolved in world frame";
//   input Real r_shape[1](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real r_shape[2](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real r_shape[3](quantity = "Length", unit = "m") = 0.0 "Position vector from origin of object frame to shape origin, resolved in object frame";
//   input Real lengthDirection[1](unit = "1") = 1.0 "Vector in length direction, resolved in object frame";
//   input Real lengthDirection[2](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real lengthDirection[3](unit = "1") = 0.0 "Vector in length direction, resolved in object frame";
//   input Real widthDirection[1](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real widthDirection[2](unit = "1") = 1.0 "Vector in width direction, resolved in object frame";
//   input Real widthDirection[3](unit = "1") = 0.0 "Vector in width direction, resolved in object frame";
//   input Real length(quantity = "Length", unit = "m") = 0.0 "Length of visual object";
//   input Real width(quantity = "Length", unit = "m") = 0.0 "Width of visual object";
//   input Real height(quantity = "Length", unit = "m") = 0.0 "Height of visual object";
//   input Real extra = 0.0 "Additional size data for some of the shape types";
//   input Real color[1] = 255.0 "Color of shape";
//   input Real color[2] = 0.0 "Color of shape";
//   input Real color[3] = 0.0 "Color of shape";
//   input Real specularCoefficient = 0.7 "Reflection of ambient light (= 0: light is completely absorbed)";
//   protected Real abs_n_x(unit = "1") = Modelica.Math.Vectors.length({lengthDirection[1],lengthDirection[2],lengthDirection[3]});
//   protected Real e_x[1](unit = "1") = if noEvent(abs_n_x < 1e-10) then 1.0 else lengthDirection[1] / abs_n_x;
//   protected Real e_x[2](unit = "1") = if noEvent(abs_n_x < 1e-10) then 0.0 else lengthDirection[2] / abs_n_x;
//   protected Real e_x[3](unit = "1") = if noEvent(abs_n_x < 1e-10) then 0.0 else lengthDirection[3] / abs_n_x;
//   protected Real n_z_aux[1](unit = "1") = e_x[2] * widthDirection[3] - e_x[3] * widthDirection[2];
//   protected Real n_z_aux[2](unit = "1") = e_x[3] * widthDirection[1] - e_x[1] * widthDirection[3];
//   protected Real n_z_aux[3](unit = "1") = e_x[1] * widthDirection[2] - e_x[2] * widthDirection[1];
//   protected Real e_y[1](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[1];
//   protected Real e_y[2](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[2];
//   protected Real e_y[3](unit = "1") = cross(Modelica.Math.Vectors.normalize(cross({e_x[1],e_x[2],e_x[3]},if noEvent(n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06) then {widthDirection[1],widthDirection[2],widthDirection[3]} else if noEvent(abs(e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{e_x[1],e_x[2],e_x[3]})[3];
//   protected output Real Form;
//   output Real rxvisobj[1](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real rxvisobj[2](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real rxvisobj[3](unit = "1") "x-axis unit vector of shape, resolved in world frame";
//   output Real ryvisobj[1](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real ryvisobj[2](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real ryvisobj[3](unit = "1") "y-axis unit vector of shape, resolved in world frame";
//   output Real rvisobj[1](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real rvisobj[2](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   output Real rvisobj[3](quantity = "Length", unit = "m") "position vector from world frame to shape frame, resolved in world frame";
//   protected output Real size[1](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real size[2](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real size[3](quantity = "Length", unit = "m") "{length,width,height} of shape";
//   protected output Real Material;
//   protected output Real Extra;
// equation
//   Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(shapeType);
//   rxvisobj[1] = R.T[1,1] * e_x[1] + (R.T[2,1] * e_x[2] + R.T[3,1] * e_x[3]);
//   rxvisobj[2] = R.T[1,2] * e_x[1] + (R.T[2,2] * e_x[2] + R.T[3,2] * e_x[3]);
//   rxvisobj[3] = R.T[1,3] * e_x[1] + (R.T[2,3] * e_x[2] + R.T[3,3] * e_x[3]);
//   ryvisobj[1] = R.T[1,1] * e_y[1] + (R.T[2,1] * e_y[2] + R.T[3,1] * e_y[3]);
//   ryvisobj[2] = R.T[1,2] * e_y[1] + (R.T[2,2] * e_y[2] + R.T[3,2] * e_y[3]);
//   ryvisobj[3] = R.T[1,3] * e_y[1] + (R.T[2,3] * e_y[2] + R.T[3,3] * e_y[3]);
//   rvisobj = r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{R.T[1,1],R.T[1,2],R.T[1,3]},{R.T[2,1],R.T[2,2],R.T[2,3]},{R.T[3,1],R.T[3,2],R.T[3,3]}},{r_shape[1],r_shape[2],r_shape[3]});
//   size[1] = length;
//   size[2] = width;
//   size[3] = height;
//   Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(color[1] / 255.0,color[2] / 255.0,color[3] / 255.0,specularCoefficient);
//   Extra = extra;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape has 37 equation(s) and 37 variable(s).
// 17 of these are trivial equation(s).
// "
// ""
// endResult
