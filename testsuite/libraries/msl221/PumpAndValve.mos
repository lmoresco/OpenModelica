//name:         PumpAndValve
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve);
getErrorString();
// Result:
// true
// "function Modelica.Math.log
// input Real u;
// output Real y;
// 
// external "C";
// end Modelica.Math.log;
// 
// function Modelica.SIunits.Conversions.from_degC
// input Real Celsius(quantity = "ThermodynamicTemperature", unit = "degC") "Celsius value";
// output Real Kelvin(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Kelvin value";
// algorithm
//   Kelvin := Celsius - -273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// function Modelica.Thermal.FluidHeatFlow.Media.Medium "Automatically generated record constructor for Modelica.Thermal.FluidHeatFlow.Media.Medium"
// input Real(quantity="Density", unit="kg/m3", displayUnit="g/cm3", min=0.0) rho = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cp = 1.0;
// input Real(quantity="SpecificHeatCapacity", unit="J/(kg.K)") cv = 1.0;
// input Real(quantity="ThermalConductivity", unit="W/(m.K)") lamda = 1.0;
// input Real(quantity="KinematicViscosity", unit="m2/s", min=0.0) nue = 1.0;
// output Medium res;
// end Modelica.Thermal.FluidHeatFlow.Media.Medium;
// 
// class Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve
// parameter Real medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real TAmb(quantity = "CelsiusTemperature", unit = "degC") = 20.0 "ambient temperature";
// output Real dTSource(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = PrescribedHeatFlow1.port.T - Modelica.SIunits.Conversions.from_degC(TAmb) "Source over Ambient";
// output Real dTtoPipe(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = PrescribedHeatFlow1.port.T - Pipe1.heatPort.T "Source over Coolant";
// output Real dTCoolant(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.dT "Coolant's temperature increase";
// parameter Real Ambient1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// output Real Ambient1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "outlet temperature of medium";
// output Real Ambient1.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Ambient1.flowPort.h / Ambient1.medium.cp "temperature at flowPort_a";
// parameter Real Ambient1.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient1.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient1.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient1.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient1.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Ambient1.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Ambient1.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Ambient1.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Ambient1.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Ambient1.h(quantity = "SpecificEnergy", unit = "J/kg") = Ambient1.medium.cp * Ambient1.T;
// parameter Real Ambient1.p_Ambient(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.0;
// parameter Real Ambient1.T_Ambient(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb);
// parameter Real IdealPump1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real IdealPump1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real IdealPump1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real IdealPump1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real IdealPump1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real IdealPump1.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.0 "mass of medium";
// parameter Real IdealPump1.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real IdealPump1.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = IdealPump1.flowPort_a.p - IdealPump1.flowPort_b.p "pressure drop a->b";
// Real IdealPump1.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = IdealPump1.flowPort_a.m_flow / IdealPump1.medium.rho "Volume flow a->b";
// Real IdealPump1.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real IdealPump1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = IdealPump1.T0) "outlet temperature of medium";
// output Real IdealPump1.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = IdealPump1.flowPort_a.h / IdealPump1.medium.cp "temperature at flowPort_a";
// output Real IdealPump1.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = IdealPump1.flowPort_b.h / IdealPump1.medium.cp "temperature at flowPort_b";
// output Real IdealPump1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(IdealPump1.V_flow >= 0.0) then IdealPump1.T - IdealPump1.T_a else IdealPump1.T_b - IdealPump1.T "temperature increase of coolant in flow direction";
// parameter Real IdealPump1.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real IdealPump1.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real IdealPump1.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real IdealPump1.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real IdealPump1.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real IdealPump1.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real IdealPump1.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real IdealPump1.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real IdealPump1.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real IdealPump1.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real IdealPump1.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real IdealPump1.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real IdealPump1.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real IdealPump1.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real IdealPump1.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real IdealPump1.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real IdealPump1.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real IdealPump1.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real IdealPump1.h(quantity = "SpecificEnergy", unit = "J/kg") = IdealPump1.medium.cp * IdealPump1.T "medium's specific enthalpy";
// protected Real IdealPump1.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = IdealPump1.T "temperature relevant for heat exchange with ambient";
// parameter Real IdealPump1.w_Nominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 1.0 "|pump characteristic|nominal speed";
// parameter Real IdealPump1.dp0(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 2.0 "|pump characteristic|max. pressure increase @ V_flow=0";
// parameter Real IdealPump1.V_flow0(quantity = "VolumeFlowRate", unit = "m3/s") = 2.0 "|pump characteristic|max. volume flow rate @ dp=0";
// Real IdealPump1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(IdealPump1.flange_a.phi) "speed";
// Real IdealPump1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real IdealPump1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// protected Real IdealPump1.dp1(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// protected Real IdealPump1.V_flow1(quantity = "VolumeFlowRate", unit = "m3/s");
// parameter Real Valve1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Valve1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Valve1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Valve1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Valve1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real Valve1.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.0 "mass of medium";
// parameter Real Valve1.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real Valve1.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = Valve1.flowPort_a.p - Valve1.flowPort_b.p "pressure drop a->b";
// Real Valve1.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = Valve1.flowPort_a.m_flow / Valve1.medium.rho "Volume flow a->b";
// Real Valve1.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real Valve1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = Valve1.T0) "outlet temperature of medium";
// output Real Valve1.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Valve1.flowPort_a.h / Valve1.medium.cp "temperature at flowPort_a";
// output Real Valve1.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Valve1.flowPort_b.h / Valve1.medium.cp "temperature at flowPort_b";
// output Real Valve1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(Valve1.V_flow >= 0.0) then Valve1.T - Valve1.T_a else Valve1.T_b - Valve1.T "temperature increase of coolant in flow direction";
// parameter Real Valve1.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Valve1.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Valve1.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Valve1.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Valve1.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Valve1.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Valve1.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Valve1.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Valve1.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real Valve1.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Valve1.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Valve1.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Valve1.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Valve1.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Valve1.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Valve1.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Valve1.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Valve1.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Valve1.h(quantity = "SpecificEnergy", unit = "J/kg") = Valve1.medium.cp * Valve1.T "medium's specific enthalpy";
// protected Real Valve1.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Valve1.T "temperature relevant for heat exchange with ambient";
// parameter Boolean Valve1.LinearCharacteristic = false "|standard characteristic|type of characteristic";
// parameter Real Valve1.y1(min = 1e-60) = 1.0 "|standard characteristic|max. valve opening";
// parameter Real Valve1.Kv1(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60) = 1.0 "|standard characteristic|max. flow @ y = y1";
// parameter Real Valve1.kv0(min = 1e-60, max = 1.0) = 0.01 "|standard characteristic|leakage flow / max.flow @ y = 0";
// parameter Real Valve1.dp0(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 1.0 "|standard characteristic|standard pressure drop";
// parameter Real Valve1.rho0(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 10.0 "|standard characteristic|standard medium's density";
// parameter Real Valve1.frictionLoss(min = 0.0, max = 1.0) = 0.0 "part of friction losses fed to medium";
// input Real Valve1.y;
// protected constant Real Valve1.small = 1e-60;
// protected constant Real Valve1.eps = 1e-15;
// protected Real Valve1.yLim = max(min(Valve1.y,Valve1.y1),0.0) "limited valve opening";
// protected Real Valve1.Kv(quantity = "VolumeFlowRate", unit = "m3/s") "standard flow rate";
// parameter Real Pipe1.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// parameter Real Pipe1.m(quantity = "Mass", unit = "kg", min = 0.0) = 0.1 "mass of medium";
// parameter Real Pipe1.T0(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb) "initial temperature of medium";
// Real Pipe1.dp(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = Pipe1.flowPort_a.p - Pipe1.flowPort_b.p "pressure drop a->b";
// Real Pipe1.V_flow(quantity = "VolumeFlowRate", unit = "m3/s") = Pipe1.flowPort_a.m_flow / Pipe1.medium.rho "Volume flow a->b";
// Real Pipe1.Q_flow(quantity = "Power", unit = "W") "heat exchange with ambient";
// output Real Pipe1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = Pipe1.T0) "outlet temperature of medium";
// output Real Pipe1.T_a(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.flowPort_a.h / Pipe1.medium.cp "temperature at flowPort_a";
// output Real Pipe1.T_b(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.flowPort_b.h / Pipe1.medium.cp "temperature at flowPort_b";
// output Real Pipe1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = if noEvent(Pipe1.V_flow >= 0.0) then Pipe1.T - Pipe1.T_a else Pipe1.T_b - Pipe1.T "temperature increase of coolant in flow direction";
// parameter Real Pipe1.flowPort_a.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.flowPort_a.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.flowPort_a.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.flowPort_a.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.flowPort_a.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Pipe1.flowPort_a.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.flowPort_a.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Pipe1.flowPort_a.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Pipe1.flowPort_a.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// parameter Real Pipe1.flowPort_b.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Pipe1.flowPort_b.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Pipe1.flowPort_b.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Pipe1.flowPort_b.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Pipe1.flowPort_b.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Pipe1.flowPort_b.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.flowPort_b.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Pipe1.flowPort_b.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Pipe1.flowPort_b.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Pipe1.h(quantity = "SpecificEnergy", unit = "J/kg") = Pipe1.medium.cp * Pipe1.T "medium's specific enthalpy";
// protected Real Pipe1.T_q(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Pipe1.T "temperature relevant for heat exchange with ambient";
// parameter Real Pipe1.V_flowLaminar(quantity = "VolumeFlowRate", unit = "m3/s", min = 1e-60) = 0.1 "|SimpleFriction|laminar volume flow";
// parameter Real Pipe1.dpLaminar(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.1 "|SimpleFriction|laminar pressure drop";
// parameter Real Pipe1.V_flowNominal(quantity = "VolumeFlowRate", unit = "m3/s") = 1.0 "|SimpleFriction|nominal volume flow";
// parameter Real Pipe1.dpNominal(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 1.0 "|SimpleFriction|nominal pressure drop";
// parameter Real Pipe1.frictionLoss(min = 0.0, max = 1.0) = 0.0 "|SimpleFriction|part of friction losses fed to medium";
// Real Pipe1.pressureDrop(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Pipe1.VolumeFlow(quantity = "VolumeFlowRate", unit = "m3/s");
// Real Pipe1.Q_friction(quantity = "Power", unit = "W");
// protected parameter Real Pipe1.k(fixed = false);
// parameter Real Pipe1.h_g(quantity = "Length", unit = "m") = 0.0 "geodetic height (heigth difference from flowPort_a to flowPort_b)";
// Real Pipe1.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real Pipe1.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real Ambient2.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient2.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient2.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient2.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient2.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// output Real Ambient2.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "outlet temperature of medium";
// output Real Ambient2.T_port(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Ambient2.flowPort.h / Ambient2.medium.cp "temperature at flowPort_a";
// parameter Real Ambient2.flowPort.medium.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.0 "density";
// parameter Real Ambient2.flowPort.medium.cp(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant pressure";
// parameter Real Ambient2.flowPort.medium.cv(quantity = "SpecificHeatCapacity", unit = "J/(kg.K)") = 1.0 "specific heat capacity at constant volume";
// parameter Real Ambient2.flowPort.medium.lamda(quantity = "ThermalConductivity", unit = "W/(m.K)") = 1.0 "thermal conductivity";
// parameter Real Ambient2.flowPort.medium.nue(quantity = "KinematicViscosity", unit = "m2/s", min = 0.0) = 1.0 "kinematic viscosity";
// Real Ambient2.flowPort.p(quantity = "Pressure", unit = "Pa", displayUnit = "bar");
// Real Ambient2.flowPort.m_flow(quantity = "MassFlowRate", unit = "kg/s");
// Real Ambient2.flowPort.h(quantity = "SpecificEnergy", unit = "J/kg");
// Real Ambient2.flowPort.H_flow(quantity = "EnthalpyFlowRate", unit = "W");
// protected Real Ambient2.h(quantity = "SpecificEnergy", unit = "J/kg") = Ambient2.medium.cp * Ambient2.T;
// parameter Real Ambient2.p_Ambient(quantity = "Pressure", unit = "Pa", displayUnit = "bar") = 0.0;
// parameter Real Ambient2.T_Ambient(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = Modelica.SIunits.Conversions.from_degC(TAmb);
// parameter Real HeatCapacitor1.C(quantity = "HeatCapacity", unit = "J/K") = 0.1 "Heat capacity of part (= cp*m)";
// parameter Boolean HeatCapacitor1.steadyStateStart = false "true, if component shall start in steady state";
// Real HeatCapacitor1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = Modelica.SIunits.Conversions.from_degC(TAmb)) "Temperature of part";
// Real HeatCapacitor1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real HeatCapacitor1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real PrescribedHeatFlow1.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 293.15 "Reference temperature";
// parameter Real PrescribedHeatFlow1.alpha(unit = "1/K") = 0.0 "Temperature coefficient of heat flow rate";
// Real PrescribedHeatFlow1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real PrescribedHeatFlow1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// input Real PrescribedHeatFlow1.Q_flow(quantity = "Power", unit = "W");
// output Real HeatFlow.y "Connector of Real output signal";
// parameter Real HeatFlow.k = 10.0 "Constant output value";
// output Real G.y "Connector of Real output signal";
// parameter Real G.k = 1.0 "Constant output value";
// output Real speedRamp.y "Connector of Real output signal";
// parameter Real speedRamp.height = 0.5 "Height of ramps";
// parameter Real speedRamp.duration(min = 1e-60) = 0.1 "Durations of ramp";
// parameter Real speedRamp.offset = 0.5 "Offset of output signal";
// parameter Real speedRamp.startTime(quantity = "Time", unit = "s") = 0.4 "Output = offset for time < startTime";
// output Real valveRamp.y "Connector of Real output signal";
// parameter Real valveRamp.height = 0.5 "Height of ramps";
// parameter Real valveRamp.duration(min = 1e-60) = 0.1 "Durations of ramp";
// parameter Real valveRamp.offset = 0.5 "Offset of output signal";
// parameter Real valveRamp.startTime(quantity = "Time", unit = "s") = 0.9 "Output = offset for time < startTime";
// parameter Boolean Speed1.exact = true "true/false exact treatment/filtering the input signal";
// parameter Real Speed1.f_crit(quantity = "Frequency", unit = "Hz") = 50.0 "if exact=false, critical frequency of filter to filter input signal";
// Real Speed1.phi_ref(quantity = "Angle", unit = "rad", displayUnit = "deg") "reference angle defined by time integration of input signal";
// Real Speed1.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "absolute rotation angle of flange flange_b";
// Real Speed1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "absolute angular velocity of flange flange_b";
// Real Speed1.a(quantity = "AngularAcceleration", unit = "rad/s2") "absolute angular acceleration of flange flange_b";
// Real Speed1.tau_support(quantity = "Torque", unit = "N.m") "Support torque";
// Real Speed1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real Speed1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// input Real Speed1.w_ref(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Reference angular velocity of flange_b as input signal";
// Real Speed1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real Speed1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// protected parameter Real Speed1.w_crit = 6.28318530717959 * Speed1.f_crit "critical frequency in [1/s]";
// Real Convection1.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from solid -> fluid";
// Real Convection1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "= solid.T - fluid.T";
// Real Convection1.solid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real Convection1.solid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real Convection1.fluid.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real Convection1.fluid.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// input Real Convection1.Gc(quantity = "ThermalConductance", unit = "W/K") "Signal representing the convective thermal conductance in [W/K]";
// initial algorithm
//   assert(Valve1.y1 > 1e-60, "Valve characteristic: y1 has to be > 0 !");
//   assert(Valve1.Kv1 > 1e-60, "Valve characteristic: Kv1 has to be > 0 !");
//   assert(Valve1.kv0 > 1e-60, "Valve characteristic: kv0 has to be > 0 !");
//   assert(Valve1.kv0 < 0.999999999999999, "Valve characteristic: kv0 has to be < 1 !");
//   assert(Pipe1.V_flowNominal > Pipe1.V_flowLaminar, "SimpleFriction: V_flowNominal has to be > V_flowLaminar!");
//   Pipe1.k := Pipe1.dpLaminar * Pipe1.V_flowNominal / Pipe1.V_flowLaminar;
//   assert(Pipe1.dpNominal >= Pipe1.k, "SimpleFriction: dpNominal has to be > dpLaminar*V_flowNominal/V_flowLaminar!");
//   Pipe1.k := (Pipe1.dpNominal - Pipe1.k) * (Pipe1.V_flowNominal - Pipe1.V_flowLaminar) ^ -2.0;
// equation
//   Ambient1.flowPort.p = Ambient1.p_Ambient;
//   Ambient1.T = Ambient1.T_Ambient;
//   Ambient1.flowPort.H_flow = semiLinear(Ambient1.flowPort.m_flow,Ambient1.flowPort.h,Ambient1.h);
//   IdealPump1.dp1 = IdealPump1.dp0 * (sign(IdealPump1.w / IdealPump1.w_Nominal) * (IdealPump1.w / IdealPump1.w_Nominal) ^ 2.0);
//   IdealPump1.V_flow1 = IdealPump1.V_flow0 * IdealPump1.w / IdealPump1.w_Nominal;
//   if noEvent(abs(IdealPump1.w) < 1e-60) then
//   IdealPump1.dp = 0.0;
//   IdealPump1.flange_a.tau = 0.0;
//   else
//   IdealPump1.dp = (-IdealPump1.dp1) * (1.0 - abs(IdealPump1.V_flow / IdealPump1.V_flow1));
//   IdealPump1.flange_a.tau * IdealPump1.w = (-IdealPump1.dp) * IdealPump1.V_flow;
//   end if;
//   IdealPump1.Q_flow = 0.0;
//   IdealPump1.flowPort_a.m_flow + IdealPump1.flowPort_b.m_flow = 0.0;
//   IdealPump1.flowPort_a.H_flow + (IdealPump1.flowPort_b.H_flow + IdealPump1.Q_flow) = 0.0;
//   IdealPump1.flowPort_a.H_flow = semiLinear(IdealPump1.flowPort_a.m_flow,IdealPump1.flowPort_a.h,IdealPump1.h);
//   IdealPump1.flowPort_b.H_flow = semiLinear(IdealPump1.flowPort_b.m_flow,IdealPump1.flowPort_b.h,IdealPump1.h);
//   Valve1.Kv / Valve1.Kv1 = if Valve1.LinearCharacteristic then Valve1.kv0 + (1.0 - Valve1.kv0) * Valve1.yLim / Valve1.y1 else Valve1.kv0 * exp((Modelica.Math.log(1.0 / Valve1.kv0) * Valve1.yLim) / Valve1.y1);
//   Valve1.dp / Valve1.dp0 = Valve1.medium.rho * (Valve1.V_flow * (abs(Valve1.V_flow / Valve1.Kv) * 1.0 / Valve1.rho0 / Valve1.Kv));
//   Valve1.Q_flow = Valve1.frictionLoss * (Valve1.V_flow * Valve1.dp);
//   Valve1.flowPort_a.m_flow + Valve1.flowPort_b.m_flow = 0.0;
//   Valve1.flowPort_a.H_flow + (Valve1.flowPort_b.H_flow + Valve1.Q_flow) = 0.0;
//   Valve1.flowPort_a.H_flow = semiLinear(Valve1.flowPort_a.m_flow,Valve1.flowPort_a.h,Valve1.h);
//   Valve1.flowPort_b.H_flow = semiLinear(Valve1.flowPort_b.m_flow,Valve1.flowPort_b.h,Valve1.h);
//   Pipe1.VolumeFlow = Pipe1.V_flow;
//   Pipe1.dp = Pipe1.pressureDrop + 9.80665 * (Pipe1.medium.rho * Pipe1.h_g);
//   Pipe1.Q_flow = Pipe1.heatPort.Q_flow + Pipe1.Q_friction;
//   Pipe1.heatPort.T = Pipe1.T_q;
//   Pipe1.flowPort_b.H_flow = semiLinear(Pipe1.flowPort_b.m_flow,Pipe1.flowPort_b.h,Pipe1.h);
//   Pipe1.flowPort_a.H_flow = semiLinear(Pipe1.flowPort_a.m_flow,Pipe1.flowPort_a.h,Pipe1.h);
//   Pipe1.flowPort_a.H_flow + (Pipe1.flowPort_b.H_flow + Pipe1.Q_flow) = Pipe1.m * (Pipe1.medium.cv * der(Pipe1.T));
//   Pipe1.flowPort_a.m_flow + Pipe1.flowPort_b.m_flow = 0.0;
//   if Pipe1.VolumeFlow > Pipe1.V_flowLaminar then
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar + Pipe1.k * (Pipe1.VolumeFlow - Pipe1.V_flowLaminar) ^ 2.0;
//   elseif Pipe1.VolumeFlow < -Pipe1.V_flowLaminar then
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar - Pipe1.k * (Pipe1.VolumeFlow + Pipe1.V_flowLaminar) ^ 2.0;
//   else
//   Pipe1.pressureDrop = Pipe1.dpLaminar * Pipe1.VolumeFlow / Pipe1.V_flowLaminar;
//   end if;
//   Pipe1.Q_friction = Pipe1.frictionLoss * (Pipe1.VolumeFlow * Pipe1.pressureDrop);
//   Ambient2.flowPort.p = Ambient2.p_Ambient;
//   Ambient2.T = Ambient2.T_Ambient;
//   Ambient2.flowPort.H_flow = semiLinear(Ambient2.flowPort.m_flow,Ambient2.flowPort.h,Ambient2.h);
//   HeatCapacitor1.T = HeatCapacitor1.port.T;
//   HeatCapacitor1.C * der(HeatCapacitor1.T) = HeatCapacitor1.port.Q_flow;
//   PrescribedHeatFlow1.port.Q_flow = (-PrescribedHeatFlow1.Q_flow) * (1.0 + PrescribedHeatFlow1.alpha * (PrescribedHeatFlow1.port.T - PrescribedHeatFlow1.T_ref));
//   HeatFlow.y = HeatFlow.k;
//   G.y = G.k;
//   speedRamp.y = speedRamp.offset + (if time < speedRamp.startTime then 0.0 else if time < speedRamp.startTime + speedRamp.duration then ((time - speedRamp.startTime) * speedRamp.height) / speedRamp.duration else speedRamp.height);
//   valveRamp.y = valveRamp.offset + (if time < valveRamp.startTime then 0.0 else if time < valveRamp.startTime + valveRamp.duration then ((time - valveRamp.startTime) * valveRamp.height) / valveRamp.duration else valveRamp.height);
//   0.0 = Speed1.flange_b.tau + Speed1.tau_support;
//   Speed1.bearing.phi = 0.0;
//   der(Speed1.phi_ref) = Speed1.w_ref;
//   Speed1.phi = Speed1.flange_b.phi;
//   Speed1.w = der(Speed1.phi);
//   Speed1.a = der(Speed1.w);
//   Speed1.w = Speed1.w_ref;
//   Convection1.dT = Convection1.solid.T - Convection1.fluid.T;
//   Convection1.solid.Q_flow = Convection1.Q_flow;
//   Convection1.fluid.Q_flow = -Convection1.Q_flow;
//   Convection1.Q_flow = Convection1.Gc * Convection1.dT;
// assert(Valve1.flowPort_b.medium.rho == Pipe1.flowPort_a.medium.rho,"automatically generated from connect");
// assert(Valve1.flowPort_b.medium.cp == Pipe1.flowPort_a.medium.cp,"automatically generated from connect");
// assert(Valve1.flowPort_b.medium.cv == Pipe1.flowPort_a.medium.cv,"automatically generated from connect");
// assert(Valve1.flowPort_b.medium.lamda == Pipe1.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(Valve1.flowPort_b.medium.nue == Pipe1.flowPort_a.medium.nue,"automatically generated from connect");
// assert(IdealPump1.flowPort_b.medium.rho == Valve1.flowPort_a.medium.rho,"automatically generated from connect");
// assert(IdealPump1.flowPort_b.medium.cp == Valve1.flowPort_a.medium.cp,"automatically generated from connect");
// assert(IdealPump1.flowPort_b.medium.cv == Valve1.flowPort_a.medium.cv,"automatically generated from connect");
// assert(IdealPump1.flowPort_b.medium.lamda == Valve1.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(IdealPump1.flowPort_b.medium.nue == Valve1.flowPort_a.medium.nue,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.rho == IdealPump1.flowPort_a.medium.rho,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.cp == IdealPump1.flowPort_a.medium.cp,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.cv == IdealPump1.flowPort_a.medium.cv,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.lamda == IdealPump1.flowPort_a.medium.lamda,"automatically generated from connect");
// assert(Ambient1.flowPort.medium.nue == IdealPump1.flowPort_a.medium.nue,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.rho == Ambient2.flowPort.medium.rho,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.cp == Ambient2.flowPort.medium.cp,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.cv == Ambient2.flowPort.medium.cv,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.lamda == Ambient2.flowPort.medium.lamda,"automatically generated from connect");
// assert(Pipe1.flowPort_b.medium.nue == Ambient2.flowPort.medium.nue,"automatically generated from connect");
// G.y = Convection1.Gc;
//   Pipe1.heatPort.Q_flow + Convection1.fluid.Q_flow = 0.0;
// Pipe1.heatPort.T = Convection1.fluid.T;
//   Convection1.solid.Q_flow + (PrescribedHeatFlow1.port.Q_flow + HeatCapacitor1.port.Q_flow) = 0.0;
// Convection1.solid.T = PrescribedHeatFlow1.port.T;
// PrescribedHeatFlow1.port.T = HeatCapacitor1.port.T;
// speedRamp.y = Speed1.w_ref;
//   Speed1.flange_b.tau + IdealPump1.flange_a.tau = 0.0;
// Speed1.flange_b.phi = IdealPump1.flange_a.phi;
//   Pipe1.flowPort_b.H_flow + Ambient2.flowPort.H_flow = 0.0;
// Pipe1.flowPort_b.h = Ambient2.flowPort.h;
//   Pipe1.flowPort_b.m_flow + Ambient2.flowPort.m_flow = 0.0;
// Pipe1.flowPort_b.p = Ambient2.flowPort.p;
// HeatFlow.y = PrescribedHeatFlow1.Q_flow;
//   Ambient1.flowPort.H_flow + IdealPump1.flowPort_a.H_flow = 0.0;
// Ambient1.flowPort.h = IdealPump1.flowPort_a.h;
//   Ambient1.flowPort.m_flow + IdealPump1.flowPort_a.m_flow = 0.0;
// Ambient1.flowPort.p = IdealPump1.flowPort_a.p;
//   IdealPump1.flowPort_b.H_flow + Valve1.flowPort_a.H_flow = 0.0;
// IdealPump1.flowPort_b.h = Valve1.flowPort_a.h;
//   IdealPump1.flowPort_b.m_flow + Valve1.flowPort_a.m_flow = 0.0;
// IdealPump1.flowPort_b.p = Valve1.flowPort_a.p;
//   Valve1.flowPort_b.H_flow + Pipe1.flowPort_a.H_flow = 0.0;
// Valve1.flowPort_b.h = Pipe1.flowPort_a.h;
//   Valve1.flowPort_b.m_flow + Pipe1.flowPort_a.m_flow = 0.0;
// Valve1.flowPort_b.p = Pipe1.flowPort_a.p;
// valveRamp.y = Valve1.y;
//   Speed1.bearing.tau = 0.0;
// end Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve;
// "
// ""
// endResult
