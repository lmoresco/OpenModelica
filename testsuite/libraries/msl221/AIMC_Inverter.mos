//name:         AIMC_Inverter
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Machines.Examples.AIMC_Inverter);
getErrorString();
// Result:
// true
// "function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.SIunits.Conversions.to_rpm
//   input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
//   output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.AIMC_Inverter
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real f(quantity = "Frequency", unit = "Hz") = 50.0 "actual frequency";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 1.0 "frequency ramp";
//   parameter Real T_Load(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.2 "time of load torque step";
//   parameter Real J_Load(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
//   constant Integer CurrentRMSsensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer CurrentRMSsensor1.plug_p.m(min = 1) = 3 "number of phases";
//   Real CurrentRMSsensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.plug_n.m(min = 1) = 3 "number of phases";
//   Real CurrentRMSsensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_p.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_n.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer CurrentRMSsensor1.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real CurrentRMSsensor1.ToSpacePhasor1.pi = 3.14159265358979;
//   output Real CurrentRMSsensor1.ToSpacePhasor1.zero;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer CurrentRMSsensor1.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real CurrentRMSsensor1.ToPolar1.u[1] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToPolar1.u[2] "Connector of Real input signals";
//   output Real CurrentRMSsensor1.ToPolar1.y[1] "Connector of Real output signals";
//   output Real CurrentRMSsensor1.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real CurrentRMSsensor1.ToPolar1.small = 1e-60;
//   parameter Real CurrentRMSsensor1.Gain1.k = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real CurrentRMSsensor1.Gain1.u "Input signal connector";
//   output Real CurrentRMSsensor1.Gain1.y "Output signal connector";
//   output Real CurrentRMSsensor1.I(quantity = "ElectricCurrent", unit = "A");
//   output Real Ramp1.y "Connector of Real output signal";
//   parameter Real Ramp1.height = f "Height of ramps";
//   parameter Real Ramp1.duration(min = 1e-60) = tRamp "Durations of ramp";
//   parameter Real Ramp1.offset = 0.0 "Offset of output signal";
//   parameter Real Ramp1.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   parameter Integer VfController1.nout = VfController1.m "Number of outputs";
//   input Real VfController1.u(quantity = "Frequency", unit = "Hz") "Connector of Real input signal";
//   output Real VfController1.y[1] "Connector of Real output signals";
//   output Real VfController1.y[2] "Connector of Real output signals";
//   output Real VfController1.y[3] "Connector of Real output signals";
//   constant Real VfController1.pi = 3.14159265358979;
//   parameter Integer VfController1.m = 3 "number of phases";
//   parameter Real VfController1.VNominal(quantity = "ElectricPotential", unit = "V") = VNominal "nominal RMS voltage per phase";
//   parameter Real VfController1.fNominal(quantity = "Frequency", unit = "Hz") = fNominal "nominal frequency";
//   parameter Real VfController1.BasePhase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "common phase shift";
//   output Real VfController1.x(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true) "Integrator state";
//   output Real VfController1.amplitude(quantity = "ElectricPotential", unit = "V");
//   parameter Integer Star1.m(min = 1) = 3 "number of phases";
//   parameter Integer Star1.plug_p.m(min = 1) = Star1.m "number of phases";
//   Real Star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real LoadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = LoadInertia.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real LoadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real LoadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real LoadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = J_Load "Moment of inertia";
//   parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real LoadInertia.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real LoadInertia.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real LoadInertia.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real LoadInertia.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = LoadInertia.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real LoadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   Real TorqueStep1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(TorqueStep1.flange.phi) "Angular velocity at flange";
//   Real TorqueStep1.tau(quantity = "Torque", unit = "N.m") = TorqueStep1.flange.tau "accelerating torque acting at flange";
//   Real TorqueStep1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real TorqueStep1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real TorqueStep1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real TorqueStep1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real TorqueStep1.stepTorque(quantity = "Torque", unit = "N.m") = -T_Load "height of torque step (if negative, torque is acting as load)";
//   parameter Real TorqueStep1.offsetTorque(quantity = "Torque", unit = "N.m") = 0.0 "offset of torque";
//   parameter Real TorqueStep1.startTime(quantity = "Time", unit = "s") = tStep "output = offset for time < startTime";
//   constant Integer TerminalBox1.m = 3 "number of phases";
//   parameter String TerminalBox1.StarDelta = "Y";
//   parameter Integer TerminalBox1.positiveMachinePlug.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.positiveMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.negativeMachinePlug.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.negativeMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plugToGrid.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plugToGrid.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugToGrid.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugToGrid.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.star.m(min = 1) = 3 "number of phases";
//   parameter Integer TerminalBox1.star.plug_p.m(min = 1) = TerminalBox1.star.m "number of phases";
//   Real TerminalBox1.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SignalVoltage1.m(min = 1) = 3 "number of phases";
//   Real SignalVoltage1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SignalVoltage1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SignalVoltage1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer SignalVoltage1.plug_p.m(min = 1) = SignalVoltage1.m "number of phases";
//   Real SignalVoltage1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SignalVoltage1.plug_n.m(min = 1) = SignalVoltage1.m "number of phases";
//   Real SignalVoltage1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.v[1] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real SignalVoltage1.v[2] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   input Real SignalVoltage1.v[3] "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real SignalVoltage1.signalVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SignalVoltage1.signalVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.signalVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.signalVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real SignalVoltage1.signalVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SignalVoltage1.signalVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.signalVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.signalVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real SignalVoltage1.signalVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SignalVoltage1.signalVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.signalVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.signalVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.signalVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
//   parameter Real AIMC1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "rotor's moment of inertia";
//   output Real AIMC1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = AIMC1.flange_a.phi "mechanical angle of rotor against stator";
//   output Real AIMC1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(AIMC1.phi_mechanical) "mechanical angular velocity of rotor against stator";
//   output Real AIMC1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(AIMC1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
//   output Real AIMC1.tau_electrical(quantity = "Torque", unit = "N.m") = AIMC1.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real AIMC1.tau_shaft(quantity = "Torque", unit = "N.m") = -AIMC1.flange_a.tau "shaft torque";
//   Real AIMC1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real AIMC1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = AIMC1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real AIMC1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real AIMC1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real AIMC1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = AIMC1.J_Rotor "Moment of inertia";
//   parameter Integer AIMC1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real AIMC1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real AIMC1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real AIMC1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer AIMC1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real AIMC1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = AIMC1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real AIMC1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   parameter Real AIMC1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real AIMC1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real AIMC1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Real AIMC1.pi = 3.14159265358979;
//   constant Integer AIMC1.m = 3 "number of phases";
//   parameter Integer AIMC1.p(min = 1) = 2 "number of pole pairs (Integer)";
//   output Real AIMC1.vs[1](quantity = "ElectricPotential", unit = "V") = AIMC1.plug_sp.pin[1].v - AIMC1.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real AIMC1.vs[2](quantity = "ElectricPotential", unit = "V") = AIMC1.plug_sp.pin[2].v - AIMC1.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real AIMC1.vs[3](quantity = "ElectricPotential", unit = "V") = AIMC1.plug_sp.pin[3].v - AIMC1.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real AIMC1.is[1](quantity = "ElectricCurrent", unit = "A") = AIMC1.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real AIMC1.is[2](quantity = "ElectricCurrent", unit = "A") = AIMC1.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real AIMC1.is[3](quantity = "ElectricCurrent", unit = "A") = AIMC1.plug_sp.pin[3].i "stator instantaneous currents";
//   parameter Integer AIMC1.plug_sp.m(min = 1) = 3 "number of phases";
//   Real AIMC1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer AIMC1.plug_sn.m(min = 1) = 3 "number of phases";
//   Real AIMC1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Real AIMC1.fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real AIMC1.Rs(quantity = "Resistance", unit = "Ohm") = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//   parameter Real AIMC1.Lssigma(quantity = "Inductance", unit = "H") = 0.000323964362549907 "|Nominal resistances and inductances|stator stray inductance per phase";
//   parameter Real AIMC1.Lm(quantity = "Inductance", unit = "H") = 0.00922533222296381 "|Nominal resistances and inductances|main field inductance";
//   parameter Real AIMC1.Lrsigma(quantity = "Inductance", unit = "H") = 0.000323964362549907 "|Nominal resistances and inductances|rotor stray inductance";
//   parameter Real AIMC1.Rr(quantity = "Resistance", unit = "Ohm") = 0.04 "|Nominal resistances and inductances|warm rotor resistance";
//   output Real AIMC1.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.default) = AIMC1.spacePhasorS.zero.i "stator zero-sequence current";
//   output Real AIMC1.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = AIMC1.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
//   output Real AIMC1.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = AIMC1.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
//   output Real AIMC1.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMC1.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
//   output Real AIMC1.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMC1.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
//   output Real AIMC1.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = AIMC1.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
//   output Real AIMC1.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = AIMC1.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
//   output Real AIMC1.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMC1.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
//   output Real AIMC1.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMC1.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
//   parameter Integer AIMC1.rs.m(min = 1) = 3 "number of phases";
//   Real AIMC1.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real AIMC1.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real AIMC1.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer AIMC1.rs.plug_p.m(min = 1) = AIMC1.rs.m "number of phases";
//   Real AIMC1.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer AIMC1.rs.plug_n.m(min = 1) = AIMC1.rs.m "number of phases";
//   Real AIMC1.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.rs.R[1](quantity = "Resistance", unit = "Ohm") = AIMC1.Rs "Resistance";
//   parameter Real AIMC1.rs.R[2](quantity = "Resistance", unit = "Ohm") = AIMC1.Rs "Resistance";
//   parameter Real AIMC1.rs.R[3](quantity = "Resistance", unit = "Ohm") = AIMC1.Rs "Resistance";
//   Real AIMC1.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm") = AIMC1.rs.R[1] "Resistance";
//   Real AIMC1.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm") = AIMC1.rs.R[2] "Resistance";
//   Real AIMC1.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm") = AIMC1.rs.R[3] "Resistance";
//   parameter Integer AIMC1.lssigma.m(min = 1) = 3 "number of phases";
//   Real AIMC1.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real AIMC1.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real AIMC1.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real AIMC1.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer AIMC1.lssigma.plug_p.m(min = 1) = AIMC1.lssigma.m "number of phases";
//   Real AIMC1.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer AIMC1.lssigma.plug_n.m(min = 1) = AIMC1.lssigma.m "number of phases";
//   Real AIMC1.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.lssigma.L[1](quantity = "Inductance", unit = "H") = AIMC1.Lssigma "Inductance";
//   parameter Real AIMC1.lssigma.L[2](quantity = "Inductance", unit = "H") = AIMC1.Lssigma "Inductance";
//   parameter Real AIMC1.lssigma.L[3](quantity = "Inductance", unit = "H") = AIMC1.Lssigma "Inductance";
//   Real AIMC1.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.lssigma.inductor[1].L(quantity = "Inductance", unit = "H") = AIMC1.lssigma.L[1] "Inductance";
//   Real AIMC1.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.lssigma.inductor[2].L(quantity = "Inductance", unit = "H") = AIMC1.lssigma.L[2] "Inductance";
//   Real AIMC1.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real AIMC1.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real AIMC1.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real AIMC1.lssigma.inductor[3].L(quantity = "Inductance", unit = "H") = AIMC1.lssigma.L[3] "Inductance";
//   constant Integer AIMC1.spacePhasorS.m = 3 "number of phases";
//   constant Real AIMC1.spacePhasorS.pi = 3.14159265358979;
//   Real AIMC1.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real AIMC1.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real AIMC1.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real AIMC1.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real AIMC1.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real AIMC1.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   parameter Integer AIMC1.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real AIMC1.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer AIMC1.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real AIMC1.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real AIMC1.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real AIMC1.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real AIMC1.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A");
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real AIMC1.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real AIMC1.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   constant Integer AIMC1.airGapS.m = 3 "number of phases";
//   parameter Integer AIMC1.airGapS.p(min = 1) = AIMC1.p "number of pole pairs";
//   parameter Real AIMC1.airGapS.Lm(quantity = "Inductance", unit = "H") = AIMC1.Lm "main field inductance";
//   output Real AIMC1.airGapS.tau_electrical(quantity = "Torque", unit = "N.m");
//   Real AIMC1.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real AIMC1.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real AIMC1.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real AIMC1.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real AIMC1.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real AIMC1.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real AIMC1.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real AIMC1.airGapS.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.airGapS.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real AIMC1.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real AIMC1.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real AIMC1.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real AIMC1.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A");
//   Real AIMC1.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real AIMC1.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
//   protected parameter Real AIMC1.airGapS.L[1,1](quantity = "Inductance", unit = "H") = AIMC1.airGapS.Lm "inductance matrix";
//   protected parameter Real AIMC1.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real AIMC1.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real AIMC1.airGapS.L[2,2](quantity = "Inductance", unit = "H") = AIMC1.airGapS.Lm "inductance matrix";
//   parameter Real AIMC1.squirrelCageR.Lrsigma(quantity = "Inductance", unit = "H") = AIMC1.Lrsigma "rotor stray inductance per phase translated to stator";
//   parameter Real AIMC1.squirrelCageR.Rr(quantity = "Resistance", unit = "Ohm") = AIMC1.Rr "warm rotor resistance per phase translated to stator";
//   Real AIMC1.squirrelCageR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.squirrelCageR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real AIMC1.squirrelCageR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real AIMC1.squirrelCageR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
//   Real Ground1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Ground1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.ToSpacePhasor1.zero = 0.333333333333333 * (CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.u[3]));
//   CurrentRMSsensor1.ToSpacePhasor1.y[1] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToSpacePhasor1.y[2] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToPolar1.y[1] = sqrt(CurrentRMSsensor1.ToPolar1.u[1] ^ 2.0 + CurrentRMSsensor1.ToPolar1.u[2] ^ 2.0);
//   CurrentRMSsensor1.ToPolar1.y[2] = if noEvent(CurrentRMSsensor1.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(CurrentRMSsensor1.ToPolar1.u[2],CurrentRMSsensor1.ToPolar1.u[1]);
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.Gain1.k * CurrentRMSsensor1.Gain1.u;
//   assert(CurrentRMSsensor1.CurrentSensor1.plug_n.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
//   assert(CurrentRMSsensor1.plug_p.m == CurrentRMSsensor1.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then ((time - Ramp1.startTime) * Ramp1.height) / Ramp1.duration else Ramp1.height);
//   VfController1.amplitude = 1.4142135623731 * (VfController1.VNominal * (if abs(VfController1.u) < VfController1.fNominal then abs(VfController1.u) / VfController1.fNominal else 1.0));
//   der(VfController1.x) = 6.28318530717959 * VfController1.u;
//   VfController1.y[1] = VfController1.amplitude * sin(VfController1.x + VfController1.BasePhase);
//   VfController1.y[2] = VfController1.amplitude * sin(VfController1.x + VfController1.BasePhase - 6.28318530717959 / Real(VfController1.m));
//   VfController1.y[3] = VfController1.amplitude * sin(VfController1.x + VfController1.BasePhase - 12.5663706143592 / Real(VfController1.m));
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   TorqueStep1.tau = (-TorqueStep1.offsetTorque) - (if time < TorqueStep1.startTime then 0.0 else TorqueStep1.stepTorque);
//   TorqueStep1.bearing.phi = 0.0;
//   assert(TerminalBox1.positiveMachinePlug.m == TerminalBox1.plugToGrid.m,"automatically generated from connect");
//   assert(TerminalBox1.negativeMachinePlug.m == TerminalBox1.star.plug_p.m,"automatically generated from connect");
//   SignalVoltage1.signalVoltage[1].v = SignalVoltage1.signalVoltage[1].p.v - SignalVoltage1.signalVoltage[1].n.v;
//   0.0 = SignalVoltage1.signalVoltage[1].p.i + SignalVoltage1.signalVoltage[1].n.i;
//   SignalVoltage1.signalVoltage[1].i = SignalVoltage1.signalVoltage[1].p.i;
//   SignalVoltage1.signalVoltage[2].v = SignalVoltage1.signalVoltage[2].p.v - SignalVoltage1.signalVoltage[2].n.v;
//   0.0 = SignalVoltage1.signalVoltage[2].p.i + SignalVoltage1.signalVoltage[2].n.i;
//   SignalVoltage1.signalVoltage[2].i = SignalVoltage1.signalVoltage[2].p.i;
//   SignalVoltage1.signalVoltage[3].v = SignalVoltage1.signalVoltage[3].p.v - SignalVoltage1.signalVoltage[3].n.v;
//   0.0 = SignalVoltage1.signalVoltage[3].p.i + SignalVoltage1.signalVoltage[3].n.i;
//   SignalVoltage1.signalVoltage[3].i = SignalVoltage1.signalVoltage[3].p.i;
//   SignalVoltage1.i[1] = SignalVoltage1.plug_p.pin[1].i;
//   SignalVoltage1.i[2] = SignalVoltage1.plug_p.pin[2].i;
//   SignalVoltage1.i[3] = SignalVoltage1.plug_p.pin[3].i;
//   AIMC1.inertiaRotor.w = der(AIMC1.inertiaRotor.phi);
//   AIMC1.inertiaRotor.a = der(AIMC1.inertiaRotor.w);
//   AIMC1.inertiaRotor.J * AIMC1.inertiaRotor.a = AIMC1.inertiaRotor.flange_a.tau + AIMC1.inertiaRotor.flange_b.tau;
//   AIMC1.inertiaRotor.flange_a.phi = AIMC1.inertiaRotor.phi;
//   AIMC1.inertiaRotor.flange_b.phi = AIMC1.inertiaRotor.phi;
//   AIMC1.fixedHousing.flange_b.phi = AIMC1.fixedHousing.phi0;
//   AIMC1.rs.resistor[1].R * AIMC1.rs.resistor[1].i = AIMC1.rs.resistor[1].v;
//   AIMC1.rs.resistor[1].v = AIMC1.rs.resistor[1].p.v - AIMC1.rs.resistor[1].n.v;
//   0.0 = AIMC1.rs.resistor[1].p.i + AIMC1.rs.resistor[1].n.i;
//   AIMC1.rs.resistor[1].i = AIMC1.rs.resistor[1].p.i;
//   AIMC1.rs.resistor[2].R * AIMC1.rs.resistor[2].i = AIMC1.rs.resistor[2].v;
//   AIMC1.rs.resistor[2].v = AIMC1.rs.resistor[2].p.v - AIMC1.rs.resistor[2].n.v;
//   0.0 = AIMC1.rs.resistor[2].p.i + AIMC1.rs.resistor[2].n.i;
//   AIMC1.rs.resistor[2].i = AIMC1.rs.resistor[2].p.i;
//   AIMC1.rs.resistor[3].R * AIMC1.rs.resistor[3].i = AIMC1.rs.resistor[3].v;
//   AIMC1.rs.resistor[3].v = AIMC1.rs.resistor[3].p.v - AIMC1.rs.resistor[3].n.v;
//   0.0 = AIMC1.rs.resistor[3].p.i + AIMC1.rs.resistor[3].n.i;
//   AIMC1.rs.resistor[3].i = AIMC1.rs.resistor[3].p.i;
//   AIMC1.rs.v[1] = AIMC1.rs.plug_p.pin[1].v - AIMC1.rs.plug_n.pin[1].v;
//   AIMC1.rs.v[2] = AIMC1.rs.plug_p.pin[2].v - AIMC1.rs.plug_n.pin[2].v;
//   AIMC1.rs.v[3] = AIMC1.rs.plug_p.pin[3].v - AIMC1.rs.plug_n.pin[3].v;
//   AIMC1.rs.i[1] = AIMC1.rs.plug_p.pin[1].i;
//   AIMC1.rs.i[2] = AIMC1.rs.plug_p.pin[2].i;
//   AIMC1.rs.i[3] = AIMC1.rs.plug_p.pin[3].i;
//   AIMC1.lssigma.inductor[1].L * der(AIMC1.lssigma.inductor[1].i) = AIMC1.lssigma.inductor[1].v;
//   AIMC1.lssigma.inductor[1].v = AIMC1.lssigma.inductor[1].p.v - AIMC1.lssigma.inductor[1].n.v;
//   0.0 = AIMC1.lssigma.inductor[1].p.i + AIMC1.lssigma.inductor[1].n.i;
//   AIMC1.lssigma.inductor[1].i = AIMC1.lssigma.inductor[1].p.i;
//   AIMC1.lssigma.inductor[2].L * der(AIMC1.lssigma.inductor[2].i) = AIMC1.lssigma.inductor[2].v;
//   AIMC1.lssigma.inductor[2].v = AIMC1.lssigma.inductor[2].p.v - AIMC1.lssigma.inductor[2].n.v;
//   0.0 = AIMC1.lssigma.inductor[2].p.i + AIMC1.lssigma.inductor[2].n.i;
//   AIMC1.lssigma.inductor[2].i = AIMC1.lssigma.inductor[2].p.i;
//   AIMC1.lssigma.inductor[3].L * der(AIMC1.lssigma.inductor[3].i) = AIMC1.lssigma.inductor[3].v;
//   AIMC1.lssigma.inductor[3].v = AIMC1.lssigma.inductor[3].p.v - AIMC1.lssigma.inductor[3].n.v;
//   0.0 = AIMC1.lssigma.inductor[3].p.i + AIMC1.lssigma.inductor[3].n.i;
//   AIMC1.lssigma.inductor[3].i = AIMC1.lssigma.inductor[3].p.i;
//   AIMC1.lssigma.v[1] = AIMC1.lssigma.plug_p.pin[1].v - AIMC1.lssigma.plug_n.pin[1].v;
//   AIMC1.lssigma.v[2] = AIMC1.lssigma.plug_p.pin[2].v - AIMC1.lssigma.plug_n.pin[2].v;
//   AIMC1.lssigma.v[3] = AIMC1.lssigma.plug_p.pin[3].v - AIMC1.lssigma.plug_n.pin[3].v;
//   AIMC1.lssigma.i[1] = AIMC1.lssigma.plug_p.pin[1].i;
//   AIMC1.lssigma.i[2] = AIMC1.lssigma.plug_p.pin[2].i;
//   AIMC1.lssigma.i[3] = AIMC1.lssigma.plug_p.pin[3].i;
//   AIMC1.spacePhasorS.gnd.p.v = 0.0;
//   AIMC1.spacePhasorS.v[1] = AIMC1.spacePhasorS.plug_p.pin[1].v - AIMC1.spacePhasorS.plug_n.pin[1].v;
//   AIMC1.spacePhasorS.v[2] = AIMC1.spacePhasorS.plug_p.pin[2].v - AIMC1.spacePhasorS.plug_n.pin[2].v;
//   AIMC1.spacePhasorS.v[3] = AIMC1.spacePhasorS.plug_p.pin[3].v - AIMC1.spacePhasorS.plug_n.pin[3].v;
//   AIMC1.spacePhasorS.i[1] = AIMC1.spacePhasorS.plug_p.pin[1].i;
//   AIMC1.spacePhasorS.i[2] = AIMC1.spacePhasorS.plug_p.pin[2].i;
//   AIMC1.spacePhasorS.i[3] = AIMC1.spacePhasorS.plug_p.pin[3].i;
//   AIMC1.spacePhasorS.i[1] = -AIMC1.spacePhasorS.plug_n.pin[1].i;
//   AIMC1.spacePhasorS.i[2] = -AIMC1.spacePhasorS.plug_n.pin[2].i;
//   AIMC1.spacePhasorS.i[3] = -AIMC1.spacePhasorS.plug_n.pin[3].i;
//   AIMC1.spacePhasorS.zero.v = 0.333333333333333 * (AIMC1.spacePhasorS.v[1] + (AIMC1.spacePhasorS.v[2] + AIMC1.spacePhasorS.v[3]));
//   AIMC1.spacePhasorS.spacePhasor.v_[1] = AIMC1.spacePhasorS.TransformationMatrix[1,1] * AIMC1.spacePhasorS.v[1] + (AIMC1.spacePhasorS.TransformationMatrix[1,2] * AIMC1.spacePhasorS.v[2] + AIMC1.spacePhasorS.TransformationMatrix[1,3] * AIMC1.spacePhasorS.v[3]);
//   AIMC1.spacePhasorS.spacePhasor.v_[2] = AIMC1.spacePhasorS.TransformationMatrix[2,1] * AIMC1.spacePhasorS.v[1] + (AIMC1.spacePhasorS.TransformationMatrix[2,2] * AIMC1.spacePhasorS.v[2] + AIMC1.spacePhasorS.TransformationMatrix[2,3] * AIMC1.spacePhasorS.v[3]);
//   -AIMC1.spacePhasorS.zero.i = 0.333333333333333 * (AIMC1.spacePhasorS.i[1] + (AIMC1.spacePhasorS.i[2] + AIMC1.spacePhasorS.i[3]));
//   -AIMC1.spacePhasorS.spacePhasor.i_[1] = AIMC1.spacePhasorS.TransformationMatrix[1,1] * AIMC1.spacePhasorS.i[1] + (AIMC1.spacePhasorS.TransformationMatrix[1,2] * AIMC1.spacePhasorS.i[2] + AIMC1.spacePhasorS.TransformationMatrix[1,3] * AIMC1.spacePhasorS.i[3]);
//   -AIMC1.spacePhasorS.spacePhasor.i_[2] = AIMC1.spacePhasorS.TransformationMatrix[2,1] * AIMC1.spacePhasorS.i[1] + (AIMC1.spacePhasorS.TransformationMatrix[2,2] * AIMC1.spacePhasorS.i[2] + AIMC1.spacePhasorS.TransformationMatrix[2,3] * AIMC1.spacePhasorS.i[3]);
//   AIMC1.airGapS.gamma = Real(AIMC1.airGapS.p) * (AIMC1.airGapS.flange_a.phi - AIMC1.airGapS.support.phi);
//   AIMC1.airGapS.RotationMatrix[1,1] = cos(AIMC1.airGapS.gamma);
//   AIMC1.airGapS.RotationMatrix[1,2] = -sin(AIMC1.airGapS.gamma);
//   AIMC1.airGapS.RotationMatrix[2,1] = sin(AIMC1.airGapS.gamma);
//   AIMC1.airGapS.RotationMatrix[2,2] = cos(AIMC1.airGapS.gamma);
//   AIMC1.airGapS.i_ss[1] = AIMC1.airGapS.spacePhasor_s.i_[1];
//   AIMC1.airGapS.i_ss[2] = AIMC1.airGapS.spacePhasor_s.i_[2];
//   AIMC1.airGapS.i_ss[1] = AIMC1.airGapS.RotationMatrix[1,1] * AIMC1.airGapS.i_sr[1] + AIMC1.airGapS.RotationMatrix[1,2] * AIMC1.airGapS.i_sr[2];
//   AIMC1.airGapS.i_ss[2] = AIMC1.airGapS.RotationMatrix[2,1] * AIMC1.airGapS.i_sr[1] + AIMC1.airGapS.RotationMatrix[2,2] * AIMC1.airGapS.i_sr[2];
//   AIMC1.airGapS.i_rr[1] = AIMC1.airGapS.spacePhasor_r.i_[1];
//   AIMC1.airGapS.i_rr[2] = AIMC1.airGapS.spacePhasor_r.i_[2];
//   AIMC1.airGapS.i_rs[1] = AIMC1.airGapS.RotationMatrix[1,1] * AIMC1.airGapS.i_rr[1] + AIMC1.airGapS.RotationMatrix[1,2] * AIMC1.airGapS.i_rr[2];
//   AIMC1.airGapS.i_rs[2] = AIMC1.airGapS.RotationMatrix[2,1] * AIMC1.airGapS.i_rr[1] + AIMC1.airGapS.RotationMatrix[2,2] * AIMC1.airGapS.i_rr[2];
//   AIMC1.airGapS.i_ms[1] = AIMC1.airGapS.i_ss[1] + AIMC1.airGapS.i_rs[1];
//   AIMC1.airGapS.i_ms[2] = AIMC1.airGapS.i_ss[2] + AIMC1.airGapS.i_rs[2];
//   AIMC1.airGapS.psi_ms[1] = AIMC1.airGapS.L[1,1] * AIMC1.airGapS.i_ms[1] + AIMC1.airGapS.L[1,2] * AIMC1.airGapS.i_ms[2];
//   AIMC1.airGapS.psi_ms[2] = AIMC1.airGapS.L[2,1] * AIMC1.airGapS.i_ms[1] + AIMC1.airGapS.L[2,2] * AIMC1.airGapS.i_ms[2];
//   AIMC1.airGapS.psi_mr[1] = AIMC1.airGapS.RotationMatrix[1,1] * AIMC1.airGapS.psi_ms[1] + AIMC1.airGapS.RotationMatrix[2,1] * AIMC1.airGapS.psi_ms[2];
//   AIMC1.airGapS.psi_mr[2] = AIMC1.airGapS.RotationMatrix[1,2] * AIMC1.airGapS.psi_ms[1] + AIMC1.airGapS.RotationMatrix[2,2] * AIMC1.airGapS.psi_ms[2];
//   AIMC1.airGapS.spacePhasor_s.v_[1] = der(AIMC1.airGapS.psi_ms[1]);
//   AIMC1.airGapS.spacePhasor_s.v_[2] = der(AIMC1.airGapS.psi_ms[2]);
//   AIMC1.airGapS.spacePhasor_r.v_[1] = der(AIMC1.airGapS.psi_mr[1]);
//   AIMC1.airGapS.spacePhasor_r.v_[2] = der(AIMC1.airGapS.psi_mr[2]);
//   AIMC1.airGapS.tau_electrical = 1.5 * (Real(AIMC1.airGapS.p) * (AIMC1.airGapS.spacePhasor_s.i_[2] * AIMC1.airGapS.psi_ms[1] - AIMC1.airGapS.spacePhasor_s.i_[1] * AIMC1.airGapS.psi_ms[2]));
//   AIMC1.airGapS.flange_a.tau = -AIMC1.airGapS.tau_electrical;
//   AIMC1.airGapS.support.tau = AIMC1.airGapS.tau_electrical;
//   AIMC1.squirrelCageR.spacePhasor_r.v_[1] = AIMC1.squirrelCageR.Rr * AIMC1.squirrelCageR.spacePhasor_r.i_[1] + AIMC1.squirrelCageR.Lrsigma * der(AIMC1.squirrelCageR.spacePhasor_r.i_[1]);
//   AIMC1.squirrelCageR.spacePhasor_r.v_[2] = AIMC1.squirrelCageR.Rr * AIMC1.squirrelCageR.spacePhasor_r.i_[2] + AIMC1.squirrelCageR.Lrsigma * der(AIMC1.squirrelCageR.spacePhasor_r.i_[2]);
//   assert(AIMC1.spacePhasorS.plug_n.m == AIMC1.plug_sn.m,"automatically generated from connect");
//   assert(AIMC1.rs.plug_p.m == AIMC1.plug_sp.m,"automatically generated from connect");
//   assert(AIMC1.rs.plug_n.m == AIMC1.lssigma.plug_p.m,"automatically generated from connect");
//   assert(AIMC1.lssigma.plug_n.m == AIMC1.spacePhasorS.plug_p.m,"automatically generated from connect");
//   Ground1.p.v = 0.0;
//   assert(TerminalBox1.plugToGrid.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
//   assert(SignalVoltage1.plug_n.m == Star1.plug_p.m,"automatically generated from connect");
//   assert(SignalVoltage1.plug_p.m == CurrentRMSsensor1.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.negativeMachinePlug.m == AIMC1.plug_sn.m,"automatically generated from connect");
//   assert(TerminalBox1.positiveMachinePlug.m == AIMC1.plug_sp.m,"automatically generated from connect");
//   Star1.pin_n.i + Ground1.p.i = 0.0;
//   Ground1.p.v = SignalVoltage1.plug_n.pin[1].v;
//   Ground1.p.v = SignalVoltage1.plug_n.pin[2].v;
//   Ground1.p.v = SignalVoltage1.plug_n.pin[3].v;
//   Ground1.p.v = SignalVoltage1.signalVoltage[1].n.v;
//   Ground1.p.v = SignalVoltage1.signalVoltage[2].n.v;
//   Ground1.p.v = SignalVoltage1.signalVoltage[3].n.v;
//   Ground1.p.v = Star1.pin_n.v;
//   Ground1.p.v = Star1.plug_p.pin[1].v;
//   Ground1.p.v = Star1.plug_p.pin[2].v;
//   Ground1.p.v = Star1.plug_p.pin[3].v;
//   TerminalBox1.positiveMachinePlug.pin[3].i + AIMC1.plug_sp.pin[3].i = 0.0;
//   AIMC1.plug_sp.pin[3].v = AIMC1.rs.plug_p.pin[3].v;
//   AIMC1.plug_sp.pin[3].v = AIMC1.rs.resistor[3].p.v;
//   AIMC1.plug_sp.pin[3].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v;
//   AIMC1.plug_sp.pin[3].v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v;
//   AIMC1.plug_sp.pin[3].v = CurrentRMSsensor1.plug_n.pin[3].v;
//   AIMC1.plug_sp.pin[3].v = TerminalBox1.plugToGrid.pin[3].v;
//   AIMC1.plug_sp.pin[3].v = TerminalBox1.positiveMachinePlug.pin[3].v;
//   TerminalBox1.positiveMachinePlug.pin[2].i + AIMC1.plug_sp.pin[2].i = 0.0;
//   AIMC1.plug_sp.pin[2].v = AIMC1.rs.plug_p.pin[2].v;
//   AIMC1.plug_sp.pin[2].v = AIMC1.rs.resistor[2].p.v;
//   AIMC1.plug_sp.pin[2].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v;
//   AIMC1.plug_sp.pin[2].v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v;
//   AIMC1.plug_sp.pin[2].v = CurrentRMSsensor1.plug_n.pin[2].v;
//   AIMC1.plug_sp.pin[2].v = TerminalBox1.plugToGrid.pin[2].v;
//   AIMC1.plug_sp.pin[2].v = TerminalBox1.positiveMachinePlug.pin[2].v;
//   TerminalBox1.positiveMachinePlug.pin[1].i + AIMC1.plug_sp.pin[1].i = 0.0;
//   AIMC1.plug_sp.pin[1].v = AIMC1.rs.plug_p.pin[1].v;
//   AIMC1.plug_sp.pin[1].v = AIMC1.rs.resistor[1].p.v;
//   AIMC1.plug_sp.pin[1].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v;
//   AIMC1.plug_sp.pin[1].v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v;
//   AIMC1.plug_sp.pin[1].v = CurrentRMSsensor1.plug_n.pin[1].v;
//   AIMC1.plug_sp.pin[1].v = TerminalBox1.plugToGrid.pin[1].v;
//   AIMC1.plug_sp.pin[1].v = TerminalBox1.positiveMachinePlug.pin[1].v;
//   TerminalBox1.negativeMachinePlug.pin[3].i + AIMC1.plug_sn.pin[3].i = 0.0;
//   AIMC1.plug_sn.pin[1].v = AIMC1.plug_sn.pin[2].v;
//   AIMC1.plug_sn.pin[1].v = AIMC1.plug_sn.pin[3].v;
//   AIMC1.plug_sn.pin[1].v = AIMC1.spacePhasorS.plug_n.pin[1].v;
//   AIMC1.plug_sn.pin[1].v = AIMC1.spacePhasorS.plug_n.pin[2].v;
//   AIMC1.plug_sn.pin[1].v = AIMC1.spacePhasorS.plug_n.pin[3].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.negativeMachinePlug.pin[1].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.negativeMachinePlug.pin[2].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.negativeMachinePlug.pin[3].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.star.pin_n.v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.star.plug_p.pin[1].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.star.plug_p.pin[2].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.star.plug_p.pin[3].v;
//   AIMC1.plug_sn.pin[1].v = TerminalBox1.starpoint.v;
//   TerminalBox1.negativeMachinePlug.pin[2].i + AIMC1.plug_sn.pin[2].i = 0.0;
//   TerminalBox1.negativeMachinePlug.pin[1].i + AIMC1.plug_sn.pin[1].i = 0.0;
//   AIMC1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
//   AIMC1.flange_a.phi = AIMC1.inertiaRotor.flange_b.phi;
//   AIMC1.flange_a.phi = LoadInertia.flange_a.phi;
//   SignalVoltage1.plug_p.pin[3].i + CurrentRMSsensor1.plug_p.pin[3].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = SignalVoltage1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = SignalVoltage1.signalVoltage[3].p.v;
//   SignalVoltage1.plug_p.pin[2].i + CurrentRMSsensor1.plug_p.pin[2].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = SignalVoltage1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = SignalVoltage1.signalVoltage[2].p.v;
//   SignalVoltage1.plug_p.pin[1].i + CurrentRMSsensor1.plug_p.pin[1].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = SignalVoltage1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = SignalVoltage1.signalVoltage[1].p.v;
//   SignalVoltage1.signalVoltage[1].v = SignalVoltage1.v[1];
//   SignalVoltage1.signalVoltage[1].v = VfController1.y[1];
//   SignalVoltage1.signalVoltage[2].v = SignalVoltage1.v[2];
//   SignalVoltage1.signalVoltage[2].v = VfController1.y[2];
//   SignalVoltage1.signalVoltage[3].v = SignalVoltage1.v[3];
//   SignalVoltage1.signalVoltage[3].v = VfController1.y[3];
//   SignalVoltage1.plug_n.pin[3].i + Star1.plug_p.pin[3].i = 0.0;
//   SignalVoltage1.plug_n.pin[2].i + Star1.plug_p.pin[2].i = 0.0;
//   SignalVoltage1.plug_n.pin[1].i + Star1.plug_p.pin[1].i = 0.0;
//   Ramp1.y = VfController1.u;
//   TorqueStep1.flange.tau + LoadInertia.flange_b.tau = 0.0;
//   LoadInertia.flange_b.phi = TorqueStep1.flange.phi;
//   TerminalBox1.plugToGrid.pin[3].i + CurrentRMSsensor1.plug_n.pin[3].i = 0.0;
//   TerminalBox1.plugToGrid.pin[2].i + CurrentRMSsensor1.plug_n.pin[2].i = 0.0;
//   TerminalBox1.plugToGrid.pin[1].i + CurrentRMSsensor1.plug_n.pin[1].i = 0.0;
//   AIMC1.inertiaRotor.flange_b.tau + (-AIMC1.flange_a.tau) = 0.0;
//   AIMC1.airGapS.support.tau + ((-AIMC1.internalSupport.tau) + AIMC1.fixedHousing.flange_b.tau) = 0.0;
//   AIMC1.airGapS.support.phi = AIMC1.fixedHousing.flange_b.phi;
//   AIMC1.airGapS.support.phi = AIMC1.internalSupport.phi;
//   AIMC1.airGapS.spacePhasor_r.i_[1] + AIMC1.squirrelCageR.spacePhasor_r.i_[1] = 0.0;
//   AIMC1.airGapS.spacePhasor_r.i_[2] + AIMC1.squirrelCageR.spacePhasor_r.i_[2] = 0.0;
//   AIMC1.airGapS.spacePhasor_r.v_[1] = AIMC1.squirrelCageR.spacePhasor_r.v_[1];
//   AIMC1.airGapS.spacePhasor_r.v_[2] = AIMC1.squirrelCageR.spacePhasor_r.v_[2];
//   AIMC1.spacePhasorS.spacePhasor.i_[1] + AIMC1.airGapS.spacePhasor_s.i_[1] = 0.0;
//   AIMC1.spacePhasorS.spacePhasor.i_[2] + AIMC1.airGapS.spacePhasor_s.i_[2] = 0.0;
//   AIMC1.airGapS.spacePhasor_s.v_[1] = AIMC1.spacePhasorS.spacePhasor.v_[1];
//   AIMC1.airGapS.spacePhasor_s.v_[2] = AIMC1.spacePhasorS.spacePhasor.v_[2];
//   AIMC1.spacePhasorS.ground.i + AIMC1.spacePhasorS.zero.i = 0.0;
//   AIMC1.spacePhasorS.gnd.p.v = AIMC1.spacePhasorS.ground.v;
//   AIMC1.spacePhasorS.gnd.p.v = AIMC1.spacePhasorS.zero.v;
//   AIMC1.lssigma.plug_n.pin[3].i + AIMC1.spacePhasorS.plug_p.pin[3].i = 0.0;
//   AIMC1.lssigma.inductor[3].n.v = AIMC1.lssigma.plug_n.pin[3].v;
//   AIMC1.lssigma.inductor[3].n.v = AIMC1.spacePhasorS.plug_p.pin[3].v;
//   AIMC1.lssigma.plug_n.pin[2].i + AIMC1.spacePhasorS.plug_p.pin[2].i = 0.0;
//   AIMC1.lssigma.inductor[2].n.v = AIMC1.lssigma.plug_n.pin[2].v;
//   AIMC1.lssigma.inductor[2].n.v = AIMC1.spacePhasorS.plug_p.pin[2].v;
//   AIMC1.lssigma.plug_n.pin[1].i + AIMC1.spacePhasorS.plug_p.pin[1].i = 0.0;
//   AIMC1.lssigma.inductor[1].n.v = AIMC1.lssigma.plug_n.pin[1].v;
//   AIMC1.lssigma.inductor[1].n.v = AIMC1.spacePhasorS.plug_p.pin[1].v;
//   AIMC1.rs.plug_n.pin[3].i + AIMC1.lssigma.plug_p.pin[3].i = 0.0;
//   AIMC1.lssigma.inductor[3].p.v = AIMC1.lssigma.plug_p.pin[3].v;
//   AIMC1.lssigma.inductor[3].p.v = AIMC1.rs.plug_n.pin[3].v;
//   AIMC1.lssigma.inductor[3].p.v = AIMC1.rs.resistor[3].n.v;
//   AIMC1.rs.plug_n.pin[2].i + AIMC1.lssigma.plug_p.pin[2].i = 0.0;
//   AIMC1.lssigma.inductor[2].p.v = AIMC1.lssigma.plug_p.pin[2].v;
//   AIMC1.lssigma.inductor[2].p.v = AIMC1.rs.plug_n.pin[2].v;
//   AIMC1.lssigma.inductor[2].p.v = AIMC1.rs.resistor[2].n.v;
//   AIMC1.rs.plug_n.pin[1].i + AIMC1.lssigma.plug_p.pin[1].i = 0.0;
//   AIMC1.lssigma.inductor[1].p.v = AIMC1.lssigma.plug_p.pin[1].v;
//   AIMC1.lssigma.inductor[1].p.v = AIMC1.rs.plug_n.pin[1].v;
//   AIMC1.lssigma.inductor[1].p.v = AIMC1.rs.resistor[1].n.v;
//   AIMC1.rs.plug_p.pin[3].i + (-AIMC1.plug_sp.pin[3].i) = 0.0;
//   AIMC1.rs.plug_p.pin[2].i + (-AIMC1.plug_sp.pin[2].i) = 0.0;
//   AIMC1.rs.plug_p.pin[1].i + (-AIMC1.plug_sp.pin[1].i) = 0.0;
//   AIMC1.spacePhasorS.plug_n.pin[3].i + (-AIMC1.plug_sn.pin[3].i) = 0.0;
//   AIMC1.spacePhasorS.plug_n.pin[2].i + (-AIMC1.plug_sn.pin[2].i) = 0.0;
//   AIMC1.spacePhasorS.plug_n.pin[1].i + (-AIMC1.plug_sn.pin[1].i) = 0.0;
//   AIMC1.airGapS.flange_a.tau + AIMC1.inertiaRotor.flange_a.tau = 0.0;
//   AIMC1.airGapS.flange_a.phi = AIMC1.inertiaRotor.flange_a.phi;
//   AIMC1.lssigma.inductor[3].p.i + (-AIMC1.lssigma.plug_p.pin[3].i) = 0.0;
//   AIMC1.lssigma.inductor[2].p.i + (-AIMC1.lssigma.plug_p.pin[2].i) = 0.0;
//   AIMC1.lssigma.inductor[1].p.i + (-AIMC1.lssigma.plug_p.pin[1].i) = 0.0;
//   AIMC1.lssigma.inductor[3].n.i + (-AIMC1.lssigma.plug_n.pin[3].i) = 0.0;
//   AIMC1.lssigma.inductor[2].n.i + (-AIMC1.lssigma.plug_n.pin[2].i) = 0.0;
//   AIMC1.lssigma.inductor[1].n.i + (-AIMC1.lssigma.plug_n.pin[1].i) = 0.0;
//   AIMC1.rs.resistor[3].p.i + (-AIMC1.rs.plug_p.pin[3].i) = 0.0;
//   AIMC1.rs.resistor[2].p.i + (-AIMC1.rs.plug_p.pin[2].i) = 0.0;
//   AIMC1.rs.resistor[1].p.i + (-AIMC1.rs.plug_p.pin[1].i) = 0.0;
//   AIMC1.rs.resistor[3].n.i + (-AIMC1.rs.plug_n.pin[3].i) = 0.0;
//   AIMC1.rs.resistor[2].n.i + (-AIMC1.rs.plug_n.pin[2].i) = 0.0;
//   AIMC1.rs.resistor[1].n.i + (-AIMC1.rs.plug_n.pin[1].i) = 0.0;
//   AIMC1.spacePhasorS.gnd.p.i + (-AIMC1.spacePhasorS.ground.i) = 0.0;
//   AIMC1.internalSupport.tau = 0.0;
//   SignalVoltage1.signalVoltage[3].n.i + (-SignalVoltage1.plug_n.pin[3].i) = 0.0;
//   SignalVoltage1.signalVoltage[2].n.i + (-SignalVoltage1.plug_n.pin[2].i) = 0.0;
//   SignalVoltage1.signalVoltage[1].n.i + (-SignalVoltage1.plug_n.pin[1].i) = 0.0;
//   SignalVoltage1.signalVoltage[3].p.i + (-SignalVoltage1.plug_p.pin[3].i) = 0.0;
//   SignalVoltage1.signalVoltage[2].p.i + (-SignalVoltage1.plug_p.pin[2].i) = 0.0;
//   SignalVoltage1.signalVoltage[1].p.i + (-SignalVoltage1.plug_p.pin[1].i) = 0.0;
//   (-TerminalBox1.negativeMachinePlug.pin[3].i) + TerminalBox1.star.plug_p.pin[3].i = 0.0;
//   (-TerminalBox1.negativeMachinePlug.pin[2].i) + TerminalBox1.star.plug_p.pin[2].i = 0.0;
//   (-TerminalBox1.negativeMachinePlug.pin[1].i) + TerminalBox1.star.plug_p.pin[1].i = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[3].i) + (-TerminalBox1.plugToGrid.pin[3].i) = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[2].i) + (-TerminalBox1.plugToGrid.pin[2].i) = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[1].i) + (-TerminalBox1.plugToGrid.pin[1].i) = 0.0;
//   TerminalBox1.star.pin_n.i + (-TerminalBox1.starpoint.i) = 0.0;
//   TerminalBox1.starpoint.i = 0.0;
//   (-TerminalBox1.star.plug_p.pin[3].i) + ((-TerminalBox1.star.plug_p.pin[2].i) + ((-TerminalBox1.star.plug_p.pin[1].i) + (-TerminalBox1.star.pin_n.i))) = 0.0;
//   TorqueStep1.bearing.tau = 0.0;
//   (-Star1.plug_p.pin[3].i) + ((-Star1.plug_p.pin[2].i) + ((-Star1.plug_p.pin[1].i) + (-Star1.pin_n.i))) = 0.0;
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.I;
//   (-CurrentRMSsensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-CurrentRMSsensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-CurrentRMSsensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i + (-CurrentRMSsensor1.plug_n.pin[3].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i + (-CurrentRMSsensor1.plug_n.pin[2].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i + (-CurrentRMSsensor1.plug_n.pin[1].i) = 0.0;
//   CurrentRMSsensor1.Gain1.u = CurrentRMSsensor1.ToPolar1.y[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.CurrentSensor1.i[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.ToSpacePhasor1.u[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.CurrentSensor1.i[2];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.ToSpacePhasor1.u[2];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.CurrentSensor1.i[3];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.ToSpacePhasor1.u[3];
//   CurrentRMSsensor1.ToPolar1.u[1] = CurrentRMSsensor1.ToSpacePhasor1.y[1];
//   CurrentRMSsensor1.ToPolar1.u[2] = CurrentRMSsensor1.ToSpacePhasor1.y[2];
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i) = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMC_Inverter;
// "
// ""
// endResult
