//name:         SMEE_Gen
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Machines.Examples.SMEE_Gen);
getErrorString();
// Result:
// true
// "function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
//   constant Integer m = 3 "number of phases";
//   constant Real pi = 3.14159265358979;
//   input Real[3] x;
//   output Real[2] y;
//   output Real y0;
// algorithm
//   y := {0.0,0.0};
//   for k in 1:3 loop
//     y := {y[1] + x[k] * 0.666666666666667 * cos(2.0943951023932 * /*REAL*/(k - 1)),y[2] + x[k] * 0.666666666666667 * sin(2.0943951023932 * /*REAL*/(k - 1))};
//   end for;
//   y0 := 0.333333333333333 * (x[1] + x[2] + x[3]);
// end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.SIunits.Conversions.from_deg
//   input Real degree(quantity = "Angle", unit = "deg") "degree value";
//   output Real radian(quantity = "Angle", unit = "rad", displayUnit = "deg") "radian value";
// algorithm
//   radian := 0.0174532925199433 * degree;
// end Modelica.SIunits.Conversions.from_deg;
// 
// function Modelica.SIunits.Conversions.from_rpm
//   input Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
//   output Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// algorithm
//   rs := 0.10471975511966 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm
//   input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
//   output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.SMEE_Gen
//   constant Integer m = 3 "number of phases";
//   parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
//   parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
//   parameter Real rpm(quantity = "AngularVelocity", unit = "rev/min") = 1499.0 "nominal speed";
//   parameter Real Ie(quantity = "ElectricCurrent", unit = "A") = 19.0 "excitation current";
//   parameter Real Ie0(quantity = "ElectricCurrent", unit = "A") = 10.0 "initial excitation current";
//   parameter Real gamma0(quantity = "Angle", unit = "deg") = 0.0 "initial rotor displacement angle";
//   parameter Real SMEE1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "rotor's moment of inertia";
//   output Real SMEE1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg", start = (-3.14159265358979 - Modelica.SIunits.Conversions.from_deg(gamma0)) / Real(SMEE1.p)) = SMEE1.flange_a.phi "mechanical angle of rotor against stator";
//   output Real SMEE1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(SMEE1.phi_mechanical) "mechanical angular velocity of rotor against stator";
//   output Real SMEE1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(SMEE1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
//   output Real SMEE1.tau_electrical(quantity = "Torque", unit = "N.m") = SMEE1.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real SMEE1.tau_shaft(quantity = "Torque", unit = "N.m") = -SMEE1.flange_a.tau "shaft torque";
//   Real SMEE1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real SMEE1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = SMEE1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real SMEE1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real SMEE1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real SMEE1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = SMEE1.J_Rotor "Moment of inertia";
//   parameter Integer SMEE1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real SMEE1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real SMEE1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real SMEE1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer SMEE1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real SMEE1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = SMEE1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real SMEE1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   parameter Real SMEE1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real SMEE1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real SMEE1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   constant Real SMEE1.pi = 3.14159265358979;
//   constant Integer SMEE1.m = 3 "number of phases";
//   parameter Integer SMEE1.p(min = 1) = 2 "number of pole pairs (Integer)";
//   output Real SMEE1.vs[1](quantity = "ElectricPotential", unit = "V") = SMEE1.plug_sp.pin[1].v - SMEE1.plug_sn.pin[1].v "stator instantaneous voltages";
//   output Real SMEE1.vs[2](quantity = "ElectricPotential", unit = "V") = SMEE1.plug_sp.pin[2].v - SMEE1.plug_sn.pin[2].v "stator instantaneous voltages";
//   output Real SMEE1.vs[3](quantity = "ElectricPotential", unit = "V") = SMEE1.plug_sp.pin[3].v - SMEE1.plug_sn.pin[3].v "stator instantaneous voltages";
//   output Real SMEE1.is[1](quantity = "ElectricCurrent", unit = "A") = SMEE1.plug_sp.pin[1].i "stator instantaneous currents";
//   output Real SMEE1.is[2](quantity = "ElectricCurrent", unit = "A") = SMEE1.plug_sp.pin[2].i "stator instantaneous currents";
//   output Real SMEE1.is[3](quantity = "ElectricCurrent", unit = "A") = SMEE1.plug_sp.pin[3].i "stator instantaneous currents";
//   parameter Integer SMEE1.plug_sp.m(min = 1) = 3 "number of phases";
//   Real SMEE1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SMEE1.plug_sn.m(min = 1) = 3 "number of phases";
//   Real SMEE1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.Rs(quantity = "Resistance", unit = "Ohm") = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
//   parameter Real SMEE1.Lssigma(quantity = "Inductance", unit = "H") = 0.1 * 1.0 / SMEE1.fNominal / 6.28318530717959 "|Nominal resistances and inductances|stator stray inductance per phase";
//   parameter Real SMEE1.Lmd(quantity = "Inductance", unit = "H") = 1.5 * 1.0 / SMEE1.fNominal / 6.28318530717959 "|Nominal resistances and inductances|main field inductance in d-axis";
//   parameter Real SMEE1.Lmq(quantity = "Inductance", unit = "H") = 1.5 * 1.0 / SMEE1.fNominal / 6.28318530717959 "|Nominal resistances and inductances|main field inductance in q-axis";
//   parameter Boolean SMEE1.DamperCage = true "damper cage is present?";
//   parameter Real SMEE1.Lrsigma(quantity = "Inductance", unit = "H") = 0.05 * 1.0 / SMEE1.fNominal / 6.28318530717959 "damper stray inductance in d-axis";
//   parameter Real SMEE1.Lrsigmaq(quantity = "Inductance", unit = "H") = SMEE1.Lrsigma "damper stray inductance in q-axis";
//   parameter Real SMEE1.Rr(quantity = "Resistance", unit = "Ohm") = 0.04 "warm damper resistance in d-axis";
//   parameter Real SMEE1.Rrq(quantity = "Resistance", unit = "Ohm") = SMEE1.Rr "warm damper resistance in q-axis";
//   parameter Real SMEE1.VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "|Excitation|nominal stator RMS voltage per phase";
//   parameter Real SMEE1.fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "|Excitation|nominal frequency";
//   parameter Real SMEE1.Ie0(quantity = "ElectricCurrent", unit = "A") = 10.0 "|Excitation|no-load excitation current @ nominal voltage and frequency";
//   parameter Real SMEE1.Re(quantity = "Resistance", unit = "Ohm") = 2.5 "|Excitation|warm excitation resistance";
//   parameter Real SMEE1.sigmae(min = 0.0, max = 1.0) = 0.025 "|Excitation|stray fraction of total excitation inductance";
//   output Real SMEE1.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.default) = SMEE1.spacePhasorS.zero.i "stator zero-sequence current";
//   output Real SMEE1.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = SMEE1.airGapR.i_ss[1] "stator space phasor current / stator fixed frame";
//   output Real SMEE1.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = SMEE1.airGapR.i_ss[2] "stator space phasor current / stator fixed frame";
//   output Real SMEE1.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = SMEE1.airGapR.i_sr[1] "stator space phasor current / rotor fixed frame";
//   output Real SMEE1.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = SMEE1.airGapR.i_sr[2] "stator space phasor current / rotor fixed frame";
//   output Real SMEE1.ve(quantity = "ElectricPotential", unit = "V") = SMEE1.pin_ep.v - SMEE1.pin_en.v "excitation voltage";
//   output Real SMEE1.ie(quantity = "ElectricCurrent", unit = "A") = SMEE1.pin_ep.i "excitation current";
//   parameter Integer SMEE1.rs.m(min = 1) = 3 "number of phases";
//   Real SMEE1.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SMEE1.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SMEE1.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer SMEE1.rs.plug_p.m(min = 1) = SMEE1.rs.m "number of phases";
//   Real SMEE1.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SMEE1.rs.plug_n.m(min = 1) = SMEE1.rs.m "number of phases";
//   Real SMEE1.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.rs.R[1](quantity = "Resistance", unit = "Ohm") = SMEE1.Rs "Resistance";
//   parameter Real SMEE1.rs.R[2](quantity = "Resistance", unit = "Ohm") = SMEE1.Rs "Resistance";
//   parameter Real SMEE1.rs.R[3](quantity = "Resistance", unit = "Ohm") = SMEE1.Rs "Resistance";
//   Real SMEE1.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm") = SMEE1.rs.R[1] "Resistance";
//   Real SMEE1.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm") = SMEE1.rs.R[2] "Resistance";
//   Real SMEE1.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm") = SMEE1.rs.R[3] "Resistance";
//   parameter Integer SMEE1.lssigma.m(min = 1) = 3 "number of phases";
//   Real SMEE1.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SMEE1.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SMEE1.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SMEE1.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer SMEE1.lssigma.plug_p.m(min = 1) = SMEE1.lssigma.m "number of phases";
//   Real SMEE1.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SMEE1.lssigma.plug_n.m(min = 1) = SMEE1.lssigma.m "number of phases";
//   Real SMEE1.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.lssigma.L[1](quantity = "Inductance", unit = "H") = SMEE1.Lssigma "Inductance";
//   parameter Real SMEE1.lssigma.L[2](quantity = "Inductance", unit = "H") = SMEE1.Lssigma "Inductance";
//   parameter Real SMEE1.lssigma.L[3](quantity = "Inductance", unit = "H") = SMEE1.Lssigma "Inductance";
//   Real SMEE1.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.lssigma.inductor[1].L(quantity = "Inductance", unit = "H") = SMEE1.lssigma.L[1] "Inductance";
//   Real SMEE1.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.lssigma.inductor[2].L(quantity = "Inductance", unit = "H") = SMEE1.lssigma.L[2] "Inductance";
//   Real SMEE1.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.lssigma.inductor[3].L(quantity = "Inductance", unit = "H") = SMEE1.lssigma.L[3] "Inductance";
//   Real SMEE1.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.re.R(quantity = "Resistance", unit = "Ohm") = SMEE1.Re "Resistance";
//   Real SMEE1.lesigma.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SMEE1.lesigma.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SMEE1.lesigma.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lesigma.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.lesigma.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.lesigma.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SMEE1.lesigma.L(quantity = "Inductance", unit = "H") = SMEE1.Lesigma "Inductance";
//   Real SMEE1.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer SMEE1.spacePhasorS.m = 3 "number of phases";
//   constant Real SMEE1.spacePhasorS.pi = 3.14159265358979;
//   Real SMEE1.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real SMEE1.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real SMEE1.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
//   Real SMEE1.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real SMEE1.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   Real SMEE1.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
//   parameter Integer SMEE1.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
//   Real SMEE1.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SMEE1.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
//   Real SMEE1.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A");
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real SMEE1.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real SMEE1.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
//   constant Integer SMEE1.airGapR.m = 3 "number of phases";
//   parameter Integer SMEE1.airGapR.p(min = 1) = SMEE1.p "number of pole pairs";
//   parameter Real SMEE1.airGapR.Lmd(quantity = "Inductance", unit = "H") = SMEE1.Lmd "main field inductance d-axis";
//   parameter Real SMEE1.airGapR.Lmq(quantity = "Inductance", unit = "H") = SMEE1.Lmq "main field inductance q-axis";
//   output Real SMEE1.airGapR.tau_electrical(quantity = "Torque", unit = "N.m");
//   Real SMEE1.airGapR.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
//   Real SMEE1.airGapR.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.i_mr[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.i_mr[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
//   Real SMEE1.airGapR.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
//   Real SMEE1.airGapR.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
//   Real SMEE1.airGapR.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
//   Real SMEE1.airGapR.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
//   Real SMEE1.airGapR.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
//   Real SMEE1.airGapR.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.airGapR.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real SMEE1.airGapR.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real SMEE1.airGapR.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real SMEE1.airGapR.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.airGapR.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.airGapR.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.airGapR.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.airGapR.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.airGapR.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.airGapR.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.airGapR.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
//   protected parameter Real SMEE1.airGapR.L[1,1](quantity = "Inductance", unit = "H") = SMEE1.airGapR.Lmd "inductance matrix";
//   protected parameter Real SMEE1.airGapR.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real SMEE1.airGapR.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
//   protected parameter Real SMEE1.airGapR.L[2,2](quantity = "Inductance", unit = "H") = SMEE1.airGapR.Lmq "inductance matrix";
//   parameter Real SMEE1.electricalExcitation.TurnsRatio = SMEE1.TurnsRatio "stator current / excitation current";
//   Real SMEE1.electricalExcitation.ie(quantity = "ElectricCurrent", unit = "A") "excitation current";
//   Real SMEE1.electricalExcitation.ve(quantity = "ElectricPotential", unit = "V") "excitation voltage";
//   Real SMEE1.electricalExcitation.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.electricalExcitation.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.electricalExcitation.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.electricalExcitation.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.electricalExcitation.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.electricalExcitation.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SMEE1.electricalExcitation.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SMEE1.electricalExcitation.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected parameter Real SMEE1.TurnsRatio = 1.4142135623731 * (SMEE1.VNominal * 1.0 / SMEE1.Ie0 / SMEE1.Lmd / SMEE1.fNominal / 6.28318530717959) "stator current / excitation current";
//   protected parameter Real SMEE1.Lesigma(quantity = "Inductance", unit = "H") = SMEE1.Lmd * (SMEE1.TurnsRatio ^ 2.0 * SMEE1.sigmae / (1.0 - SMEE1.sigmae));
//   output Real SMEE1.idq_dr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = SMEE1.damperCage.spacePhasor_r.i_[1] "damper space phasor current / rotor fixed frame";
//   output Real SMEE1.idq_dr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = SMEE1.damperCage.spacePhasor_r.i_[2] "damper space phasor current / rotor fixed frame";
//   parameter Real SMEE1.damperCage.Lrsigma(quantity = "Inductance", unit = "H") = SMEE1.Lrsigma "stray inductance in d-axis per phase translated to stator";
//   parameter Real SMEE1.damperCage.Lrsigmaq(quantity = "Inductance", unit = "H") = SMEE1.Lrsigmaq "stray inductance in q-axis per phase translated to stator";
//   parameter Real SMEE1.damperCage.Rr(quantity = "Resistance", unit = "Ohm") = SMEE1.Rr "warm resistance in d-axis per phase translated to stator";
//   parameter Real SMEE1.damperCage.Rrq(quantity = "Resistance", unit = "Ohm") = SMEE1.Rrq "warm resistance in q-axis per phase translated to stator";
//   Real SMEE1.damperCage.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.damperCage.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
//   Real SMEE1.damperCage.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
//   Real SMEE1.damperCage.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
//   constant Integer RotorAngle1.m = 3 "number of phases";
//   parameter Integer RotorAngle1.p(min = 1) = SMEE1.p "number of pole pairs";
//   output Real RotorAngle1.rotorAngle(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   parameter Integer RotorAngle1.plug_p.m(min = 1) = 3 "number of phases";
//   Real RotorAngle1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer RotorAngle1.plug_n.m(min = 1) = 3 "number of phases";
//   Real RotorAngle1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer RotorAngle1.VoltageSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer RotorAngle1.VoltageSensor1.plug_p.m(min = 1) = RotorAngle1.VoltageSensor1.m "number of phases";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer RotorAngle1.VoltageSensor1.plug_n.m(min = 1) = RotorAngle1.VoltageSensor1.m "number of phases";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real RotorAngle1.VoltageSensor1.v[1] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real RotorAngle1.VoltageSensor1.v[2] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   output Real RotorAngle1.VoltageSensor1.v[3] "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RotorAngle1.VoltageSensor1.voltageSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real RotorAngle1.VoltageSensor1.voltageSensor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
//   parameter Integer RotorAngle1.ToSpacePhasorVS.nin = 3 "Number of inputs";
//   parameter Integer RotorAngle1.ToSpacePhasorVS.nout = 2 "Number of outputs";
//   input Real RotorAngle1.ToSpacePhasorVS.u[1] "Connector of Real input signals";
//   input Real RotorAngle1.ToSpacePhasorVS.u[2] "Connector of Real input signals";
//   input Real RotorAngle1.ToSpacePhasorVS.u[3] "Connector of Real input signals";
//   output Real RotorAngle1.ToSpacePhasorVS.y[1] "Connector of Real output signals";
//   output Real RotorAngle1.ToSpacePhasorVS.y[2] "Connector of Real output signals";
//   constant Integer RotorAngle1.ToSpacePhasorVS.m = 3 "number of phases";
//   constant Real RotorAngle1.ToSpacePhasorVS.pi = 3.14159265358979;
//   output Real RotorAngle1.ToSpacePhasorVS.zero;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[1,1] = 1.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[1,2] = 0.0;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[2,1] = -0.5;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[3,1] = -0.5;
//   protected parameter Real RotorAngle1.ToSpacePhasorVS.InverseTransformation[3,2] = -0.866025403784438;
//   Real RotorAngle1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real RotorAngle1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real RotorAngle1.relativeAngleSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real RotorAngle1.relativeAngleSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real RotorAngle1.relativeAngleSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real RotorAngle1.relativeAngleSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real RotorAngle1.relativeAngleSensor.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg") "Relative angle between two flanges (= flange_b.phi - flange_a.phi)";
//   output Real RotorAngle1.constant_.y "Connector of Real output signal";
//   parameter Real RotorAngle1.constant_.k = 1.5707963267949 "Constant output value";
//   input Real RotorAngle1.add.u1 "Connector of Real input signal 1";
//   input Real RotorAngle1.add.u2 "Connector of Real input signal 2";
//   output Real RotorAngle1.add.y "Connector of Real output signal";
//   parameter Real RotorAngle1.add.k1 = Real(RotorAngle1.p) "Gain of upper input";
//   parameter Real RotorAngle1.add.k2 = 1.0 "Gain of lower input";
//   parameter Integer RotorAngle1.rotatorVS2R.n = 2 "Number of inputs (= number of outputs)";
//   input Real RotorAngle1.rotatorVS2R.u[1] "Connector of Real input signals";
//   input Real RotorAngle1.rotatorVS2R.u[2] "Connector of Real input signals";
//   output Real RotorAngle1.rotatorVS2R.y[1] "Connector of Real output signals";
//   output Real RotorAngle1.rotatorVS2R.y[2] "Connector of Real output signals";
//   input Real RotorAngle1.rotatorVS2R.angle(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[1,1] = cos(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[1,2] = -sin(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[2,1] = sin(-RotorAngle1.rotatorVS2R.angle);
//   protected Real RotorAngle1.rotatorVS2R.RotationMatrix[2,2] = cos(-RotorAngle1.rotatorVS2R.angle);
//   parameter Integer RotorAngle1.ToPolarVSR.n = 2 "Number of inputs (= number of outputs)";
//   input Real RotorAngle1.ToPolarVSR.u[1] "Connector of Real input signals";
//   input Real RotorAngle1.ToPolarVSR.u[2] "Connector of Real input signals";
//   output Real RotorAngle1.ToPolarVSR.y[1] "Connector of Real output signals";
//   output Real RotorAngle1.ToPolarVSR.y[2] "Connector of Real output signals";
//   constant Real RotorAngle1.ToPolarVSR.small = 1e-60;
//   parameter Integer RotorAngle1.deMultiplex2.n1 = 1 "dimension of output signal connector 1";
//   parameter Integer RotorAngle1.deMultiplex2.n2 = 1 "dimension of output signal connector 2";
//   input Real RotorAngle1.deMultiplex2.u[1] "Connector of Real input signals";
//   input Real RotorAngle1.deMultiplex2.u[2] "Connector of Real input signals";
//   output Real RotorAngle1.deMultiplex2.y1[1] "Connector of Real output signals 1";
//   output Real RotorAngle1.deMultiplex2.y2[1] "Connector of Real output signals 2";
//   parameter Real RotorAngle1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real RotorAngle1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real RotorAngle1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real ConstantSpeed1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(ConstantSpeed1.flange.phi) "Angular velocity at flange";
//   Real ConstantSpeed1.tau(quantity = "Torque", unit = "N.m") = ConstantSpeed1.flange.tau "accelerating torque acting at flange";
//   Real ConstantSpeed1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real ConstantSpeed1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real ConstantSpeed1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real ConstantSpeed1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real ConstantSpeed1.w_fixed(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = Modelica.SIunits.Conversions.from_rpm(rpm) "fixed speed (if negative, torque is acting as load)";
//   Real MechanicalPowerSensor1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real MechanicalPowerSensor1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real MechanicalPowerSensor1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real MechanicalPowerSensor1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real MechanicalPowerSensor1.P(quantity = "Power", unit = "W");
//   Real MechanicalPowerSensor1.TorqueSensor1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real MechanicalPowerSensor1.TorqueSensor1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real MechanicalPowerSensor1.TorqueSensor1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real MechanicalPowerSensor1.TorqueSensor1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real MechanicalPowerSensor1.TorqueSensor1.tau(quantity = "Torque", unit = "N.m") "Torque in flange flange_a and flange_b (= flange_a.tau = -flange_b.tau)";
//   input Real MechanicalPowerSensor1.Product1.u1 "Connector of Real input signal 1";
//   input Real MechanicalPowerSensor1.Product1.u2 "Connector of Real input signal 2";
//   output Real MechanicalPowerSensor1.Product1.y "Connector of Real output signal";
//   Real MechanicalPowerSensor1.SpeedSensor1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real MechanicalPowerSensor1.SpeedSensor1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real MechanicalPowerSensor1.SpeedSensor1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Absolute angular velocity of flange";
//   constant Integer CurrentRMSsensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer CurrentRMSsensor1.plug_p.m(min = 1) = 3 "number of phases";
//   Real CurrentRMSsensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.plug_n.m(min = 1) = 3 "number of phases";
//   Real CurrentRMSsensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.m(min = 1) = 3 "number of phases";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_p.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_n.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
//   output Real CurrentRMSsensor1.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nin = 3 "Number of inputs";
//   parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nout = 2 "Number of outputs";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[1] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[2] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToSpacePhasor1.u[3] "Connector of Real input signals";
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[1] "Connector of Real output signals";
//   output Real CurrentRMSsensor1.ToSpacePhasor1.y[2] "Connector of Real output signals";
//   constant Integer CurrentRMSsensor1.ToSpacePhasor1.m = 3 "number of phases";
//   constant Real CurrentRMSsensor1.ToSpacePhasor1.pi = 3.14159265358979;
//   output Real CurrentRMSsensor1.ToSpacePhasor1.zero;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
//   protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
//   parameter Integer CurrentRMSsensor1.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
//   input Real CurrentRMSsensor1.ToPolar1.u[1] "Connector of Real input signals";
//   input Real CurrentRMSsensor1.ToPolar1.u[2] "Connector of Real input signals";
//   output Real CurrentRMSsensor1.ToPolar1.y[1] "Connector of Real output signals";
//   output Real CurrentRMSsensor1.ToPolar1.y[2] "Connector of Real output signals";
//   constant Real CurrentRMSsensor1.ToPolar1.small = 1e-60;
//   parameter Real CurrentRMSsensor1.Gain1.k = 0.707106781186547 "Gain value multiplied with input signal";
//   input Real CurrentRMSsensor1.Gain1.u "Input signal connector";
//   output Real CurrentRMSsensor1.Gain1.y "Output signal connector";
//   output Real CurrentRMSsensor1.I(quantity = "ElectricCurrent", unit = "A");
//   parameter Integer SineVoltage1.m(min = 1) = 3 "number of phases";
//   Real SineVoltage1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SineVoltage1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SineVoltage1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
//   Real SineVoltage1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SineVoltage1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   Real SineVoltage1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
//   parameter Integer SineVoltage1.plug_p.m(min = 1) = SineVoltage1.m "number of phases";
//   Real SineVoltage1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer SineVoltage1.plug_n.m(min = 1) = SineVoltage1.m "number of phases";
//   Real SineVoltage1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SineVoltage1.V[1](quantity = "ElectricPotential", unit = "V") = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real SineVoltage1.V[2](quantity = "ElectricPotential", unit = "V") = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real SineVoltage1.V[3](quantity = "ElectricPotential", unit = "V") = 1.4142135623731 * VNominal "Amplitudes of sine waves";
//   parameter Real SineVoltage1.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
//   parameter Real SineVoltage1.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(SineVoltage1.m) "Phases of sine waves";
//   parameter Real SineVoltage1.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(SineVoltage1.m) "Phases of sine waves";
//   parameter Real SineVoltage1.freqHz[1](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
//   parameter Real SineVoltage1.freqHz[2](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
//   parameter Real SineVoltage1.freqHz[3](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
//   parameter Real SineVoltage1.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real SineVoltage1.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real SineVoltage1.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
//   parameter Real SineVoltage1.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real SineVoltage1.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   parameter Real SineVoltage1.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
//   Real SineVoltage1.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SineVoltage1.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SineVoltage1.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SineVoltage1.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[1] "Voltage offset";
//   parameter Real SineVoltage1.sineVoltage[1].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[1] "Time offset";
//   output Real SineVoltage1.sineVoltage[1].signalSource.y "Connector of Real output signal";
//   parameter Real SineVoltage1.sineVoltage[1].signalSource.amplitude = SineVoltage1.sineVoltage[1].V "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[1].freqHz "Frequency of sine wave";
//   parameter Real SineVoltage1.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[1].phase "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[1].signalSource.offset = SineVoltage1.sineVoltage[1].offset "Offset of output signal";
//   parameter Real SineVoltage1.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[1].startTime "Output = offset for time < startTime";
//   protected constant Real SineVoltage1.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real SineVoltage1.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[1] "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[1] "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[1] "Frequency of sine wave";
//   Real SineVoltage1.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SineVoltage1.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SineVoltage1.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SineVoltage1.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[2] "Voltage offset";
//   parameter Real SineVoltage1.sineVoltage[2].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[2] "Time offset";
//   output Real SineVoltage1.sineVoltage[2].signalSource.y "Connector of Real output signal";
//   parameter Real SineVoltage1.sineVoltage[2].signalSource.amplitude = SineVoltage1.sineVoltage[2].V "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[2].freqHz "Frequency of sine wave";
//   parameter Real SineVoltage1.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[2].phase "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[2].signalSource.offset = SineVoltage1.sineVoltage[2].offset "Offset of output signal";
//   parameter Real SineVoltage1.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[2].startTime "Output = offset for time < startTime";
//   protected constant Real SineVoltage1.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real SineVoltage1.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[2] "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[2] "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[2] "Frequency of sine wave";
//   Real SineVoltage1.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real SineVoltage1.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SineVoltage1.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SineVoltage1.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SineVoltage1.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real SineVoltage1.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[3] "Voltage offset";
//   parameter Real SineVoltage1.sineVoltage[3].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[3] "Time offset";
//   output Real SineVoltage1.sineVoltage[3].signalSource.y "Connector of Real output signal";
//   parameter Real SineVoltage1.sineVoltage[3].signalSource.amplitude = SineVoltage1.sineVoltage[3].V "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[3].freqHz "Frequency of sine wave";
//   parameter Real SineVoltage1.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[3].phase "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[3].signalSource.offset = SineVoltage1.sineVoltage[3].offset "Offset of output signal";
//   parameter Real SineVoltage1.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[3].startTime "Output = offset for time < startTime";
//   protected constant Real SineVoltage1.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real SineVoltage1.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[3] "Amplitude of sine wave";
//   parameter Real SineVoltage1.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[3] "Phase of sine wave";
//   parameter Real SineVoltage1.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[3] "Frequency of sine wave";
//   parameter Integer Star1.m(min = 1) = 3 "number of phases";
//   parameter Integer Star1.plug_p.m(min = 1) = Star1.m "number of phases";
//   Real Star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   constant Integer TerminalBox1.m = 3 "number of phases";
//   parameter String TerminalBox1.StarDelta = "Y";
//   parameter Integer TerminalBox1.positiveMachinePlug.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.positiveMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.positiveMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.negativeMachinePlug.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.negativeMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.negativeMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.plugToGrid.m(min = 1) = 3 "number of phases";
//   Real TerminalBox1.plugToGrid.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugToGrid.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.plugToGrid.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.plugToGrid.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer TerminalBox1.star.m(min = 1) = 3 "number of phases";
//   parameter Integer TerminalBox1.star.plug_p.m(min = 1) = TerminalBox1.star.m "number of phases";
//   Real TerminalBox1.star.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.star.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.star.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real TerminalBox1.starpoint.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real TerminalBox1.starpoint.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Ground1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Ground1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real Ground3.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Ground3.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RampCurrent1.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real RampCurrent1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real RampCurrent1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RampCurrent1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real RampCurrent1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real RampCurrent1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real RampCurrent1.offset(quantity = "ElectricCurrent", unit = "A") = Ie0 "Current offset";
//   parameter Real RampCurrent1.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
//   output Real RampCurrent1.signalSource.y "Connector of Real output signal";
//   parameter Real RampCurrent1.signalSource.height = RampCurrent1.I "Height of ramps";
//   parameter Real RampCurrent1.signalSource.duration(min = 1e-60) = RampCurrent1.duration "Durations of ramp";
//   parameter Real RampCurrent1.signalSource.offset = RampCurrent1.offset "Offset of output signal";
//   parameter Real RampCurrent1.signalSource.startTime(quantity = "Time", unit = "s") = RampCurrent1.startTime "Output = offset for time < startTime";
//   parameter Real RampCurrent1.I(quantity = "ElectricCurrent", unit = "A") = Ie - Ie0 "Height of ramp";
//   parameter Real RampCurrent1.duration(quantity = "Time", unit = "s", min = 1e-60) = 0.1 "Duration of ramp";
//   constant Integer ElectricalPowerSensor1.m(min = 1) = 3 "number of phases";
//   output Real ElectricalPowerSensor1.P(quantity = "Power", unit = "W");
//   output Real ElectricalPowerSensor1.Q(quantity = "Power", unit = "W");
//   parameter Integer ElectricalPowerSensor1.plug_p.m(min = 1) = 3 "number of phases";
//   Real ElectricalPowerSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer ElectricalPowerSensor1.plug_ni.m(min = 1) = 3 "number of phases";
//   Real ElectricalPowerSensor1.plug_ni.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_ni.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_ni.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_ni.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_ni.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_ni.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Integer ElectricalPowerSensor1.plug_nv.m(min = 1) = 3 "number of phases";
//   Real ElectricalPowerSensor1.plug_nv.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_nv.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_nv.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_nv.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real ElectricalPowerSensor1.plug_nv.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real ElectricalPowerSensor1.plug_nv.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected Real ElectricalPowerSensor1.v_[1](quantity = "ElectricPotential", unit = "V");
//   protected Real ElectricalPowerSensor1.v_[2](quantity = "ElectricPotential", unit = "V");
//   protected Real ElectricalPowerSensor1.i_[1](quantity = "ElectricCurrent", unit = "A");
//   protected Real ElectricalPowerSensor1.i_[2](quantity = "ElectricCurrent", unit = "A");
// equation
//   SMEE1.inertiaRotor.w = der(SMEE1.inertiaRotor.phi);
//   SMEE1.inertiaRotor.a = der(SMEE1.inertiaRotor.w);
//   SMEE1.inertiaRotor.J * SMEE1.inertiaRotor.a = SMEE1.inertiaRotor.flange_a.tau + SMEE1.inertiaRotor.flange_b.tau;
//   SMEE1.inertiaRotor.flange_a.phi = SMEE1.inertiaRotor.phi;
//   SMEE1.inertiaRotor.flange_b.phi = SMEE1.inertiaRotor.phi;
//   SMEE1.fixedHousing.flange_b.phi = SMEE1.fixedHousing.phi0;
//   SMEE1.rs.resistor[1].R * SMEE1.rs.resistor[1].i = SMEE1.rs.resistor[1].v;
//   SMEE1.rs.resistor[1].v = SMEE1.rs.resistor[1].p.v - SMEE1.rs.resistor[1].n.v;
//   0.0 = SMEE1.rs.resistor[1].p.i + SMEE1.rs.resistor[1].n.i;
//   SMEE1.rs.resistor[1].i = SMEE1.rs.resistor[1].p.i;
//   SMEE1.rs.resistor[2].R * SMEE1.rs.resistor[2].i = SMEE1.rs.resistor[2].v;
//   SMEE1.rs.resistor[2].v = SMEE1.rs.resistor[2].p.v - SMEE1.rs.resistor[2].n.v;
//   0.0 = SMEE1.rs.resistor[2].p.i + SMEE1.rs.resistor[2].n.i;
//   SMEE1.rs.resistor[2].i = SMEE1.rs.resistor[2].p.i;
//   SMEE1.rs.resistor[3].R * SMEE1.rs.resistor[3].i = SMEE1.rs.resistor[3].v;
//   SMEE1.rs.resistor[3].v = SMEE1.rs.resistor[3].p.v - SMEE1.rs.resistor[3].n.v;
//   0.0 = SMEE1.rs.resistor[3].p.i + SMEE1.rs.resistor[3].n.i;
//   SMEE1.rs.resistor[3].i = SMEE1.rs.resistor[3].p.i;
//   SMEE1.rs.v[1] = SMEE1.rs.plug_p.pin[1].v - SMEE1.rs.plug_n.pin[1].v;
//   SMEE1.rs.v[2] = SMEE1.rs.plug_p.pin[2].v - SMEE1.rs.plug_n.pin[2].v;
//   SMEE1.rs.v[3] = SMEE1.rs.plug_p.pin[3].v - SMEE1.rs.plug_n.pin[3].v;
//   SMEE1.rs.i[1] = SMEE1.rs.plug_p.pin[1].i;
//   SMEE1.rs.i[2] = SMEE1.rs.plug_p.pin[2].i;
//   SMEE1.rs.i[3] = SMEE1.rs.plug_p.pin[3].i;
//   SMEE1.lssigma.inductor[1].L * der(SMEE1.lssigma.inductor[1].i) = SMEE1.lssigma.inductor[1].v;
//   SMEE1.lssigma.inductor[1].v = SMEE1.lssigma.inductor[1].p.v - SMEE1.lssigma.inductor[1].n.v;
//   0.0 = SMEE1.lssigma.inductor[1].p.i + SMEE1.lssigma.inductor[1].n.i;
//   SMEE1.lssigma.inductor[1].i = SMEE1.lssigma.inductor[1].p.i;
//   SMEE1.lssigma.inductor[2].L * der(SMEE1.lssigma.inductor[2].i) = SMEE1.lssigma.inductor[2].v;
//   SMEE1.lssigma.inductor[2].v = SMEE1.lssigma.inductor[2].p.v - SMEE1.lssigma.inductor[2].n.v;
//   0.0 = SMEE1.lssigma.inductor[2].p.i + SMEE1.lssigma.inductor[2].n.i;
//   SMEE1.lssigma.inductor[2].i = SMEE1.lssigma.inductor[2].p.i;
//   SMEE1.lssigma.inductor[3].L * der(SMEE1.lssigma.inductor[3].i) = SMEE1.lssigma.inductor[3].v;
//   SMEE1.lssigma.inductor[3].v = SMEE1.lssigma.inductor[3].p.v - SMEE1.lssigma.inductor[3].n.v;
//   0.0 = SMEE1.lssigma.inductor[3].p.i + SMEE1.lssigma.inductor[3].n.i;
//   SMEE1.lssigma.inductor[3].i = SMEE1.lssigma.inductor[3].p.i;
//   SMEE1.lssigma.v[1] = SMEE1.lssigma.plug_p.pin[1].v - SMEE1.lssigma.plug_n.pin[1].v;
//   SMEE1.lssigma.v[2] = SMEE1.lssigma.plug_p.pin[2].v - SMEE1.lssigma.plug_n.pin[2].v;
//   SMEE1.lssigma.v[3] = SMEE1.lssigma.plug_p.pin[3].v - SMEE1.lssigma.plug_n.pin[3].v;
//   SMEE1.lssigma.i[1] = SMEE1.lssigma.plug_p.pin[1].i;
//   SMEE1.lssigma.i[2] = SMEE1.lssigma.plug_p.pin[2].i;
//   SMEE1.lssigma.i[3] = SMEE1.lssigma.plug_p.pin[3].i;
//   SMEE1.re.R * SMEE1.re.i = SMEE1.re.v;
//   SMEE1.re.v = SMEE1.re.p.v - SMEE1.re.n.v;
//   0.0 = SMEE1.re.p.i + SMEE1.re.n.i;
//   SMEE1.re.i = SMEE1.re.p.i;
//   SMEE1.lesigma.L * der(SMEE1.lesigma.i) = SMEE1.lesigma.v;
//   SMEE1.lesigma.v = SMEE1.lesigma.p.v - SMEE1.lesigma.n.v;
//   0.0 = SMEE1.lesigma.p.i + SMEE1.lesigma.n.i;
//   SMEE1.lesigma.i = SMEE1.lesigma.p.i;
//   SMEE1.spacePhasorS.gnd.p.v = 0.0;
//   SMEE1.spacePhasorS.v[1] = SMEE1.spacePhasorS.plug_p.pin[1].v - SMEE1.spacePhasorS.plug_n.pin[1].v;
//   SMEE1.spacePhasorS.v[2] = SMEE1.spacePhasorS.plug_p.pin[2].v - SMEE1.spacePhasorS.plug_n.pin[2].v;
//   SMEE1.spacePhasorS.v[3] = SMEE1.spacePhasorS.plug_p.pin[3].v - SMEE1.spacePhasorS.plug_n.pin[3].v;
//   SMEE1.spacePhasorS.i[1] = SMEE1.spacePhasorS.plug_p.pin[1].i;
//   SMEE1.spacePhasorS.i[2] = SMEE1.spacePhasorS.plug_p.pin[2].i;
//   SMEE1.spacePhasorS.i[3] = SMEE1.spacePhasorS.plug_p.pin[3].i;
//   SMEE1.spacePhasorS.i[1] = -SMEE1.spacePhasorS.plug_n.pin[1].i;
//   SMEE1.spacePhasorS.i[2] = -SMEE1.spacePhasorS.plug_n.pin[2].i;
//   SMEE1.spacePhasorS.i[3] = -SMEE1.spacePhasorS.plug_n.pin[3].i;
//   SMEE1.spacePhasorS.zero.v = 0.333333333333333 * (SMEE1.spacePhasorS.v[1] + (SMEE1.spacePhasorS.v[2] + SMEE1.spacePhasorS.v[3]));
//   SMEE1.spacePhasorS.spacePhasor.v_[1] = SMEE1.spacePhasorS.TransformationMatrix[1,1] * SMEE1.spacePhasorS.v[1] + (SMEE1.spacePhasorS.TransformationMatrix[1,2] * SMEE1.spacePhasorS.v[2] + SMEE1.spacePhasorS.TransformationMatrix[1,3] * SMEE1.spacePhasorS.v[3]);
//   SMEE1.spacePhasorS.spacePhasor.v_[2] = SMEE1.spacePhasorS.TransformationMatrix[2,1] * SMEE1.spacePhasorS.v[1] + (SMEE1.spacePhasorS.TransformationMatrix[2,2] * SMEE1.spacePhasorS.v[2] + SMEE1.spacePhasorS.TransformationMatrix[2,3] * SMEE1.spacePhasorS.v[3]);
//   -SMEE1.spacePhasorS.zero.i = 0.333333333333333 * (SMEE1.spacePhasorS.i[1] + (SMEE1.spacePhasorS.i[2] + SMEE1.spacePhasorS.i[3]));
//   -SMEE1.spacePhasorS.spacePhasor.i_[1] = SMEE1.spacePhasorS.TransformationMatrix[1,1] * SMEE1.spacePhasorS.i[1] + (SMEE1.spacePhasorS.TransformationMatrix[1,2] * SMEE1.spacePhasorS.i[2] + SMEE1.spacePhasorS.TransformationMatrix[1,3] * SMEE1.spacePhasorS.i[3]);
//   -SMEE1.spacePhasorS.spacePhasor.i_[2] = SMEE1.spacePhasorS.TransformationMatrix[2,1] * SMEE1.spacePhasorS.i[1] + (SMEE1.spacePhasorS.TransformationMatrix[2,2] * SMEE1.spacePhasorS.i[2] + SMEE1.spacePhasorS.TransformationMatrix[2,3] * SMEE1.spacePhasorS.i[3]);
//   SMEE1.airGapR.gamma = Real(SMEE1.airGapR.p) * (SMEE1.airGapR.flange_a.phi - SMEE1.airGapR.support.phi);
//   SMEE1.airGapR.RotationMatrix[1,1] = cos(SMEE1.airGapR.gamma);
//   SMEE1.airGapR.RotationMatrix[1,2] = -sin(SMEE1.airGapR.gamma);
//   SMEE1.airGapR.RotationMatrix[2,1] = sin(SMEE1.airGapR.gamma);
//   SMEE1.airGapR.RotationMatrix[2,2] = cos(SMEE1.airGapR.gamma);
//   SMEE1.airGapR.i_ss[1] = SMEE1.airGapR.spacePhasor_s.i_[1];
//   SMEE1.airGapR.i_ss[2] = SMEE1.airGapR.spacePhasor_s.i_[2];
//   SMEE1.airGapR.i_ss[1] = SMEE1.airGapR.RotationMatrix[1,1] * SMEE1.airGapR.i_sr[1] + SMEE1.airGapR.RotationMatrix[1,2] * SMEE1.airGapR.i_sr[2];
//   SMEE1.airGapR.i_ss[2] = SMEE1.airGapR.RotationMatrix[2,1] * SMEE1.airGapR.i_sr[1] + SMEE1.airGapR.RotationMatrix[2,2] * SMEE1.airGapR.i_sr[2];
//   SMEE1.airGapR.i_rr[1] = SMEE1.airGapR.spacePhasor_r.i_[1];
//   SMEE1.airGapR.i_rr[2] = SMEE1.airGapR.spacePhasor_r.i_[2];
//   SMEE1.airGapR.i_rs[1] = SMEE1.airGapR.RotationMatrix[1,1] * SMEE1.airGapR.i_rr[1] + SMEE1.airGapR.RotationMatrix[1,2] * SMEE1.airGapR.i_rr[2];
//   SMEE1.airGapR.i_rs[2] = SMEE1.airGapR.RotationMatrix[2,1] * SMEE1.airGapR.i_rr[1] + SMEE1.airGapR.RotationMatrix[2,2] * SMEE1.airGapR.i_rr[2];
//   SMEE1.airGapR.i_mr[1] = SMEE1.airGapR.i_sr[1] + SMEE1.airGapR.i_rr[1];
//   SMEE1.airGapR.i_mr[2] = SMEE1.airGapR.i_sr[2] + SMEE1.airGapR.i_rr[2];
//   SMEE1.airGapR.psi_mr[1] = SMEE1.airGapR.L[1,1] * SMEE1.airGapR.i_mr[1] + SMEE1.airGapR.L[1,2] * SMEE1.airGapR.i_mr[2];
//   SMEE1.airGapR.psi_mr[2] = SMEE1.airGapR.L[2,1] * SMEE1.airGapR.i_mr[1] + SMEE1.airGapR.L[2,2] * SMEE1.airGapR.i_mr[2];
//   SMEE1.airGapR.psi_ms[1] = SMEE1.airGapR.RotationMatrix[1,1] * SMEE1.airGapR.psi_mr[1] + SMEE1.airGapR.RotationMatrix[1,2] * SMEE1.airGapR.psi_mr[2];
//   SMEE1.airGapR.psi_ms[2] = SMEE1.airGapR.RotationMatrix[2,1] * SMEE1.airGapR.psi_mr[1] + SMEE1.airGapR.RotationMatrix[2,2] * SMEE1.airGapR.psi_mr[2];
//   SMEE1.airGapR.spacePhasor_s.v_[1] = der(SMEE1.airGapR.psi_ms[1]);
//   SMEE1.airGapR.spacePhasor_s.v_[2] = der(SMEE1.airGapR.psi_ms[2]);
//   SMEE1.airGapR.spacePhasor_r.v_[1] = der(SMEE1.airGapR.psi_mr[1]);
//   SMEE1.airGapR.spacePhasor_r.v_[2] = der(SMEE1.airGapR.psi_mr[2]);
//   SMEE1.airGapR.tau_electrical = 1.5 * (Real(SMEE1.airGapR.p) * (SMEE1.airGapR.spacePhasor_s.i_[2] * SMEE1.airGapR.psi_ms[1] - SMEE1.airGapR.spacePhasor_s.i_[1] * SMEE1.airGapR.psi_ms[2]));
//   SMEE1.airGapR.flange_a.tau = -SMEE1.airGapR.tau_electrical;
//   SMEE1.airGapR.support.tau = SMEE1.airGapR.tau_electrical;
//   SMEE1.electricalExcitation.pin_ep.i + SMEE1.electricalExcitation.pin_en.i = 0.0;
//   SMEE1.electricalExcitation.ie = SMEE1.electricalExcitation.pin_ep.i;
//   SMEE1.electricalExcitation.ve = SMEE1.electricalExcitation.pin_ep.v - SMEE1.electricalExcitation.pin_en.v;
//   SMEE1.electricalExcitation.spacePhasor_r.i_[1] = (-SMEE1.electricalExcitation.ie) * SMEE1.electricalExcitation.TurnsRatio;
//   SMEE1.electricalExcitation.spacePhasor_r.i_[2] = 0.0;
//   SMEE1.electricalExcitation.ve = SMEE1.electricalExcitation.spacePhasor_r.v_[1] * SMEE1.electricalExcitation.TurnsRatio;
//   SMEE1.damperCage.spacePhasor_r.v_[1] = SMEE1.damperCage.Rr * SMEE1.damperCage.spacePhasor_r.i_[1] + SMEE1.damperCage.Lrsigma * der(SMEE1.damperCage.spacePhasor_r.i_[1]);
//   SMEE1.damperCage.spacePhasor_r.v_[2] = SMEE1.damperCage.Rrq * SMEE1.damperCage.spacePhasor_r.i_[2] + SMEE1.damperCage.Lrsigmaq * der(SMEE1.damperCage.spacePhasor_r.i_[2]);
//   assert(SMEE1.spacePhasorS.plug_n.m == SMEE1.plug_sn.m,"automatically generated from connect");
//   assert(SMEE1.rs.plug_p.m == SMEE1.plug_sp.m,"automatically generated from connect");
//   assert(SMEE1.rs.plug_n.m == SMEE1.lssigma.plug_p.m,"automatically generated from connect");
//   assert(SMEE1.lssigma.plug_n.m == SMEE1.spacePhasorS.plug_p.m,"automatically generated from connect");
//   RotorAngle1.VoltageSensor1.voltageSensor[1].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].v = RotorAngle1.VoltageSensor1.voltageSensor[1].p.v - RotorAngle1.VoltageSensor1.voltageSensor[1].n.v;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].v = RotorAngle1.VoltageSensor1.voltageSensor[2].p.v - RotorAngle1.VoltageSensor1.voltageSensor[2].n.v;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].p.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].n.i = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].v = RotorAngle1.VoltageSensor1.voltageSensor[3].p.v - RotorAngle1.VoltageSensor1.voltageSensor[3].n.v;
//   RotorAngle1.ToSpacePhasorVS.zero = 0.333333333333333 * (RotorAngle1.ToSpacePhasorVS.u[1] + (RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.u[3]));
//   RotorAngle1.ToSpacePhasorVS.y[1] = RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,1] * RotorAngle1.ToSpacePhasorVS.u[1] + (RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,2] * RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[1,3] * RotorAngle1.ToSpacePhasorVS.u[3]);
//   RotorAngle1.ToSpacePhasorVS.y[2] = RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,1] * RotorAngle1.ToSpacePhasorVS.u[1] + (RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,2] * RotorAngle1.ToSpacePhasorVS.u[2] + RotorAngle1.ToSpacePhasorVS.TransformationMatrix[2,3] * RotorAngle1.ToSpacePhasorVS.u[3]);
//   RotorAngle1.relativeAngleSensor.phi_rel = RotorAngle1.relativeAngleSensor.flange_b.phi - RotorAngle1.relativeAngleSensor.flange_a.phi;
//   0.0 = RotorAngle1.relativeAngleSensor.flange_a.tau;
//   0.0 = RotorAngle1.relativeAngleSensor.flange_b.tau;
//   RotorAngle1.constant_.y = RotorAngle1.constant_.k;
//   RotorAngle1.add.y = RotorAngle1.add.k1 * RotorAngle1.add.u1 + RotorAngle1.add.k2 * RotorAngle1.add.u2;
//   RotorAngle1.rotatorVS2R.y[1] = RotorAngle1.rotatorVS2R.RotationMatrix[1,1] * RotorAngle1.rotatorVS2R.u[1] + RotorAngle1.rotatorVS2R.RotationMatrix[1,2] * RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.rotatorVS2R.y[2] = RotorAngle1.rotatorVS2R.RotationMatrix[2,1] * RotorAngle1.rotatorVS2R.u[1] + RotorAngle1.rotatorVS2R.RotationMatrix[2,2] * RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.ToPolarVSR.y[1] = sqrt(RotorAngle1.ToPolarVSR.u[1] ^ 2.0 + RotorAngle1.ToPolarVSR.u[2] ^ 2.0);
//   RotorAngle1.ToPolarVSR.y[2] = if noEvent(RotorAngle1.ToPolarVSR.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(RotorAngle1.ToPolarVSR.u[2],RotorAngle1.ToPolarVSR.u[1]);
//   RotorAngle1.deMultiplex2.u[1] = RotorAngle1.deMultiplex2.y1[1];
//   RotorAngle1.deMultiplex2.u[2] = RotorAngle1.deMultiplex2.y2[1];
//   RotorAngle1.fixedHousing.flange_b.phi = RotorAngle1.fixedHousing.phi0;
//   assert(RotorAngle1.plug_p.m == RotorAngle1.VoltageSensor1.plug_p.m,"automatically generated from connect");
//   assert(RotorAngle1.plug_n.m == RotorAngle1.VoltageSensor1.plug_n.m,"automatically generated from connect");
//   ConstantSpeed1.w = ConstantSpeed1.w_fixed;
//   ConstantSpeed1.bearing.phi = 0.0;
//   MechanicalPowerSensor1.TorqueSensor1.flange_a.phi = MechanicalPowerSensor1.TorqueSensor1.flange_b.phi;
//   MechanicalPowerSensor1.TorqueSensor1.flange_a.tau = MechanicalPowerSensor1.TorqueSensor1.tau;
//   MechanicalPowerSensor1.TorqueSensor1.flange_b.tau = -MechanicalPowerSensor1.TorqueSensor1.tau;
//   MechanicalPowerSensor1.Product1.y = MechanicalPowerSensor1.Product1.u1 * MechanicalPowerSensor1.Product1.u2;
//   MechanicalPowerSensor1.SpeedSensor1.w = der(MechanicalPowerSensor1.SpeedSensor1.flange_a.phi);
//   0.0 = MechanicalPowerSensor1.SpeedSensor1.flange_a.tau;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.ToSpacePhasor1.zero = 0.333333333333333 * (CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.u[3]));
//   CurrentRMSsensor1.ToSpacePhasor1.y[1] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToSpacePhasor1.y[2] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToPolar1.y[1] = sqrt(CurrentRMSsensor1.ToPolar1.u[1] ^ 2.0 + CurrentRMSsensor1.ToPolar1.u[2] ^ 2.0);
//   CurrentRMSsensor1.ToPolar1.y[2] = if noEvent(CurrentRMSsensor1.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(CurrentRMSsensor1.ToPolar1.u[2],CurrentRMSsensor1.ToPolar1.u[1]);
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.Gain1.k * CurrentRMSsensor1.Gain1.u;
//   assert(CurrentRMSsensor1.CurrentSensor1.plug_n.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
//   assert(CurrentRMSsensor1.plug_p.m == CurrentRMSsensor1.CurrentSensor1.plug_p.m,"automatically generated from connect");
//   SineVoltage1.sineVoltage[1].signalSource.y = SineVoltage1.sineVoltage[1].signalSource.offset + (if time < SineVoltage1.sineVoltage[1].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[1].signalSource.freqHz * (time - SineVoltage1.sineVoltage[1].signalSource.startTime)) + SineVoltage1.sineVoltage[1].signalSource.phase));
//   SineVoltage1.sineVoltage[1].v = SineVoltage1.sineVoltage[1].signalSource.y;
//   SineVoltage1.sineVoltage[1].v = SineVoltage1.sineVoltage[1].p.v - SineVoltage1.sineVoltage[1].n.v;
//   0.0 = SineVoltage1.sineVoltage[1].p.i + SineVoltage1.sineVoltage[1].n.i;
//   SineVoltage1.sineVoltage[1].i = SineVoltage1.sineVoltage[1].p.i;
//   SineVoltage1.sineVoltage[2].signalSource.y = SineVoltage1.sineVoltage[2].signalSource.offset + (if time < SineVoltage1.sineVoltage[2].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[2].signalSource.freqHz * (time - SineVoltage1.sineVoltage[2].signalSource.startTime)) + SineVoltage1.sineVoltage[2].signalSource.phase));
//   SineVoltage1.sineVoltage[2].v = SineVoltage1.sineVoltage[2].signalSource.y;
//   SineVoltage1.sineVoltage[2].v = SineVoltage1.sineVoltage[2].p.v - SineVoltage1.sineVoltage[2].n.v;
//   0.0 = SineVoltage1.sineVoltage[2].p.i + SineVoltage1.sineVoltage[2].n.i;
//   SineVoltage1.sineVoltage[2].i = SineVoltage1.sineVoltage[2].p.i;
//   SineVoltage1.sineVoltage[3].signalSource.y = SineVoltage1.sineVoltage[3].signalSource.offset + (if time < SineVoltage1.sineVoltage[3].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[3].signalSource.freqHz * (time - SineVoltage1.sineVoltage[3].signalSource.startTime)) + SineVoltage1.sineVoltage[3].signalSource.phase));
//   SineVoltage1.sineVoltage[3].v = SineVoltage1.sineVoltage[3].signalSource.y;
//   SineVoltage1.sineVoltage[3].v = SineVoltage1.sineVoltage[3].p.v - SineVoltage1.sineVoltage[3].n.v;
//   0.0 = SineVoltage1.sineVoltage[3].p.i + SineVoltage1.sineVoltage[3].n.i;
//   SineVoltage1.sineVoltage[3].i = SineVoltage1.sineVoltage[3].p.i;
//   SineVoltage1.v[1] = SineVoltage1.plug_p.pin[1].v - SineVoltage1.plug_n.pin[1].v;
//   SineVoltage1.v[2] = SineVoltage1.plug_p.pin[2].v - SineVoltage1.plug_n.pin[2].v;
//   SineVoltage1.v[3] = SineVoltage1.plug_p.pin[3].v - SineVoltage1.plug_n.pin[3].v;
//   SineVoltage1.i[1] = SineVoltage1.plug_p.pin[1].i;
//   SineVoltage1.i[2] = SineVoltage1.plug_p.pin[2].i;
//   SineVoltage1.i[3] = SineVoltage1.plug_p.pin[3].i;
//   assert(TerminalBox1.positiveMachinePlug.m == TerminalBox1.plugToGrid.m,"automatically generated from connect");
//   assert(TerminalBox1.negativeMachinePlug.m == TerminalBox1.star.plug_p.m,"automatically generated from connect");
//   Ground1.p.v = 0.0;
//   Ground3.p.v = 0.0;
//   RampCurrent1.signalSource.y = RampCurrent1.signalSource.offset + (if time < RampCurrent1.signalSource.startTime then 0.0 else if time < RampCurrent1.signalSource.startTime + RampCurrent1.signalSource.duration then ((time - RampCurrent1.signalSource.startTime) * RampCurrent1.signalSource.height) / RampCurrent1.signalSource.duration else RampCurrent1.signalSource.height);
//   RampCurrent1.i = RampCurrent1.signalSource.y;
//   RampCurrent1.v = RampCurrent1.p.v - RampCurrent1.n.v;
//   0.0 = RampCurrent1.p.i + RampCurrent1.n.i;
//   RampCurrent1.i = RampCurrent1.p.i;
//   ElectricalPowerSensor1.plug_p.pin[1].v = ElectricalPowerSensor1.plug_ni.pin[1].v;
//   ElectricalPowerSensor1.plug_p.pin[2].v = ElectricalPowerSensor1.plug_ni.pin[2].v;
//   ElectricalPowerSensor1.plug_p.pin[3].v = ElectricalPowerSensor1.plug_ni.pin[3].v;
//   ElectricalPowerSensor1.plug_p.pin[1].i + ElectricalPowerSensor1.plug_ni.pin[1].i = 0.0;
//   ElectricalPowerSensor1.plug_p.pin[2].i + ElectricalPowerSensor1.plug_ni.pin[2].i = 0.0;
//   ElectricalPowerSensor1.plug_p.pin[3].i + ElectricalPowerSensor1.plug_ni.pin[3].i = 0.0;
//   ElectricalPowerSensor1.plug_nv.pin[1].i = 0.0;
//   ElectricalPowerSensor1.plug_nv.pin[2].i = 0.0;
//   ElectricalPowerSensor1.plug_nv.pin[3].i = 0.0;
//   (ElectricalPowerSensor1.v_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({ElectricalPowerSensor1.plug_p.pin[1].v - ElectricalPowerSensor1.plug_nv.pin[1].v,ElectricalPowerSensor1.plug_p.pin[2].v - ElectricalPowerSensor1.plug_nv.pin[2].v,ElectricalPowerSensor1.plug_p.pin[3].v - ElectricalPowerSensor1.plug_nv.pin[3].v});
//   (ElectricalPowerSensor1.i_,_) = Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({ElectricalPowerSensor1.plug_p.pin[1].i,ElectricalPowerSensor1.plug_p.pin[2].i,ElectricalPowerSensor1.plug_p.pin[3].i});
//   0.666666666666667 * ElectricalPowerSensor1.P = ElectricalPowerSensor1.v_[1] * ElectricalPowerSensor1.i_[1] + ElectricalPowerSensor1.v_[2] * ElectricalPowerSensor1.i_[2];
//   0.666666666666667 * ElectricalPowerSensor1.Q = (-ElectricalPowerSensor1.v_[1]) * ElectricalPowerSensor1.i_[2] + ElectricalPowerSensor1.v_[2] * ElectricalPowerSensor1.i_[1];
//   assert(ElectricalPowerSensor1.plug_nv.m == RotorAngle1.plug_n.m,"automatically generated from connect");
//   assert(SineVoltage1.plug_p.m == ElectricalPowerSensor1.plug_p.m,"automatically generated from connect");
//   assert(ElectricalPowerSensor1.plug_ni.m == CurrentRMSsensor1.plug_p.m,"automatically generated from connect");
//   assert(TerminalBox1.plugToGrid.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
//   assert(SMEE1.plug_sp.m == TerminalBox1.positiveMachinePlug.m,"automatically generated from connect");
//   assert(SMEE1.plug_sn.m == TerminalBox1.negativeMachinePlug.m,"automatically generated from connect");
//   assert(Star1.plug_p.m == SineVoltage1.plug_n.m,"automatically generated from connect");
//   assert(RotorAngle1.plug_p.m == SMEE1.plug_sp.m,"automatically generated from connect");
//   assert(RotorAngle1.plug_n.m == SMEE1.plug_sn.m,"automatically generated from connect");
//   RampCurrent1.n.i + SMEE1.pin_ep.i = 0.0;
//   RampCurrent1.n.v = SMEE1.pin_ep.v;
//   RampCurrent1.n.v = SMEE1.re.p.v;
//   RampCurrent1.p.i + (Ground3.p.i + SMEE1.pin_en.i) = 0.0;
//   Ground3.p.v = RampCurrent1.p.v;
//   Ground3.p.v = SMEE1.electricalExcitation.pin_en.v;
//   Ground3.p.v = SMEE1.pin_en.v;
//   Star1.pin_n.i + Ground1.p.i = 0.0;
//   Ground1.p.v = SineVoltage1.plug_n.pin[1].v;
//   Ground1.p.v = SineVoltage1.plug_n.pin[2].v;
//   Ground1.p.v = SineVoltage1.plug_n.pin[3].v;
//   Ground1.p.v = SineVoltage1.sineVoltage[1].n.v;
//   Ground1.p.v = SineVoltage1.sineVoltage[2].n.v;
//   Ground1.p.v = SineVoltage1.sineVoltage[3].n.v;
//   Ground1.p.v = Star1.pin_n.v;
//   Ground1.p.v = Star1.plug_p.pin[1].v;
//   Ground1.p.v = Star1.plug_p.pin[2].v;
//   Ground1.p.v = Star1.plug_p.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[3].i + (RotorAngle1.plug_n.pin[3].i + (SMEE1.plug_sn.pin[3].i + TerminalBox1.negativeMachinePlug.pin[3].i)) = 0.0;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = ElectricalPowerSensor1.plug_nv.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = ElectricalPowerSensor1.plug_nv.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.plug_n.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.plug_n.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.plug_n.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.voltageSensor[1].n.v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.voltageSensor[2].n.v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.VoltageSensor1.voltageSensor[3].n.v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.plug_n.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.plug_n.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = RotorAngle1.plug_n.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.plug_sn.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.plug_sn.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.plug_sn.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.spacePhasorS.plug_n.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.spacePhasorS.plug_n.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = SMEE1.spacePhasorS.plug_n.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.negativeMachinePlug.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.negativeMachinePlug.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.negativeMachinePlug.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.star.pin_n.v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.star.plug_p.pin[1].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.star.plug_p.pin[2].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.star.plug_p.pin[3].v;
//   ElectricalPowerSensor1.plug_nv.pin[1].v = TerminalBox1.starpoint.v;
//   ElectricalPowerSensor1.plug_nv.pin[2].i + (RotorAngle1.plug_n.pin[2].i + (SMEE1.plug_sn.pin[2].i + TerminalBox1.negativeMachinePlug.pin[2].i)) = 0.0;
//   ElectricalPowerSensor1.plug_nv.pin[1].i + (RotorAngle1.plug_n.pin[1].i + (SMEE1.plug_sn.pin[1].i + TerminalBox1.negativeMachinePlug.pin[1].i)) = 0.0;
//   RotorAngle1.plug_p.pin[3].i + (SMEE1.plug_sp.pin[3].i + TerminalBox1.positiveMachinePlug.pin[3].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = CurrentRMSsensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = RotorAngle1.VoltageSensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = RotorAngle1.VoltageSensor1.voltageSensor[3].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = RotorAngle1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = SMEE1.plug_sp.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = SMEE1.rs.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = SMEE1.rs.resistor[3].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = TerminalBox1.plugToGrid.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = TerminalBox1.positiveMachinePlug.pin[3].v;
//   RotorAngle1.plug_p.pin[2].i + (SMEE1.plug_sp.pin[2].i + TerminalBox1.positiveMachinePlug.pin[2].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = CurrentRMSsensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = RotorAngle1.VoltageSensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = RotorAngle1.VoltageSensor1.voltageSensor[2].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = RotorAngle1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = SMEE1.plug_sp.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = SMEE1.rs.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = SMEE1.rs.resistor[2].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = TerminalBox1.plugToGrid.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = TerminalBox1.positiveMachinePlug.pin[2].v;
//   RotorAngle1.plug_p.pin[1].i + (SMEE1.plug_sp.pin[1].i + TerminalBox1.positiveMachinePlug.pin[1].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = CurrentRMSsensor1.plug_n.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = RotorAngle1.VoltageSensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = RotorAngle1.VoltageSensor1.voltageSensor[1].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = RotorAngle1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = SMEE1.plug_sp.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = SMEE1.rs.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = SMEE1.rs.resistor[1].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = TerminalBox1.plugToGrid.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = TerminalBox1.positiveMachinePlug.pin[1].v;
//   RotorAngle1.flange.tau + (SMEE1.flange_a.tau + MechanicalPowerSensor1.flange_a.tau) = 0.0;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = MechanicalPowerSensor1.TorqueSensor1.flange_a.phi;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = MechanicalPowerSensor1.flange_a.phi;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = RotorAngle1.flange.phi;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = RotorAngle1.relativeAngleSensor.flange_b.phi;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = SMEE1.flange_a.phi;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.phi = SMEE1.inertiaRotor.flange_b.phi;
//   Star1.plug_p.pin[3].i + SineVoltage1.plug_n.pin[3].i = 0.0;
//   Star1.plug_p.pin[2].i + SineVoltage1.plug_n.pin[2].i = 0.0;
//   Star1.plug_p.pin[1].i + SineVoltage1.plug_n.pin[1].i = 0.0;
//   TerminalBox1.plugToGrid.pin[3].i + CurrentRMSsensor1.plug_n.pin[3].i = 0.0;
//   TerminalBox1.plugToGrid.pin[2].i + CurrentRMSsensor1.plug_n.pin[2].i = 0.0;
//   TerminalBox1.plugToGrid.pin[1].i + CurrentRMSsensor1.plug_n.pin[1].i = 0.0;
//   ElectricalPowerSensor1.plug_ni.pin[3].i + CurrentRMSsensor1.plug_p.pin[3].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.plug_p.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = ElectricalPowerSensor1.plug_ni.pin[3].v;
//   ElectricalPowerSensor1.plug_ni.pin[2].i + CurrentRMSsensor1.plug_p.pin[2].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.plug_p.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = ElectricalPowerSensor1.plug_ni.pin[2].v;
//   ElectricalPowerSensor1.plug_ni.pin[1].i + CurrentRMSsensor1.plug_p.pin[1].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = ElectricalPowerSensor1.plug_ni.pin[1].v;
//   SineVoltage1.plug_p.pin[3].i + ElectricalPowerSensor1.plug_p.pin[3].i = 0.0;
//   ElectricalPowerSensor1.plug_p.pin[3].v = SineVoltage1.plug_p.pin[3].v;
//   ElectricalPowerSensor1.plug_p.pin[3].v = SineVoltage1.sineVoltage[3].p.v;
//   SineVoltage1.plug_p.pin[2].i + ElectricalPowerSensor1.plug_p.pin[2].i = 0.0;
//   ElectricalPowerSensor1.plug_p.pin[2].v = SineVoltage1.plug_p.pin[2].v;
//   ElectricalPowerSensor1.plug_p.pin[2].v = SineVoltage1.sineVoltage[2].p.v;
//   SineVoltage1.plug_p.pin[1].i + ElectricalPowerSensor1.plug_p.pin[1].i = 0.0;
//   ElectricalPowerSensor1.plug_p.pin[1].v = SineVoltage1.plug_p.pin[1].v;
//   ElectricalPowerSensor1.plug_p.pin[1].v = SineVoltage1.sineVoltage[1].p.v;
//   MechanicalPowerSensor1.flange_b.tau + ConstantSpeed1.flange.tau = 0.0;
//   ConstantSpeed1.flange.phi = MechanicalPowerSensor1.TorqueSensor1.flange_b.phi;
//   ConstantSpeed1.flange.phi = MechanicalPowerSensor1.flange_b.phi;
//   (-TerminalBox1.negativeMachinePlug.pin[3].i) + TerminalBox1.star.plug_p.pin[3].i = 0.0;
//   (-TerminalBox1.negativeMachinePlug.pin[2].i) + TerminalBox1.star.plug_p.pin[2].i = 0.0;
//   (-TerminalBox1.negativeMachinePlug.pin[1].i) + TerminalBox1.star.plug_p.pin[1].i = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[3].i) + (-TerminalBox1.plugToGrid.pin[3].i) = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[2].i) + (-TerminalBox1.plugToGrid.pin[2].i) = 0.0;
//   (-TerminalBox1.positiveMachinePlug.pin[1].i) + (-TerminalBox1.plugToGrid.pin[1].i) = 0.0;
//   TerminalBox1.star.pin_n.i + (-TerminalBox1.starpoint.i) = 0.0;
//   TerminalBox1.starpoint.i = 0.0;
//   (-TerminalBox1.star.plug_p.pin[3].i) + ((-TerminalBox1.star.plug_p.pin[2].i) + ((-TerminalBox1.star.plug_p.pin[1].i) + (-TerminalBox1.star.pin_n.i))) = 0.0;
//   (-Star1.plug_p.pin[3].i) + ((-Star1.plug_p.pin[2].i) + ((-Star1.plug_p.pin[1].i) + (-Star1.pin_n.i))) = 0.0;
//   SineVoltage1.sineVoltage[3].p.i + (-SineVoltage1.plug_p.pin[3].i) = 0.0;
//   SineVoltage1.sineVoltage[2].p.i + (-SineVoltage1.plug_p.pin[2].i) = 0.0;
//   SineVoltage1.sineVoltage[1].p.i + (-SineVoltage1.plug_p.pin[1].i) = 0.0;
//   SineVoltage1.sineVoltage[3].n.i + (-SineVoltage1.plug_n.pin[3].i) = 0.0;
//   SineVoltage1.sineVoltage[2].n.i + (-SineVoltage1.plug_n.pin[2].i) = 0.0;
//   SineVoltage1.sineVoltage[1].n.i + (-SineVoltage1.plug_n.pin[1].i) = 0.0;
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.I;
//   (-CurrentRMSsensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i = 0.0;
//   (-CurrentRMSsensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i = 0.0;
//   (-CurrentRMSsensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i + (-CurrentRMSsensor1.plug_n.pin[3].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i + (-CurrentRMSsensor1.plug_n.pin[2].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i + (-CurrentRMSsensor1.plug_n.pin[1].i) = 0.0;
//   CurrentRMSsensor1.Gain1.u = CurrentRMSsensor1.ToPolar1.y[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.CurrentSensor1.i[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.ToSpacePhasor1.u[1];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.CurrentSensor1.i[2];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.ToSpacePhasor1.u[2];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.CurrentSensor1.i[3];
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.ToSpacePhasor1.u[3];
//   CurrentRMSsensor1.ToPolar1.u[1] = CurrentRMSsensor1.ToSpacePhasor1.y[1];
//   CurrentRMSsensor1.ToPolar1.u[2] = CurrentRMSsensor1.ToSpacePhasor1.y[2];
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = 0.0;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = 0.0;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i) = 0.0;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i) = 0.0;
//   MechanicalPowerSensor1.SpeedSensor1.flange_a.tau + ((-MechanicalPowerSensor1.flange_a.tau) + MechanicalPowerSensor1.TorqueSensor1.flange_a.tau) = 0.0;
//   MechanicalPowerSensor1.TorqueSensor1.flange_b.tau + (-MechanicalPowerSensor1.flange_b.tau) = 0.0;
//   MechanicalPowerSensor1.P = MechanicalPowerSensor1.Product1.y;
//   MechanicalPowerSensor1.Product1.u1 = MechanicalPowerSensor1.TorqueSensor1.tau;
//   MechanicalPowerSensor1.Product1.u2 = MechanicalPowerSensor1.SpeedSensor1.w;
//   ConstantSpeed1.bearing.tau = 0.0;
//   RotorAngle1.ToSpacePhasorVS.y[1] = RotorAngle1.rotatorVS2R.u[1];
//   RotorAngle1.ToSpacePhasorVS.y[2] = RotorAngle1.rotatorVS2R.u[2];
//   RotorAngle1.ToPolarVSR.u[1] = RotorAngle1.rotatorVS2R.y[1];
//   RotorAngle1.ToPolarVSR.u[2] = RotorAngle1.rotatorVS2R.y[2];
//   RotorAngle1.ToPolarVSR.y[1] = RotorAngle1.deMultiplex2.u[1];
//   RotorAngle1.ToPolarVSR.y[2] = RotorAngle1.deMultiplex2.u[2];
//   RotorAngle1.deMultiplex2.y2[1] = RotorAngle1.rotorAngle;
//   RotorAngle1.relativeAngleSensor.flange_b.tau + (-RotorAngle1.flange.tau) = 0.0;
//   RotorAngle1.relativeAngleSensor.flange_a.tau + RotorAngle1.fixedHousing.flange_b.tau = 0.0;
//   RotorAngle1.fixedHousing.flange_b.phi = RotorAngle1.relativeAngleSensor.flange_a.phi;
//   RotorAngle1.ToSpacePhasorVS.u[1] = RotorAngle1.VoltageSensor1.v[1];
//   RotorAngle1.ToSpacePhasorVS.u[1] = RotorAngle1.VoltageSensor1.voltageSensor[1].v;
//   RotorAngle1.ToSpacePhasorVS.u[2] = RotorAngle1.VoltageSensor1.v[2];
//   RotorAngle1.ToSpacePhasorVS.u[2] = RotorAngle1.VoltageSensor1.voltageSensor[2].v;
//   RotorAngle1.ToSpacePhasorVS.u[3] = RotorAngle1.VoltageSensor1.v[3];
//   RotorAngle1.ToSpacePhasorVS.u[3] = RotorAngle1.VoltageSensor1.voltageSensor[3].v;
//   (-RotorAngle1.plug_n.pin[3].i) + RotorAngle1.VoltageSensor1.plug_n.pin[3].i = 0.0;
//   (-RotorAngle1.plug_n.pin[2].i) + RotorAngle1.VoltageSensor1.plug_n.pin[2].i = 0.0;
//   (-RotorAngle1.plug_n.pin[1].i) + RotorAngle1.VoltageSensor1.plug_n.pin[1].i = 0.0;
//   (-RotorAngle1.plug_p.pin[3].i) + RotorAngle1.VoltageSensor1.plug_p.pin[3].i = 0.0;
//   (-RotorAngle1.plug_p.pin[2].i) + RotorAngle1.VoltageSensor1.plug_p.pin[2].i = 0.0;
//   (-RotorAngle1.plug_p.pin[1].i) + RotorAngle1.VoltageSensor1.plug_p.pin[1].i = 0.0;
//   RotorAngle1.add.u1 = RotorAngle1.relativeAngleSensor.phi_rel;
//   RotorAngle1.add.y = RotorAngle1.rotatorVS2R.angle;
//   RotorAngle1.add.u2 = RotorAngle1.constant_.y;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].n.i + (-RotorAngle1.VoltageSensor1.plug_n.pin[3].i) = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].n.i + (-RotorAngle1.VoltageSensor1.plug_n.pin[2].i) = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].n.i + (-RotorAngle1.VoltageSensor1.plug_n.pin[1].i) = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[3].p.i + (-RotorAngle1.VoltageSensor1.plug_p.pin[3].i) = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[2].p.i + (-RotorAngle1.VoltageSensor1.plug_p.pin[2].i) = 0.0;
//   RotorAngle1.VoltageSensor1.voltageSensor[1].p.i + (-RotorAngle1.VoltageSensor1.plug_p.pin[1].i) = 0.0;
//   SMEE1.inertiaRotor.flange_b.tau + (-SMEE1.flange_a.tau) = 0.0;
//   SMEE1.airGapR.support.tau + ((-SMEE1.internalSupport.tau) + SMEE1.fixedHousing.flange_b.tau) = 0.0;
//   SMEE1.airGapR.support.phi = SMEE1.fixedHousing.flange_b.phi;
//   SMEE1.airGapR.support.phi = SMEE1.internalSupport.phi;
//   SMEE1.airGapR.spacePhasor_r.i_[1] + (SMEE1.damperCage.spacePhasor_r.i_[1] + SMEE1.electricalExcitation.spacePhasor_r.i_[1]) = 0.0;
//   SMEE1.airGapR.spacePhasor_r.i_[2] + (SMEE1.damperCage.spacePhasor_r.i_[2] + SMEE1.electricalExcitation.spacePhasor_r.i_[2]) = 0.0;
//   SMEE1.airGapR.spacePhasor_r.v_[1] = SMEE1.damperCage.spacePhasor_r.v_[1];
//   SMEE1.airGapR.spacePhasor_r.v_[1] = SMEE1.electricalExcitation.spacePhasor_r.v_[1];
//   SMEE1.airGapR.spacePhasor_r.v_[2] = SMEE1.damperCage.spacePhasor_r.v_[2];
//   SMEE1.airGapR.spacePhasor_r.v_[2] = SMEE1.electricalExcitation.spacePhasor_r.v_[2];
//   SMEE1.lesigma.n.i + SMEE1.electricalExcitation.pin_ep.i = 0.0;
//   SMEE1.electricalExcitation.pin_ep.v = SMEE1.lesigma.n.v;
//   SMEE1.electricalExcitation.pin_en.i + (-SMEE1.pin_en.i) = 0.0;
//   SMEE1.spacePhasorS.spacePhasor.i_[1] + SMEE1.airGapR.spacePhasor_s.i_[1] = 0.0;
//   SMEE1.spacePhasorS.spacePhasor.i_[2] + SMEE1.airGapR.spacePhasor_s.i_[2] = 0.0;
//   SMEE1.airGapR.spacePhasor_s.v_[1] = SMEE1.spacePhasorS.spacePhasor.v_[1];
//   SMEE1.airGapR.spacePhasor_s.v_[2] = SMEE1.spacePhasorS.spacePhasor.v_[2];
//   SMEE1.spacePhasorS.ground.i + SMEE1.spacePhasorS.zero.i = 0.0;
//   SMEE1.spacePhasorS.gnd.p.v = SMEE1.spacePhasorS.ground.v;
//   SMEE1.spacePhasorS.gnd.p.v = SMEE1.spacePhasorS.zero.v;
//   SMEE1.lssigma.plug_n.pin[3].i + SMEE1.spacePhasorS.plug_p.pin[3].i = 0.0;
//   SMEE1.lssigma.inductor[3].n.v = SMEE1.lssigma.plug_n.pin[3].v;
//   SMEE1.lssigma.inductor[3].n.v = SMEE1.spacePhasorS.plug_p.pin[3].v;
//   SMEE1.lssigma.plug_n.pin[2].i + SMEE1.spacePhasorS.plug_p.pin[2].i = 0.0;
//   SMEE1.lssigma.inductor[2].n.v = SMEE1.lssigma.plug_n.pin[2].v;
//   SMEE1.lssigma.inductor[2].n.v = SMEE1.spacePhasorS.plug_p.pin[2].v;
//   SMEE1.lssigma.plug_n.pin[1].i + SMEE1.spacePhasorS.plug_p.pin[1].i = 0.0;
//   SMEE1.lssigma.inductor[1].n.v = SMEE1.lssigma.plug_n.pin[1].v;
//   SMEE1.lssigma.inductor[1].n.v = SMEE1.spacePhasorS.plug_p.pin[1].v;
//   SMEE1.rs.plug_n.pin[3].i + SMEE1.lssigma.plug_p.pin[3].i = 0.0;
//   SMEE1.lssigma.inductor[3].p.v = SMEE1.lssigma.plug_p.pin[3].v;
//   SMEE1.lssigma.inductor[3].p.v = SMEE1.rs.plug_n.pin[3].v;
//   SMEE1.lssigma.inductor[3].p.v = SMEE1.rs.resistor[3].n.v;
//   SMEE1.rs.plug_n.pin[2].i + SMEE1.lssigma.plug_p.pin[2].i = 0.0;
//   SMEE1.lssigma.inductor[2].p.v = SMEE1.lssigma.plug_p.pin[2].v;
//   SMEE1.lssigma.inductor[2].p.v = SMEE1.rs.plug_n.pin[2].v;
//   SMEE1.lssigma.inductor[2].p.v = SMEE1.rs.resistor[2].n.v;
//   SMEE1.rs.plug_n.pin[1].i + SMEE1.lssigma.plug_p.pin[1].i = 0.0;
//   SMEE1.lssigma.inductor[1].p.v = SMEE1.lssigma.plug_p.pin[1].v;
//   SMEE1.lssigma.inductor[1].p.v = SMEE1.rs.plug_n.pin[1].v;
//   SMEE1.lssigma.inductor[1].p.v = SMEE1.rs.resistor[1].n.v;
//   (-SMEE1.pin_ep.i) + SMEE1.re.p.i = 0.0;
//   SMEE1.lesigma.p.i + SMEE1.re.n.i = 0.0;
//   SMEE1.lesigma.p.v = SMEE1.re.n.v;
//   SMEE1.rs.plug_p.pin[3].i + (-SMEE1.plug_sp.pin[3].i) = 0.0;
//   SMEE1.rs.plug_p.pin[2].i + (-SMEE1.plug_sp.pin[2].i) = 0.0;
//   SMEE1.rs.plug_p.pin[1].i + (-SMEE1.plug_sp.pin[1].i) = 0.0;
//   SMEE1.spacePhasorS.plug_n.pin[3].i + (-SMEE1.plug_sn.pin[3].i) = 0.0;
//   SMEE1.spacePhasorS.plug_n.pin[2].i + (-SMEE1.plug_sn.pin[2].i) = 0.0;
//   SMEE1.spacePhasorS.plug_n.pin[1].i + (-SMEE1.plug_sn.pin[1].i) = 0.0;
//   SMEE1.airGapR.flange_a.tau + SMEE1.inertiaRotor.flange_a.tau = 0.0;
//   SMEE1.airGapR.flange_a.phi = SMEE1.inertiaRotor.flange_a.phi;
//   SMEE1.lssigma.inductor[3].p.i + (-SMEE1.lssigma.plug_p.pin[3].i) = 0.0;
//   SMEE1.lssigma.inductor[2].p.i + (-SMEE1.lssigma.plug_p.pin[2].i) = 0.0;
//   SMEE1.lssigma.inductor[1].p.i + (-SMEE1.lssigma.plug_p.pin[1].i) = 0.0;
//   SMEE1.lssigma.inductor[3].n.i + (-SMEE1.lssigma.plug_n.pin[3].i) = 0.0;
//   SMEE1.lssigma.inductor[2].n.i + (-SMEE1.lssigma.plug_n.pin[2].i) = 0.0;
//   SMEE1.lssigma.inductor[1].n.i + (-SMEE1.lssigma.plug_n.pin[1].i) = 0.0;
//   SMEE1.rs.resistor[3].p.i + (-SMEE1.rs.plug_p.pin[3].i) = 0.0;
//   SMEE1.rs.resistor[2].p.i + (-SMEE1.rs.plug_p.pin[2].i) = 0.0;
//   SMEE1.rs.resistor[1].p.i + (-SMEE1.rs.plug_p.pin[1].i) = 0.0;
//   SMEE1.rs.resistor[3].n.i + (-SMEE1.rs.plug_n.pin[3].i) = 0.0;
//   SMEE1.rs.resistor[2].n.i + (-SMEE1.rs.plug_n.pin[2].i) = 0.0;
//   SMEE1.rs.resistor[1].n.i + (-SMEE1.rs.plug_n.pin[1].i) = 0.0;
//   SMEE1.spacePhasorS.gnd.p.i + (-SMEE1.spacePhasorS.ground.i) = 0.0;
//   SMEE1.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.SMEE_Gen;
// "
// ""
// endResult
