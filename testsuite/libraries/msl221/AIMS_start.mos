//name:         AIMS_start
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Electrical.Machines.Examples.AIMS_start);
getErrorString();
// Result:
// true
// "function Modelica.Math.atan2
// input Real u1;
// input Real u2;
// output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.sin
// input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
// output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.SIunits.Conversions.from_rpm
// input Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// output Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// algorithm
//   rs := 0.10471975511966 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm
// input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.AIMS_start
// constant Integer m = 3 "number of phases";
// parameter Real VNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "nominal RMS voltage per phase";
// parameter Real fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
// parameter Real tStart1(quantity = "Time", unit = "s") = 0.1 "1st start time";
// parameter Real Rstart(quantity = "Resistance", unit = "Ohm") = 0.16 "starting resistance";
// parameter Real tStart2(quantity = "Time", unit = "s") = 1.0 "2nd start time";
// parameter Real T_Load(quantity = "Torque", unit = "N.m") = 161.4 "nominal load torque";
// parameter Real rpmLoad(quantity = "AngularVelocity", unit = "rev/min") = 1440.45 "nominal load speed";
// parameter Real J_Load(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "load's moment of inertia";
// parameter Real AIMS1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.29 "rotor's moment of inertia";
// output Real AIMS1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = AIMS1.flange_a.phi "mechanical angle of rotor against stator";
// output Real AIMS1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(AIMS1.phi_mechanical) "mechanical angular velocity of rotor against stator";
// output Real AIMS1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(AIMS1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
// output Real AIMS1.tau_electrical(quantity = "Torque", unit = "N.m") = AIMS1.inertiaRotor.flange_a.tau "electromagnetic torque";
// output Real AIMS1.tau_shaft(quantity = "Torque", unit = "N.m") = -AIMS1.flange_a.tau "shaft torque";
// Real AIMS1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real AIMS1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = AIMS1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real AIMS1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real AIMS1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real AIMS1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = AIMS1.J_Rotor "Moment of inertia";
// parameter Integer AIMS1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real AIMS1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real AIMS1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real AIMS1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer AIMS1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real AIMS1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = AIMS1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real AIMS1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// parameter Real AIMS1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
// Real AIMS1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real AIMS1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// constant Real AIMS1.pi = 3.14159265358979;
// constant Integer AIMS1.m = 3 "number of phases";
// parameter Integer AIMS1.p(min = 1) = 2 "number of pole pairs (Integer)";
// output Real AIMS1.vs[1](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_sp.pin[1].v - AIMS1.plug_sn.pin[1].v "stator instantaneous voltages";
// output Real AIMS1.vs[2](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_sp.pin[2].v - AIMS1.plug_sn.pin[2].v "stator instantaneous voltages";
// output Real AIMS1.vs[3](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_sp.pin[3].v - AIMS1.plug_sn.pin[3].v "stator instantaneous voltages";
// output Real AIMS1.is[1](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_sp.pin[1].i "stator instantaneous currents";
// output Real AIMS1.is[2](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_sp.pin[2].i "stator instantaneous currents";
// output Real AIMS1.is[3](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_sp.pin[3].i "stator instantaneous currents";
// parameter Integer AIMS1.plug_sp.m(min = 1) = 3 "number of phases";
// Real AIMS1.plug_sp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_sp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_sp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.plug_sn.m(min = 1) = 3 "number of phases";
// Real AIMS1.plug_sn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_sn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_sn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_sn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// constant Real AIMS1.fNominal(quantity = "Frequency", unit = "Hz") = 50.0 "nominal frequency";
// parameter Real AIMS1.Rs(quantity = "Resistance", unit = "Ohm") = 0.03 "|Nominal resistances and inductances|warm stator resistance per phase";
// parameter Real AIMS1.Lssigma(quantity = "Inductance", unit = "H") = 0.000323964362549907 "|Nominal resistances and inductances|stator stray inductance per phase";
// parameter Real AIMS1.Lm(quantity = "Inductance", unit = "H") = 0.00922533222296381 "|Nominal resistances and inductances|main field inductance";
// parameter Real AIMS1.Lrsigma(quantity = "Inductance", unit = "H") = 0.000323964362549907 "|Nominal resistances and inductances|rotor stray inductance per phase";
// parameter Real AIMS1.Rr(quantity = "Resistance", unit = "Ohm") = 0.04 "|Nominal resistances and inductances|warm rotor resistance per phase";
// parameter Boolean AIMS1.useTurnsRatio = true "use TurnsRatio or calculate from locked-rotor voltage?";
// parameter Real AIMS1.TurnsRatio(min = 1e-60) = 1.0 "(ws*xis) / (wr*xir)";
// parameter Real AIMS1.VsNom(quantity = "ElectricPotential", unit = "V") = 100.0 "Nominal stator voltage per phase";
// parameter Real AIMS1.Vr_LR(quantity = "ElectricPotential", unit = "V") = 31415.9265358979 * AIMS1.Lm / sqrt(AIMS1.Rs ^ 2.0 + (314.159265358979 * (AIMS1.Lm + AIMS1.Lssigma)) ^ 2.0) "Locked-rotor voltage per phase";
// output Real AIMS1.i_0_s(quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMS1.spacePhasorS.zero.i "stator zero-sequence current";
// output Real AIMS1.idq_ss[1](quantity = "ElectricCurrent", unit = "A") = AIMS1.airGapS.i_ss[1] "stator space phasor current / stator fixed frame";
// output Real AIMS1.idq_ss[2](quantity = "ElectricCurrent", unit = "A") = AIMS1.airGapS.i_ss[2] "stator space phasor current / stator fixed frame";
// output Real AIMS1.idq_sr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMS1.airGapS.i_sr[1] "stator space phasor current / rotor fixed frame";
// output Real AIMS1.idq_sr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMS1.airGapS.i_sr[2] "stator space phasor current / rotor fixed frame";
// output Real AIMS1.idq_rs[1](quantity = "ElectricCurrent", unit = "A") = AIMS1.airGapS.i_rs[1] "rotor space phasor current / stator fixed frame";
// output Real AIMS1.idq_rs[2](quantity = "ElectricCurrent", unit = "A") = AIMS1.airGapS.i_rs[2] "rotor space phasor current / stator fixed frame";
// output Real AIMS1.idq_rr[1](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMS1.airGapS.i_rr[1] "rotor space phasor current / rotor fixed frame";
// output Real AIMS1.idq_rr[2](quantity = "ElectricCurrent", unit = "A", StateSelect = StateSelect.prefer) = AIMS1.airGapS.i_rr[2] "rotor space phasor current / rotor fixed frame";
// output Real AIMS1.i_0_r(quantity = "ElectricCurrent", unit = "A") = AIMS1.spacePhasorR.zero.i "rotor zero-sequence current";
// output Real AIMS1.vr[1](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_rp.pin[1].v - AIMS1.plug_rn.pin[1].v "rotor instantaneous voltages";
// output Real AIMS1.vr[2](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_rp.pin[2].v - AIMS1.plug_rn.pin[2].v "rotor instantaneous voltages";
// output Real AIMS1.vr[3](quantity = "ElectricPotential", unit = "V") = AIMS1.plug_rp.pin[3].v - AIMS1.plug_rn.pin[3].v "rotor instantaneous voltages";
// output Real AIMS1.ir[1](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_rp.pin[1].i "rotor instantaneous currents";
// output Real AIMS1.ir[2](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_rp.pin[2].i "rotor instantaneous currents";
// output Real AIMS1.ir[3](quantity = "ElectricCurrent", unit = "A") = AIMS1.plug_rp.pin[3].i "rotor instantaneous currents";
// parameter Integer AIMS1.rs.m(min = 1) = 3 "number of phases";
// Real AIMS1.rs.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rs.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rs.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rs.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.rs.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.rs.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer AIMS1.rs.plug_p.m(min = 1) = AIMS1.rs.m "number of phases";
// Real AIMS1.rs.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.rs.plug_n.m(min = 1) = AIMS1.rs.m "number of phases";
// Real AIMS1.rs.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rs.R[1](quantity = "Resistance", unit = "Ohm") = AIMS1.Rs "Resistance";
// parameter Real AIMS1.rs.R[2](quantity = "Resistance", unit = "Ohm") = AIMS1.Rs "Resistance";
// parameter Real AIMS1.rs.R[3](quantity = "Resistance", unit = "Ohm") = AIMS1.Rs "Resistance";
// Real AIMS1.rs.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rs.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rs.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rs.resistor[1].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rs.R[1] "Resistance";
// Real AIMS1.rs.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rs.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rs.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rs.resistor[2].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rs.R[2] "Resistance";
// Real AIMS1.rs.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rs.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rs.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rs.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rs.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rs.resistor[3].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rs.R[3] "Resistance";
// parameter Integer AIMS1.lssigma.m(min = 1) = 3 "number of phases";
// Real AIMS1.lssigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lssigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lssigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lssigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.lssigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.lssigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer AIMS1.lssigma.plug_p.m(min = 1) = AIMS1.lssigma.m "number of phases";
// Real AIMS1.lssigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.lssigma.plug_n.m(min = 1) = AIMS1.lssigma.m "number of phases";
// Real AIMS1.lssigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lssigma.L[1](quantity = "Inductance", unit = "H") = AIMS1.Lssigma "Inductance";
// parameter Real AIMS1.lssigma.L[2](quantity = "Inductance", unit = "H") = AIMS1.Lssigma "Inductance";
// parameter Real AIMS1.lssigma.L[3](quantity = "Inductance", unit = "H") = AIMS1.Lssigma "Inductance";
// Real AIMS1.lssigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lssigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lssigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lssigma.inductor[1].L(quantity = "Inductance", unit = "H") = AIMS1.lssigma.L[1] "Inductance";
// Real AIMS1.lssigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lssigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lssigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lssigma.inductor[2].L(quantity = "Inductance", unit = "H") = AIMS1.lssigma.L[2] "Inductance";
// Real AIMS1.lssigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lssigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lssigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lssigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lssigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lssigma.inductor[3].L(quantity = "Inductance", unit = "H") = AIMS1.lssigma.L[3] "Inductance";
// parameter Integer AIMS1.IdealTransformer1.m(min = 1) = 3 "number of phases";
// Real AIMS1.IdealTransformer1.v1[1](quantity = "ElectricPotential", unit = "V") "Voltage drops over the left port";
// Real AIMS1.IdealTransformer1.v1[2](quantity = "ElectricPotential", unit = "V") "Voltage drops over the left port";
// Real AIMS1.IdealTransformer1.v1[3](quantity = "ElectricPotential", unit = "V") "Voltage drops over the left port";
// Real AIMS1.IdealTransformer1.v2[1](quantity = "ElectricPotential", unit = "V") "Voltage drops over the right port";
// Real AIMS1.IdealTransformer1.v2[2](quantity = "ElectricPotential", unit = "V") "Voltage drops over the right port";
// Real AIMS1.IdealTransformer1.v2[3](quantity = "ElectricPotential", unit = "V") "Voltage drops over the right port";
// Real AIMS1.IdealTransformer1.i1[1](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the left port";
// Real AIMS1.IdealTransformer1.i1[2](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the left port";
// Real AIMS1.IdealTransformer1.i1[3](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the left port";
// Real AIMS1.IdealTransformer1.i2[1](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the right port";
// Real AIMS1.IdealTransformer1.i2[2](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the right port";
// Real AIMS1.IdealTransformer1.i2[3](quantity = "ElectricCurrent", unit = "A") "Current flowing into positive plug of the right port";
// parameter Integer AIMS1.IdealTransformer1.plug_p1.m(min = 1) = AIMS1.IdealTransformer1.m "number of phases";
// Real AIMS1.IdealTransformer1.plug_p1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_p1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_p1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.IdealTransformer1.plug_p2.m(min = 1) = AIMS1.IdealTransformer1.m "number of phases";
// Real AIMS1.IdealTransformer1.plug_p2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_p2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_p2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_p2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.IdealTransformer1.plug_n1.m(min = 1) = AIMS1.IdealTransformer1.m "number of phases";
// Real AIMS1.IdealTransformer1.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.IdealTransformer1.plug_n2.m(min = 1) = AIMS1.IdealTransformer1.m "number of phases";
// Real AIMS1.IdealTransformer1.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.IdealTransformer1.n[1] = 1.0 / AIMS1.internalTurnsRatio "Turns ratio";
// parameter Real AIMS1.IdealTransformer1.n[2] = 1.0 / AIMS1.internalTurnsRatio "Turns ratio";
// parameter Real AIMS1.IdealTransformer1.n[3] = 1.0 / AIMS1.internalTurnsRatio "Turns ratio";
// Real AIMS1.IdealTransformer1.idealTransformer[1].v1(quantity = "ElectricPotential", unit = "V") "Voltage drop over the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[1].v2(quantity = "ElectricPotential", unit = "V") "Voltage drop over the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[1].i1(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[1].i2(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[1].p1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].p1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].p2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].p2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.IdealTransformer1.idealTransformer[1].n = AIMS1.IdealTransformer1.n[1] "Turns ratio";
// Real AIMS1.IdealTransformer1.idealTransformer[2].v1(quantity = "ElectricPotential", unit = "V") "Voltage drop over the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[2].v2(quantity = "ElectricPotential", unit = "V") "Voltage drop over the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[2].i1(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[2].i2(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[2].p1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].p1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].p2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].p2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.IdealTransformer1.idealTransformer[2].n = AIMS1.IdealTransformer1.n[2] "Turns ratio";
// Real AIMS1.IdealTransformer1.idealTransformer[3].v1(quantity = "ElectricPotential", unit = "V") "Voltage drop over the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[3].v2(quantity = "ElectricPotential", unit = "V") "Voltage drop over the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[3].i1(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the left port";
// Real AIMS1.IdealTransformer1.idealTransformer[3].i2(quantity = "ElectricCurrent", unit = "A") "Current flowing from pos. to neg. pin of the right port";
// Real AIMS1.IdealTransformer1.idealTransformer[3].p1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].p1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].p2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].p2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.IdealTransformer1.idealTransformer[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.IdealTransformer1.idealTransformer[3].n = AIMS1.IdealTransformer1.n[3] "Turns ratio";
// parameter Integer AIMS1.Star1.m(min = 1) = 3 "number of phases";
// parameter Integer AIMS1.Star1.plug_p.m(min = 1) = AIMS1.Star1.m "number of phases";
// Real AIMS1.Star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.Star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.Star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.Star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.Star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.Star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.Star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.Star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.Ground1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.Ground1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.lrsigma.m(min = 1) = 3 "number of phases";
// Real AIMS1.lrsigma.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lrsigma.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lrsigma.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.lrsigma.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.lrsigma.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.lrsigma.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer AIMS1.lrsigma.plug_p.m(min = 1) = AIMS1.lrsigma.m "number of phases";
// Real AIMS1.lrsigma.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.lrsigma.plug_n.m(min = 1) = AIMS1.lrsigma.m "number of phases";
// Real AIMS1.lrsigma.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lrsigma.L[1](quantity = "Inductance", unit = "H") = AIMS1.Lrsigma "Inductance";
// parameter Real AIMS1.lrsigma.L[2](quantity = "Inductance", unit = "H") = AIMS1.Lrsigma "Inductance";
// parameter Real AIMS1.lrsigma.L[3](quantity = "Inductance", unit = "H") = AIMS1.Lrsigma "Inductance";
// Real AIMS1.lrsigma.inductor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lrsigma.inductor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lrsigma.inductor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.inductor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lrsigma.inductor[1].L(quantity = "Inductance", unit = "H") = AIMS1.lrsigma.L[1] "Inductance";
// Real AIMS1.lrsigma.inductor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lrsigma.inductor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lrsigma.inductor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.inductor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lrsigma.inductor[2].L(quantity = "Inductance", unit = "H") = AIMS1.lrsigma.L[2] "Inductance";
// Real AIMS1.lrsigma.inductor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.lrsigma.inductor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.lrsigma.inductor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.lrsigma.inductor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.lrsigma.inductor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.lrsigma.inductor[3].L(quantity = "Inductance", unit = "H") = AIMS1.lrsigma.L[3] "Inductance";
// parameter Integer AIMS1.rr.m(min = 1) = 3 "number of phases";
// Real AIMS1.rr.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rr.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rr.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real AIMS1.rr.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.rr.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real AIMS1.rr.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer AIMS1.rr.plug_p.m(min = 1) = AIMS1.rr.m "number of phases";
// Real AIMS1.rr.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.rr.plug_n.m(min = 1) = AIMS1.rr.m "number of phases";
// Real AIMS1.rr.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rr.R[1](quantity = "Resistance", unit = "Ohm") = AIMS1.Rr "Resistance";
// parameter Real AIMS1.rr.R[2](quantity = "Resistance", unit = "Ohm") = AIMS1.Rr "Resistance";
// parameter Real AIMS1.rr.R[3](quantity = "Resistance", unit = "Ohm") = AIMS1.Rr "Resistance";
// Real AIMS1.rr.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rr.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rr.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rr.resistor[1].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rr.R[1] "Resistance";
// Real AIMS1.rr.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rr.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rr.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rr.resistor[2].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rr.R[2] "Resistance";
// Real AIMS1.rr.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real AIMS1.rr.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real AIMS1.rr.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.rr.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.rr.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real AIMS1.rr.resistor[3].R(quantity = "Resistance", unit = "Ohm") = AIMS1.rr.R[3] "Resistance";
// parameter Integer AIMS1.plug_rp.m(min = 1) = 3 "number of phases";
// Real AIMS1.plug_rp.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rp.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_rp.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rp.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_rp.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rp.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.plug_rn.m(min = 1) = 3 "number of phases";
// Real AIMS1.plug_rn.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rn.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_rn.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rn.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.plug_rn.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.plug_rn.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// constant Integer AIMS1.spacePhasorS.m = 3 "number of phases";
// constant Real AIMS1.spacePhasorS.pi = 3.14159265358979;
// Real AIMS1.spacePhasorS.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorS.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorS.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorS.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// Real AIMS1.spacePhasorS.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// Real AIMS1.spacePhasorS.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// parameter Integer AIMS1.spacePhasorS.plug_p.m(min = 1) = 3 "number of phases";
// Real AIMS1.spacePhasorS.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.spacePhasorS.plug_n.m(min = 1) = 3 "number of phases";
// Real AIMS1.spacePhasorS.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorS.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorS.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.spacePhasorS.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.spacePhasorS.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A");
// Real AIMS1.spacePhasorS.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A");
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[1,1] = 0.666666666666667;
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[1,2] = -0.333333333333333;
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[1,3] = -0.333333333333334;
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[2,1] = 0.0;
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[2,2] = 0.577350269189626;
// protected parameter Real AIMS1.spacePhasorS.TransformationMatrix[2,3] = -0.577350269189626;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[1,1] = 1.0;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[1,2] = 0.0;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[2,1] = -0.5;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[2,2] = 0.866025403784439;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[3,1] = -0.5;
// protected parameter Real AIMS1.spacePhasorS.InverseTransformation[3,2] = -0.866025403784438;
// constant Integer AIMS1.airGapS.m = 3 "number of phases";
// parameter Integer AIMS1.airGapS.p(min = 1) = AIMS1.p "number of pole pairs";
// parameter Real AIMS1.airGapS.Lm(quantity = "Inductance", unit = "H") = AIMS1.Lm "main field inductance";
// output Real AIMS1.airGapS.tau_electrical(quantity = "Torque", unit = "N.m");
// Real AIMS1.airGapS.gamma(quantity = "Angle", unit = "rad", displayUnit = "deg") "Rotor displacement angle";
// Real AIMS1.airGapS.i_ss[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.i_ss[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.i_sr[1](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.i_sr[2](quantity = "ElectricCurrent", unit = "A") "Stator current space phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.i_rs[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.i_rs[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.i_rr[1](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.i_rr[2](quantity = "ElectricCurrent", unit = "A") "Rotor current space phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.i_ms[1](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.i_ms[2](quantity = "ElectricCurrent", unit = "A") "Magnetizing current space phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.psi_ms[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.psi_ms[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the stator fixed frame";
// Real AIMS1.airGapS.psi_mr[1](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.psi_mr[2](quantity = "MagneticFlux", unit = "Wb") "Magnetizing flux phasor with respect to the rotor fixed frame";
// Real AIMS1.airGapS.RotationMatrix[1,1] "matrix of rotation from rotor to stator";
// Real AIMS1.airGapS.RotationMatrix[1,2] "matrix of rotation from rotor to stator";
// Real AIMS1.airGapS.RotationMatrix[2,1] "matrix of rotation from rotor to stator";
// Real AIMS1.airGapS.RotationMatrix[2,2] "matrix of rotation from rotor to stator";
// Real AIMS1.airGapS.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.airGapS.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real AIMS1.airGapS.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real AIMS1.airGapS.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real AIMS1.airGapS.spacePhasor_s.v_[1](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.airGapS.spacePhasor_s.v_[2](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.airGapS.spacePhasor_s.i_[1](quantity = "ElectricCurrent", unit = "A");
// Real AIMS1.airGapS.spacePhasor_s.i_[2](quantity = "ElectricCurrent", unit = "A");
// Real AIMS1.airGapS.spacePhasor_r.v_[1](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.airGapS.spacePhasor_r.v_[2](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.airGapS.spacePhasor_r.i_[1](quantity = "ElectricCurrent", unit = "A");
// Real AIMS1.airGapS.spacePhasor_r.i_[2](quantity = "ElectricCurrent", unit = "A");
// protected parameter Real AIMS1.airGapS.L[1,1](quantity = "Inductance", unit = "H") = AIMS1.airGapS.Lm "inductance matrix";
// protected parameter Real AIMS1.airGapS.L[1,2](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
// protected parameter Real AIMS1.airGapS.L[2,1](quantity = "Inductance", unit = "H") = 0.0 "inductance matrix";
// protected parameter Real AIMS1.airGapS.L[2,2](quantity = "Inductance", unit = "H") = AIMS1.airGapS.Lm "inductance matrix";
// constant Integer AIMS1.spacePhasorR.m = 3 "number of phases";
// constant Real AIMS1.spacePhasorR.pi = 3.14159265358979;
// Real AIMS1.spacePhasorR.v[1](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorR.v[2](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorR.v[3](quantity = "ElectricPotential", unit = "V") "instantaneous phase voltages";
// Real AIMS1.spacePhasorR.i[1](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// Real AIMS1.spacePhasorR.i[2](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// Real AIMS1.spacePhasorR.i[3](quantity = "ElectricCurrent", unit = "A") "instantaneous phase currents";
// parameter Integer AIMS1.spacePhasorR.plug_p.m(min = 1) = 3 "number of phases";
// Real AIMS1.spacePhasorR.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer AIMS1.spacePhasorR.plug_n.m(min = 1) = 3 "number of phases";
// Real AIMS1.spacePhasorR.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real AIMS1.spacePhasorR.gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real AIMS1.spacePhasorR.spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.spacePhasorR.spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V");
// Real AIMS1.spacePhasorR.spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A");
// Real AIMS1.spacePhasorR.spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A");
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[1,1] = 0.666666666666667;
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[1,2] = -0.333333333333333;
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[1,3] = -0.333333333333334;
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[2,1] = 0.0;
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[2,2] = 0.577350269189626;
// protected parameter Real AIMS1.spacePhasorR.TransformationMatrix[2,3] = -0.577350269189626;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[1,1] = 1.0;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[1,2] = 0.0;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[2,1] = -0.5;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[2,2] = 0.866025403784439;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[3,1] = -0.5;
// protected parameter Real AIMS1.spacePhasorR.InverseTransformation[3,2] = -0.866025403784438;
// protected parameter Real AIMS1.internalTurnsRatio = if AIMS1.useTurnsRatio then AIMS1.TurnsRatio else 314.159265358979 * (AIMS1.VsNom * (AIMS1.Lm * 1.0 / sqrt(AIMS1.Rs ^ 2.0 + (314.159265358979 * (AIMS1.Lm + AIMS1.Lssigma)) ^ 2.0) / AIMS1.Vr_LR));
// constant Integer CurrentRMSsensor1.m(min = 1) = 3 "number of phases";
// parameter Integer CurrentRMSsensor1.plug_p.m(min = 1) = 3 "number of phases";
// Real CurrentRMSsensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer CurrentRMSsensor1.plug_n.m(min = 1) = 3 "number of phases";
// Real CurrentRMSsensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer CurrentRMSsensor1.CurrentSensor1.m(min = 1) = 3 "number of phases";
// parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_p.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer CurrentRMSsensor1.CurrentSensor1.plug_n.m(min = 1) = CurrentRMSsensor1.CurrentSensor1.m "number of phases";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// output Real CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i(quantity = "ElectricCurrent", unit = "A") "current in the branch from p to n as output signal";
// output Real CurrentRMSsensor1.CurrentSensor1.i[1] "current in the branch from p to n as output signal";
// output Real CurrentRMSsensor1.CurrentSensor1.i[2] "current in the branch from p to n as output signal";
// output Real CurrentRMSsensor1.CurrentSensor1.i[3] "current in the branch from p to n as output signal";
// parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nin = 3 "Number of inputs";
// parameter Integer CurrentRMSsensor1.ToSpacePhasor1.nout = 2 "Number of outputs";
// input Real CurrentRMSsensor1.ToSpacePhasor1.u[1] "Connector of Real input signals";
// input Real CurrentRMSsensor1.ToSpacePhasor1.u[2] "Connector of Real input signals";
// input Real CurrentRMSsensor1.ToSpacePhasor1.u[3] "Connector of Real input signals";
// output Real CurrentRMSsensor1.ToSpacePhasor1.y[1] "Connector of Real output signals";
// output Real CurrentRMSsensor1.ToSpacePhasor1.y[2] "Connector of Real output signals";
// constant Integer CurrentRMSsensor1.ToSpacePhasor1.m = 3 "number of phases";
// constant Real CurrentRMSsensor1.ToSpacePhasor1.pi = 3.14159265358979;
// output Real CurrentRMSsensor1.ToSpacePhasor1.zero;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] = 0.666666666666667;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] = -0.333333333333333;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] = -0.333333333333334;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] = 0.0;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] = 0.577350269189626;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] = -0.577350269189626;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,1] = 1.0;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[1,2] = 0.0;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,1] = -0.5;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[2,2] = 0.866025403784439;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,1] = -0.5;
// protected parameter Real CurrentRMSsensor1.ToSpacePhasor1.InverseTransformation[3,2] = -0.866025403784438;
// parameter Integer CurrentRMSsensor1.ToPolar1.n = 2 "Number of inputs (= number of outputs)";
// input Real CurrentRMSsensor1.ToPolar1.u[1] "Connector of Real input signals";
// input Real CurrentRMSsensor1.ToPolar1.u[2] "Connector of Real input signals";
// output Real CurrentRMSsensor1.ToPolar1.y[1] "Connector of Real output signals";
// output Real CurrentRMSsensor1.ToPolar1.y[2] "Connector of Real output signals";
// constant Real CurrentRMSsensor1.ToPolar1.small = 1e-60;
// parameter Real CurrentRMSsensor1.Gain1.k = 0.707106781186547 "Gain value multiplied with input signal";
// input Real CurrentRMSsensor1.Gain1.u "Input signal connector";
// output Real CurrentRMSsensor1.Gain1.y "Output signal connector";
// output Real CurrentRMSsensor1.I(quantity = "ElectricCurrent", unit = "A");
// parameter Integer SineVoltage1.m(min = 1) = 3 "number of phases";
// Real SineVoltage1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real SineVoltage1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real SineVoltage1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real SineVoltage1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real SineVoltage1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real SineVoltage1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer SineVoltage1.plug_p.m(min = 1) = SineVoltage1.m "number of phases";
// Real SineVoltage1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer SineVoltage1.plug_n.m(min = 1) = SineVoltage1.m "number of phases";
// Real SineVoltage1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real SineVoltage1.V[1](quantity = "ElectricPotential", unit = "V") = 0.816496580927726 * VNominal "Amplitudes of sine waves";
// parameter Real SineVoltage1.V[2](quantity = "ElectricPotential", unit = "V") = 0.816496580927726 * VNominal "Amplitudes of sine waves";
// parameter Real SineVoltage1.V[3](quantity = "ElectricPotential", unit = "V") = 0.816496580927726 * VNominal "Amplitudes of sine waves";
// parameter Real SineVoltage1.phase[1](quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phases of sine waves";
// parameter Real SineVoltage1.phase[2](quantity = "Angle", unit = "rad", displayUnit = "deg") = -6.28318530717959 / Real(SineVoltage1.m) "Phases of sine waves";
// parameter Real SineVoltage1.phase[3](quantity = "Angle", unit = "rad", displayUnit = "deg") = -12.5663706143592 / Real(SineVoltage1.m) "Phases of sine waves";
// parameter Real SineVoltage1.freqHz[1](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
// parameter Real SineVoltage1.freqHz[2](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
// parameter Real SineVoltage1.freqHz[3](quantity = "Frequency", unit = "Hz") = fNominal "Frequencies of sine waves";
// parameter Real SineVoltage1.offset[1](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
// parameter Real SineVoltage1.offset[2](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
// parameter Real SineVoltage1.offset[3](quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offsets";
// parameter Real SineVoltage1.startTime[1](quantity = "Time", unit = "s") = 0.0 "Time offsets";
// parameter Real SineVoltage1.startTime[2](quantity = "Time", unit = "s") = 0.0 "Time offsets";
// parameter Real SineVoltage1.startTime[3](quantity = "Time", unit = "s") = 0.0 "Time offsets";
// Real SineVoltage1.sineVoltage[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real SineVoltage1.sineVoltage[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real SineVoltage1.sineVoltage[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.sineVoltage[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real SineVoltage1.sineVoltage[1].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[1] "Voltage offset";
// parameter Real SineVoltage1.sineVoltage[1].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[1] "Time offset";
// output Real SineVoltage1.sineVoltage[1].signalSource.y "Connector of Real output signal";
// parameter Real SineVoltage1.sineVoltage[1].signalSource.amplitude = SineVoltage1.sineVoltage[1].V "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[1].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[1].freqHz "Frequency of sine wave";
// parameter Real SineVoltage1.sineVoltage[1].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[1].phase "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[1].signalSource.offset = SineVoltage1.sineVoltage[1].offset "Offset of output signal";
// parameter Real SineVoltage1.sineVoltage[1].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[1].startTime "Output = offset for time < startTime";
// protected constant Real SineVoltage1.sineVoltage[1].signalSource.pi = 3.14159265358979;
// parameter Real SineVoltage1.sineVoltage[1].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[1] "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[1].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[1] "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[1].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[1] "Frequency of sine wave";
// Real SineVoltage1.sineVoltage[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real SineVoltage1.sineVoltage[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real SineVoltage1.sineVoltage[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.sineVoltage[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real SineVoltage1.sineVoltage[2].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[2] "Voltage offset";
// parameter Real SineVoltage1.sineVoltage[2].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[2] "Time offset";
// output Real SineVoltage1.sineVoltage[2].signalSource.y "Connector of Real output signal";
// parameter Real SineVoltage1.sineVoltage[2].signalSource.amplitude = SineVoltage1.sineVoltage[2].V "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[2].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[2].freqHz "Frequency of sine wave";
// parameter Real SineVoltage1.sineVoltage[2].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[2].phase "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[2].signalSource.offset = SineVoltage1.sineVoltage[2].offset "Offset of output signal";
// parameter Real SineVoltage1.sineVoltage[2].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[2].startTime "Output = offset for time < startTime";
// protected constant Real SineVoltage1.sineVoltage[2].signalSource.pi = 3.14159265358979;
// parameter Real SineVoltage1.sineVoltage[2].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[2] "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[2].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[2] "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[2].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[2] "Frequency of sine wave";
// Real SineVoltage1.sineVoltage[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real SineVoltage1.sineVoltage[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real SineVoltage1.sineVoltage[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real SineVoltage1.sineVoltage[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real SineVoltage1.sineVoltage[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real SineVoltage1.sineVoltage[3].offset(quantity = "ElectricPotential", unit = "V") = SineVoltage1.offset[3] "Voltage offset";
// parameter Real SineVoltage1.sineVoltage[3].startTime(quantity = "Time", unit = "s") = SineVoltage1.startTime[3] "Time offset";
// output Real SineVoltage1.sineVoltage[3].signalSource.y "Connector of Real output signal";
// parameter Real SineVoltage1.sineVoltage[3].signalSource.amplitude = SineVoltage1.sineVoltage[3].V "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[3].signalSource.freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.sineVoltage[3].freqHz "Frequency of sine wave";
// parameter Real SineVoltage1.sineVoltage[3].signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.sineVoltage[3].phase "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[3].signalSource.offset = SineVoltage1.sineVoltage[3].offset "Offset of output signal";
// parameter Real SineVoltage1.sineVoltage[3].signalSource.startTime(quantity = "Time", unit = "s") = SineVoltage1.sineVoltage[3].startTime "Output = offset for time < startTime";
// protected constant Real SineVoltage1.sineVoltage[3].signalSource.pi = 3.14159265358979;
// parameter Real SineVoltage1.sineVoltage[3].V(quantity = "ElectricPotential", unit = "V") = SineVoltage1.V[3] "Amplitude of sine wave";
// parameter Real SineVoltage1.sineVoltage[3].phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = SineVoltage1.phase[3] "Phase of sine wave";
// parameter Real SineVoltage1.sineVoltage[3].freqHz(quantity = "Frequency", unit = "Hz") = SineVoltage1.freqHz[3] "Frequency of sine wave";
// parameter Integer Star1.m(min = 1) = 3 "number of phases";
// parameter Integer Star1.plug_p.m(min = 1) = Star1.m "number of phases";
// Real Star1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star1.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star1.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// output Boolean BooleanStep1[1].y "Connector of Boolean output signal";
// parameter Real BooleanStep1[1].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
// parameter Boolean BooleanStep1[1].startValue = false "Output before startTime";
// output Boolean BooleanStep1[2].y "Connector of Boolean output signal";
// parameter Real BooleanStep1[2].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
// parameter Boolean BooleanStep1[2].startValue = false "Output before startTime";
// output Boolean BooleanStep1[3].y "Connector of Boolean output signal";
// parameter Real BooleanStep1[3].startTime(quantity = "Time", unit = "s") = tStart1 "Time instant of step start";
// parameter Boolean BooleanStep1[3].startValue = false "Output before startTime";
// parameter Integer IdealCloser1.m(min = 1) = 3 "number of phases";
// Real IdealCloser1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real IdealCloser1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real IdealCloser1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real IdealCloser1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real IdealCloser1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real IdealCloser1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer IdealCloser1.plug_p.m(min = 1) = IdealCloser1.m "number of phases";
// Real IdealCloser1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer IdealCloser1.plug_n.m(min = 1) = IdealCloser1.m "number of phases";
// Real IdealCloser1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real IdealCloser1.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCloser1.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCloser1.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCloser1.Goff[1](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// parameter Real IdealCloser1.Goff[2](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// parameter Real IdealCloser1.Goff[3](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// Real IdealCloser1.idealClosingSwitch[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real IdealCloser1.idealClosingSwitch[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real IdealCloser1.idealClosingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.idealClosingSwitch[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real IdealCloser1.idealClosingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCloser1.Ron[1] "Closed switch resistance";
// parameter Real IdealCloser1.idealClosingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCloser1.Goff[1] "Opened switch conductance";
// input Boolean IdealCloser1.idealClosingSwitch[1].control "true => p--n connected, false => switch open";
// protected Real IdealCloser1.idealClosingSwitch[1].s "Auxiliary variable";
// protected parameter Real IdealCloser1.idealClosingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCloser1.idealClosingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// Real IdealCloser1.idealClosingSwitch[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real IdealCloser1.idealClosingSwitch[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real IdealCloser1.idealClosingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.idealClosingSwitch[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real IdealCloser1.idealClosingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCloser1.Ron[2] "Closed switch resistance";
// parameter Real IdealCloser1.idealClosingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCloser1.Goff[2] "Opened switch conductance";
// input Boolean IdealCloser1.idealClosingSwitch[2].control "true => p--n connected, false => switch open";
// protected Real IdealCloser1.idealClosingSwitch[2].s "Auxiliary variable";
// protected parameter Real IdealCloser1.idealClosingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCloser1.idealClosingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// Real IdealCloser1.idealClosingSwitch[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real IdealCloser1.idealClosingSwitch[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real IdealCloser1.idealClosingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCloser1.idealClosingSwitch[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCloser1.idealClosingSwitch[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real IdealCloser1.idealClosingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCloser1.Ron[3] "Closed switch resistance";
// parameter Real IdealCloser1.idealClosingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCloser1.Goff[3] "Opened switch conductance";
// input Boolean IdealCloser1.idealClosingSwitch[3].control "true => p--n connected, false => switch open";
// protected Real IdealCloser1.idealClosingSwitch[3].s "Auxiliary variable";
// protected parameter Real IdealCloser1.idealClosingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCloser1.idealClosingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// input Boolean IdealCloser1.control[1] "true => p--n connected, false => switch open";
// input Boolean IdealCloser1.control[2] "true => p--n connected, false => switch open";
// input Boolean IdealCloser1.control[3] "true => p--n connected, false => switch open";
// parameter Integer Star3.m(min = 1) = 3 "number of phases";
// parameter Integer Star3.plug_p.m(min = 1) = Star3.m "number of phases";
// Real Star3.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star3.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star3.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star3.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star3.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star3.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star3.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star3.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer IdealCommutingSwitch1.m(min = 1) = 3 "number of phases";
// parameter Real IdealCommutingSwitch1.Ron[1](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.Ron[2](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.Ron[3](quantity = "Resistance", unit = "Ohm", min = 0.0) = 1e-05 "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.Goff[1](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// parameter Real IdealCommutingSwitch1.Goff[2](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// parameter Real IdealCommutingSwitch1.Goff[3](quantity = "Conductance", unit = "S", min = 0.0) = 1e-05 "Opened switch conductance";
// parameter Integer IdealCommutingSwitch1.plug_p.m(min = 1) = IdealCommutingSwitch1.m "number of phases";
// Real IdealCommutingSwitch1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer IdealCommutingSwitch1.plug_n2.m(min = 1) = IdealCommutingSwitch1.m "number of phases";
// Real IdealCommutingSwitch1.plug_n2.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n2.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_n2.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n2.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_n2.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n2.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer IdealCommutingSwitch1.plug_n1.m(min = 1) = IdealCommutingSwitch1.m "number of phases";
// Real IdealCommutingSwitch1.plug_n1.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n1.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_n1.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n1.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.plug_n1.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.plug_n1.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[1].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCommutingSwitch1.Ron[1] "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[1].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCommutingSwitch1.Goff[1] "Opened switch conductance";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[1].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// input Boolean IdealCommutingSwitch1.idealCommutingSwitch[1].control "true => p--n2 connected, false => p--n1 connected";
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[1].s1;
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[1].s2 "Auxiliary variables";
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[1].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[1].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[2].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCommutingSwitch1.Ron[2] "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[2].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCommutingSwitch1.Goff[2] "Opened switch conductance";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[2].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// input Boolean IdealCommutingSwitch1.idealCommutingSwitch[2].control "true => p--n2 connected, false => p--n1 connected";
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[2].s1;
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[2].s2 "Auxiliary variables";
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[2].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[2].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[3].Ron(quantity = "Resistance", unit = "Ohm", min = 0.0) = IdealCommutingSwitch1.Ron[3] "Closed switch resistance";
// parameter Real IdealCommutingSwitch1.idealCommutingSwitch[3].Goff(quantity = "Conductance", unit = "S", min = 0.0) = IdealCommutingSwitch1.Goff[3] "Opened switch conductance";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].n2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].n2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].n1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real IdealCommutingSwitch1.idealCommutingSwitch[3].n1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// input Boolean IdealCommutingSwitch1.idealCommutingSwitch[3].control "true => p--n2 connected, false => p--n1 connected";
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[3].s1;
// protected Real IdealCommutingSwitch1.idealCommutingSwitch[3].s2 "Auxiliary variables";
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[3].unitVoltage(quantity = "ElectricPotential", unit = "V") = 1.0;
// protected parameter Real IdealCommutingSwitch1.idealCommutingSwitch[3].unitCurrent(quantity = "ElectricCurrent", unit = "A") = 1.0;
// input Boolean IdealCommutingSwitch1.control[1] "true => p--n2 connected, false => p--n1 connected";
// input Boolean IdealCommutingSwitch1.control[2] "true => p--n2 connected, false => p--n1 connected";
// input Boolean IdealCommutingSwitch1.control[3] "true => p--n2 connected, false => p--n1 connected";
// parameter Integer Resistor1.m(min = 1) = 3 "number of phases";
// Real Resistor1.v[1](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real Resistor1.v[2](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real Resistor1.v[3](quantity = "ElectricPotential", unit = "V") "Voltage drops between the two plugs";
// Real Resistor1.i[1](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real Resistor1.i[2](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// Real Resistor1.i[3](quantity = "ElectricCurrent", unit = "A") "Currents flowing into positive plugs";
// parameter Integer Resistor1.plug_p.m(min = 1) = Resistor1.m "number of phases";
// Real Resistor1.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer Resistor1.plug_n.m(min = 1) = Resistor1.m "number of phases";
// Real Resistor1.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Resistor1.R[1](quantity = "Resistance", unit = "Ohm") = Rstart "Resistance";
// parameter Real Resistor1.R[2](quantity = "Resistance", unit = "Ohm") = Rstart "Resistance";
// parameter Real Resistor1.R[3](quantity = "Resistance", unit = "Ohm") = Rstart "Resistance";
// Real Resistor1.resistor[1].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Resistor1.resistor[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Resistor1.resistor[1].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[1].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.resistor[1].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[1].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Resistor1.resistor[1].R(quantity = "Resistance", unit = "Ohm") = Resistor1.R[1] "Resistance";
// Real Resistor1.resistor[2].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Resistor1.resistor[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Resistor1.resistor[2].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[2].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.resistor[2].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[2].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Resistor1.resistor[2].R(quantity = "Resistance", unit = "Ohm") = Resistor1.R[2] "Resistance";
// Real Resistor1.resistor[3].v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Resistor1.resistor[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Resistor1.resistor[3].p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[3].p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Resistor1.resistor[3].n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Resistor1.resistor[3].n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Resistor1.resistor[3].R(quantity = "Resistance", unit = "Ohm") = Resistor1.R[3] "Resistance";
// parameter Integer Star4.m(min = 1) = 3 "number of phases";
// parameter Integer Star4.plug_p.m(min = 1) = Star4.m "number of phases";
// Real Star4.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star4.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star4.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star4.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star4.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star4.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Star4.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Star4.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// output Boolean BooleanStep2[1].y "Connector of Boolean output signal";
// parameter Real BooleanStep2[1].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
// parameter Boolean BooleanStep2[1].startValue = false "Output before startTime";
// output Boolean BooleanStep2[2].y "Connector of Boolean output signal";
// parameter Real BooleanStep2[2].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
// parameter Boolean BooleanStep2[2].startValue = false "Output before startTime";
// output Boolean BooleanStep2[3].y "Connector of Boolean output signal";
// parameter Real BooleanStep2[3].startTime(quantity = "Time", unit = "s") = tStart2 "Time instant of step start";
// parameter Boolean BooleanStep2[3].startValue = false "Output before startTime";
// Real LoadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = LoadInertia.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real LoadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real LoadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real LoadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real LoadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real LoadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = J_Load "Moment of inertia";
// parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real LoadInertia.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real LoadInertia.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real LoadInertia.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real LoadInertia.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = LoadInertia.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real LoadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// Real QuadraticLoadTorque1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(QuadraticLoadTorque1.flange.phi) "Angular velocity at flange";
// Real QuadraticLoadTorque1.tau(quantity = "Torque", unit = "N.m") = QuadraticLoadTorque1.flange.tau "accelerating torque acting at flange";
// Real QuadraticLoadTorque1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real QuadraticLoadTorque1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real QuadraticLoadTorque1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real QuadraticLoadTorque1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real QuadraticLoadTorque1.tau_nominal(quantity = "Torque", unit = "N.m") = -T_Load "nominal torque (if negative, torque is acting as load)";
// parameter Boolean QuadraticLoadTorque1.TorqueDirection = true "same direction of torque in both directions of rotation";
// parameter Real QuadraticLoadTorque1.w_nominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", min = 1e-15) = Modelica.SIunits.Conversions.from_rpm(rpmLoad) "nominal speed";
// constant Integer TerminalBox1.m = 3 "number of phases";
// parameter String TerminalBox1.StarDelta = "D";
// parameter Integer TerminalBox1.positiveMachinePlug.m(min = 1) = 3 "number of phases";
// Real TerminalBox1.positiveMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.positiveMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.positiveMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.positiveMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.positiveMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.positiveMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer TerminalBox1.negativeMachinePlug.m(min = 1) = 3 "number of phases";
// Real TerminalBox1.negativeMachinePlug.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.negativeMachinePlug.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.negativeMachinePlug.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.negativeMachinePlug.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.negativeMachinePlug.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.negativeMachinePlug.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer TerminalBox1.delta.m(min = 2) = 3 "number of phases";
// parameter Integer TerminalBox1.delta.plug_p.m(min = 1) = TerminalBox1.delta.m "number of phases";
// Real TerminalBox1.delta.plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.delta.plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.delta.plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer TerminalBox1.delta.plug_n.m(min = 1) = TerminalBox1.delta.m "number of phases";
// Real TerminalBox1.delta.plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.delta.plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.delta.plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.delta.plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Integer TerminalBox1.plugToGrid.m(min = 1) = 3 "number of phases";
// Real TerminalBox1.plugToGrid.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.plugToGrid.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.plugToGrid.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.plugToGrid.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real TerminalBox1.plugToGrid.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real TerminalBox1.plugToGrid.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Ground1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Ground1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Ground3.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Ground3.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   AIMS1.inertiaRotor.w = der(AIMS1.inertiaRotor.phi);
//   AIMS1.inertiaRotor.a = der(AIMS1.inertiaRotor.w);
//   AIMS1.inertiaRotor.J * AIMS1.inertiaRotor.a = AIMS1.inertiaRotor.flange_a.tau + AIMS1.inertiaRotor.flange_b.tau;
//   AIMS1.inertiaRotor.flange_a.phi = AIMS1.inertiaRotor.phi;
//   AIMS1.inertiaRotor.flange_b.phi = AIMS1.inertiaRotor.phi;
//   AIMS1.fixedHousing.flange_b.phi = AIMS1.fixedHousing.phi0;
//   AIMS1.rs.resistor[1].R * AIMS1.rs.resistor[1].i = AIMS1.rs.resistor[1].v;
//   AIMS1.rs.resistor[1].v = AIMS1.rs.resistor[1].p.v - AIMS1.rs.resistor[1].n.v;
//   0.0 = AIMS1.rs.resistor[1].p.i + AIMS1.rs.resistor[1].n.i;
//   AIMS1.rs.resistor[1].i = AIMS1.rs.resistor[1].p.i;
//   AIMS1.rs.resistor[2].R * AIMS1.rs.resistor[2].i = AIMS1.rs.resistor[2].v;
//   AIMS1.rs.resistor[2].v = AIMS1.rs.resistor[2].p.v - AIMS1.rs.resistor[2].n.v;
//   0.0 = AIMS1.rs.resistor[2].p.i + AIMS1.rs.resistor[2].n.i;
//   AIMS1.rs.resistor[2].i = AIMS1.rs.resistor[2].p.i;
//   AIMS1.rs.resistor[3].R * AIMS1.rs.resistor[3].i = AIMS1.rs.resistor[3].v;
//   AIMS1.rs.resistor[3].v = AIMS1.rs.resistor[3].p.v - AIMS1.rs.resistor[3].n.v;
//   0.0 = AIMS1.rs.resistor[3].p.i + AIMS1.rs.resistor[3].n.i;
//   AIMS1.rs.resistor[3].i = AIMS1.rs.resistor[3].p.i;
//   AIMS1.rs.v[1] = AIMS1.rs.plug_p.pin[1].v - AIMS1.rs.plug_n.pin[1].v;
//   AIMS1.rs.v[2] = AIMS1.rs.plug_p.pin[2].v - AIMS1.rs.plug_n.pin[2].v;
//   AIMS1.rs.v[3] = AIMS1.rs.plug_p.pin[3].v - AIMS1.rs.plug_n.pin[3].v;
//   AIMS1.rs.i[1] = AIMS1.rs.plug_p.pin[1].i;
//   AIMS1.rs.i[2] = AIMS1.rs.plug_p.pin[2].i;
//   AIMS1.rs.i[3] = AIMS1.rs.plug_p.pin[3].i;
//   AIMS1.rs.resistor[3].p.i + (-AIMS1.rs.plug_p.pin[3].i) = 0.0;
// AIMS1.rs.resistor[3].p.v = AIMS1.rs.plug_p.pin[3].v;
//   AIMS1.rs.resistor[2].p.i + (-AIMS1.rs.plug_p.pin[2].i) = 0.0;
// AIMS1.rs.resistor[2].p.v = AIMS1.rs.plug_p.pin[2].v;
//   AIMS1.rs.resistor[1].p.i + (-AIMS1.rs.plug_p.pin[1].i) = 0.0;
// AIMS1.rs.resistor[1].p.v = AIMS1.rs.plug_p.pin[1].v;
//   AIMS1.rs.resistor[3].n.i + (-AIMS1.rs.plug_n.pin[3].i) = 0.0;
// AIMS1.rs.resistor[3].n.v = AIMS1.rs.plug_n.pin[3].v;
//   AIMS1.rs.resistor[2].n.i + (-AIMS1.rs.plug_n.pin[2].i) = 0.0;
// AIMS1.rs.resistor[2].n.v = AIMS1.rs.plug_n.pin[2].v;
//   AIMS1.rs.resistor[1].n.i + (-AIMS1.rs.plug_n.pin[1].i) = 0.0;
// AIMS1.rs.resistor[1].n.v = AIMS1.rs.plug_n.pin[1].v;
//   AIMS1.lssigma.inductor[1].L * der(AIMS1.lssigma.inductor[1].i) = AIMS1.lssigma.inductor[1].v;
//   AIMS1.lssigma.inductor[1].v = AIMS1.lssigma.inductor[1].p.v - AIMS1.lssigma.inductor[1].n.v;
//   0.0 = AIMS1.lssigma.inductor[1].p.i + AIMS1.lssigma.inductor[1].n.i;
//   AIMS1.lssigma.inductor[1].i = AIMS1.lssigma.inductor[1].p.i;
//   AIMS1.lssigma.inductor[2].L * der(AIMS1.lssigma.inductor[2].i) = AIMS1.lssigma.inductor[2].v;
//   AIMS1.lssigma.inductor[2].v = AIMS1.lssigma.inductor[2].p.v - AIMS1.lssigma.inductor[2].n.v;
//   0.0 = AIMS1.lssigma.inductor[2].p.i + AIMS1.lssigma.inductor[2].n.i;
//   AIMS1.lssigma.inductor[2].i = AIMS1.lssigma.inductor[2].p.i;
//   AIMS1.lssigma.inductor[3].L * der(AIMS1.lssigma.inductor[3].i) = AIMS1.lssigma.inductor[3].v;
//   AIMS1.lssigma.inductor[3].v = AIMS1.lssigma.inductor[3].p.v - AIMS1.lssigma.inductor[3].n.v;
//   0.0 = AIMS1.lssigma.inductor[3].p.i + AIMS1.lssigma.inductor[3].n.i;
//   AIMS1.lssigma.inductor[3].i = AIMS1.lssigma.inductor[3].p.i;
//   AIMS1.lssigma.v[1] = AIMS1.lssigma.plug_p.pin[1].v - AIMS1.lssigma.plug_n.pin[1].v;
//   AIMS1.lssigma.v[2] = AIMS1.lssigma.plug_p.pin[2].v - AIMS1.lssigma.plug_n.pin[2].v;
//   AIMS1.lssigma.v[3] = AIMS1.lssigma.plug_p.pin[3].v - AIMS1.lssigma.plug_n.pin[3].v;
//   AIMS1.lssigma.i[1] = AIMS1.lssigma.plug_p.pin[1].i;
//   AIMS1.lssigma.i[2] = AIMS1.lssigma.plug_p.pin[2].i;
//   AIMS1.lssigma.i[3] = AIMS1.lssigma.plug_p.pin[3].i;
//   AIMS1.lssigma.inductor[3].p.i + (-AIMS1.lssigma.plug_p.pin[3].i) = 0.0;
// AIMS1.lssigma.inductor[3].p.v = AIMS1.lssigma.plug_p.pin[3].v;
//   AIMS1.lssigma.inductor[2].p.i + (-AIMS1.lssigma.plug_p.pin[2].i) = 0.0;
// AIMS1.lssigma.inductor[2].p.v = AIMS1.lssigma.plug_p.pin[2].v;
//   AIMS1.lssigma.inductor[1].p.i + (-AIMS1.lssigma.plug_p.pin[1].i) = 0.0;
// AIMS1.lssigma.inductor[1].p.v = AIMS1.lssigma.plug_p.pin[1].v;
//   AIMS1.lssigma.inductor[3].n.i + (-AIMS1.lssigma.plug_n.pin[3].i) = 0.0;
// AIMS1.lssigma.inductor[3].n.v = AIMS1.lssigma.plug_n.pin[3].v;
//   AIMS1.lssigma.inductor[2].n.i + (-AIMS1.lssigma.plug_n.pin[2].i) = 0.0;
// AIMS1.lssigma.inductor[2].n.v = AIMS1.lssigma.plug_n.pin[2].v;
//   AIMS1.lssigma.inductor[1].n.i + (-AIMS1.lssigma.plug_n.pin[1].i) = 0.0;
// AIMS1.lssigma.inductor[1].n.v = AIMS1.lssigma.plug_n.pin[1].v;
//   AIMS1.IdealTransformer1.idealTransformer[1].v1 = AIMS1.IdealTransformer1.idealTransformer[1].n * AIMS1.IdealTransformer1.idealTransformer[1].v2;
//   AIMS1.IdealTransformer1.idealTransformer[1].i2 = (-AIMS1.IdealTransformer1.idealTransformer[1].n) * AIMS1.IdealTransformer1.idealTransformer[1].i1;
//   AIMS1.IdealTransformer1.idealTransformer[1].v1 = AIMS1.IdealTransformer1.idealTransformer[1].p1.v - AIMS1.IdealTransformer1.idealTransformer[1].n1.v;
//   AIMS1.IdealTransformer1.idealTransformer[1].v2 = AIMS1.IdealTransformer1.idealTransformer[1].p2.v - AIMS1.IdealTransformer1.idealTransformer[1].n2.v;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[1].p1.i + AIMS1.IdealTransformer1.idealTransformer[1].n1.i;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[1].p2.i + AIMS1.IdealTransformer1.idealTransformer[1].n2.i;
//   AIMS1.IdealTransformer1.idealTransformer[1].i1 = AIMS1.IdealTransformer1.idealTransformer[1].p1.i;
//   AIMS1.IdealTransformer1.idealTransformer[1].i2 = AIMS1.IdealTransformer1.idealTransformer[1].p2.i;
//   AIMS1.IdealTransformer1.idealTransformer[2].v1 = AIMS1.IdealTransformer1.idealTransformer[2].n * AIMS1.IdealTransformer1.idealTransformer[2].v2;
//   AIMS1.IdealTransformer1.idealTransformer[2].i2 = (-AIMS1.IdealTransformer1.idealTransformer[2].n) * AIMS1.IdealTransformer1.idealTransformer[2].i1;
//   AIMS1.IdealTransformer1.idealTransformer[2].v1 = AIMS1.IdealTransformer1.idealTransformer[2].p1.v - AIMS1.IdealTransformer1.idealTransformer[2].n1.v;
//   AIMS1.IdealTransformer1.idealTransformer[2].v2 = AIMS1.IdealTransformer1.idealTransformer[2].p2.v - AIMS1.IdealTransformer1.idealTransformer[2].n2.v;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[2].p1.i + AIMS1.IdealTransformer1.idealTransformer[2].n1.i;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[2].p2.i + AIMS1.IdealTransformer1.idealTransformer[2].n2.i;
//   AIMS1.IdealTransformer1.idealTransformer[2].i1 = AIMS1.IdealTransformer1.idealTransformer[2].p1.i;
//   AIMS1.IdealTransformer1.idealTransformer[2].i2 = AIMS1.IdealTransformer1.idealTransformer[2].p2.i;
//   AIMS1.IdealTransformer1.idealTransformer[3].v1 = AIMS1.IdealTransformer1.idealTransformer[3].n * AIMS1.IdealTransformer1.idealTransformer[3].v2;
//   AIMS1.IdealTransformer1.idealTransformer[3].i2 = (-AIMS1.IdealTransformer1.idealTransformer[3].n) * AIMS1.IdealTransformer1.idealTransformer[3].i1;
//   AIMS1.IdealTransformer1.idealTransformer[3].v1 = AIMS1.IdealTransformer1.idealTransformer[3].p1.v - AIMS1.IdealTransformer1.idealTransformer[3].n1.v;
//   AIMS1.IdealTransformer1.idealTransformer[3].v2 = AIMS1.IdealTransformer1.idealTransformer[3].p2.v - AIMS1.IdealTransformer1.idealTransformer[3].n2.v;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[3].p1.i + AIMS1.IdealTransformer1.idealTransformer[3].n1.i;
//   0.0 = AIMS1.IdealTransformer1.idealTransformer[3].p2.i + AIMS1.IdealTransformer1.idealTransformer[3].n2.i;
//   AIMS1.IdealTransformer1.idealTransformer[3].i1 = AIMS1.IdealTransformer1.idealTransformer[3].p1.i;
//   AIMS1.IdealTransformer1.idealTransformer[3].i2 = AIMS1.IdealTransformer1.idealTransformer[3].p2.i;
//   AIMS1.IdealTransformer1.v1[1] = AIMS1.IdealTransformer1.plug_p1.pin[1].v - AIMS1.IdealTransformer1.plug_n1.pin[1].v;
//   AIMS1.IdealTransformer1.v1[2] = AIMS1.IdealTransformer1.plug_p1.pin[2].v - AIMS1.IdealTransformer1.plug_n1.pin[2].v;
//   AIMS1.IdealTransformer1.v1[3] = AIMS1.IdealTransformer1.plug_p1.pin[3].v - AIMS1.IdealTransformer1.plug_n1.pin[3].v;
//   AIMS1.IdealTransformer1.v2[1] = AIMS1.IdealTransformer1.plug_p2.pin[1].v - AIMS1.IdealTransformer1.plug_n2.pin[1].v;
//   AIMS1.IdealTransformer1.v2[2] = AIMS1.IdealTransformer1.plug_p2.pin[2].v - AIMS1.IdealTransformer1.plug_n2.pin[2].v;
//   AIMS1.IdealTransformer1.v2[3] = AIMS1.IdealTransformer1.plug_p2.pin[3].v - AIMS1.IdealTransformer1.plug_n2.pin[3].v;
//   AIMS1.IdealTransformer1.i1[1] = AIMS1.IdealTransformer1.plug_p1.pin[1].i;
//   AIMS1.IdealTransformer1.i1[2] = AIMS1.IdealTransformer1.plug_p1.pin[2].i;
//   AIMS1.IdealTransformer1.i1[3] = AIMS1.IdealTransformer1.plug_p1.pin[3].i;
//   AIMS1.IdealTransformer1.i2[1] = AIMS1.IdealTransformer1.plug_p2.pin[1].i;
//   AIMS1.IdealTransformer1.i2[2] = AIMS1.IdealTransformer1.plug_p2.pin[2].i;
//   AIMS1.IdealTransformer1.i2[3] = AIMS1.IdealTransformer1.plug_p2.pin[3].i;
//   (-AIMS1.IdealTransformer1.plug_p1.pin[3].i) + AIMS1.IdealTransformer1.idealTransformer[3].p1.i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[3].v = AIMS1.IdealTransformer1.idealTransformer[3].p1.v;
//   (-AIMS1.IdealTransformer1.plug_p1.pin[2].i) + AIMS1.IdealTransformer1.idealTransformer[2].p1.i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[2].v = AIMS1.IdealTransformer1.idealTransformer[2].p1.v;
//   (-AIMS1.IdealTransformer1.plug_p1.pin[1].i) + AIMS1.IdealTransformer1.idealTransformer[1].p1.i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[1].v = AIMS1.IdealTransformer1.idealTransformer[1].p1.v;
//   (-AIMS1.IdealTransformer1.plug_p2.pin[3].i) + AIMS1.IdealTransformer1.idealTransformer[3].p2.i = 0.0;
// AIMS1.IdealTransformer1.plug_p2.pin[3].v = AIMS1.IdealTransformer1.idealTransformer[3].p2.v;
//   (-AIMS1.IdealTransformer1.plug_p2.pin[2].i) + AIMS1.IdealTransformer1.idealTransformer[2].p2.i = 0.0;
// AIMS1.IdealTransformer1.plug_p2.pin[2].v = AIMS1.IdealTransformer1.idealTransformer[2].p2.v;
//   (-AIMS1.IdealTransformer1.plug_p2.pin[1].i) + AIMS1.IdealTransformer1.idealTransformer[1].p2.i = 0.0;
// AIMS1.IdealTransformer1.plug_p2.pin[1].v = AIMS1.IdealTransformer1.idealTransformer[1].p2.v;
//   (-AIMS1.IdealTransformer1.plug_n1.pin[3].i) + AIMS1.IdealTransformer1.idealTransformer[3].n1.i = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[3].v = AIMS1.IdealTransformer1.idealTransformer[3].n1.v;
//   (-AIMS1.IdealTransformer1.plug_n1.pin[2].i) + AIMS1.IdealTransformer1.idealTransformer[2].n1.i = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[2].v = AIMS1.IdealTransformer1.idealTransformer[2].n1.v;
//   (-AIMS1.IdealTransformer1.plug_n1.pin[1].i) + AIMS1.IdealTransformer1.idealTransformer[1].n1.i = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[1].v = AIMS1.IdealTransformer1.idealTransformer[1].n1.v;
//   (-AIMS1.IdealTransformer1.plug_n2.pin[3].i) + AIMS1.IdealTransformer1.idealTransformer[3].n2.i = 0.0;
// AIMS1.IdealTransformer1.plug_n2.pin[3].v = AIMS1.IdealTransformer1.idealTransformer[3].n2.v;
//   (-AIMS1.IdealTransformer1.plug_n2.pin[2].i) + AIMS1.IdealTransformer1.idealTransformer[2].n2.i = 0.0;
// AIMS1.IdealTransformer1.plug_n2.pin[2].v = AIMS1.IdealTransformer1.idealTransformer[2].n2.v;
//   (-AIMS1.IdealTransformer1.plug_n2.pin[1].i) + AIMS1.IdealTransformer1.idealTransformer[1].n2.i = 0.0;
// AIMS1.IdealTransformer1.plug_n2.pin[1].v = AIMS1.IdealTransformer1.idealTransformer[1].n2.v;
//   (-AIMS1.Star1.plug_p.pin[3].i) + ((-AIMS1.Star1.plug_p.pin[2].i) + ((-AIMS1.Star1.plug_p.pin[1].i) + (-AIMS1.Star1.pin_n.i))) = 0.0;
// AIMS1.Star1.plug_p.pin[3].v = AIMS1.Star1.plug_p.pin[2].v;
// AIMS1.Star1.plug_p.pin[2].v = AIMS1.Star1.plug_p.pin[1].v;
// AIMS1.Star1.plug_p.pin[1].v = AIMS1.Star1.pin_n.v;
//   AIMS1.Ground1.p.v = 0.0;
//   AIMS1.lrsigma.inductor[1].L * der(AIMS1.lrsigma.inductor[1].i) = AIMS1.lrsigma.inductor[1].v;
//   AIMS1.lrsigma.inductor[1].v = AIMS1.lrsigma.inductor[1].p.v - AIMS1.lrsigma.inductor[1].n.v;
//   0.0 = AIMS1.lrsigma.inductor[1].p.i + AIMS1.lrsigma.inductor[1].n.i;
//   AIMS1.lrsigma.inductor[1].i = AIMS1.lrsigma.inductor[1].p.i;
//   AIMS1.lrsigma.inductor[2].L * der(AIMS1.lrsigma.inductor[2].i) = AIMS1.lrsigma.inductor[2].v;
//   AIMS1.lrsigma.inductor[2].v = AIMS1.lrsigma.inductor[2].p.v - AIMS1.lrsigma.inductor[2].n.v;
//   0.0 = AIMS1.lrsigma.inductor[2].p.i + AIMS1.lrsigma.inductor[2].n.i;
//   AIMS1.lrsigma.inductor[2].i = AIMS1.lrsigma.inductor[2].p.i;
//   AIMS1.lrsigma.inductor[3].L * der(AIMS1.lrsigma.inductor[3].i) = AIMS1.lrsigma.inductor[3].v;
//   AIMS1.lrsigma.inductor[3].v = AIMS1.lrsigma.inductor[3].p.v - AIMS1.lrsigma.inductor[3].n.v;
//   0.0 = AIMS1.lrsigma.inductor[3].p.i + AIMS1.lrsigma.inductor[3].n.i;
//   AIMS1.lrsigma.inductor[3].i = AIMS1.lrsigma.inductor[3].p.i;
//   AIMS1.lrsigma.v[1] = AIMS1.lrsigma.plug_p.pin[1].v - AIMS1.lrsigma.plug_n.pin[1].v;
//   AIMS1.lrsigma.v[2] = AIMS1.lrsigma.plug_p.pin[2].v - AIMS1.lrsigma.plug_n.pin[2].v;
//   AIMS1.lrsigma.v[3] = AIMS1.lrsigma.plug_p.pin[3].v - AIMS1.lrsigma.plug_n.pin[3].v;
//   AIMS1.lrsigma.i[1] = AIMS1.lrsigma.plug_p.pin[1].i;
//   AIMS1.lrsigma.i[2] = AIMS1.lrsigma.plug_p.pin[2].i;
//   AIMS1.lrsigma.i[3] = AIMS1.lrsigma.plug_p.pin[3].i;
//   AIMS1.lrsigma.inductor[3].p.i + (-AIMS1.lrsigma.plug_p.pin[3].i) = 0.0;
// AIMS1.lrsigma.inductor[3].p.v = AIMS1.lrsigma.plug_p.pin[3].v;
//   AIMS1.lrsigma.inductor[2].p.i + (-AIMS1.lrsigma.plug_p.pin[2].i) = 0.0;
// AIMS1.lrsigma.inductor[2].p.v = AIMS1.lrsigma.plug_p.pin[2].v;
//   AIMS1.lrsigma.inductor[1].p.i + (-AIMS1.lrsigma.plug_p.pin[1].i) = 0.0;
// AIMS1.lrsigma.inductor[1].p.v = AIMS1.lrsigma.plug_p.pin[1].v;
//   AIMS1.lrsigma.inductor[3].n.i + (-AIMS1.lrsigma.plug_n.pin[3].i) = 0.0;
// AIMS1.lrsigma.inductor[3].n.v = AIMS1.lrsigma.plug_n.pin[3].v;
//   AIMS1.lrsigma.inductor[2].n.i + (-AIMS1.lrsigma.plug_n.pin[2].i) = 0.0;
// AIMS1.lrsigma.inductor[2].n.v = AIMS1.lrsigma.plug_n.pin[2].v;
//   AIMS1.lrsigma.inductor[1].n.i + (-AIMS1.lrsigma.plug_n.pin[1].i) = 0.0;
// AIMS1.lrsigma.inductor[1].n.v = AIMS1.lrsigma.plug_n.pin[1].v;
//   AIMS1.rr.resistor[1].R * AIMS1.rr.resistor[1].i = AIMS1.rr.resistor[1].v;
//   AIMS1.rr.resistor[1].v = AIMS1.rr.resistor[1].p.v - AIMS1.rr.resistor[1].n.v;
//   0.0 = AIMS1.rr.resistor[1].p.i + AIMS1.rr.resistor[1].n.i;
//   AIMS1.rr.resistor[1].i = AIMS1.rr.resistor[1].p.i;
//   AIMS1.rr.resistor[2].R * AIMS1.rr.resistor[2].i = AIMS1.rr.resistor[2].v;
//   AIMS1.rr.resistor[2].v = AIMS1.rr.resistor[2].p.v - AIMS1.rr.resistor[2].n.v;
//   0.0 = AIMS1.rr.resistor[2].p.i + AIMS1.rr.resistor[2].n.i;
//   AIMS1.rr.resistor[2].i = AIMS1.rr.resistor[2].p.i;
//   AIMS1.rr.resistor[3].R * AIMS1.rr.resistor[3].i = AIMS1.rr.resistor[3].v;
//   AIMS1.rr.resistor[3].v = AIMS1.rr.resistor[3].p.v - AIMS1.rr.resistor[3].n.v;
//   0.0 = AIMS1.rr.resistor[3].p.i + AIMS1.rr.resistor[3].n.i;
//   AIMS1.rr.resistor[3].i = AIMS1.rr.resistor[3].p.i;
//   AIMS1.rr.v[1] = AIMS1.rr.plug_p.pin[1].v - AIMS1.rr.plug_n.pin[1].v;
//   AIMS1.rr.v[2] = AIMS1.rr.plug_p.pin[2].v - AIMS1.rr.plug_n.pin[2].v;
//   AIMS1.rr.v[3] = AIMS1.rr.plug_p.pin[3].v - AIMS1.rr.plug_n.pin[3].v;
//   AIMS1.rr.i[1] = AIMS1.rr.plug_p.pin[1].i;
//   AIMS1.rr.i[2] = AIMS1.rr.plug_p.pin[2].i;
//   AIMS1.rr.i[3] = AIMS1.rr.plug_p.pin[3].i;
//   AIMS1.rr.resistor[3].p.i + (-AIMS1.rr.plug_p.pin[3].i) = 0.0;
// AIMS1.rr.resistor[3].p.v = AIMS1.rr.plug_p.pin[3].v;
//   AIMS1.rr.resistor[2].p.i + (-AIMS1.rr.plug_p.pin[2].i) = 0.0;
// AIMS1.rr.resistor[2].p.v = AIMS1.rr.plug_p.pin[2].v;
//   AIMS1.rr.resistor[1].p.i + (-AIMS1.rr.plug_p.pin[1].i) = 0.0;
// AIMS1.rr.resistor[1].p.v = AIMS1.rr.plug_p.pin[1].v;
//   AIMS1.rr.resistor[3].n.i + (-AIMS1.rr.plug_n.pin[3].i) = 0.0;
// AIMS1.rr.resistor[3].n.v = AIMS1.rr.plug_n.pin[3].v;
//   AIMS1.rr.resistor[2].n.i + (-AIMS1.rr.plug_n.pin[2].i) = 0.0;
// AIMS1.rr.resistor[2].n.v = AIMS1.rr.plug_n.pin[2].v;
//   AIMS1.rr.resistor[1].n.i + (-AIMS1.rr.plug_n.pin[1].i) = 0.0;
// AIMS1.rr.resistor[1].n.v = AIMS1.rr.plug_n.pin[1].v;
//   AIMS1.spacePhasorS.gnd.p.v = 0.0;
//   AIMS1.spacePhasorS.v[1] = AIMS1.spacePhasorS.plug_p.pin[1].v - AIMS1.spacePhasorS.plug_n.pin[1].v;
//   AIMS1.spacePhasorS.v[2] = AIMS1.spacePhasorS.plug_p.pin[2].v - AIMS1.spacePhasorS.plug_n.pin[2].v;
//   AIMS1.spacePhasorS.v[3] = AIMS1.spacePhasorS.plug_p.pin[3].v - AIMS1.spacePhasorS.plug_n.pin[3].v;
//   AIMS1.spacePhasorS.i[1] = AIMS1.spacePhasorS.plug_p.pin[1].i;
//   AIMS1.spacePhasorS.i[2] = AIMS1.spacePhasorS.plug_p.pin[2].i;
//   AIMS1.spacePhasorS.i[3] = AIMS1.spacePhasorS.plug_p.pin[3].i;
//   AIMS1.spacePhasorS.i[1] = -AIMS1.spacePhasorS.plug_n.pin[1].i;
//   AIMS1.spacePhasorS.i[2] = -AIMS1.spacePhasorS.plug_n.pin[2].i;
//   AIMS1.spacePhasorS.i[3] = -AIMS1.spacePhasorS.plug_n.pin[3].i;
//   AIMS1.spacePhasorS.zero.v = 0.333333333333333 * (AIMS1.spacePhasorS.v[1] + (AIMS1.spacePhasorS.v[2] + AIMS1.spacePhasorS.v[3]));
//   AIMS1.spacePhasorS.spacePhasor.v_[1] = AIMS1.spacePhasorS.TransformationMatrix[1,1] * AIMS1.spacePhasorS.v[1] + (AIMS1.spacePhasorS.TransformationMatrix[1,2] * AIMS1.spacePhasorS.v[2] + AIMS1.spacePhasorS.TransformationMatrix[1,3] * AIMS1.spacePhasorS.v[3]);
//   AIMS1.spacePhasorS.spacePhasor.v_[2] = AIMS1.spacePhasorS.TransformationMatrix[2,1] * AIMS1.spacePhasorS.v[1] + (AIMS1.spacePhasorS.TransformationMatrix[2,2] * AIMS1.spacePhasorS.v[2] + AIMS1.spacePhasorS.TransformationMatrix[2,3] * AIMS1.spacePhasorS.v[3]);
//   -AIMS1.spacePhasorS.zero.i = 0.333333333333333 * (AIMS1.spacePhasorS.i[1] + (AIMS1.spacePhasorS.i[2] + AIMS1.spacePhasorS.i[3]));
//   -AIMS1.spacePhasorS.spacePhasor.i_[1] = AIMS1.spacePhasorS.TransformationMatrix[1,1] * AIMS1.spacePhasorS.i[1] + (AIMS1.spacePhasorS.TransformationMatrix[1,2] * AIMS1.spacePhasorS.i[2] + AIMS1.spacePhasorS.TransformationMatrix[1,3] * AIMS1.spacePhasorS.i[3]);
//   -AIMS1.spacePhasorS.spacePhasor.i_[2] = AIMS1.spacePhasorS.TransformationMatrix[2,1] * AIMS1.spacePhasorS.i[1] + (AIMS1.spacePhasorS.TransformationMatrix[2,2] * AIMS1.spacePhasorS.i[2] + AIMS1.spacePhasorS.TransformationMatrix[2,3] * AIMS1.spacePhasorS.i[3]);
//   AIMS1.spacePhasorS.gnd.p.i + (-AIMS1.spacePhasorS.ground.i) = 0.0;
// AIMS1.spacePhasorS.gnd.p.v = AIMS1.spacePhasorS.ground.v;
//   AIMS1.airGapS.gamma = Real(AIMS1.airGapS.p) * (AIMS1.airGapS.flange_a.phi - AIMS1.airGapS.support.phi);
//   AIMS1.airGapS.RotationMatrix[1,1] = cos(AIMS1.airGapS.gamma);
//   AIMS1.airGapS.RotationMatrix[1,2] = -sin(AIMS1.airGapS.gamma);
//   AIMS1.airGapS.RotationMatrix[2,1] = sin(AIMS1.airGapS.gamma);
//   AIMS1.airGapS.RotationMatrix[2,2] = cos(AIMS1.airGapS.gamma);
//   AIMS1.airGapS.i_ss[1] = AIMS1.airGapS.spacePhasor_s.i_[1];
//   AIMS1.airGapS.i_ss[2] = AIMS1.airGapS.spacePhasor_s.i_[2];
//   AIMS1.airGapS.i_ss[1] = AIMS1.airGapS.RotationMatrix[1,1] * AIMS1.airGapS.i_sr[1] + AIMS1.airGapS.RotationMatrix[1,2] * AIMS1.airGapS.i_sr[2];
//   AIMS1.airGapS.i_ss[2] = AIMS1.airGapS.RotationMatrix[2,1] * AIMS1.airGapS.i_sr[1] + AIMS1.airGapS.RotationMatrix[2,2] * AIMS1.airGapS.i_sr[2];
//   AIMS1.airGapS.i_rr[1] = AIMS1.airGapS.spacePhasor_r.i_[1];
//   AIMS1.airGapS.i_rr[2] = AIMS1.airGapS.spacePhasor_r.i_[2];
//   AIMS1.airGapS.i_rs[1] = AIMS1.airGapS.RotationMatrix[1,1] * AIMS1.airGapS.i_rr[1] + AIMS1.airGapS.RotationMatrix[1,2] * AIMS1.airGapS.i_rr[2];
//   AIMS1.airGapS.i_rs[2] = AIMS1.airGapS.RotationMatrix[2,1] * AIMS1.airGapS.i_rr[1] + AIMS1.airGapS.RotationMatrix[2,2] * AIMS1.airGapS.i_rr[2];
//   AIMS1.airGapS.i_ms[1] = AIMS1.airGapS.i_ss[1] + AIMS1.airGapS.i_rs[1];
//   AIMS1.airGapS.i_ms[2] = AIMS1.airGapS.i_ss[2] + AIMS1.airGapS.i_rs[2];
//   AIMS1.airGapS.psi_ms[1] = AIMS1.airGapS.L[1,1] * AIMS1.airGapS.i_ms[1] + AIMS1.airGapS.L[1,2] * AIMS1.airGapS.i_ms[2];
//   AIMS1.airGapS.psi_ms[2] = AIMS1.airGapS.L[2,1] * AIMS1.airGapS.i_ms[1] + AIMS1.airGapS.L[2,2] * AIMS1.airGapS.i_ms[2];
//   AIMS1.airGapS.psi_mr[1] = AIMS1.airGapS.RotationMatrix[1,1] * AIMS1.airGapS.psi_ms[1] + AIMS1.airGapS.RotationMatrix[2,1] * AIMS1.airGapS.psi_ms[2];
//   AIMS1.airGapS.psi_mr[2] = AIMS1.airGapS.RotationMatrix[1,2] * AIMS1.airGapS.psi_ms[1] + AIMS1.airGapS.RotationMatrix[2,2] * AIMS1.airGapS.psi_ms[2];
//   AIMS1.airGapS.spacePhasor_s.v_[1] = der(AIMS1.airGapS.psi_ms[1]);
//   AIMS1.airGapS.spacePhasor_s.v_[2] = der(AIMS1.airGapS.psi_ms[2]);
//   AIMS1.airGapS.spacePhasor_r.v_[1] = der(AIMS1.airGapS.psi_mr[1]);
//   AIMS1.airGapS.spacePhasor_r.v_[2] = der(AIMS1.airGapS.psi_mr[2]);
//   AIMS1.airGapS.tau_electrical = 1.5 * (Real(AIMS1.airGapS.p) * (AIMS1.airGapS.spacePhasor_s.i_[2] * AIMS1.airGapS.psi_ms[1] - AIMS1.airGapS.spacePhasor_s.i_[1] * AIMS1.airGapS.psi_ms[2]));
//   AIMS1.airGapS.flange_a.tau = -AIMS1.airGapS.tau_electrical;
//   AIMS1.airGapS.support.tau = AIMS1.airGapS.tau_electrical;
//   AIMS1.spacePhasorR.gnd.p.v = 0.0;
//   AIMS1.spacePhasorR.v[1] = AIMS1.spacePhasorR.plug_p.pin[1].v - AIMS1.spacePhasorR.plug_n.pin[1].v;
//   AIMS1.spacePhasorR.v[2] = AIMS1.spacePhasorR.plug_p.pin[2].v - AIMS1.spacePhasorR.plug_n.pin[2].v;
//   AIMS1.spacePhasorR.v[3] = AIMS1.spacePhasorR.plug_p.pin[3].v - AIMS1.spacePhasorR.plug_n.pin[3].v;
//   AIMS1.spacePhasorR.i[1] = AIMS1.spacePhasorR.plug_p.pin[1].i;
//   AIMS1.spacePhasorR.i[2] = AIMS1.spacePhasorR.plug_p.pin[2].i;
//   AIMS1.spacePhasorR.i[3] = AIMS1.spacePhasorR.plug_p.pin[3].i;
//   AIMS1.spacePhasorR.i[1] = -AIMS1.spacePhasorR.plug_n.pin[1].i;
//   AIMS1.spacePhasorR.i[2] = -AIMS1.spacePhasorR.plug_n.pin[2].i;
//   AIMS1.spacePhasorR.i[3] = -AIMS1.spacePhasorR.plug_n.pin[3].i;
//   AIMS1.spacePhasorR.zero.v = 0.333333333333333 * (AIMS1.spacePhasorR.v[1] + (AIMS1.spacePhasorR.v[2] + AIMS1.spacePhasorR.v[3]));
//   AIMS1.spacePhasorR.spacePhasor.v_[1] = AIMS1.spacePhasorR.TransformationMatrix[1,1] * AIMS1.spacePhasorR.v[1] + (AIMS1.spacePhasorR.TransformationMatrix[1,2] * AIMS1.spacePhasorR.v[2] + AIMS1.spacePhasorR.TransformationMatrix[1,3] * AIMS1.spacePhasorR.v[3]);
//   AIMS1.spacePhasorR.spacePhasor.v_[2] = AIMS1.spacePhasorR.TransformationMatrix[2,1] * AIMS1.spacePhasorR.v[1] + (AIMS1.spacePhasorR.TransformationMatrix[2,2] * AIMS1.spacePhasorR.v[2] + AIMS1.spacePhasorR.TransformationMatrix[2,3] * AIMS1.spacePhasorR.v[3]);
//   -AIMS1.spacePhasorR.zero.i = 0.333333333333333 * (AIMS1.spacePhasorR.i[1] + (AIMS1.spacePhasorR.i[2] + AIMS1.spacePhasorR.i[3]));
//   -AIMS1.spacePhasorR.spacePhasor.i_[1] = AIMS1.spacePhasorR.TransformationMatrix[1,1] * AIMS1.spacePhasorR.i[1] + (AIMS1.spacePhasorR.TransformationMatrix[1,2] * AIMS1.spacePhasorR.i[2] + AIMS1.spacePhasorR.TransformationMatrix[1,3] * AIMS1.spacePhasorR.i[3]);
//   -AIMS1.spacePhasorR.spacePhasor.i_[2] = AIMS1.spacePhasorR.TransformationMatrix[2,1] * AIMS1.spacePhasorR.i[1] + (AIMS1.spacePhasorR.TransformationMatrix[2,2] * AIMS1.spacePhasorR.i[2] + AIMS1.spacePhasorR.TransformationMatrix[2,3] * AIMS1.spacePhasorR.i[3]);
//   AIMS1.spacePhasorR.gnd.p.i + (-AIMS1.spacePhasorR.ground.i) = 0.0;
// AIMS1.spacePhasorR.gnd.p.v = AIMS1.spacePhasorR.ground.v;
// assert(AIMS1.spacePhasorR.plug_p.m == AIMS1.IdealTransformer1.plug_p2.m,"automatically generated from connect");
// assert(AIMS1.spacePhasorR.plug_n.m == AIMS1.IdealTransformer1.plug_n2.m,"automatically generated from connect");
// assert(AIMS1.IdealTransformer1.plug_p1.m == AIMS1.lrsigma.plug_n.m,"automatically generated from connect");
// assert(AIMS1.Star1.plug_p.m == AIMS1.IdealTransformer1.plug_n2.m,"automatically generated from connect");
// assert(AIMS1.IdealTransformer1.plug_n1.m == AIMS1.plug_rn.m,"automatically generated from connect");
// assert(AIMS1.lssigma.plug_n.m == AIMS1.spacePhasorS.plug_p.m,"automatically generated from connect");
// assert(AIMS1.plug_sn.m == AIMS1.spacePhasorS.plug_n.m,"automatically generated from connect");
// assert(AIMS1.rs.plug_p.m == AIMS1.plug_sp.m,"automatically generated from connect");
// assert(AIMS1.rr.plug_p.m == AIMS1.plug_rp.m,"automatically generated from connect");
// assert(AIMS1.rr.plug_n.m == AIMS1.lrsigma.plug_p.m,"automatically generated from connect");
// assert(AIMS1.rs.plug_n.m == AIMS1.lssigma.plug_p.m,"automatically generated from connect");
//   AIMS1.inertiaRotor.flange_b.tau + (-AIMS1.flange_a.tau) = 0.0;
// AIMS1.inertiaRotor.flange_b.phi = AIMS1.flange_a.phi;
//   AIMS1.airGapS.support.tau + ((-AIMS1.internalSupport.tau) + AIMS1.fixedHousing.flange_b.tau) = 0.0;
// AIMS1.airGapS.support.phi = AIMS1.internalSupport.phi;
// AIMS1.internalSupport.phi = AIMS1.fixedHousing.flange_b.phi;
//   AIMS1.airGapS.spacePhasor_r.i_[1] + AIMS1.spacePhasorR.spacePhasor.i_[1] = 0.0;
//   AIMS1.airGapS.spacePhasor_r.i_[2] + AIMS1.spacePhasorR.spacePhasor.i_[2] = 0.0;
// AIMS1.airGapS.spacePhasor_r.v_[1] = AIMS1.spacePhasorR.spacePhasor.v_[1];
// AIMS1.airGapS.spacePhasor_r.v_[2] = AIMS1.spacePhasorR.spacePhasor.v_[2];
//   AIMS1.spacePhasorR.ground.i + AIMS1.spacePhasorR.zero.i = 0.0;
// AIMS1.spacePhasorR.ground.v = AIMS1.spacePhasorR.zero.v;
//   AIMS1.rs.plug_n.pin[3].i + AIMS1.lssigma.plug_p.pin[3].i = 0.0;
// AIMS1.rs.plug_n.pin[3].v = AIMS1.lssigma.plug_p.pin[3].v;
//   AIMS1.rs.plug_n.pin[2].i + AIMS1.lssigma.plug_p.pin[2].i = 0.0;
// AIMS1.rs.plug_n.pin[2].v = AIMS1.lssigma.plug_p.pin[2].v;
//   AIMS1.rs.plug_n.pin[1].i + AIMS1.lssigma.plug_p.pin[1].i = 0.0;
// AIMS1.rs.plug_n.pin[1].v = AIMS1.lssigma.plug_p.pin[1].v;
//   AIMS1.rr.plug_n.pin[3].i + AIMS1.lrsigma.plug_p.pin[3].i = 0.0;
// AIMS1.rr.plug_n.pin[3].v = AIMS1.lrsigma.plug_p.pin[3].v;
//   AIMS1.rr.plug_n.pin[2].i + AIMS1.lrsigma.plug_p.pin[2].i = 0.0;
// AIMS1.rr.plug_n.pin[2].v = AIMS1.lrsigma.plug_p.pin[2].v;
//   AIMS1.rr.plug_n.pin[1].i + AIMS1.lrsigma.plug_p.pin[1].i = 0.0;
// AIMS1.rr.plug_n.pin[1].v = AIMS1.lrsigma.plug_p.pin[1].v;
//   AIMS1.Star1.pin_n.i + AIMS1.Ground1.p.i = 0.0;
// AIMS1.Star1.pin_n.v = AIMS1.Ground1.p.v;
//   AIMS1.rr.plug_p.pin[3].i + (-AIMS1.plug_rp.pin[3].i) = 0.0;
// AIMS1.rr.plug_p.pin[3].v = AIMS1.plug_rp.pin[3].v;
//   AIMS1.rr.plug_p.pin[2].i + (-AIMS1.plug_rp.pin[2].i) = 0.0;
// AIMS1.rr.plug_p.pin[2].v = AIMS1.plug_rp.pin[2].v;
//   AIMS1.rr.plug_p.pin[1].i + (-AIMS1.plug_rp.pin[1].i) = 0.0;
// AIMS1.rr.plug_p.pin[1].v = AIMS1.plug_rp.pin[1].v;
//   AIMS1.rs.plug_p.pin[3].i + (-AIMS1.plug_sp.pin[3].i) = 0.0;
// AIMS1.rs.plug_p.pin[3].v = AIMS1.plug_sp.pin[3].v;
//   AIMS1.rs.plug_p.pin[2].i + (-AIMS1.plug_sp.pin[2].i) = 0.0;
// AIMS1.rs.plug_p.pin[2].v = AIMS1.plug_sp.pin[2].v;
//   AIMS1.rs.plug_p.pin[1].i + (-AIMS1.plug_sp.pin[1].i) = 0.0;
// AIMS1.rs.plug_p.pin[1].v = AIMS1.plug_sp.pin[1].v;
//   AIMS1.airGapS.flange_a.tau + AIMS1.inertiaRotor.flange_a.tau = 0.0;
// AIMS1.airGapS.flange_a.phi = AIMS1.inertiaRotor.flange_a.phi;
//   (-AIMS1.plug_sn.pin[3].i) + AIMS1.spacePhasorS.plug_n.pin[3].i = 0.0;
// AIMS1.plug_sn.pin[3].v = AIMS1.spacePhasorS.plug_n.pin[3].v;
//   (-AIMS1.plug_sn.pin[2].i) + AIMS1.spacePhasorS.plug_n.pin[2].i = 0.0;
// AIMS1.plug_sn.pin[2].v = AIMS1.spacePhasorS.plug_n.pin[2].v;
//   (-AIMS1.plug_sn.pin[1].i) + AIMS1.spacePhasorS.plug_n.pin[1].i = 0.0;
// AIMS1.plug_sn.pin[1].v = AIMS1.spacePhasorS.plug_n.pin[1].v;
//   AIMS1.lssigma.plug_n.pin[3].i + AIMS1.spacePhasorS.plug_p.pin[3].i = 0.0;
// AIMS1.lssigma.plug_n.pin[3].v = AIMS1.spacePhasorS.plug_p.pin[3].v;
//   AIMS1.lssigma.plug_n.pin[2].i + AIMS1.spacePhasorS.plug_p.pin[2].i = 0.0;
// AIMS1.lssigma.plug_n.pin[2].v = AIMS1.spacePhasorS.plug_p.pin[2].v;
//   AIMS1.lssigma.plug_n.pin[1].i + AIMS1.spacePhasorS.plug_p.pin[1].i = 0.0;
// AIMS1.lssigma.plug_n.pin[1].v = AIMS1.spacePhasorS.plug_p.pin[1].v;
//   AIMS1.spacePhasorS.ground.i + AIMS1.spacePhasorS.zero.i = 0.0;
// AIMS1.spacePhasorS.ground.v = AIMS1.spacePhasorS.zero.v;
//   AIMS1.spacePhasorS.spacePhasor.i_[1] + AIMS1.airGapS.spacePhasor_s.i_[1] = 0.0;
//   AIMS1.spacePhasorS.spacePhasor.i_[2] + AIMS1.airGapS.spacePhasor_s.i_[2] = 0.0;
// AIMS1.spacePhasorS.spacePhasor.v_[1] = AIMS1.airGapS.spacePhasor_s.v_[1];
// AIMS1.spacePhasorS.spacePhasor.v_[2] = AIMS1.airGapS.spacePhasor_s.v_[2];
//   AIMS1.IdealTransformer1.plug_n1.pin[3].i + (-AIMS1.plug_rn.pin[3].i) = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[3].v = AIMS1.plug_rn.pin[3].v;
//   AIMS1.IdealTransformer1.plug_n1.pin[2].i + (-AIMS1.plug_rn.pin[2].i) = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[2].v = AIMS1.plug_rn.pin[2].v;
//   AIMS1.IdealTransformer1.plug_n1.pin[1].i + (-AIMS1.plug_rn.pin[1].i) = 0.0;
// AIMS1.IdealTransformer1.plug_n1.pin[1].v = AIMS1.plug_rn.pin[1].v;
//   AIMS1.Star1.plug_p.pin[3].i + (AIMS1.spacePhasorR.plug_n.pin[3].i + AIMS1.IdealTransformer1.plug_n2.pin[3].i) = 0.0;
// AIMS1.Star1.plug_p.pin[3].v = AIMS1.spacePhasorR.plug_n.pin[3].v;
// AIMS1.spacePhasorR.plug_n.pin[3].v = AIMS1.IdealTransformer1.plug_n2.pin[3].v;
//   AIMS1.Star1.plug_p.pin[2].i + (AIMS1.spacePhasorR.plug_n.pin[2].i + AIMS1.IdealTransformer1.plug_n2.pin[2].i) = 0.0;
// AIMS1.Star1.plug_p.pin[2].v = AIMS1.spacePhasorR.plug_n.pin[2].v;
// AIMS1.spacePhasorR.plug_n.pin[2].v = AIMS1.IdealTransformer1.plug_n2.pin[2].v;
//   AIMS1.Star1.plug_p.pin[1].i + (AIMS1.spacePhasorR.plug_n.pin[1].i + AIMS1.IdealTransformer1.plug_n2.pin[1].i) = 0.0;
// AIMS1.Star1.plug_p.pin[1].v = AIMS1.spacePhasorR.plug_n.pin[1].v;
// AIMS1.spacePhasorR.plug_n.pin[1].v = AIMS1.IdealTransformer1.plug_n2.pin[1].v;
//   AIMS1.IdealTransformer1.plug_p1.pin[3].i + AIMS1.lrsigma.plug_n.pin[3].i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[3].v = AIMS1.lrsigma.plug_n.pin[3].v;
//   AIMS1.IdealTransformer1.plug_p1.pin[2].i + AIMS1.lrsigma.plug_n.pin[2].i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[2].v = AIMS1.lrsigma.plug_n.pin[2].v;
//   AIMS1.IdealTransformer1.plug_p1.pin[1].i + AIMS1.lrsigma.plug_n.pin[1].i = 0.0;
// AIMS1.IdealTransformer1.plug_p1.pin[1].v = AIMS1.lrsigma.plug_n.pin[1].v;
//   AIMS1.spacePhasorR.plug_p.pin[3].i + AIMS1.IdealTransformer1.plug_p2.pin[3].i = 0.0;
// AIMS1.spacePhasorR.plug_p.pin[3].v = AIMS1.IdealTransformer1.plug_p2.pin[3].v;
//   AIMS1.spacePhasorR.plug_p.pin[2].i + AIMS1.IdealTransformer1.plug_p2.pin[2].i = 0.0;
// AIMS1.spacePhasorR.plug_p.pin[2].v = AIMS1.IdealTransformer1.plug_p2.pin[2].v;
//   AIMS1.spacePhasorR.plug_p.pin[1].i + AIMS1.IdealTransformer1.plug_p2.pin[1].i = 0.0;
// AIMS1.spacePhasorR.plug_p.pin[1].v = AIMS1.IdealTransformer1.plug_p2.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i = -CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i;
// CurrentRMSsensor1.CurrentSensor1.currentSensor[1].i = CurrentRMSsensor1.CurrentSensor1.i[1];
// CurrentRMSsensor1.CurrentSensor1.currentSensor[2].i = CurrentRMSsensor1.CurrentSensor1.i[2];
// CurrentRMSsensor1.CurrentSensor1.currentSensor[3].i = CurrentRMSsensor1.CurrentSensor1.i[3];
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.i = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[3].p.v;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.i = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[2].p.v;
//   (-CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.i = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v = CurrentRMSsensor1.CurrentSensor1.currentSensor[1].p.v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.currentSensor[3].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.currentSensor[2].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.i + (-CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.currentSensor[1].n.v = CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v;
//   CurrentRMSsensor1.ToSpacePhasor1.zero = 0.333333333333333 * (CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.u[3]));
//   CurrentRMSsensor1.ToSpacePhasor1.y[1] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[1,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToSpacePhasor1.y[2] = CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,1] * CurrentRMSsensor1.ToSpacePhasor1.u[1] + (CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,2] * CurrentRMSsensor1.ToSpacePhasor1.u[2] + CurrentRMSsensor1.ToSpacePhasor1.TransformationMatrix[2,3] * CurrentRMSsensor1.ToSpacePhasor1.u[3]);
//   CurrentRMSsensor1.ToPolar1.y[1] = sqrt(CurrentRMSsensor1.ToPolar1.u[1] ^ 2.0 + CurrentRMSsensor1.ToPolar1.u[2] ^ 2.0);
//   CurrentRMSsensor1.ToPolar1.y[2] = if noEvent(CurrentRMSsensor1.ToPolar1.y[1] <= 1e-60) then 0.0 else Modelica.Math.atan2(CurrentRMSsensor1.ToPolar1.u[2],CurrentRMSsensor1.ToPolar1.u[1]);
//   CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.Gain1.k * CurrentRMSsensor1.Gain1.u;
// assert(CurrentRMSsensor1.CurrentSensor1.plug_n.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
// assert(CurrentRMSsensor1.plug_p.m == CurrentRMSsensor1.CurrentSensor1.plug_p.m,"automatically generated from connect");
// CurrentRMSsensor1.Gain1.y = CurrentRMSsensor1.I;
//   (-CurrentRMSsensor1.plug_p.pin[3].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].i = 0.0;
// CurrentRMSsensor1.plug_p.pin[3].v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[3].v;
//   (-CurrentRMSsensor1.plug_p.pin[2].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].i = 0.0;
// CurrentRMSsensor1.plug_p.pin[2].v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[2].v;
//   (-CurrentRMSsensor1.plug_p.pin[1].i) + CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].i = 0.0;
// CurrentRMSsensor1.plug_p.pin[1].v = CurrentRMSsensor1.CurrentSensor1.plug_p.pin[1].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].i + (-CurrentRMSsensor1.plug_n.pin[3].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_n.pin[3].v = CurrentRMSsensor1.plug_n.pin[3].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].i + (-CurrentRMSsensor1.plug_n.pin[2].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_n.pin[2].v = CurrentRMSsensor1.plug_n.pin[2].v;
//   CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].i + (-CurrentRMSsensor1.plug_n.pin[1].i) = 0.0;
// CurrentRMSsensor1.CurrentSensor1.plug_n.pin[1].v = CurrentRMSsensor1.plug_n.pin[1].v;
// CurrentRMSsensor1.ToPolar1.y[1] = CurrentRMSsensor1.Gain1.u;
// CurrentRMSsensor1.CurrentSensor1.i[1] = CurrentRMSsensor1.ToSpacePhasor1.u[1];
// CurrentRMSsensor1.CurrentSensor1.i[2] = CurrentRMSsensor1.ToSpacePhasor1.u[2];
// CurrentRMSsensor1.CurrentSensor1.i[3] = CurrentRMSsensor1.ToSpacePhasor1.u[3];
// CurrentRMSsensor1.ToSpacePhasor1.y[1] = CurrentRMSsensor1.ToPolar1.u[1];
// CurrentRMSsensor1.ToSpacePhasor1.y[2] = CurrentRMSsensor1.ToPolar1.u[2];
//   SineVoltage1.sineVoltage[1].signalSource.y = SineVoltage1.sineVoltage[1].signalSource.offset + (if time < SineVoltage1.sineVoltage[1].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[1].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[1].signalSource.freqHz * (time - SineVoltage1.sineVoltage[1].signalSource.startTime)) + SineVoltage1.sineVoltage[1].signalSource.phase));
//   SineVoltage1.sineVoltage[1].v = SineVoltage1.sineVoltage[1].signalSource.y;
//   SineVoltage1.sineVoltage[1].v = SineVoltage1.sineVoltage[1].p.v - SineVoltage1.sineVoltage[1].n.v;
//   0.0 = SineVoltage1.sineVoltage[1].p.i + SineVoltage1.sineVoltage[1].n.i;
//   SineVoltage1.sineVoltage[1].i = SineVoltage1.sineVoltage[1].p.i;
//   SineVoltage1.sineVoltage[2].signalSource.y = SineVoltage1.sineVoltage[2].signalSource.offset + (if time < SineVoltage1.sineVoltage[2].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[2].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[2].signalSource.freqHz * (time - SineVoltage1.sineVoltage[2].signalSource.startTime)) + SineVoltage1.sineVoltage[2].signalSource.phase));
//   SineVoltage1.sineVoltage[2].v = SineVoltage1.sineVoltage[2].signalSource.y;
//   SineVoltage1.sineVoltage[2].v = SineVoltage1.sineVoltage[2].p.v - SineVoltage1.sineVoltage[2].n.v;
//   0.0 = SineVoltage1.sineVoltage[2].p.i + SineVoltage1.sineVoltage[2].n.i;
//   SineVoltage1.sineVoltage[2].i = SineVoltage1.sineVoltage[2].p.i;
//   SineVoltage1.sineVoltage[3].signalSource.y = SineVoltage1.sineVoltage[3].signalSource.offset + (if time < SineVoltage1.sineVoltage[3].signalSource.startTime then 0.0 else SineVoltage1.sineVoltage[3].signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (SineVoltage1.sineVoltage[3].signalSource.freqHz * (time - SineVoltage1.sineVoltage[3].signalSource.startTime)) + SineVoltage1.sineVoltage[3].signalSource.phase));
//   SineVoltage1.sineVoltage[3].v = SineVoltage1.sineVoltage[3].signalSource.y;
//   SineVoltage1.sineVoltage[3].v = SineVoltage1.sineVoltage[3].p.v - SineVoltage1.sineVoltage[3].n.v;
//   0.0 = SineVoltage1.sineVoltage[3].p.i + SineVoltage1.sineVoltage[3].n.i;
//   SineVoltage1.sineVoltage[3].i = SineVoltage1.sineVoltage[3].p.i;
//   SineVoltage1.v[1] = SineVoltage1.plug_p.pin[1].v - SineVoltage1.plug_n.pin[1].v;
//   SineVoltage1.v[2] = SineVoltage1.plug_p.pin[2].v - SineVoltage1.plug_n.pin[2].v;
//   SineVoltage1.v[3] = SineVoltage1.plug_p.pin[3].v - SineVoltage1.plug_n.pin[3].v;
//   SineVoltage1.i[1] = SineVoltage1.plug_p.pin[1].i;
//   SineVoltage1.i[2] = SineVoltage1.plug_p.pin[2].i;
//   SineVoltage1.i[3] = SineVoltage1.plug_p.pin[3].i;
//   SineVoltage1.sineVoltage[3].p.i + (-SineVoltage1.plug_p.pin[3].i) = 0.0;
// SineVoltage1.sineVoltage[3].p.v = SineVoltage1.plug_p.pin[3].v;
//   SineVoltage1.sineVoltage[2].p.i + (-SineVoltage1.plug_p.pin[2].i) = 0.0;
// SineVoltage1.sineVoltage[2].p.v = SineVoltage1.plug_p.pin[2].v;
//   SineVoltage1.sineVoltage[1].p.i + (-SineVoltage1.plug_p.pin[1].i) = 0.0;
// SineVoltage1.sineVoltage[1].p.v = SineVoltage1.plug_p.pin[1].v;
//   SineVoltage1.sineVoltage[3].n.i + (-SineVoltage1.plug_n.pin[3].i) = 0.0;
// SineVoltage1.sineVoltage[3].n.v = SineVoltage1.plug_n.pin[3].v;
//   SineVoltage1.sineVoltage[2].n.i + (-SineVoltage1.plug_n.pin[2].i) = 0.0;
// SineVoltage1.sineVoltage[2].n.v = SineVoltage1.plug_n.pin[2].v;
//   SineVoltage1.sineVoltage[1].n.i + (-SineVoltage1.plug_n.pin[1].i) = 0.0;
// SineVoltage1.sineVoltage[1].n.v = SineVoltage1.plug_n.pin[1].v;
//   (-Star1.plug_p.pin[3].i) + ((-Star1.plug_p.pin[2].i) + ((-Star1.plug_p.pin[1].i) + (-Star1.pin_n.i))) = 0.0;
// Star1.plug_p.pin[3].v = Star1.plug_p.pin[2].v;
// Star1.plug_p.pin[2].v = Star1.plug_p.pin[1].v;
// Star1.plug_p.pin[1].v = Star1.pin_n.v;
//   BooleanStep1[1].y = if time >= BooleanStep1[1].startTime then  NOT BooleanStep1[1].startValue else BooleanStep1[1].startValue;
//   BooleanStep1[2].y = if time >= BooleanStep1[2].startTime then  NOT BooleanStep1[2].startValue else BooleanStep1[2].startValue;
//   BooleanStep1[3].y = if time >= BooleanStep1[3].startTime then  NOT BooleanStep1[3].startValue else BooleanStep1[3].startValue;
//   IdealCloser1.idealClosingSwitch[1].v = IdealCloser1.idealClosingSwitch[1].s * (IdealCloser1.idealClosingSwitch[1].unitCurrent * (if IdealCloser1.idealClosingSwitch[1].control then IdealCloser1.idealClosingSwitch[1].Ron else 1.0));
//   IdealCloser1.idealClosingSwitch[1].i = IdealCloser1.idealClosingSwitch[1].s * (IdealCloser1.idealClosingSwitch[1].unitVoltage * (if IdealCloser1.idealClosingSwitch[1].control then 1.0 else IdealCloser1.idealClosingSwitch[1].Goff));
//   IdealCloser1.idealClosingSwitch[1].v = IdealCloser1.idealClosingSwitch[1].p.v - IdealCloser1.idealClosingSwitch[1].n.v;
//   0.0 = IdealCloser1.idealClosingSwitch[1].p.i + IdealCloser1.idealClosingSwitch[1].n.i;
//   IdealCloser1.idealClosingSwitch[1].i = IdealCloser1.idealClosingSwitch[1].p.i;
//   IdealCloser1.idealClosingSwitch[2].v = IdealCloser1.idealClosingSwitch[2].s * (IdealCloser1.idealClosingSwitch[2].unitCurrent * (if IdealCloser1.idealClosingSwitch[2].control then IdealCloser1.idealClosingSwitch[2].Ron else 1.0));
//   IdealCloser1.idealClosingSwitch[2].i = IdealCloser1.idealClosingSwitch[2].s * (IdealCloser1.idealClosingSwitch[2].unitVoltage * (if IdealCloser1.idealClosingSwitch[2].control then 1.0 else IdealCloser1.idealClosingSwitch[2].Goff));
//   IdealCloser1.idealClosingSwitch[2].v = IdealCloser1.idealClosingSwitch[2].p.v - IdealCloser1.idealClosingSwitch[2].n.v;
//   0.0 = IdealCloser1.idealClosingSwitch[2].p.i + IdealCloser1.idealClosingSwitch[2].n.i;
//   IdealCloser1.idealClosingSwitch[2].i = IdealCloser1.idealClosingSwitch[2].p.i;
//   IdealCloser1.idealClosingSwitch[3].v = IdealCloser1.idealClosingSwitch[3].s * (IdealCloser1.idealClosingSwitch[3].unitCurrent * (if IdealCloser1.idealClosingSwitch[3].control then IdealCloser1.idealClosingSwitch[3].Ron else 1.0));
//   IdealCloser1.idealClosingSwitch[3].i = IdealCloser1.idealClosingSwitch[3].s * (IdealCloser1.idealClosingSwitch[3].unitVoltage * (if IdealCloser1.idealClosingSwitch[3].control then 1.0 else IdealCloser1.idealClosingSwitch[3].Goff));
//   IdealCloser1.idealClosingSwitch[3].v = IdealCloser1.idealClosingSwitch[3].p.v - IdealCloser1.idealClosingSwitch[3].n.v;
//   0.0 = IdealCloser1.idealClosingSwitch[3].p.i + IdealCloser1.idealClosingSwitch[3].n.i;
//   IdealCloser1.idealClosingSwitch[3].i = IdealCloser1.idealClosingSwitch[3].p.i;
//   IdealCloser1.v[1] = IdealCloser1.plug_p.pin[1].v - IdealCloser1.plug_n.pin[1].v;
//   IdealCloser1.v[2] = IdealCloser1.plug_p.pin[2].v - IdealCloser1.plug_n.pin[2].v;
//   IdealCloser1.v[3] = IdealCloser1.plug_p.pin[3].v - IdealCloser1.plug_n.pin[3].v;
//   IdealCloser1.i[1] = IdealCloser1.plug_p.pin[1].i;
//   IdealCloser1.i[2] = IdealCloser1.plug_p.pin[2].i;
//   IdealCloser1.i[3] = IdealCloser1.plug_p.pin[3].i;
// IdealCloser1.control[1] = IdealCloser1.idealClosingSwitch[1].control;
// IdealCloser1.control[2] = IdealCloser1.idealClosingSwitch[2].control;
// IdealCloser1.control[3] = IdealCloser1.idealClosingSwitch[3].control;
//   (-IdealCloser1.plug_p.pin[3].i) + IdealCloser1.idealClosingSwitch[3].p.i = 0.0;
// IdealCloser1.plug_p.pin[3].v = IdealCloser1.idealClosingSwitch[3].p.v;
//   (-IdealCloser1.plug_p.pin[2].i) + IdealCloser1.idealClosingSwitch[2].p.i = 0.0;
// IdealCloser1.plug_p.pin[2].v = IdealCloser1.idealClosingSwitch[2].p.v;
//   (-IdealCloser1.plug_p.pin[1].i) + IdealCloser1.idealClosingSwitch[1].p.i = 0.0;
// IdealCloser1.plug_p.pin[1].v = IdealCloser1.idealClosingSwitch[1].p.v;
//   IdealCloser1.idealClosingSwitch[3].n.i + (-IdealCloser1.plug_n.pin[3].i) = 0.0;
// IdealCloser1.idealClosingSwitch[3].n.v = IdealCloser1.plug_n.pin[3].v;
//   IdealCloser1.idealClosingSwitch[2].n.i + (-IdealCloser1.plug_n.pin[2].i) = 0.0;
// IdealCloser1.idealClosingSwitch[2].n.v = IdealCloser1.plug_n.pin[2].v;
//   IdealCloser1.idealClosingSwitch[1].n.i + (-IdealCloser1.plug_n.pin[1].i) = 0.0;
// IdealCloser1.idealClosingSwitch[1].n.v = IdealCloser1.plug_n.pin[1].v;
//   (-Star3.plug_p.pin[3].i) + ((-Star3.plug_p.pin[2].i) + ((-Star3.plug_p.pin[1].i) + (-Star3.pin_n.i))) = 0.0;
// Star3.plug_p.pin[3].v = Star3.plug_p.pin[2].v;
// Star3.plug_p.pin[2].v = Star3.plug_p.pin[1].v;
// Star3.plug_p.pin[1].v = Star3.pin_n.v;
//   0.0 = IdealCommutingSwitch1.idealCommutingSwitch[1].p.i + (IdealCommutingSwitch1.idealCommutingSwitch[1].n2.i + IdealCommutingSwitch1.idealCommutingSwitch[1].n1.i);
//   IdealCommutingSwitch1.idealCommutingSwitch[1].p.v - IdealCommutingSwitch1.idealCommutingSwitch[1].n1.v = IdealCommutingSwitch1.idealCommutingSwitch[1].s1 * (IdealCommutingSwitch1.idealCommutingSwitch[1].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[1].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[1].Ron));
//   IdealCommutingSwitch1.idealCommutingSwitch[1].n1.i = (-IdealCommutingSwitch1.idealCommutingSwitch[1].s1) * (IdealCommutingSwitch1.idealCommutingSwitch[1].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[1].control then IdealCommutingSwitch1.idealCommutingSwitch[1].Goff else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[1].p.v - IdealCommutingSwitch1.idealCommutingSwitch[1].n2.v = IdealCommutingSwitch1.idealCommutingSwitch[1].s2 * (IdealCommutingSwitch1.idealCommutingSwitch[1].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[1].control then IdealCommutingSwitch1.idealCommutingSwitch[1].Ron else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[1].n2.i = (-IdealCommutingSwitch1.idealCommutingSwitch[1].s2) * (IdealCommutingSwitch1.idealCommutingSwitch[1].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[1].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[1].Goff));
//   0.0 = IdealCommutingSwitch1.idealCommutingSwitch[2].p.i + (IdealCommutingSwitch1.idealCommutingSwitch[2].n2.i + IdealCommutingSwitch1.idealCommutingSwitch[2].n1.i);
//   IdealCommutingSwitch1.idealCommutingSwitch[2].p.v - IdealCommutingSwitch1.idealCommutingSwitch[2].n1.v = IdealCommutingSwitch1.idealCommutingSwitch[2].s1 * (IdealCommutingSwitch1.idealCommutingSwitch[2].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[2].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[2].Ron));
//   IdealCommutingSwitch1.idealCommutingSwitch[2].n1.i = (-IdealCommutingSwitch1.idealCommutingSwitch[2].s1) * (IdealCommutingSwitch1.idealCommutingSwitch[2].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[2].control then IdealCommutingSwitch1.idealCommutingSwitch[2].Goff else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[2].p.v - IdealCommutingSwitch1.idealCommutingSwitch[2].n2.v = IdealCommutingSwitch1.idealCommutingSwitch[2].s2 * (IdealCommutingSwitch1.idealCommutingSwitch[2].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[2].control then IdealCommutingSwitch1.idealCommutingSwitch[2].Ron else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[2].n2.i = (-IdealCommutingSwitch1.idealCommutingSwitch[2].s2) * (IdealCommutingSwitch1.idealCommutingSwitch[2].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[2].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[2].Goff));
//   0.0 = IdealCommutingSwitch1.idealCommutingSwitch[3].p.i + (IdealCommutingSwitch1.idealCommutingSwitch[3].n2.i + IdealCommutingSwitch1.idealCommutingSwitch[3].n1.i);
//   IdealCommutingSwitch1.idealCommutingSwitch[3].p.v - IdealCommutingSwitch1.idealCommutingSwitch[3].n1.v = IdealCommutingSwitch1.idealCommutingSwitch[3].s1 * (IdealCommutingSwitch1.idealCommutingSwitch[3].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[3].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[3].Ron));
//   IdealCommutingSwitch1.idealCommutingSwitch[3].n1.i = (-IdealCommutingSwitch1.idealCommutingSwitch[3].s1) * (IdealCommutingSwitch1.idealCommutingSwitch[3].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[3].control then IdealCommutingSwitch1.idealCommutingSwitch[3].Goff else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[3].p.v - IdealCommutingSwitch1.idealCommutingSwitch[3].n2.v = IdealCommutingSwitch1.idealCommutingSwitch[3].s2 * (IdealCommutingSwitch1.idealCommutingSwitch[3].unitCurrent * (if IdealCommutingSwitch1.idealCommutingSwitch[3].control then IdealCommutingSwitch1.idealCommutingSwitch[3].Ron else 1.0));
//   IdealCommutingSwitch1.idealCommutingSwitch[3].n2.i = (-IdealCommutingSwitch1.idealCommutingSwitch[3].s2) * (IdealCommutingSwitch1.idealCommutingSwitch[3].unitVoltage * (if IdealCommutingSwitch1.idealCommutingSwitch[3].control then 1.0 else IdealCommutingSwitch1.idealCommutingSwitch[3].Goff));
// IdealCommutingSwitch1.control[1] = IdealCommutingSwitch1.idealCommutingSwitch[1].control;
// IdealCommutingSwitch1.control[2] = IdealCommutingSwitch1.idealCommutingSwitch[2].control;
// IdealCommutingSwitch1.control[3] = IdealCommutingSwitch1.idealCommutingSwitch[3].control;
//   (-IdealCommutingSwitch1.plug_p.pin[3].i) + IdealCommutingSwitch1.idealCommutingSwitch[3].p.i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[3].v = IdealCommutingSwitch1.idealCommutingSwitch[3].p.v;
//   (-IdealCommutingSwitch1.plug_p.pin[2].i) + IdealCommutingSwitch1.idealCommutingSwitch[2].p.i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[2].v = IdealCommutingSwitch1.idealCommutingSwitch[2].p.v;
//   (-IdealCommutingSwitch1.plug_p.pin[1].i) + IdealCommutingSwitch1.idealCommutingSwitch[1].p.i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[1].v = IdealCommutingSwitch1.idealCommutingSwitch[1].p.v;
//   IdealCommutingSwitch1.idealCommutingSwitch[3].n2.i + (-IdealCommutingSwitch1.plug_n2.pin[3].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[3].n2.v = IdealCommutingSwitch1.plug_n2.pin[3].v;
//   IdealCommutingSwitch1.idealCommutingSwitch[2].n2.i + (-IdealCommutingSwitch1.plug_n2.pin[2].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[2].n2.v = IdealCommutingSwitch1.plug_n2.pin[2].v;
//   IdealCommutingSwitch1.idealCommutingSwitch[1].n2.i + (-IdealCommutingSwitch1.plug_n2.pin[1].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[1].n2.v = IdealCommutingSwitch1.plug_n2.pin[1].v;
//   IdealCommutingSwitch1.idealCommutingSwitch[3].n1.i + (-IdealCommutingSwitch1.plug_n1.pin[3].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[3].n1.v = IdealCommutingSwitch1.plug_n1.pin[3].v;
//   IdealCommutingSwitch1.idealCommutingSwitch[2].n1.i + (-IdealCommutingSwitch1.plug_n1.pin[2].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[2].n1.v = IdealCommutingSwitch1.plug_n1.pin[2].v;
//   IdealCommutingSwitch1.idealCommutingSwitch[1].n1.i + (-IdealCommutingSwitch1.plug_n1.pin[1].i) = 0.0;
// IdealCommutingSwitch1.idealCommutingSwitch[1].n1.v = IdealCommutingSwitch1.plug_n1.pin[1].v;
//   Resistor1.resistor[1].R * Resistor1.resistor[1].i = Resistor1.resistor[1].v;
//   Resistor1.resistor[1].v = Resistor1.resistor[1].p.v - Resistor1.resistor[1].n.v;
//   0.0 = Resistor1.resistor[1].p.i + Resistor1.resistor[1].n.i;
//   Resistor1.resistor[1].i = Resistor1.resistor[1].p.i;
//   Resistor1.resistor[2].R * Resistor1.resistor[2].i = Resistor1.resistor[2].v;
//   Resistor1.resistor[2].v = Resistor1.resistor[2].p.v - Resistor1.resistor[2].n.v;
//   0.0 = Resistor1.resistor[2].p.i + Resistor1.resistor[2].n.i;
//   Resistor1.resistor[2].i = Resistor1.resistor[2].p.i;
//   Resistor1.resistor[3].R * Resistor1.resistor[3].i = Resistor1.resistor[3].v;
//   Resistor1.resistor[3].v = Resistor1.resistor[3].p.v - Resistor1.resistor[3].n.v;
//   0.0 = Resistor1.resistor[3].p.i + Resistor1.resistor[3].n.i;
//   Resistor1.resistor[3].i = Resistor1.resistor[3].p.i;
//   Resistor1.v[1] = Resistor1.plug_p.pin[1].v - Resistor1.plug_n.pin[1].v;
//   Resistor1.v[2] = Resistor1.plug_p.pin[2].v - Resistor1.plug_n.pin[2].v;
//   Resistor1.v[3] = Resistor1.plug_p.pin[3].v - Resistor1.plug_n.pin[3].v;
//   Resistor1.i[1] = Resistor1.plug_p.pin[1].i;
//   Resistor1.i[2] = Resistor1.plug_p.pin[2].i;
//   Resistor1.i[3] = Resistor1.plug_p.pin[3].i;
//   Resistor1.resistor[3].p.i + (-Resistor1.plug_p.pin[3].i) = 0.0;
// Resistor1.resistor[3].p.v = Resistor1.plug_p.pin[3].v;
//   Resistor1.resistor[2].p.i + (-Resistor1.plug_p.pin[2].i) = 0.0;
// Resistor1.resistor[2].p.v = Resistor1.plug_p.pin[2].v;
//   Resistor1.resistor[1].p.i + (-Resistor1.plug_p.pin[1].i) = 0.0;
// Resistor1.resistor[1].p.v = Resistor1.plug_p.pin[1].v;
//   Resistor1.resistor[3].n.i + (-Resistor1.plug_n.pin[3].i) = 0.0;
// Resistor1.resistor[3].n.v = Resistor1.plug_n.pin[3].v;
//   Resistor1.resistor[2].n.i + (-Resistor1.plug_n.pin[2].i) = 0.0;
// Resistor1.resistor[2].n.v = Resistor1.plug_n.pin[2].v;
//   Resistor1.resistor[1].n.i + (-Resistor1.plug_n.pin[1].i) = 0.0;
// Resistor1.resistor[1].n.v = Resistor1.plug_n.pin[1].v;
//   (-Star4.plug_p.pin[3].i) + ((-Star4.plug_p.pin[2].i) + ((-Star4.plug_p.pin[1].i) + (-Star4.pin_n.i))) = 0.0;
// Star4.plug_p.pin[3].v = Star4.plug_p.pin[2].v;
// Star4.plug_p.pin[2].v = Star4.plug_p.pin[1].v;
// Star4.plug_p.pin[1].v = Star4.pin_n.v;
//   BooleanStep2[1].y = if time >= BooleanStep2[1].startTime then  NOT BooleanStep2[1].startValue else BooleanStep2[1].startValue;
//   BooleanStep2[2].y = if time >= BooleanStep2[2].startTime then  NOT BooleanStep2[2].startValue else BooleanStep2[2].startValue;
//   BooleanStep2[3].y = if time >= BooleanStep2[3].startTime then  NOT BooleanStep2[3].startValue else BooleanStep2[3].startValue;
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   QuadraticLoadTorque1.tau = (-QuadraticLoadTorque1.tau_nominal) * (QuadraticLoadTorque1.w / QuadraticLoadTorque1.w_nominal) ^ 2.0;
//   QuadraticLoadTorque1.bearing.phi = 0.0;
//   (-TerminalBox1.delta.plug_n.pin[3].i) + (-TerminalBox1.delta.plug_p.pin[1].i) = 0.0;
// TerminalBox1.delta.plug_n.pin[3].v = TerminalBox1.delta.plug_p.pin[1].v;
//   (-TerminalBox1.delta.plug_n.pin[2].i) + (-TerminalBox1.delta.plug_p.pin[3].i) = 0.0;
// TerminalBox1.delta.plug_n.pin[2].v = TerminalBox1.delta.plug_p.pin[3].v;
//   (-TerminalBox1.delta.plug_n.pin[1].i) + (-TerminalBox1.delta.plug_p.pin[2].i) = 0.0;
// TerminalBox1.delta.plug_n.pin[1].v = TerminalBox1.delta.plug_p.pin[2].v;
// assert(TerminalBox1.positiveMachinePlug.m == TerminalBox1.plugToGrid.m,"automatically generated from connect");
// assert(TerminalBox1.delta.plug_p.m == TerminalBox1.positiveMachinePlug.m,"automatically generated from connect");
// assert(TerminalBox1.negativeMachinePlug.m == TerminalBox1.delta.plug_n.m,"automatically generated from connect");
//   (-TerminalBox1.negativeMachinePlug.pin[3].i) + TerminalBox1.delta.plug_n.pin[3].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[3].v = TerminalBox1.delta.plug_n.pin[3].v;
//   (-TerminalBox1.negativeMachinePlug.pin[2].i) + TerminalBox1.delta.plug_n.pin[2].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[2].v = TerminalBox1.delta.plug_n.pin[2].v;
//   (-TerminalBox1.negativeMachinePlug.pin[1].i) + TerminalBox1.delta.plug_n.pin[1].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[1].v = TerminalBox1.delta.plug_n.pin[1].v;
//   TerminalBox1.delta.plug_p.pin[3].i + ((-TerminalBox1.positiveMachinePlug.pin[3].i) + (-TerminalBox1.plugToGrid.pin[3].i)) = 0.0;
// TerminalBox1.delta.plug_p.pin[3].v = TerminalBox1.positiveMachinePlug.pin[3].v;
// TerminalBox1.positiveMachinePlug.pin[3].v = TerminalBox1.plugToGrid.pin[3].v;
//   TerminalBox1.delta.plug_p.pin[2].i + ((-TerminalBox1.positiveMachinePlug.pin[2].i) + (-TerminalBox1.plugToGrid.pin[2].i)) = 0.0;
// TerminalBox1.delta.plug_p.pin[2].v = TerminalBox1.positiveMachinePlug.pin[2].v;
// TerminalBox1.positiveMachinePlug.pin[2].v = TerminalBox1.plugToGrid.pin[2].v;
//   TerminalBox1.delta.plug_p.pin[1].i + ((-TerminalBox1.positiveMachinePlug.pin[1].i) + (-TerminalBox1.plugToGrid.pin[1].i)) = 0.0;
// TerminalBox1.delta.plug_p.pin[1].v = TerminalBox1.positiveMachinePlug.pin[1].v;
// TerminalBox1.positiveMachinePlug.pin[1].v = TerminalBox1.plugToGrid.pin[1].v;
//   Ground1.p.v = 0.0;
//   Ground3.p.v = 0.0;
// assert(Resistor1.plug_p.m == IdealCommutingSwitch1.plug_n1.m,"automatically generated from connect");
// assert(IdealCommutingSwitch1.plug_n2.m == AIMS1.plug_rn.m,"automatically generated from connect");
// assert(IdealCommutingSwitch1.plug_p.m == AIMS1.plug_rp.m,"automatically generated from connect");
// assert(TerminalBox1.plugToGrid.m == CurrentRMSsensor1.plug_n.m,"automatically generated from connect");
// assert(TerminalBox1.positiveMachinePlug.m == AIMS1.plug_sp.m,"automatically generated from connect");
// assert(TerminalBox1.negativeMachinePlug.m == AIMS1.plug_sn.m,"automatically generated from connect");
// assert(IdealCloser1.plug_n.m == CurrentRMSsensor1.plug_p.m,"automatically generated from connect");
// assert(AIMS1.plug_rn.m == Star3.plug_p.m,"automatically generated from connect");
// assert(Star4.plug_p.m == Resistor1.plug_n.m,"automatically generated from connect");
// assert(SineVoltage1.plug_p.m == IdealCloser1.plug_p.m,"automatically generated from connect");
// assert(SineVoltage1.plug_n.m == Star1.plug_p.m,"automatically generated from connect");
//   Star3.pin_n.i + Ground3.p.i = 0.0;
// Star3.pin_n.v = Ground3.p.v;
//   Star1.pin_n.i + Ground1.p.i = 0.0;
// Star1.pin_n.v = Ground1.p.v;
//   SineVoltage1.plug_n.pin[3].i + Star1.plug_p.pin[3].i = 0.0;
// SineVoltage1.plug_n.pin[3].v = Star1.plug_p.pin[3].v;
//   SineVoltage1.plug_n.pin[2].i + Star1.plug_p.pin[2].i = 0.0;
// SineVoltage1.plug_n.pin[2].v = Star1.plug_p.pin[2].v;
//   SineVoltage1.plug_n.pin[1].i + Star1.plug_p.pin[1].i = 0.0;
// SineVoltage1.plug_n.pin[1].v = Star1.plug_p.pin[1].v;
//   SineVoltage1.plug_p.pin[3].i + IdealCloser1.plug_p.pin[3].i = 0.0;
// SineVoltage1.plug_p.pin[3].v = IdealCloser1.plug_p.pin[3].v;
//   SineVoltage1.plug_p.pin[2].i + IdealCloser1.plug_p.pin[2].i = 0.0;
// SineVoltage1.plug_p.pin[2].v = IdealCloser1.plug_p.pin[2].v;
//   SineVoltage1.plug_p.pin[1].i + IdealCloser1.plug_p.pin[1].i = 0.0;
// SineVoltage1.plug_p.pin[1].v = IdealCloser1.plug_p.pin[1].v;
//   Star4.plug_p.pin[3].i + Resistor1.plug_n.pin[3].i = 0.0;
// Star4.plug_p.pin[3].v = Resistor1.plug_n.pin[3].v;
//   Star4.plug_p.pin[2].i + Resistor1.plug_n.pin[2].i = 0.0;
// Star4.plug_p.pin[2].v = Resistor1.plug_n.pin[2].v;
//   Star4.plug_p.pin[1].i + Resistor1.plug_n.pin[1].i = 0.0;
// Star4.plug_p.pin[1].v = Resistor1.plug_n.pin[1].v;
//   IdealCommutingSwitch1.plug_n2.pin[3].i + (AIMS1.plug_rn.pin[3].i + Star3.plug_p.pin[3].i) = 0.0;
// IdealCommutingSwitch1.plug_n2.pin[3].v = AIMS1.plug_rn.pin[3].v;
// AIMS1.plug_rn.pin[3].v = Star3.plug_p.pin[3].v;
//   IdealCommutingSwitch1.plug_n2.pin[2].i + (AIMS1.plug_rn.pin[2].i + Star3.plug_p.pin[2].i) = 0.0;
// IdealCommutingSwitch1.plug_n2.pin[2].v = AIMS1.plug_rn.pin[2].v;
// AIMS1.plug_rn.pin[2].v = Star3.plug_p.pin[2].v;
//   IdealCommutingSwitch1.plug_n2.pin[1].i + (AIMS1.plug_rn.pin[1].i + Star3.plug_p.pin[1].i) = 0.0;
// IdealCommutingSwitch1.plug_n2.pin[1].v = AIMS1.plug_rn.pin[1].v;
// AIMS1.plug_rn.pin[1].v = Star3.plug_p.pin[1].v;
//   LoadInertia.flange_b.tau + QuadraticLoadTorque1.flange.tau = 0.0;
// LoadInertia.flange_b.phi = QuadraticLoadTorque1.flange.phi;
//   AIMS1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
// AIMS1.flange_a.phi = LoadInertia.flange_a.phi;
// BooleanStep1[1].y = IdealCloser1.control[1];
// BooleanStep1[2].y = IdealCloser1.control[2];
// BooleanStep1[3].y = IdealCloser1.control[3];
//   IdealCloser1.plug_n.pin[3].i + CurrentRMSsensor1.plug_p.pin[3].i = 0.0;
// IdealCloser1.plug_n.pin[3].v = CurrentRMSsensor1.plug_p.pin[3].v;
//   IdealCloser1.plug_n.pin[2].i + CurrentRMSsensor1.plug_p.pin[2].i = 0.0;
// IdealCloser1.plug_n.pin[2].v = CurrentRMSsensor1.plug_p.pin[2].v;
//   IdealCloser1.plug_n.pin[1].i + CurrentRMSsensor1.plug_p.pin[1].i = 0.0;
// IdealCloser1.plug_n.pin[1].v = CurrentRMSsensor1.plug_p.pin[1].v;
//   TerminalBox1.negativeMachinePlug.pin[3].i + AIMS1.plug_sn.pin[3].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[3].v = AIMS1.plug_sn.pin[3].v;
//   TerminalBox1.negativeMachinePlug.pin[2].i + AIMS1.plug_sn.pin[2].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[2].v = AIMS1.plug_sn.pin[2].v;
//   TerminalBox1.negativeMachinePlug.pin[1].i + AIMS1.plug_sn.pin[1].i = 0.0;
// TerminalBox1.negativeMachinePlug.pin[1].v = AIMS1.plug_sn.pin[1].v;
//   TerminalBox1.positiveMachinePlug.pin[3].i + AIMS1.plug_sp.pin[3].i = 0.0;
// TerminalBox1.positiveMachinePlug.pin[3].v = AIMS1.plug_sp.pin[3].v;
//   TerminalBox1.positiveMachinePlug.pin[2].i + AIMS1.plug_sp.pin[2].i = 0.0;
// TerminalBox1.positiveMachinePlug.pin[2].v = AIMS1.plug_sp.pin[2].v;
//   TerminalBox1.positiveMachinePlug.pin[1].i + AIMS1.plug_sp.pin[1].i = 0.0;
// TerminalBox1.positiveMachinePlug.pin[1].v = AIMS1.plug_sp.pin[1].v;
//   TerminalBox1.plugToGrid.pin[3].i + CurrentRMSsensor1.plug_n.pin[3].i = 0.0;
// TerminalBox1.plugToGrid.pin[3].v = CurrentRMSsensor1.plug_n.pin[3].v;
//   TerminalBox1.plugToGrid.pin[2].i + CurrentRMSsensor1.plug_n.pin[2].i = 0.0;
// TerminalBox1.plugToGrid.pin[2].v = CurrentRMSsensor1.plug_n.pin[2].v;
//   TerminalBox1.plugToGrid.pin[1].i + CurrentRMSsensor1.plug_n.pin[1].i = 0.0;
// TerminalBox1.plugToGrid.pin[1].v = CurrentRMSsensor1.plug_n.pin[1].v;
// BooleanStep2[1].y = IdealCommutingSwitch1.control[1];
// BooleanStep2[2].y = IdealCommutingSwitch1.control[2];
// BooleanStep2[3].y = IdealCommutingSwitch1.control[3];
//   IdealCommutingSwitch1.plug_p.pin[3].i + AIMS1.plug_rp.pin[3].i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[3].v = AIMS1.plug_rp.pin[3].v;
//   IdealCommutingSwitch1.plug_p.pin[2].i + AIMS1.plug_rp.pin[2].i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[2].v = AIMS1.plug_rp.pin[2].v;
//   IdealCommutingSwitch1.plug_p.pin[1].i + AIMS1.plug_rp.pin[1].i = 0.0;
// IdealCommutingSwitch1.plug_p.pin[1].v = AIMS1.plug_rp.pin[1].v;
//   Resistor1.plug_p.pin[3].i + IdealCommutingSwitch1.plug_n1.pin[3].i = 0.0;
// Resistor1.plug_p.pin[3].v = IdealCommutingSwitch1.plug_n1.pin[3].v;
//   Resistor1.plug_p.pin[2].i + IdealCommutingSwitch1.plug_n1.pin[2].i = 0.0;
// Resistor1.plug_p.pin[2].v = IdealCommutingSwitch1.plug_n1.pin[2].v;
//   Resistor1.plug_p.pin[1].i + IdealCommutingSwitch1.plug_n1.pin[1].i = 0.0;
// Resistor1.plug_p.pin[1].v = IdealCommutingSwitch1.plug_n1.pin[1].v;
//   AIMS1.internalSupport.tau = 0.0;
//   QuadraticLoadTorque1.bearing.tau = 0.0;
//   Star4.pin_n.i = 0.0;
// end Modelica.Electrical.Machines.Examples.AIMS_start;
// "
// ""
// endResult
