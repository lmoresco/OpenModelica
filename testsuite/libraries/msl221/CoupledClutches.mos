//name:         CoupledClutches
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Mechanics.Rotational.Examples.CoupledClutches);
getErrorString();
// Result:
// true
// "function Modelica.Math.sin
// input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
// output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Math.tempInterpol1
// input Real u "input value (first column of table)";
// input Real[:, :] table "table to be interpolated";
// input Integer icol "column of table to be interpolated";
// output Real y "interpolated input value (icol column of table)";
// protected Integer i;
// protected Integer n "number of rows of table";
// protected Real u1;
// protected Real u2;
// protected Real y1;
// protected Real y2;
// algorithm
//   n := size(table,1);
//   if n <= 1 then
//     y := table[1, icol];
//   else
//     if u <= table[1,1] then
//       i := 1;
//     else
//       i := 2;
//       while i < n AND u >= table[i, 1] loop
//         i := 1 + i;
//       end while;
//       i := i - 1;
//     end if;
//     u1 := table[i, 1];
//     u2 := table[1 + i, 1];
//     y1 := table[i, icol];
//     y2 := table[1 + i, icol];
//     assert( u2 > u1, "Table index must be increasing");
//     y := y1 + (y2 - y1) * (u - u1) / (u2 - u1);
//   end if;
// end Modelica.Math.tempInterpol1;
// 
// class Modelica.Mechanics.Rotational.Examples.CoupledClutches
// parameter Real freqHz(quantity = "Frequency", unit = "Hz") = 0.2 "frequency of sine function to invoke clutch1";
// parameter Real T2(quantity = "Time", unit = "s") = 0.4 "time when clutch2 is invoked";
// parameter Real T3(quantity = "Time", unit = "s") = 0.9 "time when clutch3 is invoked";
// Real J1.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real J1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real J1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real J1.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
// parameter Integer J1.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real J1.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real J1.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real J1.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer J1.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real J1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = 10.0, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real J1.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// input Real torque.tau(quantity = "Torque", unit = "N.m") "Torque driving the flange (a positive value accelerates the flange)";
// Real torque.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real torque.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real torque.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real torque.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real clutch1.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
// Real clutch1.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
// Real clutch1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real clutch1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real clutch1.w_small(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 10000000000.0 "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)";
// Real clutch1.w_relfric(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity between frictional surfaces";
// Real clutch1.a_relfric(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration between frictional surfaces";
// Real clutch1.tau0(quantity = "Torque", unit = "N.m") "Friction torque for w=0 and forward sliding";
// Real clutch1.tau0_max(quantity = "Torque", unit = "N.m") "Maximum friction torque for w=0 and locked";
// Boolean clutch1.free "true, if frictional element is not active";
// Real clutch1.sa "Path parameter of friction characteristic tau = f(a_relfric)";
// Boolean clutch1.startForward(start = false, fixed = true) "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
// Boolean clutch1.startBackward(start = false, fixed = true) "true, if w_rel=0 and start of backward sliding or w_rel < -w_small";
// Boolean clutch1.locked(start = false) "true, if w_rel=0 and not sliding";
// constant Integer clutch1.Unknown = 3 "Value of mode is not known";
// constant Integer clutch1.Free = 2 "Element is not active";
// constant Integer clutch1.Forward = 1 "w_rel > 0 (forward sliding)";
// constant Integer clutch1.Stuck = 0 "w_rel = 0 (forward sliding, locked or backward sliding)";
// constant Integer clutch1.Backward = -1 "w_rel < 0 (backward sliding)";
// Integer clutch1.mode(min = -1, max = 3, start = 3, fixed = true);
// protected parameter Real clutch1.unitAngularAcceleration(quantity = "AngularAcceleration", unit = "rad/s2") = 1.0;
// protected parameter Real clutch1.unitTorque(quantity = "Torque", unit = "N.m") = 1.0;
// parameter Real clutch1.mue_pos[1,1] = 0.0 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch1.mue_pos[1,2] = 0.5 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch1.peak(min = 1.0) = 1.1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
// parameter Real clutch1.cgeo(min = 0.0) = 1.0 "Geometry constant containing friction distribution assumption";
// parameter Real clutch1.fn_max(quantity = "Force", unit = "N", min = 0.0) = 20.0 "Maximum normal force";
// Real clutch1.w_rel(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity (flange_b.w - flange_a.w)";
// Real clutch1.a_rel(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration (flange_b.a - flange_a.a)";
// Real clutch1.mue0 "Friction coefficient for w=0 and forward sliding";
// Real clutch1.fn(quantity = "Force", unit = "N") "Normal force (fn=fn_max*inPort.signal)";
// input Real clutch1.f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)";
// output Real sin1.y "Connector of Real output signal";
// parameter Real sin1.amplitude = 10.0 "Amplitude of sine wave";
// parameter Real sin1.freqHz(quantity = "Frequency", unit = "Hz") = 5.0 "Frequency of sine wave";
// parameter Real sin1.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
// parameter Real sin1.offset = 0.0 "Offset of output signal";
// parameter Real sin1.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
// protected constant Real sin1.pi = 3.14159265358979;
// Real J2.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = J2.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real J2.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J2.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real J2.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J2.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real J2.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
// parameter Integer J2.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real J2.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real J2.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real J2.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer J2.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real J2.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = J2.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real J2.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// Real clutch2.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
// Real clutch2.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
// Real clutch2.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch2.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real clutch2.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch2.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real clutch2.w_small(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 10000000000.0 "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)";
// Real clutch2.w_relfric(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity between frictional surfaces";
// Real clutch2.a_relfric(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration between frictional surfaces";
// Real clutch2.tau0(quantity = "Torque", unit = "N.m") "Friction torque for w=0 and forward sliding";
// Real clutch2.tau0_max(quantity = "Torque", unit = "N.m") "Maximum friction torque for w=0 and locked";
// Boolean clutch2.free "true, if frictional element is not active";
// Real clutch2.sa "Path parameter of friction characteristic tau = f(a_relfric)";
// Boolean clutch2.startForward(start = false, fixed = true) "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
// Boolean clutch2.startBackward(start = false, fixed = true) "true, if w_rel=0 and start of backward sliding or w_rel < -w_small";
// Boolean clutch2.locked(start = false) "true, if w_rel=0 and not sliding";
// constant Integer clutch2.Unknown = 3 "Value of mode is not known";
// constant Integer clutch2.Free = 2 "Element is not active";
// constant Integer clutch2.Forward = 1 "w_rel > 0 (forward sliding)";
// constant Integer clutch2.Stuck = 0 "w_rel = 0 (forward sliding, locked or backward sliding)";
// constant Integer clutch2.Backward = -1 "w_rel < 0 (backward sliding)";
// Integer clutch2.mode(min = -1, max = 3, start = 3, fixed = true);
// protected parameter Real clutch2.unitAngularAcceleration(quantity = "AngularAcceleration", unit = "rad/s2") = 1.0;
// protected parameter Real clutch2.unitTorque(quantity = "Torque", unit = "N.m") = 1.0;
// parameter Real clutch2.mue_pos[1,1] = 0.0 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch2.mue_pos[1,2] = 0.5 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch2.peak(min = 1.0) = 1.1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
// parameter Real clutch2.cgeo(min = 0.0) = 1.0 "Geometry constant containing friction distribution assumption";
// parameter Real clutch2.fn_max(quantity = "Force", unit = "N", min = 0.0) = 20.0 "Maximum normal force";
// Real clutch2.w_rel(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity (flange_b.w - flange_a.w)";
// Real clutch2.a_rel(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration (flange_b.a - flange_a.a)";
// Real clutch2.mue0 "Friction coefficient for w=0 and forward sliding";
// Real clutch2.fn(quantity = "Force", unit = "N") "Normal force (fn=fn_max*inPort.signal)";
// input Real clutch2.f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)";
// Real J3.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = J3.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real J3.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J3.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real J3.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J3.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real J3.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
// parameter Integer J3.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real J3.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real J3.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real J3.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer J3.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real J3.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = J3.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real J3.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// Real clutch3.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
// Real clutch3.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
// Real clutch3.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch3.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real clutch3.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real clutch3.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real clutch3.w_small(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 10000000000.0 "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)";
// Real clutch3.w_relfric(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity between frictional surfaces";
// Real clutch3.a_relfric(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration between frictional surfaces";
// Real clutch3.tau0(quantity = "Torque", unit = "N.m") "Friction torque for w=0 and forward sliding";
// Real clutch3.tau0_max(quantity = "Torque", unit = "N.m") "Maximum friction torque for w=0 and locked";
// Boolean clutch3.free "true, if frictional element is not active";
// Real clutch3.sa "Path parameter of friction characteristic tau = f(a_relfric)";
// Boolean clutch3.startForward(start = false, fixed = true) "true, if w_rel=0 and start of forward sliding or w_rel > w_small";
// Boolean clutch3.startBackward(start = false, fixed = true) "true, if w_rel=0 and start of backward sliding or w_rel < -w_small";
// Boolean clutch3.locked(start = false) "true, if w_rel=0 and not sliding";
// constant Integer clutch3.Unknown = 3 "Value of mode is not known";
// constant Integer clutch3.Free = 2 "Element is not active";
// constant Integer clutch3.Forward = 1 "w_rel > 0 (forward sliding)";
// constant Integer clutch3.Stuck = 0 "w_rel = 0 (forward sliding, locked or backward sliding)";
// constant Integer clutch3.Backward = -1 "w_rel < 0 (backward sliding)";
// Integer clutch3.mode(min = -1, max = 3, start = 3, fixed = true);
// protected parameter Real clutch3.unitAngularAcceleration(quantity = "AngularAcceleration", unit = "rad/s2") = 1.0;
// protected parameter Real clutch3.unitTorque(quantity = "Torque", unit = "N.m") = 1.0;
// parameter Real clutch3.mue_pos[1,1] = 0.0 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch3.mue_pos[1,2] = 0.5 "[w,mue] positive sliding friction coefficient (w_rel>=0)";
// parameter Real clutch3.peak(min = 1.0) = 1.1 "peak*mue_pos[1,2] = maximum value of mue for w_rel==0";
// parameter Real clutch3.cgeo(min = 0.0) = 1.0 "Geometry constant containing friction distribution assumption";
// parameter Real clutch3.fn_max(quantity = "Force", unit = "N", min = 0.0) = 20.0 "Maximum normal force";
// Real clutch3.w_rel(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Relative angular velocity (flange_b.w - flange_a.w)";
// Real clutch3.a_rel(quantity = "AngularAcceleration", unit = "rad/s2") "Relative angular acceleration (flange_b.a - flange_a.a)";
// Real clutch3.mue0 "Friction coefficient for w=0 and forward sliding";
// Real clutch3.fn(quantity = "Force", unit = "N") "Normal force (fn=fn_max*inPort.signal)";
// input Real clutch3.f_normalized "Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if > 0)";
// Real J4.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = J4.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
// Real J4.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J4.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// Real J4.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
// Real J4.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
// parameter Real J4.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
// parameter Integer J4.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
// parameter Real J4.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
// parameter Real J4.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
// parameter Real J4.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
// parameter Integer J4.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
// Real J4.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = J4.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
// Real J4.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
// output Real sin2.y "Connector of Real output signal";
// parameter Real sin2.amplitude = 1.0 "Amplitude of sine wave";
// parameter Real sin2.freqHz(quantity = "Frequency", unit = "Hz") = freqHz "Frequency of sine wave";
// parameter Real sin2.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 1.57 "Phase of sine wave";
// parameter Real sin2.offset = 0.0 "Offset of output signal";
// parameter Real sin2.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
// protected constant Real sin2.pi = 3.14159265358979;
// output Real step1.y "Connector of Real output signal";
// parameter Real step1.offset = 0.0 "offset of output signal";
// parameter Real step1.startTime(quantity = "Time", unit = "s") = T2 "output = offset for time < startTime";
// parameter Real step1.height = 1.0 "Height of step";
// output Real step2.y "Connector of Real output signal";
// parameter Real step2.offset = 0.0 "offset of output signal";
// parameter Real step2.startTime(quantity = "Time", unit = "s") = T3 "output = offset for time < startTime";
// parameter Real step2.height = 1.0 "Height of step";
// equation
//   J1.w = der(J1.phi);
//   J1.a = der(J1.w);
//   J1.J * J1.a = J1.flange_a.tau + J1.flange_b.tau;
//   J1.flange_a.phi = J1.phi;
//   J1.flange_b.phi = J1.phi;
//   torque.flange_b.tau = -torque.tau;
//   torque.bearing.phi = 0.0;
//   clutch1.mue0 = Modelica.Math.tempInterpol1(0.0,{{clutch1.mue_pos[1,1],clutch1.mue_pos[1,2]}},2);
//   clutch1.w_rel = der(clutch1.phi_rel);
//   clutch1.a_rel = der(clutch1.w_rel);
//   clutch1.w_relfric = clutch1.w_rel;
//   clutch1.a_relfric = clutch1.a_rel;
//   clutch1.fn = clutch1.fn_max * clutch1.f_normalized;
//   clutch1.free = clutch1.fn <= 0.0;
//   clutch1.tau0 = clutch1.mue0 * (clutch1.cgeo * clutch1.fn);
//   clutch1.tau0_max = clutch1.peak * clutch1.tau0;
//   clutch1.tau = if clutch1.locked then clutch1.sa * clutch1.unitTorque else if clutch1.free then 0.0 else clutch1.cgeo * (clutch1.fn * (if clutch1.startForward then Modelica.Math.tempInterpol1(clutch1.w_rel,{{clutch1.mue_pos[1,1],clutch1.mue_pos[1,2]}},2) else if clutch1.startBackward then -Modelica.Math.tempInterpol1(-clutch1.w_rel,{{clutch1.mue_pos[1,1],clutch1.mue_pos[1,2]}},2) else if pre(clutch1.mode) == 1 then Modelica.Math.tempInterpol1(clutch1.w_rel,{{clutch1.mue_pos[1,1],clutch1.mue_pos[1,2]}},2) else -Modelica.Math.tempInterpol1(-clutch1.w_rel,{{clutch1.mue_pos[1,1],clutch1.mue_pos[1,2]}},2)));
//   clutch1.flange_a.tau = -clutch1.tau;
//   clutch1.flange_b.tau = clutch1.tau;
//   clutch1.phi_rel = clutch1.flange_b.phi - clutch1.flange_a.phi;
//   clutch1.startForward = pre(clutch1.mode) == 0 AND (clutch1.sa > clutch1.tau0_max OR pre(clutch1.startForward) AND clutch1.sa > clutch1.tau0) OR pre(clutch1.mode) == -1 AND clutch1.w_relfric > clutch1.w_small OR initial() AND clutch1.w_relfric > 0.0;
//   clutch1.startBackward = pre(clutch1.mode) == 0 AND (clutch1.sa < -clutch1.tau0_max OR pre(clutch1.startBackward) AND clutch1.sa < -clutch1.tau0) OR pre(clutch1.mode) == 1 AND clutch1.w_relfric < -clutch1.w_small OR initial() AND clutch1.w_relfric < 0.0;
//   clutch1.locked =  NOT clutch1.free AND  NOT (pre(clutch1.mode) == 1 OR clutch1.startForward OR pre(clutch1.mode) == -1 OR clutch1.startBackward);
//   clutch1.a_relfric = clutch1.unitAngularAcceleration * (if clutch1.locked then 0.0 else if clutch1.free then clutch1.sa else if clutch1.startForward then clutch1.sa - clutch1.tau0_max / clutch1.unitTorque else if clutch1.startBackward then clutch1.sa + clutch1.tau0_max / clutch1.unitTorque else if pre(clutch1.mode) == 1 then clutch1.sa - clutch1.tau0 / clutch1.unitTorque else clutch1.sa + clutch1.tau0 / clutch1.unitTorque);
//   clutch1.mode = if clutch1.free then 2 else if (pre(clutch1.mode) == 1 OR pre(clutch1.mode) == 2 OR clutch1.startForward) AND clutch1.w_relfric > 0.0 then 1 else if (pre(clutch1.mode) == -1 OR pre(clutch1.mode) == 2 OR clutch1.startBackward) AND clutch1.w_relfric < 0.0 then -1 else 0;
//   sin1.y = sin1.offset + (if time < sin1.startTime then 0.0 else sin1.amplitude * Modelica.Math.sin(6.28318530717959 * (sin1.freqHz * (time - sin1.startTime)) + sin1.phase));
//   J2.w = der(J2.phi);
//   J2.a = der(J2.w);
//   J2.J * J2.a = J2.flange_a.tau + J2.flange_b.tau;
//   J2.flange_a.phi = J2.phi;
//   J2.flange_b.phi = J2.phi;
//   clutch2.mue0 = Modelica.Math.tempInterpol1(0.0,{{clutch2.mue_pos[1,1],clutch2.mue_pos[1,2]}},2);
//   clutch2.w_rel = der(clutch2.phi_rel);
//   clutch2.a_rel = der(clutch2.w_rel);
//   clutch2.w_relfric = clutch2.w_rel;
//   clutch2.a_relfric = clutch2.a_rel;
//   clutch2.fn = clutch2.fn_max * clutch2.f_normalized;
//   clutch2.free = clutch2.fn <= 0.0;
//   clutch2.tau0 = clutch2.mue0 * (clutch2.cgeo * clutch2.fn);
//   clutch2.tau0_max = clutch2.peak * clutch2.tau0;
//   clutch2.tau = if clutch2.locked then clutch2.sa * clutch2.unitTorque else if clutch2.free then 0.0 else clutch2.cgeo * (clutch2.fn * (if clutch2.startForward then Modelica.Math.tempInterpol1(clutch2.w_rel,{{clutch2.mue_pos[1,1],clutch2.mue_pos[1,2]}},2) else if clutch2.startBackward then -Modelica.Math.tempInterpol1(-clutch2.w_rel,{{clutch2.mue_pos[1,1],clutch2.mue_pos[1,2]}},2) else if pre(clutch2.mode) == 1 then Modelica.Math.tempInterpol1(clutch2.w_rel,{{clutch2.mue_pos[1,1],clutch2.mue_pos[1,2]}},2) else -Modelica.Math.tempInterpol1(-clutch2.w_rel,{{clutch2.mue_pos[1,1],clutch2.mue_pos[1,2]}},2)));
//   clutch2.flange_a.tau = -clutch2.tau;
//   clutch2.flange_b.tau = clutch2.tau;
//   clutch2.phi_rel = clutch2.flange_b.phi - clutch2.flange_a.phi;
//   clutch2.startForward = pre(clutch2.mode) == 0 AND (clutch2.sa > clutch2.tau0_max OR pre(clutch2.startForward) AND clutch2.sa > clutch2.tau0) OR pre(clutch2.mode) == -1 AND clutch2.w_relfric > clutch2.w_small OR initial() AND clutch2.w_relfric > 0.0;
//   clutch2.startBackward = pre(clutch2.mode) == 0 AND (clutch2.sa < -clutch2.tau0_max OR pre(clutch2.startBackward) AND clutch2.sa < -clutch2.tau0) OR pre(clutch2.mode) == 1 AND clutch2.w_relfric < -clutch2.w_small OR initial() AND clutch2.w_relfric < 0.0;
//   clutch2.locked =  NOT clutch2.free AND  NOT (pre(clutch2.mode) == 1 OR clutch2.startForward OR pre(clutch2.mode) == -1 OR clutch2.startBackward);
//   clutch2.a_relfric = clutch2.unitAngularAcceleration * (if clutch2.locked then 0.0 else if clutch2.free then clutch2.sa else if clutch2.startForward then clutch2.sa - clutch2.tau0_max / clutch2.unitTorque else if clutch2.startBackward then clutch2.sa + clutch2.tau0_max / clutch2.unitTorque else if pre(clutch2.mode) == 1 then clutch2.sa - clutch2.tau0 / clutch2.unitTorque else clutch2.sa + clutch2.tau0 / clutch2.unitTorque);
//   clutch2.mode = if clutch2.free then 2 else if (pre(clutch2.mode) == 1 OR pre(clutch2.mode) == 2 OR clutch2.startForward) AND clutch2.w_relfric > 0.0 then 1 else if (pre(clutch2.mode) == -1 OR pre(clutch2.mode) == 2 OR clutch2.startBackward) AND clutch2.w_relfric < 0.0 then -1 else 0;
//   J3.w = der(J3.phi);
//   J3.a = der(J3.w);
//   J3.J * J3.a = J3.flange_a.tau + J3.flange_b.tau;
//   J3.flange_a.phi = J3.phi;
//   J3.flange_b.phi = J3.phi;
//   clutch3.mue0 = Modelica.Math.tempInterpol1(0.0,{{clutch3.mue_pos[1,1],clutch3.mue_pos[1,2]}},2);
//   clutch3.w_rel = der(clutch3.phi_rel);
//   clutch3.a_rel = der(clutch3.w_rel);
//   clutch3.w_relfric = clutch3.w_rel;
//   clutch3.a_relfric = clutch3.a_rel;
//   clutch3.fn = clutch3.fn_max * clutch3.f_normalized;
//   clutch3.free = clutch3.fn <= 0.0;
//   clutch3.tau0 = clutch3.mue0 * (clutch3.cgeo * clutch3.fn);
//   clutch3.tau0_max = clutch3.peak * clutch3.tau0;
//   clutch3.tau = if clutch3.locked then clutch3.sa * clutch3.unitTorque else if clutch3.free then 0.0 else clutch3.cgeo * (clutch3.fn * (if clutch3.startForward then Modelica.Math.tempInterpol1(clutch3.w_rel,{{clutch3.mue_pos[1,1],clutch3.mue_pos[1,2]}},2) else if clutch3.startBackward then -Modelica.Math.tempInterpol1(-clutch3.w_rel,{{clutch3.mue_pos[1,1],clutch3.mue_pos[1,2]}},2) else if pre(clutch3.mode) == 1 then Modelica.Math.tempInterpol1(clutch3.w_rel,{{clutch3.mue_pos[1,1],clutch3.mue_pos[1,2]}},2) else -Modelica.Math.tempInterpol1(-clutch3.w_rel,{{clutch3.mue_pos[1,1],clutch3.mue_pos[1,2]}},2)));
//   clutch3.flange_a.tau = -clutch3.tau;
//   clutch3.flange_b.tau = clutch3.tau;
//   clutch3.phi_rel = clutch3.flange_b.phi - clutch3.flange_a.phi;
//   clutch3.startForward = pre(clutch3.mode) == 0 AND (clutch3.sa > clutch3.tau0_max OR pre(clutch3.startForward) AND clutch3.sa > clutch3.tau0) OR pre(clutch3.mode) == -1 AND clutch3.w_relfric > clutch3.w_small OR initial() AND clutch3.w_relfric > 0.0;
//   clutch3.startBackward = pre(clutch3.mode) == 0 AND (clutch3.sa < -clutch3.tau0_max OR pre(clutch3.startBackward) AND clutch3.sa < -clutch3.tau0) OR pre(clutch3.mode) == 1 AND clutch3.w_relfric < -clutch3.w_small OR initial() AND clutch3.w_relfric < 0.0;
//   clutch3.locked =  NOT clutch3.free AND  NOT (pre(clutch3.mode) == 1 OR clutch3.startForward OR pre(clutch3.mode) == -1 OR clutch3.startBackward);
//   clutch3.a_relfric = clutch3.unitAngularAcceleration * (if clutch3.locked then 0.0 else if clutch3.free then clutch3.sa else if clutch3.startForward then clutch3.sa - clutch3.tau0_max / clutch3.unitTorque else if clutch3.startBackward then clutch3.sa + clutch3.tau0_max / clutch3.unitTorque else if pre(clutch3.mode) == 1 then clutch3.sa - clutch3.tau0 / clutch3.unitTorque else clutch3.sa + clutch3.tau0 / clutch3.unitTorque);
//   clutch3.mode = if clutch3.free then 2 else if (pre(clutch3.mode) == 1 OR pre(clutch3.mode) == 2 OR clutch3.startForward) AND clutch3.w_relfric > 0.0 then 1 else if (pre(clutch3.mode) == -1 OR pre(clutch3.mode) == 2 OR clutch3.startBackward) AND clutch3.w_relfric < 0.0 then -1 else 0;
//   J4.w = der(J4.phi);
//   J4.a = der(J4.w);
//   J4.J * J4.a = J4.flange_a.tau + J4.flange_b.tau;
//   J4.flange_a.phi = J4.phi;
//   J4.flange_b.phi = J4.phi;
//   sin2.y = sin2.offset + (if time < sin2.startTime then 0.0 else sin2.amplitude * Modelica.Math.sin(6.28318530717959 * (sin2.freqHz * (time - sin2.startTime)) + sin2.phase));
//   step1.y = step1.offset + (if time < step1.startTime then 0.0 else step1.height);
//   step2.y = step2.offset + (if time < step2.startTime then 0.0 else step2.height);
// step2.y = clutch3.f_normalized;
// step1.y = clutch2.f_normalized;
// sin2.y = clutch1.f_normalized;
//   torque.flange_b.tau + J1.flange_a.tau = 0.0;
// torque.flange_b.phi = J1.flange_a.phi;
//   J1.flange_b.tau + clutch1.flange_a.tau = 0.0;
// J1.flange_b.phi = clutch1.flange_a.phi;
//   clutch1.flange_b.tau + J2.flange_a.tau = 0.0;
// clutch1.flange_b.phi = J2.flange_a.phi;
//   J2.flange_b.tau + clutch2.flange_a.tau = 0.0;
// J2.flange_b.phi = clutch2.flange_a.phi;
//   clutch2.flange_b.tau + J3.flange_a.tau = 0.0;
// clutch2.flange_b.phi = J3.flange_a.phi;
//   J3.flange_b.tau + clutch3.flange_a.tau = 0.0;
// J3.flange_b.phi = clutch3.flange_a.phi;
//   clutch3.flange_b.tau + J4.flange_a.tau = 0.0;
// clutch3.flange_b.phi = J4.flange_a.phi;
// sin1.y = torque.tau;
//   J4.flange_b.tau = 0.0;
//   torque.bearing.tau = 0.0;
// end Modelica.Mechanics.Rotational.Examples.CoupledClutches;
// "
// ""
// endResult
