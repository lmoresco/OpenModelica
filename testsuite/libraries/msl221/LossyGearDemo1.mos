//name:         LossyGearDemo1
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Mechanics.Rotational.Examples.LossyGearDemo1);
getErrorString();
// Result:
// true
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.Math.tempInterpol2
//   input Real u "input value (first column of table)";
//   input Real[:, :] table "table to be interpolated";
//   input Integer[:] icol "column(s) of table to be interpolated";
//   output Real[1, size(icol,1)] y "interpolated input value(s) (column(s) icol of table)";
//   protected Integer i;
//   protected Integer n "number of rows of table";
//   protected Real u1;
//   protected Real u2;
//   protected Real[1, size(icol,1)] y1;
//   protected Real[1, size(icol,1)] y2;
// algorithm
//   n := size(table,1);
//   if n <= 1 then
//     y := transpose(promote(table[1,icol],1));
//   else
//     if u <= table[1,1] then
//       i := 1;
//     else
//       i := 2;
//       while i < n AND u >= table[i, 1] loop
//         i := 1 + i;
//       end while;
//       i := i - 1;
//     end if;
//     u1 := table[i, 1];
//     u2 := table[1 + i, 1];
//     y1 := transpose(promote(table[i,icol],1));
//     y2 := transpose(promote(table[1 + i,icol],1));
//     assert( u2 > u1, "Table index must be increasing");
//     y := y1 + (y2 - y1 * (u - u1)) / (u2 - u1);
//   end if;
// end Modelica.Math.tempInterpol2;
// 
// function Modelica.Mechanics.Rotational.LossyGear.equal
//   input Real[:, :] A;
//   input Real[:, :] B;
//   input Real eps = 1e-15 "two numbers r1, r2 are identical if abs(r1-r2) <= eps";
//   output Boolean result;
// algorithm
//   result := false;
//   if size(A,1) == size(B,1) AND size(A,2) == size(B,2) then
//     result := true;
//     for i in 1:size(A,1) loop
//       for j in 1:size(A,2) loop
//         if abs(A[i, j] - B[i, j]) >= eps then
//           result := false;
//         end if;
//       end for;
//     end for;
//   end if;
// end Modelica.Mechanics.Rotational.LossyGear.equal;
// 
// class Modelica.Mechanics.Rotational.Examples.LossyGearDemo1
//   Real PowerLoss(quantity = "Power", unit = "W") "power lost in the gear";
//   Real gear.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real gear.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real gear.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real gear.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real gear.tau_support(quantity = "Torque", unit = "N.m");
//   Real gear.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real gear.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real gear.phi_a(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   Real gear.phi_b(quantity = "Angle", unit = "rad", displayUnit = "deg");
//   parameter Real gear.i = 2.0 "Transmission ratio (flange_a.phi/flange_b.phi)";
//   parameter Real gear.lossTable[1,1] = 0.0 "Array for mesh efficiencies and bearing friction depending on speed";
//   parameter Real gear.lossTable[1,2] = 0.5 "Array for mesh efficiencies and bearing friction depending on speed";
//   parameter Real gear.lossTable[1,3] = 0.5 "Array for mesh efficiencies and bearing friction depending on speed";
//   parameter Real gear.lossTable[1,4] = 0.0 "Array for mesh efficiencies and bearing friction depending on speed";
//   parameter Real gear.lossTable[1,5] = 0.0 "Array for mesh efficiencies and bearing friction depending on speed";
//   Real gear.sa "path parameter for acceleration and torque loss";
//   Real gear.w_a(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "angular velocity of flange_a";
//   Real gear.a_a(quantity = "AngularAcceleration", unit = "rad/s2") "angular acceleration of flange_a";
//   Real gear.interpolation_result[1,1];
//   Real gear.interpolation_result[1,2];
//   Real gear.interpolation_result[1,3];
//   Real gear.interpolation_result[1,4];
//   Real gear.eta_mf1;
//   Real gear.eta_mf2;
//   Real gear.tau_bf1;
//   Real gear.tau_bf2;
//   Real gear.quadrant1;
//   Real gear.quadrant2;
//   Real gear.quadrant3;
//   Real gear.quadrant4;
//   Real gear.tauLoss(quantity = "Torque", unit = "N.m") "Torque loss due to friction in the gear teeth and in the bearings";
//   Real gear.tauLossMax(quantity = "Torque", unit = "N.m") "Torque loss for positive speed";
//   Real gear.tauLossMin(quantity = "Torque", unit = "N.m") "Torque loss for negative speed";
//   Boolean gear.tau_aPos "true, if torque of flange_a is not negative";
//   Boolean gear.startForward "true, if starting to roll forward";
//   Boolean gear.startBackward "true, if starting to roll backward";
//   Boolean gear.locked "true, if gear is locked";
//   Boolean gear.ideal "true, if losses are neglected";
//   constant Integer gear.Unknown = 3 "Value of mode is not known";
//   constant Integer gear.Free = 2 "Element is not active";
//   constant Integer gear.Forward = 1 "w_a > 0 (forward rolling)";
//   constant Integer gear.Stuck = 0 "w_a = 0 (forward rolling, locked or backward rolling)";
//   constant Integer gear.Backward = -1 "w_a < 0 (backward rolling)";
//   Integer gear.mode(min = -1, max = 3, start = 2, fixed = true);
//   protected parameter Real gear.unitTorque(quantity = "Torque", unit = "N.m") = 1.0;
//   protected parameter Real gear.unitAcceleration(quantity = "AngularAcceleration", unit = "rad/s2") = 1.0;
//   Real Inertia1.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = Inertia1.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real Inertia1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real Inertia1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real Inertia1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real Inertia1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real Inertia1.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.0 "Moment of inertia";
//   parameter Integer Inertia1.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real Inertia1.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real Inertia1.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real Inertia1.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer Inertia1.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real Inertia1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = Inertia1.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real Inertia1.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   Real Inertia2.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = Inertia2.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real Inertia2.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real Inertia2.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real Inertia2.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real Inertia2.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real Inertia2.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = 1.5 "Moment of inertia";
//   parameter Integer Inertia2.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real Inertia2.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real Inertia2.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real Inertia2.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer Inertia2.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real Inertia2.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = Inertia2.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real Inertia2.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   input Real torque1.tau(quantity = "Torque", unit = "N.m") "Torque driving the flange (a positive value accelerates the flange)";
//   Real torque1.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque1.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real torque1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   input Real torque2.tau(quantity = "Torque", unit = "N.m") "Torque driving the flange (a positive value accelerates the flange)";
//   Real torque2.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque2.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real torque2.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real torque2.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real DriveSine.y "Connector of Real output signal";
//   parameter Real DriveSine.amplitude = 10.0 "Amplitude of sine wave";
//   parameter Real DriveSine.freqHz(quantity = "Frequency", unit = "Hz") = 1.0 "Frequency of sine wave";
//   parameter Real DriveSine.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
//   parameter Real DriveSine.offset = 0.0 "Offset of output signal";
//   parameter Real DriveSine.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
//   protected constant Real DriveSine.pi = 3.14159265358979;
//   output Real load.y "Connector of Real output signal";
//   parameter Real load.height = 5.0 "Height of ramps";
//   parameter Real load.duration(min = 1e-60) = 2.0 "Durations of ramp";
//   parameter Real load.offset = -10.0 "Offset of output signal";
//   parameter Real load.startTime(quantity = "Time", unit = "s") = 0.0 "Output = offset for time < startTime";
// equation
//   assert(abs(gear.i) > 0.0,"Error in initialization of LossyGear: i may not be zero");
//   gear.ideal = Modelica.Mechanics.Rotational.LossyGear.equal({{gear.lossTable[1,1],gear.lossTable[1,2],gear.lossTable[1,3],gear.lossTable[1,4],gear.lossTable[1,5]}},{{0.0,1.0,1.0,0.0,0.0}},1e-15);
//   gear.interpolation_result = if gear.ideal then {{1.0,1.0,0.0,0.0}} else Modelica.Math.tempInterpol2(abs(gear.w_a),{{gear.lossTable[1,1],gear.lossTable[1,2],gear.lossTable[1,3],gear.lossTable[1,4],gear.lossTable[1,5]}},{2,3,4,5});
//   gear.eta_mf1 = gear.interpolation_result[1,1];
//   gear.eta_mf2 = gear.interpolation_result[1,2];
//   gear.tau_bf1 = abs(gear.interpolation_result[1,3]);
//   gear.tau_bf2 = abs(gear.interpolation_result[1,4]);
//   gear.phi_a = gear.i * gear.phi_b;
//   0.0 = gear.flange_b.tau + gear.i * (gear.flange_a.tau - gear.tauLoss);
//   gear.w_a = der(gear.phi_a);
//   gear.a_a = der(gear.w_a);
//   gear.quadrant1 = (1.0 - gear.eta_mf1) * gear.flange_a.tau + gear.tau_bf1;
//   gear.quadrant2 = (1.0 - 1.0 / gear.eta_mf2) * gear.flange_a.tau + gear.tau_bf2;
//   gear.quadrant4 = (1.0 - 1.0 / gear.eta_mf2) * gear.flange_a.tau - gear.tau_bf2;
//   gear.quadrant3 = (1.0 - gear.eta_mf1) * gear.flange_a.tau - gear.tau_bf1;
//   gear.tau_aPos = gear.ideal OR gear.flange_a.tau >= 0.0;
//   gear.tauLossMax = if gear.tau_aPos then gear.quadrant1 else gear.quadrant2;
//   gear.tauLossMin = if gear.tau_aPos then gear.quadrant4 else gear.quadrant3;
//   gear.startForward = pre(gear.mode) == 0 AND gear.sa > gear.tauLossMax / gear.unitTorque OR initial() AND gear.w_a > 0.0;
//   gear.startBackward = pre(gear.mode) == 0 AND gear.sa < gear.tauLossMin / gear.unitTorque OR initial() AND gear.w_a < 0.0;
//   gear.locked =  NOT (gear.ideal OR pre(gear.mode) == 1 OR gear.startForward OR pre(gear.mode) == -1 OR gear.startBackward);
//   gear.tauLoss = if gear.ideal then 0.0 else if gear.locked then gear.sa * gear.unitTorque else if gear.startForward OR pre(gear.mode) == 1 then gear.tauLossMax else gear.tauLossMin;
//   gear.a_a = gear.unitAcceleration * (if gear.locked then 0.0 else gear.sa - gear.tauLoss / gear.unitTorque);
//   gear.mode = if gear.ideal then 2 else if (pre(gear.mode) == 1 OR gear.startForward) AND gear.w_a > 0.0 then 1 else if (pre(gear.mode) == -1 OR gear.startBackward) AND gear.w_a < 0.0 then -1 else 0;
//   gear.bearing.phi = 0.0;
//   0.0 = gear.flange_a.tau + (gear.flange_b.tau + gear.tau_support);
//   gear.phi_a = gear.flange_a.phi - gear.bearing.phi;
//   gear.phi_b = gear.flange_b.phi - gear.bearing.phi;
//   Inertia1.w = der(Inertia1.phi);
//   Inertia1.a = der(Inertia1.w);
//   Inertia1.J * Inertia1.a = Inertia1.flange_a.tau + Inertia1.flange_b.tau;
//   Inertia1.flange_a.phi = Inertia1.phi;
//   Inertia1.flange_b.phi = Inertia1.phi;
//   Inertia2.w = der(Inertia2.phi);
//   Inertia2.a = der(Inertia2.w);
//   Inertia2.J * Inertia2.a = Inertia2.flange_a.tau + Inertia2.flange_b.tau;
//   Inertia2.flange_a.phi = Inertia2.phi;
//   Inertia2.flange_b.phi = Inertia2.phi;
//   torque1.flange_b.tau = -torque1.tau;
//   torque1.bearing.phi = 0.0;
//   torque2.flange_b.tau = -torque2.tau;
//   torque2.bearing.phi = 0.0;
//   DriveSine.y = DriveSine.offset + (if time < DriveSine.startTime then 0.0 else DriveSine.amplitude * Modelica.Math.sin(6.28318530717959 * (DriveSine.freqHz * (time - DriveSine.startTime)) + DriveSine.phase));
//   load.y = load.offset + (if time < load.startTime then 0.0 else if time < load.startTime + load.duration then ((time - load.startTime) * load.height) / load.duration else load.height);
//   PowerLoss = gear.flange_a.tau * der(gear.flange_a.phi) + gear.flange_b.tau * der(gear.flange_b.phi);
//   Inertia1.flange_b.tau + gear.flange_a.tau = 0.0;
//   Inertia1.flange_b.phi = gear.flange_a.phi;
//   gear.flange_b.tau + Inertia2.flange_a.tau = 0.0;
//   Inertia2.flange_a.phi = gear.flange_b.phi;
//   torque1.flange_b.tau + Inertia1.flange_a.tau = 0.0;
//   Inertia1.flange_a.phi = torque1.flange_b.phi;
//   torque2.flange_b.tau + Inertia2.flange_b.tau = 0.0;
//   Inertia2.flange_b.phi = torque2.flange_b.phi;
//   DriveSine.y = torque1.tau;
//   load.y = torque2.tau;
//   torque2.bearing.tau = 0.0;
//   torque1.bearing.tau = 0.0;
//   gear.bearing.tau = 0.0;
// end Modelica.Mechanics.Rotational.Examples.LossyGearDemo1;
// "
// ""
// endResult
