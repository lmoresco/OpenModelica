//name:         DCSE_start
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Machines.Examples.DCSE_start);
getErrorString();
// Result:
// true
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = "Angle", unit = "rad", displayUnit = "deg");
// 
// external "C";
// end Modelica.Math.asin;
// 
// function Modelica.SIunits.Conversions.from_rpm
//   input Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
//   output Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// algorithm
//   rs := 0.10471975511966 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm
//   input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
//   output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.DCSE_start
//   parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
//   parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
//   parameter Real T_Load(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
//   parameter Real rpmLoad(quantity = "AngularVelocity", unit = "rev/min") = 1402.5 "nominal load speed";
//   parameter Real J_Load(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
//   parameter Real DCSE1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "rotor's moment of inertia";
//   output Real DCSE1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = DCSE1.flange_a.phi "mechanical angle of rotor against stator";
//   output Real DCSE1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(DCSE1.phi_mechanical) "mechanical angular velocity of rotor against stator";
//   output Real DCSE1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(DCSE1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
//   output Real DCSE1.tau_electrical(quantity = "Torque", unit = "N.m") = DCSE1.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real DCSE1.tau_shaft(quantity = "Torque", unit = "N.m") = -DCSE1.flange_a.tau "shaft torque";
//   Real DCSE1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCSE1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = DCSE1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real DCSE1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCSE1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real DCSE1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = DCSE1.J_Rotor "Moment of inertia";
//   parameter Integer DCSE1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real DCSE1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real DCSE1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real DCSE1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer DCSE1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real DCSE1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = DCSE1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real DCSE1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   parameter Real DCSE1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real DCSE1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCSE1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real DCSE1.va(quantity = "ElectricPotential", unit = "V") = DCSE1.pin_ap.v - DCSE1.pin_an.v "armature voltage";
//   output Real DCSE1.ia(quantity = "ElectricCurrent", unit = "A") = DCSE1.pin_ap.i "armature current";
//   Real DCSE1.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCSE1.VaNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "|Nominal parameters|nominal armature voltage";
//   parameter Real DCSE1.IaNominal(quantity = "ElectricCurrent", unit = "A") = 100.0 "|Nominal parameters|nominal armature current";
//   parameter Real DCSE1.rpmNominal(quantity = "AngularVelocity", unit = "rev/min") = 1402.5 "|Nominal parameters|nominal speed";
//   parameter Real DCSE1.Ra(quantity = "Resistance", unit = "Ohm") = 0.05 "|Nominal resistances and inductances|warm armature resistance";
//   parameter Real DCSE1.La(quantity = "Inductance", unit = "H") = 0.0015 "|Nominal resistances and inductances|armature inductance";
//   parameter Real DCSE1.Re(quantity = "Resistance", unit = "Ohm") = 0.01 "|Excitation|warm field excitation resistance";
//   parameter Real DCSE1.Le(quantity = "Inductance", unit = "H") = 0.0005 "|Excitation|total field excitation inductance";
//   output Real DCSE1.ve(quantity = "ElectricPotential", unit = "V") = DCSE1.pin_ep.v - DCSE1.pin_en.v "Field excitation voltage";
//   output Real DCSE1.ie(quantity = "ElectricCurrent", unit = "A") = DCSE1.pin_ep.i "Field excitation current";
//   Real DCSE1.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCSE1.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCSE1.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCSE1.ra.R(quantity = "Resistance", unit = "Ohm") = DCSE1.Ra "Resistance";
//   Real DCSE1.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCSE1.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCSE1.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCSE1.la.L(quantity = "Inductance", unit = "H") = DCSE1.La "Inductance";
//   Real DCSE1.re.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCSE1.re.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCSE1.re.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.re.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.re.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.re.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCSE1.re.R(quantity = "Resistance", unit = "Ohm") = DCSE1.Re "Resistance";
//   Real DCSE1.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCSE1.airGapDC.Le(quantity = "Inductance", unit = "H") = DCSE1.Le "Excitation inductance";
//   parameter Real DCSE1.airGapDC.TurnsRatio = DCSE1.TurnsRatio "Ratio of armature turns over number of turns of the excitation winding";
//   Real DCSE1.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Angluar velocity";
//   Real DCSE1.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
//   Real DCSE1.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
//   Real DCSE1.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
//   Real DCSE1.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
//   Real DCSE1.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
//   output Real DCSE1.airGapDC.tau_electrical(quantity = "Torque", unit = "N.m");
//   Real DCSE1.airGapDC.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.airGapDC.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCSE1.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCSE1.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCSE1.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCSE1.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCSE1.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   protected parameter Real DCSE1.TurnsRatio = (DCSE1.VaNominal - (DCSE1.Ra + DCSE1.Re) * DCSE1.IaNominal) * 1.0 / DCSE1.IaNominal / DCSE1.Le / Modelica.SIunits.Conversions.from_rpm(DCSE1.rpmNominal) "Ratio of armature turns over number of turns of the excitation winding";
//   output Real Ramp1.y "Connector of Real output signal";
//   parameter Real Ramp1.height = Va "Height of ramps";
//   parameter Real Ramp1.duration(min = 1e-60) = tRamp "Durations of ramp";
//   parameter Real Ramp1.offset = 0.0 "Offset of output signal";
//   parameter Real Ramp1.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
//   Real SignalVoltage1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SignalVoltage1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
//   Real LoadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = LoadInertia.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real LoadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real LoadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real LoadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = J_Load "Moment of inertia";
//   parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real LoadInertia.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real LoadInertia.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real LoadInertia.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real LoadInertia.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = LoadInertia.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real LoadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   Real QuadraticLoadTorque1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(QuadraticLoadTorque1.flange.phi) "Angular velocity at flange";
//   Real QuadraticLoadTorque1.tau(quantity = "Torque", unit = "N.m") = QuadraticLoadTorque1.flange.tau "accelerating torque acting at flange";
//   Real QuadraticLoadTorque1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real QuadraticLoadTorque1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real QuadraticLoadTorque1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real QuadraticLoadTorque1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real QuadraticLoadTorque1.tau_nominal(quantity = "Torque", unit = "N.m") = -T_Load "nominal torque (if negative, torque is acting as load)";
//   parameter Boolean QuadraticLoadTorque1.TorqueDirection = true "same direction of torque in both directions of rotation";
//   parameter Real QuadraticLoadTorque1.w_nominal(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", min = 1e-15) = Modelica.SIunits.Conversions.from_rpm(rpmLoad) "nominal speed";
//   Real Grounda.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Grounda.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// equation
//   DCSE1.inertiaRotor.w = der(DCSE1.inertiaRotor.phi);
//   DCSE1.inertiaRotor.a = der(DCSE1.inertiaRotor.w);
//   DCSE1.inertiaRotor.J * DCSE1.inertiaRotor.a = DCSE1.inertiaRotor.flange_a.tau + DCSE1.inertiaRotor.flange_b.tau;
//   DCSE1.inertiaRotor.flange_a.phi = DCSE1.inertiaRotor.phi;
//   DCSE1.inertiaRotor.flange_b.phi = DCSE1.inertiaRotor.phi;
//   DCSE1.fixedHousing.flange_b.phi = DCSE1.fixedHousing.phi0;
//   DCSE1.ra.R * DCSE1.ra.i = DCSE1.ra.v;
//   DCSE1.ra.v = DCSE1.ra.p.v - DCSE1.ra.n.v;
//   0.0 = DCSE1.ra.p.i + DCSE1.ra.n.i;
//   DCSE1.ra.i = DCSE1.ra.p.i;
//   DCSE1.la.L * der(DCSE1.la.i) = DCSE1.la.v;
//   DCSE1.la.v = DCSE1.la.p.v - DCSE1.la.n.v;
//   0.0 = DCSE1.la.p.i + DCSE1.la.n.i;
//   DCSE1.la.i = DCSE1.la.p.i;
//   DCSE1.re.R * DCSE1.re.i = DCSE1.re.v;
//   DCSE1.re.v = DCSE1.re.p.v - DCSE1.re.n.v;
//   0.0 = DCSE1.re.p.i + DCSE1.re.n.i;
//   DCSE1.re.i = DCSE1.re.p.i;
//   DCSE1.airGapDC.vai = DCSE1.airGapDC.pin_ap.v - DCSE1.airGapDC.pin_an.v;
//   DCSE1.airGapDC.ia = DCSE1.airGapDC.pin_ap.i;
//   DCSE1.airGapDC.ia = -DCSE1.airGapDC.pin_an.i;
//   DCSE1.airGapDC.vei = DCSE1.airGapDC.pin_ep.v - DCSE1.airGapDC.pin_en.v;
//   DCSE1.airGapDC.ie = DCSE1.airGapDC.pin_ep.i;
//   DCSE1.airGapDC.ie = -DCSE1.airGapDC.pin_en.i;
//   DCSE1.airGapDC.psi_e = DCSE1.airGapDC.Le * DCSE1.airGapDC.ie;
//   DCSE1.airGapDC.vei = der(DCSE1.airGapDC.psi_e);
//   DCSE1.airGapDC.w = der(DCSE1.airGapDC.flange_a.phi) - der(DCSE1.airGapDC.support.phi);
//   DCSE1.airGapDC.vai = DCSE1.airGapDC.TurnsRatio * (DCSE1.airGapDC.psi_e * DCSE1.airGapDC.w);
//   DCSE1.airGapDC.tau_electrical = DCSE1.airGapDC.TurnsRatio * (DCSE1.airGapDC.psi_e * DCSE1.airGapDC.ia);
//   DCSE1.airGapDC.flange_a.tau = -DCSE1.airGapDC.tau_electrical;
//   DCSE1.airGapDC.support.tau = DCSE1.airGapDC.tau_electrical;
//   assert(DCSE1.VaNominal > (DCSE1.Ra + DCSE1.Re) * DCSE1.IaNominal,"VaNominal has to be > (Ra+Re)*IaNominal");
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then ((time - Ramp1.startTime) * Ramp1.height) / Ramp1.duration else Ramp1.height);
//   SignalVoltage1.v = SignalVoltage1.p.v - SignalVoltage1.n.v;
//   0.0 = SignalVoltage1.p.i + SignalVoltage1.n.i;
//   SignalVoltage1.i = SignalVoltage1.p.i;
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   QuadraticLoadTorque1.tau = (-QuadraticLoadTorque1.tau_nominal) * (QuadraticLoadTorque1.w / QuadraticLoadTorque1.w_nominal) ^ 2.0;
//   QuadraticLoadTorque1.bearing.phi = 0.0;
//   Grounda.p.v = 0.0;
//   DCSE1.pin_en.i + (SignalVoltage1.n.i + Grounda.p.i) = 0.0;
//   DCSE1.airGapDC.pin_en.v = DCSE1.pin_en.v;
//   DCSE1.airGapDC.pin_en.v = Grounda.p.v;
//   DCSE1.airGapDC.pin_en.v = SignalVoltage1.n.v;
//   DCSE1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
//   DCSE1.flange_a.phi = DCSE1.inertiaRotor.flange_b.phi;
//   DCSE1.flange_a.phi = LoadInertia.flange_a.phi;
//   Ramp1.y = SignalVoltage1.v;
//   SignalVoltage1.p.i + DCSE1.pin_ap.i = 0.0;
//   DCSE1.pin_ap.v = DCSE1.ra.p.v;
//   DCSE1.pin_ap.v = SignalVoltage1.p.v;
//   LoadInertia.flange_b.tau + QuadraticLoadTorque1.flange.tau = 0.0;
//   LoadInertia.flange_b.phi = QuadraticLoadTorque1.flange.phi;
//   DCSE1.pin_an.i + DCSE1.pin_ep.i = 0.0;
//   DCSE1.airGapDC.pin_an.v = DCSE1.pin_an.v;
//   DCSE1.airGapDC.pin_an.v = DCSE1.pin_ep.v;
//   DCSE1.airGapDC.pin_an.v = DCSE1.re.p.v;
//   QuadraticLoadTorque1.bearing.tau = 0.0;
//   DCSE1.inertiaRotor.flange_b.tau + (-DCSE1.flange_a.tau) = 0.0;
//   DCSE1.airGapDC.support.tau + ((-DCSE1.internalSupport.tau) + DCSE1.fixedHousing.flange_b.tau) = 0.0;
//   DCSE1.airGapDC.support.phi = DCSE1.fixedHousing.flange_b.phi;
//   DCSE1.airGapDC.support.phi = DCSE1.internalSupport.phi;
//   DCSE1.airGapDC.pin_en.i + (-DCSE1.pin_en.i) = 0.0;
//   DCSE1.re.n.i + DCSE1.airGapDC.pin_ep.i = 0.0;
//   DCSE1.airGapDC.pin_ep.v = DCSE1.re.n.v;
//   DCSE1.la.n.i + DCSE1.airGapDC.pin_ap.i = 0.0;
//   DCSE1.airGapDC.pin_ap.v = DCSE1.la.n.v;
//   DCSE1.la.p.i + DCSE1.ra.n.i = 0.0;
//   DCSE1.la.p.v = DCSE1.ra.n.v;
//   DCSE1.re.p.i + (-DCSE1.pin_ep.i) = 0.0;
//   DCSE1.airGapDC.flange_a.tau + DCSE1.inertiaRotor.flange_a.tau = 0.0;
//   DCSE1.airGapDC.flange_a.phi = DCSE1.inertiaRotor.flange_a.phi;
//   (-DCSE1.pin_ap.i) + DCSE1.ra.p.i = 0.0;
//   DCSE1.airGapDC.pin_an.i + (-DCSE1.pin_an.i) = 0.0;
//   DCSE1.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCSE_start;
// "
// ""
// endResult
