//name:         ShowCompositeStep
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.StateGraph.Examples.ShowCompositeStep);
getErrorString();
// Result:
// true
// "function Modelica.StateGraph.Temporary.allTrue
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := true;
//   for i in 1:size(b,1) loop
//     result := result AND b<asub>[i];
//   end for;
// end Modelica.StateGraph.Temporary.allTrue;
// 
// function Modelica.StateGraph.Temporary.anyTrue
//   input Boolean[:] b;
//   output Boolean result;
// algorithm
//   result := false;
//   for i in 1:size(b,1) loop
//     result := result OR b<asub>[i];
//   end for;
// end Modelica.StateGraph.Temporary.anyTrue;
// 
// fclass Modelica.StateGraph.Examples.ShowCompositeStep
//   output Boolean stateGraphRoot.suspend = false;
//   output Boolean stateGraphRoot.resume = false;
//   output Boolean stateGraphRoot.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   output Boolean stateGraphRoot.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   input Real stateGraphRoot.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   output Integer stateGraphRoot.activeSteps "Number of active steps within the stategraph";
//   output Boolean compositeStep.stateGraphRoot.suspend = Modelica.StateGraph.Temporary.anyTrue({compositeStep.suspend[1].reset}) OR compositeStep.outerState.subgraphStatePort.suspend;
//   output Boolean compositeStep.stateGraphRoot.resume = Modelica.StateGraph.Temporary.anyTrue({compositeStep.resume[1].set}) OR compositeStep.outerState.subgraphStatePort.resume;
//   output Boolean compositeStep.stateGraphRoot.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   output Boolean compositeStep.stateGraphRoot.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   input Real compositeStep.stateGraphRoot.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   parameter Integer compositeStep.nSuspend = 1 "Number of suspend ports";
//   parameter Integer compositeStep.nResume = 1 "Number of resume ports";
//   output Boolean compositeStep.active "= true if step is active, otherwise the step is not active";
//   input Boolean compositeStep.outerState.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.outerState.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.outerState.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   output Boolean compositeStep.inPort.occupied "true, if step is active";
//   input Boolean compositeStep.inPort.set "true, if transition fires and step is activated";
//   output Boolean compositeStep.outPort.available "true, if step is active";
//   input Boolean compositeStep.outPort.reset "true, if transition fires and step is deactivated";
//   output Boolean compositeStep.suspend[1].available "true, if step is active";
//   input Boolean compositeStep.suspend[1].reset "true, if transition fires and step is deactived";
//   output Boolean compositeStep.resume[1].occupied "true, if step is active";
//   input Boolean compositeStep.resume[1].set "true, if transition fires and step is activated";
//   protected Boolean compositeStep.newActive "Value of active in the next iteration";
//   protected Integer compositeStep.activeSteps "Number of active steps within the CompositeStep";
//   input Boolean compositeStep.transition3.localCondition = compositeStep.transition3.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition3.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition3.waitTime(quantity = "Time", unit = "s", min = 0.0) = 1.0 "Wait time before transition fires";
//   output Real compositeStep.transition3.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition3.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition3.fire "= true, if transition fires";
//   input Boolean compositeStep.transition3.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition3.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition3.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition3.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition3.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition3.t_dummy;
//   input Boolean compositeStep.transition3.condition = true "= true, if transition may fire (time varying expression)";
//   input Boolean compositeStep.transition4.localCondition = compositeStep.transition4.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition4.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition4.waitTime(quantity = "Time", unit = "s", min = 0.0) = 1.0 "Wait time before transition fires";
//   output Real compositeStep.transition4.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition4.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition4.fire "= true, if transition fires";
//   input Boolean compositeStep.transition4.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition4.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition4.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition4.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition4.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition4.t_dummy;
//   input Boolean compositeStep.transition4.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer compositeStep.step3.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer compositeStep.step3.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean compositeStep.step3.localActive = compositeStep.step3.active "= true if step is active, otherwise the step is not active";
//   output Boolean compositeStep.step3.inPort[1].occupied "true, if step is active";
//   input Boolean compositeStep.step3.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.step3.outPort[1].available "true, if step is active";
//   input Boolean compositeStep.step3.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean compositeStep.step3.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.step3.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.step3.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean compositeStep.step3.newActive "Value of active in the next iteration";
//   protected Boolean compositeStep.step3.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean compositeStep.step3.active "= true if step is active, otherwise the step is not active";
//   parameter Integer compositeStep.step4.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer compositeStep.step4.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean compositeStep.step4.localActive = compositeStep.step4.active "= true if step is active, otherwise the step is not active";
//   output Boolean compositeStep.step4.inPort[1].occupied "true, if step is active";
//   input Boolean compositeStep.step4.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.step4.outPort[1].available "true, if step is active";
//   input Boolean compositeStep.step4.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean compositeStep.step4.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.step4.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.step4.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean compositeStep.step4.newActive "Value of active in the next iteration";
//   protected Boolean compositeStep.step4.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean compositeStep.step4.active "= true if step is active, otherwise the step is not active";
//   input Boolean compositeStep.transition5.localCondition = compositeStep.transition5.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition5.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition5.waitTime(quantity = "Time", unit = "s", min = 0.0) = 2.0 "Wait time before transition fires";
//   output Real compositeStep.transition5.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition5.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition5.fire "= true, if transition fires";
//   input Boolean compositeStep.transition5.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition5.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition5.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition5.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition5.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition5.t_dummy;
//   input Boolean compositeStep.transition5.condition = true "= true, if transition may fire (time varying expression)";
//   input Boolean compositeStep.transition6.localCondition = compositeStep.transition6.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition6.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition6.waitTime(quantity = "Time", unit = "s", min = 0.0) = 2.0 "Wait time before transition fires";
//   output Real compositeStep.transition6.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition6.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition6.fire "= true, if transition fires";
//   input Boolean compositeStep.transition6.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition6.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition6.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition6.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition6.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition6.t_dummy;
//   input Boolean compositeStep.transition6.condition = true "= true, if transition may fire (time varying expression)";
//   input Boolean compositeStep.transition4a.localCondition = compositeStep.transition4a.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition4a.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition4a.waitTime(quantity = "Time", unit = "s", min = 0.0) = 1.0 "Wait time before transition fires";
//   output Real compositeStep.transition4a.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition4a.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition4a.fire "= true, if transition fires";
//   input Boolean compositeStep.transition4a.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition4a.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition4a.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition4a.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition4a.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition4a.t_dummy;
//   input Boolean compositeStep.transition4a.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer compositeStep.step4a.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer compositeStep.step4a.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean compositeStep.step4a.localActive = compositeStep.step4a.active "= true if step is active, otherwise the step is not active";
//   output Boolean compositeStep.step4a.inPort[1].occupied "true, if step is active";
//   input Boolean compositeStep.step4a.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.step4a.outPort[1].available "true, if step is active";
//   input Boolean compositeStep.step4a.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean compositeStep.step4a.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.step4a.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.step4a.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean compositeStep.step4a.newActive "Value of active in the next iteration";
//   protected Boolean compositeStep.step4a.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean compositeStep.step4a.active "= true if step is active, otherwise the step is not active";
//   input Boolean compositeStep.transition6a.localCondition = compositeStep.transition6a.condition "= true, if transition may fire";
//   parameter Boolean compositeStep.transition6a.enableTimer = true "= true, if timer is enabled";
//   parameter Real compositeStep.transition6a.waitTime(quantity = "Time", unit = "s", min = 0.0) = 2.0 "Wait time before transition fires";
//   output Real compositeStep.transition6a.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean compositeStep.transition6a.enableFire "= true, if all firing conditions are true";
//   output Boolean compositeStep.transition6a.fire "= true, if transition fires";
//   input Boolean compositeStep.transition6a.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.transition6a.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.transition6a.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.transition6a.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real compositeStep.transition6a.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real compositeStep.transition6a.t_dummy;
//   input Boolean compositeStep.transition6a.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer compositeStep.initStep.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer compositeStep.initStep.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean compositeStep.initStep.localActive = compositeStep.initStep.active "= true if step is active, otherwise the step is not active";
//   output Boolean compositeStep.initStep.inPort[1].occupied "true, if step is active";
//   input Boolean compositeStep.initStep.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.initStep.outPort[1].available "true, if step is active";
//   input Boolean compositeStep.initStep.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean compositeStep.initStep.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.initStep.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.initStep.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean compositeStep.initStep.newActive "Value of active in the next iteration";
//   protected Boolean compositeStep.initStep.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean compositeStep.initStep.active "= true if step is active, otherwise the step is not active";
//   parameter Integer compositeStep.exitStep.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer compositeStep.exitStep.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean compositeStep.exitStep.localActive = compositeStep.exitStep.active "= true if step is active, otherwise the step is not active";
//   output Boolean compositeStep.exitStep.inPort[1].occupied "true, if step is active";
//   input Boolean compositeStep.exitStep.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.exitStep.outPort[1].available "true, if step is active";
//   input Boolean compositeStep.exitStep.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean compositeStep.exitStep.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean compositeStep.exitStep.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real compositeStep.exitStep.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean compositeStep.exitStep.newActive "Value of active in the next iteration";
//   protected Boolean compositeStep.exitStep.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean compositeStep.exitStep.active "= true if step is active, otherwise the step is not active";
//   parameter Integer compositeStep.Alternative1.nBranches(min = 1) = 3 "Number of alternative branches";
//   input Boolean compositeStep.Alternative1.inPort.available "true, if step connected to the transition input is active";
//   output Boolean compositeStep.Alternative1.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean compositeStep.Alternative1.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean compositeStep.Alternative1.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   output Boolean compositeStep.Alternative1.join[1].occupied "true, if step is active";
//   input Boolean compositeStep.Alternative1.join[1].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.Alternative1.join[2].occupied "true, if step is active";
//   input Boolean compositeStep.Alternative1.join[2].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.Alternative1.join[3].occupied "true, if step is active";
//   input Boolean compositeStep.Alternative1.join[3].set "true, if transition fires and step is activated";
//   output Boolean compositeStep.Alternative1.split[1].available "true, if step is active";
//   input Boolean compositeStep.Alternative1.split[1].reset "true, if transition fires and step is deactivated";
//   output Boolean compositeStep.Alternative1.split[2].available "true, if step is active";
//   input Boolean compositeStep.Alternative1.split[2].reset "true, if transition fires and step is deactivated";
//   output Boolean compositeStep.Alternative1.split[3].available "true, if step is active";
//   input Boolean compositeStep.Alternative1.split[3].reset "true, if transition fires and step is deactivated";
//   parameter Integer step0.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer step0.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean step0.localActive = step0.active "= true if step is active, otherwise the step is not active";
//   output Boolean step0.inPort[1].occupied "true, if step is active";
//   input Boolean step0.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean step0.outPort[1].available "true, if step is active";
//   input Boolean step0.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean step0.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean step0.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real step0.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean step0.newActive "Value of active in the next iteration";
//   protected Boolean step0.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean step0.active "= true if step is active, otherwise the step is not active";
//   input Boolean transition1.localCondition = transition1.condition "= true, if transition may fire";
//   parameter Boolean transition1.enableTimer = true "= true, if timer is enabled";
//   parameter Real transition1.waitTime(quantity = "Time", unit = "s", min = 0.0) = 1.0 "Wait time before transition fires";
//   output Real transition1.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean transition1.enableFire "= true, if all firing conditions are true";
//   output Boolean transition1.fire "= true, if transition fires";
//   input Boolean transition1.inPort.available "true, if step connected to the transition input is active";
//   output Boolean transition1.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean transition1.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean transition1.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real transition1.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real transition1.t_dummy;
//   input Boolean transition1.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer step1.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer step1.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean step1.localActive = step1.active "= true if step is active, otherwise the step is not active";
//   output Boolean step1.inPort[1].occupied "true, if step is active";
//   input Boolean step1.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean step1.outPort[1].available "true, if step is active";
//   input Boolean step1.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean step1.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean step1.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real step1.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean step1.newActive "Value of active in the next iteration";
//   protected Boolean step1.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean step1.active "= true if step is active, otherwise the step is not active";
//   input Boolean transition2.localCondition = transition2.condition "= true, if transition may fire";
//   parameter Boolean transition2.enableTimer = true "= true, if timer is enabled";
//   parameter Real transition2.waitTime(quantity = "Time", unit = "s", min = 0.0) = 1.0 "Wait time before transition fires";
//   output Real transition2.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean transition2.enableFire "= true, if all firing conditions are true";
//   output Boolean transition2.fire "= true, if transition fires";
//   input Boolean transition2.inPort.available "true, if step connected to the transition input is active";
//   output Boolean transition2.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean transition2.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean transition2.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real transition2.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real transition2.t_dummy;
//   input Boolean transition2.condition = true "= true, if transition may fire (time varying expression)";
//   parameter Integer step6.nIn(min = 0) = 1 "Number of input connections";
//   parameter Integer step6.nOut(min = 0) = 1 "Number of output connections";
//   output Boolean step6.localActive = step6.active "= true if step is active, otherwise the step is not active";
//   output Boolean step6.inPort[1].occupied "true, if step is active";
//   input Boolean step6.inPort[1].set "true, if transition fires and step is activated";
//   output Boolean step6.outPort[1].available "true, if step is active";
//   input Boolean step6.outPort[1].reset "true, if transition fires and step is deactivated";
//   input Boolean step6.subgraphStatePort.suspend "= true, if suspend transition of CompositeStep fires";
//   input Boolean step6.subgraphStatePort.resume "= true, if resume transition of CompositeStep fires";
//   output Real step6.subgraphStatePort.activeSteps "Number of active steps in the CompositeStep";
//   protected Boolean step6.newActive "Value of active in the next iteration";
//   protected Boolean step6.oldActive "Value of active when CompositeStep was aborted";
//   output Boolean step6.active "= true if step is active, otherwise the step is not active";
//   input Boolean transition7.localCondition = transition7.condition "= true, if transition may fire";
//   parameter Boolean transition7.enableTimer = false "= true, if timer is enabled";
//   parameter Real transition7.waitTime(quantity = "Time", unit = "s", min = 0.0) = 0.0 "Wait time before transition fires";
//   output Real transition7.t(quantity = "Time", unit = "s") "= actual waiting time (transition will fire when t > waitTime)";
//   output Boolean transition7.enableFire "= true, if all firing conditions are true";
//   output Boolean transition7.fire "= true, if transition fires";
//   input Boolean transition7.inPort.available "true, if step connected to the transition input is active";
//   output Boolean transition7.inPort.reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean transition7.outPort.occupied "true, if step connected to the transition output is active";
//   output Boolean transition7.outPort.set "true, if transition fires and step connected to the transition output becomes active";
//   protected Real transition7.t_start(quantity = "Time", unit = "s") "Time instant at which the transition would fire, if waitTime would be zero";
//   protected Real transition7.t_dummy;
//   input Boolean transition7.condition;
//   parameter Integer Parallel1.nBranches(min = 1) = 2 "Number of parallel branches that are executed in parallel";
//   output Boolean Parallel1.inPort.occupied "true, if step is active";
//   input Boolean Parallel1.inPort.set "true, if transition fires and step is activated";
//   output Boolean Parallel1.outPort.available "true, if step is active";
//   input Boolean Parallel1.outPort.reset "true, if transition fires and step is deactivated";
//   input Boolean Parallel1.join[1].available "true, if step connected to the transition input is active";
//   output Boolean Parallel1.join[1].reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean Parallel1.join[2].available "true, if step connected to the transition input is active";
//   output Boolean Parallel1.join[2].reset "true, if transition fires and the step connected to the transition input is deactivated";
//   input Boolean Parallel1.split[1].occupied "true, if step connected to the transition output is active";
//   output Boolean Parallel1.split[1].set "true, if transition fires and step connected to the transition output becomes active";
//   input Boolean Parallel1.split[2].occupied "true, if step connected to the transition output is active";
//   output Boolean Parallel1.split[2].set "true, if transition fires and step connected to the transition output becomes active";
//   output Boolean setCondition.y = time > 7.0 "Value of Boolean output";
// initial equation
//   pre(compositeStep.transition3.enableFire) = false;
//   pre(compositeStep.transition4.enableFire) = false;
//   compositeStep.step3.active = false;
//   pre(compositeStep.step3.newActive) = pre(compositeStep.step3.localActive);
//   pre(compositeStep.step3.oldActive) = pre(compositeStep.step3.localActive);
//   compositeStep.step4.active = false;
//   pre(compositeStep.step4.newActive) = pre(compositeStep.step4.localActive);
//   pre(compositeStep.step4.oldActive) = pre(compositeStep.step4.localActive);
//   pre(compositeStep.transition5.enableFire) = false;
//   pre(compositeStep.transition6.enableFire) = false;
//   pre(compositeStep.transition4a.enableFire) = false;
//   compositeStep.step4a.active = false;
//   pre(compositeStep.step4a.newActive) = pre(compositeStep.step4a.localActive);
//   pre(compositeStep.step4a.oldActive) = pre(compositeStep.step4a.localActive);
//   pre(compositeStep.transition6a.enableFire) = false;
//   compositeStep.initStep.active = false;
//   pre(compositeStep.initStep.newActive) = pre(compositeStep.initStep.localActive);
//   pre(compositeStep.initStep.oldActive) = pre(compositeStep.initStep.localActive);
//   compositeStep.exitStep.active = false;
//   pre(compositeStep.exitStep.newActive) = pre(compositeStep.exitStep.localActive);
//   pre(compositeStep.exitStep.oldActive) = pre(compositeStep.exitStep.localActive);
//   pre(compositeStep.newActive) = pre(compositeStep.active);
//   step0.active = true;
//   pre(step0.newActive) = pre(step0.localActive);
//   pre(step0.oldActive) = pre(step0.localActive);
//   pre(transition1.enableFire) = false;
//   step1.active = false;
//   pre(step1.newActive) = pre(step1.localActive);
//   pre(step1.oldActive) = pre(step1.localActive);
//   pre(transition2.enableFire) = false;
//   step6.active = false;
//   pre(step6.newActive) = pre(step6.localActive);
//   pre(step6.oldActive) = pre(step6.localActive);
//   pre(transition7.enableFire) = false;
// equation
//   stateGraphRoot.activeSteps = -integer(stateGraphRoot.subgraphStatePort.activeSteps);
//   stateGraphRoot.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   stateGraphRoot.resume = stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.stateGraphRoot.suspend = compositeStep.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.stateGraphRoot.resume = compositeStep.stateGraphRoot.subgraphStatePort.resume;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition3.enableFire then
//   compositeStep.transition3.t_start = time;
//   end when;
//   compositeStep.transition3.t_dummy = time - compositeStep.transition3.t_start;
//   compositeStep.transition3.t = if compositeStep.transition3.enableFire then compositeStep.transition3.t_dummy else 0.0;
//   compositeStep.transition3.fire = compositeStep.transition3.enableFire AND time >= compositeStep.transition3.t_start + compositeStep.transition3.waitTime;
//   compositeStep.transition3.enableFire = compositeStep.transition3.localCondition AND compositeStep.transition3.inPort.available AND  NOT compositeStep.transition3.outPort.occupied;
//   compositeStep.transition3.inPort.reset = compositeStep.transition3.fire;
//   compositeStep.transition3.outPort.set = compositeStep.transition3.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition4.enableFire then
//   compositeStep.transition4.t_start = time;
//   end when;
//   compositeStep.transition4.t_dummy = time - compositeStep.transition4.t_start;
//   compositeStep.transition4.t = if compositeStep.transition4.enableFire then compositeStep.transition4.t_dummy else 0.0;
//   compositeStep.transition4.fire = compositeStep.transition4.enableFire AND time >= compositeStep.transition4.t_start + compositeStep.transition4.waitTime;
//   compositeStep.transition4.enableFire = compositeStep.transition4.localCondition AND compositeStep.transition4.inPort.available AND  NOT compositeStep.transition4.outPort.occupied;
//   compositeStep.transition4.inPort.reset = compositeStep.transition4.fire;
//   compositeStep.transition4.outPort.set = compositeStep.transition4.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   compositeStep.step3.localActive = pre(compositeStep.step3.newActive);
//   compositeStep.step3.newActive = if compositeStep.step3.subgraphStatePort.resume then compositeStep.step3.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.step3.inPort[1].set}) OR compositeStep.step3.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.step3.outPort[1].reset})) AND  NOT compositeStep.step3.subgraphStatePort.suspend;
//   when compositeStep.step3.subgraphStatePort.suspend then
//   compositeStep.step3.oldActive = compositeStep.step3.localActive;
//   end when;
//   compositeStep.step3.subgraphStatePort.activeSteps = if compositeStep.step3.localActive then 1.0 else 0.0;
//   compositeStep.step3.inPort[1].occupied = compositeStep.step3.localActive;
//   compositeStep.step3.outPort[1].available = compositeStep.step3.localActive;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   compositeStep.step4.localActive = pre(compositeStep.step4.newActive);
//   compositeStep.step4.newActive = if compositeStep.step4.subgraphStatePort.resume then compositeStep.step4.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.step4.inPort[1].set}) OR compositeStep.step4.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.step4.outPort[1].reset})) AND  NOT compositeStep.step4.subgraphStatePort.suspend;
//   when compositeStep.step4.subgraphStatePort.suspend then
//   compositeStep.step4.oldActive = compositeStep.step4.localActive;
//   end when;
//   compositeStep.step4.subgraphStatePort.activeSteps = if compositeStep.step4.localActive then 1.0 else 0.0;
//   compositeStep.step4.inPort[1].occupied = compositeStep.step4.localActive;
//   compositeStep.step4.outPort[1].available = compositeStep.step4.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition5.enableFire then
//   compositeStep.transition5.t_start = time;
//   end when;
//   compositeStep.transition5.t_dummy = time - compositeStep.transition5.t_start;
//   compositeStep.transition5.t = if compositeStep.transition5.enableFire then compositeStep.transition5.t_dummy else 0.0;
//   compositeStep.transition5.fire = compositeStep.transition5.enableFire AND time >= compositeStep.transition5.t_start + compositeStep.transition5.waitTime;
//   compositeStep.transition5.enableFire = compositeStep.transition5.localCondition AND compositeStep.transition5.inPort.available AND  NOT compositeStep.transition5.outPort.occupied;
//   compositeStep.transition5.inPort.reset = compositeStep.transition5.fire;
//   compositeStep.transition5.outPort.set = compositeStep.transition5.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition6.enableFire then
//   compositeStep.transition6.t_start = time;
//   end when;
//   compositeStep.transition6.t_dummy = time - compositeStep.transition6.t_start;
//   compositeStep.transition6.t = if compositeStep.transition6.enableFire then compositeStep.transition6.t_dummy else 0.0;
//   compositeStep.transition6.fire = compositeStep.transition6.enableFire AND time >= compositeStep.transition6.t_start + compositeStep.transition6.waitTime;
//   compositeStep.transition6.enableFire = compositeStep.transition6.localCondition AND compositeStep.transition6.inPort.available AND  NOT compositeStep.transition6.outPort.occupied;
//   compositeStep.transition6.inPort.reset = compositeStep.transition6.fire;
//   compositeStep.transition6.outPort.set = compositeStep.transition6.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition4a.enableFire then
//   compositeStep.transition4a.t_start = time;
//   end when;
//   compositeStep.transition4a.t_dummy = time - compositeStep.transition4a.t_start;
//   compositeStep.transition4a.t = if compositeStep.transition4a.enableFire then compositeStep.transition4a.t_dummy else 0.0;
//   compositeStep.transition4a.fire = compositeStep.transition4a.enableFire AND time >= compositeStep.transition4a.t_start + compositeStep.transition4a.waitTime;
//   compositeStep.transition4a.enableFire = compositeStep.transition4a.localCondition AND compositeStep.transition4a.inPort.available AND  NOT compositeStep.transition4a.outPort.occupied;
//   compositeStep.transition4a.inPort.reset = compositeStep.transition4a.fire;
//   compositeStep.transition4a.outPort.set = compositeStep.transition4a.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   compositeStep.step4a.localActive = pre(compositeStep.step4a.newActive);
//   compositeStep.step4a.newActive = if compositeStep.step4a.subgraphStatePort.resume then compositeStep.step4a.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.step4a.inPort[1].set}) OR compositeStep.step4a.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.step4a.outPort[1].reset})) AND  NOT compositeStep.step4a.subgraphStatePort.suspend;
//   when compositeStep.step4a.subgraphStatePort.suspend then
//   compositeStep.step4a.oldActive = compositeStep.step4a.localActive;
//   end when;
//   compositeStep.step4a.subgraphStatePort.activeSteps = if compositeStep.step4a.localActive then 1.0 else 0.0;
//   compositeStep.step4a.inPort[1].occupied = compositeStep.step4a.localActive;
//   compositeStep.step4a.outPort[1].available = compositeStep.step4a.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when compositeStep.transition6a.enableFire then
//   compositeStep.transition6a.t_start = time;
//   end when;
//   compositeStep.transition6a.t_dummy = time - compositeStep.transition6a.t_start;
//   compositeStep.transition6a.t = if compositeStep.transition6a.enableFire then compositeStep.transition6a.t_dummy else 0.0;
//   compositeStep.transition6a.fire = compositeStep.transition6a.enableFire AND time >= compositeStep.transition6a.t_start + compositeStep.transition6a.waitTime;
//   compositeStep.transition6a.enableFire = compositeStep.transition6a.localCondition AND compositeStep.transition6a.inPort.available AND  NOT compositeStep.transition6a.outPort.occupied;
//   compositeStep.transition6a.inPort.reset = compositeStep.transition6a.fire;
//   compositeStep.transition6a.outPort.set = compositeStep.transition6a.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   compositeStep.initStep.localActive = pre(compositeStep.initStep.newActive);
//   compositeStep.initStep.newActive = if compositeStep.initStep.subgraphStatePort.resume then compositeStep.initStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.initStep.inPort[1].set}) OR compositeStep.initStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.initStep.outPort[1].reset})) AND  NOT compositeStep.initStep.subgraphStatePort.suspend;
//   when compositeStep.initStep.subgraphStatePort.suspend then
//   compositeStep.initStep.oldActive = compositeStep.initStep.localActive;
//   end when;
//   compositeStep.initStep.subgraphStatePort.activeSteps = if compositeStep.initStep.localActive then 1.0 else 0.0;
//   compositeStep.initStep.inPort[1].occupied = compositeStep.initStep.localActive;
//   compositeStep.initStep.outPort[1].available = compositeStep.initStep.localActive;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   compositeStep.exitStep.localActive = pre(compositeStep.exitStep.newActive);
//   compositeStep.exitStep.newActive = if compositeStep.exitStep.subgraphStatePort.resume then compositeStep.exitStep.oldActive else (Modelica.StateGraph.Temporary.anyTrue({compositeStep.exitStep.inPort[1].set}) OR compositeStep.exitStep.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.exitStep.outPort[1].reset})) AND  NOT compositeStep.exitStep.subgraphStatePort.suspend;
//   when compositeStep.exitStep.subgraphStatePort.suspend then
//   compositeStep.exitStep.oldActive = compositeStep.exitStep.localActive;
//   end when;
//   compositeStep.exitStep.subgraphStatePort.activeSteps = if compositeStep.exitStep.localActive then 1.0 else 0.0;
//   compositeStep.exitStep.inPort[1].occupied = compositeStep.exitStep.localActive;
//   compositeStep.exitStep.outPort[1].available = compositeStep.exitStep.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   assert(true,"Connector split[1] is not connected to exactly one other connector");
//   assert(true,"Connector join[1] is not connected to exactly one other connector");
//   assert(true,"Connector split[2] is not connected to exactly one other connector");
//   assert(true,"Connector join[2] is not connected to exactly one other connector");
//   assert(true,"Connector split[3] is not connected to exactly one other connector");
//   assert(true,"Connector join[3] is not connected to exactly one other connector");
//   compositeStep.Alternative1.split[1].available = compositeStep.Alternative1.inPort.available;
//   compositeStep.Alternative1.split[2].available = compositeStep.Alternative1.split[1].available AND  NOT compositeStep.Alternative1.split[1].reset;
//   compositeStep.Alternative1.split[3].available = compositeStep.Alternative1.split[2].available AND  NOT compositeStep.Alternative1.split[2].reset;
//   compositeStep.Alternative1.join[1].occupied = compositeStep.Alternative1.outPort.occupied;
//   compositeStep.Alternative1.join[2].occupied = compositeStep.Alternative1.outPort.occupied;
//   compositeStep.Alternative1.join[3].occupied = compositeStep.Alternative1.outPort.occupied;
//   compositeStep.Alternative1.inPort.reset = Modelica.StateGraph.Temporary.anyTrue({compositeStep.Alternative1.split[1].reset,compositeStep.Alternative1.split[2].reset,compositeStep.Alternative1.split[3].reset});
//   compositeStep.Alternative1.outPort.set = Modelica.StateGraph.Temporary.anyTrue({compositeStep.Alternative1.join[1].set,compositeStep.Alternative1.join[2].set,compositeStep.Alternative1.join[3].set});
//   compositeStep.outerState.subgraphStatePort.activeSteps = if compositeStep.active then 1.0 else 0.0;
//   compositeStep.activeSteps = -integer(compositeStep.stateGraphRoot.subgraphStatePort.activeSteps);
//   compositeStep.active = pre(compositeStep.newActive);
//   compositeStep.newActive = compositeStep.activeSteps > 0 AND  NOT Modelica.StateGraph.Temporary.anyTrue({compositeStep.suspend[1].reset}) AND  NOT compositeStep.outerState.subgraphStatePort.suspend OR Modelica.StateGraph.Temporary.anyTrue({compositeStep.resume[1].set}) OR compositeStep.outerState.subgraphStatePort.resume;
//   compositeStep.resume[1].occupied = compositeStep.active;
//   compositeStep.suspend[1].available = compositeStep.active;
//   assert(true,"Connector suspend[1] of the CompositeStep is connected to more than one transition");
//   compositeStep.suspend[1].reset = false;
//   assert(true,"Connector resume[1] of the CompositeStep is connected to more than one transition");
//   compositeStep.resume[1].set = false;
//   assert(true,"Connector inPort of the CompositeStep has more than 2 connections. It should have only one connection from the outside to the inPort and one connection to a step inside the CompositeStep.");
//   assert(true,"Connector outPort of the CompositeStep has more than 2 connections. It should have only one connection from the outPort to the outside to the CompositeStep and one connection from a step inside the CompositeStep to the outPort connector.");
//   compositeStep.transition6a.outPort.set = compositeStep.Alternative1.join[3].set;
//   compositeStep.transition6a.outPort.occupied = compositeStep.Alternative1.join[3].occupied;
//   compositeStep.transition6.outPort.set = compositeStep.Alternative1.join[2].set;
//   compositeStep.transition6.outPort.occupied = compositeStep.Alternative1.join[2].occupied;
//   compositeStep.transition5.outPort.set = compositeStep.Alternative1.join[1].set;
//   compositeStep.transition5.outPort.occupied = compositeStep.Alternative1.join[1].occupied;
//   compositeStep.transition4a.inPort.reset = compositeStep.Alternative1.split[3].reset;
//   compositeStep.transition4a.inPort.available = compositeStep.Alternative1.split[3].available;
//   compositeStep.transition4.inPort.reset = compositeStep.Alternative1.split[2].reset;
//   compositeStep.transition4.inPort.available = compositeStep.Alternative1.split[2].available;
//   compositeStep.transition3.inPort.reset = compositeStep.Alternative1.split[1].reset;
//   compositeStep.transition3.inPort.available = compositeStep.Alternative1.split[1].available;
//   compositeStep.Alternative1.outPort.set = compositeStep.exitStep.inPort[1].set;
//   compositeStep.Alternative1.outPort.occupied = compositeStep.exitStep.inPort[1].occupied;
//   compositeStep.initStep.outPort[1].reset = compositeStep.Alternative1.inPort.reset;
//   compositeStep.initStep.outPort[1].available = compositeStep.Alternative1.inPort.available;
//   compositeStep.exitStep.outPort[1].reset = compositeStep.outPort.reset;
//   compositeStep.exitStep.outPort[1].available = compositeStep.outPort.available;
//   compositeStep.initStep.inPort[1].set = compositeStep.inPort.set;
//   compositeStep.initStep.inPort[1].occupied = compositeStep.inPort.occupied;
//   compositeStep.step4a.outPort[1].reset = compositeStep.transition6a.inPort.reset;
//   compositeStep.step4a.outPort[1].available = compositeStep.transition6a.inPort.available;
//   compositeStep.transition4a.outPort.set = compositeStep.step4a.inPort[1].set;
//   compositeStep.transition4a.outPort.occupied = compositeStep.step4a.inPort[1].occupied;
//   compositeStep.step4.outPort[1].reset = compositeStep.transition6.inPort.reset;
//   compositeStep.step4.outPort[1].available = compositeStep.transition6.inPort.available;
//   compositeStep.transition4.outPort.set = compositeStep.step4.inPort[1].set;
//   compositeStep.transition4.outPort.occupied = compositeStep.step4.inPort[1].occupied;
//   compositeStep.step3.outPort[1].reset = compositeStep.transition5.inPort.reset;
//   compositeStep.step3.outPort[1].available = compositeStep.transition5.inPort.available;
//   compositeStep.transition3.outPort.set = compositeStep.step3.inPort[1].set;
//   compositeStep.transition3.outPort.occupied = compositeStep.step3.inPort[1].occupied;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   step0.localActive = pre(step0.newActive);
//   step0.newActive = if step0.subgraphStatePort.resume then step0.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step0.inPort[1].set}) OR step0.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({step0.outPort[1].reset})) AND  NOT step0.subgraphStatePort.suspend;
//   when step0.subgraphStatePort.suspend then
//   step0.oldActive = step0.localActive;
//   end when;
//   step0.subgraphStatePort.activeSteps = if step0.localActive then 1.0 else 0.0;
//   step0.inPort[1].occupied = step0.localActive;
//   step0.outPort[1].available = step0.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when transition1.enableFire then
//   transition1.t_start = time;
//   end when;
//   transition1.t_dummy = time - transition1.t_start;
//   transition1.t = if transition1.enableFire then transition1.t_dummy else 0.0;
//   transition1.fire = transition1.enableFire AND time >= transition1.t_start + transition1.waitTime;
//   transition1.enableFire = transition1.localCondition AND transition1.inPort.available AND  NOT transition1.outPort.occupied;
//   transition1.inPort.reset = transition1.fire;
//   transition1.outPort.set = transition1.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   step1.localActive = pre(step1.newActive);
//   step1.newActive = if step1.subgraphStatePort.resume then step1.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step1.inPort[1].set}) OR step1.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({step1.outPort[1].reset})) AND  NOT step1.subgraphStatePort.suspend;
//   when step1.subgraphStatePort.suspend then
//   step1.oldActive = step1.localActive;
//   end when;
//   step1.subgraphStatePort.activeSteps = if step1.localActive then 1.0 else 0.0;
//   step1.inPort[1].occupied = step1.localActive;
//   step1.outPort[1].available = step1.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   when transition2.enableFire then
//   transition2.t_start = time;
//   end when;
//   transition2.t_dummy = time - transition2.t_start;
//   transition2.t = if transition2.enableFire then transition2.t_dummy else 0.0;
//   transition2.fire = transition2.enableFire AND time >= transition2.t_start + transition2.waitTime;
//   transition2.enableFire = transition2.localCondition AND transition2.inPort.available AND  NOT transition2.outPort.occupied;
//   transition2.inPort.reset = transition2.fire;
//   transition2.outPort.set = transition2.fire;
//   assert(true,"Connector inPort[1] of the step is connected to more than one transition");
//   assert(true,"Connector outPort[1] of the step is connected to more than one transition");
//   step6.localActive = pre(step6.newActive);
//   step6.newActive = if step6.subgraphStatePort.resume then step6.oldActive else (Modelica.StateGraph.Temporary.anyTrue({step6.inPort[1].set}) OR step6.localActive AND  NOT Modelica.StateGraph.Temporary.anyTrue({step6.outPort[1].reset})) AND  NOT step6.subgraphStatePort.suspend;
//   when step6.subgraphStatePort.suspend then
//   step6.oldActive = step6.localActive;
//   end when;
//   step6.subgraphStatePort.activeSteps = if step6.localActive then 1.0 else 0.0;
//   step6.inPort[1].occupied = step6.localActive;
//   step6.outPort[1].available = step6.localActive;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   transition7.t_start = 0.0;
//   transition7.t_dummy = 0.0;
//   transition7.t = 0.0;
//   transition7.fire = transition7.enableFire;
//   transition7.enableFire = transition7.localCondition AND transition7.inPort.available AND  NOT transition7.outPort.occupied;
//   transition7.inPort.reset = transition7.fire;
//   transition7.outPort.set = transition7.fire;
//   assert(true,"Connector inPort is not connected to exactly one other connector");
//   assert(true,"Connector outPort is not connected to exactly one other connector");
//   assert(true,"Connector split[1] is not connected to exactly one other connector");
//   assert(true,"Connector join[1] is not connected to exactly one other connector");
//   assert(true,"Connector split[2] is not connected to exactly one other connector");
//   assert(true,"Connector join[2] is not connected to exactly one other connector");
//   Parallel1.split[1].set = Parallel1.inPort.set;
//   Parallel1.split[2].set = Parallel1.inPort.set;
//   Parallel1.join[1].reset = Parallel1.outPort.reset;
//   Parallel1.join[2].reset = Parallel1.outPort.reset;
//   Parallel1.inPort.occupied = Modelica.StateGraph.Temporary.anyTrue({Parallel1.split[1].occupied,Parallel1.split[2].occupied});
//   Parallel1.outPort.available = Modelica.StateGraph.Temporary.allTrue({Parallel1.join[1].available,Parallel1.join[2].available});
//   compositeStep.step3.subgraphStatePort.activeSteps + (compositeStep.step4.subgraphStatePort.activeSteps + (compositeStep.step4a.subgraphStatePort.activeSteps + (compositeStep.initStep.subgraphStatePort.activeSteps + (compositeStep.exitStep.subgraphStatePort.activeSteps + compositeStep.stateGraphRoot.subgraphStatePort.activeSteps)))) = 0.0;
//   compositeStep.step3.subgraphStatePort.resume = compositeStep.step4.subgraphStatePort.resume;
//   compositeStep.step4.subgraphStatePort.resume = compositeStep.step4a.subgraphStatePort.resume;
//   compositeStep.step4a.subgraphStatePort.resume = compositeStep.initStep.subgraphStatePort.resume;
//   compositeStep.initStep.subgraphStatePort.resume = compositeStep.exitStep.subgraphStatePort.resume;
//   compositeStep.exitStep.subgraphStatePort.resume = compositeStep.stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.step3.subgraphStatePort.suspend = compositeStep.step4.subgraphStatePort.suspend;
//   compositeStep.step4.subgraphStatePort.suspend = compositeStep.step4a.subgraphStatePort.suspend;
//   compositeStep.step4a.subgraphStatePort.suspend = compositeStep.initStep.subgraphStatePort.suspend;
//   compositeStep.initStep.subgraphStatePort.suspend = compositeStep.exitStep.subgraphStatePort.suspend;
//   compositeStep.exitStep.subgraphStatePort.suspend = compositeStep.stateGraphRoot.subgraphStatePort.suspend;
//   compositeStep.outerState.subgraphStatePort.activeSteps + (step0.subgraphStatePort.activeSteps + (step1.subgraphStatePort.activeSteps + (step6.subgraphStatePort.activeSteps + stateGraphRoot.subgraphStatePort.activeSteps))) = 0.0;
//   compositeStep.outerState.subgraphStatePort.resume = step0.subgraphStatePort.resume;
//   step0.subgraphStatePort.resume = step1.subgraphStatePort.resume;
//   step1.subgraphStatePort.resume = step6.subgraphStatePort.resume;
//   step6.subgraphStatePort.resume = stateGraphRoot.subgraphStatePort.resume;
//   compositeStep.outerState.subgraphStatePort.suspend = step0.subgraphStatePort.suspend;
//   step0.subgraphStatePort.suspend = step1.subgraphStatePort.suspend;
//   step1.subgraphStatePort.suspend = step6.subgraphStatePort.suspend;
//   step6.subgraphStatePort.suspend = stateGraphRoot.subgraphStatePort.suspend;
//   step0.outPort[1].reset = transition1.inPort.reset;
//   step0.outPort[1].available = transition1.inPort.available;
//   transition7.outPort.set = step0.inPort[1].set;
//   transition7.outPort.occupied = step0.inPort[1].occupied;
//   step6.outPort[1].reset = transition7.inPort.reset;
//   step6.outPort[1].available = transition7.inPort.available;
//   transition2.outPort.set = step6.inPort[1].set;
//   transition2.outPort.occupied = step6.inPort[1].occupied;
//   transition1.outPort.set = Parallel1.inPort.set;
//   transition1.outPort.occupied = Parallel1.inPort.occupied;
//   Parallel1.outPort.reset = transition2.inPort.reset;
//   Parallel1.outPort.available = transition2.inPort.available;
//   compositeStep.inPort.set = Parallel1.split[1].set;
//   compositeStep.inPort.occupied = Parallel1.split[1].occupied;
//   compositeStep.outPort.reset = Parallel1.join[1].reset;
//   compositeStep.outPort.available = Parallel1.join[1].available;
//   step1.inPort[1].set = Parallel1.split[2].set;
//   step1.inPort[1].occupied = Parallel1.split[2].occupied;
//   step1.outPort[1].reset = Parallel1.join[2].reset;
//   step1.outPort[1].available = Parallel1.join[2].available;
//   setCondition.y = transition7.condition;
// end Modelica.StateGraph.Examples.ShowCompositeStep;
// "
// ""
// endResult
