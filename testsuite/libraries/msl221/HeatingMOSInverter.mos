//name:         HeatingMOSInverter
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Electrical.Analog.Examples.HeatingMOSInverter);
getErrorString();
// Result:
// true
// "function Modelica.Electrical.Analog.Semiconductors.pow
// input Real x;
// input Real y;
// output Real z;
// algorithm
//   z := x ^ y;
// end Modelica.Electrical.Analog.Semiconductors.pow;
// 
// function Modelica.Math.sin
// input Real u(quantity = "Angle", unit = "rad", displayUnit = "deg");
// output Real y;
// 
// external "C";
// end Modelica.Math.sin;
// 
// function Modelica.SIunits.Conversions.from_degC
// input Real Celsius(quantity = "ThermodynamicTemperature", unit = "degC") "Celsius value";
// output Real Kelvin(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Kelvin value";
// algorithm
//   Kelvin := Celsius - -273.15;
// end Modelica.SIunits.Conversions.from_degC;
// 
// fclass Modelica.Electrical.Analog.Examples.HeatingMOSInverter
// parameter Real HeatCapacitor1.C(quantity = "HeatCapacity", unit = "J/K") = 0.01 "Heat capacity of part (= cp*m)";
// parameter Boolean HeatCapacitor1.steadyStateStart = false "true, if component shall start in steady state";
// Real HeatCapacitor1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 293.15) "Temperature of part";
// Real HeatCapacitor1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real HeatCapacitor1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real TC1.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from port_a -> port_b";
// Real TC1.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "port_a.T - port_b.T";
// Real TC1.port_a.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC1.port_a.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real TC1.port_b.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC1.port_b.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real TC1.G(quantity = "ThermalConductance", unit = "W/K") = 0.01 "Constant thermal conductance of material";
// Real TC2.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from port_a -> port_b";
// Real TC2.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "port_a.T - port_b.T";
// Real TC2.port_a.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC2.port_a.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real TC2.port_b.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC2.port_b.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real TC2.G(quantity = "ThermalConductance", unit = "W/K") = 0.01 "Constant thermal conductance of material";
// parameter Real FixedTemperature1.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.0 "Fixed temperature at port";
// Real FixedTemperature1.port.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real FixedTemperature1.port.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real TC3.Q_flow(quantity = "Power", unit = "W") "Heat flow rate from port_a -> port_b";
// Real TC3.dT(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "port_a.T - port_b.T";
// Real TC3.port_a.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC3.port_a.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// Real TC3.port_b.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) "Port temperature";
// Real TC3.port_b.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// parameter Real TC3.G(quantity = "ThermalConductance", unit = "W/K") = 0.01 "Constant thermal conductance of material";
// Real G.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real G.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real H_PMOS.W(quantity = "Length", unit = "m") = 2e-05 "Width";
// parameter Real H_PMOS.L(quantity = "Length", unit = "m") = 6e-06 "Length";
// parameter Real H_PMOS.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 1.05e-05 "Transconductance parameter";
// parameter Real H_PMOS.Vt(quantity = "ElectricPotential", unit = "V") = -1.0 "Zero bias threshold voltage";
// parameter Real H_PMOS.K2 = 0.41 "Bulk threshold parameter";
// parameter Real H_PMOS.K5 = 0.839 "Reduction of pinch-off region";
// parameter Real H_PMOS.dW(quantity = "Length", unit = "m") = -2.5e-06 "Narrowing of channel";
// parameter Real H_PMOS.dL(quantity = "Length", unit = "m") = -2.1e-06 "Shortening of channel";
// parameter Real H_PMOS.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// parameter Real H_PMOS.Tnom(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Parameter measurement temperature";
// parameter Real H_PMOS.kvt = -0.0029 "fitting parameter for Vt";
// parameter Real H_PMOS.kk2 = 0.00062 "fitting parameter for Kk2";
// Real H_PMOS.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_PMOS.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_PMOS.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_PMOS.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_PMOS.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_PMOS.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_PMOS.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_PMOS.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_PMOS.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 300.15) "Port temperature";
// Real H_PMOS.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// protected Real H_PMOS.v;
// protected Real H_PMOS.uds;
// protected Real H_PMOS.ubs;
// protected Real H_PMOS.ugst;
// protected Real H_PMOS.ud;
// protected Real H_PMOS.us;
// protected Real H_PMOS.id;
// protected Real H_PMOS.gds;
// protected Real H_PMOS.beta_t;
// protected Real H_PMOS.vt_t;
// protected Real H_PMOS.k2_t;
// parameter Real H_NMOS.W(quantity = "Length", unit = "m") = 2e-05 "Width";
// parameter Real H_NMOS.L(quantity = "Length", unit = "m") = 6e-06 "Length";
// parameter Real H_NMOS.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 4.1e-05 "Transconductance parameter";
// parameter Real H_NMOS.Vt(quantity = "ElectricPotential", unit = "V") = 0.8 "Zero bias threshold voltage";
// parameter Real H_NMOS.K2 = 1.144 "Bulk threshold parameter";
// parameter Real H_NMOS.K5 = 0.7311 "Reduction of pinch-off region";
// parameter Real H_NMOS.dW(quantity = "Length", unit = "m") = -2.5e-06 "narrowing of channel";
// parameter Real H_NMOS.dL(quantity = "Length", unit = "m") = -1.5e-06 "shortening of channel";
// parameter Real H_NMOS.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// parameter Real H_NMOS.Tnom(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0) = 300.15 "Parameter measurement temperature";
// parameter Real H_NMOS.kvt = -0.00696 "fitting parameter for Vt";
// parameter Real H_NMOS.kk2 = 0.0006 "fitting parameter for K22";
// Real H_NMOS.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_NMOS.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_NMOS.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_NMOS.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_NMOS.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_NMOS.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_NMOS.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real H_NMOS.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real H_NMOS.heatPort.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 300.15) "Port temperature";
// Real H_NMOS.heatPort.Q_flow(quantity = "Power", unit = "W") "Heat flow rate (positive if flowing from outside into the component)";
// protected Real H_NMOS.v;
// protected Real H_NMOS.uds;
// protected Real H_NMOS.ubs;
// protected Real H_NMOS.ugst;
// protected Real H_NMOS.ud;
// protected Real H_NMOS.us;
// protected Real H_NMOS.id;
// protected Real H_NMOS.gds;
// protected Real H_NMOS.beta_t;
// protected Real H_NMOS.vt_t;
// protected Real H_NMOS.k2_t;
// Real Sin.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Sin.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Sin.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Sin.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Sin.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Sin.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Sin.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
// parameter Real Sin.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
// output Real Sin.signalSource.y "Connector of Real output signal";
// parameter Real Sin.signalSource.amplitude = Sin.V "Amplitude of sine wave";
// parameter Real Sin.signalSource.freqHz(quantity = "Frequency", unit = "Hz") = Sin.freqHz "Frequency of sine wave";
// parameter Real Sin.signalSource.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = Sin.phase "Phase of sine wave";
// parameter Real Sin.signalSource.offset = Sin.offset "Offset of output signal";
// parameter Real Sin.signalSource.startTime(quantity = "Time", unit = "s") = Sin.startTime "Output = offset for time < startTime";
// protected constant Real Sin.signalSource.pi = 3.14159265358979;
// parameter Real Sin.V(quantity = "ElectricPotential", unit = "V") = 5.0 "Amplitude of sine wave";
// parameter Real Sin.phase(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Phase of sine wave";
// parameter Real Sin.freqHz(quantity = "Frequency", unit = "Hz") = 1.0 "Frequency of sine wave";
// Real V.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real V.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real V.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real V.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real V.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real V.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real V.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
// parameter Real V.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
// output Real V.signalSource.y "Connector of Real output signal";
// parameter Real V.signalSource.height = V.V "Height of ramps";
// parameter Real V.signalSource.duration(min = 1e-60) = V.duration "Durations of ramp";
// parameter Real V.signalSource.offset = V.offset "Offset of output signal";
// parameter Real V.signalSource.startTime(quantity = "Time", unit = "s") = V.startTime "Output = offset for time < startTime";
// parameter Real V.V(quantity = "ElectricPotential", unit = "V") = 5.0 "Height of ramp";
// parameter Real V.duration(quantity = "Time", unit = "s", min = 1e-60) = 0.01 "Duration of ramp";
// Real Capacitor1.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Capacitor1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Capacitor1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Capacitor1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Capacitor1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Capacitor1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Capacitor1.C(quantity = "Capacitance", unit = "F", min = 0.0) = 1e-05 "Capacitance";
// equation
//   HeatCapacitor1.T = HeatCapacitor1.port.T;
//   HeatCapacitor1.C * der(HeatCapacitor1.T) = HeatCapacitor1.port.Q_flow;
//   TC1.Q_flow = TC1.G * TC1.dT;
//   TC1.dT = TC1.port_a.T - TC1.port_b.T;
//   TC1.port_a.Q_flow = TC1.Q_flow;
//   TC1.port_b.Q_flow = -TC1.Q_flow;
//   TC2.Q_flow = TC2.G * TC2.dT;
//   TC2.dT = TC2.port_a.T - TC2.port_b.T;
//   TC2.port_a.Q_flow = TC2.Q_flow;
//   TC2.port_b.Q_flow = -TC2.Q_flow;
//   FixedTemperature1.port.T = FixedTemperature1.T;
//   TC3.Q_flow = TC3.G * TC3.dT;
//   TC3.dT = TC3.port_a.T - TC3.port_b.T;
//   TC3.port_a.Q_flow = TC3.Q_flow;
//   TC3.port_b.Q_flow = -TC3.Q_flow;
//   G.p.v = 0.0;
// assert(H_PMOS.L + H_PMOS.dL > 0.0,"Effective length must be positive");
// assert(H_PMOS.W + H_PMOS.dW > 0.0,"Effective width  must be positive");
// assert(H_PMOS.heatPort.T > 0.0,"temperature must be positive");
//   H_PMOS.gds = if H_PMOS.RDS < 1e-20 AND H_PMOS.RDS > -1e-20 then 1e+20 else 1.0 / H_PMOS.RDS;
//   H_PMOS.v = H_PMOS.beta_t * (H_PMOS.W + H_PMOS.dW) / (H_PMOS.L + H_PMOS.dL);
//   H_PMOS.ud = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.S.v else H_PMOS.D.v;
//   H_PMOS.us = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.D.v else H_PMOS.S.v;
//   H_PMOS.uds = H_PMOS.ud - H_PMOS.us;
//   H_PMOS.ubs = if H_PMOS.B.v < H_PMOS.us then 0.0 else H_PMOS.B.v - H_PMOS.us;
//   H_PMOS.ugst = (H_PMOS.G.v + (H_PMOS.k2_t * H_PMOS.ubs + ((-H_PMOS.vt_t) + (-H_PMOS.us)))) * H_PMOS.K5;
//   H_PMOS.id = if H_PMOS.ugst >= 0.0 then H_PMOS.uds * H_PMOS.gds else if H_PMOS.ugst < H_PMOS.uds then (-H_PMOS.v) * (H_PMOS.uds * (H_PMOS.ugst - H_PMOS.uds / 2.0)) + H_PMOS.uds * H_PMOS.gds else 0.5 * ((-H_PMOS.v) * H_PMOS.ugst ^ 2.0) + H_PMOS.uds * H_PMOS.gds;
//   H_PMOS.beta_t = H_PMOS.Beta * Modelica.Electrical.Analog.Semiconductors.pow(H_PMOS.heatPort.T / H_PMOS.Tnom,-1.5);
//   H_PMOS.vt_t = H_PMOS.Vt * (1.0 + (H_PMOS.heatPort.T - H_PMOS.Tnom) * H_PMOS.kvt);
//   H_PMOS.k2_t = H_PMOS.K2 * (1.0 + (H_PMOS.heatPort.T - H_PMOS.Tnom) * H_PMOS.kk2);
//   H_PMOS.G.i = 0.0;
//   H_PMOS.D.i = if H_PMOS.D.v > H_PMOS.S.v then -H_PMOS.id else H_PMOS.id;
//   H_PMOS.S.i = if H_PMOS.D.v > H_PMOS.S.v then H_PMOS.id else -H_PMOS.id;
//   H_PMOS.B.i = 0.0;
//   H_PMOS.heatPort.Q_flow = (-H_PMOS.D.i) * (H_PMOS.D.v - H_PMOS.S.v);
// assert(H_NMOS.L + H_NMOS.dL > 0.0,"Effective length must be positive");
// assert(H_NMOS.W + H_NMOS.dW > 0.0,"Effective width  must be positive");
// assert(H_NMOS.heatPort.T > 0.0,"temperature must be positive");
//   H_NMOS.gds = if H_NMOS.RDS < 1e-20 AND H_NMOS.RDS > -1e-20 then 1e+20 else 1.0 / H_NMOS.RDS;
//   H_NMOS.v = H_NMOS.beta_t * (H_NMOS.W + H_NMOS.dW) / (H_NMOS.L + H_NMOS.dL);
//   H_NMOS.ud = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.S.v else H_NMOS.D.v;
//   H_NMOS.us = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.D.v else H_NMOS.S.v;
//   H_NMOS.uds = H_NMOS.ud - H_NMOS.us;
//   H_NMOS.ubs = if H_NMOS.B.v > H_NMOS.us then 0.0 else H_NMOS.B.v - H_NMOS.us;
//   H_NMOS.ugst = (H_NMOS.G.v + (H_NMOS.k2_t * H_NMOS.ubs + ((-H_NMOS.vt_t) + (-H_NMOS.us)))) * H_NMOS.K5;
//   H_NMOS.id = if H_NMOS.ugst <= 0.0 then H_NMOS.uds * H_NMOS.gds else if H_NMOS.ugst > H_NMOS.uds then H_NMOS.v * (H_NMOS.uds * (H_NMOS.ugst - H_NMOS.uds / 2.0)) + H_NMOS.uds * H_NMOS.gds else 0.5 * (H_NMOS.v * H_NMOS.ugst ^ 2.0) + H_NMOS.uds * H_NMOS.gds;
//   H_NMOS.beta_t = H_NMOS.Beta * Modelica.Electrical.Analog.Semiconductors.pow(H_NMOS.heatPort.T / H_NMOS.Tnom,-1.5);
//   H_NMOS.vt_t = H_NMOS.Vt * (1.0 + (H_NMOS.heatPort.T - H_NMOS.Tnom) * H_NMOS.kvt);
//   H_NMOS.k2_t = H_NMOS.K2 * (1.0 + (H_NMOS.heatPort.T - H_NMOS.Tnom) * H_NMOS.kk2);
//   H_NMOS.G.i = 0.0;
//   H_NMOS.D.i = if H_NMOS.D.v < H_NMOS.S.v then -H_NMOS.id else H_NMOS.id;
//   H_NMOS.S.i = if H_NMOS.D.v < H_NMOS.S.v then H_NMOS.id else -H_NMOS.id;
//   H_NMOS.B.i = 0.0;
//   H_NMOS.heatPort.Q_flow = (-H_NMOS.D.i) * (H_NMOS.D.v - H_NMOS.S.v);
//   Sin.signalSource.y = Sin.signalSource.offset + (if time < Sin.signalSource.startTime then 0.0 else Sin.signalSource.amplitude * Modelica.Math.sin(6.28318530717959 * (Sin.signalSource.freqHz * (time - Sin.signalSource.startTime)) + Sin.signalSource.phase));
//   Sin.v = Sin.signalSource.y;
//   Sin.v = Sin.p.v - Sin.n.v;
//   0.0 = Sin.p.i + Sin.n.i;
//   Sin.i = Sin.p.i;
//   V.signalSource.y = V.signalSource.offset + (if time < V.signalSource.startTime then 0.0 else if time < V.signalSource.startTime + V.signalSource.duration then ((time - V.signalSource.startTime) * V.signalSource.height) / V.signalSource.duration else V.signalSource.height);
//   V.v = V.signalSource.y;
//   V.v = V.p.v - V.n.v;
//   0.0 = V.p.i + V.n.i;
//   V.i = V.p.i;
//   Capacitor1.i = Capacitor1.C * der(Capacitor1.v);
//   Capacitor1.v = Capacitor1.p.v - Capacitor1.n.v;
//   0.0 = Capacitor1.p.i + Capacitor1.n.i;
//   Capacitor1.i = Capacitor1.p.i;
//   H_PMOS.S.i + (H_NMOS.D.i + Capacitor1.p.i) = 0.0;
// H_PMOS.S.v = H_NMOS.D.v;
// H_NMOS.D.v = Capacitor1.p.v;
//   Capacitor1.n.i + (V.n.i + (Sin.n.i + (H_NMOS.B.i + (H_NMOS.S.i + G.p.i)))) = 0.0;
// Capacitor1.n.v = V.n.v;
// V.n.v = Sin.n.v;
// Sin.n.v = H_NMOS.B.v;
// H_NMOS.B.v = H_NMOS.S.v;
// H_NMOS.S.v = G.p.v;
//   V.p.i + (H_PMOS.B.i + H_PMOS.D.i) = 0.0;
// V.p.v = H_PMOS.B.v;
// H_PMOS.B.v = H_PMOS.D.v;
//   H_NMOS.G.i + (H_PMOS.G.i + Sin.p.i) = 0.0;
// H_NMOS.G.v = H_PMOS.G.v;
// H_PMOS.G.v = Sin.p.v;
//   TC1.port_b.Q_flow + (TC2.port_b.Q_flow + (TC3.port_a.Q_flow + HeatCapacitor1.port.Q_flow)) = 0.0;
// TC1.port_b.T = TC2.port_b.T;
// TC2.port_b.T = TC3.port_a.T;
// TC3.port_a.T = HeatCapacitor1.port.T;
//   TC1.port_a.Q_flow + H_PMOS.heatPort.Q_flow = 0.0;
// TC1.port_a.T = H_PMOS.heatPort.T;
//   TC2.port_a.Q_flow + H_NMOS.heatPort.Q_flow = 0.0;
// TC2.port_a.T = H_NMOS.heatPort.T;
//   TC3.port_b.Q_flow + FixedTemperature1.port.Q_flow = 0.0;
// TC3.port_b.T = FixedTemperature1.port.T;
// end Modelica.Electrical.Analog.Examples.HeatingMOSInverter;
// "
// ""
// endResult
