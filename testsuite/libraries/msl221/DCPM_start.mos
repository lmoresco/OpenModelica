//name:         DCPM_start
//keyword:      instantiating msl221
//status:       correct
//env: OPENMODELICALIBRARY=../../../libraries/msl221
//
// instantiate example
//

loadModel(Modelica);
instantiateModel(Modelica.Electrical.Machines.Examples.DCPM_start);
getErrorString();
// Result:
// true
// "function Modelica.SIunits.Conversions.from_rpm
//   input Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
//   output Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
// algorithm
//   rs := 0.10471975511966 * rpm;
// end Modelica.SIunits.Conversions.from_rpm;
// 
// function Modelica.SIunits.Conversions.to_rpm
//   input Real rs(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "radian per second value";
//   output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
// algorithm
//   rpm := 9.54929658551372 * rs;
// end Modelica.SIunits.Conversions.to_rpm;
// 
// class Modelica.Electrical.Machines.Examples.DCPM_start
//   parameter Real Va(quantity = "ElectricPotential", unit = "V") = 100.0 "actual armature voltage";
//   parameter Real tStart(quantity = "Time", unit = "s") = 0.2 "armature voltage ramp";
//   parameter Real tRamp(quantity = "Time", unit = "s") = 0.8 "armature voltage ramp";
//   parameter Real T_Load(quantity = "Torque", unit = "N.m") = 63.66 "nominal load torque";
//   parameter Real tStep(quantity = "Time", unit = "s") = 1.5 "time of load torque step";
//   parameter Real J_Load(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "load's moment of inertia";
//   parameter Real DCPM1.J_Rotor(quantity = "MomentOfInertia", unit = "kg.m2") = 0.15 "rotor's moment of inertia";
//   output Real DCPM1.phi_mechanical(quantity = "Angle", unit = "rad", displayUnit = "deg") = DCPM1.flange_a.phi "mechanical angle of rotor against stator";
//   output Real DCPM1.w_mechanical(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(DCPM1.phi_mechanical) "mechanical angular velocity of rotor against stator";
//   output Real DCPM1.rpm_mechanical(quantity = "AngularVelocity", unit = "rev/min") = Modelica.SIunits.Conversions.to_rpm(DCPM1.w_mechanical) "mechanical speed of rotor against stator [rpm]";
//   output Real DCPM1.tau_electrical(quantity = "Torque", unit = "N.m") = DCPM1.inertiaRotor.flange_a.tau "electromagnetic torque";
//   output Real DCPM1.tau_shaft(quantity = "Torque", unit = "N.m") = -DCPM1.flange_a.tau "shaft torque";
//   Real DCPM1.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCPM1.inertiaRotor.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = DCPM1.inertiaRotor.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real DCPM1.inertiaRotor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.inertiaRotor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCPM1.inertiaRotor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.inertiaRotor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real DCPM1.inertiaRotor.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = DCPM1.J_Rotor "Moment of inertia";
//   parameter Integer DCPM1.inertiaRotor.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real DCPM1.inertiaRotor.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real DCPM1.inertiaRotor.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real DCPM1.inertiaRotor.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer DCPM1.inertiaRotor.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real DCPM1.inertiaRotor.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = DCPM1.inertiaRotor.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real DCPM1.inertiaRotor.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   parameter Real DCPM1.fixedHousing.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
//   Real DCPM1.fixedHousing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.fixedHousing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCPM1.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.internalSupport.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   output Real DCPM1.va(quantity = "ElectricPotential", unit = "V") = DCPM1.pin_ap.v - DCPM1.pin_an.v "armature voltage";
//   output Real DCPM1.ia(quantity = "ElectricCurrent", unit = "A") = DCPM1.pin_ap.i "armature current";
//   Real DCPM1.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCPM1.VaNominal(quantity = "ElectricPotential", unit = "V") = 100.0 "|Nominal parameters|nominal armature voltage";
//   parameter Real DCPM1.IaNominal(quantity = "ElectricCurrent", unit = "A") = 100.0 "|Nominal parameters|nominal armature current";
//   parameter Real DCPM1.rpmNominal(quantity = "AngularVelocity", unit = "rev/min") = 1425.0 "|Nominal parameters|nominal speed";
//   parameter Real DCPM1.Ra(quantity = "Resistance", unit = "Ohm") = 0.05 "|Nominal resistances and inductances|warm armature resistance";
//   parameter Real DCPM1.La(quantity = "Inductance", unit = "H") = 0.0015 "|Nominal resistances and inductances|armature inductance";
//   Real DCPM1.ra.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCPM1.ra.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCPM1.ra.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.ra.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.ra.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.ra.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCPM1.ra.R(quantity = "Resistance", unit = "Ohm") = DCPM1.Ra "Resistance";
//   Real DCPM1.la.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCPM1.la.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCPM1.la.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.la.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.la.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.la.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCPM1.la.L(quantity = "Inductance", unit = "H") = DCPM1.La "Inductance";
//   Real DCPM1.eGround.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.eGround.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCPM1.airGapDC.Le(quantity = "Inductance", unit = "H") = 1.0 "Excitation inductance";
//   parameter Real DCPM1.airGapDC.TurnsRatio = DCPM1.TurnsRatio "Ratio of armature turns over number of turns of the excitation winding";
//   Real DCPM1.airGapDC.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") "Angluar velocity";
//   Real DCPM1.airGapDC.vei(quantity = "ElectricPotential", unit = "V") "Voltage drop across field excitation inductance";
//   Real DCPM1.airGapDC.ie(quantity = "ElectricCurrent", unit = "A") "Excitation current";
//   Real DCPM1.airGapDC.psi_e(quantity = "MagneticFlux", unit = "Wb") "Excitation flux";
//   Real DCPM1.airGapDC.vai(quantity = "ElectricPotential", unit = "V") "Induced armature voltage";
//   Real DCPM1.airGapDC.ia(quantity = "ElectricCurrent", unit = "A") "Armature current";
//   output Real DCPM1.airGapDC.tau_electrical(quantity = "Torque", unit = "N.m");
//   Real DCPM1.airGapDC.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.airGapDC.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCPM1.airGapDC.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real DCPM1.airGapDC.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real DCPM1.airGapDC.pin_ap.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.airGapDC.pin_ap.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.airGapDC.pin_ep.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.airGapDC.pin_ep.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.airGapDC.pin_an.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.airGapDC.pin_an.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.airGapDC.pin_en.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.airGapDC.pin_en.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.ie.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
//   Real DCPM1.ie.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real DCPM1.ie.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.ie.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real DCPM1.ie.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real DCPM1.ie.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   parameter Real DCPM1.ie.I(quantity = "ElectricCurrent", unit = "A") = 1.0 "Value of constant current";
//   protected constant Real DCPM1.IeNominal(quantity = "ElectricCurrent", unit = "A") = 1.0 "equivalent excitation current";
//   protected constant Real DCPM1.Le(quantity = "Inductance", unit = "H") = 1.0 "arbitrary excitation inductance";
//   protected parameter Real DCPM1.TurnsRatio = (DCPM1.VaNominal - DCPM1.Ra * DCPM1.IaNominal) / Modelica.SIunits.Conversions.from_rpm(DCPM1.rpmNominal) "Ratio of armature turns over number of turns of the excitation winding";
//   output Real Ramp1.y "Connector of Real output signal";
//   parameter Real Ramp1.height = Va "Height of ramps";
//   parameter Real Ramp1.duration(min = 1e-60) = tRamp "Durations of ramp";
//   parameter Real Ramp1.offset = 0.0 "Offset of output signal";
//   parameter Real Ramp1.startTime(quantity = "Time", unit = "s") = tStart "Output = offset for time < startTime";
//   Real LoadInertia.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = LoadInertia.phi_start, StateSelect = StateSelect.default) "Absolute rotation angle of component (= flange_a.phi = flange_b.phi)";
//   Real LoadInertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real LoadInertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real LoadInertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real LoadInertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0) = J_Load "Moment of inertia";
//   parameter Integer LoadInertia.initType(min = 1, max = 9) = 1 "Type of initialization (defines usage of start values below)";
//   parameter Real LoadInertia.phi_start(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Initial or guess value of rotor rotation angle phi";
//   parameter Real LoadInertia.w_start(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = 0.0 "Initial or guess value of angular velocity w = der(phi)";
//   parameter Real LoadInertia.a_start(quantity = "AngularAcceleration", unit = "rad/s2") = 0.0 "Initial value of angular acceleration a = der(w)";
//   parameter Integer LoadInertia.stateSelection(min = 1, max = 5) = 3 "Priority to use phi and w as states";
//   Real LoadInertia.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min", start = LoadInertia.w_start, StateSelect = StateSelect.default) "Absolute angular velocity of component";
//   Real LoadInertia.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component";
//   Real TorqueStep1.w(quantity = "AngularVelocity", unit = "rad/s", displayUnit = "rev/min") = der(TorqueStep1.flange.phi) "Angular velocity at flange";
//   Real TorqueStep1.tau(quantity = "Torque", unit = "N.m") = TorqueStep1.flange.tau "accelerating torque acting at flange";
//   Real TorqueStep1.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real TorqueStep1.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   Real TorqueStep1.bearing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
//   Real TorqueStep1.bearing.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
//   parameter Real TorqueStep1.stepTorque(quantity = "Torque", unit = "N.m") = -T_Load "height of torque step (if negative, torque is acting as load)";
//   parameter Real TorqueStep1.offsetTorque(quantity = "Torque", unit = "N.m") = 0.0 "offset of torque";
//   parameter Real TorqueStep1.startTime(quantity = "Time", unit = "s") = tStep "output = offset for time < startTime";
//   Real Ground1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real Ground1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
//   Real SignalVoltage1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   Real SignalVoltage1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
//   Real SignalVoltage1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
//   input Real SignalVoltage1.v(quantity = "ElectricPotential", unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
// equation
//   DCPM1.inertiaRotor.w = der(DCPM1.inertiaRotor.phi);
//   DCPM1.inertiaRotor.a = der(DCPM1.inertiaRotor.w);
//   DCPM1.inertiaRotor.J * DCPM1.inertiaRotor.a = DCPM1.inertiaRotor.flange_a.tau + DCPM1.inertiaRotor.flange_b.tau;
//   DCPM1.inertiaRotor.flange_a.phi = DCPM1.inertiaRotor.phi;
//   DCPM1.inertiaRotor.flange_b.phi = DCPM1.inertiaRotor.phi;
//   DCPM1.fixedHousing.flange_b.phi = DCPM1.fixedHousing.phi0;
//   DCPM1.ra.R * DCPM1.ra.i = DCPM1.ra.v;
//   DCPM1.ra.v = DCPM1.ra.p.v - DCPM1.ra.n.v;
//   0.0 = DCPM1.ra.p.i + DCPM1.ra.n.i;
//   DCPM1.ra.i = DCPM1.ra.p.i;
//   DCPM1.la.L * der(DCPM1.la.i) = DCPM1.la.v;
//   DCPM1.la.v = DCPM1.la.p.v - DCPM1.la.n.v;
//   0.0 = DCPM1.la.p.i + DCPM1.la.n.i;
//   DCPM1.la.i = DCPM1.la.p.i;
//   DCPM1.eGround.p.v = 0.0;
//   DCPM1.airGapDC.vai = DCPM1.airGapDC.pin_ap.v - DCPM1.airGapDC.pin_an.v;
//   DCPM1.airGapDC.ia = DCPM1.airGapDC.pin_ap.i;
//   DCPM1.airGapDC.ia = -DCPM1.airGapDC.pin_an.i;
//   DCPM1.airGapDC.vei = DCPM1.airGapDC.pin_ep.v - DCPM1.airGapDC.pin_en.v;
//   DCPM1.airGapDC.ie = DCPM1.airGapDC.pin_ep.i;
//   DCPM1.airGapDC.ie = -DCPM1.airGapDC.pin_en.i;
//   DCPM1.airGapDC.psi_e = DCPM1.airGapDC.Le * DCPM1.airGapDC.ie;
//   DCPM1.airGapDC.vei = der(DCPM1.airGapDC.psi_e);
//   DCPM1.airGapDC.w = der(DCPM1.airGapDC.flange_a.phi) - der(DCPM1.airGapDC.support.phi);
//   DCPM1.airGapDC.vai = DCPM1.airGapDC.TurnsRatio * (DCPM1.airGapDC.psi_e * DCPM1.airGapDC.w);
//   DCPM1.airGapDC.tau_electrical = DCPM1.airGapDC.TurnsRatio * (DCPM1.airGapDC.psi_e * DCPM1.airGapDC.ia);
//   DCPM1.airGapDC.flange_a.tau = -DCPM1.airGapDC.tau_electrical;
//   DCPM1.airGapDC.support.tau = DCPM1.airGapDC.tau_electrical;
//   DCPM1.ie.i = DCPM1.ie.I;
//   DCPM1.ie.v = DCPM1.ie.p.v - DCPM1.ie.n.v;
//   0.0 = DCPM1.ie.p.i + DCPM1.ie.n.i;
//   DCPM1.ie.i = DCPM1.ie.p.i;
//   assert(DCPM1.VaNominal > DCPM1.Ra * DCPM1.IaNominal,"VaNominal has to be > (Ra+Re)*IaNominal");
//   Ramp1.y = Ramp1.offset + (if time < Ramp1.startTime then 0.0 else if time < Ramp1.startTime + Ramp1.duration then ((time - Ramp1.startTime) * Ramp1.height) / Ramp1.duration else Ramp1.height);
//   LoadInertia.w = der(LoadInertia.phi);
//   LoadInertia.a = der(LoadInertia.w);
//   LoadInertia.J * LoadInertia.a = LoadInertia.flange_a.tau + LoadInertia.flange_b.tau;
//   LoadInertia.flange_a.phi = LoadInertia.phi;
//   LoadInertia.flange_b.phi = LoadInertia.phi;
//   TorqueStep1.tau = (-TorqueStep1.offsetTorque) - (if time < TorqueStep1.startTime then 0.0 else TorqueStep1.stepTorque);
//   TorqueStep1.bearing.phi = 0.0;
//   Ground1.p.v = 0.0;
//   SignalVoltage1.v = SignalVoltage1.p.v - SignalVoltage1.n.v;
//   0.0 = SignalVoltage1.p.i + SignalVoltage1.n.i;
//   SignalVoltage1.i = SignalVoltage1.p.i;
//   DCPM1.pin_an.i + (SignalVoltage1.n.i + Ground1.p.i) = 0.0;
//   DCPM1.airGapDC.pin_an.v = DCPM1.pin_an.v;
//   DCPM1.airGapDC.pin_an.v = Ground1.p.v;
//   DCPM1.airGapDC.pin_an.v = SignalVoltage1.n.v;
//   SignalVoltage1.p.i + DCPM1.pin_ap.i = 0.0;
//   DCPM1.pin_ap.v = DCPM1.ra.p.v;
//   DCPM1.pin_ap.v = SignalVoltage1.p.v;
//   Ramp1.y = SignalVoltage1.v;
//   DCPM1.flange_a.tau + LoadInertia.flange_a.tau = 0.0;
//   DCPM1.flange_a.phi = DCPM1.inertiaRotor.flange_b.phi;
//   DCPM1.flange_a.phi = LoadInertia.flange_a.phi;
//   LoadInertia.flange_b.tau + TorqueStep1.flange.tau = 0.0;
//   LoadInertia.flange_b.phi = TorqueStep1.flange.phi;
//   TorqueStep1.bearing.tau = 0.0;
//   DCPM1.inertiaRotor.flange_b.tau + (-DCPM1.flange_a.tau) = 0.0;
//   DCPM1.airGapDC.support.tau + ((-DCPM1.internalSupport.tau) + DCPM1.fixedHousing.flange_b.tau) = 0.0;
//   DCPM1.airGapDC.support.phi = DCPM1.fixedHousing.flange_b.phi;
//   DCPM1.airGapDC.support.phi = DCPM1.internalSupport.phi;
//   DCPM1.airGapDC.pin_en.i + (DCPM1.eGround.p.i + DCPM1.ie.p.i) = 0.0;
//   DCPM1.airGapDC.pin_en.v = DCPM1.eGround.p.v;
//   DCPM1.airGapDC.pin_en.v = DCPM1.ie.p.v;
//   DCPM1.la.p.i + DCPM1.ra.n.i = 0.0;
//   DCPM1.la.p.v = DCPM1.ra.n.v;
//   (-DCPM1.pin_ap.i) + DCPM1.ra.p.i = 0.0;
//   DCPM1.airGapDC.pin_an.i + (-DCPM1.pin_an.i) = 0.0;
//   DCPM1.airGapDC.flange_a.tau + DCPM1.inertiaRotor.flange_a.tau = 0.0;
//   DCPM1.airGapDC.flange_a.phi = DCPM1.inertiaRotor.flange_a.phi;
//   DCPM1.la.n.i + DCPM1.airGapDC.pin_ap.i = 0.0;
//   DCPM1.airGapDC.pin_ap.v = DCPM1.la.n.v;
//   DCPM1.airGapDC.pin_ep.i + DCPM1.ie.n.i = 0.0;
//   DCPM1.airGapDC.pin_ep.v = DCPM1.ie.n.v;
//   DCPM1.internalSupport.tau = 0.0;
// end Modelica.Electrical.Machines.Examples.DCPM_start;
// "
// ""
// endResult
