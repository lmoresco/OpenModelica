//name:         NandGatee
//keyword:      instantiating msl221
//status:       correct
//
// instantiate example
//

loadFile("Modelica/package.mo");
instantiateModel(Modelica.Electrical.Analog.Examples.NandGate);
getErrorString();
// Result:
// true
// "fclass Modelica.Electrical.Analog.Examples.NandGate
// Real Gnd1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Gnd1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Gnd4.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Gnd4.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Gnd5.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Gnd5.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Nand.TP1.W(quantity = "Length", unit = "m") = 6.5e-06 "Width";
// parameter Real Nand.TP1.L(quantity = "Length", unit = "m") = 3.1e-06 "Length";
// parameter Real Nand.TP1.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 1.05e-05 "Transconductance parameter";
// parameter Real Nand.TP1.Vt(quantity = "ElectricPotential", unit = "V") = -1.0 "Zero bias threshold voltage";
// parameter Real Nand.TP1.K2 = 0.41 "Bulk threshold parameter";
// parameter Real Nand.TP1.K5 = 0.8385 "Reduction of pinch-off region";
// parameter Real Nand.TP1.dW(quantity = "Length", unit = "m") = -2.5e-06 "Narrowing of channel";
// parameter Real Nand.TP1.dL(quantity = "Length", unit = "m") = -2.1e-06 "Shortening of channel";
// parameter Real Nand.TP1.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// Real Nand.TP1.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP1.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP1.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP1.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP1.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP1.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP1.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP1.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// protected Real Nand.TP1.v;
// protected Real Nand.TP1.uds;
// protected Real Nand.TP1.ubs;
// protected Real Nand.TP1.ugst;
// protected Real Nand.TP1.ud;
// protected Real Nand.TP1.us;
// protected Real Nand.TP1.id;
// protected Real Nand.TP1.gds;
// parameter Real Nand.TP2.W(quantity = "Length", unit = "m") = 6.5e-06 "Width";
// parameter Real Nand.TP2.L(quantity = "Length", unit = "m") = 3.1e-06 "Length";
// parameter Real Nand.TP2.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 1.05e-05 "Transconductance parameter";
// parameter Real Nand.TP2.Vt(quantity = "ElectricPotential", unit = "V") = -1.0 "Zero bias threshold voltage";
// parameter Real Nand.TP2.K2 = 0.41 "Bulk threshold parameter";
// parameter Real Nand.TP2.K5 = 0.8385 "Reduction of pinch-off region";
// parameter Real Nand.TP2.dW(quantity = "Length", unit = "m") = -2.5e-06 "Narrowing of channel";
// parameter Real Nand.TP2.dL(quantity = "Length", unit = "m") = -2.1e-06 "Shortening of channel";
// parameter Real Nand.TP2.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// Real Nand.TP2.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP2.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP2.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP2.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP2.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP2.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TP2.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TP2.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// protected Real Nand.TP2.v;
// protected Real Nand.TP2.uds;
// protected Real Nand.TP2.ubs;
// protected Real Nand.TP2.ugst;
// protected Real Nand.TP2.ud;
// protected Real Nand.TP2.us;
// protected Real Nand.TP2.id;
// protected Real Nand.TP2.gds;
// parameter Real Nand.TN1.W(quantity = "Length", unit = "m") = 6.5e-06 "Width";
// parameter Real Nand.TN1.L(quantity = "Length", unit = "m") = 3.1e-06 "Length";
// parameter Real Nand.TN1.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 4.1e-05 "Transconductance parameter";
// parameter Real Nand.TN1.Vt(quantity = "ElectricPotential", unit = "V") = 0.8 "Zero bias threshold voltage";
// parameter Real Nand.TN1.K2 = 1.144 "Bulk threshold parameter";
// parameter Real Nand.TN1.K5 = 0.7311 "Reduction of pinch-off region";
// parameter Real Nand.TN1.dW(quantity = "Length", unit = "m") = -2.5e-06 "narrowing of channel";
// parameter Real Nand.TN1.dL(quantity = "Length", unit = "m") = -1.5e-06 "shortening of channel";
// parameter Real Nand.TN1.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// Real Nand.TN1.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN1.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN1.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN1.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN1.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN1.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN1.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN1.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// protected Real Nand.TN1.v;
// protected Real Nand.TN1.uds;
// protected Real Nand.TN1.ubs;
// protected Real Nand.TN1.ugst;
// protected Real Nand.TN1.ud;
// protected Real Nand.TN1.us;
// protected Real Nand.TN1.id;
// protected Real Nand.TN1.gds;
// parameter Real Nand.TN2.W(quantity = "Length", unit = "m") = 6.5e-06 "Width";
// parameter Real Nand.TN2.L(quantity = "Length", unit = "m") = 3.1e-06 "Length";
// parameter Real Nand.TN2.Beta(quantity = "Transconductance", unit = "A/(V*V)") = 4.1e-05 "Transconductance parameter";
// parameter Real Nand.TN2.Vt(quantity = "ElectricPotential", unit = "V") = 0.8 "Zero bias threshold voltage";
// parameter Real Nand.TN2.K2 = 1.144 "Bulk threshold parameter";
// parameter Real Nand.TN2.K5 = 0.7311 "Reduction of pinch-off region";
// parameter Real Nand.TN2.dW(quantity = "Length", unit = "m") = -2.5e-06 "narrowing of channel";
// parameter Real Nand.TN2.dL(quantity = "Length", unit = "m") = -1.5e-06 "shortening of channel";
// parameter Real Nand.TN2.RDS(quantity = "Resistance", unit = "Ohm") = 10000000.0 "Drain-Source-Resistance";
// Real Nand.TN2.D.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN2.D.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN2.G.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN2.G.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN2.S.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN2.S.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.TN2.B.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.TN2.B.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// protected Real Nand.TN2.v;
// protected Real Nand.TN2.uds;
// protected Real Nand.TN2.ubs;
// protected Real Nand.TN2.ugst;
// protected Real Nand.TN2.ud;
// protected Real Nand.TN2.us;
// protected Real Nand.TN2.id;
// protected Real Nand.TN2.gds;
// Real Nand.Gnd.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Gnd2.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd2.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Gnd3.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd3.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Gnd6.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd6.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Gnd7.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd7.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Gnd8.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Gnd8.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.x1.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.x1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.x2.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.x2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.Vdd.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.Vdd.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.y.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.y.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.C4.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Nand.C4.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Nand.C4.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.C4.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.C4.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.C4.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Nand.C4.C(quantity = "Capacitance", unit = "F", min = 0.0) = 4e-14 "Capacitance";
// Real Nand.C7.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real Nand.C7.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real Nand.C7.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.C7.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real Nand.C7.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real Nand.C7.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real Nand.C7.C(quantity = "Capacitance", unit = "F", min = 0.0) = 4e-14 "Capacitance";
// Real VIN1.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real VIN1.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real VIN1.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VIN1.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real VIN1.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VIN1.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real VIN1.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
// parameter Real VIN1.startTime(quantity = "Time", unit = "s") = 2e-08 "Time offset";
// output Real VIN1.signalSource.y "Connector of Real output signal";
// parameter Real VIN1.signalSource.amplitude = VIN1.V "Amplitude of trapezoid";
// parameter Real VIN1.signalSource.rising(quantity = "Time", unit = "s", min = 0.0) = VIN1.rising "Rising duration of trapezoid";
// parameter Real VIN1.signalSource.width(quantity = "Time", unit = "s", min = 0.0) = VIN1.width "Width duration of trapezoid";
// parameter Real VIN1.signalSource.falling(quantity = "Time", unit = "s", min = 0.0) = VIN1.falling "Falling duration of trapezoid";
// parameter Real VIN1.signalSource.period(quantity = "Time", unit = "s", min = 1e-60) = VIN1.period "Time for one period";
// parameter Integer VIN1.signalSource.nperiod = VIN1.nperiod "Number of periods (< 0 means infinite number of periods)";
// parameter Real VIN1.signalSource.offset = VIN1.offset "Offset of output signal";
// parameter Real VIN1.signalSource.startTime(quantity = "Time", unit = "s") = VIN1.startTime "Output = offset for time < startTime";
// protected parameter Real VIN1.signalSource.T_rising(quantity = "Time", unit = "s") = VIN1.signalSource.rising "End time of rising phase within one period";
// protected parameter Real VIN1.signalSource.T_width(quantity = "Time", unit = "s") = VIN1.signalSource.T_rising + VIN1.signalSource.width "End time of width phase within one period";
// protected parameter Real VIN1.signalSource.T_falling(quantity = "Time", unit = "s") = VIN1.signalSource.T_width + VIN1.signalSource.falling "End time of falling phase within one period";
// protected Real VIN1.signalSource.T0(quantity = "Time", unit = "s", start = VIN1.signalSource.startTime) "Start time of current period";
// protected Integer VIN1.signalSource.counter(start = VIN1.signalSource.nperiod) "Period counter";
// protected Integer VIN1.signalSource.counter2(start = VIN1.signalSource.nperiod);
// parameter Real VIN1.V(quantity = "ElectricPotential", unit = "V") = 3.5 "Amplitude of trapezoid";
// parameter Real VIN1.rising(quantity = "Time", unit = "s", min = 0.0) = 1e-09 "Rising duration of trapezoid";
// parameter Real VIN1.width(quantity = "Time", unit = "s", min = 0.0) = 1.9e-08 "Width duration of trapezoid";
// parameter Real VIN1.falling(quantity = "Time", unit = "s", min = 0.0) = 1e-09 "Falling duration of trapezoid";
// parameter Real VIN1.period(quantity = "Time", unit = "s", min = 1e-60) = 4e-08 "Time for one period";
// parameter Integer VIN1.nperiod = -1 "Number of periods (< 0 means infinite number of periods)";
// Real VIN2.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real VIN2.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real VIN2.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VIN2.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real VIN2.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VIN2.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real VIN2.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
// parameter Real VIN2.startTime(quantity = "Time", unit = "s") = 1e-08 "Time offset";
// output Real VIN2.signalSource.y "Connector of Real output signal";
// parameter Real VIN2.signalSource.amplitude = VIN2.V "Amplitude of trapezoid";
// parameter Real VIN2.signalSource.rising(quantity = "Time", unit = "s", min = 0.0) = VIN2.rising "Rising duration of trapezoid";
// parameter Real VIN2.signalSource.width(quantity = "Time", unit = "s", min = 0.0) = VIN2.width "Width duration of trapezoid";
// parameter Real VIN2.signalSource.falling(quantity = "Time", unit = "s", min = 0.0) = VIN2.falling "Falling duration of trapezoid";
// parameter Real VIN2.signalSource.period(quantity = "Time", unit = "s", min = 1e-60) = VIN2.period "Time for one period";
// parameter Integer VIN2.signalSource.nperiod = VIN2.nperiod "Number of periods (< 0 means infinite number of periods)";
// parameter Real VIN2.signalSource.offset = VIN2.offset "Offset of output signal";
// parameter Real VIN2.signalSource.startTime(quantity = "Time", unit = "s") = VIN2.startTime "Output = offset for time < startTime";
// protected parameter Real VIN2.signalSource.T_rising(quantity = "Time", unit = "s") = VIN2.signalSource.rising "End time of rising phase within one period";
// protected parameter Real VIN2.signalSource.T_width(quantity = "Time", unit = "s") = VIN2.signalSource.T_rising + VIN2.signalSource.width "End time of width phase within one period";
// protected parameter Real VIN2.signalSource.T_falling(quantity = "Time", unit = "s") = VIN2.signalSource.T_width + VIN2.signalSource.falling "End time of falling phase within one period";
// protected Real VIN2.signalSource.T0(quantity = "Time", unit = "s", start = VIN2.signalSource.startTime) "Start time of current period";
// protected Integer VIN2.signalSource.counter(start = VIN2.signalSource.nperiod) "Period counter";
// protected Integer VIN2.signalSource.counter2(start = VIN2.signalSource.nperiod);
// parameter Real VIN2.V(quantity = "ElectricPotential", unit = "V") = 3.5 "Amplitude of trapezoid";
// parameter Real VIN2.rising(quantity = "Time", unit = "s", min = 0.0) = 1e-09 "Rising duration of trapezoid";
// parameter Real VIN2.width(quantity = "Time", unit = "s", min = 0.0) = 1.9e-08 "Width duration of trapezoid";
// parameter Real VIN2.falling(quantity = "Time", unit = "s", min = 0.0) = 1e-09 "Falling duration of trapezoid";
// parameter Real VIN2.period(quantity = "Time", unit = "s", min = 1e-60) = 4e-08 "Time for one period";
// parameter Integer VIN2.nperiod = -1 "Number of periods (< 0 means infinite number of periods)";
// Real VDD.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
// Real VDD.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
// Real VDD.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VDD.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// Real VDD.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
// Real VDD.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
// parameter Real VDD.offset(quantity = "ElectricPotential", unit = "V") = 0.0 "Voltage offset";
// parameter Real VDD.startTime(quantity = "Time", unit = "s") = 0.0 "Time offset";
// output Real VDD.signalSource.y "Connector of Real output signal";
// parameter Real VDD.signalSource.height = VDD.V "Height of ramps";
// parameter Real VDD.signalSource.duration(min = 1e-60) = VDD.duration "Durations of ramp";
// parameter Real VDD.signalSource.offset = VDD.offset "Offset of output signal";
// parameter Real VDD.signalSource.startTime(quantity = "Time", unit = "s") = VDD.startTime "Output = offset for time < startTime";
// parameter Real VDD.V(quantity = "ElectricPotential", unit = "V") = 5.0 "Height of ramp";
// parameter Real VDD.duration(quantity = "Time", unit = "s", min = 1e-60) = 1e-09 "Duration of ramp";
// equation
//   Gnd1.p.v = 0.0;
//   Gnd4.p.v = 0.0;
//   Gnd5.p.v = 0.0;
//   Nand.TP1.gds = if Nand.TP1.RDS < 1e-20 AND Nand.TP1.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TP1.RDS;
//   Nand.TP1.v = Nand.TP1.Beta * (Nand.TP1.W + Nand.TP1.dW) / (Nand.TP1.L + Nand.TP1.dL);
//   Nand.TP1.ud = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.S.v else Nand.TP1.D.v;
//   Nand.TP1.us = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.D.v else Nand.TP1.S.v;
//   Nand.TP1.uds = Nand.TP1.ud - Nand.TP1.us;
//   Nand.TP1.ubs = if Nand.TP1.B.v < Nand.TP1.us then 0.0 else Nand.TP1.B.v - Nand.TP1.us;
//   Nand.TP1.ugst = (Nand.TP1.G.v + (Nand.TP1.K2 * Nand.TP1.ubs + ((-Nand.TP1.Vt) + (-Nand.TP1.us)))) * Nand.TP1.K5;
//   Nand.TP1.id = if Nand.TP1.ugst >= 0.0 then Nand.TP1.uds * Nand.TP1.gds else if Nand.TP1.ugst < Nand.TP1.uds then (-Nand.TP1.v) * (Nand.TP1.uds * (Nand.TP1.ugst - Nand.TP1.uds / 2.0)) + Nand.TP1.uds * Nand.TP1.gds else 0.5 * ((-Nand.TP1.v) * Nand.TP1.ugst ^ 2.0) + Nand.TP1.uds * Nand.TP1.gds;
//   Nand.TP1.G.i = 0.0;
//   Nand.TP1.D.i = if Nand.TP1.D.v > Nand.TP1.S.v then -Nand.TP1.id else Nand.TP1.id;
//   Nand.TP1.S.i = if Nand.TP1.D.v > Nand.TP1.S.v then Nand.TP1.id else -Nand.TP1.id;
//   Nand.TP1.B.i = 0.0;
//   Nand.TP2.gds = if Nand.TP2.RDS < 1e-20 AND Nand.TP2.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TP2.RDS;
//   Nand.TP2.v = Nand.TP2.Beta * (Nand.TP2.W + Nand.TP2.dW) / (Nand.TP2.L + Nand.TP2.dL);
//   Nand.TP2.ud = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.S.v else Nand.TP2.D.v;
//   Nand.TP2.us = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.D.v else Nand.TP2.S.v;
//   Nand.TP2.uds = Nand.TP2.ud - Nand.TP2.us;
//   Nand.TP2.ubs = if Nand.TP2.B.v < Nand.TP2.us then 0.0 else Nand.TP2.B.v - Nand.TP2.us;
//   Nand.TP2.ugst = (Nand.TP2.G.v + (Nand.TP2.K2 * Nand.TP2.ubs + ((-Nand.TP2.Vt) + (-Nand.TP2.us)))) * Nand.TP2.K5;
//   Nand.TP2.id = if Nand.TP2.ugst >= 0.0 then Nand.TP2.uds * Nand.TP2.gds else if Nand.TP2.ugst < Nand.TP2.uds then (-Nand.TP2.v) * (Nand.TP2.uds * (Nand.TP2.ugst - Nand.TP2.uds / 2.0)) + Nand.TP2.uds * Nand.TP2.gds else 0.5 * ((-Nand.TP2.v) * Nand.TP2.ugst ^ 2.0) + Nand.TP2.uds * Nand.TP2.gds;
//   Nand.TP2.G.i = 0.0;
//   Nand.TP2.D.i = if Nand.TP2.D.v > Nand.TP2.S.v then -Nand.TP2.id else Nand.TP2.id;
//   Nand.TP2.S.i = if Nand.TP2.D.v > Nand.TP2.S.v then Nand.TP2.id else -Nand.TP2.id;
//   Nand.TP2.B.i = 0.0;
//   Nand.TN1.gds = if Nand.TN1.RDS < 1e-20 AND Nand.TN1.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TN1.RDS;
//   Nand.TN1.v = Nand.TN1.Beta * (Nand.TN1.W + Nand.TN1.dW) / (Nand.TN1.L + Nand.TN1.dL);
//   Nand.TN1.ud = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.S.v else Nand.TN1.D.v;
//   Nand.TN1.us = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.D.v else Nand.TN1.S.v;
//   Nand.TN1.uds = Nand.TN1.ud - Nand.TN1.us;
//   Nand.TN1.ubs = if Nand.TN1.B.v > Nand.TN1.us then 0.0 else Nand.TN1.B.v - Nand.TN1.us;
//   Nand.TN1.ugst = (Nand.TN1.G.v + (Nand.TN1.K2 * Nand.TN1.ubs + ((-Nand.TN1.Vt) + (-Nand.TN1.us)))) * Nand.TN1.K5;
//   Nand.TN1.id = if Nand.TN1.ugst <= 0.0 then Nand.TN1.uds * Nand.TN1.gds else if Nand.TN1.ugst > Nand.TN1.uds then Nand.TN1.v * (Nand.TN1.uds * (Nand.TN1.ugst - Nand.TN1.uds / 2.0)) + Nand.TN1.uds * Nand.TN1.gds else 0.5 * (Nand.TN1.v * Nand.TN1.ugst ^ 2.0) + Nand.TN1.uds * Nand.TN1.gds;
//   Nand.TN1.G.i = 0.0;
//   Nand.TN1.D.i = if Nand.TN1.D.v < Nand.TN1.S.v then -Nand.TN1.id else Nand.TN1.id;
//   Nand.TN1.S.i = if Nand.TN1.D.v < Nand.TN1.S.v then Nand.TN1.id else -Nand.TN1.id;
//   Nand.TN1.B.i = 0.0;
//   Nand.TN2.gds = if Nand.TN2.RDS < 1e-20 AND Nand.TN2.RDS > -1e-20 then 1e+20 else 1.0 / Nand.TN2.RDS;
//   Nand.TN2.v = Nand.TN2.Beta * (Nand.TN2.W + Nand.TN2.dW) / (Nand.TN2.L + Nand.TN2.dL);
//   Nand.TN2.ud = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.S.v else Nand.TN2.D.v;
//   Nand.TN2.us = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.D.v else Nand.TN2.S.v;
//   Nand.TN2.uds = Nand.TN2.ud - Nand.TN2.us;
//   Nand.TN2.ubs = if Nand.TN2.B.v > Nand.TN2.us then 0.0 else Nand.TN2.B.v - Nand.TN2.us;
//   Nand.TN2.ugst = (Nand.TN2.G.v + (Nand.TN2.K2 * Nand.TN2.ubs + ((-Nand.TN2.Vt) + (-Nand.TN2.us)))) * Nand.TN2.K5;
//   Nand.TN2.id = if Nand.TN2.ugst <= 0.0 then Nand.TN2.uds * Nand.TN2.gds else if Nand.TN2.ugst > Nand.TN2.uds then Nand.TN2.v * (Nand.TN2.uds * (Nand.TN2.ugst - Nand.TN2.uds / 2.0)) + Nand.TN2.uds * Nand.TN2.gds else 0.5 * (Nand.TN2.v * Nand.TN2.ugst ^ 2.0) + Nand.TN2.uds * Nand.TN2.gds;
//   Nand.TN2.G.i = 0.0;
//   Nand.TN2.D.i = if Nand.TN2.D.v < Nand.TN2.S.v then -Nand.TN2.id else Nand.TN2.id;
//   Nand.TN2.S.i = if Nand.TN2.D.v < Nand.TN2.S.v then Nand.TN2.id else -Nand.TN2.id;
//   Nand.TN2.B.i = 0.0;
//   Nand.Gnd.p.v = 0.0;
//   Nand.Gnd2.p.v = 0.0;
//   Nand.Gnd3.p.v = 0.0;
//   Nand.Gnd6.p.v = 0.0;
//   Nand.Gnd7.p.v = 0.0;
//   Nand.Gnd8.p.v = 0.0;
//   Nand.C4.i = Nand.C4.C * der(Nand.C4.v);
//   Nand.C4.v = Nand.C4.p.v - Nand.C4.n.v;
//   0.0 = Nand.C4.p.i + Nand.C4.n.i;
//   Nand.C4.i = Nand.C4.p.i;
//   Nand.C7.i = Nand.C7.C * der(Nand.C7.v);
//   Nand.C7.v = Nand.C7.p.v - Nand.C7.n.v;
//   0.0 = Nand.C7.p.i + Nand.C7.n.i;
//   Nand.C7.i = Nand.C7.p.i;
//   Nand.C7.n.i + Nand.Gnd3.p.i = 0.0;
// Nand.C7.n.v = Nand.Gnd3.p.v;
//   Nand.TN1.S.i + (Nand.TN2.D.i + Nand.C7.p.i) = 0.0;
// Nand.TN1.S.v = Nand.TN2.D.v;
// Nand.TN2.D.v = Nand.C7.p.v;
//   Nand.TP1.S.i + (Nand.TP2.S.i + (Nand.TN1.D.i + (Nand.C4.p.i + (-Nand.y.i)))) = 0.0;
// Nand.TP1.S.v = Nand.TP2.S.v;
// Nand.TP2.S.v = Nand.TN1.D.v;
// Nand.TN1.D.v = Nand.C4.p.v;
// Nand.C4.p.v = Nand.y.v;
//   Nand.C4.n.i + Nand.Gnd2.p.i = 0.0;
// Nand.C4.n.v = Nand.Gnd2.p.v;
//   Nand.TN2.B.i + (Nand.TN2.S.i + Nand.Gnd.p.i) = 0.0;
// Nand.TN2.B.v = Nand.TN2.S.v;
// Nand.TN2.S.v = Nand.Gnd.p.v;
//   Nand.TP1.G.i + (Nand.TN1.G.i + (-Nand.x2.i)) = 0.0;
// Nand.TP1.G.v = Nand.TN1.G.v;
// Nand.TN1.G.v = Nand.x2.v;
//   Nand.TP2.B.i + Nand.Gnd6.p.i = 0.0;
// Nand.TP2.B.v = Nand.Gnd6.p.v;
//   Nand.TN1.B.i + Nand.Gnd7.p.i = 0.0;
// Nand.TN1.B.v = Nand.Gnd7.p.v;
//   Nand.TP1.B.i + Nand.Gnd8.p.i = 0.0;
// Nand.TP1.B.v = Nand.Gnd8.p.v;
//   Nand.TP2.G.i + (Nand.TN2.G.i + (-Nand.x1.i)) = 0.0;
// Nand.TP2.G.v = Nand.TN2.G.v;
// Nand.TN2.G.v = Nand.x1.v;
//   Nand.TP2.D.i + ((-Nand.Vdd.i) + Nand.TP1.D.i) = 0.0;
// Nand.TP2.D.v = Nand.Vdd.v;
// Nand.Vdd.v = Nand.TP1.D.v;
//   when pre(VIN1.signalSource.counter2) <> 0 AND sample(VIN1.signalSource.startTime,VIN1.signalSource.period) then
//   VIN1.signalSource.T0 = time;
//   VIN1.signalSource.counter2 = pre(VIN1.signalSource.counter);
//   VIN1.signalSource.counter = pre(VIN1.signalSource.counter) - (if pre(VIN1.signalSource.counter) > 0 then 1 else 0);
//   end when;
//   VIN1.signalSource.y = VIN1.signalSource.offset + (if time < VIN1.signalSource.startTime OR VIN1.signalSource.counter2 == 0 OR time >= VIN1.signalSource.T0 + VIN1.signalSource.T_falling then 0.0 else if time < VIN1.signalSource.T0 + VIN1.signalSource.T_rising then ((time - VIN1.signalSource.T0) * VIN1.signalSource.amplitude) / VIN1.signalSource.T_rising else if time < VIN1.signalSource.T0 + VIN1.signalSource.T_width then VIN1.signalSource.amplitude else ((VIN1.signalSource.T0 + VIN1.signalSource.T_falling - time) * VIN1.signalSource.amplitude) / (VIN1.signalSource.T_falling - VIN1.signalSource.T_width));
//   VIN1.v = VIN1.signalSource.y;
//   VIN1.v = VIN1.p.v - VIN1.n.v;
//   0.0 = VIN1.p.i + VIN1.n.i;
//   VIN1.i = VIN1.p.i;
//   when pre(VIN2.signalSource.counter2) <> 0 AND sample(VIN2.signalSource.startTime,VIN2.signalSource.period) then
//   VIN2.signalSource.T0 = time;
//   VIN2.signalSource.counter2 = pre(VIN2.signalSource.counter);
//   VIN2.signalSource.counter = pre(VIN2.signalSource.counter) - (if pre(VIN2.signalSource.counter) > 0 then 1 else 0);
//   end when;
//   VIN2.signalSource.y = VIN2.signalSource.offset + (if time < VIN2.signalSource.startTime OR VIN2.signalSource.counter2 == 0 OR time >= VIN2.signalSource.T0 + VIN2.signalSource.T_falling then 0.0 else if time < VIN2.signalSource.T0 + VIN2.signalSource.T_rising then ((time - VIN2.signalSource.T0) * VIN2.signalSource.amplitude) / VIN2.signalSource.T_rising else if time < VIN2.signalSource.T0 + VIN2.signalSource.T_width then VIN2.signalSource.amplitude else ((VIN2.signalSource.T0 + VIN2.signalSource.T_falling - time) * VIN2.signalSource.amplitude) / (VIN2.signalSource.T_falling - VIN2.signalSource.T_width));
//   VIN2.v = VIN2.signalSource.y;
//   VIN2.v = VIN2.p.v - VIN2.n.v;
//   0.0 = VIN2.p.i + VIN2.n.i;
//   VIN2.i = VIN2.p.i;
//   VDD.signalSource.y = VDD.signalSource.offset + (if time < VDD.signalSource.startTime then 0.0 else if time < VDD.signalSource.startTime + VDD.signalSource.duration then ((time - VDD.signalSource.startTime) * VDD.signalSource.height) / VDD.signalSource.duration else VDD.signalSource.height);
//   VDD.v = VDD.signalSource.y;
//   VDD.v = VDD.p.v - VDD.n.v;
//   0.0 = VDD.p.i + VDD.n.i;
//   VDD.i = VDD.p.i;
//   Nand.Vdd.i + VDD.p.i = 0.0;
// Nand.Vdd.v = VDD.p.v;
//   VDD.n.i + Gnd1.p.i = 0.0;
// VDD.n.v = Gnd1.p.v;
//   VIN2.p.i + Nand.x2.i = 0.0;
// VIN2.p.v = Nand.x2.v;
//   VIN2.n.i + Gnd5.p.i = 0.0;
// VIN2.n.v = Gnd5.p.v;
//   VIN1.p.i + Nand.x1.i = 0.0;
// VIN1.p.v = Nand.x1.v;
//   VIN1.n.i + Gnd4.p.i = 0.0;
// VIN1.n.v = Gnd4.p.v;
//   Nand.y.i = 0.0;
// end Modelica.Electrical.Analog.Examples.NandGate;
// "
// ""
// endResult
